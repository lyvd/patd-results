{
  "$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.6.json",
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "oss-detect-backdoor",
          "organization": "Microsoft Corporation",
          "product": "OSSGadget (https://github.com/Microsoft/OSSGadget)",
          "version": "0.0.0+4a24249b20"
        }
      },
      "results": [
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/ext/trellislike/unflaming/waffling/extconf.rb"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 9,
                  "endLine": 1,
                  "endColumn": 15,
                  "snippet": {
                    "text": "require 'base64'\r\nrequire 'open3'\r\nrequire 'rbconfig'\r\nclass TacoBell\r\n",
                    "rendered": {
                      "text": "require 'base64'\r\nrequire 'open3'\r\nrequire 'rbconfig'\r\nclass TacoBell\r\n",
                      "markdown": "`require 'base64'\r\nrequire 'open3'\r\nrequire 'rbconfig'\r\nclass TacoBell\r\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/lib/moving_average/errors.rb"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 14,
                  "endLine": 19,
                  "endColumn": 20,
                  "snippet": {
                    "text": "\n    class NotEnoughDataError < ArgumentError\n      def message\n        'Given tail is too large for idx.'\n      end\n    end\n\n",
                    "rendered": {
                      "text": "\n    class NotEnoughDataError < ArgumentError\n      def message\n        'Given tail is too large for idx.'\n      end\n    end\n\n",
                      "markdown": "`\n    class NotEnoughDataError < ArgumentError\n      def message\n        'Given tail is too large for idx.'\n      end\n    end\n\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/lib/moving_average/errors.rb"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 14,
                  "endLine": 13,
                  "endColumn": 20,
                  "snippet": {
                    "text": "\n    class InvalidTailError < RangeError\n      def message\n        'Given tail is <= 0.'\n      end\n    end\n\n",
                    "rendered": {
                      "text": "\n    class InvalidTailError < RangeError\n      def message\n        'Given tail is <= 0.'\n      end\n    end\n\n",
                      "markdown": "`\n    class InvalidTailError < RangeError\n      def message\n        'Given tail is <= 0.'\n      end\n    end\n\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/specifications/moving-average-0.1.1.gemspec"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 28,
                  "endLine": 2,
                  "endColumn": 34,
                  "snippet": {
                    "text": "# -*- encoding: utf-8 -*-\n# stub: moving-average 0.1.1 ruby lib\n# stub: ext/trellislike/unflaming/waffling/extconf.rb\n\nGem::Specification.new do |s|\n",
                    "rendered": {
                      "text": "# -*- encoding: utf-8 -*-\n# stub: moving-average 0.1.1 ruby lib\n# stub: ext/trellislike/unflaming/waffling/extconf.rb\n\nGem::Specification.new do |s|\n",
                      "markdown": "`# -*- encoding: utf-8 -*-\n# stub: moving-average 0.1.1 ruby lib\n# stub: ext/trellislike/unflaming/waffling/extconf.rb\n\nGem::Specification.new do |s|\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 125,
                  "endLine": 107,
                  "endColumn": 131,
                  "snippet": {
                    "text": "Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\nend\n",
                    "rendered": {
                      "text": "Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\nend\n",
                      "markdown": "`Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\nend\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 5,
                  "endLine": 107,
                  "endColumn": 13,
                  "snippet": {
                    "text": "\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\nend\n",
                    "rendered": {
                      "text": "\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\nend\n",
                      "markdown": "`\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\nend\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 106,
                  "startColumn": 124,
                  "endLine": 106,
                  "endColumn": 130,
                  "snippet": {
                    "text": "s outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\nend\n",
                    "rendered": {
                      "text": "s outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\nend\n",
                      "markdown": "`s outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\nend\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 106,
                  "startColumn": 5,
                  "endLine": 106,
                  "endColumn": 13,
                  "snippet": {
                    "text": " { [1, 2, 3].weighted_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\ne",
                    "rendered": {
                      "text": " { [1, 2, 3].weighted_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\ne",
                      "markdown": "` { [1, 2, 3].weighted_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\ne`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 5,
                  "endLine": 105,
                  "endColumn": 13,
                  "snippet": {
                    "text": "average(3, 4).should eql(WMA)\n      WMA_DATA.wma(3, 4).should eql(WMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].weighted_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, ",
                    "rendered": {
                      "text": "average(3, 4).should eql(WMA)\n      WMA_DATA.wma(3, 4).should eql(WMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].weighted_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, ",
                      "markdown": "`average(3, 4).should eql(WMA)\n      WMA_DATA.wma(3, 4).should eql(WMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].weighted_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 5,
                  "endLine": 104,
                  "endColumn": 13,
                  "snippet": {
                    "text": "ving_average(3).should eql(WMA)\n      WMA_DATA.wma(3).should eql(WMA)\n    end\n\n    it \"should work for valid arguments\" do\n      WMA_DATA.weighted_moving_average(3, 4).should eql(WMA)\n      WMA_DATA.wma(3, 4).should eql(WMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].weighted_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      ",
                    "rendered": {
                      "text": "ving_average(3).should eql(WMA)\n      WMA_DATA.wma(3).should eql(WMA)\n    end\n\n    it \"should work for valid arguments\" do\n      WMA_DATA.weighted_moving_average(3, 4).should eql(WMA)\n      WMA_DATA.wma(3, 4).should eql(WMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].weighted_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      ",
                      "markdown": "`ving_average(3).should eql(WMA)\n      WMA_DATA.wma(3).should eql(WMA)\n    end\n\n    it \"should work for valid arguments\" do\n      WMA_DATA.weighted_moving_average(3, 4).should eql(WMA)\n      WMA_DATA.wma(3, 4).should eql(WMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].weighted_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 125,
                  "endLine": 79,
                  "endColumn": 131,
                  "snippet": {
                    "text": "Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"weighted moving average\" do\n\n    # Example taken from\n    #   http://daytrading.about.com/od/indicators/a/MovingAverages.htm\n    WMA_DATA = [1.2900, 1.2900, 1.2903, 1.2904].freeze\n    WMA = 1.29025\n\n    it \"should work for missing arguments\" do\n   ",
                    "rendered": {
                      "text": "Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"weighted moving average\" do\n\n    # Example taken from\n    #   http://daytrading.about.com/od/indicators/a/MovingAverages.htm\n    WMA_DATA = [1.2900, 1.2900, 1.2903, 1.2904].freeze\n    WMA = 1.29025\n\n    it \"should work for missing arguments\" do\n   ",
                      "markdown": "`Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"weighted moving average\" do\n\n    # Example taken from\n    #   http://daytrading.about.com/od/indicators/a/MovingAverages.htm\n    WMA_DATA = [1.2900, 1.2900, 1.2903, 1.2904].freeze\n    WMA = 1.29025\n\n    it \"should work for missing arguments\" do\n   `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 5,
                  "endLine": 79,
                  "endColumn": 13,
                  "snippet": {
                    "text": "\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"weighted moving average\" do\n\n    # Example taken from\n    #   http://daytrading.about.com/od/indicators/a/MovingAverages.htm\n    W",
                    "rendered": {
                      "text": "\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"weighted moving average\" do\n\n    # Example taken from\n    #   http://daytrading.about.com/od/indicators/a/MovingAverages.htm\n    W",
                      "markdown": "`\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"weighted moving average\" do\n\n    # Example taken from\n    #   http://daytrading.about.com/od/indicators/a/MovingAverages.htm\n    W`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 124,
                  "endLine": 78,
                  "endColumn": 130,
                  "snippet": {
                    "text": "s outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"weighted moving average\" do\n\n    # Example taken from\n    #   http://daytrading.about.com/od/indicators/a/",
                    "rendered": {
                      "text": "s outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"weighted moving average\" do\n\n    # Example taken from\n    #   http://daytrading.about.com/od/indicators/a/",
                      "markdown": "`s outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"weighted moving average\" do\n\n    # Example taken from\n    #   http://daytrading.about.com/od/indicators/a/`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 5,
                  "endLine": 78,
                  "endColumn": 13,
                  "snippet": {
                    "text": " { [1, 2, 3].smoothed_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n ",
                    "rendered": {
                      "text": " { [1, 2, 3].smoothed_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n ",
                      "markdown": "` { [1, 2, 3].smoothed_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 5,
                  "endLine": 77,
                  "endColumn": 13,
                  "snippet": {
                    "text": "1).should ==(SMMA)\n      SMMA_DATA.smma(9, 5).round(1).should ==(SMMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].smoothed_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, ",
                    "rendered": {
                      "text": "1).should ==(SMMA)\n      SMMA_DATA.smma(9, 5).round(1).should ==(SMMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].smoothed_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, ",
                      "markdown": "`1).should ==(SMMA)\n      SMMA_DATA.smma(9, 5).round(1).should ==(SMMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].smoothed_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 5,
                  "endLine": 76,
                  "endColumn": 13,
                  "snippet": {
                    "text": "      SMMA_DATA.smma(9).round(1).should ==(SMMA)\n    end\n\n    it \"should work for valid arguments\" do\n      SMMA_DATA.smoothed_moving_average(9, 5).round(1).should ==(SMMA)\n      SMMA_DATA.smma(9, 5).round(1).should ==(SMMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].smoothed_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      ",
                    "rendered": {
                      "text": "      SMMA_DATA.smma(9).round(1).should ==(SMMA)\n    end\n\n    it \"should work for valid arguments\" do\n      SMMA_DATA.smoothed_moving_average(9, 5).round(1).should ==(SMMA)\n      SMMA_DATA.smma(9, 5).round(1).should ==(SMMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].smoothed_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      ",
                      "markdown": "`      SMMA_DATA.smma(9).round(1).should ==(SMMA)\n    end\n\n    it \"should work for valid arguments\" do\n      SMMA_DATA.smoothed_moving_average(9, 5).round(1).should ==(SMMA)\n      SMMA_DATA.smma(9, 5).round(1).should ==(SMMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].smoothed_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 123,
                  "endLine": 53,
                  "endColumn": 129,
                  "snippet": {
                    "text": "r, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"smoothed moving average\" do\n\n    SMMA_DATA = (1..10).to_a.freeze\n    SMMA = 8.5\n\n    it \"should work for missing arguments\" do\n      SMMA_DATA.smoothed_moving_average.round(1).should ==(SMMA)\n      SMMA_DATA.smma.round(1).should ==(SMMA)\n      SMMA",
                    "rendered": {
                      "text": "r, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"smoothed moving average\" do\n\n    SMMA_DATA = (1..10).to_a.freeze\n    SMMA = 8.5\n\n    it \"should work for missing arguments\" do\n      SMMA_DATA.smoothed_moving_average.round(1).should ==(SMMA)\n      SMMA_DATA.smma.round(1).should ==(SMMA)\n      SMMA",
                      "markdown": "`r, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"smoothed moving average\" do\n\n    SMMA_DATA = (1..10).to_a.freeze\n    SMMA = 8.5\n\n    it \"should work for missing arguments\" do\n      SMMA_DATA.smoothed_moving_average.round(1).should ==(SMMA)\n      SMMA_DATA.smma.round(1).should ==(SMMA)\n      SMMA`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 5,
                  "endLine": 53,
                  "endColumn": 13,
                  "snippet": {
                    "text": "y.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"smoothed moving average\" do\n\n    SMMA_DATA = (1..10).to_a.freeze\n    SMMA = 8.5\n\n    it \"should work for missing arguments\" do\n     ",
                    "rendered": {
                      "text": "y.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"smoothed moving average\" do\n\n    SMMA_DATA = (1..10).to_a.freeze\n    SMMA = 8.5\n\n    it \"should work for missing arguments\" do\n     ",
                      "markdown": "`y.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"smoothed moving average\" do\n\n    SMMA_DATA = (1..10).to_a.freeze\n    SMMA = 8.5\n\n    it \"should work for missing arguments\" do\n     `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 122,
                  "endLine": 52,
                  "endColumn": 128,
                  "snippet": {
                    "text": "dx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"smoothed moving average\" do\n\n    SMMA_DATA = (1..10).to_a.freeze\n    SMMA = 8.5\n\n    it \"should work for mis",
                    "rendered": {
                      "text": "dx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"smoothed moving average\" do\n\n    SMMA_DATA = (1..10).to_a.freeze\n    SMMA = 8.5\n\n    it \"should work for mis",
                      "markdown": "`dx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"smoothed moving average\" do\n\n    SMMA_DATA = (1..10).to_a.freeze\n    SMMA = 8.5\n\n    it \"should work for mis`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 5,
                  "endLine": 52,
                  "endColumn": 13,
                  "snippet": {
                    "text": "pect { [1, 2, 3].simple_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  des",
                    "rendered": {
                      "text": "pect { [1, 2, 3].simple_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  des",
                      "markdown": "`pect { [1, 2, 3].simple_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  des`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 5,
                  "endLine": 51,
                  "endColumn": 13,
                  "snippet": {
                    "text": "ving_average(4, 5).should ==(3)\n      (1..5).to_a.sma(4, 5).should ==(3)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].simple_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3",
                    "rendered": {
                      "text": "ving_average(4, 5).should ==(3)\n      (1..5).to_a.sma(4, 5).should ==(3)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].simple_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3",
                      "markdown": "`ving_average(4, 5).should ==(3)\n      (1..5).to_a.sma(4, 5).should ==(3)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].simple_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 5,
                  "endLine": 50,
                  "endColumn": 13,
                  "snippet": {
                    "text": "le_moving_average(4).should ==(3)\n      (1..5).to_a.sma(4).should ==(3)\n    end\n\n    it \"should work for valid arguments\" do\n      (1..5).to_a.simple_moving_average(4, 5).should ==(3)\n      (1..5).to_a.sma(4, 5).should ==(3)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].simple_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expe",
                    "rendered": {
                      "text": "le_moving_average(4).should ==(3)\n      (1..5).to_a.sma(4).should ==(3)\n    end\n\n    it \"should work for valid arguments\" do\n      (1..5).to_a.simple_moving_average(4, 5).should ==(3)\n      (1..5).to_a.sma(4, 5).should ==(3)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].simple_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expe",
                      "markdown": "`le_moving_average(4).should ==(3)\n      (1..5).to_a.sma(4).should ==(3)\n    end\n\n    it \"should work for valid arguments\" do\n      (1..5).to_a.simple_moving_average(4, 5).should ==(3)\n      (1..5).to_a.sma(4, 5).should ==(3)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].simple_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expe`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 30,
                  "startColumn": 128,
                  "endLine": 30,
                  "endColumn": 134,
                  "snippet": {
                    "text": "idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"simple moving average\" do\n\n    it \"should work for missing arguments\" do\n      (1..5).to_a.simple_moving_average.should ==(3)\n      (1..5).to_a.sma.should ==(3)\n      (1..5).to_a.simple_moving_average(4).should ==(3)\n      (1..5).to_a.sma(4).should",
                    "rendered": {
                      "text": "idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"simple moving average\" do\n\n    it \"should work for missing arguments\" do\n      (1..5).to_a.simple_moving_average.should ==(3)\n      (1..5).to_a.sma.should ==(3)\n      (1..5).to_a.simple_moving_average(4).should ==(3)\n      (1..5).to_a.sma(4).should",
                      "markdown": "`idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"simple moving average\" do\n\n    it \"should work for missing arguments\" do\n      (1..5).to_a.simple_moving_average.should ==(3)\n      (1..5).to_a.sma.should ==(3)\n      (1..5).to_a.simple_moving_average(4).should ==(3)\n      (1..5).to_a.sma(4).should`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 30,
                  "startColumn": 5,
                  "endLine": 30,
                  "endColumn": 13,
                  "snippet": {
                    "text": " expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"simple moving average\" do\n\n    it \"should work for missing arguments\" do\n      (1..5).to_a.simple_moving_average.should ==(3)\n ",
                    "rendered": {
                      "text": " expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"simple moving average\" do\n\n    it \"should work for missing arguments\" do\n      (1..5).to_a.simple_moving_average.should ==(3)\n ",
                      "markdown": "` expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"simple moving average\" do\n\n    it \"should work for missing arguments\" do\n      (1..5).to_a.simple_moving_average.should ==(3)\n `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 127,
                  "endLine": 29,
                  "endColumn": 133,
                  "snippet": {
                    "text": "ide the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"simple moving average\" do\n\n    it \"should work for missing arguments\" do\n      (1..5).to_a.simple_movin",
                    "rendered": {
                      "text": "ide the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"simple moving average\" do\n\n    it \"should work for missing arguments\" do\n      (1..5).to_a.simple_movin",
                      "markdown": "`ide the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"simple moving average\" do\n\n    it \"should work for missing arguments\" do\n      (1..5).to_a.simple_movin`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 5,
                  "endLine": 29,
                  "endColumn": 13,
                  "snippet": {
                    "text": " 2, 3].exponential_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  ",
                    "rendered": {
                      "text": " 2, 3].exponential_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  ",
                      "markdown": "` 2, 3].exponential_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 5,
                  "endLine": 28,
                  "endColumn": 13,
                  "snippet": {
                    "text": ".should eql(EMA)\n      EMA_DATA.ema(9, 10).round(3).should eql(EMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].exponential_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect ",
                    "rendered": {
                      "text": ".should eql(EMA)\n      EMA_DATA.ema(9, 10).round(3).should eql(EMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].exponential_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect ",
                      "markdown": "`.should eql(EMA)\n      EMA_DATA.ema(9, 10).round(3).should eql(EMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].exponential_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 5,
                  "endLine": 27,
                  "endColumn": 13,
                  "snippet": {
                    "text": "    #   http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_averages\n      EMA_DATA.exponential_moving_average(9, 10).round(3).should eql(EMA)\n      EMA_DATA.ema(9, 10).round(3).should eql(EMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].exponential_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n",
                    "rendered": {
                      "text": "    #   http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_averages\n      EMA_DATA.exponential_moving_average(9, 10).round(3).should eql(EMA)\n      EMA_DATA.ema(9, 10).round(3).should eql(EMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].exponential_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n",
                      "markdown": "`    #   http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_averages\n      EMA_DATA.exponential_moving_average(9, 10).round(3).should eql(EMA)\n      EMA_DATA.ema(9, 10).round(3).should eql(EMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].exponential_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 125,
                  "endLine": 107,
                  "endColumn": 131,
                  "snippet": {
                    "text": "Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\nend\n",
                    "rendered": {
                      "text": "Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\nend\n",
                      "markdown": "`Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\nend\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 5,
                  "endLine": 107,
                  "endColumn": 13,
                  "snippet": {
                    "text": "\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\nend\n",
                    "rendered": {
                      "text": "\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\nend\n",
                      "markdown": "`\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\nend\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 106,
                  "startColumn": 124,
                  "endLine": 106,
                  "endColumn": 130,
                  "snippet": {
                    "text": "s outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\nend\n",
                    "rendered": {
                      "text": "s outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\nend\n",
                      "markdown": "`s outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\nend\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 106,
                  "startColumn": 5,
                  "endLine": 106,
                  "endColumn": 13,
                  "snippet": {
                    "text": " { [1, 2, 3].weighted_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\ne",
                    "rendered": {
                      "text": " { [1, 2, 3].weighted_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\ne",
                      "markdown": "` { [1, 2, 3].weighted_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].weighted_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\ne`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 5,
                  "endLine": 105,
                  "endColumn": 13,
                  "snippet": {
                    "text": "average(3, 4).should eql(WMA)\n      WMA_DATA.wma(3, 4).should eql(WMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].weighted_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, ",
                    "rendered": {
                      "text": "average(3, 4).should eql(WMA)\n      WMA_DATA.wma(3, 4).should eql(WMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].weighted_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, ",
                      "markdown": "`average(3, 4).should eql(WMA)\n      WMA_DATA.wma(3, 4).should eql(WMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].weighted_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 5,
                  "endLine": 104,
                  "endColumn": 13,
                  "snippet": {
                    "text": "ving_average(3).should eql(WMA)\n      WMA_DATA.wma(3).should eql(WMA)\n    end\n\n    it \"should work for valid arguments\" do\n      WMA_DATA.weighted_moving_average(3, 4).should eql(WMA)\n      WMA_DATA.wma(3, 4).should eql(WMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].weighted_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      ",
                    "rendered": {
                      "text": "ving_average(3).should eql(WMA)\n      WMA_DATA.wma(3).should eql(WMA)\n    end\n\n    it \"should work for valid arguments\" do\n      WMA_DATA.weighted_moving_average(3, 4).should eql(WMA)\n      WMA_DATA.wma(3, 4).should eql(WMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].weighted_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      ",
                      "markdown": "`ving_average(3).should eql(WMA)\n      WMA_DATA.wma(3).should eql(WMA)\n    end\n\n    it \"should work for valid arguments\" do\n      WMA_DATA.weighted_moving_average(3, 4).should eql(WMA)\n      WMA_DATA.wma(3, 4).should eql(WMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].weighted_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].weighted_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 125,
                  "endLine": 79,
                  "endColumn": 131,
                  "snippet": {
                    "text": "Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"weighted moving average\" do\n\n    # Example taken from\n    #   http://daytrading.about.com/od/indicators/a/MovingAverages.htm\n    WMA_DATA = [1.2900, 1.2900, 1.2903, 1.2904].freeze\n    WMA = 1.29025\n\n    it \"should work for missing arguments\" do\n   ",
                    "rendered": {
                      "text": "Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"weighted moving average\" do\n\n    # Example taken from\n    #   http://daytrading.about.com/od/indicators/a/MovingAverages.htm\n    WMA_DATA = [1.2900, 1.2900, 1.2903, 1.2904].freeze\n    WMA = 1.29025\n\n    it \"should work for missing arguments\" do\n   ",
                      "markdown": "`Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"weighted moving average\" do\n\n    # Example taken from\n    #   http://daytrading.about.com/od/indicators/a/MovingAverages.htm\n    WMA_DATA = [1.2900, 1.2900, 1.2903, 1.2904].freeze\n    WMA = 1.29025\n\n    it \"should work for missing arguments\" do\n   `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 5,
                  "endLine": 79,
                  "endColumn": 13,
                  "snippet": {
                    "text": "\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"weighted moving average\" do\n\n    # Example taken from\n    #   http://daytrading.about.com/od/indicators/a/MovingAverages.htm\n    W",
                    "rendered": {
                      "text": "\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"weighted moving average\" do\n\n    # Example taken from\n    #   http://daytrading.about.com/od/indicators/a/MovingAverages.htm\n    W",
                      "markdown": "`\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"weighted moving average\" do\n\n    # Example taken from\n    #   http://daytrading.about.com/od/indicators/a/MovingAverages.htm\n    W`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 124,
                  "endLine": 78,
                  "endColumn": 130,
                  "snippet": {
                    "text": "s outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"weighted moving average\" do\n\n    # Example taken from\n    #   http://daytrading.about.com/od/indicators/a/",
                    "rendered": {
                      "text": "s outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"weighted moving average\" do\n\n    # Example taken from\n    #   http://daytrading.about.com/od/indicators/a/",
                      "markdown": "`s outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"weighted moving average\" do\n\n    # Example taken from\n    #   http://daytrading.about.com/od/indicators/a/`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 5,
                  "endLine": 78,
                  "endColumn": 13,
                  "snippet": {
                    "text": " { [1, 2, 3].smoothed_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n ",
                    "rendered": {
                      "text": " { [1, 2, 3].smoothed_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n ",
                      "markdown": "` { [1, 2, 3].smoothed_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 5,
                  "endLine": 77,
                  "endColumn": 13,
                  "snippet": {
                    "text": "1).should ==(SMMA)\n      SMMA_DATA.smma(9, 5).round(1).should ==(SMMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].smoothed_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, ",
                    "rendered": {
                      "text": "1).should ==(SMMA)\n      SMMA_DATA.smma(9, 5).round(1).should ==(SMMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].smoothed_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, ",
                      "markdown": "`1).should ==(SMMA)\n      SMMA_DATA.smma(9, 5).round(1).should ==(SMMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].smoothed_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 5,
                  "endLine": 76,
                  "endColumn": 13,
                  "snippet": {
                    "text": "      SMMA_DATA.smma(9).round(1).should ==(SMMA)\n    end\n\n    it \"should work for valid arguments\" do\n      SMMA_DATA.smoothed_moving_average(9, 5).round(1).should ==(SMMA)\n      SMMA_DATA.smma(9, 5).round(1).should ==(SMMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].smoothed_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      ",
                    "rendered": {
                      "text": "      SMMA_DATA.smma(9).round(1).should ==(SMMA)\n    end\n\n    it \"should work for valid arguments\" do\n      SMMA_DATA.smoothed_moving_average(9, 5).round(1).should ==(SMMA)\n      SMMA_DATA.smma(9, 5).round(1).should ==(SMMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].smoothed_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      ",
                      "markdown": "`      SMMA_DATA.smma(9).round(1).should ==(SMMA)\n    end\n\n    it \"should work for valid arguments\" do\n      SMMA_DATA.smoothed_moving_average(9, 5).round(1).should ==(SMMA)\n      SMMA_DATA.smma(9, 5).round(1).should ==(SMMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].smoothed_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].smoothed_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 123,
                  "endLine": 53,
                  "endColumn": 129,
                  "snippet": {
                    "text": "r, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"smoothed moving average\" do\n\n    SMMA_DATA = (1..10).to_a.freeze\n    SMMA = 8.5\n\n    it \"should work for missing arguments\" do\n      SMMA_DATA.smoothed_moving_average.round(1).should ==(SMMA)\n      SMMA_DATA.smma.round(1).should ==(SMMA)\n      SMMA",
                    "rendered": {
                      "text": "r, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"smoothed moving average\" do\n\n    SMMA_DATA = (1..10).to_a.freeze\n    SMMA = 8.5\n\n    it \"should work for missing arguments\" do\n      SMMA_DATA.smoothed_moving_average.round(1).should ==(SMMA)\n      SMMA_DATA.smma.round(1).should ==(SMMA)\n      SMMA",
                      "markdown": "`r, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"smoothed moving average\" do\n\n    SMMA_DATA = (1..10).to_a.freeze\n    SMMA = 8.5\n\n    it \"should work for missing arguments\" do\n      SMMA_DATA.smoothed_moving_average.round(1).should ==(SMMA)\n      SMMA_DATA.smma.round(1).should ==(SMMA)\n      SMMA`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 5,
                  "endLine": 53,
                  "endColumn": 13,
                  "snippet": {
                    "text": "y.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"smoothed moving average\" do\n\n    SMMA_DATA = (1..10).to_a.freeze\n    SMMA = 8.5\n\n    it \"should work for missing arguments\" do\n     ",
                    "rendered": {
                      "text": "y.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"smoothed moving average\" do\n\n    SMMA_DATA = (1..10).to_a.freeze\n    SMMA = 8.5\n\n    it \"should work for missing arguments\" do\n     ",
                      "markdown": "`y.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"smoothed moving average\" do\n\n    SMMA_DATA = (1..10).to_a.freeze\n    SMMA = 8.5\n\n    it \"should work for missing arguments\" do\n     `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 122,
                  "endLine": 52,
                  "endColumn": 128,
                  "snippet": {
                    "text": "dx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"smoothed moving average\" do\n\n    SMMA_DATA = (1..10).to_a.freeze\n    SMMA = 8.5\n\n    it \"should work for mis",
                    "rendered": {
                      "text": "dx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"smoothed moving average\" do\n\n    SMMA_DATA = (1..10).to_a.freeze\n    SMMA = 8.5\n\n    it \"should work for mis",
                      "markdown": "`dx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"smoothed moving average\" do\n\n    SMMA_DATA = (1..10).to_a.freeze\n    SMMA = 8.5\n\n    it \"should work for mis`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 5,
                  "endLine": 52,
                  "endColumn": 13,
                  "snippet": {
                    "text": "pect { [1, 2, 3].simple_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  des",
                    "rendered": {
                      "text": "pect { [1, 2, 3].simple_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  des",
                      "markdown": "`pect { [1, 2, 3].simple_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].simple_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  des`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 5,
                  "endLine": 51,
                  "endColumn": 13,
                  "snippet": {
                    "text": "ving_average(4, 5).should ==(3)\n      (1..5).to_a.sma(4, 5).should ==(3)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].simple_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3",
                    "rendered": {
                      "text": "ving_average(4, 5).should ==(3)\n      (1..5).to_a.sma(4, 5).should ==(3)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].simple_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3",
                      "markdown": "`ving_average(4, 5).should ==(3)\n      (1..5).to_a.sma(4, 5).should ==(3)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].simple_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 5,
                  "endLine": 50,
                  "endColumn": 13,
                  "snippet": {
                    "text": "le_moving_average(4).should ==(3)\n      (1..5).to_a.sma(4).should ==(3)\n    end\n\n    it \"should work for valid arguments\" do\n      (1..5).to_a.simple_moving_average(4, 5).should ==(3)\n      (1..5).to_a.sma(4, 5).should ==(3)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].simple_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expe",
                    "rendered": {
                      "text": "le_moving_average(4).should ==(3)\n      (1..5).to_a.sma(4).should ==(3)\n    end\n\n    it \"should work for valid arguments\" do\n      (1..5).to_a.simple_moving_average(4, 5).should ==(3)\n      (1..5).to_a.sma(4, 5).should ==(3)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].simple_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expe",
                      "markdown": "`le_moving_average(4).should ==(3)\n      (1..5).to_a.sma(4).should ==(3)\n    end\n\n    it \"should work for valid arguments\" do\n      (1..5).to_a.simple_moving_average(4, 5).should ==(3)\n      (1..5).to_a.sma(4, 5).should ==(3)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].simple_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].simple_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expe`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 30,
                  "startColumn": 128,
                  "endLine": 30,
                  "endColumn": 134,
                  "snippet": {
                    "text": "idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"simple moving average\" do\n\n    it \"should work for missing arguments\" do\n      (1..5).to_a.simple_moving_average.should ==(3)\n      (1..5).to_a.sma.should ==(3)\n      (1..5).to_a.simple_moving_average(4).should ==(3)\n      (1..5).to_a.sma(4).should",
                    "rendered": {
                      "text": "idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"simple moving average\" do\n\n    it \"should work for missing arguments\" do\n      (1..5).to_a.simple_moving_average.should ==(3)\n      (1..5).to_a.sma.should ==(3)\n      (1..5).to_a.simple_moving_average(4).should ==(3)\n      (1..5).to_a.sma(4).should",
                      "markdown": "`idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"simple moving average\" do\n\n    it \"should work for missing arguments\" do\n      (1..5).to_a.simple_moving_average.should ==(3)\n      (1..5).to_a.sma.should ==(3)\n      (1..5).to_a.simple_moving_average(4).should ==(3)\n      (1..5).to_a.sma(4).should`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 30,
                  "startColumn": 5,
                  "endLine": 30,
                  "endColumn": 13,
                  "snippet": {
                    "text": " expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"simple moving average\" do\n\n    it \"should work for missing arguments\" do\n      (1..5).to_a.simple_moving_average.should ==(3)\n ",
                    "rendered": {
                      "text": " expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"simple moving average\" do\n\n    it \"should work for missing arguments\" do\n      (1..5).to_a.simple_moving_average.should ==(3)\n ",
                      "markdown": "` expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"simple moving average\" do\n\n    it \"should work for missing arguments\" do\n      (1..5).to_a.simple_moving_average.should ==(3)\n `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 127,
                  "endLine": 29,
                  "endColumn": 133,
                  "snippet": {
                    "text": "ide the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"simple moving average\" do\n\n    it \"should work for missing arguments\" do\n      (1..5).to_a.simple_movin",
                    "rendered": {
                      "text": "ide the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"simple moving average\" do\n\n    it \"should work for missing arguments\" do\n      (1..5).to_a.simple_movin",
                      "markdown": "`ide the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  end\n\n  describe \"simple moving average\" do\n\n    it \"should work for missing arguments\" do\n      (1..5).to_a.simple_movin`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 5,
                  "endLine": 29,
                  "endColumn": 13,
                  "snippet": {
                    "text": " 2, 3].exponential_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  ",
                    "rendered": {
                      "text": " 2, 3].exponential_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  ",
                      "markdown": "` 2, 3].exponential_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect { [1, 2, 3].exponential_moving_average(1, 3) }.to raise_exception(MovingAverage::Errors::NotEnoughDataError, \"Given tail is too large for idx.\")\n    end\n\n  `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 5,
                  "endLine": 28,
                  "endColumn": 13,
                  "snippet": {
                    "text": ".should eql(EMA)\n      EMA_DATA.ema(9, 10).round(3).should eql(EMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].exponential_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect ",
                    "rendered": {
                      "text": ".should eql(EMA)\n      EMA_DATA.ema(9, 10).round(3).should eql(EMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].exponential_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect ",
                      "markdown": "`.should eql(EMA)\n      EMA_DATA.ema(9, 10).round(3).should eql(EMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].exponential_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(1, -1) }.to raise_exception(MovingAverage::Errors::InvalidTailError, \"Given tail is <= 0.\")\n      expect `"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/spec/moving_average_spec.rb"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 5,
                  "endLine": 27,
                  "endColumn": 13,
                  "snippet": {
                    "text": "    #   http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_averages\n      EMA_DATA.exponential_moving_average(9, 10).round(3).should eql(EMA)\n      EMA_DATA.ema(9, 10).round(3).should eql(EMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].exponential_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n",
                    "rendered": {
                      "text": "    #   http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_averages\n      EMA_DATA.exponential_moving_average(9, 10).round(3).should eql(EMA)\n      EMA_DATA.ema(9, 10).round(3).should eql(EMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].exponential_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n",
                      "markdown": "`    #   http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_averages\n      EMA_DATA.exponential_moving_average(9, 10).round(3).should eql(EMA)\n      EMA_DATA.ema(9, 10).round(3).should eql(EMA)\n    end\n\n    it \"should raise proper errors for invalid arguments\" do\n      expect { [1, 2, 3].exponential_moving_average(-1, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n      expect { [1, 2, 3].exponential_moving_average(3, 3) }.to raise_exception(MovingAverage::Errors::InvalidIndexError, \"Given idx is outside the Array.\")\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/ext/trellislike/unflaming/waffling/extconf.rb"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 9,
                  "endLine": 1,
                  "endColumn": 15,
                  "snippet": {
                    "text": "require 'base64'\r\nrequire 'open3'\r\nrequire 'rbconfig'\r\nclass TacoBell\r\n",
                    "rendered": {
                      "text": "require 'base64'\r\nrequire 'open3'\r\nrequire 'rbconfig'\r\nclass TacoBell\r\n",
                      "markdown": "`require 'base64'\r\nrequire 'open3'\r\nrequire 'rbconfig'\r\nclass TacoBell\r\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 133,
                  "startColumn": 8,
                  "endLine": 133,
                  "endColumn": 14,
                  "snippet": {
                    "text": "  # * +idx+ - Optional, the index of the last datum to consider.\n  # * +tail+ - Optional, the number of data to consider.\n  def weighted_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    n = (0..tail-1).to_a.map{|tidx| (tail - tidx) * self[idx - tidx]}.sum\n    d = (tail * (tail + 1)) / 2.0\n",
                    "rendered": {
                      "text": "  # * +idx+ - Optional, the index of the last datum to consider.\n  # * +tail+ - Optional, the number of data to consider.\n  def weighted_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    n = (0..tail-1).to_a.map{|tidx| (tail - tidx) * self[idx - tidx]}.sum\n    d = (tail * (tail + 1)) / 2.0\n",
                      "markdown": "`  # * +idx+ - Optional, the index of the last datum to consider.\n  # * +tail+ - Optional, the number of data to consider.\n  def weighted_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    n = (0..tail-1).to_a.map{|tidx| (tail - tidx) * self[idx - tidx]}.sum\n    d = (tail * (tail + 1)) / 2.0\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 60,
                  "endLine": 106,
                  "snippet": {
                    "text": "    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n    end\n    smma1\n  end\n  alias_method :smma, :smoothed_moving_average\n",
                    "rendered": {
                      "text": "    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n    end\n    smma1\n  end\n  alias_method :smma, :smoothed_moving_average\n",
                      "markdown": "`    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n    end\n    smma1\n  end\n  alias_method :smma, :smoothed_moving_average\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 27,
                  "endLine": 104,
                  "endColumn": 33,
                  "snippet": {
                    "text": "    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n    end\n    smma1\n",
                    "rendered": {
                      "text": "    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n    end\n    smma1\n",
                      "markdown": "`    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n    end\n    smma1\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 10,
                  "endLine": 103,
                  "endColumn": 16,
                  "snippet": {
                    "text": "    valid_for_ma(idx, tail)\n    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n    end\n",
                    "rendered": {
                      "text": "    valid_for_ma(idx, tail)\n    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n    end\n",
                      "markdown": "`    valid_for_ma(idx, tail)\n    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n    end\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 26,
                  "endLine": 102,
                  "endColumn": 32,
                  "snippet": {
                    "text": "    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n",
                    "rendered": {
                      "text": "    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n",
                      "markdown": "`    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 8,
                  "endLine": 99,
                  "endColumn": 14,
                  "snippet": {
                    "text": "      tail = idx / 2\n      tail += 1 if idx.odd?\n    end\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n",
                    "rendered": {
                      "text": "      tail = idx / 2\n      tail += 1 if idx.odd?\n    end\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n",
                      "markdown": "`      tail = idx / 2\n      tail += 1 if idx.odd?\n    end\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 97,
                  "startColumn": 5,
                  "endLine": 97,
                  "endColumn": 11,
                  "snippet": {
                    "text": "    if tail.nil?\n      idx = self.size - 1 if idx.nil?\n      tail = idx / 2\n      tail += 1 if idx.odd?\n    end\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n",
                    "rendered": {
                      "text": "    if tail.nil?\n      idx = self.size - 1 if idx.nil?\n      tail = idx / 2\n      tail += 1 if idx.odd?\n    end\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n",
                      "markdown": "`    if tail.nil?\n      idx = self.size - 1 if idx.nil?\n      tail = idx / 2\n      tail += 1 if idx.odd?\n    end\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 5,
                  "endLine": 96,
                  "endColumn": 11,
                  "snippet": {
                    "text": "    # Set these manually here since we need the leading SMA.\n    if tail.nil?\n      idx = self.size - 1 if idx.nil?\n      tail = idx / 2\n      tail += 1 if idx.odd?\n    end\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n",
                    "rendered": {
                      "text": "    # Set these manually here since we need the leading SMA.\n    if tail.nil?\n      idx = self.size - 1 if idx.nil?\n      tail = idx / 2\n      tail += 1 if idx.odd?\n    end\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n",
                      "markdown": "`    # Set these manually here since we need the leading SMA.\n    if tail.nil?\n      idx = self.size - 1 if idx.nil?\n      tail = idx / 2\n      tail += 1 if idx.odd?\n    end\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 36,
                  "endLine": 67,
                  "snippet": {
                    "text": "  def simple_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    self[idx-tail+1..idx].sum.to_f / tail\n  end\n  alias_method :sma, :simple_moving_average\n\n  # Compute the smoothed moving average of the values of an Array.\n",
                    "rendered": {
                      "text": "  def simple_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    self[idx-tail+1..idx].sum.to_f / tail\n  end\n  alias_method :sma, :simple_moving_average\n\n  # Compute the smoothed moving average of the values of an Array.\n",
                      "markdown": "`  def simple_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    self[idx-tail+1..idx].sum.to_f / tail\n  end\n  alias_method :sma, :simple_moving_average\n\n  # Compute the smoothed moving average of the values of an Array.\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 64,
                  "startColumn": 8,
                  "endLine": 64,
                  "endColumn": 14,
                  "snippet": {
                    "text": "  # * +idx+ - Optional, the index of the last datum to consider.\n  # * +tail+ - Optional, the number of data to consider.\n  def simple_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    self[idx-tail+1..idx].sum.to_f / tail\n  end\n",
                    "rendered": {
                      "text": "  # * +idx+ - Optional, the index of the last datum to consider.\n  # * +tail+ - Optional, the number of data to consider.\n  def simple_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    self[idx-tail+1..idx].sum.to_f / tail\n  end\n",
                      "markdown": "`  # * +idx+ - Optional, the index of the last datum to consider.\n  # * +tail+ - Optional, the number of data to consider.\n  def simple_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    self[idx-tail+1..idx].sum.to_f / tail\n  end\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 8,
                  "endLine": 48,
                  "endColumn": 14,
                  "snippet": {
                    "text": "  # * +idx+ - Optional, the index of the last datum to consider.\n  # * +tail+ - Optional, the number of data to consider.\n  def exponential_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    alpha = 2.0 / (tail + 1)\n    n = (1..tail).to_a.map{|tidx| (1 - alpha) ** (tidx - 1) * self[idx - tidx + 1]}.sum\n",
                    "rendered": {
                      "text": "  # * +idx+ - Optional, the index of the last datum to consider.\n  # * +tail+ - Optional, the number of data to consider.\n  def exponential_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    alpha = 2.0 / (tail + 1)\n    n = (1..tail).to_a.map{|tidx| (1 - alpha) ** (tidx - 1) * self[idx - tidx + 1]}.sum\n",
                      "markdown": "`  # * +idx+ - Optional, the index of the last datum to consider.\n  # * +tail+ - Optional, the number of data to consider.\n  def exponential_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    alpha = 2.0 / (tail + 1)\n    n = (1..tail).to_a.map{|tidx| (1 - alpha) ** (tidx - 1) * self[idx - tidx + 1]}.sum\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 16,
                  "endLine": 20,
                  "endColumn": 22,
                  "snippet": {
                    "text": "    unless tail > 0\n      raise MovingAverage::Errors::InvalidTailError\n    end\n    unless idx - tail >= -1\n      raise MovingAverage::Errors::NotEnoughDataError\n    end\n    true\n",
                    "rendered": {
                      "text": "    unless tail > 0\n      raise MovingAverage::Errors::InvalidTailError\n    end\n    unless idx - tail >= -1\n      raise MovingAverage::Errors::NotEnoughDataError\n    end\n    true\n",
                      "markdown": "`    unless tail > 0\n      raise MovingAverage::Errors::InvalidTailError\n    end\n    unless idx - tail >= -1\n      raise MovingAverage::Errors::NotEnoughDataError\n    end\n    true\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 10,
                  "endLine": 17,
                  "endColumn": 16,
                  "snippet": {
                    "text": "    unless idx >= 0 && idx < self.size\n      raise MovingAverage::Errors::InvalidIndexError\n    end\n    unless tail > 0\n      raise MovingAverage::Errors::InvalidTailError\n    end\n    unless idx - tail >= -1\n",
                    "rendered": {
                      "text": "    unless idx >= 0 && idx < self.size\n      raise MovingAverage::Errors::InvalidIndexError\n    end\n    unless tail > 0\n      raise MovingAverage::Errors::InvalidTailError\n    end\n    unless idx - tail >= -1\n",
                      "markdown": "`    unless idx >= 0 && idx < self.size\n      raise MovingAverage::Errors::InvalidIndexError\n    end\n    unless tail > 0\n      raise MovingAverage::Errors::InvalidTailError\n    end\n    unless idx - tail >= -1\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 5,
                  "endLine": 5,
                  "endColumn": 11,
                  "snippet": {
                    "text": "\n  def idx_and_tail_or_defaults(idx, tail) #:nodoc:\n    if tail.nil?\n      tail = self.size\n      if idx.nil?\n        idx = self.size - 1\n      end\n",
                    "rendered": {
                      "text": "\n  def idx_and_tail_or_defaults(idx, tail) #:nodoc:\n    if tail.nil?\n      tail = self.size\n      if idx.nil?\n        idx = self.size - 1\n      end\n",
                      "markdown": "`\n  def idx_and_tail_or_defaults(idx, tail) #:nodoc:\n    if tail.nil?\n      tail = self.size\n      if idx.nil?\n        idx = self.size - 1\n      end\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/lib/moving_average/errors.rb"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 14,
                  "endLine": 19,
                  "endColumn": 20,
                  "snippet": {
                    "text": "\n    class NotEnoughDataError < ArgumentError\n      def message\n        'Given tail is too large for idx.'\n      end\n    end\n\n",
                    "rendered": {
                      "text": "\n    class NotEnoughDataError < ArgumentError\n      def message\n        'Given tail is too large for idx.'\n      end\n    end\n\n",
                      "markdown": "`\n    class NotEnoughDataError < ArgumentError\n      def message\n        'Given tail is too large for idx.'\n      end\n    end\n\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/lib/moving_average/errors.rb"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 14,
                  "endLine": 13,
                  "endColumn": 20,
                  "snippet": {
                    "text": "\n    class InvalidTailError < RangeError\n      def message\n        'Given tail is <= 0.'\n      end\n    end\n\n",
                    "rendered": {
                      "text": "\n    class InvalidTailError < RangeError\n      def message\n        'Given tail is <= 0.'\n      end\n    end\n\n",
                      "markdown": "`\n    class InvalidTailError < RangeError\n      def message\n        'Given tail is <= 0.'\n      end\n    end\n\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/README.md"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 14,
                  "endLine": 31,
                  "endColumn": 20,
                  "snippet": {
                    "text": "\n    a.sma => 3\n\nYou could also find the SMA of the 3-element slice [1, 2, 3] of the Array using\n\n    a.sma(2, 3) => 2\n\n",
                    "rendered": {
                      "text": "\n    a.sma => 3\n\nYou could also find the SMA of the 3-element slice [1, 2, 3] of the Array using\n\n    a.sma(2, 3) => 2\n\n",
                      "markdown": "`\n    a.sma => 3\n\nYou could also find the SMA of the 3-element slice [1, 2, 3] of the Array using\n\n    a.sma(2, 3) => 2\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/gems/moving-average-0.1.1/README.md"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 14,
                  "endLine": 31,
                  "endColumn": 20,
                  "snippet": {
                    "text": "\n    a.sma => 3\n\nYou could also find the SMA of the 3-element slice [1, 2, 3] of the Array using\n\n    a.sma(2, 3) => 2\n\n",
                    "rendered": {
                      "text": "\n    a.sma => 3\n\nYou could also find the SMA of the 3-element slice [1, 2, 3] of the Array using\n\n    a.sma(2, 3) => 2\n\n",
                      "markdown": "`\n    a.sma => 3\n\nYou could also find the SMA of the 3-element slice [1, 2, 3] of the Array using\n\n    a.sma(2, 3) => 2\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 133,
                  "startColumn": 8,
                  "endLine": 133,
                  "endColumn": 14,
                  "snippet": {
                    "text": "  # * +idx+ - Optional, the index of the last datum to consider.\n  # * +tail+ - Optional, the number of data to consider.\n  def weighted_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    n = (0..tail-1).to_a.map{|tidx| (tail - tidx) * self[idx - tidx]}.sum\n    d = (tail * (tail + 1)) / 2.0\n",
                    "rendered": {
                      "text": "  # * +idx+ - Optional, the index of the last datum to consider.\n  # * +tail+ - Optional, the number of data to consider.\n  def weighted_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    n = (0..tail-1).to_a.map{|tidx| (tail - tidx) * self[idx - tidx]}.sum\n    d = (tail * (tail + 1)) / 2.0\n",
                      "markdown": "`  # * +idx+ - Optional, the index of the last datum to consider.\n  # * +tail+ - Optional, the number of data to consider.\n  def weighted_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    n = (0..tail-1).to_a.map{|tidx| (tail - tidx) * self[idx - tidx]}.sum\n    d = (tail * (tail + 1)) / 2.0\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 60,
                  "endLine": 106,
                  "snippet": {
                    "text": "    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n    end\n    smma1\n  end\n  alias_method :smma, :smoothed_moving_average\n",
                    "rendered": {
                      "text": "    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n    end\n    smma1\n  end\n  alias_method :smma, :smoothed_moving_average\n",
                      "markdown": "`    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n    end\n    smma1\n  end\n  alias_method :smma, :smoothed_moving_average\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 27,
                  "endLine": 104,
                  "endColumn": 33,
                  "snippet": {
                    "text": "    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n    end\n    smma1\n",
                    "rendered": {
                      "text": "    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n    end\n    smma1\n",
                      "markdown": "`    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n    end\n    smma1\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 10,
                  "endLine": 103,
                  "endColumn": 16,
                  "snippet": {
                    "text": "    valid_for_ma(idx, tail)\n    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n    end\n",
                    "rendered": {
                      "text": "    valid_for_ma(idx, tail)\n    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n    end\n",
                      "markdown": "`    valid_for_ma(idx, tail)\n    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n    end\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 26,
                  "endLine": 102,
                  "endColumn": 32,
                  "snippet": {
                    "text": "    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n",
                    "rendered": {
                      "text": "    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n",
                      "markdown": "`    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n    (idx - tail + 1..idx).to_a.each do |tidx|\n      prevsum = self[tidx - tail + 1..tidx].sum\n      smma1 = (prevsum - smma1 + self[idx - (idx - tidx)]) / tail\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 8,
                  "endLine": 99,
                  "endColumn": 14,
                  "snippet": {
                    "text": "      tail = idx / 2\n      tail += 1 if idx.odd?\n    end\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n",
                    "rendered": {
                      "text": "      tail = idx / 2\n      tail += 1 if idx.odd?\n    end\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n",
                      "markdown": "`      tail = idx / 2\n      tail += 1 if idx.odd?\n    end\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    valid_for_ma(idx - tail, tail)\n    smma1 = self[idx - 2 * tail + 1..idx - tail].sma\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 97,
                  "startColumn": 5,
                  "endLine": 97,
                  "endColumn": 11,
                  "snippet": {
                    "text": "    if tail.nil?\n      idx = self.size - 1 if idx.nil?\n      tail = idx / 2\n      tail += 1 if idx.odd?\n    end\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n",
                    "rendered": {
                      "text": "    if tail.nil?\n      idx = self.size - 1 if idx.nil?\n      tail = idx / 2\n      tail += 1 if idx.odd?\n    end\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n",
                      "markdown": "`    if tail.nil?\n      idx = self.size - 1 if idx.nil?\n      tail = idx / 2\n      tail += 1 if idx.odd?\n    end\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 5,
                  "endLine": 96,
                  "endColumn": 11,
                  "snippet": {
                    "text": "    # Set these manually here since we need the leading SMA.\n    if tail.nil?\n      idx = self.size - 1 if idx.nil?\n      tail = idx / 2\n      tail += 1 if idx.odd?\n    end\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n",
                    "rendered": {
                      "text": "    # Set these manually here since we need the leading SMA.\n    if tail.nil?\n      idx = self.size - 1 if idx.nil?\n      tail = idx / 2\n      tail += 1 if idx.odd?\n    end\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n",
                      "markdown": "`    # Set these manually here since we need the leading SMA.\n    if tail.nil?\n      idx = self.size - 1 if idx.nil?\n      tail = idx / 2\n      tail += 1 if idx.odd?\n    end\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 36,
                  "endLine": 67,
                  "snippet": {
                    "text": "  def simple_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    self[idx-tail+1..idx].sum.to_f / tail\n  end\n  alias_method :sma, :simple_moving_average\n\n  # Compute the smoothed moving average of the values of an Array.\n",
                    "rendered": {
                      "text": "  def simple_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    self[idx-tail+1..idx].sum.to_f / tail\n  end\n  alias_method :sma, :simple_moving_average\n\n  # Compute the smoothed moving average of the values of an Array.\n",
                      "markdown": "`  def simple_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    self[idx-tail+1..idx].sum.to_f / tail\n  end\n  alias_method :sma, :simple_moving_average\n\n  # Compute the smoothed moving average of the values of an Array.\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 64,
                  "startColumn": 8,
                  "endLine": 64,
                  "endColumn": 14,
                  "snippet": {
                    "text": "  # * +idx+ - Optional, the index of the last datum to consider.\n  # * +tail+ - Optional, the number of data to consider.\n  def simple_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    self[idx-tail+1..idx].sum.to_f / tail\n  end\n",
                    "rendered": {
                      "text": "  # * +idx+ - Optional, the index of the last datum to consider.\n  # * +tail+ - Optional, the number of data to consider.\n  def simple_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    self[idx-tail+1..idx].sum.to_f / tail\n  end\n",
                      "markdown": "`  # * +idx+ - Optional, the index of the last datum to consider.\n  # * +tail+ - Optional, the number of data to consider.\n  def simple_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    self[idx-tail+1..idx].sum.to_f / tail\n  end\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 8,
                  "endLine": 48,
                  "endColumn": 14,
                  "snippet": {
                    "text": "  # * +idx+ - Optional, the index of the last datum to consider.\n  # * +tail+ - Optional, the number of data to consider.\n  def exponential_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    alpha = 2.0 / (tail + 1)\n    n = (1..tail).to_a.map{|tidx| (1 - alpha) ** (tidx - 1) * self[idx - tidx + 1]}.sum\n",
                    "rendered": {
                      "text": "  # * +idx+ - Optional, the index of the last datum to consider.\n  # * +tail+ - Optional, the number of data to consider.\n  def exponential_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    alpha = 2.0 / (tail + 1)\n    n = (1..tail).to_a.map{|tidx| (1 - alpha) ** (tidx - 1) * self[idx - tidx + 1]}.sum\n",
                      "markdown": "`  # * +idx+ - Optional, the index of the last datum to consider.\n  # * +tail+ - Optional, the number of data to consider.\n  def exponential_moving_average(idx=nil, tail=nil)\n    idx, tail = idx_and_tail_or_defaults(idx, tail)\n    valid_for_ma(idx, tail)\n    alpha = 2.0 / (tail + 1)\n    n = (1..tail).to_a.map{|tidx| (1 - alpha) ** (tidx - 1) * self[idx - tidx + 1]}.sum\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 16,
                  "endLine": 20,
                  "endColumn": 22,
                  "snippet": {
                    "text": "    unless tail > 0\n      raise MovingAverage::Errors::InvalidTailError\n    end\n    unless idx - tail >= -1\n      raise MovingAverage::Errors::NotEnoughDataError\n    end\n    true\n",
                    "rendered": {
                      "text": "    unless tail > 0\n      raise MovingAverage::Errors::InvalidTailError\n    end\n    unless idx - tail >= -1\n      raise MovingAverage::Errors::NotEnoughDataError\n    end\n    true\n",
                      "markdown": "`    unless tail > 0\n      raise MovingAverage::Errors::InvalidTailError\n    end\n    unless idx - tail >= -1\n      raise MovingAverage::Errors::NotEnoughDataError\n    end\n    true\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 10,
                  "endLine": 17,
                  "endColumn": 16,
                  "snippet": {
                    "text": "    unless idx >= 0 && idx < self.size\n      raise MovingAverage::Errors::InvalidIndexError\n    end\n    unless tail > 0\n      raise MovingAverage::Errors::InvalidTailError\n    end\n    unless idx - tail >= -1\n",
                    "rendered": {
                      "text": "    unless idx >= 0 && idx < self.size\n      raise MovingAverage::Errors::InvalidIndexError\n    end\n    unless tail > 0\n      raise MovingAverage::Errors::InvalidTailError\n    end\n    unless idx - tail >= -1\n",
                      "markdown": "`    unless idx >= 0 && idx < self.size\n      raise MovingAverage::Errors::InvalidIndexError\n    end\n    unless tail > 0\n      raise MovingAverage::Errors::InvalidTailError\n    end\n    unless idx - tail >= -1\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/data.tar.gz/data.tar/lib/moving_average/moving_average.rb"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 5,
                  "endLine": 5,
                  "endColumn": 11,
                  "snippet": {
                    "text": "\n  def idx_and_tail_or_defaults(idx, tail) #:nodoc:\n    if tail.nil?\n      tail = self.size\n      if idx.nil?\n        idx = self.size - 1\n      end\n",
                    "rendered": {
                      "text": "\n  def idx_and_tail_or_defaults(idx, tail) #:nodoc:\n    if tail.nil?\n      tail = self.size\n      if idx.nil?\n        idx = self.size - 1\n      end\n",
                      "markdown": "`\n  def idx_and_tail_or_defaults(idx, tail) #:nodoc:\n    if tail.nil?\n      tail = self.size\n      if idx.nil?\n        idx = self.size - 1\n      end\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset2/ruby/moving-average-0.1.1-r2.apk/moving-average-0.1.1-r2/home/cg/cache/moving-average-0.1.1.gem/metadata.gz/metadata"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 9,
                  "endLine": 6,
                  "snippet": {
                    "text": "name: moving-average\nversion: !ruby/object:Gem::Version\n  version: 0.1.1\nplatform: ruby\nauthors:\n- Brad Cater\nautorequire: \nbindir: bin\n",
                    "rendered": {
                      "text": "name: moving-average\nversion: !ruby/object:Gem::Version\n  version: 0.1.1\nplatform: ruby\nauthors:\n- Brad Cater\nautorequire: \nbindir: bin\n",
                      "markdown": "`name: moving-average\nversion: !ruby/object:Gem::Version\n  version: 0.1.1\nplatform: ruby\nauthors:\n- Brad Cater\nautorequire: \nbindir: bin\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        }
      ],
      "columnKind": "utf16CodeUnits"
    }
  ]
}