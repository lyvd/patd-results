{
  "$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.6.json",
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "oss-detect-backdoor",
          "organization": "Microsoft Corporation",
          "product": "OSSGadget (https://github.com/Microsoft/OSSGadget)",
          "version": "0.0.0+ed0e2cfe6a"
        }
      },
      "results": [
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/utils.py"
                },
                "region": {
                  "startLine": 110,
                  "startColumn": 41,
                  "endLine": 110,
                  "endColumn": 50,
                  "snippet": {
                    "text": "def get_fatal_error_message(filepath: str, issue_template_path: Path) -> str:\n    return (\n        f\"Fatal error while checking '{filepath}'. \"\n        f\"Please open an issue in our bug tracker so we address this. \"\n        f\"There is a pre-filled template that you can use in '{issue_template_path}'.\"\n    )\n\n",
                    "rendered": {
                      "text": "def get_fatal_error_message(filepath: str, issue_template_path: Path) -> str:\n    return (\n        f\"Fatal error while checking '{filepath}'. \"\n        f\"Please open an issue in our bug tracker so we address this. \"\n        f\"There is a pre-filled template that you can use in '{issue_template_path}'.\"\n    )\n\n",
                      "markdown": "`def get_fatal_error_message(filepath: str, issue_template_path: Path) -> str:\n    return (\n        f\"Fatal error while checking '{filepath}'. \"\n        f\"Please open an issue in our bug tracker so we address this. \"\n        f\"There is a pre-filled template that you can use in '{issue_template_path}'.\"\n    )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/run.py"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 52,
                  "endLine": 41,
                  "endColumn": 60,
                  "snippet": {
                    "text": "\n\ndef _query_cpu() -> int | None:\n    \"\"\"Try to determine number of CPUs allotted in a docker container.\n\n    This is based on discussion and copied from suggestions in\n    https://bugs.python.org/issue36054.\n",
                    "rendered": {
                      "text": "\n\ndef _query_cpu() -> int | None:\n    \"\"\"Try to determine number of CPUs allotted in a docker container.\n\n    This is based on discussion and copied from suggestions in\n    https://bugs.python.org/issue36054.\n",
                      "markdown": "`\n\ndef _query_cpu() -> int | None:\n    \"\"\"Try to determine number of CPUs allotted in a docker container.\n\n    This is based on discussion and copied from suggestions in\n    https://bugs.python.org/issue36054.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/reporters/ureports/nodes.py"
                },
                "region": {
                  "startLine": 60,
                  "startColumn": 16,
                  "endLine": 60,
                  "endColumn": 22,
                  "snippet": {
                    "text": "                self.add_text(child)\n\n    def append(self, child: VNode) -> None:\n        \"\"\"Add a node to children.\"\"\"\n        assert child not in self.parents()\n        self.children.append(child)\n        child.parent = self\n",
                    "rendered": {
                      "text": "                self.add_text(child)\n\n    def append(self, child: VNode) -> None:\n        \"\"\"Add a node to children.\"\"\"\n        assert child not in self.parents()\n        self.children.append(child)\n        child.parent = self\n",
                      "markdown": "`                self.add_text(child)\n\n    def append(self, child: VNode) -> None:\n        \"\"\"Add a node to children.\"\"\"\n        assert child not in self.parents()\n        self.children.append(child)\n        child.parent = self\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/reporters/text.py"
                },
                "region": {
                  "startLine": 279,
                  "startColumn": 49,
                  "endLine": 279,
                  "endColumn": 54,
                  "snippet": {
                    "text": "        for key in (\"end_line\", \"end_column\"):\n            self_dict[key] = self_dict[key] or \"\"\n\n        self_dict[\"category\"] = self.category_map.get(msg.C) or \"error\"\n        self.writeln(self._fixed_template.format(**self_dict))\n\n\n",
                    "rendered": {
                      "text": "        for key in (\"end_line\", \"end_column\"):\n            self_dict[key] = self_dict[key] or \"\"\n\n        self_dict[\"category\"] = self.category_map.get(msg.C) or \"error\"\n        self.writeln(self._fixed_template.format(**self_dict))\n\n\n",
                      "markdown": "`        for key in (\"end_line\", \"end_column\"):\n            self_dict[key] = self_dict[key] or \"\"\n\n        self_dict[\"category\"] = self.category_map.get(msg.C) or \"error\"\n        self.writeln(self._fixed_template.format(**self_dict))\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/reporters/text.py"
                },
                "region": {
                  "startLine": 238,
                  "startColumn": 33,
                  "endLine": 238,
                  "endColumn": 38,
                  "snippet": {
                    "text": "\n    def _get_decoration(self, msg_id: str) -> MessageStyle:\n        \"\"\"Returns the message style as defined in self.color_mapping.\"\"\"\n        return self.color_mapping.get(msg_id[0]) or MessageStyle(None)\n\n    def handle_message(self, msg: Message) -> None:\n        \"\"\"Manage message of different types, and colorize output\n",
                    "rendered": {
                      "text": "\n    def _get_decoration(self, msg_id: str) -> MessageStyle:\n        \"\"\"Returns the message style as defined in self.color_mapping.\"\"\"\n        return self.color_mapping.get(msg_id[0]) or MessageStyle(None)\n\n    def handle_message(self, msg: Message) -> None:\n        \"\"\"Manage message of different types, and colorize output\n",
                      "markdown": "`\n    def _get_decoration(self, msg_id: str) -> MessageStyle:\n        \"\"\"Returns the message style as defined in self.color_mapping.\"\"\"\n        return self.color_mapping.get(msg_id[0]) or MessageStyle(None)\n\n    def handle_message(self, msg: Message) -> None:\n        \"\"\"Manage message of different types, and colorize output\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/reporters/text.py"
                },
                "region": {
                  "startLine": 229,
                  "startColumn": 21,
                  "endLine": 229,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        super().__init__(output)\n        self.color_mapping = color_mapping or ColorizedTextReporter.COLOR_MAPPING\n        ansi_terms = [\"xterm-16color\", \"xterm-256color\"]\n        if os.environ.get(\"TERM\") not in ansi_terms:\n            if sys.platform == \"win32\":\n                # pylint: disable=import-outside-toplevel\n                import colorama\n",
                    "rendered": {
                      "text": "        super().__init__(output)\n        self.color_mapping = color_mapping or ColorizedTextReporter.COLOR_MAPPING\n        ansi_terms = [\"xterm-16color\", \"xterm-256color\"]\n        if os.environ.get(\"TERM\") not in ansi_terms:\n            if sys.platform == \"win32\":\n                # pylint: disable=import-outside-toplevel\n                import colorama\n",
                      "markdown": "`        super().__init__(output)\n        self.color_mapping = color_mapping or ColorizedTextReporter.COLOR_MAPPING\n        ansi_terms = [\"xterm-16color\", \"xterm-256color\"]\n        if os.environ.get(\"TERM\") not in ansi_terms:\n            if sys.platform == \"win32\":\n                # pylint: disable=import-outside-toplevel\n                import colorama\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/reporters/text.py"
                },
                "region": {
                  "startLine": 229,
                  "startColumn": 14,
                  "endLine": 229,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        super().__init__(output)\n        self.color_mapping = color_mapping or ColorizedTextReporter.COLOR_MAPPING\n        ansi_terms = [\"xterm-16color\", \"xterm-256color\"]\n        if os.environ.get(\"TERM\") not in ansi_terms:\n            if sys.platform == \"win32\":\n                # pylint: disable=import-outside-toplevel\n                import colorama\n",
                    "rendered": {
                      "text": "        super().__init__(output)\n        self.color_mapping = color_mapping or ColorizedTextReporter.COLOR_MAPPING\n        ansi_terms = [\"xterm-16color\", \"xterm-256color\"]\n        if os.environ.get(\"TERM\") not in ansi_terms:\n            if sys.platform == \"win32\":\n                # pylint: disable=import-outside-toplevel\n                import colorama\n",
                      "markdown": "`        super().__init__(output)\n        self.color_mapping = color_mapping or ColorizedTextReporter.COLOR_MAPPING\n        ansi_terms = [\"xterm-16color\", \"xterm-256color\"]\n        if os.environ.get(\"TERM\") not in ansi_terms:\n            if sys.platform == \"win32\":\n                # pylint: disable=import-outside-toplevel\n                import colorama\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/message/message_id_store.py"
                },
                "region": {
                  "startLine": 159,
                  "startColumn": 30,
                  "endLine": 159,
                  "endColumn": 35,
                  "snippet": {
                    "text": "                raise MessageBecameExtensionError(msgid_or_symbol, moved_reason)\n            error_msg = f\"No such message id or symbol '{msgid_or_symbol}'.\"\n            raise UnknownMessageError(error_msg)\n        ids = self.__old_names.get(msgid, [msgid])\n        # Add to cache\n        self.__active_msgids[msgid_or_symbol] = ids\n        return ids\n",
                    "rendered": {
                      "text": "                raise MessageBecameExtensionError(msgid_or_symbol, moved_reason)\n            error_msg = f\"No such message id or symbol '{msgid_or_symbol}'.\"\n            raise UnknownMessageError(error_msg)\n        ids = self.__old_names.get(msgid, [msgid])\n        # Add to cache\n        self.__active_msgids[msgid_or_symbol] = ids\n        return ids\n",
                      "markdown": "`                raise MessageBecameExtensionError(msgid_or_symbol, moved_reason)\n            error_msg = f\"No such message id or symbol '{msgid_or_symbol}'.\"\n            raise UnknownMessageError(error_msg)\n        ids = self.__old_names.get(msgid, [msgid])\n        # Add to cache\n        self.__active_msgids[msgid_or_symbol] = ids\n        return ids\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/message/message_id_store.py"
                },
                "region": {
                  "startLine": 147,
                  "startColumn": 42,
                  "endLine": 147,
                  "endColumn": 47,
                  "snippet": {
                    "text": "                    moved_reason = is_moved_msgid(msgid)\n        else:\n            symbol = msgid_or_symbol\n            msgid = self.__symbol_to_msgid.get(msgid_or_symbol)\n            if not msgid:\n                deletion_reason = is_deleted_symbol(symbol)\n                if deletion_reason is None:\n",
                    "rendered": {
                      "text": "                    moved_reason = is_moved_msgid(msgid)\n        else:\n            symbol = msgid_or_symbol\n            msgid = self.__symbol_to_msgid.get(msgid_or_symbol)\n            if not msgid:\n                deletion_reason = is_deleted_symbol(symbol)\n                if deletion_reason is None:\n",
                      "markdown": "`                    moved_reason = is_moved_msgid(msgid)\n        else:\n            symbol = msgid_or_symbol\n            msgid = self.__symbol_to_msgid.get(msgid_or_symbol)\n            if not msgid:\n                deletion_reason = is_deleted_symbol(symbol)\n                if deletion_reason is None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/message/message_id_store.py"
                },
                "region": {
                  "startLine": 140,
                  "startColumn": 43,
                  "endLine": 140,
                  "endColumn": 48,
                  "snippet": {
                    "text": "        if msgid_or_symbol[1:].isdigit():\n            # Only msgid can have a digit as second letter\n            msgid = msgid_or_symbol.upper()\n            symbol = self.__msgid_to_symbol.get(msgid)\n            if not symbol:\n                deletion_reason = is_deleted_msgid(msgid)\n                if deletion_reason is None:\n",
                    "rendered": {
                      "text": "        if msgid_or_symbol[1:].isdigit():\n            # Only msgid can have a digit as second letter\n            msgid = msgid_or_symbol.upper()\n            symbol = self.__msgid_to_symbol.get(msgid)\n            if not symbol:\n                deletion_reason = is_deleted_msgid(msgid)\n                if deletion_reason is None:\n",
                      "markdown": "`        if msgid_or_symbol[1:].isdigit():\n            # Only msgid can have a digit as second letter\n            msgid = msgid_or_symbol.upper()\n            symbol = self.__msgid_to_symbol.get(msgid)\n            if not symbol:\n                deletion_reason = is_deleted_msgid(msgid)\n                if deletion_reason is None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/message/message_id_store.py"
                },
                "region": {
                  "startLine": 92,
                  "startColumn": 60,
                  "endLine": 92,
                  "endColumn": 65,
                  "snippet": {
                    "text": "\n    def check_msgid_and_symbol(self, msgid: str, symbol: str) -> None:\n        existing_msgid: str | None = self.__symbol_to_msgid.get(symbol)\n        existing_symbol: str | None = self.__msgid_to_symbol.get(msgid)\n        if existing_symbol is None and existing_msgid is None:\n            return  # both symbol and msgid are usable\n        if existing_msgid is not None:\n",
                    "rendered": {
                      "text": "\n    def check_msgid_and_symbol(self, msgid: str, symbol: str) -> None:\n        existing_msgid: str | None = self.__symbol_to_msgid.get(symbol)\n        existing_symbol: str | None = self.__msgid_to_symbol.get(msgid)\n        if existing_symbol is None and existing_msgid is None:\n            return  # both symbol and msgid are usable\n        if existing_msgid is not None:\n",
                      "markdown": "`\n    def check_msgid_and_symbol(self, msgid: str, symbol: str) -> None:\n        existing_msgid: str | None = self.__symbol_to_msgid.get(symbol)\n        existing_symbol: str | None = self.__msgid_to_symbol.get(msgid)\n        if existing_symbol is None and existing_msgid is None:\n            return  # both symbol and msgid are usable\n        if existing_msgid is not None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/message/message_id_store.py"
                },
                "region": {
                  "startLine": 91,
                  "startColumn": 59,
                  "endLine": 91,
                  "endColumn": 64,
                  "snippet": {
                    "text": "        self.__old_names[msgid] = existing_old_names\n\n    def check_msgid_and_symbol(self, msgid: str, symbol: str) -> None:\n        existing_msgid: str | None = self.__symbol_to_msgid.get(symbol)\n        existing_symbol: str | None = self.__msgid_to_symbol.get(msgid)\n        if existing_symbol is None and existing_msgid is None:\n            return  # both symbol and msgid are usable\n",
                    "rendered": {
                      "text": "        self.__old_names[msgid] = existing_old_names\n\n    def check_msgid_and_symbol(self, msgid: str, symbol: str) -> None:\n        existing_msgid: str | None = self.__symbol_to_msgid.get(symbol)\n        existing_symbol: str | None = self.__msgid_to_symbol.get(msgid)\n        if existing_symbol is None and existing_msgid is None:\n            return  # both symbol and msgid are usable\n",
                      "markdown": "`        self.__old_names[msgid] = existing_old_names\n\n    def check_msgid_and_symbol(self, msgid: str, symbol: str) -> None:\n        existing_msgid: str | None = self.__symbol_to_msgid.get(symbol)\n        existing_symbol: str | None = self.__msgid_to_symbol.get(msgid)\n        if existing_symbol is None and existing_msgid is None:\n            return  # both symbol and msgid are usable\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/message/message_id_store.py"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 45,
                  "endLine": 86,
                  "endColumn": 50,
                  "snippet": {
                    "text": "        \"\"\"\n        self.__msgid_to_symbol[msgid] = symbol\n        self.__symbol_to_msgid[symbol] = msgid\n        existing_old_names = self.__old_names.get(msgid, [])\n        existing_old_names.append(new_msgid)\n        self.__old_names[msgid] = existing_old_names\n\n",
                    "rendered": {
                      "text": "        \"\"\"\n        self.__msgid_to_symbol[msgid] = symbol\n        self.__symbol_to_msgid[symbol] = msgid\n        existing_old_names = self.__old_names.get(msgid, [])\n        existing_old_names.append(new_msgid)\n        self.__old_names[msgid] = existing_old_names\n\n",
                      "markdown": "`        \"\"\"\n        self.__msgid_to_symbol[msgid] = symbol\n        self.__symbol_to_msgid[symbol] = msgid\n        existing_old_names = self.__old_names.get(msgid, [])\n        existing_old_names.append(new_msgid)\n        self.__old_names[msgid] = existing_old_names\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/message/message_id_store.py"
                },
                "region": {
                  "startLine": 118,
                  "startColumn": 45,
                  "endLine": 118,
                  "endColumn": 49,
                  "snippet": {
                    "text": "        msgids.sort()\n        error_message = (\n            f\"Message symbol '{symbol}' cannot be used for \"\n            f\"'{msgids[0]}' and '{msgids[1]}' at the same time.\"\n            f\" If you're creating an 'old_names' use 'old-{symbol}' as the old symbol.\"\n        )\n        raise InvalidMessageError(error_message)\n",
                    "rendered": {
                      "text": "        msgids.sort()\n        error_message = (\n            f\"Message symbol '{symbol}' cannot be used for \"\n            f\"'{msgids[0]}' and '{msgids[1]}' at the same time.\"\n            f\" If you're creating an 'old_names' use 'old-{symbol}' as the old symbol.\"\n        )\n        raise InvalidMessageError(error_message)\n",
                      "markdown": "`        msgids.sort()\n        error_message = (\n            f\"Message symbol '{symbol}' cannot be used for \"\n            f\"'{msgids[0]}' and '{msgids[1]}' at the same time.\"\n            f\" If you're creating an 'old_names' use 'old-{symbol}' as the old symbol.\"\n        )\n        raise InvalidMessageError(error_message)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/message/message_id_store.py"
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 28,
                  "endLine": 82,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        \"\"\"Add valid legacy message id.\n\n        There is a little duplication with add_msgid_and_symbol to avoid a function call,\n        this is called a lot at initialization.\n        \"\"\"\n        self.__msgid_to_symbol[msgid] = symbol\n        self.__symbol_to_msgid[symbol] = msgid\n",
                    "rendered": {
                      "text": "        \"\"\"Add valid legacy message id.\n\n        There is a little duplication with add_msgid_and_symbol to avoid a function call,\n        this is called a lot at initialization.\n        \"\"\"\n        self.__msgid_to_symbol[msgid] = symbol\n        self.__symbol_to_msgid[symbol] = msgid\n",
                      "markdown": "`        \"\"\"Add valid legacy message id.\n\n        There is a little duplication with add_msgid_and_symbol to avoid a function call,\n        this is called a lot at initialization.\n        \"\"\"\n        self.__msgid_to_symbol[msgid] = symbol\n        self.__symbol_to_msgid[symbol] = msgid\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/message/message_id_store.py"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 28,
                  "endLine": 71,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        \"\"\"Add valid message id.\n\n        There is a little duplication with add_legacy_msgid_and_symbol to avoid a function call,\n        this is called a lot at initialization.\n        \"\"\"\n        self.__msgid_to_symbol[msgid] = symbol\n        self.__symbol_to_msgid[symbol] = msgid\n",
                    "rendered": {
                      "text": "        \"\"\"Add valid message id.\n\n        There is a little duplication with add_legacy_msgid_and_symbol to avoid a function call,\n        this is called a lot at initialization.\n        \"\"\"\n        self.__msgid_to_symbol[msgid] = symbol\n        self.__symbol_to_msgid[symbol] = msgid\n",
                      "markdown": "`        \"\"\"Add valid message id.\n\n        There is a little duplication with add_legacy_msgid_and_symbol to avoid a function call,\n        this is called a lot at initialization.\n        \"\"\"\n        self.__msgid_to_symbol[msgid] = symbol\n        self.__symbol_to_msgid[symbol] = msgid\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/message/message_definition.py"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 18,
                  "endLine": 128,
                  "endColumn": 24,
                  "snippet": {
                    "text": "                    )\n            elif self.scope == WarningScope.NODE:\n                # Node-based warnings may provide an override line.\n                if node is None:\n                    raise InvalidMessageError(\n                        f\"Message {self.msgid} must provide Node, got None\"\n                    )\n",
                    "rendered": {
                      "text": "                    )\n            elif self.scope == WarningScope.NODE:\n                # Node-based warnings may provide an override line.\n                if node is None:\n                    raise InvalidMessageError(\n                        f\"Message {self.msgid} must provide Node, got None\"\n                    )\n",
                      "markdown": "`                    )\n            elif self.scope == WarningScope.NODE:\n                # Node-based warnings may provide an override line.\n                if node is None:\n                    raise InvalidMessageError(\n                        f\"Message {self.msgid} must provide Node, got None\"\n                    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/message/message_definition.py"
                },
                "region": {
                  "startLine": 121,
                  "startColumn": 18,
                  "endLine": 121,
                  "endColumn": 24,
                  "snippet": {
                    "text": "                    raise InvalidMessageError(\n                        f\"Message {self.msgid} must provide line, got None\"\n                    )\n                if node is not None:\n                    raise InvalidMessageError(\n                        f\"Message {self.msgid} must only provide line, \"\n                        f\"got line={line}, node={node}\"\n",
                    "rendered": {
                      "text": "                    raise InvalidMessageError(\n                        f\"Message {self.msgid} must provide line, got None\"\n                    )\n                if node is not None:\n                    raise InvalidMessageError(\n                        f\"Message {self.msgid} must only provide line, \"\n                        f\"got line={line}, node={node}\"\n",
                      "markdown": "`                    raise InvalidMessageError(\n                        f\"Message {self.msgid} must provide line, got None\"\n                    )\n                if node is not None:\n                    raise InvalidMessageError(\n                        f\"Message {self.msgid} must only provide line, \"\n                        f\"got line={line}, node={node}\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/config_initialization.py"
                },
                "region": {
                  "startLine": 119,
                  "startColumn": 46,
                  "endLine": 119,
                  "endColumn": 50,
                  "snippet": {
                    "text": "            warnings.warn_explicit(\n                f\"'{exc_name}' is not a proper value for the 'overgeneral-exceptions' option. \"\n                f\"Use fully qualified name (maybe 'builtins.{exc_name}' ?) instead. \"\n                \"This will cease to be checked at runtime when the configuration \"\n                \"upgrader is released.\",\n                category=UserWarning,\n                filename=\"pylint: Command line or configuration file\",\n",
                    "rendered": {
                      "text": "            warnings.warn_explicit(\n                f\"'{exc_name}' is not a proper value for the 'overgeneral-exceptions' option. \"\n                f\"Use fully qualified name (maybe 'builtins.{exc_name}' ?) instead. \"\n                \"This will cease to be checked at runtime when the configuration \"\n                \"upgrader is released.\",\n                category=UserWarning,\n                filename=\"pylint: Command line or configuration file\",\n",
                      "markdown": "`            warnings.warn_explicit(\n                f\"'{exc_name}' is not a proper value for the 'overgeneral-exceptions' option. \"\n                f\"Use fully qualified name (maybe 'builtins.{exc_name}' ?) instead. \"\n                \"This will cease to be checked at runtime when the configuration \"\n                \"upgrader is released.\",\n                category=UserWarning,\n                filename=\"pylint: Command line or configuration file\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/config_initialization.py"
                },
                "region": {
                  "startLine": 166,
                  "startColumn": 23,
                  "endLine": 166,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    Raise if both are given.\n\n    If joined is True, expect args in the form '--enable=all,for-any-all'.\n    If joined is False, expect args in the form '--enable', 'all,for-any-all'.\n    \"\"\"\n    indexes_to_prepend = []\n    all_action = \"\"\n",
                    "rendered": {
                      "text": "    Raise if both are given.\n\n    If joined is True, expect args in the form '--enable=all,for-any-all'.\n    If joined is False, expect args in the form '--enable', 'all,for-any-all'.\n    \"\"\"\n    indexes_to_prepend = []\n    all_action = \"\"\n",
                      "markdown": "`    Raise if both are given.\n\n    If joined is True, expect args in the form '--enable=all,for-any-all'.\n    If joined is False, expect args in the form '--enable', 'all,for-any-all'.\n    \"\"\"\n    indexes_to_prepend = []\n    all_action = \"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/config_initialization.py"
                },
                "region": {
                  "startLine": 165,
                  "startColumn": 22,
                  "endLine": 165,
                  "endColumn": 30,
                  "snippet": {
                    "text": "\n    Raise if both are given.\n\n    If joined is True, expect args in the form '--enable=all,for-any-all'.\n    If joined is False, expect args in the form '--enable', 'all,for-any-all'.\n    \"\"\"\n    indexes_to_prepend = []\n",
                    "rendered": {
                      "text": "\n    Raise if both are given.\n\n    If joined is True, expect args in the form '--enable=all,for-any-all'.\n    If joined is False, expect args in the form '--enable', 'all,for-any-all'.\n    \"\"\"\n    indexes_to_prepend = []\n",
                      "markdown": "`\n    Raise if both are given.\n\n    If joined is True, expect args in the form '--enable=all,for-any-all'.\n    If joined is False, expect args in the form '--enable', 'all,for-any-all'.\n    \"\"\"\n    indexes_to_prepend = []\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/config_initialization.py"
                },
                "region": {
                  "startLine": 151,
                  "startColumn": 46,
                  "endLine": 151,
                  "endColumn": 52,
                  "snippet": {
                    "text": "    return list(\n        chain.from_iterable(\n            # NOTE: 'or [arg]' is needed in the case the input file or directory does\n            # not exist and 'glob(arg)' cannot find anything. Without this we would\n            # not be able to output the fatal import error for this module later on,\n            # as it would get silently ignored.\n            glob(arg, recursive=True) or [arg]\n",
                    "rendered": {
                      "text": "    return list(\n        chain.from_iterable(\n            # NOTE: 'or [arg]' is needed in the case the input file or directory does\n            # not exist and 'glob(arg)' cannot find anything. Without this we would\n            # not be able to output the fatal import error for this module later on,\n            # as it would get silently ignored.\n            glob(arg, recursive=True) or [arg]\n",
                      "markdown": "`    return list(\n        chain.from_iterable(\n            # NOTE: 'or [arg]' is needed in the case the input file or directory does\n            # not exist and 'glob(arg)' cannot find anything. Without this we would\n            # not be able to output the fatal import error for this module later on,\n            # as it would get silently ignored.\n            glob(arg, recursive=True) or [arg]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/arguments_provider.py"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 39,
                  "endLine": 50,
                  "endColumn": 44,
                  "snippet": {
                    "text": "        \"\"\"\n        sections: dict[str, list[tuple[str, OptionDict, Any]]] = {}\n        for optname, optdict in self.options:\n            sections.setdefault(optdict.get(\"group\"), []).append(  # type: ignore[arg-type]\n                (optname, optdict, self._option_value(optname))\n            )\n        if None in sections:\n",
                    "rendered": {
                      "text": "        \"\"\"\n        sections: dict[str, list[tuple[str, OptionDict, Any]]] = {}\n        for optname, optdict in self.options:\n            sections.setdefault(optdict.get(\"group\"), []).append(  # type: ignore[arg-type]\n                (optname, optdict, self._option_value(optname))\n            )\n        if None in sections:\n",
                      "markdown": "`        \"\"\"\n        sections: dict[str, list[tuple[str, OptionDict, Any]]] = {}\n        for optname, optdict in self.options:\n            sections.setdefault(optdict.get(\"group\"), []).append(  # type: ignore[arg-type]\n                (optname, optdict, self._option_value(optname))\n            )\n        if None in sections:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/arguments_manager.py"
                },
                "region": {
                  "startLine": 379,
                  "startColumn": 47,
                  "endLine": 379,
                  "endColumn": 52,
                  "snippet": {
                    "text": "                    value = \".\".join(str(i) for i in value)\n\n                # Check if it is default value if we are in minimal mode\n                if minimal and value == optdict.get(\"default\"):\n                    continue\n\n                # Add to table\n",
                    "rendered": {
                      "text": "                    value = \".\".join(str(i) for i in value)\n\n                # Check if it is default value if we are in minimal mode\n                if minimal and value == optdict.get(\"default\"):\n                    continue\n\n                # Add to table\n",
                      "markdown": "`                    value = \".\".join(str(i) for i in value)\n\n                # Check if it is default value if we are in minimal mode\n                if minimal and value == optdict.get(\"default\"):\n                    continue\n\n                # Add to table\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/arguments_manager.py"
                },
                "region": {
                  "startLine": 375,
                  "startColumn": 26,
                  "endLine": 375,
                  "endColumn": 31,
                  "snippet": {
                    "text": "                    value = [i.pattern for i in value]\n\n                # Handle tuples that should be strings\n                if optdict.get(\"type\") == \"py_version\":\n                    value = \".\".join(str(i) for i in value)\n\n                # Check if it is default value if we are in minimal mode\n",
                    "rendered": {
                      "text": "                    value = [i.pattern for i in value]\n\n                # Handle tuples that should be strings\n                if optdict.get(\"type\") == \"py_version\":\n                    value = \".\".join(str(i) for i in value)\n\n                # Check if it is default value if we are in minimal mode\n",
                      "markdown": "`                    value = [i.pattern for i in value]\n\n                # Handle tuples that should be strings\n                if optdict.get(\"type\") == \"py_version\":\n                    value = \".\".join(str(i) for i in value)\n\n                # Check if it is default value if we are in minimal mode\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/arguments_manager.py"
                },
                "region": {
                  "startLine": 344,
                  "startColumn": 38,
                  "endLine": 344,
                  "endColumn": 43,
                  "snippet": {
                    "text": "\n                # Add help comment\n                if not minimal:\n                    help_msg = optdict.get(\"help\", \"\")\n                    assert isinstance(help_msg, str)\n                    help_text = textwrap.wrap(help_msg, width=79)\n                    for line in help_text:\n",
                    "rendered": {
                      "text": "\n                # Add help comment\n                if not minimal:\n                    help_msg = optdict.get(\"help\", \"\")\n                    assert isinstance(help_msg, str)\n                    help_text = textwrap.wrap(help_msg, width=79)\n                    for line in help_text:\n",
                      "markdown": "`\n                # Add help comment\n                if not minimal:\n                    help_msg = optdict.get(\"help\", \"\")\n                    assert isinstance(help_msg, str)\n                    help_text = textwrap.wrap(help_msg, width=79)\n                    for line in help_text:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/arguments_manager.py"
                },
                "region": {
                  "startLine": 339,
                  "startColumn": 26,
                  "endLine": 339,
                  "endColumn": 31,
                  "snippet": {
                    "text": "                except KeyError:\n                    continue\n\n                if optdict.get(\"hide_from_config_file\"):\n                    continue\n\n                # Add help comment\n",
                    "rendered": {
                      "text": "                except KeyError:\n                    continue\n\n                if optdict.get(\"hide_from_config_file\"):\n                    continue\n\n                # Add help comment\n",
                      "markdown": "`                except KeyError:\n                    continue\n\n                if optdict.get(\"hide_from_config_file\"):\n                    continue\n\n                # Add help comment\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/arguments_manager.py"
                },
                "region": {
                  "startLine": 279,
                  "startColumn": 63,
                  "endLine": 279,
                  "endColumn": 68,
                  "snippet": {
                    "text": "                )\n\n                options = [\n                    (n, d, v) for (n, d, v) in options if not d.get(\"deprecated\")\n                ]\n\n            if options:\n",
                    "rendered": {
                      "text": "                )\n\n                options = [\n                    (n, d, v) for (n, d, v) in options if not d.get(\"deprecated\")\n                ]\n\n            if options:\n",
                      "markdown": "`                )\n\n                options = [\n                    (n, d, v) for (n, d, v) in options if not d.get(\"deprecated\")\n                ]\n\n            if options:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/arguments_manager.py"
                },
                "region": {
                  "startLine": 100,
                  "startColumn": 55,
                  "endLine": 100,
                  "endColumn": 60,
                  "snippet": {
                    "text": "            argument = _convert_option_to_argument(opt, optdict)\n            section = argument.section or provider.name.capitalize()\n\n            section_desc = provider.option_groups_descs.get(section, None)\n\n            # We exclude main since its docstring comes from PyLinter\n            if provider.name != MAIN_CHECKER_NAME and provider.__doc__:\n",
                    "rendered": {
                      "text": "            argument = _convert_option_to_argument(opt, optdict)\n            section = argument.section or provider.name.capitalize()\n\n            section_desc = provider.option_groups_descs.get(section, None)\n\n            # We exclude main since its docstring comes from PyLinter\n            if provider.name != MAIN_CHECKER_NAME and provider.__doc__:\n",
                      "markdown": "`            argument = _convert_option_to_argument(opt, optdict)\n            section = argument.section or provider.name.capitalize()\n\n            section_desc = provider.option_groups_descs.get(section, None)\n\n            # We exclude main since its docstring comes from PyLinter\n            if provider.name != MAIN_CHECKER_NAME and provider.__doc__:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/argument.py"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 71,
                  "endLine": 111,
                  "endColumn": 75,
                  "snippet": {
                    "text": "    try:\n        return re.compile(value)\n    except re.error as e:\n        msg = f\"Error in provided regular expression: {value} beginning at index {e.pos}: {e.msg}\"\n        raise argparse.ArgumentTypeError(msg) from e\n\n\n",
                    "rendered": {
                      "text": "    try:\n        return re.compile(value)\n    except re.error as e:\n        msg = f\"Error in provided regular expression: {value} beginning at index {e.pos}: {e.msg}\"\n        raise argparse.ArgumentTypeError(msg) from e\n\n\n",
                      "markdown": "`    try:\n        return re.compile(value)\n    except re.error as e:\n        msg = f\"Error in provided regular expression: {value} beginning at index {e.pos}: {e.msg}\"\n        raise argparse.ArgumentTypeError(msg) from e\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/special_methods_checker.py"
                },
                "region": {
                  "startLine": 224,
                  "startColumn": 17,
                  "endLine": 224,
                  "endColumn": 21,
                  "snippet": {
                    "text": "            # to take all of them in consideration.\n            emit = mandatory not in expected_params\n            # mypy thinks that expected_params has type tuple[int, int] | int | None\n            # But at this point it must be 'tuple[int, int]' because of the type check\n            expected_params = f\"between {expected_params[0]} or {expected_params[1]}\"  # type: ignore[assignment]\n        else:\n            # If the number of mandatory parameters doesn't\n",
                    "rendered": {
                      "text": "            # to take all of them in consideration.\n            emit = mandatory not in expected_params\n            # mypy thinks that expected_params has type tuple[int, int] | int | None\n            # But at this point it must be 'tuple[int, int]' because of the type check\n            expected_params = f\"between {expected_params[0]} or {expected_params[1]}\"  # type: ignore[assignment]\n        else:\n            # If the number of mandatory parameters doesn't\n",
                      "markdown": "`            # to take all of them in consideration.\n            emit = mandatory not in expected_params\n            # mypy thinks that expected_params has type tuple[int, int] | int | None\n            # But at this point it must be 'tuple[int, int]' because of the type check\n            expected_params = f\"between {expected_params[0]} or {expected_params[1]}\"  # type: ignore[assignment]\n        else:\n            # If the number of mandatory parameters doesn't\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/special_methods_checker.py"
                },
                "region": {
                  "startLine": 80,
                  "startColumn": 40,
                  "endLine": 80,
                  "endColumn": 44,
                  "snippet": {
                    "text": "            \"unexpected-special-method-signature\",\n            \"Emitted when a special method was defined with an \"\n            \"invalid number of parameters. If it has too few or \"\n            \"too many, it might not work at all.\",\n            {\"old_names\": [(\"E0235\", \"bad-context-manager\")]},\n        ),\n        \"E0303\": (\n",
                    "rendered": {
                      "text": "            \"unexpected-special-method-signature\",\n            \"Emitted when a special method was defined with an \"\n            \"invalid number of parameters. If it has too few or \"\n            \"too many, it might not work at all.\",\n            {\"old_names\": [(\"E0235\", \"bad-context-manager\")]},\n        ),\n        \"E0303\": (\n",
                      "markdown": "`            \"unexpected-special-method-signature\",\n            \"Emitted when a special method was defined with an \"\n            \"invalid number of parameters. If it has too few or \"\n            \"too many, it might not work at all.\",\n            {\"old_names\": [(\"E0235\", \"bad-context-manager\")]},\n        ),\n        \"E0303\": (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/special_methods_checker.py"
                },
                "region": {
                  "startLine": 209,
                  "startColumn": 16,
                  "endLine": 209,
                  "endColumn": 24,
                  "snippet": {
                    "text": "            return\n\n        if decorated_with(node, [\"builtins.staticmethod\"]):\n            # We expect to not take in consideration self.\n            all_args = node.args.args\n        else:\n            all_args = node.args.args[1:]\n",
                    "rendered": {
                      "text": "            return\n\n        if decorated_with(node, [\"builtins.staticmethod\"]):\n            # We expect to not take in consideration self.\n            all_args = node.args.args\n        else:\n            all_args = node.args.args[1:]\n",
                      "markdown": "`            return\n\n        if decorated_with(node, [\"builtins.staticmethod\"]):\n            # We expect to not take in consideration self.\n            all_args = node.args.args\n        else:\n            all_args = node.args.args[1:]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/special_methods_checker.py"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 57,
                  "endLine": 50,
                  "snippet": {
                    "text": "        return None  # no values inferred\n    try:\n        next(inferit)\n        return None  # there is ambiguity on the inferred node\n    except astroid.InferenceError:\n        return None  # there is some kind of ambiguity\n    except StopIteration:\n        return value\n",
                    "rendered": {
                      "text": "        return None  # no values inferred\n    try:\n        next(inferit)\n        return None  # there is ambiguity on the inferred node\n    except astroid.InferenceError:\n        return None  # there is some kind of ambiguity\n    except StopIteration:\n        return value\n",
                      "markdown": "`        return None  # no values inferred\n    try:\n        next(inferit)\n        return None  # there is ambiguity on the inferred node\n    except astroid.InferenceError:\n        return None  # there is some kind of ambiguity\n    except StopIteration:\n        return value\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/special_methods_checker.py"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 7,
                  "endLine": 38,
                  "endColumn": 13,
                  "snippet": {
                    "text": "    \"\"\"Safely infer the return value of a function.\n\n    Returns None if inference failed or if there is some ambiguity (more than\n    one node has been inferred). Otherwise, returns inferred value.\n    \"\"\"\n    try:\n        inferit = node.infer_call_result(caller, context=context)\n",
                    "rendered": {
                      "text": "    \"\"\"Safely infer the return value of a function.\n\n    Returns None if inference failed or if there is some ambiguity (more than\n    one node has been inferred). Otherwise, returns inferred value.\n    \"\"\"\n    try:\n        inferit = node.infer_call_result(caller, context=context)\n",
                      "markdown": "`    \"\"\"Safely infer the return value of a function.\n\n    Returns None if inference failed or if there is some ambiguity (more than\n    one node has been inferred). Otherwise, returns inferred value.\n    \"\"\"\n    try:\n        inferit = node.infer_call_result(caller, context=context)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 1824,
                  "startColumn": 50,
                  "endLine": 1824,
                  "endColumn": 55,
                  "snippet": {
                    "text": "                ):\n                    return\n                if node.attrname in klass.locals:\n                    for local_name in klass.locals.get(node.attrname):\n                        statement = local_name.statement()\n                        if (\n                            isinstance(statement, nodes.AnnAssign)\n",
                    "rendered": {
                      "text": "                ):\n                    return\n                if node.attrname in klass.locals:\n                    for local_name in klass.locals.get(node.attrname):\n                        statement = local_name.statement()\n                        if (\n                            isinstance(statement, nodes.AnnAssign)\n",
                      "markdown": "`                ):\n                    return\n                if node.attrname in klass.locals:\n                    for local_name in klass.locals.get(node.attrname):\n                        statement = local_name.statement()\n                        if (\n                            isinstance(statement, nodes.AnnAssign)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 1796,
                  "startColumn": 30,
                  "endLine": 1796,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        # of 'slots()' might have been evaluated incorrectly, thus deleted cache entry.\n        if any(base.qname() == \"typing.Generic\" for base in klass.mro()):\n            cache = getattr(klass, \"__cache\", None)\n            if cache and cache.get(klass.slots) is not None:\n                del cache[klass.slots]\n\n        slots = klass.slots()\n",
                    "rendered": {
                      "text": "        # of 'slots()' might have been evaluated incorrectly, thus deleted cache entry.\n        if any(base.qname() == \"typing.Generic\" for base in klass.mro()):\n            cache = getattr(klass, \"__cache\", None)\n            if cache and cache.get(klass.slots) is not None:\n                del cache[klass.slots]\n\n        slots = klass.slots()\n",
                      "markdown": "`        # of 'slots()' might have been evaluated incorrectly, thus deleted cache entry.\n        if any(base.qname() == \"typing.Generic\" for base in klass.mro()):\n            cache = getattr(klass, \"__cache\", None)\n            if cache and cache.get(klass.slots) is not None:\n                del cache[klass.slots]\n\n        slots = klass.slots()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 1786,
                  "startColumn": 23,
                  "endLine": 1786,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        # If `__setattr__` is defined on the class, then we can't reason about\n        # what will happen when assigning to an attribute.\n        if any(\n            base.locals.get(\"__setattr__\")\n            for base in klass.mro()\n            if base.qname() != \"builtins.object\"\n        ):\n",
                    "rendered": {
                      "text": "        # If `__setattr__` is defined on the class, then we can't reason about\n        # what will happen when assigning to an attribute.\n        if any(\n            base.locals.get(\"__setattr__\")\n            for base in klass.mro()\n            if base.qname() != \"builtins.object\"\n        ):\n",
                      "markdown": "`        # If `__setattr__` is defined on the class, then we can't reason about\n        # what will happen when assigning to an attribute.\n        if any(\n            base.locals.get(\"__setattr__\")\n            for base in klass.mro()\n            if base.qname() != \"builtins.object\"\n        ):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 1674,
                  "startColumn": 40,
                  "endLine": 1674,
                  "endColumn": 45,
                  "snippet": {
                    "text": "                )\n\n            # Check if we have a conflict with a class variable.\n            class_variable = node.locals.get(inferred.value)\n            if class_variable:\n                # Skip annotated assignments which don't conflict at all with slots.\n                if len(class_variable) == 1:\n",
                    "rendered": {
                      "text": "                )\n\n            # Check if we have a conflict with a class variable.\n            class_variable = node.locals.get(inferred.value)\n            if class_variable:\n                # Skip annotated assignments which don't conflict at all with slots.\n                if len(class_variable) == 1:\n",
                      "markdown": "`                )\n\n            # Check if we have a conflict with a class variable.\n            class_variable = node.locals.get(inferred.value)\n            if class_variable:\n                # Skip annotated assignments which don't conflict at all with slots.\n                if len(class_variable) == 1:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 764,
                  "startColumn": 27,
                  "endLine": 764,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n    def accessed(self, scope: nodes.ClassDef) -> dict[str, list[_AccessNodes]]:\n        \"\"\"Get the accessed variables for the given scope.\"\"\"\n        return self._scopes.get(scope, {})\n\n\nclass ClassChecker(BaseChecker):\n",
                    "rendered": {
                      "text": "\n    def accessed(self, scope: nodes.ClassDef) -> dict[str, list[_AccessNodes]]:\n        \"\"\"Get the accessed variables for the given scope.\"\"\"\n        return self._scopes.get(scope, {})\n\n\nclass ClassChecker(BaseChecker):\n",
                      "markdown": "`\n    def accessed(self, scope: nodes.ClassDef) -> dict[str, list[_AccessNodes]]:\n        \"\"\"Get the accessed variables for the given scope.\"\"\"\n        return self._scopes.get(scope, {})\n\n\nclass ClassChecker(BaseChecker):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 249,
                  "startColumn": 80,
                  "endLine": 249,
                  "endColumn": 85,
                  "snippet": {
                    "text": "        if not isinstance(overridden_default, original_type):\n            # Two args with same name but different types\n            return True\n        is_same_fn: Callable[[Any, Any], bool] | None = ASTROID_TYPE_COMPARATORS.get(\n            original_type\n        )\n        if is_same_fn is None:\n",
                    "rendered": {
                      "text": "        if not isinstance(overridden_default, original_type):\n            # Two args with same name but different types\n            return True\n        is_same_fn: Callable[[Any, Any], bool] | None = ASTROID_TYPE_COMPARATORS.get(\n            original_type\n        )\n        if is_same_fn is None:\n",
                      "markdown": "`        if not isinstance(overridden_default, original_type):\n            # Two args with same name but different types\n            return True\n        is_same_fn: Callable[[Any, Any], bool] | None = ASTROID_TYPE_COMPARATORS.get(\n            original_type\n        )\n        if is_same_fn is None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 1923,
                  "startColumn": 41,
                  "endLine": 1923,
                  "endColumn": 45,
                  "snippet": {
                    "text": "        if utils.is_node_in_type_annotation_context(node):\n            return\n\n        # Return if `attrname` is defined at the module-level or as a class attribute\n        # and is listed in `exclude-protected`.\n        inferred = safe_infer(node.expr)\n        if (\n",
                    "rendered": {
                      "text": "        if utils.is_node_in_type_annotation_context(node):\n            return\n\n        # Return if `attrname` is defined at the module-level or as a class attribute\n        # and is listed in `exclude-protected`.\n        inferred = safe_infer(node.expr)\n        if (\n",
                      "markdown": "`        if utils.is_node_in_type_annotation_context(node):\n            return\n\n        # Return if `attrname` is defined at the module-level or as a class attribute\n        # and is listed in `exclude-protected`.\n        inferred = safe_infer(node.expr)\n        if (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 1883,
                  "startColumn": 28,
                  "endLine": 1883,
                  "endColumn": 32,
                  "snippet": {
                    "text": "            if func.name == \"classmethod\"\n            else \"no-staticmethod-decorator\"\n        )\n        # assignment must be at a class scope\n        parent_class = node.scope()\n        if not isinstance(parent_class, nodes.ClassDef):\n            return\n",
                    "rendered": {
                      "text": "            if func.name == \"classmethod\"\n            else \"no-staticmethod-decorator\"\n        )\n        # assignment must be at a class scope\n        parent_class = node.scope()\n        if not isinstance(parent_class, nodes.ClassDef):\n            return\n",
                      "markdown": "`            if func.name == \"classmethod\"\n            else \"no-staticmethod-decorator\"\n        )\n        # assignment must be at a class scope\n        parent_class = node.scope()\n        if not isinstance(parent_class, nodes.ClassDef):\n            return\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 1862,
                  "startColumn": 59,
                  "endLine": 1862,
                  "endColumn": 63,
                  "snippet": {
                    "text": "        \"\"\"Checks for uses of classmethod() or staticmethod().\n\n        When a @classmethod or @staticmethod decorator should be used instead.\n        A message will be emitted only if the assignment is at a class scope\n        and only if the classmethod's argument belongs to the class where it\n        is defined.\n        `node` is an assign node.\n",
                    "rendered": {
                      "text": "        \"\"\"Checks for uses of classmethod() or staticmethod().\n\n        When a @classmethod or @staticmethod decorator should be used instead.\n        A message will be emitted only if the assignment is at a class scope\n        and only if the classmethod's argument belongs to the class where it\n        is defined.\n        `node` is an assign node.\n",
                      "markdown": "`        \"\"\"Checks for uses of classmethod() or staticmethod().\n\n        When a @classmethod or @staticmethod decorator should be used instead.\n        A message will be emitted only if the assignment is at a class scope\n        and only if the classmethod's argument belongs to the class where it\n        is defined.\n        `node` is an assign node.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 1676,
                  "startColumn": 65,
                  "endLine": 1676,
                  "endColumn": 69,
                  "snippet": {
                    "text": "            # Check if we have a conflict with a class variable.\n            class_variable = node.locals.get(inferred.value)\n            if class_variable:\n                # Skip annotated assignments which don't conflict at all with slots.\n                if len(class_variable) == 1:\n                    parent = class_variable[0].parent\n                    if isinstance(parent, nodes.AnnAssign) and parent.value is None:\n",
                    "rendered": {
                      "text": "            # Check if we have a conflict with a class variable.\n            class_variable = node.locals.get(inferred.value)\n            if class_variable:\n                # Skip annotated assignments which don't conflict at all with slots.\n                if len(class_variable) == 1:\n                    parent = class_variable[0].parent\n                    if isinstance(parent, nodes.AnnAssign) and parent.value is None:\n",
                      "markdown": "`            # Check if we have a conflict with a class variable.\n            class_variable = node.locals.get(inferred.value)\n            if class_variable:\n                # Skip annotated assignments which don't conflict at all with slots.\n                if len(class_variable) == 1:\n                    parent = class_variable[0].parent\n                    if isinstance(parent, nodes.AnnAssign) and parent.value is None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 1376,
                  "startColumn": 70,
                  "endLine": 1376,
                  "endColumn": 74,
                  "snippet": {
                    "text": "        \"\"\"Check if the given function node is an useless method override.\n\n        We consider it *useless* if it uses the super() builtin, but having\n        nothing additional whatsoever than not implementing the method at all.\n        If the method uses super() to delegate an operation to the rest of the MRO,\n        and if the method called is the same as the current one, the arguments\n        passed to super() are the same as the parameters that were passed to\n",
                    "rendered": {
                      "text": "        \"\"\"Check if the given function node is an useless method override.\n\n        We consider it *useless* if it uses the super() builtin, but having\n        nothing additional whatsoever than not implementing the method at all.\n        If the method uses super() to delegate an operation to the rest of the MRO,\n        and if the method called is the same as the current one, the arguments\n        passed to super() are the same as the parameters that were passed to\n",
                      "markdown": "`        \"\"\"Check if the given function node is an useless method override.\n\n        We consider it *useless* if it uses the super() builtin, but having\n        nothing additional whatsoever than not implementing the method at all.\n        If the method uses super() to delegate an operation to the rest of the MRO,\n        and if the method called is the same as the current one, the arguments\n        passed to super() are the same as the parameters that were passed to\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 703,
                  "startColumn": 40,
                  "endLine": 703,
                  "endColumn": 44,
                  "snippet": {
                    "text": "        'Extending inherited Enum class \"%s\"',\n        \"invalid-enum-extension\",\n        \"Used when a class tries to extend an inherited Enum class. \"\n        \"Doing so will raise a TypeError at runtime.\",\n    ),\n    \"E0245\": (\n        \"No such name %r in __slots__\",\n",
                    "rendered": {
                      "text": "        'Extending inherited Enum class \"%s\"',\n        \"invalid-enum-extension\",\n        \"Used when a class tries to extend an inherited Enum class. \"\n        \"Doing so will raise a TypeError at runtime.\",\n    ),\n    \"E0245\": (\n        \"No such name %r in __slots__\",\n",
                      "markdown": "`        'Extending inherited Enum class \"%s\"',\n        \"invalid-enum-extension\",\n        \"Used when a class tries to extend an inherited Enum class. \"\n        \"Doing so will raise a TypeError at runtime.\",\n    ),\n    \"E0245\": (\n        \"No such name %r in __slots__\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 623,
                  "startColumn": 45,
                  "endLine": 623,
                  "endColumn": 49,
                  "snippet": {
                    "text": "        \"invalid-overridden-method\",\n        \"Used when we detect that a method was overridden in a way \"\n        \"that does not match its base class \"\n        \"which could result in potential bugs at runtime.\",\n    ),\n    \"W0237\": (\n        \"%s %s %r method\",\n",
                    "rendered": {
                      "text": "        \"invalid-overridden-method\",\n        \"Used when we detect that a method was overridden in a way \"\n        \"that does not match its base class \"\n        \"which could result in potential bugs at runtime.\",\n    ),\n    \"W0237\": (\n        \"%s %s %r method\",\n",
                      "markdown": "`        \"invalid-overridden-method\",\n        \"Used when we detect that a method was overridden in a way \"\n        \"that does not match its base class \"\n        \"which could result in potential bugs at runtime.\",\n    ),\n    \"W0237\": (\n        \"%s %s %r method\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 2210,
                  "startColumn": 37,
                  "endLine": 2210,
                  "endColumn": 43,
                  "snippet": {
                    "text": "            self.add_message(message, args=(method_name, valid), node=node)\n\n    def _check_bases_classes(self, node: nodes.ClassDef) -> None:\n        \"\"\"Check that the given class node implements abstract methods from\n        base classes.\n        \"\"\"\n\n",
                    "rendered": {
                      "text": "            self.add_message(message, args=(method_name, valid), node=node)\n\n    def _check_bases_classes(self, node: nodes.ClassDef) -> None:\n        \"\"\"Check that the given class node implements abstract methods from\n        base classes.\n        \"\"\"\n\n",
                      "markdown": "`            self.add_message(message, args=(method_name, valid), node=node)\n\n    def _check_bases_classes(self, node: nodes.ClassDef) -> None:\n        \"\"\"Check that the given class node implements abstract methods from\n        base classes.\n        \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 2097,
                  "startColumn": 39,
                  "endLine": 2097,
                  "endColumn": 45,
                  "snippet": {
                    "text": "                # than we can be\n                if len(defstmts) == 1:\n                    defstmt = defstmts[0]\n                    # check that if the node is accessed in the same method as\n                    # it's defined, it's accessed after the initial assignment\n                    frame = defstmt.frame()\n                    lno = defstmt.fromlineno\n",
                    "rendered": {
                      "text": "                # than we can be\n                if len(defstmts) == 1:\n                    defstmt = defstmts[0]\n                    # check that if the node is accessed in the same method as\n                    # it's defined, it's accessed after the initial assignment\n                    frame = defstmt.frame()\n                    lno = defstmt.fromlineno\n",
                      "markdown": "`                # than we can be\n                if len(defstmts) == 1:\n                    defstmt = defstmts[0]\n                    # check that if the node is accessed in the same method as\n                    # it's defined, it's accessed after the initial assignment\n                    frame = defstmt.frame()\n                    lno = defstmt.fromlineno\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 2021,
                  "startColumn": 36,
                  "endLine": 2021,
                  "endColumn": 42,
                  "snippet": {
                    "text": "\n    @staticmethod\n    def _is_classmethod(func: LocalsDictNodeNG) -> bool:\n        \"\"\"Check if the given *func* node is a class method.\"\"\"\n        return isinstance(func, nodes.FunctionDef) and (\n            func.type == \"classmethod\" or func.name == \"__class_getitem__\"\n        )\n",
                    "rendered": {
                      "text": "\n    @staticmethod\n    def _is_classmethod(func: LocalsDictNodeNG) -> bool:\n        \"\"\"Check if the given *func* node is a class method.\"\"\"\n        return isinstance(func, nodes.FunctionDef) and (\n            func.type == \"classmethod\" or func.name == \"__class_getitem__\"\n        )\n",
                      "markdown": "`\n    @staticmethod\n    def _is_classmethod(func: LocalsDictNodeNG) -> bool:\n        \"\"\"Check if the given *func* node is a class method.\"\"\"\n        return isinstance(func, nodes.FunctionDef) and (\n            func.type == \"classmethod\" or func.name == \"__class_getitem__\"\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 2006,
                  "startColumn": 30,
                  "endLine": 2006,
                  "endColumn": 36,
                  "snippet": {
                    "text": "\n    @staticmethod\n    def _is_called_inside_special_method(node: nodes.NodeNG) -> bool:\n        \"\"\"Returns true if the node is located inside a special (aka dunder) method.\"\"\"\n        frame_name = node.frame().name\n        return frame_name and frame_name in PYMETHODS\n\n",
                    "rendered": {
                      "text": "\n    @staticmethod\n    def _is_called_inside_special_method(node: nodes.NodeNG) -> bool:\n        \"\"\"Returns true if the node is located inside a special (aka dunder) method.\"\"\"\n        frame_name = node.frame().name\n        return frame_name and frame_name in PYMETHODS\n\n",
                      "markdown": "`\n    @staticmethod\n    def _is_called_inside_special_method(node: nodes.NodeNG) -> bool:\n        \"\"\"Returns true if the node is located inside a special (aka dunder) method.\"\"\"\n        frame_name = node.frame().name\n        return frame_name and frame_name in PYMETHODS\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 1903,
                  "startColumn": 35,
                  "endLine": 1903,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        \"\"\"Given an attribute access node (set or get), check if attribute\n        access is legitimate.\n\n        Call _check_first_attr with node before calling\n        this method. Valid cases are:\n        * self._attr in a method or cls._attr in a classmethod. Checked by\n        _check_first_attr.\n",
                    "rendered": {
                      "text": "        \"\"\"Given an attribute access node (set or get), check if attribute\n        access is legitimate.\n\n        Call _check_first_attr with node before calling\n        this method. Valid cases are:\n        * self._attr in a method or cls._attr in a classmethod. Checked by\n        _check_first_attr.\n",
                      "markdown": "`        \"\"\"Given an attribute access node (set or get), check if attribute\n        access is legitimate.\n\n        Call _check_first_attr with node before calling\n        this method. Valid cases are:\n        * self._attr in a method or cls._attr in a classmethod. Checked by\n        _check_first_attr.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 1900,
                  "startColumn": 36,
                  "endLine": 1900,
                  "endColumn": 42,
                  "snippet": {
                    "text": "    def _check_protected_attribute_access(\n        self, node: nodes.Attribute | nodes.AssignAttr\n    ) -> None:\n        \"\"\"Given an attribute access node (set or get), check if attribute\n        access is legitimate.\n\n        Call _check_first_attr with node before calling\n",
                    "rendered": {
                      "text": "    def _check_protected_attribute_access(\n        self, node: nodes.Attribute | nodes.AssignAttr\n    ) -> None:\n        \"\"\"Given an attribute access node (set or get), check if attribute\n        access is legitimate.\n\n        Call _check_first_attr with node before calling\n",
                      "markdown": "`    def _check_protected_attribute_access(\n        self, node: nodes.Attribute | nodes.AssignAttr\n    ) -> None:\n        \"\"\"Given an attribute access node (set or get), check if attribute\n        access is legitimate.\n\n        Call _check_first_attr with node before calling\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 1850,
                  "startColumn": 7,
                  "endLine": 1850,
                  "endColumn": 13,
                  "snippet": {
                    "text": "    )\n    def visit_assign(self, assign_node: nodes.Assign) -> None:\n        self._check_classmethod_declaration(assign_node)\n        node = assign_node.targets[0]\n        if not isinstance(node, nodes.AssignAttr):\n            return\n\n",
                    "rendered": {
                      "text": "    )\n    def visit_assign(self, assign_node: nodes.Assign) -> None:\n        self._check_classmethod_declaration(assign_node)\n        node = assign_node.targets[0]\n        if not isinstance(node, nodes.AssignAttr):\n            return\n\n",
                      "markdown": "`    )\n    def visit_assign(self, assign_node: nodes.Assign) -> None:\n        self._check_classmethod_declaration(assign_node)\n        node = assign_node.targets[0]\n        if not isinstance(node, nodes.AssignAttr):\n            return\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 1771,
                  "startColumn": 42,
                  "endLine": 1772,
                  "snippet": {
                    "text": "        )\n\n    def _check_in_slots(self, node: nodes.AssignAttr) -> None:\n        \"\"\"Check that the given AssignAttr node\n        is defined in the class slots.\n        \"\"\"\n        inferred = safe_infer(node.expr)\n        if not isinstance(inferred, astroid.Instance):\n",
                    "rendered": {
                      "text": "        )\n\n    def _check_in_slots(self, node: nodes.AssignAttr) -> None:\n        \"\"\"Check that the given AssignAttr node\n        is defined in the class slots.\n        \"\"\"\n        inferred = safe_infer(node.expr)\n        if not isinstance(inferred, astroid.Instance):\n",
                      "markdown": "`        )\n\n    def _check_in_slots(self, node: nodes.AssignAttr) -> None:\n        \"\"\"Check that the given AssignAttr node\n        is defined in the class slots.\n        \"\"\"\n        inferred = safe_infer(node.expr)\n        if not isinstance(inferred, astroid.Instance):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 1751,
                  "startColumn": 68,
                  "endLine": 1751,
                  "endColumn": 74,
                  "snippet": {
                    "text": "                if hasattr(elt, \"attrname\") and elt.attrname == \"__class__\":\n                    class_index = i\n            if class_index == -1:\n                # This should not happen because we checked that the node name\n                # is '__class__' earlier, but let's not be too confident here\n                return  # pragma: no cover\n            inferred = safe_infer(node.parent.parent.value.elts[class_index])\n",
                    "rendered": {
                      "text": "                if hasattr(elt, \"attrname\") and elt.attrname == \"__class__\":\n                    class_index = i\n            if class_index == -1:\n                # This should not happen because we checked that the node name\n                # is '__class__' earlier, but let's not be too confident here\n                return  # pragma: no cover\n            inferred = safe_infer(node.parent.parent.value.elts[class_index])\n",
                      "markdown": "`                if hasattr(elt, \"attrname\") and elt.attrname == \"__class__\":\n                    class_index = i\n            if class_index == -1:\n                # This should not happen because we checked that the node name\n                # is '__class__' earlier, but let's not be too confident here\n                return  # pragma: no cover\n            inferred = safe_infer(node.parent.parent.value.elts[class_index])\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 1373,
                  "startColumn": 38,
                  "endLine": 1373,
                  "endColumn": 44,
                  "snippet": {
                    "text": "    visit_asyncfunctiondef = visit_functiondef\n\n    def _check_useless_super_delegation(self, function: nodes.FunctionDef) -> None:\n        \"\"\"Check if the given function node is an useless method override.\n\n        We consider it *useless* if it uses the super() builtin, but having\n        nothing additional whatsoever than not implementing the method at all.\n",
                    "rendered": {
                      "text": "    visit_asyncfunctiondef = visit_functiondef\n\n    def _check_useless_super_delegation(self, function: nodes.FunctionDef) -> None:\n        \"\"\"Check if the given function node is an useless method override.\n\n        We consider it *useless* if it uses the super() builtin, but having\n        nothing additional whatsoever than not implementing the method at all.\n",
                      "markdown": "`    visit_asyncfunctiondef = visit_functiondef\n\n    def _check_useless_super_delegation(self, function: nodes.FunctionDef) -> None:\n        \"\"\"Check if the given function node is an useless method override.\n\n        We consider it *useless* if it uses the super() builtin, but having\n        nothing additional whatsoever than not implementing the method at all.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 1257,
                  "startColumn": 23,
                  "endLine": 1257,
                  "endColumn": 29,
                  "snippet": {
                    "text": "                try:\n                    cnode.local_attr(attr)\n                except astroid.NotFoundError:\n                    for node in nodes_lst:\n                        if node.frame().name not in defining_methods:\n                            # If the attribute was set by a call in any\n                            # of the defining methods, then don't emit\n",
                    "rendered": {
                      "text": "                try:\n                    cnode.local_attr(attr)\n                except astroid.NotFoundError:\n                    for node in nodes_lst:\n                        if node.frame().name not in defining_methods:\n                            # If the attribute was set by a call in any\n                            # of the defining methods, then don't emit\n",
                      "markdown": "`                try:\n                    cnode.local_attr(attr)\n                except astroid.NotFoundError:\n                    for node in nodes_lst:\n                        if node.frame().name not in defining_methods:\n                            # If the attribute was set by a call in any\n                            # of the defining methods, then don't emit\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 1246,
                  "startColumn": 19,
                  "endLine": 1246,
                  "endColumn": 25,
                  "snippet": {
                    "text": "            for parent in cnode.instance_attr_ancestors(attr):\n                attr_defined = False\n                # check if any parent method attr is defined in is a defining method\n                for node in parent.instance_attrs[attr]:\n                    if node.frame().name in defining_methods:\n                        attr_defined = True\n                if attr_defined:\n",
                    "rendered": {
                      "text": "            for parent in cnode.instance_attr_ancestors(attr):\n                attr_defined = False\n                # check if any parent method attr is defined in is a defining method\n                for node in parent.instance_attrs[attr]:\n                    if node.frame().name in defining_methods:\n                        attr_defined = True\n                if attr_defined:\n",
                      "markdown": "`            for parent in cnode.instance_attr_ancestors(attr):\n                attr_defined = False\n                # check if any parent method attr is defined in is a defining method\n                for node in parent.instance_attrs[attr]:\n                    if node.frame().name in defining_methods:\n                        attr_defined = True\n                if attr_defined:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 1235,
                  "startColumn": 38,
                  "endLine": 1235,
                  "endColumn": 44,
                  "snippet": {
                    "text": "\n            # Check if any method attr is defined in is a defining method\n            # or if we have the attribute defined in a setter.\n            frames = (node.frame() for node in nodes_lst)\n            if any(\n                frame.name in defining_methods or is_property_setter(frame)\n                for frame in frames\n",
                    "rendered": {
                      "text": "\n            # Check if any method attr is defined in is a defining method\n            # or if we have the attribute defined in a setter.\n            frames = (node.frame() for node in nodes_lst)\n            if any(\n                frame.name in defining_methods or is_property_setter(frame)\n                for frame in frames\n",
                      "markdown": "`\n            # Check if any method attr is defined in is a defining method\n            # or if we have the attribute defined in a setter.\n            frames = (node.frame() for node in nodes_lst)\n            if any(\n                frame.name in defining_methods or is_property_setter(frame)\n                for frame in frames\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 901,
                  "startColumn": 20,
                  "endLine": 901,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        if not slot_names:\n            return\n\n        # Stop if we find __dict__, since this means attributes can be set\n        # dynamically\n        if \"__dict__\" in slot_names:\n            return\n",
                    "rendered": {
                      "text": "        if not slot_names:\n            return\n\n        # Stop if we find __dict__, since this means attributes can be set\n        # dynamically\n        if \"__dict__\" in slot_names:\n            return\n",
                      "markdown": "`        if not slot_names:\n            return\n\n        # Stop if we find __dict__, since this means attributes can be set\n        # dynamically\n        if \"__dict__\" in slot_names:\n            return\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 758,
                  "startColumn": 17,
                  "endLine": 758,
                  "endColumn": 23,
                  "snippet": {
                    "text": "        \"\"\"Set the given node as accessed.\"\"\"\n        frame = node_frame_class(node)\n        if frame is None:\n            # The node does not live in a class.\n            return\n        self._scopes[frame][node.attrname].append(node)\n\n",
                    "rendered": {
                      "text": "        \"\"\"Set the given node as accessed.\"\"\"\n        frame = node_frame_class(node)\n        if frame is None:\n            # The node does not live in a class.\n            return\n        self._scopes[frame][node.attrname].append(node)\n\n",
                      "markdown": "`        \"\"\"Set the given node as accessed.\"\"\"\n        frame = node_frame_class(node)\n        if frame is None:\n            # The node does not live in a class.\n            return\n        self._scopes[frame][node.attrname].append(node)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/classes/class_checker.py"
                },
                "region": {
                  "startLine": 755,
                  "startColumn": 24,
                  "endLine": 755,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        ] = defaultdict(_scope_default)\n\n    def set_accessed(self, node: _AccessNodes) -> None:\n        \"\"\"Set the given node as accessed.\"\"\"\n        frame = node_frame_class(node)\n        if frame is None:\n            # The node does not live in a class.\n",
                    "rendered": {
                      "text": "        ] = defaultdict(_scope_default)\n\n    def set_accessed(self, node: _AccessNodes) -> None:\n        \"\"\"Set the given node as accessed.\"\"\"\n        frame = node_frame_class(node)\n        if frame is None:\n            # The node does not live in a class.\n",
                      "markdown": "`        ] = defaultdict(_scope_default)\n\n    def set_accessed(self, node: _AccessNodes) -> None:\n        \"\"\"Set the given node as accessed.\"\"\"\n        frame = node_frame_class(node)\n        if frame is None:\n            # The node does not live in a class.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/configuration_test.py"
                },
                "region": {
                  "startLine": 92,
                  "startColumn": 11,
                  "endLine": 92,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    \"\"\"Get the expected output of a functional test.\"\"\"\n    exit_code = 0\n    msg = (\n        \"we expect a single file of the form 'filename.32.out' where 'filename' represents \"\n        \"the name of the configuration file, and '32' the expected error code.\"\n    )\n    possible_out_files = get_related_files(configuration_path, suffix_filter=\"out\")\n",
                    "rendered": {
                      "text": "    \"\"\"Get the expected output of a functional test.\"\"\"\n    exit_code = 0\n    msg = (\n        \"we expect a single file of the form 'filename.32.out' where 'filename' represents \"\n        \"the name of the configuration file, and '32' the expected error code.\"\n    )\n    possible_out_files = get_related_files(configuration_path, suffix_filter=\"out\")\n",
                      "markdown": "`    \"\"\"Get the expected output of a functional test.\"\"\"\n    exit_code = 0\n    msg = (\n        \"we expect a single file of the form 'filename.32.out' where 'filename' represents \"\n        \"the name of the configuration file, and '32' the expected error code.\"\n    )\n    possible_out_files = get_related_files(configuration_path, suffix_filter=\"out\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/plantuml_printer.py"
                },
                "region": {
                  "startLine": 91,
                  "startColumn": 34,
                  "endLine": 91,
                  "endColumn": 40,
                  "snippet": {
                    "text": "        type_: EdgeType,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Create an edge from one node to another to display relationships.\"\"\"\n        edge = f\"{from_node} {self.ARROWS[type_]} {to_node}\"\n        if label:\n            edge += f\" : {label}\"\n",
                    "rendered": {
                      "text": "        type_: EdgeType,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Create an edge from one node to another to display relationships.\"\"\"\n        edge = f\"{from_node} {self.ARROWS[type_]} {to_node}\"\n        if label:\n            edge += f\" : {label}\"\n",
                      "markdown": "`        type_: EdgeType,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Create an edge from one node to another to display relationships.\"\"\"\n        edge = f\"{from_node} {self.ARROWS[type_]} {to_node}\"\n        if label:\n            edge += f\" : {label}\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/plantuml_printer.py"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 47,
                  "endLine": 43,
                  "endColumn": 52,
                  "snippet": {
                    "text": "            else:\n                raise ValueError(\n                    f\"Unsupported layout {self.layout}. PlantUmlPrinter only \"\n                    \"supports left to right and top to bottom layout.\"\n                )\n\n    def emit_node(\n",
                    "rendered": {
                      "text": "            else:\n                raise ValueError(\n                    f\"Unsupported layout {self.layout}. PlantUmlPrinter only \"\n                    \"supports left to right and top to bottom layout.\"\n                )\n\n    def emit_node(\n",
                      "markdown": "`            else:\n                raise ValueError(\n                    f\"Unsupported layout {self.layout}. PlantUmlPrinter only \"\n                    \"supports left to right and top to bottom layout.\"\n                )\n\n    def emit_node(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/mermaidjs_printer.py"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 34,
                  "endLine": 75,
                  "endColumn": 40,
                  "snippet": {
                    "text": "        type_: EdgeType,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Create an edge from one node to another to display relationships.\"\"\"\n        from_node = from_node.split(\".\")[-1]\n        to_node = to_node.split(\".\")[-1]\n        edge = f\"{from_node} {self.ARROWS[type_]} {to_node}\"\n",
                    "rendered": {
                      "text": "        type_: EdgeType,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Create an edge from one node to another to display relationships.\"\"\"\n        from_node = from_node.split(\".\")[-1]\n        to_node = to_node.split(\".\")[-1]\n        edge = f\"{from_node} {self.ARROWS[type_]} {to_node}\"\n",
                      "markdown": "`        type_: EdgeType,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Create an edge from one node to another to display relationships.\"\"\"\n        from_node = from_node.split(\".\")[-1]\n        to_node = to_node.split(\".\")[-1]\n        edge = f\"{from_node} {self.ARROWS[type_]} {to_node}\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/inspector.py"
                },
                "region": {
                  "startLine": 306,
                  "startColumn": 6,
                  "endLine": 306,
                  "endColumn": 14,
                  "snippet": {
                    "text": "class AbstractAssociationHandler(AssociationHandlerInterface):\n    \"\"\"\n    Chain of Responsibility for handling types of association, useful\n    to expand in the future if we want to add more distinct associations.\n\n    Every link of the chain checks if it's a certain type of association.\n    If no association is found it's set as a generic association in `associations_type`.\n",
                    "rendered": {
                      "text": "class AbstractAssociationHandler(AssociationHandlerInterface):\n    \"\"\"\n    Chain of Responsibility for handling types of association, useful\n    to expand in the future if we want to add more distinct associations.\n\n    Every link of the chain checks if it's a certain type of association.\n    If no association is found it's set as a generic association in `associations_type`.\n",
                      "markdown": "`class AbstractAssociationHandler(AssociationHandlerInterface):\n    \"\"\"\n    Chain of Responsibility for handling types of association, useful\n    to expand in the future if we want to add more distinct associations.\n\n    Every link of the chain checks if it's a certain type of association.\n    If no association is found it's set as a generic association in `associations_type`.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/inspector.py"
                },
                "region": {
                  "startLine": 88,
                  "startColumn": 39,
                  "endLine": 88,
                  "endColumn": 43,
                  "snippet": {
                    "text": "        return self.modules\n\n    def __repr__(self) -> str:\n        return f\"<Project {self.name!r} at {id(self)} ({len(self.modules)} modules)>\"\n\n\nclass Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n",
                    "rendered": {
                      "text": "        return self.modules\n\n    def __repr__(self) -> str:\n        return f\"<Project {self.name!r} at {id(self)} ({len(self.modules)} modules)>\"\n\n\nclass Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n",
                      "markdown": "`        return self.modules\n\n    def __repr__(self) -> str:\n        return f\"<Project {self.name!r} at {id(self)} ({len(self.modules)} modules)>\"\n\n\nclass Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/inspector.py"
                },
                "region": {
                  "startLine": 306,
                  "startColumn": 6,
                  "endLine": 306,
                  "endColumn": 14,
                  "snippet": {
                    "text": "class AbstractAssociationHandler(AssociationHandlerInterface):\n    \"\"\"\n    Chain of Responsibility for handling types of association, useful\n    to expand in the future if we want to add more distinct associations.\n\n    Every link of the chain checks if it's a certain type of association.\n    If no association is found it's set as a generic association in `associations_type`.\n",
                    "rendered": {
                      "text": "class AbstractAssociationHandler(AssociationHandlerInterface):\n    \"\"\"\n    Chain of Responsibility for handling types of association, useful\n    to expand in the future if we want to add more distinct associations.\n\n    Every link of the chain checks if it's a certain type of association.\n    If no association is found it's set as a generic association in `associations_type`.\n",
                      "markdown": "`class AbstractAssociationHandler(AssociationHandlerInterface):\n    \"\"\"\n    Chain of Responsibility for handling types of association, useful\n    to expand in the future if we want to add more distinct associations.\n\n    Every link of the chain checks if it's a certain type of association.\n    If no association is found it's set as a generic association in `associations_type`.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/inspector.py"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 28,
                  "endLine": 182,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        \"\"\"Visit an astroid.Function node.\n\n        * set the locals_type mapping\n        * optionally tag the node with a unique id\n        \"\"\"\n        if hasattr(node, \"locals_type\"):\n            return\n",
                    "rendered": {
                      "text": "        \"\"\"Visit an astroid.Function node.\n\n        * set the locals_type mapping\n        * optionally tag the node with a unique id\n        \"\"\"\n        if hasattr(node, \"locals_type\"):\n            return\n",
                      "markdown": "`        \"\"\"Visit an astroid.Function node.\n\n        * set the locals_type mapping\n        * optionally tag the node with a unique id\n        \"\"\"\n        if hasattr(node, \"locals_type\"):\n            return\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/inspector.py"
                },
                "region": {
                  "startLine": 156,
                  "startColumn": 28,
                  "endLine": 156,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        \"\"\"Visit an astroid.Class node.\n\n        * set the locals_type and instance_attrs_type mappings\n        * optionally tag the node with a unique id\n        \"\"\"\n        if hasattr(node, \"locals_type\"):\n            return\n",
                    "rendered": {
                      "text": "        \"\"\"Visit an astroid.Class node.\n\n        * set the locals_type and instance_attrs_type mappings\n        * optionally tag the node with a unique id\n        \"\"\"\n        if hasattr(node, \"locals_type\"):\n            return\n",
                      "markdown": "`        \"\"\"Visit an astroid.Class node.\n\n        * set the locals_type and instance_attrs_type mappings\n        * optionally tag the node with a unique id\n        \"\"\"\n        if hasattr(node, \"locals_type\"):\n            return\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/inspector.py"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 28,
                  "endLine": 142,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\n        * set the locals_type mapping\n        * set the depends mapping\n        * optionally tag the node with a unique id\n        \"\"\"\n        if hasattr(node, \"locals_type\"):\n            return\n",
                    "rendered": {
                      "text": "\n        * set the locals_type mapping\n        * set the depends mapping\n        * optionally tag the node with a unique id\n        \"\"\"\n        if hasattr(node, \"locals_type\"):\n            return\n",
                      "markdown": "`\n        * set the locals_type mapping\n        * set the depends mapping\n        * optionally tag the node with a unique id\n        \"\"\"\n        if hasattr(node, \"locals_type\"):\n            return\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/inspector.py"
                },
                "region": {
                  "startLine": 130,
                  "startColumn": 28,
                  "endLine": 130,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    def visit_project(self, node: Project) -> None:\n        \"\"\"Visit a pyreverse.utils.Project node.\n\n        * optionally tag the node with a unique id\n        \"\"\"\n        if self.tag:\n            node.uid = self.generate_id()\n",
                    "rendered": {
                      "text": "    def visit_project(self, node: Project) -> None:\n        \"\"\"Visit a pyreverse.utils.Project node.\n\n        * optionally tag the node with a unique id\n        \"\"\"\n        if self.tag:\n            node.uid = self.generate_id()\n",
                      "markdown": "`    def visit_project(self, node: Project) -> None:\n        \"\"\"Visit a pyreverse.utils.Project node.\n\n        * optionally tag the node with a unique id\n        \"\"\"\n        if self.tag:\n            node.uid = self.generate_id()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/inspector.py"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 57,
                  "endLine": 105,
                  "snippet": {
                    "text": "\n    * Function\n      a mapping from locals names to their bounded value, which may be a\n      constant like a string or an integer, or an astroid node\n      (on astroid.Module, astroid.Class and astroid.Function).\n\n    * instance_attrs_type\n      as locals_type but for klass member attributes (only on astroid.Class)\n",
                    "rendered": {
                      "text": "\n    * Function\n      a mapping from locals names to their bounded value, which may be a\n      constant like a string or an integer, or an astroid node\n      (on astroid.Module, astroid.Class and astroid.Function).\n\n    * instance_attrs_type\n      as locals_type but for klass member attributes (only on astroid.Class)\n",
                      "markdown": "`\n    * Function\n      a mapping from locals names to their bounded value, which may be a\n      constant like a string or an integer, or an astroid node\n      (on astroid.Module, astroid.Class and astroid.Function).\n\n    * instance_attrs_type\n      as locals_type but for klass member attributes (only on astroid.Class)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/inspector.py"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 33,
                  "endLine": 98,
                  "endColumn": 39,
                  "snippet": {
                    "text": "    added to visited nodes:\n\n    * uid,\n      a unique identifier for the node (on astroid.Project, astroid.Module,\n      astroid.Class and astroid.locals_type). Only if the linker\n      has been instantiated with tag=True parameter (False by default).\n\n",
                    "rendered": {
                      "text": "    added to visited nodes:\n\n    * uid,\n      a unique identifier for the node (on astroid.Project, astroid.Module,\n      astroid.Class and astroid.locals_type). Only if the linker\n      has been instantiated with tag=True parameter (False by default).\n\n",
                      "markdown": "`    added to visited nodes:\n\n    * uid,\n      a unique identifier for the node (on astroid.Project, astroid.Module,\n      astroid.Class and astroid.locals_type). Only if the linker\n      has been instantiated with tag=True parameter (False by default).\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/inspector.py"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 32,
                  "endLine": 79,
                  "snippet": {
                    "text": "        self.items = self.locals.items\n\n    def add_module(self, node: nodes.Module) -> None:\n        self.locals[node.name] = node\n        self.modules.append(node)\n\n    def get_module(self, name: str) -> nodes.Module:\n        return self.locals[name]\n",
                    "rendered": {
                      "text": "        self.items = self.locals.items\n\n    def add_module(self, node: nodes.Module) -> None:\n        self.locals[node.name] = node\n        self.modules.append(node)\n\n    def get_module(self, name: str) -> nodes.Module:\n        return self.locals[name]\n",
                      "markdown": "`        self.items = self.locals.items\n\n    def add_module(self, node: nodes.Module) -> None:\n        self.locals[node.name] = node\n        self.modules.append(node)\n\n    def get_module(self, name: str) -> nodes.Module:\n        return self.locals[name]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/dot_printer.py"
                },
                "region": {
                  "startLine": 147,
                  "startColumn": 34,
                  "endLine": 147,
                  "endColumn": 40,
                  "snippet": {
                    "text": "        type_: EdgeType,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Create an edge from one node to another to display relationships.\"\"\"\n        arrowstyle = ARROWS[type_]\n        attrs = [f'{prop}=\"{value}\"' for prop, value in arrowstyle.items()]\n        if label:\n",
                    "rendered": {
                      "text": "        type_: EdgeType,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Create an edge from one node to another to display relationships.\"\"\"\n        arrowstyle = ARROWS[type_]\n        attrs = [f'{prop}=\"{value}\"' for prop, value in arrowstyle.items()]\n        if label:\n",
                      "markdown": "`        type_: EdgeType,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Create an edge from one node to another to display relationships.\"\"\"\n        arrowstyle = ARROWS[type_]\n        attrs = [f'{prop}=\"{value}\"' for prop, value in arrowstyle.items()]\n        if label:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/diagrams.py"
                },
                "region": {
                  "startLine": 116,
                  "startColumn": 37,
                  "endLine": 116,
                  "endColumn": 42,
                  "snippet": {
                    "text": "        self, from_object: DiagramEntity, relation_type: str\n    ) -> Relationship:\n        \"\"\"Return a relationship or None.\"\"\"\n        for rel in self.relationships.get(relation_type, ()):\n            if rel.from_object is from_object:\n                return rel\n        raise KeyError(relation_type)\n",
                    "rendered": {
                      "text": "        self, from_object: DiagramEntity, relation_type: str\n    ) -> Relationship:\n        \"\"\"Return a relationship or None.\"\"\"\n        for rel in self.relationships.get(relation_type, ()):\n            if rel.from_object is from_object:\n                return rel\n        raise KeyError(relation_type)\n",
                      "markdown": "`        self, from_object: DiagramEntity, relation_type: str\n    ) -> Relationship:\n        \"\"\"Return a relationship or None.\"\"\"\n        for rel in self.relationships.get(relation_type, ()):\n            if rel.from_object is from_object:\n                return rel\n        raise KeyError(relation_type)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/diagrams.py"
                },
                "region": {
                  "startLine": 97,
                  "startColumn": 30,
                  "endLine": 97,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    def get_relationships(self, role: str) -> Iterable[Relationship]:\n        # sorted to get predictable (hence testable) results\n        return sorted(\n            self.relationships.get(role, ()),\n            key=lambda x: (x.from_object.fig_id, x.to_object.fig_id),\n        )\n\n",
                    "rendered": {
                      "text": "    def get_relationships(self, role: str) -> Iterable[Relationship]:\n        # sorted to get predictable (hence testable) results\n        return sorted(\n            self.relationships.get(role, ()),\n            key=lambda x: (x.from_object.fig_id, x.to_object.fig_id),\n        )\n\n",
                      "markdown": "`    def get_relationships(self, role: str) -> Iterable[Relationship]:\n        # sorted to get predictable (hence testable) results\n        return sorted(\n            self.relationships.get(role, ()),\n            key=lambda x: (x.from_object.fig_id, x.to_object.fig_id),\n        )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/diagrams.py"
                },
                "region": {
                  "startLine": 272,
                  "startColumn": 14,
                  "endLine": 272,
                  "endColumn": 20,
                  "snippet": {
                    "text": "\n    def add_object(self, title: str, node: nodes.Module) -> None:\n        \"\"\"Create a diagram object.\"\"\"\n        assert node not in self._nodes\n        ent = PackageEntity(title, node)\n        self._nodes[node] = ent\n        self.objects.append(ent)\n",
                    "rendered": {
                      "text": "\n    def add_object(self, title: str, node: nodes.Module) -> None:\n        \"\"\"Create a diagram object.\"\"\"\n        assert node not in self._nodes\n        ent = PackageEntity(title, node)\n        self._nodes[node] = ent\n        self.objects.append(ent)\n",
                      "markdown": "`\n    def add_object(self, title: str, node: nodes.Module) -> None:\n        \"\"\"Create a diagram object.\"\"\"\n        assert node not in self._nodes\n        ent = PackageEntity(title, node)\n        self._nodes[node] = ent\n        self.objects.append(ent)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/diagrams.py"
                },
                "region": {
                  "startLine": 209,
                  "startColumn": 11,
                  "endLine": 209,
                  "endColumn": 17,
                  "snippet": {
                    "text": "    def extract_relationships(self) -> None:\n        \"\"\"Extract relationships between nodes in the diagram.\"\"\"\n        for obj in self.classes():\n            node = obj.node\n            obj.attrs = self.get_attrs(node)\n            obj.methods = self.get_methods(node)\n            obj.shape = \"class\"\n",
                    "rendered": {
                      "text": "    def extract_relationships(self) -> None:\n        \"\"\"Extract relationships between nodes in the diagram.\"\"\"\n        for obj in self.classes():\n            node = obj.node\n            obj.attrs = self.get_attrs(node)\n            obj.methods = self.get_methods(node)\n            obj.shape = \"class\"\n",
                      "markdown": "`    def extract_relationships(self) -> None:\n        \"\"\"Extract relationships between nodes in the diagram.\"\"\"\n        for obj in self.classes():\n            node = obj.node\n            obj.attrs = self.get_attrs(node)\n            obj.methods = self.get_methods(node)\n            obj.shape = \"class\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/diagrams.py"
                },
                "region": {
                  "startLine": 189,
                  "startColumn": 14,
                  "endLine": 189,
                  "endColumn": 20,
                  "snippet": {
                    "text": "\n    def has_node(self, node: nodes.NodeNG) -> bool:\n        \"\"\"Return true if the given node is included in the diagram.\"\"\"\n        return node in self._nodes\n\n    def object_from_node(self, node: nodes.NodeNG) -> DiagramEntity:\n        \"\"\"Return the diagram object mapped to node.\"\"\"\n",
                    "rendered": {
                      "text": "\n    def has_node(self, node: nodes.NodeNG) -> bool:\n        \"\"\"Return true if the given node is included in the diagram.\"\"\"\n        return node in self._nodes\n\n    def object_from_node(self, node: nodes.NodeNG) -> DiagramEntity:\n        \"\"\"Return the diagram object mapped to node.\"\"\"\n",
                      "markdown": "`\n    def has_node(self, node: nodes.NodeNG) -> bool:\n        \"\"\"Return true if the given node is included in the diagram.\"\"\"\n        return node in self._nodes\n\n    def object_from_node(self, node: nodes.NodeNG) -> DiagramEntity:\n        \"\"\"Return the diagram object mapped to node.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/diagrams.py"
                },
                "region": {
                  "startLine": 188,
                  "startColumn": 35,
                  "endLine": 188,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        )\n\n    def has_node(self, node: nodes.NodeNG) -> bool:\n        \"\"\"Return true if the given node is included in the diagram.\"\"\"\n        return node in self._nodes\n\n    def object_from_node(self, node: nodes.NodeNG) -> DiagramEntity:\n",
                    "rendered": {
                      "text": "        )\n\n    def has_node(self, node: nodes.NodeNG) -> bool:\n        \"\"\"Return true if the given node is included in the diagram.\"\"\"\n        return node in self._nodes\n\n    def object_from_node(self, node: nodes.NodeNG) -> DiagramEntity:\n",
                      "markdown": "`        )\n\n    def has_node(self, node: nodes.NodeNG) -> bool:\n        \"\"\"Return true if the given node is included in the diagram.\"\"\"\n        return node in self._nodes\n\n    def object_from_node(self, node: nodes.NodeNG) -> DiagramEntity:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/diagrams.py"
                },
                "region": {
                  "startLine": 169,
                  "startColumn": 15,
                  "endLine": 169,
                  "endColumn": 21,
                  "snippet": {
                    "text": "        names = []\n        for node in nodes_lst:\n            if isinstance(node, astroid.Instance):\n                node = node._proxied\n            if (\n                isinstance(\n                    node, (nodes.ClassDef, nodes.Name, nodes.Subscript, nodes.BinOp)\n",
                    "rendered": {
                      "text": "        names = []\n        for node in nodes_lst:\n            if isinstance(node, astroid.Instance):\n                node = node._proxied\n            if (\n                isinstance(\n                    node, (nodes.ClassDef, nodes.Name, nodes.Subscript, nodes.BinOp)\n",
                      "markdown": "`        names = []\n        for node in nodes_lst:\n            if isinstance(node, astroid.Instance):\n                node = node._proxied\n            if (\n                isinstance(\n                    node, (nodes.ClassDef, nodes.Name, nodes.Subscript, nodes.BinOp)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/diagrams.py"
                },
                "region": {
                  "startLine": 167,
                  "startColumn": 11,
                  "endLine": 167,
                  "endColumn": 17,
                  "snippet": {
                    "text": "    def class_names(self, nodes_lst: Iterable[nodes.NodeNG]) -> list[str]:\n        \"\"\"Return class names if needed in diagram.\"\"\"\n        names = []\n        for node in nodes_lst:\n            if isinstance(node, astroid.Instance):\n                node = node._proxied\n            if (\n",
                    "rendered": {
                      "text": "    def class_names(self, nodes_lst: Iterable[nodes.NodeNG]) -> list[str]:\n        \"\"\"Return class names if needed in diagram.\"\"\"\n        names = []\n        for node in nodes_lst:\n            if isinstance(node, astroid.Instance):\n                node = node._proxied\n            if (\n",
                      "markdown": "`    def class_names(self, nodes_lst: Iterable[nodes.NodeNG]) -> list[str]:\n        \"\"\"Return class names if needed in diagram.\"\"\"\n        names = []\n        for node in nodes_lst:\n            if isinstance(node, astroid.Instance):\n                node = node._proxied\n            if (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/diagrams.py"
                },
                "region": {
                  "startLine": 159,
                  "startColumn": 14,
                  "endLine": 159,
                  "endColumn": 20,
                  "snippet": {
                    "text": "\n    def add_object(self, title: str, node: nodes.ClassDef) -> None:\n        \"\"\"Create a diagram object.\"\"\"\n        assert node not in self._nodes\n        ent = ClassEntity(title, node)\n        self._nodes[node] = ent\n        self.objects.append(ent)\n",
                    "rendered": {
                      "text": "\n    def add_object(self, title: str, node: nodes.ClassDef) -> None:\n        \"\"\"Create a diagram object.\"\"\"\n        assert node not in self._nodes\n        ent = ClassEntity(title, node)\n        self._nodes[node] = ent\n        self.objects.append(ent)\n",
                      "markdown": "`\n    def add_object(self, title: str, node: nodes.ClassDef) -> None:\n        \"\"\"Create a diagram object.\"\"\"\n        assert node not in self._nodes\n        ent = ClassEntity(title, node)\n        self._nodes[node] = ent\n        self.objects.append(ent)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/diagrams.py"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 33,
                  "endLine": 53,
                  "endColumn": 39,
                  "snippet": {
                    "text": "    ) -> None:\n        super().__init__()\n        self.title = title\n        self.node: nodes.NodeNG = node or nodes.NodeNG(\n            lineno=None,\n            col_offset=None,\n            end_lineno=None,\n",
                    "rendered": {
                      "text": "    ) -> None:\n        super().__init__()\n        self.title = title\n        self.node: nodes.NodeNG = node or nodes.NodeNG(\n            lineno=None,\n            col_offset=None,\n            end_lineno=None,\n",
                      "markdown": "`    ) -> None:\n        super().__init__()\n        self.title = title\n        self.node: nodes.NodeNG = node or nodes.NodeNG(\n            lineno=None,\n            col_offset=None,\n            end_lineno=None,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/diadefslib.py"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 11,
                  "endLine": 123,
                  "endColumn": 17,
                  "snippet": {
                    "text": "        for ancestor in self.get_ancestors(klass_node, anc_level):\n            self.extract_classes(ancestor, anc_level - 1, association_level)\n\n        for node in self.get_associated(klass_node, association_level):\n            self.extract_classes(node, anc_level, association_level - 1)\n\n\n",
                    "rendered": {
                      "text": "        for ancestor in self.get_ancestors(klass_node, anc_level):\n            self.extract_classes(ancestor, anc_level - 1, association_level)\n\n        for node in self.get_associated(klass_node, association_level):\n            self.extract_classes(node, anc_level, association_level - 1)\n\n\n",
                      "markdown": "`        for ancestor in self.get_ancestors(klass_node, anc_level):\n            self.extract_classes(ancestor, anc_level - 1, association_level)\n\n        for node in self.get_associated(klass_node, association_level):\n            self.extract_classes(node, anc_level, association_level - 1)\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/diadefslib.py"
                },
                "region": {
                  "startLine": 110,
                  "startColumn": 21,
                  "endLine": 111,
                  "snippet": {
                    "text": "                    node = node._proxied\n                if not (isinstance(node, nodes.ClassDef) and self.show_node(node)):\n                    continue\n                yield node\n\n    def extract_classes(\n        self, klass_node: nodes.ClassDef, anc_level: int, association_level: int\n    ) -> None:\n",
                    "rendered": {
                      "text": "                    node = node._proxied\n                if not (isinstance(node, nodes.ClassDef) and self.show_node(node)):\n                    continue\n                yield node\n\n    def extract_classes(\n        self, klass_node: nodes.ClassDef, anc_level: int, association_level: int\n    ) -> None:\n",
                      "markdown": "`                    node = node._proxied\n                if not (isinstance(node, nodes.ClassDef) and self.show_node(node)):\n                    continue\n                yield node\n\n    def extract_classes(\n        self, klass_node: nodes.ClassDef, anc_level: int, association_level: int\n    ) -> None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/diadefslib.py"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 19,
                  "endLine": 107,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        ):\n            for node in association_nodes:\n                if isinstance(node, astroid.Instance):\n                    node = node._proxied\n                if not (isinstance(node, nodes.ClassDef) and self.show_node(node)):\n                    continue\n                yield node\n",
                    "rendered": {
                      "text": "        ):\n            for node in association_nodes:\n                if isinstance(node, astroid.Instance):\n                    node = node._proxied\n                if not (isinstance(node, nodes.ClassDef) and self.show_node(node)):\n                    continue\n                yield node\n",
                      "markdown": "`        ):\n            for node in association_nodes:\n                if isinstance(node, astroid.Instance):\n                    node = node._proxied\n                if not (isinstance(node, nodes.ClassDef) and self.show_node(node)):\n                    continue\n                yield node\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/diadefslib.py"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 15,
                  "endLine": 105,
                  "endColumn": 21,
                  "snippet": {
                    "text": "        for association_nodes in list(klass_node.instance_attrs_type.values()) + list(\n            klass_node.locals_type.values()\n        ):\n            for node in association_nodes:\n                if isinstance(node, astroid.Instance):\n                    node = node._proxied\n                if not (isinstance(node, nodes.ClassDef) and self.show_node(node)):\n",
                    "rendered": {
                      "text": "        for association_nodes in list(klass_node.instance_attrs_type.values()) + list(\n            klass_node.locals_type.values()\n        ):\n            for node in association_nodes:\n                if isinstance(node, astroid.Instance):\n                    node = node._proxied\n                if not (isinstance(node, nodes.ClassDef) and self.show_node(node)):\n",
                      "markdown": "`        for association_nodes in list(klass_node.instance_attrs_type.values()) + list(\n            klass_node.locals_type.values()\n        ):\n            for node in association_nodes:\n                if isinstance(node, astroid.Instance):\n                    node = node._proxied\n                if not (isinstance(node, nodes.ClassDef) and self.show_node(node)):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/diadefslib.py"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 23,
                  "endLine": 71,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        return self.anc_level, self.association_level\n\n    def show_node(self, node: nodes.ClassDef) -> bool:\n        \"\"\"Determine if node should be shown based on config.\"\"\"\n        if node.root().name == \"builtins\":\n            return self.config.show_builtin  # type: ignore[no-any-return]\n\n",
                    "rendered": {
                      "text": "        return self.anc_level, self.association_level\n\n    def show_node(self, node: nodes.ClassDef) -> bool:\n        \"\"\"Determine if node should be shown based on config.\"\"\"\n        if node.root().name == \"builtins\":\n            return self.config.show_builtin  # type: ignore[no-any-return]\n\n",
                      "markdown": "`        return self.anc_level, self.association_level\n\n    def show_node(self, node: nodes.ClassDef) -> bool:\n        \"\"\"Determine if node should be shown based on config.\"\"\"\n        if node.root().name == \"builtins\":\n            return self.config.show_builtin  # type: ignore[no-any-return]\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/_check_docs_utils.py"
                },
                "region": {
                  "startLine": 267,
                  "startColumn": 36,
                  "endLine": 267,
                  "endColumn": 41,
                  "snippet": {
                    "text": "def docstringify(\n    docstring: nodes.Const | None, default_type: str = \"default\"\n) -> Docstring:\n    best_match = (0, DOCSTRING_TYPES.get(default_type, Docstring)(docstring))\n    for docstring_type in (\n        SphinxDocstring,\n        EpytextDocstring,\n",
                    "rendered": {
                      "text": "def docstringify(\n    docstring: nodes.Const | None, default_type: str = \"default\"\n) -> Docstring:\n    best_match = (0, DOCSTRING_TYPES.get(default_type, Docstring)(docstring))\n    for docstring_type in (\n        SphinxDocstring,\n        EpytextDocstring,\n",
                      "markdown": "`def docstringify(\n    docstring: nodes.Const | None, default_type: str = \"default\"\n) -> Docstring:\n    best_match = (0, DOCSTRING_TYPES.get(default_type, Docstring)(docstring))\n    for docstring_type in (\n        SphinxDocstring,\n        EpytextDocstring,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/_check_docs_utils.py"
                },
                "region": {
                  "startLine": 189,
                  "startColumn": 25,
                  "endLine": 189,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    * A type comment on the function.\n    * A type common on the individual argument.\n\n    :param args_node: The node to get the annotations for.\n    :returns: The annotations.\n    \"\"\"\n    plain_annotations = args_node.annotations or ()\n",
                    "rendered": {
                      "text": "    * A type comment on the function.\n    * A type common on the individual argument.\n\n    :param args_node: The node to get the annotations for.\n    :returns: The annotations.\n    \"\"\"\n    plain_annotations = args_node.annotations or ()\n",
                      "markdown": "`    * A type comment on the function.\n    * A type common on the individual argument.\n\n    :param args_node: The node to get the annotations for.\n    :returns: The annotations.\n    \"\"\"\n    plain_annotations = args_node.annotations or ()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/_check_docs_utils.py"
                },
                "region": {
                  "startLine": 114,
                  "startColumn": 34,
                  "endLine": 114,
                  "endColumn": 40,
                  "snippet": {
                    "text": "\n        Caught exception types are ignored.\n\n    :param node: The raise node to find exception types for.\n\n    :returns: A list of exception types possibly raised by :param:`node`.\n    \"\"\"\n",
                    "rendered": {
                      "text": "\n        Caught exception types are ignored.\n\n    :param node: The raise node to find exception types for.\n\n    :returns: A list of exception types possibly raised by :param:`node`.\n    \"\"\"\n",
                      "markdown": "`\n        Caught exception types are ignored.\n\n    :param node: The raise node to find exception types for.\n\n    :returns: A list of exception types possibly raised by :param:`node`.\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/_check_docs_utils.py"
                },
                "region": {
                  "startLine": 114,
                  "startColumn": 26,
                  "endLine": 114,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n        Caught exception types are ignored.\n\n    :param node: The raise node to find exception types for.\n\n    :returns: A list of exception types possibly raised by :param:`node`.\n    \"\"\"\n",
                    "rendered": {
                      "text": "\n        Caught exception types are ignored.\n\n    :param node: The raise node to find exception types for.\n\n    :returns: A list of exception types possibly raised by :param:`node`.\n    \"\"\"\n",
                      "markdown": "`\n        Caught exception types are ignored.\n\n    :param node: The raise node to find exception types for.\n\n    :returns: A list of exception types possibly raised by :param:`node`.\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/_check_docs_utils.py"
                },
                "region": {
                  "startLine": 83,
                  "startColumn": 31,
                  "endLine": 83,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    :type return_node: astroid.Return\n\n    :rtype: bool\n    :return: True if the return node returns a value other than None,\n        False otherwise.\n    \"\"\"\n    returns = return_node.value\n",
                    "rendered": {
                      "text": "    :type return_node: astroid.Return\n\n    :rtype: bool\n    :return: True if the return node returns a value other than None,\n        False otherwise.\n    \"\"\"\n    returns = return_node.value\n",
                      "markdown": "`    :type return_node: astroid.Return\n\n    :rtype: bool\n    :return: True if the return node returns a value other than None,\n        False otherwise.\n    \"\"\"\n    returns = return_node.value\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/_check_docs_utils.py"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 34,
                  "endLine": 79,
                  "endColumn": 40,
                  "snippet": {
                    "text": "def returns_something(return_node: nodes.Return) -> bool:\n    \"\"\"Check if a return node returns a value other than None.\n\n    :param return_node: The return node to check.\n    :type return_node: astroid.Return\n\n    :rtype: bool\n",
                    "rendered": {
                      "text": "def returns_something(return_node: nodes.Return) -> bool:\n    \"\"\"Check if a return node returns a value other than None.\n\n    :param return_node: The return node to check.\n    :type return_node: astroid.Return\n\n    :rtype: bool\n",
                      "markdown": "`def returns_something(return_node: nodes.Return) -> bool:\n    \"\"\"Check if a return node returns a value other than None.\n\n    :param return_node: The return node to check.\n    :type return_node: astroid.Return\n\n    :rtype: bool\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/_check_docs_utils.py"
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 24,
                  "endLine": 77,
                  "endColumn": 30,
                  "snippet": {
                    "text": "\n\ndef returns_something(return_node: nodes.Return) -> bool:\n    \"\"\"Check if a return node returns a value other than None.\n\n    :param return_node: The return node to check.\n    :type return_node: astroid.Return\n",
                    "rendered": {
                      "text": "\n\ndef returns_something(return_node: nodes.Return) -> bool:\n    \"\"\"Check if a return node returns a value other than None.\n\n    :param return_node: The return node to check.\n    :type return_node: astroid.Return\n",
                      "markdown": "`\n\ndef returns_something(return_node: nodes.Return) -> bool:\n    \"\"\"Check if a return node returns a value other than None.\n\n    :param return_node: The return node to check.\n    :type return_node: astroid.Return\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/_check_docs_utils.py"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 17,
                  "endLine": 59,
                  "endColumn": 23,
                  "snippet": {
                    "text": "    :type node: nodes.FunctionDef\n\n    :rtype: nodes.FunctionDef or None\n    :returns: The node relating to the property of the given setter node,\n        or None if one could not be found.\n    \"\"\"\n    property_ = None\n",
                    "rendered": {
                      "text": "    :type node: nodes.FunctionDef\n\n    :rtype: nodes.FunctionDef or None\n    :returns: The node relating to the property of the given setter node,\n        or None if one could not be found.\n    \"\"\"\n    property_ = None\n",
                      "markdown": "`    :type node: nodes.FunctionDef\n\n    :rtype: nodes.FunctionDef or None\n    :returns: The node relating to the property of the given setter node,\n        or None if one could not be found.\n    \"\"\"\n    property_ = None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/_check_docs_utils.py"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 20,
                  "endLine": 55,
                  "endColumn": 26,
                  "snippet": {
                    "text": "def get_setters_property(node: nodes.FunctionDef) -> nodes.FunctionDef | None:\n    \"\"\"Get the property node for the given setter node.\n\n    :param node: The node to get the property for.\n    :type node: nodes.FunctionDef\n\n    :rtype: nodes.FunctionDef or None\n",
                    "rendered": {
                      "text": "def get_setters_property(node: nodes.FunctionDef) -> nodes.FunctionDef | None:\n    \"\"\"Get the property node for the given setter node.\n\n    :param node: The node to get the property for.\n    :type node: nodes.FunctionDef\n\n    :rtype: nodes.FunctionDef or None\n",
                      "markdown": "`def get_setters_property(node: nodes.FunctionDef) -> nodes.FunctionDef | None:\n    \"\"\"Get the property node for the given setter node.\n\n    :param node: The node to get the property for.\n    :type node: nodes.FunctionDef\n\n    :rtype: nodes.FunctionDef or None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/_check_docs_utils.py"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 23,
                  "endLine": 53,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n\ndef get_setters_property(node: nodes.FunctionDef) -> nodes.FunctionDef | None:\n    \"\"\"Get the property node for the given setter node.\n\n    :param node: The node to get the property for.\n    :type node: nodes.FunctionDef\n",
                    "rendered": {
                      "text": "\n\ndef get_setters_property(node: nodes.FunctionDef) -> nodes.FunctionDef | None:\n    \"\"\"Get the property node for the given setter node.\n\n    :param node: The node to get the property for.\n    :type node: nodes.FunctionDef\n",
                      "markdown": "`\n\ndef get_setters_property(node: nodes.FunctionDef) -> nodes.FunctionDef | None:\n    \"\"\"Get the property node for the given setter node.\n\n    :param node: The node to get the property for.\n    :type node: nodes.FunctionDef\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/_check_docs_utils.py"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 47,
                  "endLine": 38,
                  "endColumn": 53,
                  "snippet": {
                    "text": "    :type node: str\n\n    :rtype: str or None\n    :returns: The name of the property that the node is a setter for,\n        or None if one could not be found.\n    \"\"\"\n    decorators = node.decorators.nodes if node.decorators else []\n",
                    "rendered": {
                      "text": "    :type node: str\n\n    :rtype: str or None\n    :returns: The name of the property that the node is a setter for,\n        or None if one could not be found.\n    \"\"\"\n    decorators = node.decorators.nodes if node.decorators else []\n",
                      "markdown": "`    :type node: str\n\n    :rtype: str or None\n    :returns: The name of the property that the node is a setter for,\n        or None if one could not be found.\n    \"\"\"\n    decorators = node.decorators.nodes if node.decorators else []\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/_check_docs_utils.py"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 20,
                  "endLine": 34,
                  "endColumn": 26,
                  "snippet": {
                    "text": "def get_setters_property_name(node: nodes.FunctionDef) -> str | None:\n    \"\"\"Get the name of the property that the given node is a setter for.\n\n    :param node: The node to get the property name for.\n    :type node: str\n\n    :rtype: str or None\n",
                    "rendered": {
                      "text": "def get_setters_property_name(node: nodes.FunctionDef) -> str | None:\n    \"\"\"Get the name of the property that the given node is a setter for.\n\n    :param node: The node to get the property name for.\n    :type node: str\n\n    :rtype: str or None\n",
                      "markdown": "`def get_setters_property_name(node: nodes.FunctionDef) -> str | None:\n    \"\"\"Get the name of the property that the given node is a setter for.\n\n    :param node: The node to get the property name for.\n    :type node: str\n\n    :rtype: str or None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/_check_docs_utils.py"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 50,
                  "endLine": 32,
                  "endColumn": 56,
                  "snippet": {
                    "text": "\n\ndef get_setters_property_name(node: nodes.FunctionDef) -> str | None:\n    \"\"\"Get the name of the property that the given node is a setter for.\n\n    :param node: The node to get the property name for.\n    :type node: str\n",
                    "rendered": {
                      "text": "\n\ndef get_setters_property_name(node: nodes.FunctionDef) -> str | None:\n    \"\"\"Get the name of the property that the given node is a setter for.\n\n    :param node: The node to get the property name for.\n    :type node: str\n",
                      "markdown": "`\n\ndef get_setters_property_name(node: nodes.FunctionDef) -> str | None:\n    \"\"\"Get the name of the property that the given node is a setter for.\n\n    :param node: The node to get the property name for.\n    :type node: str\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 1196,
                  "startColumn": 42,
                  "endLine": 1196,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        graph: defaultdict[str, set[str]] = defaultdict(set)\n        for importee, importers in self.linter.stats.dependencies.items():\n            for importer in importers:\n                package = self._module_pkg.get(importer, importer)\n                is_inside = importee.startswith(package)\n                if is_inside and internal or not is_inside and not internal:\n                    graph[importee].add(importer)\n",
                    "rendered": {
                      "text": "        graph: defaultdict[str, set[str]] = defaultdict(set)\n        for importee, importers in self.linter.stats.dependencies.items():\n            for importer in importers:\n                package = self._module_pkg.get(importer, importer)\n                is_inside = importee.startswith(package)\n                if is_inside and internal or not is_inside and not internal:\n                    graph[importee].add(importer)\n",
                      "markdown": "`        graph: defaultdict[str, set[str]] = defaultdict(set)\n        for importee, importers in self.linter.stats.dependencies.items():\n            for importer in importers:\n                package = self._module_pkg.get(importer, importer)\n                is_inside = importee.startswith(package)\n                if is_inside and internal or not is_inside and not internal:\n                    graph[importee].add(importer)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 1251,
                  "startColumn": 69,
                  "endLine": 1251,
                  "endColumn": 73,
                  "snippet": {
                    "text": "            for name in node.names\n        ]\n\n        # Get the full names of all the imports that are only allowed at the module level\n        scoped_imports = [\n            name for name in module_names if name not in self._allow_any_import_level\n        ]\n",
                    "rendered": {
                      "text": "            for name in node.names\n        ]\n\n        # Get the full names of all the imports that are only allowed at the module level\n        scoped_imports = [\n            name for name in module_names if name not in self._allow_any_import_level\n        ]\n",
                      "markdown": "`            for name in node.names\n        ]\n\n        # Get the full names of all the imports that are only allowed at the module level\n        scoped_imports = [\n            name for name in module_names if name not in self._allow_any_import_level\n        ]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 1074,
                  "startColumn": 13,
                  "endLine": 1074,
                  "endColumn": 21,
                  "snippet": {
                    "text": "            if context_name not in importedmodnames:\n                importedmodnames.add(context_name)\n\n            # update import graph\n            self.import_graph[context_name].add(importedmodname)\n            if not self.linter.is_message_enabled(\n                \"cyclic-import\", line=node.lineno\n",
                    "rendered": {
                      "text": "            if context_name not in importedmodnames:\n                importedmodnames.add(context_name)\n\n            # update import graph\n            self.import_graph[context_name].add(importedmodname)\n            if not self.linter.is_message_enabled(\n                \"cyclic-import\", line=node.lineno\n",
                      "markdown": "`            if context_name not in importedmodnames:\n                importedmodnames.add(context_name)\n\n            # update import graph\n            self.import_graph[context_name].add(importedmodname)\n            if not self.linter.is_message_enabled(\n                \"cyclic-import\", line=node.lineno\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 422,
                  "startColumn": 57,
                  "endLine": 422,
                  "endColumn": 61,
                  "snippet": {
                    "text": "                \"type\": \"csv\",\n                \"metavar\": \"<modules>\",\n                \"help\": (\n                    \"List of modules that can be imported at any level, not just \"\n                    \"the top level one.\"\n                ),\n            },\n",
                    "rendered": {
                      "text": "                \"type\": \"csv\",\n                \"metavar\": \"<modules>\",\n                \"help\": (\n                    \"List of modules that can be imported at any level, not just \"\n                    \"the top level one.\"\n                ),\n            },\n",
                      "markdown": "`                \"type\": \"csv\",\n                \"metavar\": \"<modules>\",\n                \"help\": (\n                    \"List of modules that can be imported at any level, not just \"\n                    \"the top level one.\"\n                ),\n            },\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 297,
                  "startColumn": 37,
                  "endLine": 297,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        \"Used when imports are not grouped by packages.\",\n    ),\n    \"C0413\": (\n        'Import \"%s\" should be placed at the top of the module',\n        \"wrong-import-position\",\n        \"Used when code and imports are mixed.\",\n    ),\n",
                    "rendered": {
                      "text": "        \"Used when imports are not grouped by packages.\",\n    ),\n    \"C0413\": (\n        'Import \"%s\" should be placed at the top of the module',\n        \"wrong-import-position\",\n        \"Used when code and imports are mixed.\",\n    ),\n",
                      "markdown": "`        \"Used when imports are not grouped by packages.\",\n    ),\n    \"C0413\": (\n        'Import \"%s\" should be placed at the top of the module',\n        \"wrong-import-position\",\n        \"Used when code and imports are mixed.\",\n    ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 1088,
                  "startColumn": 9,
                  "endLine": 1088,
                  "endColumn": 15,
                  "snippet": {
                    "text": "        if isinstance(node, astroid.nodes.node_classes.ImportFrom):\n            mod_compare = [f\"{node.modname}.{name[0]}\" for name in node.names]\n\n        # find whether there are matches with the import vs preferred_modules keys\n        matches = [\n            k\n            for k in self.preferred_modules\n",
                    "rendered": {
                      "text": "        if isinstance(node, astroid.nodes.node_classes.ImportFrom):\n            mod_compare = [f\"{node.modname}.{name[0]}\" for name in node.names]\n\n        # find whether there are matches with the import vs preferred_modules keys\n        matches = [\n            k\n            for k in self.preferred_modules\n",
                      "markdown": "`        if isinstance(node, astroid.nodes.node_classes.ImportFrom):\n            mod_compare = [f\"{node.modname}.{name[0]}\" for name in node.names]\n\n        # find whether there are matches with the import vs preferred_modules keys\n        matches = [\n            k\n            for k in self.preferred_modules\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 1065,
                  "startColumn": 19,
                  "endLine": 1065,
                  "endColumn": 24,
                  "snippet": {
                    "text": "            # if this is not a package __init__ module\n            if base != \"__init__\" and context_name not in self._module_pkg:\n                # record the module's parent, or the module itself if this is\n                # a top level module, as the package it belongs to\n                self._module_pkg[context_name] = context_name.rsplit(\".\", 1)[0]\n\n            # handle dependencies\n",
                    "rendered": {
                      "text": "            # if this is not a package __init__ module\n            if base != \"__init__\" and context_name not in self._module_pkg:\n                # record the module's parent, or the module itself if this is\n                # a top level module, as the package it belongs to\n                self._module_pkg[context_name] = context_name.rsplit(\".\", 1)[0]\n\n            # handle dependencies\n",
                      "markdown": "`            # if this is not a package __init__ module\n            if base != \"__init__\" and context_name not in self._module_pkg:\n                # record the module's parent, or the module itself if this is\n                # a top level module, as the package it belongs to\n                self._module_pkg[context_name] = context_name.rsplit(\".\", 1)[0]\n\n            # handle dependencies\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 1005,
                  "startColumn": 29,
                  "endLine": 1005,
                  "endColumn": 35,
                  "snippet": {
                    "text": "                # and node = X.Y or X\n                return node\n\n            # when there is a node that contains multiple imports, the \"current\"\n            # import being analyzed is specified by package (node is the first\n            # import on the line and therefore != package in this case)\n            return package\n",
                    "rendered": {
                      "text": "                # and node = X.Y or X\n                return node\n\n            # when there is a node that contains multiple imports, the \"current\"\n            # import being analyzed is specified by package (node is the first\n            # import on the line and therefore != package in this case)\n            return package\n",
                      "markdown": "`                # and node = X.Y or X\n                return node\n\n            # when there is a node that contains multiple imports, the \"current\"\n            # import being analyzed is specified by package (node is the first\n            # import on the line and therefore != package in this case)\n            return package\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 1003,
                  "startColumn": 22,
                  "endLine": 1004,
                  "snippet": {
                    "text": "            if node.split(\".\")[0] == package:\n                # this is sufficient with one import per line, since package = X\n                # and node = X.Y or X\n                return node\n\n            # when there is a node that contains multiple imports, the \"current\"\n            # import being analyzed is specified by package (node is the first\n            # import on the line and therefore != package in this case)\n",
                    "rendered": {
                      "text": "            if node.split(\".\")[0] == package:\n                # this is sufficient with one import per line, since package = X\n                # and node = X.Y or X\n                return node\n\n            # when there is a node that contains multiple imports, the \"current\"\n            # import being analyzed is specified by package (node is the first\n            # import on the line and therefore != package in this case)\n",
                      "markdown": "`            if node.split(\".\")[0] == package:\n                # this is sufficient with one import per line, since package = X\n                # and node = X.Y or X\n                return node\n\n            # when there is a node that contains multiple imports, the \"current\"\n            # import being analyzed is specified by package (node is the first\n            # import on the line and therefore != package in this case)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 1002,
                  "startColumn": 21,
                  "endLine": 1002,
                  "endColumn": 27,
                  "snippet": {
                    "text": "\n            if node.split(\".\")[0] == package:\n                # this is sufficient with one import per line, since package = X\n                # and node = X.Y or X\n                return node\n\n            # when there is a node that contains multiple imports, the \"current\"\n",
                    "rendered": {
                      "text": "\n            if node.split(\".\")[0] == package:\n                # this is sufficient with one import per line, since package = X\n                # and node = X.Y or X\n                return node\n\n            # when there is a node that contains multiple imports, the \"current\"\n",
                      "markdown": "`\n            if node.split(\".\")[0] == package:\n                # this is sufficient with one import per line, since package = X\n                # and node = X.Y or X\n                return node\n\n            # when there is a node that contains multiple imports, the \"current\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 855,
                  "startColumn": 66,
                  "endLine": 856,
                  "snippet": {
                    "text": "                        local_not_ignored.append((node, package))\n                    else:\n                        self.linter.add_ignored_message(\n                            \"wrong-import-order\", node.fromlineno, node\n                        )\n        return std_imports, external_imports, local_imports\n\n    def _get_out_of_order_string(\n",
                    "rendered": {
                      "text": "                        local_not_ignored.append((node, package))\n                    else:\n                        self.linter.add_ignored_message(\n                            \"wrong-import-order\", node.fromlineno, node\n                        )\n        return std_imports, external_imports, local_imports\n\n    def _get_out_of_order_string(\n",
                      "markdown": "`                        local_not_ignored.append((node, package))\n                    else:\n                        self.linter.add_ignored_message(\n                            \"wrong-import-order\", node.fromlineno, node\n                        )\n        return std_imports, external_imports, local_imports\n\n    def _get_out_of_order_string(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 834,
                  "startColumn": 66,
                  "endLine": 835,
                  "snippet": {
                    "text": "                        first_party_not_ignored.append(node_and_package_import)\n                    else:\n                        self.linter.add_ignored_message(\n                            \"wrong-import-order\", node.fromlineno, node\n                        )\n                wrong_import = local_not_ignored\n                if wrong_import and not nested:\n                    self.add_message(\n",
                    "rendered": {
                      "text": "                        first_party_not_ignored.append(node_and_package_import)\n                    else:\n                        self.linter.add_ignored_message(\n                            \"wrong-import-order\", node.fromlineno, node\n                        )\n                wrong_import = local_not_ignored\n                if wrong_import and not nested:\n                    self.add_message(\n",
                      "markdown": "`                        first_party_not_ignored.append(node_and_package_import)\n                    else:\n                        self.linter.add_ignored_message(\n                            \"wrong-import-order\", node.fromlineno, node\n                        )\n                wrong_import = local_not_ignored\n                if wrong_import and not nested:\n                    self.add_message(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 812,
                  "startColumn": 66,
                  "endLine": 813,
                  "snippet": {
                    "text": "                        third_party_not_ignored.append(node_and_package_import)\n                    else:\n                        self.linter.add_ignored_message(\n                            \"wrong-import-order\", node.fromlineno, node\n                        )\n                wrong_import = first_party_not_ignored or local_not_ignored\n                if wrong_import and not nested:\n                    self.add_message(\n",
                    "rendered": {
                      "text": "                        third_party_not_ignored.append(node_and_package_import)\n                    else:\n                        self.linter.add_ignored_message(\n                            \"wrong-import-order\", node.fromlineno, node\n                        )\n                wrong_import = first_party_not_ignored or local_not_ignored\n                if wrong_import and not nested:\n                    self.add_message(\n",
                      "markdown": "`                        third_party_not_ignored.append(node_and_package_import)\n                    else:\n                        self.linter.add_ignored_message(\n                            \"wrong-import-order\", node.fromlineno, node\n                        )\n                wrong_import = first_party_not_ignored or local_not_ignored\n                if wrong_import and not nested:\n                    self.add_message(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 715,
                  "startColumn": 61,
                  "endLine": 716,
                  "snippet": {
                    "text": "                )\n            else:\n                self.linter.add_ignored_message(\n                    \"wrong-import-position\", node.fromlineno, node\n                )\n\n    def _record_import(\n        self,\n",
                    "rendered": {
                      "text": "                )\n            else:\n                self.linter.add_ignored_message(\n                    \"wrong-import-position\", node.fromlineno, node\n                )\n\n    def _record_import(\n        self,\n",
                      "markdown": "`                )\n            else:\n                self.linter.add_ignored_message(\n                    \"wrong-import-position\", node.fromlineno, node\n                )\n\n    def _record_import(\n        self,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 700,
                  "startColumn": 44,
                  "endLine": 700,
                  "endColumn": 50,
                  "snippet": {
                    "text": "                self.add_message(\"reimported\", node=node, args=(name, node.fromlineno))\n\n    def _check_position(self, node: ImportNode) -> None:\n        \"\"\"Check `node` import or importfrom node position is correct.\n\n        Send a message  if `node` comes before another instruction\n        \"\"\"\n",
                    "rendered": {
                      "text": "                self.add_message(\"reimported\", node=node, args=(name, node.fromlineno))\n\n    def _check_position(self, node: ImportNode) -> None:\n        \"\"\"Check `node` import or importfrom node position is correct.\n\n        Send a message  if `node` comes before another instruction\n        \"\"\"\n",
                      "markdown": "`                self.add_message(\"reimported\", node=node, args=(name, node.fromlineno))\n\n    def _check_position(self, node: ImportNode) -> None:\n        \"\"\"Check `node` import or importfrom node position is correct.\n\n        Send a message  if `node` comes before another instruction\n        \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 675,
                  "startColumn": 37,
                  "endLine": 676,
                  "snippet": {
                    "text": "            if any(root.nodes_of_class((nodes.Import, nodes.ImportFrom))):\n                return\n\n        self._first_non_import_node = node\n\n    visit_classdef = visit_for = visit_while = visit_functiondef\n\n    def _check_misplaced_future(self, node: nodes.ImportFrom) -> None:\n",
                    "rendered": {
                      "text": "            if any(root.nodes_of_class((nodes.Import, nodes.ImportFrom))):\n                return\n\n        self._first_non_import_node = node\n\n    visit_classdef = visit_for = visit_while = visit_functiondef\n\n    def _check_misplaced_future(self, node: nodes.ImportFrom) -> None:\n",
                      "markdown": "`            if any(root.nodes_of_class((nodes.Import, nodes.ImportFrom))):\n                return\n\n        self._first_non_import_node = node\n\n    visit_classdef = visit_for = visit_while = visit_functiondef\n\n    def _check_misplaced_future(self, node: nodes.ImportFrom) -> None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 667,
                  "startColumn": 14,
                  "endLine": 668,
                  "snippet": {
                    "text": "        if not isinstance(node.parent.scope(), nodes.Module):\n            return\n\n        root = node\n        while not isinstance(root.parent, nodes.Module):\n            root = root.parent\n\n        if isinstance(root, (nodes.If, nodes.Try)):\n",
                    "rendered": {
                      "text": "        if not isinstance(node.parent.scope(), nodes.Module):\n            return\n\n        root = node\n        while not isinstance(root.parent, nodes.Module):\n            root = root.parent\n\n        if isinstance(root, (nodes.If, nodes.Try)):\n",
                      "markdown": "`        if not isinstance(node.parent.scope(), nodes.Module):\n            return\n\n        root = node\n        while not isinstance(root.parent, nodes.Module):\n            root = root.parent\n\n        if isinstance(root, (nodes.If, nodes.Try)):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 662,
                  "startColumn": 22,
                  "endLine": 662,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        if self._first_non_import_node:\n            return\n\n        # Check if the node belongs to an `If` or a `Try` block. If they\n        # contain imports, skip recording this node.\n        if not isinstance(node.parent.scope(), nodes.Module):\n            return\n",
                    "rendered": {
                      "text": "        if self._first_non_import_node:\n            return\n\n        # Check if the node belongs to an `If` or a `Try` block. If they\n        # contain imports, skip recording this node.\n        if not isinstance(node.parent.scope(), nodes.Module):\n            return\n",
                      "markdown": "`        if self._first_non_import_node:\n            return\n\n        # Check if the node belongs to an `If` or a `Try` block. If they\n        # contain imports, skip recording this node.\n        if not isinstance(node.parent.scope(), nodes.Module):\n            return\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 649,
                  "startColumn": 37,
                  "endLine": 650,
                  "snippet": {
                    "text": "            ]\n            if all(valid_targets):\n                return\n        self._first_non_import_node = node\n\n    visit_try = visit_assignattr = visit_assign = visit_ifexp = visit_comprehension = (\n        visit_expr\n    ) = visit_if = compute_first_non_import_node\n",
                    "rendered": {
                      "text": "            ]\n            if all(valid_targets):\n                return\n        self._first_non_import_node = node\n\n    visit_try = visit_assignattr = visit_assign = visit_ifexp = visit_comprehension = (\n        visit_expr\n    ) = visit_if = compute_first_non_import_node\n",
                      "markdown": "`            ]\n            if all(valid_targets):\n                return\n        self._first_non_import_node = node\n\n    visit_try = visit_assignattr = visit_assign = visit_ifexp = visit_comprehension = (\n        visit_expr\n    ) = visit_if = compute_first_non_import_node\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 627,
                  "startColumn": 15,
                  "endLine": 627,
                  "endColumn": 21,
                  "snippet": {
                    "text": "        ),\n    ) -> None:\n        # if the node does not contain an import instruction, and if it is the\n        # first node of the module, keep a track of it (all the import positions\n        # of the module will be compared to the position of this first\n        # instruction)\n        if self._first_non_import_node:\n",
                    "rendered": {
                      "text": "        ),\n    ) -> None:\n        # if the node does not contain an import instruction, and if it is the\n        # first node of the module, keep a track of it (all the import positions\n        # of the module will be compared to the position of this first\n        # instruction)\n        if self._first_non_import_node:\n",
                      "markdown": "`        ),\n    ) -> None:\n        # if the node does not contain an import instruction, and if it is the\n        # first node of the module, keep a track of it (all the import positions\n        # of the module will be compared to the position of this first\n        # instruction)\n        if self._first_non_import_node:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 626,
                  "startColumn": 16,
                  "endLine": 626,
                  "endColumn": 22,
                  "snippet": {
                    "text": "            | nodes.Try\n        ),\n    ) -> None:\n        # if the node does not contain an import instruction, and if it is the\n        # first node of the module, keep a track of it (all the import positions\n        # of the module will be compared to the position of this first\n        # instruction)\n",
                    "rendered": {
                      "text": "            | nodes.Try\n        ),\n    ) -> None:\n        # if the node does not contain an import instruction, and if it is the\n        # first node of the module, keep a track of it (all the import positions\n        # of the module will be compared to the position of this first\n        # instruction)\n",
                      "markdown": "`            | nodes.Try\n        ),\n    ) -> None:\n        # if the node does not contain an import instruction, and if it is the\n        # first node of the module, keep a track of it (all the import positions\n        # of the module will be compared to the position of this first\n        # instruction)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 481,
                  "startColumn": 11,
                  "endLine": 481,
                  "endColumn": 17,
                  "snippet": {
                    "text": "\n    def _import_graph_without_ignored_edges(self) -> defaultdict[str, set[str]]:\n        filtered_graph = copy.deepcopy(self.import_graph)\n        for node in filtered_graph:\n            filtered_graph[node].difference_update(self._excluded_edges[node])\n        return filtered_graph\n\n",
                    "rendered": {
                      "text": "\n    def _import_graph_without_ignored_edges(self) -> defaultdict[str, set[str]]:\n        filtered_graph = copy.deepcopy(self.import_graph)\n        for node in filtered_graph:\n            filtered_graph[node].difference_update(self._excluded_edges[node])\n        return filtered_graph\n\n",
                      "markdown": "`\n    def _import_graph_without_ignored_edges(self) -> defaultdict[str, set[str]]:\n        filtered_graph = copy.deepcopy(self.import_graph)\n        for node in filtered_graph:\n            filtered_graph[node].difference_update(self._excluded_edges[node])\n        return filtered_graph\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 423,
                  "startColumn": 24,
                  "endLine": 423,
                  "endColumn": 29,
                  "snippet": {
                    "text": "                \"metavar\": \"<modules>\",\n                \"help\": (\n                    \"List of modules that can be imported at any level, not just \"\n                    \"the top level one.\"\n                ),\n            },\n        ),\n",
                    "rendered": {
                      "text": "                \"metavar\": \"<modules>\",\n                \"help\": (\n                    \"List of modules that can be imported at any level, not just \"\n                    \"the top level one.\"\n                ),\n            },\n        ),\n",
                      "markdown": "`                \"metavar\": \"<modules>\",\n                \"help\": (\n                    \"List of modules that can be imported at any level, not just \"\n                    \"the top level one.\"\n                ),\n            },\n        ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 311,
                  "startColumn": 42,
                  "endLine": 311,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        \"Import outside toplevel (%s)\",\n        \"import-outside-toplevel\",\n        \"Used when an import statement is used anywhere other than the module \"\n        \"toplevel. Move this import to the top of the file.\",\n    ),\n    \"W0416\": (\n        \"Shadowed %r (imported line %s)\",\n",
                    "rendered": {
                      "text": "        \"Import outside toplevel (%s)\",\n        \"import-outside-toplevel\",\n        \"Used when an import statement is used anywhere other than the module \"\n        \"toplevel. Move this import to the top of the file.\",\n    ),\n    \"W0416\": (\n        \"Shadowed %r (imported line %s)\",\n",
                      "markdown": "`        \"Import outside toplevel (%s)\",\n        \"import-outside-toplevel\",\n        \"Used when an import statement is used anywhere other than the module \"\n        \"toplevel. Move this import to the top of the file.\",\n    ),\n    \"W0416\": (\n        \"Shadowed %r (imported line %s)\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 297,
                  "startColumn": 44,
                  "endLine": 297,
                  "endColumn": 49,
                  "snippet": {
                    "text": "        \"Used when imports are not grouped by packages.\",\n    ),\n    \"C0413\": (\n        'Import \"%s\" should be placed at the top of the module',\n        \"wrong-import-position\",\n        \"Used when code and imports are mixed.\",\n    ),\n",
                    "rendered": {
                      "text": "        \"Used when imports are not grouped by packages.\",\n    ),\n    \"C0413\": (\n        'Import \"%s\" should be placed at the top of the module',\n        \"wrong-import-position\",\n        \"Used when code and imports are mixed.\",\n    ),\n",
                      "markdown": "`        \"Used when imports are not grouped by packages.\",\n    ),\n    \"C0413\": (\n        'Import \"%s\" should be placed at the top of the module',\n        \"wrong-import-position\",\n        \"Used when code and imports are mixed.\",\n    ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 171,
                  "startColumn": 11,
                  "endLine": 171,
                  "endColumn": 17,
                  "snippet": {
                    "text": "        node: list[_ImportTree | list[str]] = [tree_defs, []]\n        for prefix in mod.split(\".\"):\n            assert isinstance(node[0], dict)\n            node = node[0].setdefault(prefix, ({}, []))  # type: ignore[arg-type,assignment]\n        assert isinstance(node[1], list)\n        node[1].extend(files)\n    return tree_defs\n",
                    "rendered": {
                      "text": "        node: list[_ImportTree | list[str]] = [tree_defs, []]\n        for prefix in mod.split(\".\"):\n            assert isinstance(node[0], dict)\n            node = node[0].setdefault(prefix, ({}, []))  # type: ignore[arg-type,assignment]\n        assert isinstance(node[1], list)\n        node[1].extend(files)\n    return tree_defs\n",
                      "markdown": "`        node: list[_ImportTree | list[str]] = [tree_defs, []]\n        for prefix in mod.split(\".\"):\n            assert isinstance(node[0], dict)\n            node = node[0].setdefault(prefix, ({}, []))  # type: ignore[arg-type,assignment]\n        assert isinstance(node[1], list)\n        node[1].extend(files)\n    return tree_defs\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/imports.py"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 17,
                  "endLine": 94,
                  "endColumn": 23,
                  "snippet": {
                    "text": "    level: int | None,\n    alias: str | None,\n) -> tuple[nodes.Import | nodes.ImportFrom | None, str | None]:\n    \"\"\"Return the node where [base.]<name> is imported or None if not found.\"\"\"\n    fullname = f\"{base}.{name}\" if base else name\n\n    first = None\n",
                    "rendered": {
                      "text": "    level: int | None,\n    alias: str | None,\n) -> tuple[nodes.Import | nodes.ImportFrom | None, str | None]:\n    \"\"\"Return the node where [base.]<name> is imported or None if not found.\"\"\"\n    fullname = f\"{base}.{name}\" if base else name\n\n    first = None\n",
                      "markdown": "`    level: int | None,\n    alias: str | None,\n) -> tuple[nodes.Import | nodes.ImportFrom | None, str | None]:\n    \"\"\"Return the node where [base.]<name> is imported or None if not found.\"\"\"\n    fullname = f\"{base}.{name}\" if base else name\n\n    first = None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/format.py"
                },
                "region": {
                  "startLine": 509,
                  "startColumn": 52,
                  "endLine": 509,
                  "endColumn": 57,
                  "snippet": {
                    "text": "            prev_line = node.parent.statement().fromlineno\n        line = node.fromlineno\n        assert line, node\n        if prev_line == line and self._visited_lines.get(line) != 2:\n            self._check_multi_statement_line(node, line)\n            return\n        if line in self._visited_lines:\n",
                    "rendered": {
                      "text": "            prev_line = node.parent.statement().fromlineno\n        line = node.fromlineno\n        assert line, node\n        if prev_line == line and self._visited_lines.get(line) != 2:\n            self._check_multi_statement_line(node, line)\n            return\n        if line in self._visited_lines:\n",
                      "markdown": "`            prev_line = node.parent.statement().fromlineno\n        line = node.fromlineno\n        assert line, node\n        if prev_line == line and self._visited_lines.get(line) != 2:\n            self._check_multi_statement_line(node, line)\n            return\n        if line in self._visited_lines:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/format.py"
                },
                "region": {
                  "startLine": 451,
                  "startColumn": 56,
                  "endLine": 451,
                  "endColumn": 61,
                  "snippet": {
                    "text": "            )[0]\n            names = (message_definition.msgid, \"too-many-lines\")\n            lineno = next(\n                filter(None, (self.linter._pragma_lineno.get(name) for name in names)),\n                1,\n            )\n            self.add_message(\n",
                    "rendered": {
                      "text": "            )[0]\n            names = (message_definition.msgid, \"too-many-lines\")\n            lineno = next(\n                filter(None, (self.linter._pragma_lineno.get(name) for name in names)),\n                1,\n            )\n            self.add_message(\n",
                      "markdown": "`            )[0]\n            names = (message_definition.msgid, \"too-many-lines\")\n            lineno = next(\n                filter(None, (self.linter._pragma_lineno.get(name) for name in names)),\n                1,\n            )\n            self.add_message(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/format.py"
                },
                "region": {
                  "startLine": 468,
                  "startColumn": 67,
                  "endLine": 469,
                  "snippet": {
                    "text": "    def _check_line_ending(self, line_ending: str, line_num: int) -> None:\n        # check if line endings are mixed\n        if self._last_line_ending is not None:\n            # line_ending == \"\" indicates a synthetic newline added at\n            # the end of a file that does not, in fact, end with a\n            # newline.\n            if line_ending and line_ending != self._last_line_ending:\n                self.add_message(\"mixed-line-endings\", line=line_num)\n",
                    "rendered": {
                      "text": "    def _check_line_ending(self, line_ending: str, line_num: int) -> None:\n        # check if line endings are mixed\n        if self._last_line_ending is not None:\n            # line_ending == \"\" indicates a synthetic newline added at\n            # the end of a file that does not, in fact, end with a\n            # newline.\n            if line_ending and line_ending != self._last_line_ending:\n                self.add_message(\"mixed-line-endings\", line=line_num)\n",
                      "markdown": "`    def _check_line_ending(self, line_ending: str, line_num: int) -> None:\n        # check if line endings are mixed\n        if self._last_line_ending is not None:\n            # line_ending == \"\" indicates a synthetic newline added at\n            # the end of a file that does not, in fact, end with a\n            # newline.\n            if line_ending and line_ending != self._last_line_ending:\n                self.add_message(\"mixed-line-endings\", line=line_num)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/format.py"
                },
                "region": {
                  "startLine": 418,
                  "startColumn": 38,
                  "endLine": 418,
                  "endColumn": 42,
                  "snippet": {
                    "text": "                # there's nothing we need to check here!  what's important is\n                # that when the run of DEDENTs ends, the indentation of the\n                # program statement (or ENDMARKER) that triggered the run is\n                # equal to what's left at the top of the indents stack\n                check_equal = True\n                if len(indents) > 1:\n                    del indents[-1]\n",
                    "rendered": {
                      "text": "                # there's nothing we need to check here!  what's important is\n                # that when the run of DEDENTs ends, the indentation of the\n                # program statement (or ENDMARKER) that triggered the run is\n                # equal to what's left at the top of the indents stack\n                check_equal = True\n                if len(indents) > 1:\n                    del indents[-1]\n",
                      "markdown": "`                # there's nothing we need to check here!  what's important is\n                # that when the run of DEDENTs ends, the indentation of the\n                # program statement (or ENDMARKER) that triggered the run is\n                # equal to what's left at the top of the indents stack\n                check_equal = True\n                if len(indents) > 1:\n                    del indents[-1]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/format.py"
                },
                "region": {
                  "startLine": 540,
                  "startColumn": 10,
                  "endLine": 540,
                  "endColumn": 16,
                  "snippet": {
                    "text": "        self, node: nodes.NodeNG, parent: nodes.Try\n    ) -> int:\n        last_line_of_prev_block = 0\n        if node in parent.finalbody and parent.orelse:\n            last_line_of_prev_block = parent.orelse[-1].tolineno\n        elif parent.handlers and parent.handlers[-1].body:\n            last_line_of_prev_block = parent.handlers[-1].body[-1].tolineno\n",
                    "rendered": {
                      "text": "        self, node: nodes.NodeNG, parent: nodes.Try\n    ) -> int:\n        last_line_of_prev_block = 0\n        if node in parent.finalbody and parent.orelse:\n            last_line_of_prev_block = parent.orelse[-1].tolineno\n        elif parent.handlers and parent.handlers[-1].body:\n            last_line_of_prev_block = parent.handlers[-1].body[-1].tolineno\n",
                      "markdown": "`        self, node: nodes.NodeNG, parent: nodes.Try\n    ) -> int:\n        last_line_of_prev_block = 0\n        if node in parent.finalbody and parent.orelse:\n            last_line_of_prev_block = parent.orelse[-1].tolineno\n        elif parent.handlers and parent.handlers[-1].body:\n            last_line_of_prev_block = parent.handlers[-1].body[-1].tolineno\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/format.py"
                },
                "region": {
                  "startLine": 532,
                  "startColumn": 31,
                  "endLine": 532,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    ) -> bool:\n        if parent.orelse and node == parent.orelse[0]:\n            return True\n        if parent.finalbody and node == parent.finalbody[0]:\n            return True\n        return False\n\n",
                    "rendered": {
                      "text": "    ) -> bool:\n        if parent.orelse and node == parent.orelse[0]:\n            return True\n        if parent.finalbody and node == parent.finalbody[0]:\n            return True\n        return False\n\n",
                      "markdown": "`    ) -> bool:\n        if parent.orelse and node == parent.orelse[0]:\n            return True\n        if parent.finalbody and node == parent.finalbody[0]:\n            return True\n        return False\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/format.py"
                },
                "region": {
                  "startLine": 530,
                  "startColumn": 28,
                  "endLine": 530,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    def _is_first_node_in_else_finally_body(\n        self, node: nodes.NodeNG, parent: nodes.Try\n    ) -> bool:\n        if parent.orelse and node == parent.orelse[0]:\n            return True\n        if parent.finalbody and node == parent.finalbody[0]:\n            return True\n",
                    "rendered": {
                      "text": "    def _is_first_node_in_else_finally_body(\n        self, node: nodes.NodeNG, parent: nodes.Try\n    ) -> bool:\n        if parent.orelse and node == parent.orelse[0]:\n            return True\n        if parent.finalbody and node == parent.finalbody[0]:\n            return True\n",
                      "markdown": "`    def _is_first_node_in_else_finally_body(\n        self, node: nodes.NodeNG, parent: nodes.Try\n    ) -> bool:\n        if parent.orelse and node == parent.orelse[0]:\n            return True\n        if parent.finalbody and node == parent.finalbody[0]:\n            return True\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/format.py"
                },
                "region": {
                  "startLine": 518,
                  "startColumn": 24,
                  "endLine": 519,
                  "snippet": {
                    "text": "            tolineno = node.blockstart_tolineno\n        except AttributeError:\n            tolineno = node.tolineno\n        assert tolineno, node\n        lines: list[str] = []\n        for line in range(line, tolineno + 1):  # noqa: B020\n            self._visited_lines[line] = 1\n            try:\n",
                    "rendered": {
                      "text": "            tolineno = node.blockstart_tolineno\n        except AttributeError:\n            tolineno = node.tolineno\n        assert tolineno, node\n        lines: list[str] = []\n        for line in range(line, tolineno + 1):  # noqa: B020\n            self._visited_lines[line] = 1\n            try:\n",
                      "markdown": "`            tolineno = node.blockstart_tolineno\n        except AttributeError:\n            tolineno = node.tolineno\n        assert tolineno, node\n        lines: list[str] = []\n        for line in range(line, tolineno + 1):  # noqa: B020\n            self._visited_lines[line] = 1\n            try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/format.py"
                },
                "region": {
                  "startLine": 508,
                  "startColumn": 20,
                  "endLine": 509,
                  "snippet": {
                    "text": "        else:\n            prev_line = node.parent.statement().fromlineno\n        line = node.fromlineno\n        assert line, node\n        if prev_line == line and self._visited_lines.get(line) != 2:\n            self._check_multi_statement_line(node, line)\n            return\n        if line in self._visited_lines:\n",
                    "rendered": {
                      "text": "        else:\n            prev_line = node.parent.statement().fromlineno\n        line = node.fromlineno\n        assert line, node\n        if prev_line == line and self._visited_lines.get(line) != 2:\n            self._check_multi_statement_line(node, line)\n            return\n        if line in self._visited_lines:\n",
                      "markdown": "`        else:\n            prev_line = node.parent.statement().fromlineno\n        line = node.fromlineno\n        assert line, node\n        if prev_line == line and self._visited_lines.get(line) != 2:\n            self._check_multi_statement_line(node, line)\n            return\n        if line in self._visited_lines:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/format.py"
                },
                "region": {
                  "startLine": 491,
                  "startColumn": 20,
                  "endLine": 491,
                  "endColumn": 26,
                  "snippet": {
                    "text": "\n    @only_required_for_messages(\"multiple-statements\")\n    def visit_default(self, node: nodes.NodeNG) -> None:\n        \"\"\"Check the node line number and check it if not yet done.\"\"\"\n        if not node.is_statement:\n            return\n        if not node.root().pure_python:\n",
                    "rendered": {
                      "text": "\n    @only_required_for_messages(\"multiple-statements\")\n    def visit_default(self, node: nodes.NodeNG) -> None:\n        \"\"\"Check the node line number and check it if not yet done.\"\"\"\n        if not node.is_statement:\n            return\n        if not node.root().pure_python:\n",
                      "markdown": "`\n    @only_required_for_messages(\"multiple-statements\")\n    def visit_default(self, node: nodes.NodeNG) -> None:\n        \"\"\"Check the node line number and check it if not yet done.\"\"\"\n        if not node.is_statement:\n            return\n        if not node.root().pure_python:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/format.py"
                },
                "region": {
                  "startLine": 418,
                  "startColumn": 45,
                  "endLine": 418,
                  "endColumn": 50,
                  "snippet": {
                    "text": "                # there's nothing we need to check here!  what's important is\n                # that when the run of DEDENTs ends, the indentation of the\n                # program statement (or ENDMARKER) that triggered the run is\n                # equal to what's left at the top of the indents stack\n                check_equal = True\n                if len(indents) > 1:\n                    del indents[-1]\n",
                    "rendered": {
                      "text": "                # there's nothing we need to check here!  what's important is\n                # that when the run of DEDENTs ends, the indentation of the\n                # program statement (or ENDMARKER) that triggered the run is\n                # equal to what's left at the top of the indents stack\n                check_equal = True\n                if len(indents) > 1:\n                    del indents[-1]\n",
                      "markdown": "`                # there's nothing we need to check here!  what's important is\n                # that when the run of DEDENTs ends, the indentation of the\n                # program statement (or ENDMARKER) that triggered the run is\n                # equal to what's left at the top of the indents stack\n                check_equal = True\n                if len(indents) > 1:\n                    del indents[-1]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/exceptions.py"
                },
                "region": {
                  "startLine": 436,
                  "startColumn": 19,
                  "endLine": 436,
                  "endColumn": 25,
                  "snippet": {
                    "text": "            if all(\n                node\n                and (utils.inherit_from_std_ex(node) or not utils.has_known_bases(node))\n                for node in inferred\n            ):\n                return\n\n",
                    "rendered": {
                      "text": "            if all(\n                node\n                and (utils.inherit_from_std_ex(node) or not utils.has_known_bases(node))\n                for node in inferred\n            ):\n                return\n\n",
                      "markdown": "`            if all(\n                node\n                and (utils.inherit_from_std_ex(node) or not utils.has_known_bases(node))\n                for node in inferred\n            ):\n                return\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/exceptions.py"
                },
                "region": {
                  "startLine": 434,
                  "startColumn": 15,
                  "endLine": 435,
                  "snippet": {
                    "text": "                # Don't emit if we don't know every component.\n                return\n            if all(\n                node\n                and (utils.inherit_from_std_ex(node) or not utils.has_known_bases(node))\n                for node in inferred\n            ):\n                return\n",
                    "rendered": {
                      "text": "                # Don't emit if we don't know every component.\n                return\n            if all(\n                node\n                and (utils.inherit_from_std_ex(node) or not utils.has_known_bases(node))\n                for node in inferred\n            ):\n                return\n",
                      "markdown": "`                # Don't emit if we don't know every component.\n                return\n            if all(\n                node\n                and (utils.inherit_from_std_ex(node) or not utils.has_known_bases(node))\n                for node in inferred\n            ):\n                return\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/exceptions.py"
                },
                "region": {
                  "startLine": 430,
                  "startColumn": 61,
                  "endLine": 430,
                  "endColumn": 67,
                  "snippet": {
                    "text": "        if isinstance(exc, nodes.Tuple):\n            # Check if it is a tuple of exceptions.\n            inferred = [utils.safe_infer(elt) for elt in exc.elts]\n            if any(isinstance(node, util.UninferableBase) for node in inferred):\n                # Don't emit if we don't know every component.\n                return\n            if all(\n",
                    "rendered": {
                      "text": "        if isinstance(exc, nodes.Tuple):\n            # Check if it is a tuple of exceptions.\n            inferred = [utils.safe_infer(elt) for elt in exc.elts]\n            if any(isinstance(node, util.UninferableBase) for node in inferred):\n                # Don't emit if we don't know every component.\n                return\n            if all(\n",
                      "markdown": "`        if isinstance(exc, nodes.Tuple):\n            # Check if it is a tuple of exceptions.\n            inferred = [utils.safe_infer(elt) for elt in exc.elts]\n            if any(isinstance(node, util.UninferableBase) for node in inferred):\n                # Don't emit if we don't know every component.\n                return\n            if all(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/exceptions.py"
                },
                "region": {
                  "startLine": 347,
                  "startColumn": 17,
                  "endLine": 348,
                  "snippet": {
                    "text": "        ):\n            return\n\n        current = node\n        # Stop when a new scope is generated or when the raise\n        # statement is found inside a Try.\n        ignores = (nodes.ExceptHandler, nodes.FunctionDef)\n        while current and not isinstance(current.parent, ignores):\n",
                    "rendered": {
                      "text": "        ):\n            return\n\n        current = node\n        # Stop when a new scope is generated or when the raise\n        # statement is found inside a Try.\n        ignores = (nodes.ExceptHandler, nodes.FunctionDef)\n        while current and not isinstance(current.parent, ignores):\n",
                      "markdown": "`        ):\n            return\n\n        current = node\n        # Stop when a new scope is generated or when the raise\n        # statement is found inside a Try.\n        ignores = (nodes.ExceptHandler, nodes.FunctionDef)\n        while current and not isinstance(current.parent, ignores):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/exceptions.py"
                },
                "region": {
                  "startLine": 188,
                  "startColumn": 20,
                  "endLine": 189,
                  "snippet": {
                    "text": "\n    def __init__(self, checker: ExceptionsChecker, node: nodes.Raise) -> None:\n        self._checker = checker\n        self._node = node\n\n    def visit(self, node: SuccessfulInferenceResult) -> None:\n        name = node.__class__.__name__.lower()\n        dispatch_meth = getattr(self, \"visit_\" + name, None)\n",
                    "rendered": {
                      "text": "\n    def __init__(self, checker: ExceptionsChecker, node: nodes.Raise) -> None:\n        self._checker = checker\n        self._node = node\n\n    def visit(self, node: SuccessfulInferenceResult) -> None:\n        name = node.__class__.__name__.lower()\n        dispatch_meth = getattr(self, \"visit_\" + name, None)\n",
                      "markdown": "`\n    def __init__(self, checker: ExceptionsChecker, node: nodes.Raise) -> None:\n        self._checker = checker\n        self._node = node\n\n    def visit(self, node: SuccessfulInferenceResult) -> None:\n        name = node.__class__.__name__.lower()\n        dispatch_meth = getattr(self, \"visit_\" + name, None)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/exceptions.py"
                },
                "region": {
                  "startLine": 177,
                  "startColumn": 12,
                  "endLine": 177,
                  "endColumn": 20,
                  "snippet": {
                    "text": "        \"Raising exceptions that are too generic force you to catch exceptions \"\n        \"generically too. It will force you to use a naked ``except Exception:`` \"\n        \"clause. You might then end up catching exceptions other than the ones \"\n        \"you expect to catch. This can hide bugs or make it harder to debug programs \"\n        \"when unrelated errors are hidden.\",\n    ),\n}\n",
                    "rendered": {
                      "text": "        \"Raising exceptions that are too generic force you to catch exceptions \"\n        \"generically too. It will force you to use a naked ``except Exception:`` \"\n        \"clause. You might then end up catching exceptions other than the ones \"\n        \"you expect to catch. This can hide bugs or make it harder to debug programs \"\n        \"when unrelated errors are hidden.\",\n    ),\n}\n",
                      "markdown": "`        \"Raising exceptions that are too generic force you to catch exceptions \"\n        \"generically too. It will force you to use a naked ``except Exception:`` \"\n        \"clause. You might then end up catching exceptions other than the ones \"\n        \"you expect to catch. This can hide bugs or make it harder to debug programs \"\n        \"when unrelated errors are hidden.\",\n    ),\n}\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/exceptions.py"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 43,
                  "endLine": 123,
                  "endColumn": 51,
                  "snippet": {
                    "text": "        \"Catching too general exception %s\",\n        \"broad-exception-caught\",\n        \"If you use a naked ``except Exception:`` clause, you might end up catching \"\n        \"exceptions other than the ones you expect to catch. This can hide bugs or \"\n        \"make it harder to debug programs when unrelated errors are hidden.\",\n        {\"old_names\": [(\"W0703\", \"broad-except\")]},\n    ),\n",
                    "rendered": {
                      "text": "        \"Catching too general exception %s\",\n        \"broad-exception-caught\",\n        \"If you use a naked ``except Exception:`` clause, you might end up catching \"\n        \"exceptions other than the ones you expect to catch. This can hide bugs or \"\n        \"make it harder to debug programs when unrelated errors are hidden.\",\n        {\"old_names\": [(\"W0703\", \"broad-except\")]},\n    ),\n",
                      "markdown": "`        \"Catching too general exception %s\",\n        \"broad-exception-caught\",\n        \"If you use a naked ``except Exception:`` clause, you might end up catching \"\n        \"exceptions other than the ones you expect to catch. This can hide bugs or \"\n        \"make it harder to debug programs when unrelated errors are hidden.\",\n        {\"old_names\": [(\"W0703\", \"broad-except\")]},\n    ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/exceptions.py"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 48,
                  "endLine": 59,
                  "endColumn": 54,
                  "snippet": {
                    "text": "\ndef _is_raising(body: list[nodes.NodeNG]) -> bool:\n    \"\"\"Return whether the given statement node raises an exception.\"\"\"\n    return any(isinstance(node, nodes.Raise) for node in body)\n\n\nMSGS: dict[str, MessageDefinitionTuple] = {\n",
                    "rendered": {
                      "text": "\ndef _is_raising(body: list[nodes.NodeNG]) -> bool:\n    \"\"\"Return whether the given statement node raises an exception.\"\"\"\n    return any(isinstance(node, nodes.Raise) for node in body)\n\n\nMSGS: dict[str, MessageDefinitionTuple] = {\n",
                      "markdown": "`\ndef _is_raising(body: list[nodes.NodeNG]) -> bool:\n    \"\"\"Return whether the given statement node raises an exception.\"\"\"\n    return any(isinstance(node, nodes.Raise) for node in body)\n\n\nMSGS: dict[str, MessageDefinitionTuple] = {\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/exceptions.py"
                },
                "region": {
                  "startLine": 58,
                  "startColumn": 41,
                  "endLine": 58,
                  "endColumn": 47,
                  "snippet": {
                    "text": "\n\ndef _is_raising(body: list[nodes.NodeNG]) -> bool:\n    \"\"\"Return whether the given statement node raises an exception.\"\"\"\n    return any(isinstance(node, nodes.Raise) for node in body)\n\n\n",
                    "rendered": {
                      "text": "\n\ndef _is_raising(body: list[nodes.NodeNG]) -> bool:\n    \"\"\"Return whether the given statement node raises an exception.\"\"\"\n    return any(isinstance(node, nodes.Raise) for node in body)\n\n\n",
                      "markdown": "`\n\ndef _is_raising(body: list[nodes.NodeNG]) -> bool:\n    \"\"\"Return whether the given statement node raises an exception.\"\"\"\n    return any(isinstance(node, nodes.Raise) for node in body)\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/_run.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 48,
                  "endLine": 7,
                  "endColumn": 52,
                  "snippet": {
                    "text": "\n\"\"\"Classes and functions used to mimic normal pylint runs.\n\nThis module is considered private and can change at any time.\n\"\"\"\n\nfrom __future__ import annotations\n",
                    "rendered": {
                      "text": "\n\"\"\"Classes and functions used to mimic normal pylint runs.\n\nThis module is considered private and can change at any time.\n\"\"\"\n\nfrom __future__ import annotations\n",
                      "markdown": "`\n\"\"\"Classes and functions used to mimic normal pylint runs.\n\nThis module is considered private and can change at any time.\n\"\"\"\n\nfrom __future__ import annotations\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/_primer/primer_run_command.py"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 15,
                  "endLine": 84,
                  "endColumn": 21,
                  "snippet": {
                    "text": "        # We want to test all the code we can\n        enables = [\"--enable-all-extensions\", \"--enable=all\"]\n        # Duplicate code takes too long and is relatively safe\n        # TODO: Find a way to allow cyclic-import and compare output correctly\n        disables = [\"--disable=duplicate-code,cyclic-import\"]\n        additional = [\"--clear-cache-post-run=y\"]\n        arguments = data.pylint_args + enables + disables + additional\n",
                    "rendered": {
                      "text": "        # We want to test all the code we can\n        enables = [\"--enable-all-extensions\", \"--enable=all\"]\n        # Duplicate code takes too long and is relatively safe\n        # TODO: Find a way to allow cyclic-import and compare output correctly\n        disables = [\"--disable=duplicate-code,cyclic-import\"]\n        additional = [\"--clear-cache-post-run=y\"]\n        arguments = data.pylint_args + enables + disables + additional\n",
                      "markdown": "`        # We want to test all the code we can\n        enables = [\"--enable-all-extensions\", \"--enable=all\"]\n        # Duplicate code takes too long and is relatively safe\n        # TODO: Find a way to allow cyclic-import and compare output correctly\n        disables = [\"--disable=duplicate-code,cyclic-import\"]\n        additional = [\"--clear-cache-post-run=y\"]\n        arguments = data.pylint_args + enables + disables + additional\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/_primer/primer_prepare_command.py"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 19,
                  "endLine": 9,
                  "snippet": {
                    "text": "\nimport sys\n\nfrom git.cmd import Git\nfrom git.repo import Repo\n\nfrom pylint.testutils._primer.primer_command import PrimerCommand\n\n",
                    "rendered": {
                      "text": "\nimport sys\n\nfrom git.cmd import Git\nfrom git.repo import Repo\n\nfrom pylint.testutils._primer.primer_command import PrimerCommand\n\n",
                      "markdown": "`\nimport sys\n\nfrom git.cmd import Git\nfrom git.repo import Repo\n\nfrom pylint.testutils._primer.primer_command import PrimerCommand\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/_primer/primer_prepare_command.py"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 45,
                  "endLine": 34,
                  "endColumn": 49,
                  "snippet": {
                    "text": "                remote_sha1_commit = (\n                    Git().ls_remote(data.url, data.branch).split(\"\\t\")[0][:8]\n                )\n                print(f\"'{package}' remote is at commit '{remote_sha1_commit}'.\")\n                commit_string += remote_sha1_commit + \"_\"\n        elif self.config.read_commit_string:\n            with open(\n",
                    "rendered": {
                      "text": "                remote_sha1_commit = (\n                    Git().ls_remote(data.url, data.branch).split(\"\\t\")[0][:8]\n                )\n                print(f\"'{package}' remote is at commit '{remote_sha1_commit}'.\")\n                commit_string += remote_sha1_commit + \"_\"\n        elif self.config.read_commit_string:\n            with open(\n",
                      "markdown": "`                remote_sha1_commit = (\n                    Git().ls_remote(data.url, data.branch).split(\"\\t\")[0][:8]\n                )\n                print(f\"'{package}' remote is at commit '{remote_sha1_commit}'.\")\n                commit_string += remote_sha1_commit + \"_\"\n        elif self.config.read_commit_string:\n            with open(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/_primer/primer_prepare_command.py"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 41,
                  "endLine": 27,
                  "endColumn": 45,
                  "snippet": {
                    "text": "        elif self.config.check:\n            for package, data in self.packages.items():\n                local_commit = Repo(data.clone_directory).head.object.hexsha\n                print(f\"Found '{package}' at commit '{local_commit}'.\")\n                commit_string += local_commit[:8] + \"_\"\n        elif self.config.make_commit_string:\n            for package, data in self.packages.items():\n",
                    "rendered": {
                      "text": "        elif self.config.check:\n            for package, data in self.packages.items():\n                local_commit = Repo(data.clone_directory).head.object.hexsha\n                print(f\"Found '{package}' at commit '{local_commit}'.\")\n                commit_string += local_commit[:8] + \"_\"\n        elif self.config.make_commit_string:\n            for package, data in self.packages.items():\n",
                      "markdown": "`        elif self.config.check:\n            for package, data in self.packages.items():\n                local_commit = Repo(data.clone_directory).head.object.hexsha\n                print(f\"Found '{package}' at commit '{local_commit}'.\")\n                commit_string += local_commit[:8] + \"_\"\n        elif self.config.make_commit_string:\n            for package, data in self.packages.items():\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/_primer/primer_prepare_command.py"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 42,
                  "endLine": 22,
                  "endColumn": 46,
                  "snippet": {
                    "text": "        if self.config.clone:\n            for package, data in self.packages.items():\n                local_commit = data.lazy_clone()\n                print(f\"Cloned '{package}' at commit '{local_commit}'.\")\n                commit_string += local_commit[:8] + \"_\"\n        elif self.config.check:\n            for package, data in self.packages.items():\n",
                    "rendered": {
                      "text": "        if self.config.clone:\n            for package, data in self.packages.items():\n                local_commit = data.lazy_clone()\n                print(f\"Cloned '{package}' at commit '{local_commit}'.\")\n                commit_string += local_commit[:8] + \"_\"\n        elif self.config.check:\n            for package, data in self.packages.items():\n",
                      "markdown": "`        if self.config.clone:\n            for package, data in self.packages.items():\n                local_commit = data.lazy_clone()\n                print(f\"Cloned '{package}' at commit '{local_commit}'.\")\n                commit_string += local_commit[:8] + \"_\"\n        elif self.config.check:\n            for package, data in self.packages.items():\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/_primer/primer_compare_command.py"
                },
                "region": {
                  "startLine": 146,
                  "startColumn": 39,
                  "endLine": 146,
                  "endColumn": 43,
                  "snippet": {
                    "text": "            )\n            assert not self.packages[package].url.endswith(\n                \".git\"\n            ), \"You don't need the .git at the end of the github url.\"\n            comment += (\n                f\"{self.packages[package].url}\"\n                f\"/blob/{new_messages['commit']}/{filepath}#L{message['line']}\\n\"\n",
                    "rendered": {
                      "text": "            )\n            assert not self.packages[package].url.endswith(\n                \".git\"\n            ), \"You don't need the .git at the end of the github url.\"\n            comment += (\n                f\"{self.packages[package].url}\"\n                f\"/blob/{new_messages['commit']}/{filepath}#L{message['line']}\\n\"\n",
                      "markdown": "`            )\n            assert not self.packages[package].url.endswith(\n                \".git\"\n            ), \"You don't need the .git at the end of the github url.\"\n            comment += (\n                f\"{self.packages[package].url}\"\n                f\"/blob/{new_messages['commit']}/{filepath}#L{message['line']}\\n\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/_primer/primer.py"
                },
                "region": {
                  "startLine": 116,
                  "startColumn": 37,
                  "endLine": 116,
                  "endColumn": 42,
                  "snippet": {
                    "text": "\n    @staticmethod\n    def _minimum_python_supported(package_data: dict[str, str]) -> bool:\n        min_python_str = package_data.get(\"minimum_python\", None)\n        if not min_python_str:\n            return True\n        min_python_tuple = tuple(int(n) for n in min_python_str.split(\".\"))\n",
                    "rendered": {
                      "text": "\n    @staticmethod\n    def _minimum_python_supported(package_data: dict[str, str]) -> bool:\n        min_python_str = package_data.get(\"minimum_python\", None)\n        if not min_python_str:\n            return True\n        min_python_tuple = tuple(int(n) for n in min_python_str.split(\".\"))\n",
                      "markdown": "`\n    @staticmethod\n    def _minimum_python_supported(package_data: dict[str, str]) -> bool:\n        min_python_str = package_data.get(\"minimum_python\", None)\n        if not min_python_str:\n            return True\n        min_python_tuple = tuple(int(n) for n in min_python_str.split(\".\"))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/_primer/package_to_lint.py"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 9,
                  "endLine": 29,
                  "endColumn": 4,
                  "snippet": {
                    "text": "/!\\ Can't pull /!\\\n\nIn order for the prepare command to be able to pull please cleanup your local repo:\ncd {path}\ngit diff\n\"\"\"\n        )\n\n",
                    "rendered": {
                      "text": "/!\\ Can't pull /!\\\n\nIn order for the prepare command to be able to pull please cleanup your local repo:\ncd {path}\ngit diff\n\"\"\"\n        )\n\n",
                      "markdown": "`/!\\ Can't pull /!\\\n\nIn order for the prepare command to be able to pull please cleanup your local repo:\ncd {path}\ngit diff\n\"\"\"\n        )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/_primer/package_to_lint.py"
                },
                "region": {
                  "startLine": 12,
                  "startColumn": 19,
                  "endLine": 13,
                  "snippet": {
                    "text": "from typing import Literal\n\nfrom git import GitCommandError\nfrom git.cmd import Git\nfrom git.repo import Repo\n\nPRIMER_DIRECTORY_PATH = Path(\"tests\") / \".pylint_primer_tests\"\n\n",
                    "rendered": {
                      "text": "from typing import Literal\n\nfrom git import GitCommandError\nfrom git.cmd import Git\nfrom git.repo import Repo\n\nPRIMER_DIRECTORY_PATH = Path(\"tests\") / \".pylint_primer_tests\"\n\n",
                      "markdown": "`from typing import Literal\n\nfrom git import GitCommandError\nfrom git.cmd import Git\nfrom git.repo import Repo\n\nPRIMER_DIRECTORY_PATH = Path(\"tests\") / \".pylint_primer_tests\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/_primer/package_to_lint.py"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 4,
                  "endLine": 11,
                  "endColumn": 9,
                  "snippet": {
                    "text": "from pathlib import Path\nfrom typing import Literal\n\nfrom git import GitCommandError\nfrom git.cmd import Git\nfrom git.repo import Repo\n\n",
                    "rendered": {
                      "text": "from pathlib import Path\nfrom typing import Literal\n\nfrom git import GitCommandError\nfrom git.cmd import Git\nfrom git.repo import Repo\n\n",
                      "markdown": "`from pathlib import Path\nfrom typing import Literal\n\nfrom git import GitCommandError\nfrom git.cmd import Git\nfrom git.repo import Repo\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 3336,
                  "startColumn": 54,
                  "endLine": 3336,
                  "endColumn": 59,
                  "snippet": {
                    "text": "                        found = True\n                        break\n            # Check parent scope\n            nodes_in_parent_scope = parent_node.locals.get(name, [])\n            for found_node_parent in nodes_in_parent_scope:\n                if found_node_parent.lineno <= klass.lineno:\n                    found = True\n",
                    "rendered": {
                      "text": "                        found = True\n                        break\n            # Check parent scope\n            nodes_in_parent_scope = parent_node.locals.get(name, [])\n            for found_node_parent in nodes_in_parent_scope:\n                if found_node_parent.lineno <= klass.lineno:\n                    found = True\n",
                      "markdown": "`                        found = True\n                        break\n            # Check parent scope\n            nodes_in_parent_scope = parent_node.locals.get(name, [])\n            for found_node_parent in nodes_in_parent_scope:\n                if found_node_parent.lineno <= klass.lineno:\n                    found = True\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 3329,
                  "startColumn": 42,
                  "endLine": 3329,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        if name:\n            # check enclosing scopes starting from most local\n            for scope_locals, _, _, _ in self._to_consume[::-1]:\n                found_nodes = scope_locals.get(name, [])\n                for found_node in found_nodes:\n                    if found_node.lineno <= klass.lineno:\n                        consumed.append((scope_locals, name))\n",
                    "rendered": {
                      "text": "        if name:\n            # check enclosing scopes starting from most local\n            for scope_locals, _, _, _ in self._to_consume[::-1]:\n                found_nodes = scope_locals.get(name, [])\n                for found_node in found_nodes:\n                    if found_node.lineno <= klass.lineno:\n                        consumed.append((scope_locals, name))\n",
                      "markdown": "`        if name:\n            # check enclosing scopes starting from most local\n            for scope_locals, _, _, _ in self._to_consume[::-1]:\n                found_nodes = scope_locals.get(name, [])\n                for found_node in found_nodes:\n                    if found_node.lineno <= klass.lineno:\n                        consumed.append((scope_locals, name))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 3325,
                  "startColumn": 40,
                  "endLine": 3325,
                  "endColumn": 45,
                  "snippet": {
                    "text": "            name = metaclass.root().name\n\n        found = False\n        name = METACLASS_NAME_TRANSFORMS.get(name, name)\n        if name:\n            # check enclosing scopes starting from most local\n            for scope_locals, _, _, _ in self._to_consume[::-1]:\n",
                    "rendered": {
                      "text": "            name = metaclass.root().name\n\n        found = False\n        name = METACLASS_NAME_TRANSFORMS.get(name, name)\n        if name:\n            # check enclosing scopes starting from most local\n            for scope_locals, _, _, _ in self._to_consume[::-1]:\n",
                      "markdown": "`            name = metaclass.root().name\n\n        found = False\n        name = METACLASS_NAME_TRANSFORMS.get(name, name)\n        if name:\n            # check enclosing scopes starting from most local\n            for scope_locals, _, _, _ in self._to_consume[::-1]:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2433,
                  "startColumn": 44,
                  "endLine": 2433,
                  "endColumn": 49,
                  "snippet": {
                    "text": "                ):\n                    return False\n\n            local_refs = parent_scope.locals.get(node.name, [])\n            for ref_node in local_refs:\n                # If local ref is in the same frame as our node, but on a later lineno\n                # we don't actually care about this local ref.\n",
                    "rendered": {
                      "text": "                ):\n                    return False\n\n            local_refs = parent_scope.locals.get(node.name, [])\n            for ref_node in local_refs:\n                # If local ref is in the same frame as our node, but on a later lineno\n                # we don't actually care about this local ref.\n",
                      "markdown": "`                ):\n                    return False\n\n            local_refs = parent_scope.locals.get(node.name, [])\n            for ref_node in local_refs:\n                # If local ref is in the same frame as our node, but on a later lineno\n                # we don't actually care about this local ref.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1971,
                  "startColumn": 34,
                  "endLine": 1971,
                  "endColumn": 39,
                  "snippet": {
                    "text": "        elif not self._is_builtin(node.name) and self._is_only_type_assignment(\n            node, defstmt\n        ):\n            if node.scope().locals.get(node.name):\n                self.add_message(\n                    \"used-before-assignment\", args=node.name, node=node, confidence=HIGH\n                )\n",
                    "rendered": {
                      "text": "        elif not self._is_builtin(node.name) and self._is_only_type_assignment(\n            node, defstmt\n        ):\n            if node.scope().locals.get(node.name):\n                self.add_message(\n                    \"used-before-assignment\", args=node.name, node=node, confidence=HIGH\n                )\n",
                      "markdown": "`        elif not self._is_builtin(node.name) and self._is_only_type_assignment(\n            node, defstmt\n        ):\n            if node.scope().locals.get(node.name):\n                self.add_message(\n                    \"used-before-assignment\", args=node.name, node=node, confidence=HIGH\n                )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1617,
                  "startColumn": 36,
                  "endLine": 1617,
                  "endColumn": 41,
                  "snippet": {
                    "text": "\n            not_defined_locally_by_import = not any(\n                isinstance(local, (nodes.Import, nodes.ImportFrom))\n                for local in locals_.get(name, ())\n            )\n            if (\n                not utils.is_reassigned_after_current(node, name)\n",
                    "rendered": {
                      "text": "\n            not_defined_locally_by_import = not any(\n                isinstance(local, (nodes.Import, nodes.ImportFrom))\n                for local in locals_.get(name, ())\n            )\n            if (\n                not utils.is_reassigned_after_current(node, name)\n",
                      "markdown": "`\n            not_defined_locally_by_import = not any(\n                isinstance(local, (nodes.Import, nodes.ImportFrom))\n                for local in locals_.get(name, ())\n            )\n            if (\n                not utils.is_reassigned_after_current(node, name)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 613,
                  "startColumn": 37,
                  "endLine": 613,
                  "endColumn": 42,
                  "snippet": {
                    "text": "        \"\"\"\n        name = node.name\n        parent_node = node.parent\n        found_nodes = self.to_consume.get(name)\n        node_statement = node.statement()\n        if (\n            found_nodes\n",
                    "rendered": {
                      "text": "        \"\"\"\n        name = node.name\n        parent_node = node.parent\n        found_nodes = self.to_consume.get(name)\n        node_statement = node.statement()\n        if (\n            found_nodes\n",
                      "markdown": "`        \"\"\"\n        name = node.name\n        parent_node = node.parent\n        found_nodes = self.to_consume.get(name)\n        node_statement = node.statement()\n        if (\n            found_nodes\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 147,
                  "startColumn": 35,
                  "endLine": 147,
                  "endColumn": 40,
                  "snippet": {
                    "text": "    except astroid.AstroidBuildingError:\n        return None\n\n    for local_node in module.locals.get(name, []):\n        if isinstance(local_node, nodes.ImportFrom) and local_node.modname == FUTURE:\n            return True\n    return None\n",
                    "rendered": {
                      "text": "    except astroid.AstroidBuildingError:\n        return None\n\n    for local_node in module.locals.get(name, []):\n        if isinstance(local_node, nodes.ImportFrom) and local_node.modname == FUTURE:\n            return True\n    return None\n",
                      "markdown": "`    except astroid.AstroidBuildingError:\n        return None\n\n    for local_node in module.locals.get(name, []):\n        if isinstance(local_node, nodes.ImportFrom) and local_node.modname == FUTURE:\n            return True\n    return None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2883,
                  "startColumn": 14,
                  "endLine": 2883,
                  "endColumn": 18,
                  "snippet": {
                    "text": "        node_scope = node.frame()\n\n        # If node appears in a default argument expression,\n        # look at the next enclosing frame instead\n        if utils.is_default_argument(node, node_scope):\n            node_scope = node_scope.parent.frame()\n\n",
                    "rendered": {
                      "text": "        node_scope = node.frame()\n\n        # If node appears in a default argument expression,\n        # look at the next enclosing frame instead\n        if utils.is_default_argument(node, node_scope):\n            node_scope = node_scope.parent.frame()\n\n",
                      "markdown": "`        node_scope = node.frame()\n\n        # If node appears in a default argument expression,\n        # look at the next enclosing frame instead\n        if utils.is_default_argument(node, node_scope):\n            node_scope = node_scope.parent.frame()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2238,
                  "startColumn": 20,
                  "endLine": 2238,
                  "endColumn": 24,
                  "snippet": {
                    "text": "        if frame is not defframe:\n            maybe_before_assign = _detect_global_scope(node, frame, defframe)\n        elif defframe.parent is None:\n            # we are at the module level, check the name is not\n            # defined in builtins\n            if (\n                node.name in defframe.scope_attrs\n",
                    "rendered": {
                      "text": "        if frame is not defframe:\n            maybe_before_assign = _detect_global_scope(node, frame, defframe)\n        elif defframe.parent is None:\n            # we are at the module level, check the name is not\n            # defined in builtins\n            if (\n                node.name in defframe.scope_attrs\n",
                      "markdown": "`        if frame is not defframe:\n            maybe_before_assign = _detect_global_scope(node, frame, defframe)\n        elif defframe.parent is None:\n            # we are at the module level, check the name is not\n            # defined in builtins\n            if (\n                node.name in defframe.scope_attrs\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2143,
                  "startColumn": 26,
                  "endLine": 2143,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_listcomp(self, _: nodes.ListComp) -> None:\n        \"\"\"Leave listcomp: update consumption analysis variable.\"\"\"\n        # do not check for not used locals here\n        self._to_consume.pop()\n\n",
                    "rendered": {
                      "text": "        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_listcomp(self, _: nodes.ListComp) -> None:\n        \"\"\"Leave listcomp: update consumption analysis variable.\"\"\"\n        # do not check for not used locals here\n        self._to_consume.pop()\n\n",
                      "markdown": "`        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_listcomp(self, _: nodes.ListComp) -> None:\n        \"\"\"Leave listcomp: update consumption analysis variable.\"\"\"\n        # do not check for not used locals here\n        self._to_consume.pop()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2139,
                  "startColumn": 26,
                  "endLine": 2139,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\n    # listcomp have now also their scope\n    def visit_listcomp(self, node: nodes.ListComp) -> None:\n        \"\"\"Visit listcomp: update consumption analysis variable.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_listcomp(self, _: nodes.ListComp) -> None:\n",
                    "rendered": {
                      "text": "\n    # listcomp have now also their scope\n    def visit_listcomp(self, node: nodes.ListComp) -> None:\n        \"\"\"Visit listcomp: update consumption analysis variable.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_listcomp(self, _: nodes.ListComp) -> None:\n",
                      "markdown": "`\n    # listcomp have now also their scope\n    def visit_listcomp(self, node: nodes.ListComp) -> None:\n        \"\"\"Visit listcomp: update consumption analysis variable.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_listcomp(self, _: nodes.ListComp) -> None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1651,
                  "startColumn": 38,
                  "endLine": 1651,
                  "endColumn": 42,
                  "snippet": {
                    "text": "                    break\n            else:\n                if not_defined_locally_by_import:\n                    # global undefined at the module scope\n                    self.add_message(\n                        \"global-variable-undefined\",\n                        args=name,\n",
                    "rendered": {
                      "text": "                    break\n            else:\n                if not_defined_locally_by_import:\n                    # global undefined at the module scope\n                    self.add_message(\n                        \"global-variable-undefined\",\n                        args=name,\n",
                      "markdown": "`                    break\n            else:\n                if not_defined_locally_by_import:\n                    # global undefined at the module scope\n                    self.add_message(\n                        \"global-variable-undefined\",\n                        args=name,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1494,
                  "startColumn": 26,
                  "endLine": 1494,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        self._to_consume.pop()\n\n    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        \"\"\"Visit function: update consumption analysis variable and check locals.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"function\"))\n        if not (\n            self.linter.is_message_enabled(\"redefined-outer-name\")\n",
                    "rendered": {
                      "text": "        self._to_consume.pop()\n\n    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        \"\"\"Visit function: update consumption analysis variable and check locals.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"function\"))\n        if not (\n            self.linter.is_message_enabled(\"redefined-outer-name\")\n",
                      "markdown": "`        self._to_consume.pop()\n\n    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        \"\"\"Visit function: update consumption analysis variable and check locals.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"function\"))\n        if not (\n            self.linter.is_message_enabled(\"redefined-outer-name\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1489,
                  "startColumn": 25,
                  "endLine": 1489,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_setcomp(self, _: nodes.SetComp) -> None:\n        \"\"\"Leave setcomp: update consumption analysis variable.\"\"\"\n        # do not check for not used locals here\n        self._to_consume.pop()\n\n",
                    "rendered": {
                      "text": "        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_setcomp(self, _: nodes.SetComp) -> None:\n        \"\"\"Leave setcomp: update consumption analysis variable.\"\"\"\n        # do not check for not used locals here\n        self._to_consume.pop()\n\n",
                      "markdown": "`        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_setcomp(self, _: nodes.SetComp) -> None:\n        \"\"\"Leave setcomp: update consumption analysis variable.\"\"\"\n        # do not check for not used locals here\n        self._to_consume.pop()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1485,
                  "startColumn": 25,
                  "endLine": 1485,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        self._to_consume.pop()\n\n    def visit_setcomp(self, node: nodes.SetComp) -> None:\n        \"\"\"Visit setcomp: update consumption analysis variable.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_setcomp(self, _: nodes.SetComp) -> None:\n",
                    "rendered": {
                      "text": "        self._to_consume.pop()\n\n    def visit_setcomp(self, node: nodes.SetComp) -> None:\n        \"\"\"Visit setcomp: update consumption analysis variable.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_setcomp(self, _: nodes.SetComp) -> None:\n",
                      "markdown": "`        self._to_consume.pop()\n\n    def visit_setcomp(self, node: nodes.SetComp) -> None:\n        \"\"\"Visit setcomp: update consumption analysis variable.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_setcomp(self, _: nodes.SetComp) -> None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1480,
                  "startColumn": 26,
                  "endLine": 1480,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_dictcomp(self, _: nodes.DictComp) -> None:\n        \"\"\"Leave dictcomp: update consumption analysis variable.\"\"\"\n        # do not check for not used locals here\n        self._to_consume.pop()\n\n",
                    "rendered": {
                      "text": "        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_dictcomp(self, _: nodes.DictComp) -> None:\n        \"\"\"Leave dictcomp: update consumption analysis variable.\"\"\"\n        # do not check for not used locals here\n        self._to_consume.pop()\n\n",
                      "markdown": "`        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_dictcomp(self, _: nodes.DictComp) -> None:\n        \"\"\"Leave dictcomp: update consumption analysis variable.\"\"\"\n        # do not check for not used locals here\n        self._to_consume.pop()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1476,
                  "startColumn": 26,
                  "endLine": 1476,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        self._to_consume.pop()\n\n    def visit_dictcomp(self, node: nodes.DictComp) -> None:\n        \"\"\"Visit dictcomp: update consumption analysis variable.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_dictcomp(self, _: nodes.DictComp) -> None:\n",
                    "rendered": {
                      "text": "        self._to_consume.pop()\n\n    def visit_dictcomp(self, node: nodes.DictComp) -> None:\n        \"\"\"Visit dictcomp: update consumption analysis variable.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_dictcomp(self, _: nodes.DictComp) -> None:\n",
                      "markdown": "`        self._to_consume.pop()\n\n    def visit_dictcomp(self, node: nodes.DictComp) -> None:\n        \"\"\"Visit dictcomp: update consumption analysis variable.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_dictcomp(self, _: nodes.DictComp) -> None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1471,
                  "startColumn": 25,
                  "endLine": 1471,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_generatorexp(self, _: nodes.GeneratorExp) -> None:\n        \"\"\"Leave genexpr: update consumption analysis variable.\"\"\"\n        # do not check for not used locals here\n        self._to_consume.pop()\n\n",
                    "rendered": {
                      "text": "        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_generatorexp(self, _: nodes.GeneratorExp) -> None:\n        \"\"\"Leave genexpr: update consumption analysis variable.\"\"\"\n        # do not check for not used locals here\n        self._to_consume.pop()\n\n",
                      "markdown": "`        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_generatorexp(self, _: nodes.GeneratorExp) -> None:\n        \"\"\"Leave genexpr: update consumption analysis variable.\"\"\"\n        # do not check for not used locals here\n        self._to_consume.pop()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1467,
                  "startColumn": 25,
                  "endLine": 1467,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        self._to_consume.pop()\n\n    def visit_generatorexp(self, node: nodes.GeneratorExp) -> None:\n        \"\"\"Visit genexpr: update consumption analysis variable.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_generatorexp(self, _: nodes.GeneratorExp) -> None:\n",
                    "rendered": {
                      "text": "        self._to_consume.pop()\n\n    def visit_generatorexp(self, node: nodes.GeneratorExp) -> None:\n        \"\"\"Visit genexpr: update consumption analysis variable.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_generatorexp(self, _: nodes.GeneratorExp) -> None:\n",
                      "markdown": "`        self._to_consume.pop()\n\n    def visit_generatorexp(self, node: nodes.GeneratorExp) -> None:\n        \"\"\"Visit genexpr: update consumption analysis variable.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"comprehension\"))\n\n    def leave_generatorexp(self, _: nodes.GeneratorExp) -> None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1462,
                  "startColumn": 24,
                  "endLine": 1462,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        self._to_consume.append(NamesConsumer(node, \"lambda\"))\n\n    def leave_lambda(self, _: nodes.Lambda) -> None:\n        \"\"\"Leave lambda: update consumption analysis variable.\"\"\"\n        # do not check for not used locals here\n        self._to_consume.pop()\n\n",
                    "rendered": {
                      "text": "        self._to_consume.append(NamesConsumer(node, \"lambda\"))\n\n    def leave_lambda(self, _: nodes.Lambda) -> None:\n        \"\"\"Leave lambda: update consumption analysis variable.\"\"\"\n        # do not check for not used locals here\n        self._to_consume.pop()\n\n",
                      "markdown": "`        self._to_consume.append(NamesConsumer(node, \"lambda\"))\n\n    def leave_lambda(self, _: nodes.Lambda) -> None:\n        \"\"\"Leave lambda: update consumption analysis variable.\"\"\"\n        # do not check for not used locals here\n        self._to_consume.pop()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1458,
                  "startColumn": 24,
                  "endLine": 1458,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        self._to_consume.pop()\n\n    def visit_lambda(self, node: nodes.Lambda) -> None:\n        \"\"\"Visit lambda: update consumption analysis variable.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"lambda\"))\n\n    def leave_lambda(self, _: nodes.Lambda) -> None:\n",
                    "rendered": {
                      "text": "        self._to_consume.pop()\n\n    def visit_lambda(self, node: nodes.Lambda) -> None:\n        \"\"\"Visit lambda: update consumption analysis variable.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"lambda\"))\n\n    def leave_lambda(self, _: nodes.Lambda) -> None:\n",
                      "markdown": "`        self._to_consume.pop()\n\n    def visit_lambda(self, node: nodes.Lambda) -> None:\n        \"\"\"Visit lambda: update consumption analysis variable.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"lambda\"))\n\n    def leave_lambda(self, _: nodes.Lambda) -> None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1438,
                  "startColumn": 23,
                  "endLine": 1438,
                  "endColumn": 31,
                  "snippet": {
                    "text": "        self._to_consume.append(NamesConsumer(node, \"class\"))\n\n    def leave_classdef(self, node: nodes.ClassDef) -> None:\n        \"\"\"Leave class: update consumption analysis variable.\"\"\"\n        # Check for hidden ancestor names\n        # e.g. \"six\" in: Class X(six.with_metaclass(ABCMeta, object)):\n        for name_node in node.nodes_of_class(nodes.Name):\n",
                    "rendered": {
                      "text": "        self._to_consume.append(NamesConsumer(node, \"class\"))\n\n    def leave_classdef(self, node: nodes.ClassDef) -> None:\n        \"\"\"Leave class: update consumption analysis variable.\"\"\"\n        # Check for hidden ancestor names\n        # e.g. \"six\" in: Class X(six.with_metaclass(ABCMeta, object)):\n        for name_node in node.nodes_of_class(nodes.Name):\n",
                      "markdown": "`        self._to_consume.append(NamesConsumer(node, \"class\"))\n\n    def leave_classdef(self, node: nodes.ClassDef) -> None:\n        \"\"\"Leave class: update consumption analysis variable.\"\"\"\n        # Check for hidden ancestor names\n        # e.g. \"six\" in: Class X(six.with_metaclass(ABCMeta, object)):\n        for name_node in node.nodes_of_class(nodes.Name):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1434,
                  "startColumn": 23,
                  "endLine": 1434,
                  "endColumn": 31,
                  "snippet": {
                    "text": "        self._type_annotation_names = []\n\n    def visit_classdef(self, node: nodes.ClassDef) -> None:\n        \"\"\"Visit class: update consumption analysis variable.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"class\"))\n\n    def leave_classdef(self, node: nodes.ClassDef) -> None:\n",
                    "rendered": {
                      "text": "        self._type_annotation_names = []\n\n    def visit_classdef(self, node: nodes.ClassDef) -> None:\n        \"\"\"Visit class: update consumption analysis variable.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"class\"))\n\n    def leave_classdef(self, node: nodes.ClassDef) -> None:\n",
                      "markdown": "`        self._type_annotation_names = []\n\n    def visit_classdef(self, node: nodes.ClassDef) -> None:\n        \"\"\"Visit class: update consumption analysis variable.\"\"\"\n        self._to_consume.append(NamesConsumer(node, \"class\"))\n\n    def leave_classdef(self, node: nodes.ClassDef) -> None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1391,
                  "startColumn": 25,
                  "endLine": 1391,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        self._store_type_annotation_names(node)\n\n    def visit_module(self, node: nodes.Module) -> None:\n        \"\"\"Visit module : update consumption analysis variable\n        checks globals doesn't overrides builtins.\n        \"\"\"\n        self._to_consume = [NamesConsumer(node, \"module\")]\n",
                    "rendered": {
                      "text": "        self._store_type_annotation_names(node)\n\n    def visit_module(self, node: nodes.Module) -> None:\n        \"\"\"Visit module : update consumption analysis variable\n        checks globals doesn't overrides builtins.\n        \"\"\"\n        self._to_consume = [NamesConsumer(node, \"module\")]\n",
                      "markdown": "`        self._store_type_annotation_names(node)\n\n    def visit_module(self, node: nodes.Module) -> None:\n        \"\"\"Visit module : update consumption analysis variable\n        checks globals doesn't overrides builtins.\n        \"\"\"\n        self._to_consume = [NamesConsumer(node, \"module\")]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1140,
                  "startColumn": 61,
                  "endLine": 1140,
                  "endColumn": 65,
                  "snippet": {
                    "text": "                not in other_node_try_ancestor.body\n            ):\n                continue\n            # Make sure nesting is correct -- there should be at least one\n            # except handler that is a sibling attached to the try ancestor,\n            # or is an ancestor of the try ancestor.\n            if not any(\n",
                    "rendered": {
                      "text": "                not in other_node_try_ancestor.body\n            ):\n                continue\n            # Make sure nesting is correct -- there should be at least one\n            # except handler that is a sibling attached to the try ancestor,\n            # or is an ancestor of the try ancestor.\n            if not any(\n",
                      "markdown": "`                not in other_node_try_ancestor.body\n            ):\n                continue\n            # Make sure nesting is correct -- there should be at least one\n            # except handler that is a sibling attached to the try ancestor,\n            # or is an ancestor of the try ancestor.\n            if not any(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1082,
                  "startColumn": 46,
                  "endLine": 1082,
                  "endColumn": 50,
                  "snippet": {
                    "text": "            ):\n                break\n        else:\n            # No continue found, so we arrived at our special case!\n            return True\n        return False\n\n",
                    "rendered": {
                      "text": "            ):\n                break\n        else:\n            # No continue found, so we arrived at our special case!\n            return True\n        return False\n\n",
                      "markdown": "`            ):\n                break\n        else:\n            # No continue found, so we arrived at our special case!\n            return True\n        return False\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1017,
                  "startColumn": 31,
                  "endLine": 1017,
                  "endColumn": 40,
                  "snippet": {
                    "text": "    def _check_loop_finishes_via_except(\n        node: nodes.NodeNG, other_node_try_except: nodes.Try\n    ) -> bool:\n        \"\"\"Check for a specific control flow scenario.\n\n        Described in https://github.com/pylint-dev/pylint/issues/5683.\n\n",
                    "rendered": {
                      "text": "    def _check_loop_finishes_via_except(\n        node: nodes.NodeNG, other_node_try_except: nodes.Try\n    ) -> bool:\n        \"\"\"Check for a specific control flow scenario.\n\n        Described in https://github.com/pylint-dev/pylint/issues/5683.\n\n",
                      "markdown": "`    def _check_loop_finishes_via_except(\n        node: nodes.NodeNG, other_node_try_except: nodes.Try\n    ) -> bool:\n        \"\"\"Check for a specific control flow scenario.\n\n        Described in https://github.com/pylint-dev/pylint/issues/5683.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 816,
                  "startColumn": 41,
                  "endLine": 816,
                  "endColumn": 50,
                  "snippet": {
                    "text": "            if NamesConsumer._node_guarded_by_same_test(node, outer_if):\n                continue\n\n            # Name defined in the if/else control flow\n            if self._inferred_to_define_name_raise_or_return(name, outer_if):\n                continue\n\n",
                    "rendered": {
                      "text": "            if NamesConsumer._node_guarded_by_same_test(node, outer_if):\n                continue\n\n            # Name defined in the if/else control flow\n            if self._inferred_to_define_name_raise_or_return(name, outer_if):\n                continue\n\n",
                      "markdown": "`            if NamesConsumer._node_guarded_by_same_test(node, outer_if):\n                continue\n\n            # Name defined in the if/else control flow\n            if self._inferred_to_define_name_raise_or_return(name, outer_if):\n                continue\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 438,
                  "startColumn": 49,
                  "endLine": 438,
                  "endColumn": 53,
                  "snippet": {
                    "text": "    \"W0604\": (\n        \"Using the global statement at the module level\",  # W0103\n        \"global-at-module-level\",\n        'Used when you use the \"global\" statement at the module level '\n        \"since it has no effect.\",\n    ),\n    \"W0611\": (\n",
                    "rendered": {
                      "text": "    \"W0604\": (\n        \"Using the global statement at the module level\",  # W0103\n        \"global-at-module-level\",\n        'Used when you use the \"global\" statement at the module level '\n        \"since it has no effect.\",\n    ),\n    \"W0611\": (\n",
                      "markdown": "`    \"W0604\": (\n        \"Using the global statement at the module level\",  # W0103\n        \"global-at-module-level\",\n        'Used when you use the \"global\" statement at the module level '\n        \"since it has no effect.\",\n    ),\n    \"W0611\": (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 436,
                  "startColumn": 35,
                  "endLine": 436,
                  "endColumn": 39,
                  "snippet": {
                    "text": "        \"use it!\",\n    ),\n    \"W0604\": (\n        \"Using the global statement at the module level\",  # W0103\n        \"global-at-module-level\",\n        'Used when you use the \"global\" statement at the module level '\n        \"since it has no effect.\",\n",
                    "rendered": {
                      "text": "        \"use it!\",\n    ),\n    \"W0604\": (\n        \"Using the global statement at the module level\",  # W0103\n        \"global-at-module-level\",\n        'Used when you use the \"global\" statement at the module level '\n        \"since it has no effect.\",\n",
                      "markdown": "`        \"use it!\",\n    ),\n    \"W0604\": (\n        \"Using the global statement at the module level\",  # W0103\n        \"global-at-module-level\",\n        'Used when you use the \"global\" statement at the module level '\n        \"since it has no effect.\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 431,
                  "startColumn": 52,
                  "endLine": 431,
                  "endColumn": 60,
                  "snippet": {
                    "text": "    \"W0603\": (\n        \"Using the global statement\",  # W0121\n        \"global-statement\",\n        'Used when you use the \"global\" statement to update a global '\n        \"variable. Pylint discourages its usage. That doesn't mean you cannot \"\n        \"use it!\",\n    ),\n",
                    "rendered": {
                      "text": "    \"W0603\": (\n        \"Using the global statement\",  # W0121\n        \"global-statement\",\n        'Used when you use the \"global\" statement to update a global '\n        \"variable. Pylint discourages its usage. That doesn't mean you cannot \"\n        \"use it!\",\n    ),\n",
                      "markdown": "`    \"W0603\": (\n        \"Using the global statement\",  # W0121\n        \"global-statement\",\n        'Used when you use the \"global\" statement to update a global '\n        \"variable. Pylint discourages its usage. That doesn't mean you cannot \"\n        \"use it!\",\n    ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 416,
                  "startColumn": 37,
                  "endLine": 416,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        \"Used when a name cannot be found in a module.\",\n    ),\n    \"W0601\": (\n        \"Global variable %r undefined at the module level\",\n        \"global-variable-undefined\",\n        'Used when a variable is defined through the \"global\" statement '\n        \"but the variable is not defined in the module scope.\",\n",
                    "rendered": {
                      "text": "        \"Used when a name cannot be found in a module.\",\n    ),\n    \"W0601\": (\n        \"Global variable %r undefined at the module level\",\n        \"global-variable-undefined\",\n        'Used when a variable is defined through the \"global\" statement '\n        \"but the variable is not defined in the module scope.\",\n",
                      "markdown": "`        \"Used when a name cannot be found in a module.\",\n    ),\n    \"W0601\": (\n        \"Global variable %r undefined at the module level\",\n        \"global-variable-undefined\",\n        'Used when a variable is defined through the \"global\" statement '\n        \"but the variable is not defined in the module scope.\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 247,
                  "startColumn": 5,
                  "endLine": 247,
                  "endColumn": 9,
                  "snippet": {
                    "text": "        # For instance, this works when they are inside a function, the node\n        # that uses a definition and the definition itself.\n        return False\n    # At this point, we are certain that frame and defframe share a scope\n    # and the definition of the first depends on the second.\n    return frame.lineno < defframe.lineno  # type: ignore[no-any-return]\n\n",
                    "rendered": {
                      "text": "        # For instance, this works when they are inside a function, the node\n        # that uses a definition and the definition itself.\n        return False\n    # At this point, we are certain that frame and defframe share a scope\n    # and the definition of the first depends on the second.\n    return frame.lineno < defframe.lineno  # type: ignore[no-any-return]\n\n",
                      "markdown": "`        # For instance, this works when they are inside a function, the node\n        # that uses a definition and the definition itself.\n        return False\n    # At this point, we are certain that frame and defframe share a scope\n    # and the definition of the first depends on the second.\n    return frame.lineno < defframe.lineno  # type: ignore[no-any-return]\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 172,
                  "startColumn": 24,
                  "endLine": 172,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        elif inferred.lineno:\n            more = f\"defined at line {inferred.lineno}\"\n    elif inferred.lineno:\n        more = f\"defined at line {inferred.lineno} of {inferred_module}\"\n    return more\n\n\n",
                    "rendered": {
                      "text": "        elif inferred.lineno:\n            more = f\"defined at line {inferred.lineno}\"\n    elif inferred.lineno:\n        more = f\"defined at line {inferred.lineno} of {inferred_module}\"\n    return more\n\n\n",
                      "markdown": "`        elif inferred.lineno:\n            more = f\"defined at line {inferred.lineno}\"\n    elif inferred.lineno:\n        more = f\"defined at line {inferred.lineno} of {inferred_module}\"\n    return more\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 170,
                  "startColumn": 28,
                  "endLine": 170,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        if node.lineno == inferred.lineno:\n            more = f\"'{inferred.as_string()}'\"\n        elif inferred.lineno:\n            more = f\"defined at line {inferred.lineno}\"\n    elif inferred.lineno:\n        more = f\"defined at line {inferred.lineno} of {inferred_module}\"\n    return more\n",
                    "rendered": {
                      "text": "        if node.lineno == inferred.lineno:\n            more = f\"'{inferred.as_string()}'\"\n        elif inferred.lineno:\n            more = f\"defined at line {inferred.lineno}\"\n    elif inferred.lineno:\n        more = f\"defined at line {inferred.lineno} of {inferred_module}\"\n    return more\n",
                      "markdown": "`        if node.lineno == inferred.lineno:\n            more = f\"'{inferred.as_string()}'\"\n        elif inferred.lineno:\n            more = f\"defined at line {inferred.lineno}\"\n    elif inferred.lineno:\n        more = f\"defined at line {inferred.lineno} of {inferred_module}\"\n    return more\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 3192,
                  "startColumn": 15,
                  "endLine": 3192,
                  "endColumn": 21,
                  "snippet": {
                    "text": "        if self._allow_global_unused_variables:\n            return\n        for name, node_lst in not_consumed.items():\n            for node in node_lst:\n                if in_type_checking_block(node):\n                    continue\n                self.add_message(\"unused-variable\", args=(name,), node=node)\n",
                    "rendered": {
                      "text": "        if self._allow_global_unused_variables:\n            return\n        for name, node_lst in not_consumed.items():\n            for node in node_lst:\n                if in_type_checking_block(node):\n                    continue\n                self.add_message(\"unused-variable\", args=(name,), node=node)\n",
                      "markdown": "`        if self._allow_global_unused_variables:\n            return\n        for name, node_lst in not_consumed.items():\n            for node in node_lst:\n                if in_type_checking_block(node):\n                    continue\n                self.add_message(\"unused-variable\", args=(name,), node=node)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2887,
                  "startColumn": 18,
                  "endLine": 2887,
                  "endColumn": 24,
                  "snippet": {
                    "text": "        if utils.is_default_argument(node, node_scope):\n            node_scope = node_scope.parent.frame()\n\n        # Check if node is a cell var\n        if (\n            not isinstance(node_scope, (nodes.Lambda, nodes.FunctionDef))\n            or node.name in node_scope.locals\n",
                    "rendered": {
                      "text": "        if utils.is_default_argument(node, node_scope):\n            node_scope = node_scope.parent.frame()\n\n        # Check if node is a cell var\n        if (\n            not isinstance(node_scope, (nodes.Lambda, nodes.FunctionDef))\n            or node.name in node_scope.locals\n",
                      "markdown": "`        if utils.is_default_argument(node, node_scope):\n            node_scope = node_scope.parent.frame()\n\n        # Check if node is a cell var\n        if (\n            not isinstance(node_scope, (nodes.Lambda, nodes.FunctionDef))\n            or node.name in node_scope.locals\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2882,
                  "startColumn": 12,
                  "endLine": 2882,
                  "endColumn": 18,
                  "snippet": {
                    "text": "\n        node_scope = node.frame()\n\n        # If node appears in a default argument expression,\n        # look at the next enclosing frame instead\n        if utils.is_default_argument(node, node_scope):\n            node_scope = node_scope.parent.frame()\n",
                    "rendered": {
                      "text": "\n        node_scope = node.frame()\n\n        # If node appears in a default argument expression,\n        # look at the next enclosing frame instead\n        if utils.is_default_argument(node, node_scope):\n            node_scope = node_scope.parent.frame()\n",
                      "markdown": "`\n        node_scope = node.frame()\n\n        # If node appears in a default argument expression,\n        # look at the next enclosing frame instead\n        if utils.is_default_argument(node, node_scope):\n            node_scope = node_scope.parent.frame()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2871,
                  "startColumn": 24,
                  "endLine": 2871,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        self.add_message(\"unused-argument\", args=name, node=stmt, confidence=confidence)\n\n    def _check_late_binding_closure(self, node: nodes.Name) -> None:\n        \"\"\"Check whether node is a cell var that is assigned within a containing loop.\n\n        Special cases where we don't care about the error:\n        1. When the node's function is immediately called, e.g. (lambda: i)()\n",
                    "rendered": {
                      "text": "        self.add_message(\"unused-argument\", args=name, node=stmt, confidence=confidence)\n\n    def _check_late_binding_closure(self, node: nodes.Name) -> None:\n        \"\"\"Check whether node is a cell var that is assigned within a containing loop.\n\n        Special cases where we don't care about the error:\n        1. When the node's function is immediately called, e.g. (lambda: i)()\n",
                      "markdown": "`        self.add_message(\"unused-argument\", args=name, node=stmt, confidence=confidence)\n\n    def _check_late_binding_closure(self, node: nodes.Name) -> None:\n        \"\"\"Check whether node is a cell var that is assigned within a containing loop.\n\n        Special cases where we don't care about the error:\n        1. When the node's function is immediately called, e.g. (lambda: i)()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2510,
                  "startColumn": 29,
                  "endLine": 2510,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        )\n\n    def _ignore_class_scope(self, node: nodes.NodeNG) -> bool:\n        \"\"\"Return True if the node is in a local class scope, as an assignment.\n\n        Detect if we are in a local class scope, as an assignment.\n        For example, the following is fair game.\n",
                    "rendered": {
                      "text": "        )\n\n    def _ignore_class_scope(self, node: nodes.NodeNG) -> bool:\n        \"\"\"Return True if the node is in a local class scope, as an assignment.\n\n        Detect if we are in a local class scope, as an assignment.\n        For example, the following is fair game.\n",
                      "markdown": "`        )\n\n    def _ignore_class_scope(self, node: nodes.NodeNG) -> bool:\n        \"\"\"Return True if the node is in a local class scope, as an assignment.\n\n        Detect if we are in a local class scope, as an assignment.\n        For example, the following is fair game.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2426,
                  "startColumn": 23,
                  "endLine": 2426,
                  "endColumn": 27,
                  "snippet": {
                    "text": "                    continue\n                if any(\n                    node.name in nl.names\n                    for nl in inner_func.nodes_of_class(nodes.Nonlocal)\n                ) and any(\n                    node.name == an.name\n                    for an in inner_func.nodes_of_class(nodes.AssignName)\n",
                    "rendered": {
                      "text": "                    continue\n                if any(\n                    node.name in nl.names\n                    for nl in inner_func.nodes_of_class(nodes.Nonlocal)\n                ) and any(\n                    node.name == an.name\n                    for an in inner_func.nodes_of_class(nodes.AssignName)\n",
                      "markdown": "`                    continue\n                if any(\n                    node.name in nl.names\n                    for nl in inner_func.nodes_of_class(nodes.Nonlocal)\n                ) and any(\n                    node.name == an.name\n                    for an in inner_func.nodes_of_class(nodes.AssignName)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2420,
                  "startColumn": 13,
                  "endLine": 2420,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        while parent is not defstmt_frame.parent:\n            parent_scope = parent.scope()\n\n            # Find out if any nonlocals receive values in nested functions\n            for inner_func in parent_scope.nodes_of_class(nodes.FunctionDef):\n                if inner_func is parent_scope:\n                    continue\n",
                    "rendered": {
                      "text": "        while parent is not defstmt_frame.parent:\n            parent_scope = parent.scope()\n\n            # Find out if any nonlocals receive values in nested functions\n            for inner_func in parent_scope.nodes_of_class(nodes.FunctionDef):\n                if inner_func is parent_scope:\n                    continue\n",
                      "markdown": "`        while parent is not defstmt_frame.parent:\n            parent_scope = parent.scope()\n\n            # Find out if any nonlocals receive values in nested functions\n            for inner_func in parent_scope.nodes_of_class(nodes.FunctionDef):\n                if inner_func is parent_scope:\n                    continue\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2416,
                  "startColumn": 16,
                  "endLine": 2417,
                  "snippet": {
                    "text": "        defstmt_frame = defstmt.frame()\n        node_frame = node.frame()\n\n        parent = node\n        while parent is not defstmt_frame.parent:\n            parent_scope = parent.scope()\n\n            # Find out if any nonlocals receive values in nested functions\n",
                    "rendered": {
                      "text": "        defstmt_frame = defstmt.frame()\n        node_frame = node.frame()\n\n        parent = node\n        while parent is not defstmt_frame.parent:\n            parent_scope = parent.scope()\n\n            # Find out if any nonlocals receive values in nested functions\n",
                      "markdown": "`        defstmt_frame = defstmt.frame()\n        node_frame = node.frame()\n\n        parent = node\n        while parent is not defstmt_frame.parent:\n            parent_scope = parent.scope()\n\n            # Find out if any nonlocals receive values in nested functions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2357,
                  "startColumn": 58,
                  "endLine": 2357,
                  "endColumn": 64,
                  "snippet": {
                    "text": "                    # (b := b)\n                    # Otherwise, safe if used after assignment:\n                    # (b := 2) and b\n                    maybe_before_assign = defnode.value is node or any(\n                        anc is defnode.value for anc in node.node_ancestors()\n                    )\n\n",
                    "rendered": {
                      "text": "                    # (b := b)\n                    # Otherwise, safe if used after assignment:\n                    # (b := 2) and b\n                    maybe_before_assign = defnode.value is node or any(\n                        anc is defnode.value for anc in node.node_ancestors()\n                    )\n\n",
                      "markdown": "`                    # (b := b)\n                    # Otherwise, safe if used after assignment:\n                    # (b := 2) and b\n                    maybe_before_assign = defnode.value is node or any(\n                        anc is defnode.value for anc in node.node_ancestors()\n                    )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2293,
                  "startColumn": 14,
                  "endLine": 2293,
                  "endColumn": 20,
                  "snippet": {
                    "text": "        ):\n            # Special rule for function return annotations,\n            # using a name defined earlier in the class containing the function.\n            if node is frame.returns and defframe.parent_of(frame.returns):\n                annotation_return = True\n                if frame.returns.name in defframe.locals:\n                    definition = defframe.locals[node.name][0]\n",
                    "rendered": {
                      "text": "        ):\n            # Special rule for function return annotations,\n            # using a name defined earlier in the class containing the function.\n            if node is frame.returns and defframe.parent_of(frame.returns):\n                annotation_return = True\n                if frame.returns.name in defframe.locals:\n                    definition = defframe.locals[node.name][0]\n",
                      "markdown": "`        ):\n            # Special rule for function return annotations,\n            # using a name defined earlier in the class containing the function.\n            if node is frame.returns and defframe.parent_of(frame.returns):\n                annotation_return = True\n                if frame.returns.name in defframe.locals:\n                    definition = defframe.locals[node.name][0]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2285,
                  "startColumn": 19,
                  "endLine": 2285,
                  "endColumn": 25,
                  "snippet": {
                    "text": "            # it should be True.\n            maybe_before_assign = not (\n                isinstance(defnode, nodes.Arguments)\n                and node in defnode.defaults\n                and frame.locals[node.name][0].fromlineno < defstmt.fromlineno\n            )\n        elif isinstance(defframe, nodes.ClassDef) and isinstance(\n",
                    "rendered": {
                      "text": "            # it should be True.\n            maybe_before_assign = not (\n                isinstance(defnode, nodes.Arguments)\n                and node in defnode.defaults\n                and frame.locals[node.name][0].fromlineno < defstmt.fromlineno\n            )\n        elif isinstance(defframe, nodes.ClassDef) and isinstance(\n",
                      "markdown": "`            # it should be True.\n            maybe_before_assign = not (\n                isinstance(defnode, nodes.Arguments)\n                and node in defnode.defaults\n                and frame.locals[node.name][0].fromlineno < defstmt.fromlineno\n            )\n        elif isinstance(defframe, nodes.ClassDef) and isinstance(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2273,
                  "startColumn": 42,
                  "endLine": 2273,
                  "endColumn": 48,
                  "snippet": {
                    "text": "            and node.name in frame.locals\n        ):\n            # This rule verifies that if the definition node of the\n            # checked name is an Arguments node and if the name\n            # is used a default value in the arguments defaults\n            # and the actual definition of the variable label\n            # is happening before the Arguments definition.\n",
                    "rendered": {
                      "text": "            and node.name in frame.locals\n        ):\n            # This rule verifies that if the definition node of the\n            # checked name is an Arguments node and if the name\n            # is used a default value in the arguments defaults\n            # and the actual definition of the variable label\n            # is happening before the Arguments definition.\n",
                      "markdown": "`            and node.name in frame.locals\n        ):\n            # This rule verifies that if the definition node of the\n            # checked name is an Arguments node and if the name\n            # is used a default value in the arguments defaults\n            # and the actual definition of the variable label\n            # is happening before the Arguments definition.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2272,
                  "startColumn": 55,
                  "endLine": 2272,
                  "endColumn": 61,
                  "snippet": {
                    "text": "            and isinstance(frame, nodes.ClassDef)\n            and node.name in frame.locals\n        ):\n            # This rule verifies that if the definition node of the\n            # checked name is an Arguments node and if the name\n            # is used a default value in the arguments defaults\n            # and the actual definition of the variable label\n",
                    "rendered": {
                      "text": "            and isinstance(frame, nodes.ClassDef)\n            and node.name in frame.locals\n        ):\n            # This rule verifies that if the definition node of the\n            # checked name is an Arguments node and if the name\n            # is used a default value in the arguments defaults\n            # and the actual definition of the variable label\n",
                      "markdown": "`            and isinstance(frame, nodes.ClassDef)\n            and node.name in frame.locals\n        ):\n            # This rule verifies that if the definition node of the\n            # checked name is an Arguments node and if the name\n            # is used a default value in the arguments defaults\n            # and the actual definition of the variable label\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2227,
                  "startColumn": 63,
                  "endLine": 2228,
                  "snippet": {
                    "text": "        defnode: nodes.NodeNG,\n        stmt: _base_nodes.Statement,\n        defstmt: _base_nodes.Statement,\n        frame: nodes.LocalsDictNodeNG,  # scope of statement of node\n        defframe: nodes.LocalsDictNodeNG,\n        base_scope_type: str,\n        is_recursive_klass: bool,\n    ) -> tuple[bool, bool, bool]:\n",
                    "rendered": {
                      "text": "        defnode: nodes.NodeNG,\n        stmt: _base_nodes.Statement,\n        defstmt: _base_nodes.Statement,\n        frame: nodes.LocalsDictNodeNG,  # scope of statement of node\n        defframe: nodes.LocalsDictNodeNG,\n        base_scope_type: str,\n        is_recursive_klass: bool,\n    ) -> tuple[bool, bool, bool]:\n",
                      "markdown": "`        defnode: nodes.NodeNG,\n        stmt: _base_nodes.Statement,\n        defstmt: _base_nodes.Statement,\n        frame: nodes.LocalsDictNodeNG,  # scope of statement of node\n        defframe: nodes.LocalsDictNodeNG,\n        base_scope_type: str,\n        is_recursive_klass: bool,\n    ) -> tuple[bool, bool, bool]:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2200,
                  "startColumn": 15,
                  "endLine": 2201,
                  "snippet": {
                    "text": "        \"\"\"Return True if node within a lambda/comprehension body (or similar) and thus\n        should not have access to class attributes in frame.\n        \"\"\"\n        child = node\n        parent = node.parent\n        while parent is not None:\n            if parent is frame:\n                return False\n",
                    "rendered": {
                      "text": "        \"\"\"Return True if node within a lambda/comprehension body (or similar) and thus\n        should not have access to class attributes in frame.\n        \"\"\"\n        child = node\n        parent = node.parent\n        while parent is not None:\n            if parent is frame:\n                return False\n",
                      "markdown": "`        \"\"\"Return True if node within a lambda/comprehension body (or similar) and thus\n        should not have access to class attributes in frame.\n        \"\"\"\n        child = node\n        parent = node.parent\n        while parent is not None:\n            if parent is frame:\n                return False\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2197,
                  "startColumn": 25,
                  "endLine": 2197,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    def _in_lambda_or_comprehension_body(\n        node: nodes.NodeNG, frame: nodes.NodeNG\n    ) -> bool:\n        \"\"\"Return True if node within a lambda/comprehension body (or similar) and thus\n        should not have access to class attributes in frame.\n        \"\"\"\n        child = node\n",
                    "rendered": {
                      "text": "    def _in_lambda_or_comprehension_body(\n        node: nodes.NodeNG, frame: nodes.NodeNG\n    ) -> bool:\n        \"\"\"Return True if node within a lambda/comprehension body (or similar) and thus\n        should not have access to class attributes in frame.\n        \"\"\"\n        child = node\n",
                      "markdown": "`    def _in_lambda_or_comprehension_body(\n        node: nodes.NodeNG, frame: nodes.NodeNG\n    ) -> bool:\n        \"\"\"Return True if node within a lambda/comprehension body (or similar) and thus\n        should not have access to class attributes in frame.\n        \"\"\"\n        child = node\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2182,
                  "startColumn": 22,
                  "endLine": 2182,
                  "endColumn": 28,
                  "snippet": {
                    "text": "                    or node in frame.args.posonlyargs_annotations\n                    or node in frame.args.kwonlyargs_annotations\n                    or node is frame.args.varargannotation\n                    or node is frame.args.kwargannotation\n                )\n                or frame.args.parent_of(node)\n                or (frame.decorators and frame.decorators.parent_of(node))\n",
                    "rendered": {
                      "text": "                    or node in frame.args.posonlyargs_annotations\n                    or node in frame.args.kwonlyargs_annotations\n                    or node is frame.args.varargannotation\n                    or node is frame.args.kwargannotation\n                )\n                or frame.args.parent_of(node)\n                or (frame.decorators and frame.decorators.parent_of(node))\n",
                      "markdown": "`                    or node in frame.args.posonlyargs_annotations\n                    or node in frame.args.kwonlyargs_annotations\n                    or node is frame.args.varargannotation\n                    or node is frame.args.kwargannotation\n                )\n                or frame.args.parent_of(node)\n                or (frame.decorators and frame.decorators.parent_of(node))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2181,
                  "startColumn": 22,
                  "endLine": 2181,
                  "endColumn": 28,
                  "snippet": {
                    "text": "                    node in frame.args.annotations\n                    or node in frame.args.posonlyargs_annotations\n                    or node in frame.args.kwonlyargs_annotations\n                    or node is frame.args.varargannotation\n                    or node is frame.args.kwargannotation\n                )\n                or frame.args.parent_of(node)\n",
                    "rendered": {
                      "text": "                    node in frame.args.annotations\n                    or node in frame.args.posonlyargs_annotations\n                    or node in frame.args.kwonlyargs_annotations\n                    or node is frame.args.varargannotation\n                    or node is frame.args.kwargannotation\n                )\n                or frame.args.parent_of(node)\n",
                      "markdown": "`                    node in frame.args.annotations\n                    or node in frame.args.posonlyargs_annotations\n                    or node in frame.args.kwonlyargs_annotations\n                    or node is frame.args.varargannotation\n                    or node is frame.args.kwargannotation\n                )\n                or frame.args.parent_of(node)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2180,
                  "startColumn": 22,
                  "endLine": 2180,
                  "endColumn": 28,
                  "snippet": {
                    "text": "                (\n                    node in frame.args.annotations\n                    or node in frame.args.posonlyargs_annotations\n                    or node in frame.args.kwonlyargs_annotations\n                    or node is frame.args.varargannotation\n                    or node is frame.args.kwargannotation\n                )\n",
                    "rendered": {
                      "text": "                (\n                    node in frame.args.annotations\n                    or node in frame.args.posonlyargs_annotations\n                    or node in frame.args.kwonlyargs_annotations\n                    or node is frame.args.varargannotation\n                    or node is frame.args.kwargannotation\n                )\n",
                      "markdown": "`                (\n                    node in frame.args.annotations\n                    or node in frame.args.posonlyargs_annotations\n                    or node in frame.args.kwonlyargs_annotations\n                    or node is frame.args.varargannotation\n                    or node is frame.args.kwargannotation\n                )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2179,
                  "startColumn": 22,
                  "endLine": 2179,
                  "endColumn": 28,
                  "snippet": {
                    "text": "            in_annotation_or_default_or_decorator = (\n                (\n                    node in frame.args.annotations\n                    or node in frame.args.posonlyargs_annotations\n                    or node in frame.args.kwonlyargs_annotations\n                    or node is frame.args.varargannotation\n                    or node is frame.args.kwargannotation\n",
                    "rendered": {
                      "text": "            in_annotation_or_default_or_decorator = (\n                (\n                    node in frame.args.annotations\n                    or node in frame.args.posonlyargs_annotations\n                    or node in frame.args.kwonlyargs_annotations\n                    or node is frame.args.varargannotation\n                    or node is frame.args.kwargannotation\n",
                      "markdown": "`            in_annotation_or_default_or_decorator = (\n                (\n                    node in frame.args.annotations\n                    or node in frame.args.posonlyargs_annotations\n                    or node in frame.args.kwonlyargs_annotations\n                    or node is frame.args.varargannotation\n                    or node is frame.args.kwargannotation\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2178,
                  "startColumn": 19,
                  "endLine": 2178,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        if isinstance(frame, nodes.FunctionDef) and node.statement() is frame:\n            in_annotation_or_default_or_decorator = (\n                (\n                    node in frame.args.annotations\n                    or node in frame.args.posonlyargs_annotations\n                    or node in frame.args.kwonlyargs_annotations\n                    or node is frame.args.varargannotation\n",
                    "rendered": {
                      "text": "        if isinstance(frame, nodes.FunctionDef) and node.statement() is frame:\n            in_annotation_or_default_or_decorator = (\n                (\n                    node in frame.args.annotations\n                    or node in frame.args.posonlyargs_annotations\n                    or node in frame.args.kwonlyargs_annotations\n                    or node is frame.args.varargannotation\n",
                      "markdown": "`        if isinstance(frame, nodes.FunctionDef) and node.statement() is frame:\n            in_annotation_or_default_or_decorator = (\n                (\n                    node in frame.args.annotations\n                    or node in frame.args.posonlyargs_annotations\n                    or node in frame.args.kwonlyargs_annotations\n                    or node is frame.args.varargannotation\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 2039,
                  "startColumn": 46,
                  "endLine": 2039,
                  "endColumn": 52,
                  "snippet": {
                    "text": "    def _filter_type_checking_import_from_consumption(\n        self, node: nodes.NodeNG, nodes_to_consume: list[nodes.NodeNG]\n    ) -> list[nodes.NodeNG]:\n        \"\"\"Do not consume type-checking import node as used-before-assignment\n        may invoke in different scopes.\n        \"\"\"\n        type_checking_import = next(\n",
                    "rendered": {
                      "text": "    def _filter_type_checking_import_from_consumption(\n        self, node: nodes.NodeNG, nodes_to_consume: list[nodes.NodeNG]\n    ) -> list[nodes.NodeNG]:\n        \"\"\"Do not consume type-checking import node as used-before-assignment\n        may invoke in different scopes.\n        \"\"\"\n        type_checking_import = next(\n",
                      "markdown": "`    def _filter_type_checking_import_from_consumption(\n        self, node: nodes.NodeNG, nodes_to_consume: list[nodes.NodeNG]\n    ) -> list[nodes.NodeNG]:\n        \"\"\"Do not consume type-checking import node as used-before-assignment\n        may invoke in different scopes.\n        \"\"\"\n        type_checking_import = next(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1785,
                  "startColumn": 25,
                  "endLine": 1785,
                  "endColumn": 31,
                  "snippet": {
                    "text": "            if any(node.name == param.name.name for param in consumer.node.type_params):\n                return False\n\n            # If the name node is used as a function default argument's value or as\n            # a decorator, then start from the parent frame of the function instead\n            # of the function frame - and thus open an inner class scope\n            return True\n",
                    "rendered": {
                      "text": "            if any(node.name == param.name.name for param in consumer.node.type_params):\n                return False\n\n            # If the name node is used as a function default argument's value or as\n            # a decorator, then start from the parent frame of the function instead\n            # of the function frame - and thus open an inner class scope\n            return True\n",
                      "markdown": "`            if any(node.name == param.name.name for param in consumer.node.type_params):\n                return False\n\n            # If the name node is used as a function default argument's value or as\n            # a decorator, then start from the parent frame of the function instead\n            # of the function frame - and thus open an inner class scope\n            return True\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1758,
                  "startColumn": 72,
                  "endLine": 1758,
                  "endColumn": 78,
                  "snippet": {
                    "text": "    def _should_node_be_skipped(\n        self, node: nodes.Name, consumer: NamesConsumer, is_start_index: bool\n    ) -> bool:\n        \"\"\"Tests a consumer and node for various conditions in which the node shouldn't\n        be checked for the undefined-variable and used-before-assignment checks.\n        \"\"\"\n        if consumer.scope_type == \"class\":\n",
                    "rendered": {
                      "text": "    def _should_node_be_skipped(\n        self, node: nodes.Name, consumer: NamesConsumer, is_start_index: bool\n    ) -> bool:\n        \"\"\"Tests a consumer and node for various conditions in which the node shouldn't\n        be checked for the undefined-variable and used-before-assignment checks.\n        \"\"\"\n        if consumer.scope_type == \"class\":\n",
                      "markdown": "`    def _should_node_be_skipped(\n        self, node: nodes.Name, consumer: NamesConsumer, is_start_index: bool\n    ) -> bool:\n        \"\"\"Tests a consumer and node for various conditions in which the node shouldn't\n        be checked for the undefined-variable and used-before-assignment checks.\n        \"\"\"\n        if consumer.scope_type == \"class\":\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1758,
                  "startColumn": 31,
                  "endLine": 1758,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    def _should_node_be_skipped(\n        self, node: nodes.Name, consumer: NamesConsumer, is_start_index: bool\n    ) -> bool:\n        \"\"\"Tests a consumer and node for various conditions in which the node shouldn't\n        be checked for the undefined-variable and used-before-assignment checks.\n        \"\"\"\n        if consumer.scope_type == \"class\":\n",
                    "rendered": {
                      "text": "    def _should_node_be_skipped(\n        self, node: nodes.Name, consumer: NamesConsumer, is_start_index: bool\n    ) -> bool:\n        \"\"\"Tests a consumer and node for various conditions in which the node shouldn't\n        be checked for the undefined-variable and used-before-assignment checks.\n        \"\"\"\n        if consumer.scope_type == \"class\":\n",
                      "markdown": "`    def _should_node_be_skipped(\n        self, node: nodes.Name, consumer: NamesConsumer, is_start_index: bool\n    ) -> bool:\n        \"\"\"Tests a consumer and node for various conditions in which the node shouldn't\n        be checked for the undefined-variable and used-before-assignment checks.\n        \"\"\"\n        if consumer.scope_type == \"class\":\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1719,
                  "startColumn": 76,
                  "endLine": 1720,
                  "snippet": {
                    "text": "        for i in range(start_index, -1, -1):\n            current_consumer = self._to_consume[i]\n\n            # Certain nodes shouldn't be checked as they get checked another time\n            if self._should_node_be_skipped(node, current_consumer, i == start_index):\n                continue\n\n            action, nodes_to_consume = self._check_consumer(\n",
                    "rendered": {
                      "text": "        for i in range(start_index, -1, -1):\n            current_consumer = self._to_consume[i]\n\n            # Certain nodes shouldn't be checked as they get checked another time\n            if self._should_node_be_skipped(node, current_consumer, i == start_index):\n                continue\n\n            action, nodes_to_consume = self._check_consumer(\n",
                      "markdown": "`        for i in range(start_index, -1, -1):\n            current_consumer = self._to_consume[i]\n\n            # Certain nodes shouldn't be checked as they get checked another time\n            if self._should_node_be_skipped(node, current_consumer, i == start_index):\n                continue\n\n            action, nodes_to_consume = self._check_consumer(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1678,
                  "startColumn": 18,
                  "endLine": 1678,
                  "endColumn": 24,
                  "snippet": {
                    "text": "        \"\"\"\n        stmt = node.statement()\n        if stmt.fromlineno is None:\n            # name node from an astroid built from live code, skip\n            assert not stmt.root().file.endswith(\".py\")\n            return\n\n",
                    "rendered": {
                      "text": "        \"\"\"\n        stmt = node.statement()\n        if stmt.fromlineno is None:\n            # name node from an astroid built from live code, skip\n            assert not stmt.root().file.endswith(\".py\")\n            return\n\n",
                      "markdown": "`        \"\"\"\n        stmt = node.statement()\n        if stmt.fromlineno is None:\n            # name node from an astroid built from live code, skip\n            assert not stmt.root().file.endswith(\".py\")\n            return\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1090,
                  "startColumn": 38,
                  "endLine": 1090,
                  "endColumn": 44,
                  "snippet": {
                    "text": "    def _recursive_search_for_continue_before_break(\n        stmt: _base_nodes.Statement, break_stmt: nodes.Break\n    ) -> bool:\n        \"\"\"Return True if any Continue node can be found in descendants of `stmt`\n        before encountering `break_stmt`, ignoring any nested loops.\n        \"\"\"\n        if stmt is break_stmt:\n",
                    "rendered": {
                      "text": "    def _recursive_search_for_continue_before_break(\n        stmt: _base_nodes.Statement, break_stmt: nodes.Break\n    ) -> bool:\n        \"\"\"Return True if any Continue node can be found in descendants of `stmt`\n        before encountering `break_stmt`, ignoring any nested loops.\n        \"\"\"\n        if stmt is break_stmt:\n",
                      "markdown": "`    def _recursive_search_for_continue_before_break(\n        stmt: _base_nodes.Statement, break_stmt: nodes.Break\n    ) -> bool:\n        \"\"\"Return True if any Continue node can be found in descendants of `stmt`\n        before encountering `break_stmt`, ignoring any nested loops.\n        \"\"\"\n        if stmt is break_stmt:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 1044,
                  "startColumn": 29,
                  "endLine": 1044,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        if closest_loop is None:\n            return False\n        if not any(\n            else_statement is node or else_statement.parent_of(node)\n            for else_statement in closest_loop.orelse\n        ):\n            # `node` not guarded by `else`\n",
                    "rendered": {
                      "text": "        if closest_loop is None:\n            return False\n        if not any(\n            else_statement is node or else_statement.parent_of(node)\n            for else_statement in closest_loop.orelse\n        ):\n            # `node` not guarded by `else`\n",
                      "markdown": "`        if closest_loop is None:\n            return False\n        if not any(\n            else_statement is node or else_statement.parent_of(node)\n            for else_statement in closest_loop.orelse\n        ):\n            # `node` not guarded by `else`\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 905,
                  "startColumn": 36,
                  "endLine": 905,
                  "endColumn": 42,
                  "snippet": {
                    "text": "                continue\n\n            if try_block_returns or else_block_returns or else_block_exits:\n                # Exception: if this node is in the final block of the other_node_statement,\n                # it will execute before returning. Assume the except statements are uncertain.\n                if (\n                    isinstance(node_statement.parent, nodes.Try)\n",
                    "rendered": {
                      "text": "                continue\n\n            if try_block_returns or else_block_returns or else_block_exits:\n                # Exception: if this node is in the final block of the other_node_statement,\n                # it will execute before returning. Assume the except statements are uncertain.\n                if (\n                    isinstance(node_statement.parent, nodes.Try)\n",
                      "markdown": "`                continue\n\n            if try_block_returns or else_block_returns or else_block_exits:\n                # Exception: if this node is in the final block of the other_node_statement,\n                # it will execute before returning. Assume the except statements are uncertain.\n                if (\n                    isinstance(node_statement.parent, nodes.Try)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 874,
                  "startColumn": 26,
                  "endLine": 874,
                  "endColumn": 32,
                  "snippet": {
                    "text": "            )\n            if not closest_except_handler:\n                continue\n            # If the other node is in the same scope as this node, assume it executes\n            if closest_except_handler.parent_of(node):\n                continue\n            closest_try_except: nodes.Try = closest_except_handler.parent\n",
                    "rendered": {
                      "text": "            )\n            if not closest_except_handler:\n                continue\n            # If the other node is in the same scope as this node, assume it executes\n            if closest_except_handler.parent_of(node):\n                continue\n            closest_try_except: nodes.Try = closest_except_handler.parent\n",
                      "markdown": "`            )\n            if not closest_except_handler:\n                continue\n            # If the other node is in the same scope as this node, assume it executes\n            if closest_except_handler.parent_of(node):\n                continue\n            closest_try_except: nodes.Try = closest_except_handler.parent\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 783,
                  "startColumn": 24,
                  "endLine": 783,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        \"\"\"Identify nodes of uncertain execution because they are defined under if\n        tests.\n\n        Don't identify a node if there is a path that is inferred to\n        define the name, raise, or return (e.g. any executed if/elif/else branch).\n        \"\"\"\n        uncertain_nodes = []\n",
                    "rendered": {
                      "text": "        \"\"\"Identify nodes of uncertain execution because they are defined under if\n        tests.\n\n        Don't identify a node if there is a path that is inferred to\n        define the name, raise, or return (e.g. any executed if/elif/else branch).\n        \"\"\"\n        uncertain_nodes = []\n",
                      "markdown": "`        \"\"\"Identify nodes of uncertain execution because they are defined under if\n        tests.\n\n        Don't identify a node if there is a path that is inferred to\n        define the name, raise, or return (e.g. any executed if/elif/else branch).\n        \"\"\"\n        uncertain_nodes = []\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 730,
                  "startColumn": 40,
                  "endLine": 730,
                  "endColumn": 46,
                  "snippet": {
                    "text": "        if any(node.nodes_of_class(nodes.Break, nodes.Continue)):\n            return True\n\n        # Is there an assignment in this node itself, e.g. in named expression?\n        if NamesConsumer._defines_name_raises_or_returns(name, node):\n            return True\n\n",
                    "rendered": {
                      "text": "        if any(node.nodes_of_class(nodes.Break, nodes.Continue)):\n            return True\n\n        # Is there an assignment in this node itself, e.g. in named expression?\n        if NamesConsumer._defines_name_raises_or_returns(name, node):\n            return True\n\n",
                      "markdown": "`        if any(node.nodes_of_class(nodes.Break, nodes.Continue)):\n            return True\n\n        # Is there an assignment in this node itself, e.g. in named expression?\n        if NamesConsumer._defines_name_raises_or_returns(name, node):\n            return True\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 714,
                  "startColumn": 21,
                  "endLine": 715,
                  "snippet": {
                    "text": "                )\n            handlers = try_except_node.handlers if try_except_node else []\n            return NamesConsumer._defines_name_raises_or_returns_recursive(\n                name, node\n            ) or all(\n                NamesConsumer._defines_name_raises_or_returns_recursive(name, handler)\n                for handler in handlers\n            )\n",
                    "rendered": {
                      "text": "                )\n            handlers = try_except_node.handlers if try_except_node else []\n            return NamesConsumer._defines_name_raises_or_returns_recursive(\n                name, node\n            ) or all(\n                NamesConsumer._defines_name_raises_or_returns_recursive(name, handler)\n                for handler in handlers\n            )\n",
                      "markdown": "`                )\n            handlers = try_except_node.handlers if try_except_node else []\n            return NamesConsumer._defines_name_raises_or_returns_recursive(\n                name, node\n            ) or all(\n                NamesConsumer._defines_name_raises_or_returns_recursive(name, handler)\n                for handler in handlers\n            )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 706,
                  "startColumn": 29,
                  "endLine": 707,
                  "snippet": {
                    "text": "        # Handle try and with\n        if isinstance(node, nodes.Try):\n            # Allow either a path through try/else/finally OR a path through ALL except handlers\n            try_except_node = node\n            if node.finalbody:\n                try_except_node = next(\n                    (child for child in node.nodes_of_class(nodes.Try)),\n                    None,\n",
                    "rendered": {
                      "text": "        # Handle try and with\n        if isinstance(node, nodes.Try):\n            # Allow either a path through try/else/finally OR a path through ALL except handlers\n            try_except_node = node\n            if node.finalbody:\n                try_except_node = next(\n                    (child for child in node.nodes_of_class(nodes.Try)),\n                    None,\n",
                      "markdown": "`        # Handle try and with\n        if isinstance(node, nodes.Try):\n            # Allow either a path through try/else/finally OR a path through ALL except handlers\n            try_except_node = node\n            if node.finalbody:\n                try_except_node = next(\n                    (child for child in node.nodes_of_class(nodes.Try)),\n                    None,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 683,
                  "startColumn": 17,
                  "endLine": 683,
                  "endColumn": 23,
                  "snippet": {
                    "text": "            uncertain_nodes_set = set(uncertain_nodes)\n            found_nodes = [n for n in found_nodes if n not in uncertain_nodes_set]\n\n        # If this node is in an ExceptHandler,\n        # filter out assignments in the try portion, assuming they may fail\n        if found_nodes:\n            uncertain_nodes = (\n",
                    "rendered": {
                      "text": "            uncertain_nodes_set = set(uncertain_nodes)\n            found_nodes = [n for n in found_nodes if n not in uncertain_nodes_set]\n\n        # If this node is in an ExceptHandler,\n        # filter out assignments in the try portion, assuming they may fail\n        if found_nodes:\n            uncertain_nodes = (\n",
                      "markdown": "`            uncertain_nodes_set = set(uncertain_nodes)\n            found_nodes = [n for n in found_nodes if n not in uncertain_nodes_set]\n\n        # If this node is in an ExceptHandler,\n        # filter out assignments in the try portion, assuming they may fail\n        if found_nodes:\n            uncertain_nodes = (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 671,
                  "startColumn": 17,
                  "endLine": 671,
                  "endColumn": 23,
                  "snippet": {
                    "text": "            uncertain_nodes_set = set(uncertain_nodes)\n            found_nodes = [n for n in found_nodes if n not in uncertain_nodes_set]\n\n        # If this node is in a Finally block of a Try/Finally,\n        # filter out assignments in the try portion, assuming they may fail\n        if found_nodes:\n            uncertain_nodes = (\n",
                    "rendered": {
                      "text": "            uncertain_nodes_set = set(uncertain_nodes)\n            found_nodes = [n for n in found_nodes if n not in uncertain_nodes_set]\n\n        # If this node is in a Finally block of a Try/Finally,\n        # filter out assignments in the try portion, assuming they may fail\n        if found_nodes:\n            uncertain_nodes = (\n",
                      "markdown": "`            uncertain_nodes_set = set(uncertain_nodes)\n            found_nodes = [n for n in found_nodes if n not in uncertain_nodes_set]\n\n        # If this node is in a Finally block of a Try/Finally,\n        # filter out assignments in the try portion, assuming they may fail\n        if found_nodes:\n            uncertain_nodes = (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 661,
                  "startColumn": 61,
                  "endLine": 661,
                  "endColumn": 67,
                  "snippet": {
                    "text": "            uncertain_nodes_set = set(uncertain_nodes)\n            found_nodes = [n for n in found_nodes if n not in uncertain_nodes_set]\n\n        # Filter out assignments in an Except clause that the node is not\n        # contained in, assuming they may fail\n        if found_nodes:\n            uncertain_nodes = self._uncertain_nodes_in_except_blocks(\n",
                    "rendered": {
                      "text": "            uncertain_nodes_set = set(uncertain_nodes)\n            found_nodes = [n for n in found_nodes if n not in uncertain_nodes_set]\n\n        # Filter out assignments in an Except clause that the node is not\n        # contained in, assuming they may fail\n        if found_nodes:\n            uncertain_nodes = self._uncertain_nodes_in_except_blocks(\n",
                      "markdown": "`            uncertain_nodes_set = set(uncertain_nodes)\n            found_nodes = [n for n in found_nodes if n not in uncertain_nodes_set]\n\n        # Filter out assignments in an Except clause that the node is not\n        # contained in, assuming they may fail\n        if found_nodes:\n            uncertain_nodes = self._uncertain_nodes_in_except_blocks(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 645,
                  "startColumn": 55,
                  "endLine": 645,
                  "endColumn": 61,
                  "snippet": {
                    "text": "        if VariablesChecker._comprehension_between_frame_and_node(node):\n            return found_nodes\n\n        # Filter out assignments in ExceptHandlers that node is not contained in\n        if found_nodes:\n            found_nodes = [\n                n\n",
                    "rendered": {
                      "text": "        if VariablesChecker._comprehension_between_frame_and_node(node):\n            return found_nodes\n\n        # Filter out assignments in ExceptHandlers that node is not contained in\n        if found_nodes:\n            found_nodes = [\n                n\n",
                      "markdown": "`        if VariablesChecker._comprehension_between_frame_and_node(node):\n            return found_nodes\n\n        # Filter out assignments in ExceptHandlers that node is not contained in\n        if found_nodes:\n            found_nodes = [\n                n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 629,
                  "startColumn": 35,
                  "endLine": 630,
                  "snippet": {
                    "text": "        if (\n            found_nodes\n            and isinstance(parent_node, nodes.For)\n            and parent_node.iter == node\n            and parent_node.target in found_nodes\n        ):\n            found_nodes = None\n\n",
                    "rendered": {
                      "text": "        if (\n            found_nodes\n            and isinstance(parent_node, nodes.For)\n            and parent_node.iter == node\n            and parent_node.target in found_nodes\n        ):\n            found_nodes = None\n\n",
                      "markdown": "`        if (\n            found_nodes\n            and isinstance(parent_node, nodes.For)\n            and parent_node.iter == node\n            and parent_node.target in found_nodes\n        ):\n            found_nodes = None\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 607,
                  "startColumn": 36,
                  "endLine": 607,
                  "endColumn": 42,
                  "snippet": {
                    "text": "    def get_next_to_consume(self, node: nodes.Name) -> list[nodes.NodeNG] | None:\n        \"\"\"Return a list of the nodes that define `node` from this scope.\n\n        If it is uncertain whether a node will be consumed, such as for statements in\n        except blocks, add it to self.consumed_uncertain instead of returning it.\n        Return None to indicate a special case that needs to be handled by the caller.\n        \"\"\"\n",
                    "rendered": {
                      "text": "    def get_next_to_consume(self, node: nodes.Name) -> list[nodes.NodeNG] | None:\n        \"\"\"Return a list of the nodes that define `node` from this scope.\n\n        If it is uncertain whether a node will be consumed, such as for statements in\n        except blocks, add it to self.consumed_uncertain instead of returning it.\n        Return None to indicate a special case that needs to be handled by the caller.\n        \"\"\"\n",
                      "markdown": "`    def get_next_to_consume(self, node: nodes.Name) -> list[nodes.NodeNG] | None:\n        \"\"\"Return a list of the nodes that define `node` from this scope.\n\n        If it is uncertain whether a node will be consumed, such as for statements in\n        except blocks, add it to self.consumed_uncertain instead of returning it.\n        Return None to indicate a special case that needs to be handled by the caller.\n        \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 543,
                  "startColumn": 19,
                  "endLine": 544,
                  "snippet": {
                    "text": "        self._atomic = ScopeConsumer(\n            copy.copy(node.locals), {}, collections.defaultdict(list), scope_type\n        )\n        self.node = node\n        self.names_under_always_false_test: set[str] = set()\n        self.names_defined_under_one_branch_only: set[str] = set()\n\n    def __repr__(self) -> str:\n",
                    "rendered": {
                      "text": "        self._atomic = ScopeConsumer(\n            copy.copy(node.locals), {}, collections.defaultdict(list), scope_type\n        )\n        self.node = node\n        self.names_under_always_false_test: set[str] = set()\n        self.names_defined_under_one_branch_only: set[str] = set()\n\n    def __repr__(self) -> str:\n",
                      "markdown": "`        self._atomic = ScopeConsumer(\n            copy.copy(node.locals), {}, collections.defaultdict(list), scope_type\n        )\n        self.node = node\n        self.names_under_always_false_test: set[str] = set()\n        self.names_defined_under_one_branch_only: set[str] = set()\n\n    def __repr__(self) -> str:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 537,
                  "startColumn": 75,
                  "endLine": 537,
                  "endColumn": 81,
                  "snippet": {
                    "text": "\n\nclass NamesConsumer:\n    \"\"\"A simple class to handle consumed, to consume and scope type info of node locals.\"\"\"\n\n    def __init__(self, node: nodes.NodeNG, scope_type: str) -> None:\n        self._atomic = ScopeConsumer(\n",
                    "rendered": {
                      "text": "\n\nclass NamesConsumer:\n    \"\"\"A simple class to handle consumed, to consume and scope type info of node locals.\"\"\"\n\n    def __init__(self, node: nodes.NodeNG, scope_type: str) -> None:\n        self._atomic = ScopeConsumer(\n",
                      "markdown": "`\n\nclass NamesConsumer:\n    \"\"\"A simple class to handle consumed, to consume and scope type info of node locals.\"\"\"\n\n    def __init__(self, node: nodes.NodeNG, scope_type: str) -> None:\n        self._atomic = ScopeConsumer(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 244,
                  "startColumn": 71,
                  "endLine": 245,
                  "snippet": {
                    "text": "        # If the stored scopes are, in fact, the very same, then it means\n        # that the two frames (frame and defframe) share the same scope,\n        # and we could apply our lineno analysis over them.\n        # For instance, this works when they are inside a function, the node\n        # that uses a definition and the definition itself.\n        return False\n    # At this point, we are certain that frame and defframe share a scope\n    # and the definition of the first depends on the second.\n",
                    "rendered": {
                      "text": "        # If the stored scopes are, in fact, the very same, then it means\n        # that the two frames (frame and defframe) share the same scope,\n        # and we could apply our lineno analysis over them.\n        # For instance, this works when they are inside a function, the node\n        # that uses a definition and the definition itself.\n        return False\n    # At this point, we are certain that frame and defframe share a scope\n    # and the definition of the first depends on the second.\n",
                      "markdown": "`        # If the stored scopes are, in fact, the very same, then it means\n        # that the two frames (frame and defframe) share the same scope,\n        # and we could apply our lineno analysis over them.\n        # For instance, this works when they are inside a function, the node\n        # that uses a definition and the definition itself.\n        return False\n    # At this point, we are certain that frame and defframe share a scope\n    # and the definition of the first depends on the second.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/variables.py"
                },
                "region": {
                  "startLine": 215,
                  "startColumn": 38,
                  "endLine": 215,
                  "endColumn": 44,
                  "snippet": {
                    "text": "        # and the def_scope is something else, then they aren't shared.\n        return False\n    if isinstance(frame, nodes.FunctionDef):\n        # If the parent of the current node is a\n        # function, then it can be under its scope (defined in); or\n        # the `->` part of annotations. The same goes\n        # for annotations of function arguments, they'll have\n",
                    "rendered": {
                      "text": "        # and the def_scope is something else, then they aren't shared.\n        return False\n    if isinstance(frame, nodes.FunctionDef):\n        # If the parent of the current node is a\n        # function, then it can be under its scope (defined in); or\n        # the `->` part of annotations. The same goes\n        # for annotations of function arguments, they'll have\n",
                      "markdown": "`        # and the def_scope is something else, then they aren't shared.\n        return False\n    if isinstance(frame, nodes.FunctionDef):\n        # If the parent of the current node is a\n        # function, then it can be under its scope (defined in); or\n        # the `->` part of annotations. The same goes\n        # for annotations of function arguments, they'll have\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 2337,
                  "startColumn": 26,
                  "endLine": 2337,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    ):\n        return False\n\n    members = frame.locals.get(\"__members__\")\n    # A dataclass is one known case for when `members` can be `None`\n    if members is None:\n        return False\n",
                    "rendered": {
                      "text": "    ):\n        return False\n\n    members = frame.locals.get(\"__members__\")\n    # A dataclass is one known case for when `members` can be `None`\n    if members is None:\n        return False\n",
                      "markdown": "`    ):\n        return False\n\n    members = frame.locals.get(\"__members__\")\n    # A dataclass is one known case for when `members` can be `None`\n    if members is None:\n        return False\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1732,
                  "startColumn": 27,
                  "endLine": 1732,
                  "endColumn": 32,
                  "snippet": {
                    "text": "    \"\"\"Test if attribute is typed annotation in current node\n    or any base nodes.\n    \"\"\"\n    attribute = node.locals.get(attr_name, [None])[0]\n    if (\n        attribute\n        and isinstance(attribute, nodes.AssignName)\n",
                    "rendered": {
                      "text": "    \"\"\"Test if attribute is typed annotation in current node\n    or any base nodes.\n    \"\"\"\n    attribute = node.locals.get(attr_name, [None])[0]\n    if (\n        attribute\n        and isinstance(attribute, nodes.AssignName)\n",
                      "markdown": "`    \"\"\"Test if attribute is typed annotation in current node\n    or any base nodes.\n    \"\"\"\n    attribute = node.locals.get(attr_name, [None])[0]\n    if (\n        attribute\n        and isinstance(attribute, nodes.AssignName)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 726,
                  "startColumn": 38,
                  "endLine": 726,
                  "endColumn": 42,
                  "snippet": {
                    "text": "    the provided keyword.\n    \"\"\"\n    if position is None and keyword is None:\n        raise ValueError(\"Must specify at least one of: position or keyword.\")\n    if position is not None:\n        try:\n            return call_node.args[position]\n",
                    "rendered": {
                      "text": "    the provided keyword.\n    \"\"\"\n    if position is None and keyword is None:\n        raise ValueError(\"Must specify at least one of: position or keyword.\")\n    if position is not None:\n        try:\n            return call_node.args[position]\n",
                      "markdown": "`    the provided keyword.\n    \"\"\"\n    if position is None and keyword is None:\n        raise ValueError(\"Must specify at least one of: position or keyword.\")\n    if position is not None:\n        try:\n            return call_node.args[position]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 722,
                  "startColumn": 47,
                  "endLine": 722,
                  "endColumn": 51,
                  "snippet": {
                    "text": "    :returns: The node representing the argument, None if the argument is not found.\n    :rtype: nodes.Name\n    :raises ValueError: if both position and keyword are None.\n    :raises NoSuchArgumentError: if no argument at the provided position or with\n    the provided keyword.\n    \"\"\"\n    if position is None and keyword is None:\n",
                    "rendered": {
                      "text": "    :returns: The node representing the argument, None if the argument is not found.\n    :rtype: nodes.Name\n    :raises ValueError: if both position and keyword are None.\n    :raises NoSuchArgumentError: if no argument at the provided position or with\n    the provided keyword.\n    \"\"\"\n    if position is None and keyword is None:\n",
                      "markdown": "`    :returns: The node representing the argument, None if the argument is not found.\n    :rtype: nodes.Name\n    :raises ValueError: if both position and keyword are None.\n    :raises NoSuchArgumentError: if no argument at the provided position or with\n    the provided keyword.\n    \"\"\"\n    if position is None and keyword is None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 704,
                  "startColumn": 3,
                  "endLine": 704,
                  "endColumn": 7,
                  "snippet": {
                    "text": "\ndef is_attr_private(attrname: str) -> Match[str] | None:\n    \"\"\"Check that attribute name is private (at least two leading underscores,\n    at most one trailing underscore).\n    \"\"\"\n    regex = re.compile(\"^_{2,10}.*[^_]+_?$\")\n    return regex.match(attrname)\n",
                    "rendered": {
                      "text": "\ndef is_attr_private(attrname: str) -> Match[str] | None:\n    \"\"\"Check that attribute name is private (at least two leading underscores,\n    at most one trailing underscore).\n    \"\"\"\n    regex = re.compile(\"^_{2,10}.*[^_]+_?$\")\n    return regex.match(attrname)\n",
                      "markdown": "`\ndef is_attr_private(attrname: str) -> Match[str] | None:\n    \"\"\"Check that attribute name is private (at least two leading underscores,\n    at most one trailing underscore).\n    \"\"\"\n    regex = re.compile(\"^_{2,10}.*[^_]+_?$\")\n    return regex.match(attrname)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 483,
                  "startColumn": 59,
                  "endLine": 483,
                  "endColumn": 63,
                  "snippet": {
                    "text": "\n    This information is used by ``ASTWalker`` to decide whether to call the decorated\n    method or not. If none of the messages is enabled, the method will be skipped.\n    Therefore, the list of messages must be well maintained at all times!\n    This decorator only has an effect on ``visit_*`` and ``leave_*`` methods\n    of a class inheriting from ``BaseChecker``.\n    \"\"\"\n",
                    "rendered": {
                      "text": "\n    This information is used by ``ASTWalker`` to decide whether to call the decorated\n    method or not. If none of the messages is enabled, the method will be skipped.\n    Therefore, the list of messages must be well maintained at all times!\n    This decorator only has an effect on ``visit_*`` and ``leave_*`` methods\n    of a class inheriting from ``BaseChecker``.\n    \"\"\"\n",
                      "markdown": "`\n    This information is used by ``ASTWalker`` to decide whether to call the decorated\n    method or not. If none of the messages is enabled, the method will be skipped.\n    Therefore, the list of messages must be well maintained at all times!\n    This decorator only has an effect on ``visit_*`` and ``leave_*`` methods\n    of a class inheriting from ``BaseChecker``.\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 2195,
                  "startColumn": 47,
                  "endLine": 2195,
                  "endColumn": 53,
                  "snippet": {
                    "text": "                and inferred.qname() in TERMINATING_FUNCS_QNAMES\n            ):\n                return True\n            # Unwrap to get the actual function node object\n            if isinstance(inferred, astroid.BoundMethod) and isinstance(\n                inferred._proxied, astroid.UnboundMethod\n            ):\n",
                    "rendered": {
                      "text": "                and inferred.qname() in TERMINATING_FUNCS_QNAMES\n            ):\n                return True\n            # Unwrap to get the actual function node object\n            if isinstance(inferred, astroid.BoundMethod) and isinstance(\n                inferred._proxied, astroid.UnboundMethod\n            ):\n",
                      "markdown": "`                and inferred.qname() in TERMINATING_FUNCS_QNAMES\n            ):\n                return True\n            # Unwrap to get the actual function node object\n            if isinstance(inferred, astroid.BoundMethod) and isinstance(\n                inferred._proxied, astroid.UnboundMethod\n            ):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 2105,
                  "startColumn": 23,
                  "endLine": 2105,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n\ndef is_augmented_assign(node: nodes.Assign) -> tuple[bool, str]:\n    \"\"\"Determine if the node is assigning itself (with modifications) to itself.\n\n    For example: x = 1 + x\n    \"\"\"\n",
                    "rendered": {
                      "text": "\n\ndef is_augmented_assign(node: nodes.Assign) -> tuple[bool, str]:\n    \"\"\"Determine if the node is assigning itself (with modifications) to itself.\n\n    For example: x = 1 + x\n    \"\"\"\n",
                      "markdown": "`\n\ndef is_augmented_assign(node: nodes.Assign) -> tuple[bool, str]:\n    \"\"\"Determine if the node is assigning itself (with modifications) to itself.\n\n    For example: x = 1 + x\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 2091,
                  "startColumn": 45,
                  "endLine": 2091,
                  "endColumn": 51,
                  "snippet": {
                    "text": "def _is_target_name_in_binop_side(\n    target: nodes.AssignName | nodes.AssignAttr, side: nodes.NodeNG | None\n) -> bool:\n    \"\"\"Determine whether the target name-like node is referenced in the side node.\"\"\"\n    if isinstance(side, nodes.Name):\n        if isinstance(target, nodes.AssignName):\n            return target.name == side.name  # type: ignore[no-any-return]\n",
                    "rendered": {
                      "text": "def _is_target_name_in_binop_side(\n    target: nodes.AssignName | nodes.AssignAttr, side: nodes.NodeNG | None\n) -> bool:\n    \"\"\"Determine whether the target name-like node is referenced in the side node.\"\"\"\n    if isinstance(side, nodes.Name):\n        if isinstance(target, nodes.AssignName):\n            return target.name == side.name  # type: ignore[no-any-return]\n",
                      "markdown": "`def _is_target_name_in_binop_side(\n    target: nodes.AssignName | nodes.AssignAttr, side: nodes.NodeNG | None\n) -> bool:\n    \"\"\"Determine whether the target name-like node is referenced in the side node.\"\"\"\n    if isinstance(side, nodes.Name):\n        if isinstance(target, nodes.AssignName):\n            return target.name == side.name  # type: ignore[no-any-return]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 2038,
                  "startColumn": 34,
                  "endLine": 2038,
                  "endColumn": 40,
                  "snippet": {
                    "text": "def has_starred_node_recursive(\n    node: nodes.For | nodes.Comprehension | nodes.Set,\n) -> Iterator[bool]:\n    \"\"\"Yield ``True`` if a Starred node is found recursively.\"\"\"\n    if isinstance(node, nodes.Starred):\n        yield True\n    elif isinstance(node, nodes.Set):\n",
                    "rendered": {
                      "text": "def has_starred_node_recursive(\n    node: nodes.For | nodes.Comprehension | nodes.Set,\n) -> Iterator[bool]:\n    \"\"\"Yield ``True`` if a Starred node is found recursively.\"\"\"\n    if isinstance(node, nodes.Starred):\n        yield True\n    elif isinstance(node, nodes.Set):\n",
                      "markdown": "`def has_starred_node_recursive(\n    node: nodes.For | nodes.Comprehension | nodes.Set,\n) -> Iterator[bool]:\n    \"\"\"Yield ``True`` if a Starred node is found recursively.\"\"\"\n    if isinstance(node, nodes.Starred):\n        yield True\n    elif isinstance(node, nodes.Set):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1958,
                  "startColumn": 17,
                  "endLine": 1958,
                  "endColumn": 23,
                  "snippet": {
                    "text": "\n\ndef in_type_checking_block(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if a node is guarded by a TYPE_CHECKING guard.\"\"\"\n    for ancestor in node.node_ancestors():\n        if not isinstance(ancestor, nodes.If):\n            continue\n",
                    "rendered": {
                      "text": "\n\ndef in_type_checking_block(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if a node is guarded by a TYPE_CHECKING guard.\"\"\"\n    for ancestor in node.node_ancestors():\n        if not isinstance(ancestor, nodes.If):\n            continue\n",
                      "markdown": "`\n\ndef in_type_checking_block(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if a node is guarded by a TYPE_CHECKING guard.\"\"\"\n    for ancestor in node.node_ancestors():\n        if not isinstance(ancestor, nodes.If):\n            continue\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1949,
                  "startColumn": 11,
                  "endLine": 1950,
                  "snippet": {
                    "text": "    Useful for extracting whether a statement is guarded by a try, except, or finally\n    when searching for a Try ancestor.\n    \"\"\"\n    child = node\n    for ancestor in node.node_ancestors():\n        if isinstance(ancestor, ancestor_type):\n            return (ancestor, child)\n        child = ancestor\n",
                    "rendered": {
                      "text": "    Useful for extracting whether a statement is guarded by a try, except, or finally\n    when searching for a Try ancestor.\n    \"\"\"\n    child = node\n    for ancestor in node.node_ancestors():\n        if isinstance(ancestor, ancestor_type):\n            return (ancestor, child)\n        child = ancestor\n",
                      "markdown": "`    Useful for extracting whether a statement is guarded by a try, except, or finally\n    when searching for a Try ancestor.\n    \"\"\"\n    child = node\n    for ancestor in node.node_ancestors():\n        if isinstance(ancestor, ancestor_type):\n            return (ancestor, child)\n        child = ancestor\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1933,
                  "startColumn": 30,
                  "endLine": 1933,
                  "endColumn": 36,
                  "snippet": {
                    "text": "def get_node_first_ancestor_of_type(\n    node: nodes.NodeNG, ancestor_type: type[_NodeT] | tuple[type[_NodeT], ...]\n) -> _NodeT | None:\n    \"\"\"Return the first parent node that is any of the provided types (or None).\"\"\"\n    for ancestor in node.node_ancestors():\n        if isinstance(ancestor, ancestor_type):\n            return ancestor  # type: ignore[no-any-return]\n",
                    "rendered": {
                      "text": "def get_node_first_ancestor_of_type(\n    node: nodes.NodeNG, ancestor_type: type[_NodeT] | tuple[type[_NodeT], ...]\n) -> _NodeT | None:\n    \"\"\"Return the first parent node that is any of the provided types (or None).\"\"\"\n    for ancestor in node.node_ancestors():\n        if isinstance(ancestor, ancestor_type):\n            return ancestor  # type: ignore[no-any-return]\n",
                      "markdown": "`def get_node_first_ancestor_of_type(\n    node: nodes.NodeNG, ancestor_type: type[_NodeT] | tuple[type[_NodeT], ...]\n) -> _NodeT | None:\n    \"\"\"Return the first parent node that is any of the provided types (or None).\"\"\"\n    for ancestor in node.node_ancestors():\n        if isinstance(ancestor, ancestor_type):\n            return ancestor  # type: ignore[no-any-return]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1922,
                  "startColumn": 24,
                  "endLine": 1922,
                  "endColumn": 30,
                  "snippet": {
                    "text": "\n\ndef assigned_bool(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns true if a node is a nodes.Assign that returns a constant boolean.\"\"\"\n    return (\n        isinstance(node, nodes.Assign)\n        and isinstance(node.value, nodes.Const)\n",
                    "rendered": {
                      "text": "\n\ndef assigned_bool(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns true if a node is a nodes.Assign that returns a constant boolean.\"\"\"\n    return (\n        isinstance(node, nodes.Assign)\n        and isinstance(node.value, nodes.Const)\n",
                      "markdown": "`\n\ndef assigned_bool(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns true if a node is a nodes.Assign that returns a constant boolean.\"\"\"\n    return (\n        isinstance(node, nodes.Assign)\n        and isinstance(node.value, nodes.Const)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1913,
                  "startColumn": 24,
                  "endLine": 1913,
                  "endColumn": 30,
                  "snippet": {
                    "text": "\n\ndef returns_bool(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns true if a node is a nodes.Return that returns a constant boolean.\"\"\"\n    return (\n        isinstance(node, nodes.Return)\n        and isinstance(node.value, nodes.Const)\n",
                    "rendered": {
                      "text": "\n\ndef returns_bool(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns true if a node is a nodes.Return that returns a constant boolean.\"\"\"\n    return (\n        isinstance(node, nodes.Return)\n        and isinstance(node.value, nodes.Const)\n",
                      "markdown": "`\n\ndef returns_bool(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns true if a node is a nodes.Return that returns a constant boolean.\"\"\"\n    return (\n        isinstance(node, nodes.Return)\n        and isinstance(node.value, nodes.Const)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1825,
                  "startColumn": 22,
                  "endLine": 1825,
                  "endColumn": 28,
                  "snippet": {
                    "text": "    for debugging. Otherwise, the initial module name\n    is returned unchanged.\n\n    :param importnode: node representing import statement.\n    :param modname: module name from import statement.\n    :returns: absolute qualified module name of the module\n        used in import.\n",
                    "rendered": {
                      "text": "    for debugging. Otherwise, the initial module name\n    is returned unchanged.\n\n    :param importnode: node representing import statement.\n    :param modname: module name from import statement.\n    :returns: absolute qualified module name of the module\n        used in import.\n",
                      "markdown": "`    for debugging. Otherwise, the initial module name\n    is returned unchanged.\n\n    :param importnode: node representing import statement.\n    :param modname: module name from import statement.\n    :returns: absolute qualified module name of the module\n        used in import.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1808,
                  "startColumn": 47,
                  "endLine": 1808,
                  "endColumn": 53,
                  "snippet": {
                    "text": "\n    :param node: Subscript Node to extract value from\n    :returns: Const Node containing subscript value\n    :raises InferredTypeError: if the subscript node cannot be inferred as a Const\n    \"\"\"\n    inferred = safe_infer(node.slice)\n    if not isinstance(inferred, nodes.Const):\n",
                    "rendered": {
                      "text": "\n    :param node: Subscript Node to extract value from\n    :returns: Const Node containing subscript value\n    :raises InferredTypeError: if the subscript node cannot be inferred as a Const\n    \"\"\"\n    inferred = safe_infer(node.slice)\n    if not isinstance(inferred, nodes.Const):\n",
                      "markdown": "`\n    :param node: Subscript Node to extract value from\n    :returns: Const Node containing subscript value\n    :raises InferredTypeError: if the subscript node cannot be inferred as a Const\n    \"\"\"\n    inferred = safe_infer(node.slice)\n    if not isinstance(inferred, nodes.Const):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1807,
                  "startColumn": 19,
                  "endLine": 1807,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    \"\"\"Returns the value 'subscript.slice' of a Subscript node.\n\n    :param node: Subscript Node to extract value from\n    :returns: Const Node containing subscript value\n    :raises InferredTypeError: if the subscript node cannot be inferred as a Const\n    \"\"\"\n    inferred = safe_infer(node.slice)\n",
                    "rendered": {
                      "text": "    \"\"\"Returns the value 'subscript.slice' of a Subscript node.\n\n    :param node: Subscript Node to extract value from\n    :returns: Const Node containing subscript value\n    :raises InferredTypeError: if the subscript node cannot be inferred as a Const\n    \"\"\"\n    inferred = safe_infer(node.slice)\n",
                      "markdown": "`    \"\"\"Returns the value 'subscript.slice' of a Subscript node.\n\n    :param node: Subscript Node to extract value from\n    :returns: Const Node containing subscript value\n    :raises InferredTypeError: if the subscript node cannot be inferred as a Const\n    \"\"\"\n    inferred = safe_infer(node.slice)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1806,
                  "startColumn": 26,
                  "endLine": 1806,
                  "endColumn": 32,
                  "snippet": {
                    "text": "def get_subscript_const_value(node: nodes.Subscript) -> nodes.Const:\n    \"\"\"Returns the value 'subscript.slice' of a Subscript node.\n\n    :param node: Subscript Node to extract value from\n    :returns: Const Node containing subscript value\n    :raises InferredTypeError: if the subscript node cannot be inferred as a Const\n    \"\"\"\n",
                    "rendered": {
                      "text": "def get_subscript_const_value(node: nodes.Subscript) -> nodes.Const:\n    \"\"\"Returns the value 'subscript.slice' of a Subscript node.\n\n    :param node: Subscript Node to extract value from\n    :returns: Const Node containing subscript value\n    :raises InferredTypeError: if the subscript node cannot be inferred as a Const\n    \"\"\"\n",
                      "markdown": "`def get_subscript_const_value(node: nodes.Subscript) -> nodes.Const:\n    \"\"\"Returns the value 'subscript.slice' of a Subscript node.\n\n    :param node: Subscript Node to extract value from\n    :returns: Const Node containing subscript value\n    :raises InferredTypeError: if the subscript node cannot be inferred as a Const\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1755,
                  "startColumn": 25,
                  "endLine": 1755,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n\ndef is_assign_name_annotated_with(node: nodes.AssignName, typing_name: str) -> bool:\n    \"\"\"Test if AssignName node has `typing_name` annotation.\n\n    Especially useful to check for `typing._SpecialForm` instances\n    like: `Union`, `Optional`, `Literal`, `ClassVar`, `Final`.\n",
                    "rendered": {
                      "text": "\n\ndef is_assign_name_annotated_with(node: nodes.AssignName, typing_name: str) -> bool:\n    \"\"\"Test if AssignName node has `typing_name` annotation.\n\n    Especially useful to check for `typing._SpecialForm` instances\n    like: `Union`, `Optional`, `Literal`, `ClassVar`, `Final`.\n",
                      "markdown": "`\n\ndef is_assign_name_annotated_with(node: nodes.AssignName, typing_name: str) -> bool:\n    \"\"\"Test if AssignName node has `typing_name` annotation.\n\n    Especially useful to check for `typing._SpecialForm` instances\n    like: `Union`, `Optional`, `Literal`, `ClassVar`, `Final`.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1729,
                  "startColumn": 55,
                  "endLine": 1730,
                  "snippet": {
                    "text": "def is_attribute_typed_annotation(\n    node: nodes.ClassDef | astroid.Instance, attr_name: str\n) -> bool:\n    \"\"\"Test if attribute is typed annotation in current node\n    or any base nodes.\n    \"\"\"\n    attribute = node.locals.get(attr_name, [None])[0]\n    if (\n",
                    "rendered": {
                      "text": "def is_attribute_typed_annotation(\n    node: nodes.ClassDef | astroid.Instance, attr_name: str\n) -> bool:\n    \"\"\"Test if attribute is typed annotation in current node\n    or any base nodes.\n    \"\"\"\n    attribute = node.locals.get(attr_name, [None])[0]\n    if (\n",
                      "markdown": "`def is_attribute_typed_annotation(\n    node: nodes.ClassDef | astroid.Instance, attr_name: str\n) -> bool:\n    \"\"\"Test if attribute is typed annotation in current node\n    or any base nodes.\n    \"\"\"\n    attribute = node.locals.get(attr_name, [None])[0]\n    if (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1720,
                  "startColumn": 23,
                  "endLine": 1720,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n\ndef is_classdef_type(node: nodes.ClassDef) -> bool:\n    \"\"\"Test if ClassDef node is Type.\"\"\"\n    if node.name == \"type\":\n        return True\n    return any(isinstance(b, nodes.Name) and b.name == \"type\" for b in node.bases)\n",
                    "rendered": {
                      "text": "\n\ndef is_classdef_type(node: nodes.ClassDef) -> bool:\n    \"\"\"Test if ClassDef node is Type.\"\"\"\n    if node.name == \"type\":\n        return True\n    return any(isinstance(b, nodes.Name) and b.name == \"type\" for b in node.bases)\n",
                      "markdown": "`\n\ndef is_classdef_type(node: nodes.ClassDef) -> bool:\n    \"\"\"Test if ClassDef node is Type.\"\"\"\n    if node.name == \"type\":\n        return True\n    return any(isinstance(b, nodes.Name) and b.name == \"type\" for b in node.bases)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1715,
                  "startColumn": 14,
                  "endLine": 1715,
                  "endColumn": 20,
                  "snippet": {
                    "text": "    if isinstance(parent, (nodes.While, nodes.If, nodes.IfExp, nodes.Assert)):\n        return node is parent.test or parent.test.parent_of(node)\n    if isinstance(parent, nodes.Comprehension):\n        return node in parent.ifs\n    return is_call_of_name(parent, \"bool\") and parent.parent_of(node)\n\n\n",
                    "rendered": {
                      "text": "    if isinstance(parent, (nodes.While, nodes.If, nodes.IfExp, nodes.Assert)):\n        return node is parent.test or parent.test.parent_of(node)\n    if isinstance(parent, nodes.Comprehension):\n        return node in parent.ifs\n    return is_call_of_name(parent, \"bool\") and parent.parent_of(node)\n\n\n",
                      "markdown": "`    if isinstance(parent, (nodes.While, nodes.If, nodes.IfExp, nodes.Assert)):\n        return node is parent.test or parent.test.parent_of(node)\n    if isinstance(parent, nodes.Comprehension):\n        return node in parent.ifs\n    return is_call_of_name(parent, \"bool\") and parent.parent_of(node)\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1713,
                  "startColumn": 14,
                  "endLine": 1713,
                  "endColumn": 20,
                  "snippet": {
                    "text": "    \"\"\"Returns true if the given node is being tested for truthiness.\"\"\"\n    parent = parent or node.parent\n    if isinstance(parent, (nodes.While, nodes.If, nodes.IfExp, nodes.Assert)):\n        return node is parent.test or parent.test.parent_of(node)\n    if isinstance(parent, nodes.Comprehension):\n        return node in parent.ifs\n    return is_call_of_name(parent, \"bool\") and parent.parent_of(node)\n",
                    "rendered": {
                      "text": "    \"\"\"Returns true if the given node is being tested for truthiness.\"\"\"\n    parent = parent or node.parent\n    if isinstance(parent, (nodes.While, nodes.If, nodes.IfExp, nodes.Assert)):\n        return node is parent.test or parent.test.parent_of(node)\n    if isinstance(parent, nodes.Comprehension):\n        return node in parent.ifs\n    return is_call_of_name(parent, \"bool\") and parent.parent_of(node)\n",
                      "markdown": "`    \"\"\"Returns true if the given node is being tested for truthiness.\"\"\"\n    parent = parent or node.parent\n    if isinstance(parent, (nodes.While, nodes.If, nodes.IfExp, nodes.Assert)):\n        return node is parent.test or parent.test.parent_of(node)\n    if isinstance(parent, nodes.Comprehension):\n        return node in parent.ifs\n    return is_call_of_name(parent, \"bool\") and parent.parent_of(node)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1710,
                  "startColumn": 32,
                  "endLine": 1710,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    node: nodes.NodeNG,\n    parent: nodes.NodeNG | None = None,\n) -> bool:\n    \"\"\"Returns true if the given node is being tested for truthiness.\"\"\"\n    parent = parent or node.parent\n    if isinstance(parent, (nodes.While, nodes.If, nodes.IfExp, nodes.Assert)):\n        return node is parent.test or parent.test.parent_of(node)\n",
                    "rendered": {
                      "text": "    node: nodes.NodeNG,\n    parent: nodes.NodeNG | None = None,\n) -> bool:\n    \"\"\"Returns true if the given node is being tested for truthiness.\"\"\"\n    parent = parent or node.parent\n    if isinstance(parent, (nodes.While, nodes.If, nodes.IfExp, nodes.Assert)):\n        return node is parent.test or parent.test.parent_of(node)\n",
                      "markdown": "`    node: nodes.NodeNG,\n    parent: nodes.NodeNG | None = None,\n) -> bool:\n    \"\"\"Returns true if the given node is being tested for truthiness.\"\"\"\n    parent = parent or node.parent\n    if isinstance(parent, (nodes.While, nodes.If, nodes.IfExp, nodes.Assert)):\n        return node is parent.test or parent.test.parent_of(node)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1698,
                  "startColumn": 16,
                  "endLine": 1698,
                  "endColumn": 22,
                  "snippet": {
                    "text": "\n\ndef is_call_of_name(node: nodes.NodeNG, name: str) -> bool:\n    \"\"\"Checks if node is a function call with the given name.\"\"\"\n    return (\n        isinstance(node, nodes.Call)\n        and isinstance(node.func, nodes.Name)\n",
                    "rendered": {
                      "text": "\n\ndef is_call_of_name(node: nodes.NodeNG, name: str) -> bool:\n    \"\"\"Checks if node is a function call with the given name.\"\"\"\n    return (\n        isinstance(node, nodes.Call)\n        and isinstance(node.func, nodes.Name)\n",
                      "markdown": "`\n\ndef is_call_of_name(node: nodes.NodeNG, name: str) -> bool:\n    \"\"\"Checks if node is a function call with the given name.\"\"\"\n    return (\n        isinstance(node, nodes.Call)\n        and isinstance(node.func, nodes.Name)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1678,
                  "startColumn": 25,
                  "endLine": 1678,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    \"\"\"Check if the given node represents a protocol class.\n\n    :param cls: The node to check\n    :returns: True if the node is or inherits from typing.Protocol directly, false otherwise.\n    \"\"\"\n    if not isinstance(cls, nodes.ClassDef):\n        return False\n",
                    "rendered": {
                      "text": "    \"\"\"Check if the given node represents a protocol class.\n\n    :param cls: The node to check\n    :returns: True if the node is or inherits from typing.Protocol directly, false otherwise.\n    \"\"\"\n    if not isinstance(cls, nodes.ClassDef):\n        return False\n",
                      "markdown": "`    \"\"\"Check if the given node represents a protocol class.\n\n    :param cls: The node to check\n    :returns: True if the node is or inherits from typing.Protocol directly, false otherwise.\n    \"\"\"\n    if not isinstance(cls, nodes.ClassDef):\n        return False\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1677,
                  "startColumn": 19,
                  "endLine": 1677,
                  "endColumn": 25,
                  "snippet": {
                    "text": "def is_protocol_class(cls: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node represents a protocol class.\n\n    :param cls: The node to check\n    :returns: True if the node is or inherits from typing.Protocol directly, false otherwise.\n    \"\"\"\n    if not isinstance(cls, nodes.ClassDef):\n",
                    "rendered": {
                      "text": "def is_protocol_class(cls: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node represents a protocol class.\n\n    :param cls: The node to check\n    :returns: True if the node is or inherits from typing.Protocol directly, false otherwise.\n    \"\"\"\n    if not isinstance(cls, nodes.ClassDef):\n",
                      "markdown": "`def is_protocol_class(cls: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node represents a protocol class.\n\n    :param cls: The node to check\n    :returns: True if the node is or inherits from typing.Protocol directly, false otherwise.\n    \"\"\"\n    if not isinstance(cls, nodes.ClassDef):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1675,
                  "startColumn": 25,
                  "endLine": 1675,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n\ndef is_protocol_class(cls: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node represents a protocol class.\n\n    :param cls: The node to check\n    :returns: True if the node is or inherits from typing.Protocol directly, false otherwise.\n",
                    "rendered": {
                      "text": "\n\ndef is_protocol_class(cls: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node represents a protocol class.\n\n    :param cls: The node to check\n    :returns: True if the node is or inherits from typing.Protocol directly, false otherwise.\n",
                      "markdown": "`\n\ndef is_protocol_class(cls: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node represents a protocol class.\n\n    :param cls: The node to check\n    :returns: True if the node is or inherits from typing.Protocol directly, false otherwise.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1668,
                  "startColumn": 21,
                  "endLine": 1668,
                  "endColumn": 27,
                  "snippet": {
                    "text": "    \"\"\"Check if a node is a function stub decorated with typing.overload.\n\n    :param node: Node to check.\n    :returns: True if node is an overload function stub. False otherwise.\n    \"\"\"\n    decorators = getattr(node, \"decorators\", None)\n    return bool(decorators and decorated_with(node, [\"typing.overload\", \"overload\"]))\n",
                    "rendered": {
                      "text": "    \"\"\"Check if a node is a function stub decorated with typing.overload.\n\n    :param node: Node to check.\n    :returns: True if node is an overload function stub. False otherwise.\n    \"\"\"\n    decorators = getattr(node, \"decorators\", None)\n    return bool(decorators and decorated_with(node, [\"typing.overload\", \"overload\"]))\n",
                      "markdown": "`    \"\"\"Check if a node is a function stub decorated with typing.overload.\n\n    :param node: Node to check.\n    :returns: True if node is an overload function stub. False otherwise.\n    \"\"\"\n    decorators = getattr(node, \"decorators\", None)\n    return bool(decorators and decorated_with(node, [\"typing.overload\", \"overload\"]))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1667,
                  "startColumn": 16,
                  "endLine": 1667,
                  "endColumn": 22,
                  "snippet": {
                    "text": "def is_overload_stub(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if a node is a function stub decorated with typing.overload.\n\n    :param node: Node to check.\n    :returns: True if node is an overload function stub. False otherwise.\n    \"\"\"\n    decorators = getattr(node, \"decorators\", None)\n",
                    "rendered": {
                      "text": "def is_overload_stub(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if a node is a function stub decorated with typing.overload.\n\n    :param node: Node to check.\n    :returns: True if node is an overload function stub. False otherwise.\n    \"\"\"\n    decorators = getattr(node, \"decorators\", None)\n",
                      "markdown": "`def is_overload_stub(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if a node is a function stub decorated with typing.overload.\n\n    :param node: Node to check.\n    :returns: True if node is an overload function stub. False otherwise.\n    \"\"\"\n    decorators = getattr(node, \"decorators\", None)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1665,
                  "startColumn": 17,
                  "endLine": 1665,
                  "endColumn": 23,
                  "snippet": {
                    "text": "\n@lru_cache(maxsize=1024)\ndef is_overload_stub(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if a node is a function stub decorated with typing.overload.\n\n    :param node: Node to check.\n    :returns: True if node is an overload function stub. False otherwise.\n",
                    "rendered": {
                      "text": "\n@lru_cache(maxsize=1024)\ndef is_overload_stub(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if a node is a function stub decorated with typing.overload.\n\n    :param node: Node to check.\n    :returns: True if node is an overload function stub. False otherwise.\n",
                      "markdown": "`\n@lru_cache(maxsize=1024)\ndef is_overload_stub(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if a node is a function stub decorated with typing.overload.\n\n    :param node: Node to check.\n    :returns: True if node is an overload function stub. False otherwise.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1651,
                  "startColumn": 51,
                  "endLine": 1651,
                  "endColumn": 57,
                  "snippet": {
                    "text": "    :param parent: Node to check for superclass.\n    :returns: True if child is derived from parent. False otherwise.\n    \"\"\"\n    if not all(isinstance(node, nodes.ClassDef) for node in (child, parent)):\n        return False\n\n    for ancestor in child.ancestors():\n",
                    "rendered": {
                      "text": "    :param parent: Node to check for superclass.\n    :returns: True if child is derived from parent. False otherwise.\n    \"\"\"\n    if not all(isinstance(node, nodes.ClassDef) for node in (child, parent)):\n        return False\n\n    for ancestor in child.ancestors():\n",
                      "markdown": "`    :param parent: Node to check for superclass.\n    :returns: True if child is derived from parent. False otherwise.\n    \"\"\"\n    if not all(isinstance(node, nodes.ClassDef) for node in (child, parent)):\n        return False\n\n    for ancestor in child.ancestors():\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1648,
                  "startColumn": 18,
                  "endLine": 1648,
                  "endColumn": 24,
                  "snippet": {
                    "text": "    \"\"\"Check if first node is a subclass of second node.\n\n    :param child: Node to check for subclass.\n    :param parent: Node to check for superclass.\n    :returns: True if child is derived from parent. False otherwise.\n    \"\"\"\n    if not all(isinstance(node, nodes.ClassDef) for node in (child, parent)):\n",
                    "rendered": {
                      "text": "    \"\"\"Check if first node is a subclass of second node.\n\n    :param child: Node to check for subclass.\n    :param parent: Node to check for superclass.\n    :returns: True if child is derived from parent. False otherwise.\n    \"\"\"\n    if not all(isinstance(node, nodes.ClassDef) for node in (child, parent)):\n",
                      "markdown": "`    \"\"\"Check if first node is a subclass of second node.\n\n    :param child: Node to check for subclass.\n    :param parent: Node to check for superclass.\n    :returns: True if child is derived from parent. False otherwise.\n    \"\"\"\n    if not all(isinstance(node, nodes.ClassDef) for node in (child, parent)):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1647,
                  "startColumn": 17,
                  "endLine": 1647,
                  "endColumn": 23,
                  "snippet": {
                    "text": "def is_subclass_of(child: nodes.ClassDef, parent: nodes.ClassDef) -> bool:\n    \"\"\"Check if first node is a subclass of second node.\n\n    :param child: Node to check for subclass.\n    :param parent: Node to check for superclass.\n    :returns: True if child is derived from parent. False otherwise.\n    \"\"\"\n",
                    "rendered": {
                      "text": "def is_subclass_of(child: nodes.ClassDef, parent: nodes.ClassDef) -> bool:\n    \"\"\"Check if first node is a subclass of second node.\n\n    :param child: Node to check for subclass.\n    :param parent: Node to check for superclass.\n    :returns: True if child is derived from parent. False otherwise.\n    \"\"\"\n",
                      "markdown": "`def is_subclass_of(child: nodes.ClassDef, parent: nodes.ClassDef) -> bool:\n    \"\"\"Check if first node is a subclass of second node.\n\n    :param child: Node to check for subclass.\n    :param parent: Node to check for superclass.\n    :returns: True if child is derived from parent. False otherwise.\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1645,
                  "startColumn": 21,
                  "endLine": 1645,
                  "endColumn": 27,
                  "snippet": {
                    "text": "\n\ndef is_subclass_of(child: nodes.ClassDef, parent: nodes.ClassDef) -> bool:\n    \"\"\"Check if first node is a subclass of second node.\n\n    :param child: Node to check for subclass.\n    :param parent: Node to check for superclass.\n",
                    "rendered": {
                      "text": "\n\ndef is_subclass_of(child: nodes.ClassDef, parent: nodes.ClassDef) -> bool:\n    \"\"\"Check if first node is a subclass of second node.\n\n    :param child: Node to check for subclass.\n    :param parent: Node to check for superclass.\n",
                      "markdown": "`\n\ndef is_subclass_of(child: nodes.ClassDef, parent: nodes.ClassDef) -> bool:\n    \"\"\"Check if first node is a subclass of second node.\n\n    :param child: Node to check for subclass.\n    :param parent: Node to check for superclass.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1615,
                  "startColumn": 15,
                  "endLine": 1615,
                  "endColumn": 21,
                  "snippet": {
                    "text": "\n\ndef is_node_in_type_annotation_context(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if node is in type annotation context.\n\n    Check for 'AnnAssign', function 'Arguments',\n    or part of function return type annotation.\n",
                    "rendered": {
                      "text": "\n\ndef is_node_in_type_annotation_context(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if node is in type annotation context.\n\n    Check for 'AnnAssign', function 'Arguments',\n    or part of function return type annotation.\n",
                      "markdown": "`\n\ndef is_node_in_type_annotation_context(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if node is in type annotation context.\n\n    Check for 'AnnAssign', function 'Arguments',\n    or part of function return type annotation.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1588,
                  "startColumn": 13,
                  "endLine": 1588,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    \"\"\"Get the last lineno of the given node.\n\n    For a simple statement this will just be node.lineno,\n    but for a node that has child statements (e.g. a method) this will be the lineno of the last\n    child statement recursively.\n    \"\"\"\n    # 'finalbody' is always the last clause in a try statement, if present\n",
                    "rendered": {
                      "text": "    \"\"\"Get the last lineno of the given node.\n\n    For a simple statement this will just be node.lineno,\n    but for a node that has child statements (e.g. a method) this will be the lineno of the last\n    child statement recursively.\n    \"\"\"\n    # 'finalbody' is always the last clause in a try statement, if present\n",
                      "markdown": "`    \"\"\"Get the last lineno of the given node.\n\n    For a simple statement this will just be node.lineno,\n    but for a node that has child statements (e.g. a method) this will be the lineno of the last\n    child statement recursively.\n    \"\"\"\n    # 'finalbody' is always the last clause in a try statement, if present\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1569,
                  "startColumn": 34,
                  "endLine": 1569,
                  "endColumn": 40,
                  "snippet": {
                    "text": "\n\ndef is_registered_in_singledispatchmethod_function(node: nodes.FunctionDef) -> bool:\n    \"\"\"Check if the given function node is a singledispatchmethod function.\"\"\"\n    singledispatchmethod_qnames = (\n        \"functools.singledispatchmethod\",\n        \"singledispatch.singledispatchmethod\",\n",
                    "rendered": {
                      "text": "\n\ndef is_registered_in_singledispatchmethod_function(node: nodes.FunctionDef) -> bool:\n    \"\"\"Check if the given function node is a singledispatchmethod function.\"\"\"\n    singledispatchmethod_qnames = (\n        \"functools.singledispatchmethod\",\n        \"singledispatch.singledispatchmethod\",\n",
                      "markdown": "`\n\ndef is_registered_in_singledispatchmethod_function(node: nodes.FunctionDef) -> bool:\n    \"\"\"Check if the given function node is a singledispatchmethod function.\"\"\"\n    singledispatchmethod_qnames = (\n        \"functools.singledispatchmethod\",\n        \"singledispatch.singledispatchmethod\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1554,
                  "startColumn": 14,
                  "endLine": 1555,
                  "snippet": {
                    "text": "    if isinstance(node, nodes.Call):\n        func = node.func\n    elif isinstance(node, nodes.Attribute):\n        func = node\n    else:\n        return None\n\n    if not isinstance(func, nodes.Attribute) or func.attrname != \"register\":\n",
                    "rendered": {
                      "text": "    if isinstance(node, nodes.Call):\n        func = node.func\n    elif isinstance(node, nodes.Attribute):\n        func = node\n    else:\n        return None\n\n    if not isinstance(func, nodes.Attribute) or func.attrname != \"register\":\n",
                      "markdown": "`    if isinstance(node, nodes.Call):\n        func = node.func\n    elif isinstance(node, nodes.Attribute):\n        func = node\n    else:\n        return None\n\n    if not isinstance(func, nodes.Attribute) or func.attrname != \"register\":\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1514,
                  "startColumn": 34,
                  "endLine": 1514,
                  "endColumn": 40,
                  "snippet": {
                    "text": "\n\ndef is_registered_in_singledispatch_function(node: nodes.FunctionDef) -> bool:\n    \"\"\"Check if the given function node is a singledispatch function.\"\"\"\n    singledispatch_qnames = (\n        \"functools.singledispatch\",\n        \"singledispatch.singledispatch\",\n",
                    "rendered": {
                      "text": "\n\ndef is_registered_in_singledispatch_function(node: nodes.FunctionDef) -> bool:\n    \"\"\"Check if the given function node is a singledispatch function.\"\"\"\n    singledispatch_qnames = (\n        \"functools.singledispatch\",\n        \"singledispatch.singledispatch\",\n",
                      "markdown": "`\n\ndef is_registered_in_singledispatch_function(node: nodes.FunctionDef) -> bool:\n    \"\"\"Check if the given function node is a singledispatch function.\"\"\"\n    singledispatch_qnames = (\n        \"functools.singledispatch\",\n        \"singledispatch.singledispatch\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1486,
                  "startColumn": 7,
                  "endLine": 1486,
                  "endColumn": 13,
                  "snippet": {
                    "text": "\ndef is_none(node: nodes.NodeNG) -> bool:\n    return (\n        node is None\n        or (isinstance(node, nodes.Const) and node.value is None)\n        or (isinstance(node, nodes.Name) and node.name == \"None\")\n    )\n",
                    "rendered": {
                      "text": "\ndef is_none(node: nodes.NodeNG) -> bool:\n    return (\n        node is None\n        or (isinstance(node, nodes.Const) and node.value is None)\n        or (isinstance(node, nodes.Name) and node.name == \"None\")\n    )\n",
                      "markdown": "`\ndef is_none(node: nodes.NodeNG) -> bool:\n    return (\n        node is None\n        or (isinstance(node, nodes.Const) and node.value is None)\n        or (isinstance(node, nodes.Name) and node.name == \"None\")\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1354,
                  "startColumn": 7,
                  "endLine": 1354,
                  "endColumn": 13,
                  "snippet": {
                    "text": "    \"\"\"Return the inferred value for the given node.\n\n    Return None if inference failed or if there is some ambiguity (more than\n    one node has been inferred of different types).\n\n    If compare_constants is True and if multiple constants are inferred,\n    unequal inferred values are also considered ambiguous and return None.\n",
                    "rendered": {
                      "text": "    \"\"\"Return the inferred value for the given node.\n\n    Return None if inference failed or if there is some ambiguity (more than\n    one node has been inferred of different types).\n\n    If compare_constants is True and if multiple constants are inferred,\n    unequal inferred values are also considered ambiguous and return None.\n",
                      "markdown": "`    \"\"\"Return the inferred value for the given node.\n\n    Return None if inference failed or if there is some ambiguity (more than\n    one node has been inferred of different types).\n\n    If compare_constants is True and if multiple constants are inferred,\n    unequal inferred values are also considered ambiguous and return None.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1322,
                  "startColumn": 11,
                  "endLine": 1323,
                  "snippet": {
                    "text": "        if _supports_protocol_method(value, CLASS_GETITEM_METHOD):\n            return True\n        if is_postponed_evaluation_enabled(node) and is_node_in_type_annotation_context(\n            node\n        ):\n            return True\n    return _supports_protocol(value, _supports_getitem_protocol)\n\n",
                    "rendered": {
                      "text": "        if _supports_protocol_method(value, CLASS_GETITEM_METHOD):\n            return True\n        if is_postponed_evaluation_enabled(node) and is_node_in_type_annotation_context(\n            node\n        ):\n            return True\n    return _supports_protocol(value, _supports_getitem_protocol)\n\n",
                      "markdown": "`        if _supports_protocol_method(value, CLASS_GETITEM_METHOD):\n            return True\n        if is_postponed_evaluation_enabled(node) and is_node_in_type_annotation_context(\n            node\n        ):\n            return True\n    return _supports_protocol(value, _supports_getitem_protocol)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1263,
                  "startColumn": 7,
                  "endLine": 1263,
                  "endColumn": 13,
                  "snippet": {
                    "text": "            name = getattr(node, \"name\", None)\n            if name is not None and _is_abstract_class_name(name):\n                return True\n        node = node.parent\n    return False\n\n\n",
                    "rendered": {
                      "text": "            name = getattr(node, \"name\", None)\n            if name is not None and _is_abstract_class_name(name):\n                return True\n        node = node.parent\n    return False\n\n\n",
                      "markdown": "`            name = getattr(node, \"name\", None)\n            if name is not None and _is_abstract_class_name(name):\n                return True\n        node = node.parent\n    return False\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1256,
                  "startColumn": 9,
                  "endLine": 1256,
                  "endColumn": 15,
                  "snippet": {
                    "text": "\n\ndef is_inside_abstract_class(node: nodes.NodeNG) -> bool:\n    while node is not None:\n        if isinstance(node, nodes.ClassDef):\n            if class_is_abstract(node):\n                return True\n",
                    "rendered": {
                      "text": "\n\ndef is_inside_abstract_class(node: nodes.NodeNG) -> bool:\n    while node is not None:\n        if isinstance(node, nodes.ClassDef):\n            if class_is_abstract(node):\n                return True\n",
                      "markdown": "`\n\ndef is_inside_abstract_class(node: nodes.NodeNG) -> bool:\n    while node is not None:\n        if isinstance(node, nodes.ClassDef):\n            if class_is_abstract(node):\n                return True\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1156,
                  "startColumn": 37,
                  "endLine": 1156,
                  "endColumn": 43,
                  "snippet": {
                    "text": "\n@lru_cache(maxsize=1024)\ndef class_is_abstract(node: nodes.ClassDef) -> bool:\n    \"\"\"Return true if the given class node should be considered as an abstract\n    class.\n    \"\"\"\n    # Protocol classes are considered \"abstract\"\n",
                    "rendered": {
                      "text": "\n@lru_cache(maxsize=1024)\ndef class_is_abstract(node: nodes.ClassDef) -> bool:\n    \"\"\"Return true if the given class node should be considered as an abstract\n    class.\n    \"\"\"\n    # Protocol classes are considered \"abstract\"\n",
                      "markdown": "`\n@lru_cache(maxsize=1024)\ndef class_is_abstract(node: nodes.ClassDef) -> bool:\n    \"\"\"Return true if the given class node should be considered as an abstract\n    class.\n    \"\"\"\n    # Protocol classes are considered \"abstract\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1143,
                  "startColumn": 19,
                  "endLine": 1143,
                  "endColumn": 25,
                  "snippet": {
                    "text": "def node_ignores_exception(\n    node: nodes.NodeNG, exception: type[Exception] | str = Exception\n) -> bool:\n    \"\"\"Check if the node is in a Try which handles the given exception.\n\n    If the exception is not given, the function is going to look for bare\n    excepts.\n",
                    "rendered": {
                      "text": "def node_ignores_exception(\n    node: nodes.NodeNG, exception: type[Exception] | str = Exception\n) -> bool:\n    \"\"\"Check if the node is in a Try which handles the given exception.\n\n    If the exception is not given, the function is going to look for bare\n    excepts.\n",
                      "markdown": "`def node_ignores_exception(\n    node: nodes.NodeNG, exception: type[Exception] | str = Exception\n) -> bool:\n    \"\"\"Check if the node is in a Try which handles the given exception.\n\n    If the exception is not given, the function is going to look for bare\n    excepts.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1134,
                  "startColumn": 25,
                  "endLine": 1134,
                  "endColumn": 31,
                  "snippet": {
                    "text": "        node (nodes.Raise): the node raising the exception.\n\n    Returns:\n        bool: True if the node is inside a try/except statement, False otherwise.\n    \"\"\"\n    context = find_try_except_wrapper_node(node)\n    return isinstance(context, nodes.Try)\n",
                    "rendered": {
                      "text": "        node (nodes.Raise): the node raising the exception.\n\n    Returns:\n        bool: True if the node is inside a try/except statement, False otherwise.\n    \"\"\"\n    context = find_try_except_wrapper_node(node)\n    return isinstance(context, nodes.Try)\n",
                      "markdown": "`        node (nodes.Raise): the node raising the exception.\n\n    Returns:\n        bool: True if the node is inside a try/except statement, False otherwise.\n    \"\"\"\n    context = find_try_except_wrapper_node(node)\n    return isinstance(context, nodes.Try)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1131,
                  "startColumn": 31,
                  "endLine": 1131,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    (but not under an ExceptHandler!).\n\n    Args:\n        node (nodes.Raise): the node raising the exception.\n\n    Returns:\n        bool: True if the node is inside a try/except statement, False otherwise.\n",
                    "rendered": {
                      "text": "    (but not under an ExceptHandler!).\n\n    Args:\n        node (nodes.Raise): the node raising the exception.\n\n    Returns:\n        bool: True if the node is inside a try/except statement, False otherwise.\n",
                      "markdown": "`    (but not under an ExceptHandler!).\n\n    Args:\n        node (nodes.Raise): the node raising the exception.\n\n    Returns:\n        bool: True if the node is inside a try/except statement, False otherwise.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1131,
                  "startColumn": 7,
                  "endLine": 1131,
                  "endColumn": 13,
                  "snippet": {
                    "text": "    (but not under an ExceptHandler!).\n\n    Args:\n        node (nodes.Raise): the node raising the exception.\n\n    Returns:\n        bool: True if the node is inside a try/except statement, False otherwise.\n",
                    "rendered": {
                      "text": "    (but not under an ExceptHandler!).\n\n    Args:\n        node (nodes.Raise): the node raising the exception.\n\n    Returns:\n        bool: True if the node is inside a try/except statement, False otherwise.\n",
                      "markdown": "`    (but not under an ExceptHandler!).\n\n    Args:\n        node (nodes.Raise): the node raising the exception.\n\n    Returns:\n        bool: True if the node is inside a try/except statement, False otherwise.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1127,
                  "startColumn": 19,
                  "endLine": 1127,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n\ndef is_node_inside_try_except(node: nodes.Raise) -> bool:\n    \"\"\"Check if the node is directly under a Try/Except statement\n    (but not under an ExceptHandler!).\n\n    Args:\n",
                    "rendered": {
                      "text": "\n\ndef is_node_inside_try_except(node: nodes.Raise) -> bool:\n    \"\"\"Check if the node is directly under a Try/Except statement\n    (but not under an ExceptHandler!).\n\n    Args:\n",
                      "markdown": "`\n\ndef is_node_inside_try_except(node: nodes.Raise) -> bool:\n    \"\"\"Check if the node is directly under a Try/Except statement\n    (but not under an ExceptHandler!).\n\n    Args:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1112,
                  "startColumn": 26,
                  "endLine": 1112,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        exception (builtin.Exception): exception or name of the exception.\n\n    Yields:\n        nodes.With: A with node that is suppressing the exception.\n    \"\"\"\n    for with_node in get_contextlib_with_statements(node):\n        for item, _ in with_node.items:\n",
                    "rendered": {
                      "text": "        exception (builtin.Exception): exception or name of the exception.\n\n    Yields:\n        nodes.With: A with node that is suppressing the exception.\n    \"\"\"\n    for with_node in get_contextlib_with_statements(node):\n        for item, _ in with_node.items:\n",
                      "markdown": "`        exception (builtin.Exception): exception or name of the exception.\n\n    Yields:\n        nodes.With: A with node that is suppressing the exception.\n    \"\"\"\n    for with_node in get_contextlib_with_statements(node):\n        for item, _ in with_node.items:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1108,
                  "startColumn": 30,
                  "endLine": 1108,
                  "endColumn": 36,
                  "snippet": {
                    "text": "    \"\"\"Return the contextlib suppressors handling the exception.\n\n    Args:\n        node (nodes.NodeNG): A node that is potentially wrapped in a contextlib.suppress.\n        exception (builtin.Exception): exception or name of the exception.\n\n    Yields:\n",
                    "rendered": {
                      "text": "    \"\"\"Return the contextlib suppressors handling the exception.\n\n    Args:\n        node (nodes.NodeNG): A node that is potentially wrapped in a contextlib.suppress.\n        exception (builtin.Exception): exception or name of the exception.\n\n    Yields:\n",
                      "markdown": "`    \"\"\"Return the contextlib suppressors handling the exception.\n\n    Args:\n        node (nodes.NodeNG): A node that is potentially wrapped in a contextlib.suppress.\n        exception (builtin.Exception): exception or name of the exception.\n\n    Yields:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1108,
                  "startColumn": 7,
                  "endLine": 1108,
                  "endColumn": 13,
                  "snippet": {
                    "text": "    \"\"\"Return the contextlib suppressors handling the exception.\n\n    Args:\n        node (nodes.NodeNG): A node that is potentially wrapped in a contextlib.suppress.\n        exception (builtin.Exception): exception or name of the exception.\n\n    Yields:\n",
                    "rendered": {
                      "text": "    \"\"\"Return the contextlib suppressors handling the exception.\n\n    Args:\n        node (nodes.NodeNG): A node that is potentially wrapped in a contextlib.suppress.\n        exception (builtin.Exception): exception or name of the exception.\n\n    Yields:\n",
                      "markdown": "`    \"\"\"Return the contextlib suppressors handling the exception.\n\n    Args:\n        node (nodes.NodeNG): A node that is potentially wrapped in a contextlib.suppress.\n        exception (builtin.Exception): exception or name of the exception.\n\n    Yields:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1083,
                  "startColumn": 25,
                  "endLine": 1083,
                  "endColumn": 31,
                  "snippet": {
                    "text": "def _suppresses_exception(\n    call: nodes.Call, exception: type[Exception] | str = Exception\n) -> bool:\n    \"\"\"Check if the given node suppresses the given exception.\"\"\"\n    if not isinstance(exception, str):\n        exception = exception.__name__\n    for arg in call.args:\n",
                    "rendered": {
                      "text": "def _suppresses_exception(\n    call: nodes.Call, exception: type[Exception] | str = Exception\n) -> bool:\n    \"\"\"Check if the given node suppresses the given exception.\"\"\"\n    if not isinstance(exception, str):\n        exception = exception.__name__\n    for arg in call.args:\n",
                      "markdown": "`def _suppresses_exception(\n    call: nodes.Call, exception: type[Exception] | str = Exception\n) -> bool:\n    \"\"\"Check if the given node suppresses the given exception.\"\"\"\n    if not isinstance(exception, str):\n        exception = exception.__name__\n    for arg in call.args:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1059,
                  "startColumn": 30,
                  "endLine": 1059,
                  "endColumn": 36,
                  "snippet": {
                    "text": "    \"\"\"Return the collections of handlers handling the exception in arguments.\n\n    Args:\n        node (nodes.NodeNG): A node that is potentially wrapped in a try except.\n        exception (builtin.Exception or str): exception or name of the exception.\n\n    Returns:\n",
                    "rendered": {
                      "text": "    \"\"\"Return the collections of handlers handling the exception in arguments.\n\n    Args:\n        node (nodes.NodeNG): A node that is potentially wrapped in a try except.\n        exception (builtin.Exception or str): exception or name of the exception.\n\n    Returns:\n",
                      "markdown": "`    \"\"\"Return the collections of handlers handling the exception in arguments.\n\n    Args:\n        node (nodes.NodeNG): A node that is potentially wrapped in a try except.\n        exception (builtin.Exception or str): exception or name of the exception.\n\n    Returns:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1059,
                  "startColumn": 7,
                  "endLine": 1059,
                  "endColumn": 13,
                  "snippet": {
                    "text": "    \"\"\"Return the collections of handlers handling the exception in arguments.\n\n    Args:\n        node (nodes.NodeNG): A node that is potentially wrapped in a try except.\n        exception (builtin.Exception or str): exception or name of the exception.\n\n    Returns:\n",
                    "rendered": {
                      "text": "    \"\"\"Return the collections of handlers handling the exception in arguments.\n\n    Args:\n        node (nodes.NodeNG): A node that is potentially wrapped in a try except.\n        exception (builtin.Exception or str): exception or name of the exception.\n\n    Returns:\n",
                      "markdown": "`    \"\"\"Return the collections of handlers handling the exception in arguments.\n\n    Args:\n        node (nodes.NodeNG): A node that is potentially wrapped in a try except.\n        exception (builtin.Exception or str): exception or name of the exception.\n\n    Returns:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1021,
                  "startColumn": 25,
                  "endLine": 1021,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n\ndef is_from_fallback_block(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is from a fallback import block.\"\"\"\n    context = find_try_except_wrapper_node(node)\n    if not context:\n        return False\n",
                    "rendered": {
                      "text": "\n\ndef is_from_fallback_block(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is from a fallback import block.\"\"\"\n    context = find_try_except_wrapper_node(node)\n    if not context:\n        return False\n",
                      "markdown": "`\n\ndef is_from_fallback_block(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is from a fallback import block.\"\"\"\n    context = find_try_except_wrapper_node(node)\n    if not context:\n        return False\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 1007,
                  "startColumn": 44,
                  "endLine": 1007,
                  "endColumn": 50,
                  "snippet": {
                    "text": "def find_except_wrapper_node_in_scope(\n    node: nodes.NodeNG,\n) -> nodes.ExceptHandler | None:\n    \"\"\"Return the ExceptHandler in which the node is, without going out of scope.\"\"\"\n    for current in node.node_ancestors():\n        if isinstance(current, astroid.scoped_nodes.LocalsDictNodeNG):\n            # If we're inside a function/class definition, we don't want to keep checking\n",
                    "rendered": {
                      "text": "def find_except_wrapper_node_in_scope(\n    node: nodes.NodeNG,\n) -> nodes.ExceptHandler | None:\n    \"\"\"Return the ExceptHandler in which the node is, without going out of scope.\"\"\"\n    for current in node.node_ancestors():\n        if isinstance(current, astroid.scoped_nodes.LocalsDictNodeNG):\n            # If we're inside a function/class definition, we don't want to keep checking\n",
                      "markdown": "`def find_except_wrapper_node_in_scope(\n    node: nodes.NodeNG,\n) -> nodes.ExceptHandler | None:\n    \"\"\"Return the ExceptHandler in which the node is, without going out of scope.\"\"\"\n    for current in node.node_ancestors():\n        if isinstance(current, astroid.scoped_nodes.LocalsDictNodeNG):\n            # If we're inside a function/class definition, we don't want to keep checking\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 994,
                  "startColumn": 13,
                  "endLine": 995,
                  "snippet": {
                    "text": "    node: nodes.NodeNG,\n) -> nodes.ExceptHandler | nodes.Try | None:\n    \"\"\"Return the ExceptHandler or the Try node in which the node is.\"\"\"\n    current = node\n    ignores = (nodes.ExceptHandler, nodes.Try)\n    while current and not isinstance(current.parent, ignores):\n        current = current.parent\n\n",
                    "rendered": {
                      "text": "    node: nodes.NodeNG,\n) -> nodes.ExceptHandler | nodes.Try | None:\n    \"\"\"Return the ExceptHandler or the Try node in which the node is.\"\"\"\n    current = node\n    ignores = (nodes.ExceptHandler, nodes.Try)\n    while current and not isinstance(current.parent, ignores):\n        current = current.parent\n\n",
                      "markdown": "`    node: nodes.NodeNG,\n) -> nodes.ExceptHandler | nodes.Try | None:\n    \"\"\"Return the ExceptHandler or the Try node in which the node is.\"\"\"\n    current = node\n    ignores = (nodes.ExceptHandler, nodes.Try)\n    while current and not isinstance(current.parent, ignores):\n        current = current.parent\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 993,
                  "startColumn": 60,
                  "endLine": 993,
                  "endColumn": 66,
                  "snippet": {
                    "text": "def find_try_except_wrapper_node(\n    node: nodes.NodeNG,\n) -> nodes.ExceptHandler | nodes.Try | None:\n    \"\"\"Return the ExceptHandler or the Try node in which the node is.\"\"\"\n    current = node\n    ignores = (nodes.ExceptHandler, nodes.Try)\n    while current and not isinstance(current.parent, ignores):\n",
                    "rendered": {
                      "text": "def find_try_except_wrapper_node(\n    node: nodes.NodeNG,\n) -> nodes.ExceptHandler | nodes.Try | None:\n    \"\"\"Return the ExceptHandler or the Try node in which the node is.\"\"\"\n    current = node\n    ignores = (nodes.ExceptHandler, nodes.Try)\n    while current and not isinstance(current.parent, ignores):\n",
                      "markdown": "`def find_try_except_wrapper_node(\n    node: nodes.NodeNG,\n) -> nodes.ExceptHandler | nodes.Try | None:\n    \"\"\"Return the ExceptHandler or the Try node in which the node is.\"\"\"\n    current = node\n    ignores = (nodes.ExceptHandler, nodes.Try)\n    while current and not isinstance(current.parent, ignores):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 993,
                  "startColumn": 42,
                  "endLine": 993,
                  "endColumn": 48,
                  "snippet": {
                    "text": "def find_try_except_wrapper_node(\n    node: nodes.NodeNG,\n) -> nodes.ExceptHandler | nodes.Try | None:\n    \"\"\"Return the ExceptHandler or the Try node in which the node is.\"\"\"\n    current = node\n    ignores = (nodes.ExceptHandler, nodes.Try)\n    while current and not isinstance(current.parent, ignores):\n",
                    "rendered": {
                      "text": "def find_try_except_wrapper_node(\n    node: nodes.NodeNG,\n) -> nodes.ExceptHandler | nodes.Try | None:\n    \"\"\"Return the ExceptHandler or the Try node in which the node is.\"\"\"\n    current = node\n    ignores = (nodes.ExceptHandler, nodes.Try)\n    while current and not isinstance(current.parent, ignores):\n",
                      "markdown": "`def find_try_except_wrapper_node(\n    node: nodes.NodeNG,\n) -> nodes.ExceptHandler | nodes.Try | None:\n    \"\"\"Return the ExceptHandler or the Try node in which the node is.\"\"\"\n    current = node\n    ignores = (nodes.ExceptHandler, nodes.Try)\n    while current and not isinstance(current.parent, ignores):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 911,
                  "startColumn": 44,
                  "endLine": 911,
                  "endColumn": 50,
                  "snippet": {
                    "text": "            _, import_nodes = decorator.lookup(decorator.name)\n\n        # The `final` decorator is expected to be found in the\n        # import_nodes. Continue if we don't find any `Import` or `ImportFrom`\n        # nodes for this decorator.\n        if not import_nodes:\n            continue\n",
                    "rendered": {
                      "text": "            _, import_nodes = decorator.lookup(decorator.name)\n\n        # The `final` decorator is expected to be found in the\n        # import_nodes. Continue if we don't find any `Import` or `ImportFrom`\n        # nodes for this decorator.\n        if not import_nodes:\n            continue\n",
                      "markdown": "`            _, import_nodes = decorator.lookup(decorator.name)\n\n        # The `final` decorator is expected to be found in the\n        # import_nodes. Continue if we don't find any `Import` or `ImportFrom`\n        # nodes for this decorator.\n        if not import_nodes:\n            continue\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 869,
                  "startColumn": 30,
                  "endLine": 869,
                  "endColumn": 36,
                  "snippet": {
                    "text": "    ),\n    qnames: Iterable[str],\n) -> bool:\n    \"\"\"Determine if the `func` node has a decorator with the qualified name `qname`.\"\"\"\n    decorators = func.decorators.nodes if func.decorators else []\n    for decorator_node in decorators:\n        if isinstance(decorator_node, nodes.Call):\n",
                    "rendered": {
                      "text": "    ),\n    qnames: Iterable[str],\n) -> bool:\n    \"\"\"Determine if the `func` node has a decorator with the qualified name `qname`.\"\"\"\n    decorators = func.decorators.nodes if func.decorators else []\n    for decorator_node in decorators:\n        if isinstance(decorator_node, nodes.Call):\n",
                      "markdown": "`    ),\n    qnames: Iterable[str],\n) -> bool:\n    \"\"\"Determine if the `func` node has a decorator with the qualified name `qname`.\"\"\"\n    decorators = func.decorators.nodes if func.decorators else []\n    for decorator_node in decorators:\n        if isinstance(decorator_node, nodes.Call):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 832,
                  "startColumn": 25,
                  "endLine": 832,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n\ndef is_property_setter_or_deleter(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is either a property setter or a deleter.\"\"\"\n    return _is_property_kind(node, \"setter\", \"deleter\")\n\n\n",
                    "rendered": {
                      "text": "\n\ndef is_property_setter_or_deleter(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is either a property setter or a deleter.\"\"\"\n    return _is_property_kind(node, \"setter\", \"deleter\")\n\n\n",
                      "markdown": "`\n\ndef is_property_setter_or_deleter(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is either a property setter or a deleter.\"\"\"\n    return _is_property_kind(node, \"setter\", \"deleter\")\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 827,
                  "startColumn": 25,
                  "endLine": 827,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n\ndef is_property_deleter(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is a property deleter.\"\"\"\n    return _is_property_kind(node, \"deleter\")\n\n\n",
                    "rendered": {
                      "text": "\n\ndef is_property_deleter(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is a property deleter.\"\"\"\n    return _is_property_kind(node, \"deleter\")\n\n\n",
                      "markdown": "`\n\ndef is_property_deleter(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is a property deleter.\"\"\"\n    return _is_property_kind(node, \"deleter\")\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 822,
                  "startColumn": 25,
                  "endLine": 822,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n\ndef is_property_setter(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is a property setter.\"\"\"\n    return _is_property_kind(node, \"setter\")\n\n\n",
                    "rendered": {
                      "text": "\n\ndef is_property_setter(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is a property setter.\"\"\"\n    return _is_property_kind(node, \"setter\")\n\n\n",
                      "markdown": "`\n\ndef is_property_setter(node: nodes.NodeNG) -> bool:\n    \"\"\"Check if the given node is a property setter.\"\"\"\n    return _is_property_kind(node, \"setter\")\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 799,
                  "startColumn": 35,
                  "endLine": 799,
                  "endColumn": 41,
                  "snippet": {
                    "text": "\n\ndef decorated_with_property(node: nodes.FunctionDef) -> bool:\n    \"\"\"Detect if the given function node is decorated with a property.\"\"\"\n    if not node.decorators:\n        return False\n    for decorator in node.decorators.nodes:\n",
                    "rendered": {
                      "text": "\n\ndef decorated_with_property(node: nodes.FunctionDef) -> bool:\n    \"\"\"Detect if the given function node is decorated with a property.\"\"\"\n    if not node.decorators:\n        return False\n    for decorator in node.decorators.nodes:\n",
                      "markdown": "`\n\ndef decorated_with_property(node: nodes.FunctionDef) -> bool:\n    \"\"\"Detect if the given function node is decorated with a property.\"\"\"\n    if not node.decorators:\n        return False\n    for decorator in node.decorators.nodes:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 760,
                  "startColumn": 37,
                  "endLine": 760,
                  "endColumn": 43,
                  "snippet": {
                    "text": "\n\ndef inherit_from_std_ex(node: nodes.NodeNG | astroid.Instance) -> bool:\n    \"\"\"Return whether the given class node is subclass of\n    exceptions.Exception.\n    \"\"\"\n    ancestors = node.ancestors() if hasattr(node, \"ancestors\") else []\n",
                    "rendered": {
                      "text": "\n\ndef inherit_from_std_ex(node: nodes.NodeNG | astroid.Instance) -> bool:\n    \"\"\"Return whether the given class node is subclass of\n    exceptions.Exception.\n    \"\"\"\n    ancestors = node.ancestors() if hasattr(node, \"ancestors\") else []\n",
                      "markdown": "`\n\ndef inherit_from_std_ex(node: nodes.NodeNG | astroid.Instance) -> bool:\n    \"\"\"Return whether the given class node is subclass of\n    exceptions.Exception.\n    \"\"\"\n    ancestors = node.ancestors() if hasattr(node, \"ancestors\") else []\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 746,
                  "startColumn": 17,
                  "endLine": 746,
                  "endColumn": 23,
                  "snippet": {
                    "text": "    :param nodes.Call call_node: Node representing a function call to check.\n    :param str keyword: Name of the argument to be extracted.\n\n    :returns: The node representing the argument, None if the argument is not found.\n    :rtype: nodes.Name\n    \"\"\"\n    for arg in call_node.kwargs:\n",
                    "rendered": {
                      "text": "    :param nodes.Call call_node: Node representing a function call to check.\n    :param str keyword: Name of the argument to be extracted.\n\n    :returns: The node representing the argument, None if the argument is not found.\n    :rtype: nodes.Name\n    \"\"\"\n    for arg in call_node.kwargs:\n",
                      "markdown": "`    :param nodes.Call call_node: Node representing a function call to check.\n    :param str keyword: Name of the argument to be extracted.\n\n    :returns: The node representing the argument, None if the argument is not found.\n    :rtype: nodes.Name\n    \"\"\"\n    for arg in call_node.kwargs:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 743,
                  "startColumn": 32,
                  "endLine": 743,
                  "endColumn": 38,
                  "snippet": {
                    "text": "def infer_kwarg_from_call(call_node: nodes.Call, keyword: str) -> nodes.Name | None:\n    \"\"\"Returns the specified argument from a function's kwargs.\n\n    :param nodes.Call call_node: Node representing a function call to check.\n    :param str keyword: Name of the argument to be extracted.\n\n    :returns: The node representing the argument, None if the argument is not found.\n",
                    "rendered": {
                      "text": "def infer_kwarg_from_call(call_node: nodes.Call, keyword: str) -> nodes.Name | None:\n    \"\"\"Returns the specified argument from a function's kwargs.\n\n    :param nodes.Call call_node: Node representing a function call to check.\n    :param str keyword: Name of the argument to be extracted.\n\n    :returns: The node representing the argument, None if the argument is not found.\n",
                      "markdown": "`def infer_kwarg_from_call(call_node: nodes.Call, keyword: str) -> nodes.Name | None:\n    \"\"\"Returns the specified argument from a function's kwargs.\n\n    :param nodes.Call call_node: Node representing a function call to check.\n    :param str keyword: Name of the argument to be extracted.\n\n    :returns: The node representing the argument, None if the argument is not found.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 719,
                  "startColumn": 17,
                  "endLine": 719,
                  "endColumn": 23,
                  "snippet": {
                    "text": "    :param int position: position of the argument.\n    :param str keyword: the keyword of the argument.\n\n    :returns: The node representing the argument, None if the argument is not found.\n    :rtype: nodes.Name\n    :raises ValueError: if both position and keyword are None.\n    :raises NoSuchArgumentError: if no argument at the provided position or with\n",
                    "rendered": {
                      "text": "    :param int position: position of the argument.\n    :param str keyword: the keyword of the argument.\n\n    :returns: The node representing the argument, None if the argument is not found.\n    :rtype: nodes.Name\n    :raises ValueError: if both position and keyword are None.\n    :raises NoSuchArgumentError: if no argument at the provided position or with\n",
                      "markdown": "`    :param int position: position of the argument.\n    :param str keyword: the keyword of the argument.\n\n    :returns: The node representing the argument, None if the argument is not found.\n    :rtype: nodes.Name\n    :raises ValueError: if both position and keyword are None.\n    :raises NoSuchArgumentError: if no argument at the provided position or with\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 715,
                  "startColumn": 32,
                  "endLine": 715,
                  "endColumn": 38,
                  "snippet": {
                    "text": ") -> nodes.Name:\n    \"\"\"Returns the specified argument from a function call.\n\n    :param nodes.Call call_node: Node representing a function call to check.\n    :param int position: position of the argument.\n    :param str keyword: the keyword of the argument.\n\n",
                    "rendered": {
                      "text": ") -> nodes.Name:\n    \"\"\"Returns the specified argument from a function call.\n\n    :param nodes.Call call_node: Node representing a function call to check.\n    :param int position: position of the argument.\n    :param str keyword: the keyword of the argument.\n\n",
                      "markdown": "`) -> nodes.Name:\n    \"\"\"Returns the specified argument from a function call.\n\n    :param nodes.Call call_node: Node representing a function call to check.\n    :param int position: position of the argument.\n    :param str keyword: the keyword of the argument.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 673,
                  "startColumn": 45,
                  "endLine": 673,
                  "endColumn": 51,
                  "snippet": {
                    "text": "def node_frame_class(node: nodes.NodeNG) -> nodes.ClassDef | None:\n    \"\"\"Return the class that is wrapping the given node.\n\n    The function returns a class for a method node (or a staticmethod or a\n    classmethod), otherwise it returns `None`.\n    \"\"\"\n    klass = node.frame()\n",
                    "rendered": {
                      "text": "def node_frame_class(node: nodes.NodeNG) -> nodes.ClassDef | None:\n    \"\"\"Return the class that is wrapping the given node.\n\n    The function returns a class for a method node (or a staticmethod or a\n    classmethod), otherwise it returns `None`.\n    \"\"\"\n    klass = node.frame()\n",
                      "markdown": "`def node_frame_class(node: nodes.NodeNG) -> nodes.ClassDef | None:\n    \"\"\"Return the class that is wrapping the given node.\n\n    The function returns a class for a method node (or a staticmethod or a\n    classmethod), otherwise it returns `None`.\n    \"\"\"\n    klass = node.frame()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 458,
                  "startColumn": 10,
                  "endLine": 459,
                  "snippet": {
                    "text": "    \"\"\"Return the higher parent which is not an AssignName, Tuple or List node.\"\"\"\n    while node and isinstance(node, (nodes.AssignName, nodes.Tuple, nodes.List)):\n        node = node.parent\n    return node\n\n\ndef overrides_a_method(class_node: nodes.ClassDef, name: str) -> bool:\n    \"\"\"Return True if <name> is a method overridden from an ancestor\n",
                    "rendered": {
                      "text": "    \"\"\"Return the higher parent which is not an AssignName, Tuple or List node.\"\"\"\n    while node and isinstance(node, (nodes.AssignName, nodes.Tuple, nodes.List)):\n        node = node.parent\n    return node\n\n\ndef overrides_a_method(class_node: nodes.ClassDef, name: str) -> bool:\n    \"\"\"Return True if <name> is a method overridden from an ancestor\n",
                      "markdown": "`    \"\"\"Return the higher parent which is not an AssignName, Tuple or List node.\"\"\"\n    while node and isinstance(node, (nodes.AssignName, nodes.Tuple, nodes.List)):\n        node = node.parent\n    return node\n\n\ndef overrides_a_method(class_node: nodes.ClassDef, name: str) -> bool:\n    \"\"\"Return True if <name> is a method overridden from an ancestor\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 457,
                  "startColumn": 7,
                  "endLine": 457,
                  "endColumn": 13,
                  "snippet": {
                    "text": "def assign_parent(node: nodes.NodeNG) -> nodes.NodeNG:\n    \"\"\"Return the higher parent which is not an AssignName, Tuple or List node.\"\"\"\n    while node and isinstance(node, (nodes.AssignName, nodes.Tuple, nodes.List)):\n        node = node.parent\n    return node\n\n\n",
                    "rendered": {
                      "text": "def assign_parent(node: nodes.NodeNG) -> nodes.NodeNG:\n    \"\"\"Return the higher parent which is not an AssignName, Tuple or List node.\"\"\"\n    while node and isinstance(node, (nodes.AssignName, nodes.Tuple, nodes.List)):\n        node = node.parent\n    return node\n\n\n",
                      "markdown": "`def assign_parent(node: nodes.NodeNG) -> nodes.NodeNG:\n    \"\"\"Return the higher parent which is not an AssignName, Tuple or List node.\"\"\"\n    while node and isinstance(node, (nodes.AssignName, nodes.Tuple, nodes.List)):\n        node = node.parent\n    return node\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 456,
                  "startColumn": 9,
                  "endLine": 456,
                  "endColumn": 15,
                  "snippet": {
                    "text": "\ndef assign_parent(node: nodes.NodeNG) -> nodes.NodeNG:\n    \"\"\"Return the higher parent which is not an AssignName, Tuple or List node.\"\"\"\n    while node and isinstance(node, (nodes.AssignName, nodes.Tuple, nodes.List)):\n        node = node.parent\n    return node\n\n",
                    "rendered": {
                      "text": "\ndef assign_parent(node: nodes.NodeNG) -> nodes.NodeNG:\n    \"\"\"Return the higher parent which is not an AssignName, Tuple or List node.\"\"\"\n    while node and isinstance(node, (nodes.AssignName, nodes.Tuple, nodes.List)):\n        node = node.parent\n    return node\n\n",
                      "markdown": "`\ndef assign_parent(node: nodes.NodeNG) -> nodes.NodeNG:\n    \"\"\"Return the higher parent which is not an AssignName, Tuple or List node.\"\"\"\n    while node and isinstance(node, (nodes.AssignName, nodes.Tuple, nodes.List)):\n        node = node.parent\n    return node\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 451,
                  "startColumn": 70,
                  "endLine": 452,
                  "snippet": {
                    "text": "\ndef is_being_called(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if node is the function being called in a Call node.\"\"\"\n    return isinstance(node.parent, nodes.Call) and node.parent.func is node\n\n\ndef assign_parent(node: nodes.NodeNG) -> nodes.NodeNG:\n    \"\"\"Return the higher parent which is not an AssignName, Tuple or List node.\"\"\"\n",
                    "rendered": {
                      "text": "\ndef is_being_called(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if node is the function being called in a Call node.\"\"\"\n    return isinstance(node.parent, nodes.Call) and node.parent.func is node\n\n\ndef assign_parent(node: nodes.NodeNG) -> nodes.NodeNG:\n    \"\"\"Return the higher parent which is not an AssignName, Tuple or List node.\"\"\"\n",
                      "markdown": "`\ndef is_being_called(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if node is the function being called in a Call node.\"\"\"\n    return isinstance(node.parent, nodes.Call) and node.parent.func is node\n\n\ndef assign_parent(node: nodes.NodeNG) -> nodes.NodeNG:\n    \"\"\"Return the higher parent which is not an AssignName, Tuple or List node.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 450,
                  "startColumn": 21,
                  "endLine": 450,
                  "endColumn": 27,
                  "snippet": {
                    "text": "\n\ndef is_being_called(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if node is the function being called in a Call node.\"\"\"\n    return isinstance(node.parent, nodes.Call) and node.parent.func is node\n\n\n",
                    "rendered": {
                      "text": "\n\ndef is_being_called(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if node is the function being called in a Call node.\"\"\"\n    return isinstance(node.parent, nodes.Call) and node.parent.func is node\n\n\n",
                      "markdown": "`\n\ndef is_being_called(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if node is the function being called in a Call node.\"\"\"\n    return isinstance(node.parent, nodes.Call) and node.parent.func is node\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 441,
                  "startColumn": 49,
                  "endLine": 441,
                  "endColumn": 55,
                  "snippet": {
                    "text": "\n\ndef is_ancestor_name(frame: nodes.ClassDef, node: nodes.NodeNG) -> bool:\n    \"\"\"Return whether `frame` is an astroid.Class node with `node` in the\n    subtree of its bases attribute.\n    \"\"\"\n    if not isinstance(frame, nodes.ClassDef):\n",
                    "rendered": {
                      "text": "\n\ndef is_ancestor_name(frame: nodes.ClassDef, node: nodes.NodeNG) -> bool:\n    \"\"\"Return whether `frame` is an astroid.Class node with `node` in the\n    subtree of its bases attribute.\n    \"\"\"\n    if not isinstance(frame, nodes.ClassDef):\n",
                      "markdown": "`\n\ndef is_ancestor_name(frame: nodes.ClassDef, node: nodes.NodeNG) -> bool:\n    \"\"\"Return whether `frame` is an astroid.Class node with `node` in the\n    subtree of its bases attribute.\n    \"\"\"\n    if not isinstance(frame, nodes.ClassDef):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 415,
                  "startColumn": 32,
                  "endLine": 416,
                  "snippet": {
                    "text": "            scope.args.defaults, (d for d in scope.args.kw_defaults if d is not None)\n        )\n        return any(\n            default_name_node is node\n            for default_node in all_defaults\n            for default_name_node in default_node.nodes_of_class(nodes.Name)\n        )\n\n",
                    "rendered": {
                      "text": "            scope.args.defaults, (d for d in scope.args.kw_defaults if d is not None)\n        )\n        return any(\n            default_name_node is node\n            for default_node in all_defaults\n            for default_name_node in default_node.nodes_of_class(nodes.Name)\n        )\n\n",
                      "markdown": "`            scope.args.defaults, (d for d in scope.args.kw_defaults if d is not None)\n        )\n        return any(\n            default_name_node is node\n            for default_node in all_defaults\n            for default_name_node in default_node.nodes_of_class(nodes.Name)\n        )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 405,
                  "startColumn": 36,
                  "endLine": 405,
                  "endColumn": 42,
                  "snippet": {
                    "text": "\n\ndef is_default_argument(node: nodes.NodeNG, scope: nodes.NodeNG | None = None) -> bool:\n    \"\"\"Return true if the given Name node is used in function or lambda\n    default argument's value.\n    \"\"\"\n    if not scope:\n",
                    "rendered": {
                      "text": "\n\ndef is_default_argument(node: nodes.NodeNG, scope: nodes.NodeNG | None = None) -> bool:\n    \"\"\"Return true if the given Name node is used in function or lambda\n    default argument's value.\n    \"\"\"\n    if not scope:\n",
                      "markdown": "`\n\ndef is_default_argument(node: nodes.NodeNG, scope: nodes.NodeNG | None = None) -> bool:\n    \"\"\"Return true if the given Name node is used in function or lambda\n    default argument's value.\n    \"\"\"\n    if not scope:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 352,
                  "startColumn": 28,
                  "endLine": 352,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    Verify that the variable node is defined by a parent node\n    (e.g. if or with) earlier than `var_node`, or is defined by a\n    (list, set, dict, or generator comprehension, lambda)\n    or in a previous sibling node on the same line\n    (statement_defining ; statement_using).\n    \"\"\"\n    varname = var_node.name\n",
                    "rendered": {
                      "text": "    Verify that the variable node is defined by a parent node\n    (e.g. if or with) earlier than `var_node`, or is defined by a\n    (list, set, dict, or generator comprehension, lambda)\n    or in a previous sibling node on the same line\n    (statement_defining ; statement_using).\n    \"\"\"\n    varname = var_node.name\n",
                      "markdown": "`    Verify that the variable node is defined by a parent node\n    (e.g. if or with) earlier than `var_node`, or is defined by a\n    (list, set, dict, or generator comprehension, lambda)\n    or in a previous sibling node on the same line\n    (statement_defining ; statement_using).\n    \"\"\"\n    varname = var_node.name\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 349,
                  "startColumn": 56,
                  "endLine": 350,
                  "snippet": {
                    "text": "def is_defined_before(var_node: nodes.Name) -> bool:\n    \"\"\"Check if the given variable node is defined before.\n\n    Verify that the variable node is defined by a parent node\n    (e.g. if or with) earlier than `var_node`, or is defined by a\n    (list, set, dict, or generator comprehension, lambda)\n    or in a previous sibling node on the same line\n    (statement_defining ; statement_using).\n",
                    "rendered": {
                      "text": "def is_defined_before(var_node: nodes.Name) -> bool:\n    \"\"\"Check if the given variable node is defined before.\n\n    Verify that the variable node is defined by a parent node\n    (e.g. if or with) earlier than `var_node`, or is defined by a\n    (list, set, dict, or generator comprehension, lambda)\n    or in a previous sibling node on the same line\n    (statement_defining ; statement_using).\n",
                      "markdown": "`def is_defined_before(var_node: nodes.Name) -> bool:\n    \"\"\"Check if the given variable node is defined before.\n\n    Verify that the variable node is defined by a parent node\n    (e.g. if or with) earlier than `var_node`, or is defined by a\n    (list, set, dict, or generator comprehension, lambda)\n    or in a previous sibling node on the same line\n    (statement_defining ; statement_using).\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 349,
                  "startColumn": 28,
                  "endLine": 349,
                  "endColumn": 34,
                  "snippet": {
                    "text": "def is_defined_before(var_node: nodes.Name) -> bool:\n    \"\"\"Check if the given variable node is defined before.\n\n    Verify that the variable node is defined by a parent node\n    (e.g. if or with) earlier than `var_node`, or is defined by a\n    (list, set, dict, or generator comprehension, lambda)\n    or in a previous sibling node on the same line\n",
                    "rendered": {
                      "text": "def is_defined_before(var_node: nodes.Name) -> bool:\n    \"\"\"Check if the given variable node is defined before.\n\n    Verify that the variable node is defined by a parent node\n    (e.g. if or with) earlier than `var_node`, or is defined by a\n    (list, set, dict, or generator comprehension, lambda)\n    or in a previous sibling node on the same line\n",
                      "markdown": "`def is_defined_before(var_node: nodes.Name) -> bool:\n    \"\"\"Check if the given variable node is defined before.\n\n    Verify that the variable node is defined by a parent node\n    (e.g. if or with) earlier than `var_node`, or is defined by a\n    (list, set, dict, or generator comprehension, lambda)\n    or in a previous sibling node on the same line\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 347,
                  "startColumn": 34,
                  "endLine": 347,
                  "endColumn": 40,
                  "snippet": {
                    "text": "\n\ndef is_defined_before(var_node: nodes.Name) -> bool:\n    \"\"\"Check if the given variable node is defined before.\n\n    Verify that the variable node is defined by a parent node\n    (e.g. if or with) earlier than `var_node`, or is defined by a\n",
                    "rendered": {
                      "text": "\n\ndef is_defined_before(var_node: nodes.Name) -> bool:\n    \"\"\"Check if the given variable node is defined before.\n\n    Verify that the variable node is defined by a parent node\n    (e.g. if or with) earlier than `var_node`, or is defined by a\n",
                      "markdown": "`\n\ndef is_defined_before(var_node: nodes.Name) -> bool:\n    \"\"\"Check if the given variable node is defined before.\n\n    Verify that the variable node is defined by a parent node\n    (e.g. if or with) earlier than `var_node`, or is defined by a\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 306,
                  "startColumn": 22,
                  "endLine": 307,
                  "snippet": {
                    "text": "    if isinstance(scope, nodes.If):\n        for node in scope.body:\n            if isinstance(node, nodes.Nonlocal) and varname in node.names:\n                return node\n            if isinstance(node, nodes.Assign):\n                for target in node.targets:\n                    if isinstance(target, nodes.AssignName) and target.name == varname:\n                        return target\n",
                    "rendered": {
                      "text": "    if isinstance(scope, nodes.If):\n        for node in scope.body:\n            if isinstance(node, nodes.Nonlocal) and varname in node.names:\n                return node\n            if isinstance(node, nodes.Assign):\n                for target in node.targets:\n                    if isinstance(target, nodes.AssignName) and target.name == varname:\n                        return target\n",
                      "markdown": "`    if isinstance(scope, nodes.If):\n        for node in scope.body:\n            if isinstance(node, nodes.Nonlocal) and varname in node.names:\n                return node\n            if isinstance(node, nodes.Assign):\n                for target in node.targets:\n                    if isinstance(target, nodes.AssignName) and target.name == varname:\n                        return target\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 304,
                  "startColumn": 11,
                  "endLine": 304,
                  "endColumn": 17,
                  "snippet": {
                    "text": "    scope: nodes.NodeNG,\n) -> nodes.NodeNG | None:\n    if isinstance(scope, nodes.If):\n        for node in scope.body:\n            if isinstance(node, nodes.Nonlocal) and varname in node.names:\n                return node\n            if isinstance(node, nodes.Assign):\n",
                    "rendered": {
                      "text": "    scope: nodes.NodeNG,\n) -> nodes.NodeNG | None:\n    if isinstance(scope, nodes.If):\n        for node in scope.body:\n            if isinstance(node, nodes.Nonlocal) and varname in node.names:\n                return node\n            if isinstance(node, nodes.Assign):\n",
                      "markdown": "`    scope: nodes.NodeNG,\n) -> nodes.NodeNG | None:\n    if isinstance(scope, nodes.If):\n        for node in scope.body:\n            if isinstance(node, nodes.Nonlocal) and varname in node.names:\n                return node\n            if isinstance(node, nodes.Assign):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 281,
                  "startColumn": 10,
                  "endLine": 281,
                  "endColumn": 16,
                  "snippet": {
                    "text": "\ndef is_builtin_object(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns True if the given node is an object from the __builtin__ module.\"\"\"\n    return node and node.root().name == \"builtins\"  # type: ignore[no-any-return]\n\n\ndef is_builtin(name: str) -> bool:\n",
                    "rendered": {
                      "text": "\ndef is_builtin_object(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns True if the given node is an object from the __builtin__ module.\"\"\"\n    return node and node.root().name == \"builtins\"  # type: ignore[no-any-return]\n\n\ndef is_builtin(name: str) -> bool:\n",
                      "markdown": "`\ndef is_builtin_object(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns True if the given node is an object from the __builtin__ module.\"\"\"\n    return node and node.root().name == \"builtins\"  # type: ignore[no-any-return]\n\n\ndef is_builtin(name: str) -> bool:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 280,
                  "startColumn": 32,
                  "endLine": 280,
                  "endColumn": 38,
                  "snippet": {
                    "text": "\n\ndef is_builtin_object(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns True if the given node is an object from the __builtin__ module.\"\"\"\n    return node and node.root().name == \"builtins\"  # type: ignore[no-any-return]\n\n\n",
                    "rendered": {
                      "text": "\n\ndef is_builtin_object(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns True if the given node is an object from the __builtin__ module.\"\"\"\n    return node and node.root().name == \"builtins\"  # type: ignore[no-any-return]\n\n\n",
                      "markdown": "`\n\ndef is_builtin_object(node: nodes.NodeNG) -> bool:\n    \"\"\"Returns True if the given node is an object from the __builtin__ module.\"\"\"\n    return node and node.root().name == \"builtins\"  # type: ignore[no-any-return]\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 271,
                  "startColumn": 40,
                  "endLine": 271,
                  "endColumn": 46,
                  "snippet": {
                    "text": "\n\ndef is_error(node: nodes.FunctionDef) -> bool:\n    \"\"\"Return true if the given function node only raises an exception.\"\"\"\n    return len(node.body) == 1 and isinstance(node.body[0], nodes.Raise)\n\n\n",
                    "rendered": {
                      "text": "\n\ndef is_error(node: nodes.FunctionDef) -> bool:\n    \"\"\"Return true if the given function node only raises an exception.\"\"\"\n    return len(node.body) == 1 and isinstance(node.body[0], nodes.Raise)\n\n\n",
                      "markdown": "`\n\ndef is_error(node: nodes.FunctionDef) -> bool:\n    \"\"\"Return true if the given function node only raises an exception.\"\"\"\n    return len(node.body) == 1 and isinstance(node.body[0], nodes.Raise)\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 264,
                  "startColumn": 25,
                  "endLine": 264,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n\ndef is_super(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if the node is referencing the \"super\" builtin function.\"\"\"\n    if getattr(node, \"name\", None) == \"super\" and node.root().name == \"builtins\":\n        return True\n    return False\n",
                    "rendered": {
                      "text": "\n\ndef is_super(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if the node is referencing the \"super\" builtin function.\"\"\"\n    if getattr(node, \"name\", None) == \"super\" and node.root().name == \"builtins\":\n        return True\n    return False\n",
                      "markdown": "`\n\ndef is_super(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if the node is referencing the \"super\" builtin function.\"\"\"\n    if getattr(node, \"name\", None) == \"super\" and node.root().name == \"builtins\":\n        return True\n    return False\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/utils.py"
                },
                "region": {
                  "startLine": 260,
                  "startColumn": 13,
                  "endLine": 261,
                  "snippet": {
                    "text": "        for child in node.elts:\n            yield from get_all_elements(child)\n    else:\n        yield node\n\n\ndef is_super(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if the node is referencing the \"super\" builtin function.\"\"\"\n",
                    "rendered": {
                      "text": "        for child in node.elts:\n            yield from get_all_elements(child)\n    else:\n        yield node\n\n\ndef is_super(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if the node is referencing the \"super\" builtin function.\"\"\"\n",
                      "markdown": "`        for child in node.elts:\n            yield from get_all_elements(child)\n    else:\n        yield node\n\n\ndef is_super(node: nodes.NodeNG) -> bool:\n    \"\"\"Return True if the node is referencing the \"super\" builtin function.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/name_checker/checker.py"
                },
                "region": {
                  "startLine": 510,
                  "startColumn": 31,
                  "endLine": 510,
                  "endColumn": 36,
                  "snippet": {
                    "text": "            self._check_name(\"argument\", arg.name, arg)\n\n    def _find_name_group(self, node_type: str) -> str:\n        return self._name_group.get(node_type, node_type)\n\n    def _raise_name_warning(\n        self,\n",
                    "rendered": {
                      "text": "            self._check_name(\"argument\", arg.name, arg)\n\n    def _find_name_group(self, node_type: str) -> str:\n        return self._name_group.get(node_type, node_type)\n\n    def _raise_name_warning(\n        self,\n",
                      "markdown": "`            self._check_name(\"argument\", arg.name, arg)\n\n    def _find_name_group(self, node_type: str) -> str:\n        return self._name_group.get(node_type, node_type)\n\n    def _raise_name_warning(\n        self,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/name_checker/checker.py"
                },
                "region": {
                  "startLine": 618,
                  "startColumn": 22,
                  "endLine": 618,
                  "endColumn": 28,
                  "snippet": {
                    "text": "            if qname == \".Union\":\n                # Union is a special case because it can be used as a type alias\n                # or as a type annotation. We only want to check the former.\n                assert node is not None\n                return not isinstance(node.parent, nodes.AnnAssign)\n        elif isinstance(inferred, nodes.FunctionDef):\n            # TODO: when py3.12 is minimum, remove this condition\n",
                    "rendered": {
                      "text": "            if qname == \".Union\":\n                # Union is a special case because it can be used as a type alias\n                # or as a type annotation. We only want to check the former.\n                assert node is not None\n                return not isinstance(node.parent, nodes.AnnAssign)\n        elif isinstance(inferred, nodes.FunctionDef):\n            # TODO: when py3.12 is minimum, remove this condition\n",
                      "markdown": "`            if qname == \".Union\":\n                # Union is a special case because it can be used as a type alias\n                # or as a type annotation. We only want to check the former.\n                assert node is not None\n                return not isinstance(node.parent, nodes.AnnAssign)\n        elif isinstance(inferred, nodes.FunctionDef):\n            # TODO: when py3.12 is minimum, remove this condition\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/name_checker/checker.py"
                },
                "region": {
                  "startLine": 609,
                  "startColumn": 21,
                  "endLine": 609,
                  "endColumn": 27,
                  "snippet": {
                    "text": "\n    @staticmethod\n    def _assigns_typealias(node: nodes.NodeNG | None) -> bool:\n        \"\"\"Check if a node is assigning a TypeAlias.\"\"\"\n        inferred = utils.safe_infer(node)\n        if isinstance(inferred, nodes.ClassDef):\n            qname = inferred.qname()\n",
                    "rendered": {
                      "text": "\n    @staticmethod\n    def _assigns_typealias(node: nodes.NodeNG | None) -> bool:\n        \"\"\"Check if a node is assigning a TypeAlias.\"\"\"\n        inferred = utils.safe_infer(node)\n        if isinstance(inferred, nodes.ClassDef):\n            qname = inferred.qname()\n",
                      "markdown": "`\n    @staticmethod\n    def _assigns_typealias(node: nodes.NodeNG | None) -> bool:\n        \"\"\"Check if a node is assigning a TypeAlias.\"\"\"\n        inferred = utils.safe_infer(node)\n        if isinstance(inferred, nodes.ClassDef):\n            qname = inferred.qname()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/name_checker/checker.py"
                },
                "region": {
                  "startLine": 597,
                  "startColumn": 21,
                  "endLine": 597,
                  "endColumn": 27,
                  "snippet": {
                    "text": "\n    @staticmethod\n    def _assigns_typevar(node: nodes.NodeNG | None) -> bool:\n        \"\"\"Check if a node is assigning a TypeVar.\"\"\"\n        if isinstance(node, astroid.Call):\n            inferred = utils.safe_infer(node.func)\n            if (\n",
                    "rendered": {
                      "text": "\n    @staticmethod\n    def _assigns_typevar(node: nodes.NodeNG | None) -> bool:\n        \"\"\"Check if a node is assigning a TypeVar.\"\"\"\n        if isinstance(node, astroid.Call):\n            inferred = utils.safe_infer(node.func)\n            if (\n",
                      "markdown": "`\n    @staticmethod\n    def _assigns_typevar(node: nodes.NodeNG | None) -> bool:\n        \"\"\"Check if a node is assigning a TypeVar.\"\"\"\n        if isinstance(node, astroid.Call):\n            inferred = utils.safe_infer(node.func)\n            if (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/name_checker/checker.py"
                },
                "region": {
                  "startLine": 88,
                  "startColumn": 13,
                  "endLine": 89,
                  "snippet": {
                    "text": "\n    Returns True if the node redefines an import, False otherwise.\n    \"\"\"\n    current = node\n    while current and not isinstance(current.parent, nodes.ExceptHandler):\n        current = current.parent\n    if not current or not utils.error_of_type(current.parent, ImportError):\n        return False\n",
                    "rendered": {
                      "text": "\n    Returns True if the node redefines an import, False otherwise.\n    \"\"\"\n    current = node\n    while current and not isinstance(current.parent, nodes.ExceptHandler):\n        current = current.parent\n    if not current or not utils.error_of_type(current.parent, ImportError):\n        return False\n",
                      "markdown": "`\n    Returns True if the node redefines an import, False otherwise.\n    \"\"\"\n    current = node\n    while current and not isinstance(current.parent, nodes.ExceptHandler):\n        current = current.parent\n    if not current or not utils.error_of_type(current.parent, ImportError):\n        return False\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/name_checker/checker.py"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 23,
                  "endLine": 86,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    \"\"\"Detect that the given node (AssignName) is inside an\n    exception handler and redefines an import from the tryexcept body.\n\n    Returns True if the node redefines an import, False otherwise.\n    \"\"\"\n    current = node\n    while current and not isinstance(current.parent, nodes.ExceptHandler):\n",
                    "rendered": {
                      "text": "    \"\"\"Detect that the given node (AssignName) is inside an\n    exception handler and redefines an import from the tryexcept body.\n\n    Returns True if the node redefines an import, False otherwise.\n    \"\"\"\n    current = node\n    while current and not isinstance(current.parent, nodes.ExceptHandler):\n",
                      "markdown": "`    \"\"\"Detect that the given node (AssignName) is inside an\n    exception handler and redefines an import from the tryexcept body.\n\n    Returns True if the node redefines an import, False otherwise.\n    \"\"\"\n    current = node\n    while current and not isinstance(current.parent, nodes.ExceptHandler):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/name_checker/checker.py"
                },
                "region": {
                  "startLine": 83,
                  "startColumn": 28,
                  "endLine": 83,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\n\ndef _redefines_import(node: nodes.AssignName) -> bool:\n    \"\"\"Detect that the given node (AssignName) is inside an\n    exception handler and redefines an import from the tryexcept body.\n\n    Returns True if the node redefines an import, False otherwise.\n",
                    "rendered": {
                      "text": "\n\ndef _redefines_import(node: nodes.AssignName) -> bool:\n    \"\"\"Detect that the given node (AssignName) is inside an\n    exception handler and redefines an import from the tryexcept body.\n\n    Returns True if the node redefines an import, False otherwise.\n",
                      "markdown": "`\n\ndef _redefines_import(node: nodes.AssignName) -> bool:\n    \"\"\"Detect that the given node (AssignName) is inside an\n    exception handler and redefines an import from the tryexcept body.\n\n    Returns True if the node redefines an import, False otherwise.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/unicode.py"
                },
                "region": {
                  "startLine": 447,
                  "startColumn": 62,
                  "endLine": 447,
                  "endColumn": 66,
                  "snippet": {
                    "text": "            codec_definition_line = len(lines) or 1\n        except SyntaxError as e:\n            # Codec could not be detected by Python, we try manually to check for\n            # UTF 16/32 BOMs, which aren't supported by Python at the time of writing.\n            # This is only included to be future save and handle these codecs as well\n            stream.seek(0)\n            try:\n",
                    "rendered": {
                      "text": "            codec_definition_line = len(lines) or 1\n        except SyntaxError as e:\n            # Codec could not be detected by Python, we try manually to check for\n            # UTF 16/32 BOMs, which aren't supported by Python at the time of writing.\n            # This is only included to be future save and handle these codecs as well\n            stream.seek(0)\n            try:\n",
                      "markdown": "`            codec_definition_line = len(lines) or 1\n        except SyntaxError as e:\n            # Codec could not be detected by Python, we try manually to check for\n            # UTF 16/32 BOMs, which aren't supported by Python at the time of writing.\n            # This is only included to be future save and handle these codecs as well\n            stream.seek(0)\n            try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/unicode.py"
                },
                "region": {
                  "startLine": 439,
                  "startColumn": 41,
                  "endLine": 439,
                  "endColumn": 45,
                  "snippet": {
                    "text": "        \"\"\"\n        try:\n            # First try to detect encoding with PEP 263\n            # Doesn't work with UTF-16/32 at the time of writing\n            # see https://bugs.python.org/issue1503789\n            codec, lines = detect_encoding(stream.readline)\n\n",
                    "rendered": {
                      "text": "        \"\"\"\n        try:\n            # First try to detect encoding with PEP 263\n            # Doesn't work with UTF-16/32 at the time of writing\n            # see https://bugs.python.org/issue1503789\n            codec, lines = detect_encoding(stream.readline)\n\n",
                      "markdown": "`        \"\"\"\n        try:\n            # First try to detect encoding with PEP 263\n            # Doesn't work with UTF-16/32 at the time of writing\n            # see https://bugs.python.org/issue1503789\n            codec, lines = detect_encoding(stream.readline)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/unicode.py"
                },
                "region": {
                  "startLine": 338,
                  "startColumn": 25,
                  "endLine": 338,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        ),\n        \"E2502\": (\n            (\n                \"Contains control characters that can permit obfuscated code \"\n                \"executed differently than displayed\"\n            ),\n            \"bidirectional-unicode\",\n",
                    "rendered": {
                      "text": "        ),\n        \"E2502\": (\n            (\n                \"Contains control characters that can permit obfuscated code \"\n                \"executed differently than displayed\"\n            ),\n            \"bidirectional-unicode\",\n",
                      "markdown": "`        ),\n        \"E2502\": (\n            (\n                \"Contains control characters that can permit obfuscated code \"\n                \"executed differently than displayed\"\n            ),\n            \"bidirectional-unicode\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/unicode.py"
                },
                "region": {
                  "startLine": 325,
                  "startColumn": 31,
                  "endLine": 325,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    msgs = {\n        \"E2501\": (\n            # This error will be only displayed to users once Python Supports\n            # UTF-16/UTF-32 (if at all)\n            \"UTF-16 and UTF-32 aren't backward compatible. Use UTF-8 instead\",\n            \"invalid-unicode-codec\",\n            (\n",
                    "rendered": {
                      "text": "    msgs = {\n        \"E2501\": (\n            # This error will be only displayed to users once Python Supports\n            # UTF-16/UTF-32 (if at all)\n            \"UTF-16 and UTF-32 aren't backward compatible. Use UTF-8 instead\",\n            \"invalid-unicode-codec\",\n            (\n",
                      "markdown": "`    msgs = {\n        \"E2501\": (\n            # This error will be only displayed to users once Python Supports\n            # UTF-16/UTF-32 (if at all)\n            \"UTF-16 and UTF-32 aren't backward compatible. Use UTF-8 instead\",\n            \"invalid-unicode-codec\",\n            (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/unicode.py"
                },
                "region": {
                  "startLine": 315,
                  "startColumn": 3,
                  "endLine": 315,
                  "endColumn": 7,
                  "snippet": {
                    "text": "    The Checker also includes a check that UTF-16 and UTF-32 are not used to encode\n    Python files.\n\n    At the time of writing Python supported only UTF-8. See\n    https://stackoverflow.com/questions/69897842/ and https://bugs.python.org/issue1503789\n    for background.\n    \"\"\"\n",
                    "rendered": {
                      "text": "    The Checker also includes a check that UTF-16 and UTF-32 are not used to encode\n    Python files.\n\n    At the time of writing Python supported only UTF-8. See\n    https://stackoverflow.com/questions/69897842/ and https://bugs.python.org/issue1503789\n    for background.\n    \"\"\"\n",
                      "markdown": "`    The Checker also includes a check that UTF-16 and UTF-32 are not used to encode\n    Python files.\n\n    At the time of writing Python supported only UTF-8. See\n    https://stackoverflow.com/questions/69897842/ and https://bugs.python.org/issue1503789\n    for background.\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/unicode.py"
                },
                "region": {
                  "startLine": 129,
                  "startColumn": 32,
                  "endLine": 129,
                  "endColumn": 36,
                  "snippet": {
                    "text": "        \"Mostly end of input for python.\",\n    ),\n    _BadChar(\n        # Zero Width with Space. At the time of writing not accepted by Python.\n        # But used in Trojan Source Examples, so still included and tested for.\n        \"zero-width-space\",\n        \"\\u200B\",  # \\n{ZERO WIDTH SPACE}\n",
                    "rendered": {
                      "text": "        \"Mostly end of input for python.\",\n    ),\n    _BadChar(\n        # Zero Width with Space. At the time of writing not accepted by Python.\n        # But used in Trojan Source Examples, so still included and tested for.\n        \"zero-width-space\",\n        \"\\u200B\",  # \\n{ZERO WIDTH SPACE}\n",
                      "markdown": "`        \"Mostly end of input for python.\",\n    ),\n    _BadChar(\n        # Zero Width with Space. At the time of writing not accepted by Python.\n        # But used in Trojan Source Examples, so still included and tested for.\n        \"zero-width-space\",\n        \"\\u200B\",  # \\n{ZERO WIDTH SPACE}\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/unicode.py"
                },
                "region": {
                  "startLine": 117,
                  "startColumn": 66,
                  "endLine": 117,
                  "endColumn": 75,
                  "snippet": {
                    "text": "        \"\\\\x1B\",\n        \"E2513\",\n        (\n            \"Commonly initiates escape codes which allow arbitrary control \"\n            \"of the terminal.\"\n        ),\n    ),\n",
                    "rendered": {
                      "text": "        \"\\\\x1B\",\n        \"E2513\",\n        (\n            \"Commonly initiates escape codes which allow arbitrary control \"\n            \"of the terminal.\"\n        ),\n    ),\n",
                      "markdown": "`        \"\\\\x1B\",\n        \"E2513\",\n        (\n            \"Commonly initiates escape codes which allow arbitrary control \"\n            \"of the terminal.\"\n        ),\n    ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/unicode.py"
                },
                "region": {
                  "startLine": 447,
                  "startColumn": 69,
                  "endLine": 447,
                  "endColumn": 75,
                  "snippet": {
                    "text": "            codec_definition_line = len(lines) or 1\n        except SyntaxError as e:\n            # Codec could not be detected by Python, we try manually to check for\n            # UTF 16/32 BOMs, which aren't supported by Python at the time of writing.\n            # This is only included to be future save and handle these codecs as well\n            stream.seek(0)\n            try:\n",
                    "rendered": {
                      "text": "            codec_definition_line = len(lines) or 1\n        except SyntaxError as e:\n            # Codec could not be detected by Python, we try manually to check for\n            # UTF 16/32 BOMs, which aren't supported by Python at the time of writing.\n            # This is only included to be future save and handle these codecs as well\n            stream.seek(0)\n            try:\n",
                      "markdown": "`            codec_definition_line = len(lines) or 1\n        except SyntaxError as e:\n            # Codec could not be detected by Python, we try manually to check for\n            # UTF 16/32 BOMs, which aren't supported by Python at the time of writing.\n            # This is only included to be future save and handle these codecs as well\n            stream.seek(0)\n            try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/unicode.py"
                },
                "region": {
                  "startLine": 439,
                  "startColumn": 48,
                  "endLine": 439,
                  "endColumn": 54,
                  "snippet": {
                    "text": "        \"\"\"\n        try:\n            # First try to detect encoding with PEP 263\n            # Doesn't work with UTF-16/32 at the time of writing\n            # see https://bugs.python.org/issue1503789\n            codec, lines = detect_encoding(stream.readline)\n\n",
                    "rendered": {
                      "text": "        \"\"\"\n        try:\n            # First try to detect encoding with PEP 263\n            # Doesn't work with UTF-16/32 at the time of writing\n            # see https://bugs.python.org/issue1503789\n            codec, lines = detect_encoding(stream.readline)\n\n",
                      "markdown": "`        \"\"\"\n        try:\n            # First try to detect encoding with PEP 263\n            # Doesn't work with UTF-16/32 at the time of writing\n            # see https://bugs.python.org/issue1503789\n            codec, lines = detect_encoding(stream.readline)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/unicode.py"
                },
                "region": {
                  "startLine": 344,
                  "startColumn": 47,
                  "endLine": 344,
                  "endColumn": 55,
                  "snippet": {
                    "text": "            \"bidirectional-unicode\",\n            (\n                \"bidirectional unicode are typically not displayed characters required \"\n                \"to display right-to-left (RTL) script \"\n                \"(i.e. Chinese, Japanese, Arabic, Hebrew, ...) correctly. \"\n                \"So can you trust this code? \"\n                \"Are you sure it displayed correctly in all editors? \"\n",
                    "rendered": {
                      "text": "            \"bidirectional-unicode\",\n            (\n                \"bidirectional unicode are typically not displayed characters required \"\n                \"to display right-to-left (RTL) script \"\n                \"(i.e. Chinese, Japanese, Arabic, Hebrew, ...) correctly. \"\n                \"So can you trust this code? \"\n                \"Are you sure it displayed correctly in all editors? \"\n",
                      "markdown": "`            \"bidirectional-unicode\",\n            (\n                \"bidirectional unicode are typically not displayed characters required \"\n                \"to display right-to-left (RTL) script \"\n                \"(i.e. Chinese, Japanese, Arabic, Hebrew, ...) correctly. \"\n                \"So can you trust this code? \"\n                \"Are you sure it displayed correctly in all editors? \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/unicode.py"
                },
                "region": {
                  "startLine": 315,
                  "startColumn": 10,
                  "endLine": 315,
                  "endColumn": 16,
                  "snippet": {
                    "text": "    The Checker also includes a check that UTF-16 and UTF-32 are not used to encode\n    Python files.\n\n    At the time of writing Python supported only UTF-8. See\n    https://stackoverflow.com/questions/69897842/ and https://bugs.python.org/issue1503789\n    for background.\n    \"\"\"\n",
                    "rendered": {
                      "text": "    The Checker also includes a check that UTF-16 and UTF-32 are not used to encode\n    Python files.\n\n    At the time of writing Python supported only UTF-8. See\n    https://stackoverflow.com/questions/69897842/ and https://bugs.python.org/issue1503789\n    for background.\n    \"\"\"\n",
                      "markdown": "`    The Checker also includes a check that UTF-16 and UTF-32 are not used to encode\n    Python files.\n\n    At the time of writing Python supported only UTF-8. See\n    https://stackoverflow.com/questions/69897842/ and https://bugs.python.org/issue1503789\n    for background.\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/unicode.py"
                },
                "region": {
                  "startLine": 129,
                  "startColumn": 39,
                  "endLine": 129,
                  "endColumn": 45,
                  "snippet": {
                    "text": "        \"Mostly end of input for python.\",\n    ),\n    _BadChar(\n        # Zero Width with Space. At the time of writing not accepted by Python.\n        # But used in Trojan Source Examples, so still included and tested for.\n        \"zero-width-space\",\n        \"\\u200B\",  # \\n{ZERO WIDTH SPACE}\n",
                    "rendered": {
                      "text": "        \"Mostly end of input for python.\",\n    ),\n    _BadChar(\n        # Zero Width with Space. At the time of writing not accepted by Python.\n        # But used in Trojan Source Examples, so still included and tested for.\n        \"zero-width-space\",\n        \"\\u200B\",  # \\n{ZERO WIDTH SPACE}\n",
                      "markdown": "`        \"Mostly end of input for python.\",\n    ),\n    _BadChar(\n        # Zero Width with Space. At the time of writing not accepted by Python.\n        # But used in Trojan Source Examples, so still included and tested for.\n        \"zero-width-space\",\n        \"\\u200B\",  # \\n{ZERO WIDTH SPACE}\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/unicode.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 52,
                  "endLine": 6,
                  "endColumn": 60,
                  "snippet": {
                    "text": "# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Unicode and some other ASCII characters can be used to create programs that run\nmuch different compared to what a human reader would expect from them.\n\nPEP 672 lists some examples.\nSee: https://www.python.org/dev/peps/pep-0672/\n",
                    "rendered": {
                      "text": "# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Unicode and some other ASCII characters can be used to create programs that run\nmuch different compared to what a human reader would expect from them.\n\nPEP 672 lists some examples.\nSee: https://www.python.org/dev/peps/pep-0672/\n",
                      "markdown": "`# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Unicode and some other ASCII characters can be used to create programs that run\nmuch different compared to what a human reader would expect from them.\n\nPEP 672 lists some examples.\nSee: https://www.python.org/dev/peps/pep-0672/\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 1306,
                  "startColumn": 44,
                  "endLine": 1306,
                  "endColumn": 49,
                  "snippet": {
                    "text": "            and bool(inferred := utils.safe_infer(node.value.func.expr))\n            and isinstance(inferred, bases.Instance)\n            and node.value.func.attrname\n            in BUILTINS_IMPLICIT_RETURN_NONE.get(inferred.pytype(), ())\n        )\n\n    def _check_dundername_is_string(self, node: nodes.Assign) -> None:\n",
                    "rendered": {
                      "text": "            and bool(inferred := utils.safe_infer(node.value.func.expr))\n            and isinstance(inferred, bases.Instance)\n            and node.value.func.attrname\n            in BUILTINS_IMPLICIT_RETURN_NONE.get(inferred.pytype(), ())\n        )\n\n    def _check_dundername_is_string(self, node: nodes.Assign) -> None:\n",
                      "markdown": "`            and bool(inferred := utils.safe_infer(node.value.func.expr))\n            and isinstance(inferred, bases.Instance)\n            and node.value.func.attrname\n            in BUILTINS_IMPLICIT_RETURN_NONE.get(inferred.pytype(), ())\n        )\n\n    def _check_dundername_is_string(self, node: nodes.Assign) -> None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 706,
                  "startColumn": 46,
                  "endLine": 706,
                  "endColumn": 50,
                  "snippet": {
                    "text": "    \"\"\"Verify if the given call node has variadic nodes without context.\n\n    This is a workaround for handling cases of nested call functions\n    which don't have the specific call context at hand.\n    Variadic arguments (variable positional arguments and variable\n    keyword arguments) are inferred, inherently wrong, by astroid\n    as a Tuple, respectively a Dict with empty elements.\n",
                    "rendered": {
                      "text": "    \"\"\"Verify if the given call node has variadic nodes without context.\n\n    This is a workaround for handling cases of nested call functions\n    which don't have the specific call context at hand.\n    Variadic arguments (variable positional arguments and variable\n    keyword arguments) are inferred, inherently wrong, by astroid\n    as a Tuple, respectively a Dict with empty elements.\n",
                      "markdown": "`    \"\"\"Verify if the given call node has variadic nodes without context.\n\n    This is a workaround for handling cases of nested call functions\n    which don't have the specific call context at hand.\n    Variadic arguments (variable positional arguments and variable\n    keyword arguments) are inferred, inherently wrong, by astroid\n    as a Tuple, respectively a Dict with empty elements.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 477,
                  "startColumn": 9,
                  "endLine": 477,
                  "endColumn": 13,
                  "snippet": {
                    "text": "            return False\n\n        # Exclude typed annotations, since these might actually exist\n        # at some point during the runtime of the program.\n        if utils.is_attribute_typed_annotation(owner, node.attrname):\n            return False\n    if isinstance(owner, astroid.objects.Super):\n",
                    "rendered": {
                      "text": "            return False\n\n        # Exclude typed annotations, since these might actually exist\n        # at some point during the runtime of the program.\n        if utils.is_attribute_typed_annotation(owner, node.attrname):\n            return False\n    if isinstance(owner, astroid.objects.Super):\n",
                      "markdown": "`            return False\n\n        # Exclude typed annotations, since these might actually exist\n        # at some point during the runtime of the program.\n        if utils.is_attribute_typed_annotation(owner, node.attrname):\n            return False\n    if isinstance(owner, astroid.objects.Super):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 462,
                  "startColumn": 17,
                  "endLine": 462,
                  "endColumn": 21,
                  "snippet": {
                    "text": "        return False\n    if isinstance(owner, (astroid.Instance, nodes.ClassDef)):\n        # Issue #2565: Don't ignore enums, as they have a `__getattr__` but it's not\n        # invoked at this point.\n        try:\n            metaclass = owner.metaclass()\n        except astroid.MroError:\n",
                    "rendered": {
                      "text": "        return False\n    if isinstance(owner, (astroid.Instance, nodes.ClassDef)):\n        # Issue #2565: Don't ignore enums, as they have a `__getattr__` but it's not\n        # invoked at this point.\n        try:\n            metaclass = owner.metaclass()\n        except astroid.MroError:\n",
                      "markdown": "`        return False\n    if isinstance(owner, (astroid.Instance, nodes.ClassDef)):\n        # Issue #2565: Don't ignore enums, as they have a `__getattr__` but it's not\n        # invoked at this point.\n        try:\n            metaclass = owner.metaclass()\n        except astroid.MroError:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 2027,
                  "startColumn": 33,
                  "endLine": 2027,
                  "endColumn": 39,
                  "snippet": {
                    "text": "        return True\n\n    def _check_unsupported_alternative_union_syntax(self, node: nodes.BinOp) -> None:\n        \"\"\"Check if left or right node is of type `type`.\n\n        If either is, and doesn't support an or operator via a metaclass,\n        infer that this is a mistaken attempt to use alternative union\n",
                    "rendered": {
                      "text": "        return True\n\n    def _check_unsupported_alternative_union_syntax(self, node: nodes.BinOp) -> None:\n        \"\"\"Check if left or right node is of type `type`.\n\n        If either is, and doesn't support an or operator via a metaclass,\n        infer that this is a mistaken attempt to use alternative union\n",
                      "markdown": "`        return True\n\n    def _check_unsupported_alternative_union_syntax(self, node: nodes.BinOp) -> None:\n        \"\"\"Check if left or right node is of type `type`.\n\n        If either is, and doesn't support an or operator via a metaclass,\n        infer that this is a mistaken attempt to use alternative union\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 1983,
                  "startColumn": 35,
                  "endLine": 1983,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        ):\n            # Check other contexts the syntax might appear, but are invalid.\n            # Make sure to filter context if postponed evaluation is enabled\n            # and parent is allowed node type.\n            allowed_nested_syntax = False\n            if is_postponed_evaluation_enabled(node):\n                parent_node = node.parent\n",
                    "rendered": {
                      "text": "        ):\n            # Check other contexts the syntax might appear, but are invalid.\n            # Make sure to filter context if postponed evaluation is enabled\n            # and parent is allowed node type.\n            allowed_nested_syntax = False\n            if is_postponed_evaluation_enabled(node):\n                parent_node = node.parent\n",
                      "markdown": "`        ):\n            # Check other contexts the syntax might appear, but are invalid.\n            # Make sure to filter context if postponed evaluation is enabled\n            # and parent is allowed node type.\n            allowed_nested_syntax = False\n            if is_postponed_evaluation_enabled(node):\n                parent_node = node.parent\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 1903,
                  "startColumn": 26,
                  "endLine": 1903,
                  "endColumn": 32,
                  "snippet": {
                    "text": "                # See the test file for not_context_manager for a couple\n                # of self explaining tests.\n\n                # Retrieve node from all previously visited nodes in the\n                # inference history\n                for inferred_path, _ in context.path:\n                    if not inferred_path:\n",
                    "rendered": {
                      "text": "                # See the test file for not_context_manager for a couple\n                # of self explaining tests.\n\n                # Retrieve node from all previously visited nodes in the\n                # inference history\n                for inferred_path, _ in context.path:\n                    if not inferred_path:\n",
                      "markdown": "`                # See the test file for not_context_manager for a couple\n                # of self explaining tests.\n\n                # Retrieve node from all previously visited nodes in the\n                # inference history\n                for inferred_path, _ in context.path:\n                    if not inferred_path:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 1897,
                  "startColumn": 44,
                  "endLine": 1897,
                  "endColumn": 50,
                  "snippet": {
                    "text": "                # function which was the real context manager.\n                # The following approach is more of a hack rather than a real\n                # solution: walk all the inferred statements for the\n                # given *ctx_mgr* and if you find one function scope\n                # which is decorated, consider it to be the real\n                # manager and give up, otherwise emit not-context-manager.\n                # See the test file for not_context_manager for a couple\n",
                    "rendered": {
                      "text": "                # function which was the real context manager.\n                # The following approach is more of a hack rather than a real\n                # solution: walk all the inferred statements for the\n                # given *ctx_mgr* and if you find one function scope\n                # which is decorated, consider it to be the real\n                # manager and give up, otherwise emit not-context-manager.\n                # See the test file for not_context_manager for a couple\n",
                      "markdown": "`                # function which was the real context manager.\n                # The following approach is more of a hack rather than a real\n                # solution: walk all the inferred statements for the\n                # given *ctx_mgr* and if you find one function scope\n                # which is decorated, consider it to be the real\n                # manager and give up, otherwise emit not-context-manager.\n                # See the test file for not_context_manager for a couple\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 1726,
                  "startColumn": 9,
                  "endLine": 1726,
                  "endColumn": 15,
                  "snippet": {
                    "text": "\n        # Determine what method on the parent this index will use\n        # The parent of this node will be a Subscript, and the parent of that\n        # node determines if the Subscript is a get, set, or delete operation.\n        if subscript.ctx is astroid.Context.Store:\n            methodname = \"__setitem__\"\n        elif subscript.ctx is astroid.Context.Del:\n",
                    "rendered": {
                      "text": "\n        # Determine what method on the parent this index will use\n        # The parent of this node will be a Subscript, and the parent of that\n        # node determines if the Subscript is a get, set, or delete operation.\n        if subscript.ctx is astroid.Context.Store:\n            methodname = \"__setitem__\"\n        elif subscript.ctx is astroid.Context.Del:\n",
                      "markdown": "`\n        # Determine what method on the parent this index will use\n        # The parent of this node will be a Subscript, and the parent of that\n        # node determines if the Subscript is a get, set, or delete operation.\n        if subscript.ctx is astroid.Context.Store:\n            methodname = \"__setitem__\"\n        elif subscript.ctx is astroid.Context.Del:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 1725,
                  "startColumn": 28,
                  "endLine": 1725,
                  "endColumn": 34,
                  "snippet": {
                    "text": "            return None\n\n        # Determine what method on the parent this index will use\n        # The parent of this node will be a Subscript, and the parent of that\n        # node determines if the Subscript is a get, set, or delete operation.\n        if subscript.ctx is astroid.Context.Store:\n            methodname = \"__setitem__\"\n",
                    "rendered": {
                      "text": "            return None\n\n        # Determine what method on the parent this index will use\n        # The parent of this node will be a Subscript, and the parent of that\n        # node determines if the Subscript is a get, set, or delete operation.\n        if subscript.ctx is astroid.Context.Store:\n            methodname = \"__setitem__\"\n",
                      "markdown": "`            return None\n\n        # Determine what method on the parent this index will use\n        # The parent of this node will be a Subscript, and the parent of that\n        # node determines if the Subscript is a get, set, or delete operation.\n        if subscript.ctx is astroid.Context.Store:\n            methodname = \"__setitem__\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 1337,
                  "startColumn": 34,
                  "endLine": 1337,
                  "endColumn": 40,
                  "snippet": {
                    "text": "            return\n\n        # Look for properties. First, obtain\n        # the lhs of the Attribute node and search the attribute\n        # there. If that attribute is a property or a subclass of properties,\n        # then most likely it's not callable.\n\n",
                    "rendered": {
                      "text": "            return\n\n        # Look for properties. First, obtain\n        # the lhs of the Attribute node and search the attribute\n        # there. If that attribute is a property or a subclass of properties,\n        # then most likely it's not callable.\n\n",
                      "markdown": "`            return\n\n        # Look for properties. First, obtain\n        # the lhs of the Attribute node and search the attribute\n        # there. If that attribute is a property or a subclass of properties,\n        # then most likely it's not callable.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 1330,
                  "startColumn": 48,
                  "endLine": 1330,
                  "endColumn": 54,
                  "snippet": {
                    "text": "            self.add_message(\"non-str-assignment-to-dunder-name\", node=node)\n\n    def _check_uninferable_call(self, node: nodes.Call) -> None:\n        \"\"\"Check that the given uninferable Call node does not\n        call an actual function.\n        \"\"\"\n        if not isinstance(node.func, nodes.Attribute):\n",
                    "rendered": {
                      "text": "            self.add_message(\"non-str-assignment-to-dunder-name\", node=node)\n\n    def _check_uninferable_call(self, node: nodes.Call) -> None:\n        \"\"\"Check that the given uninferable Call node does not\n        call an actual function.\n        \"\"\"\n        if not isinstance(node.func, nodes.Attribute):\n",
                      "markdown": "`            self.add_message(\"non-str-assignment-to-dunder-name\", node=node)\n\n    def _check_uninferable_call(self, node: nodes.Call) -> None:\n        \"\"\"Check that the given uninferable Call node does not\n        call an actual function.\n        \"\"\"\n        if not isinstance(node.func, nodes.Attribute):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 1246,
                  "startColumn": 43,
                  "endLine": 1246,
                  "endColumn": 49,
                  "snippet": {
                    "text": "        if not isinstance(function_node, funcs):\n            return\n\n        # Unwrap to get the actual function node object\n        if isinstance(function_node, astroid.BoundMethod) and isinstance(\n            function_node._proxied, astroid.UnboundMethod\n        ):\n",
                    "rendered": {
                      "text": "        if not isinstance(function_node, funcs):\n            return\n\n        # Unwrap to get the actual function node object\n        if isinstance(function_node, astroid.BoundMethod) and isinstance(\n            function_node._proxied, astroid.UnboundMethod\n        ):\n",
                      "markdown": "`        if not isinstance(function_node, funcs):\n            return\n\n        # Unwrap to get the actual function node object\n        if isinstance(function_node, astroid.BoundMethod) and isinstance(\n            function_node._proxied, astroid.UnboundMethod\n        ):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 1180,
                  "startColumn": 35,
                  "endLine": 1180,
                  "endColumn": 41,
                  "snippet": {
                    "text": "            # stop on the first found\n            break\n        else:\n            # we have not found any node with the attributes, display the\n            # message for inferred nodes\n            done = set()\n            for owner, name in missingattr:\n",
                    "rendered": {
                      "text": "            # stop on the first found\n            break\n        else:\n            # we have not found any node with the attributes, display the\n            # message for inferred nodes\n            done = set()\n            for owner, name in missingattr:\n",
                      "markdown": "`            # stop on the first found\n            break\n        else:\n            # we have not found any node with the attributes, display the\n            # message for inferred nodes\n            done = set()\n            for owner, name in missingattr:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 1084,
                  "startColumn": 11,
                  "endLine": 1085,
                  "snippet": {
                    "text": "            return\n\n        if is_postponed_evaluation_enabled(node) and is_node_in_type_annotation_context(\n            node\n        ):\n            return\n\n        try:\n",
                    "rendered": {
                      "text": "            return\n\n        if is_postponed_evaluation_enabled(node) and is_node_in_type_annotation_context(\n            node\n        ):\n            return\n\n        try:\n",
                      "markdown": "`            return\n\n        if is_postponed_evaluation_enabled(node) and is_node_in_type_annotation_context(\n            node\n        ):\n            return\n\n        try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 833,
                  "startColumn": 13,
                  "endLine": 833,
                  "endColumn": 19,
                  "snippet": {
                    "text": "\n\nclass TypeChecker(BaseChecker):\n    \"\"\"Try to find bugs in the code using type inference.\"\"\"\n\n    # configuration section name\n    name = \"typecheck\"\n",
                    "rendered": {
                      "text": "\n\nclass TypeChecker(BaseChecker):\n    \"\"\"Try to find bugs in the code using type inference.\"\"\"\n\n    # configuration section name\n    name = \"typecheck\"\n",
                      "markdown": "`\n\nclass TypeChecker(BaseChecker):\n    \"\"\"Try to find bugs in the code using type inference.\"\"\"\n\n    # configuration section name\n    name = \"typecheck\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 703,
                  "startColumn": 31,
                  "endLine": 703,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    variadic_type: nodes.Keyword | nodes.Starred,\n    variadics: list[nodes.Keyword | nodes.Starred],\n) -> bool:\n    \"\"\"Verify if the given call node has variadic nodes without context.\n\n    This is a workaround for handling cases of nested call functions\n    which don't have the specific call context at hand.\n",
                    "rendered": {
                      "text": "    variadic_type: nodes.Keyword | nodes.Starred,\n    variadics: list[nodes.Keyword | nodes.Starred],\n) -> bool:\n    \"\"\"Verify if the given call node has variadic nodes without context.\n\n    This is a workaround for handling cases of nested call functions\n    which don't have the specific call context at hand.\n",
                      "markdown": "`    variadic_type: nodes.Keyword | nodes.Starred,\n    variadics: list[nodes.Keyword | nodes.Starred],\n) -> bool:\n    \"\"\"Verify if the given call node has variadic nodes without context.\n\n    This is a workaround for handling cases of nested call functions\n    which don't have the specific call context at hand.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 666,
                  "startColumn": 25,
                  "endLine": 666,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    node_type: nodes.Keyword | nodes.Starred,\n    statement: _base_nodes.Statement,\n) -> bool:\n    \"\"\"Check if the given node has a parent of the given type.\"\"\"\n    parent = node.parent\n    while not isinstance(parent, node_type) and statement.parent_of(parent):\n        parent = parent.parent\n",
                    "rendered": {
                      "text": "    node_type: nodes.Keyword | nodes.Starred,\n    statement: _base_nodes.Statement,\n) -> bool:\n    \"\"\"Check if the given node has a parent of the given type.\"\"\"\n    parent = node.parent\n    while not isinstance(parent, node_type) and statement.parent_of(parent):\n        parent = parent.parent\n",
                      "markdown": "`    node_type: nodes.Keyword | nodes.Starred,\n    statement: _base_nodes.Statement,\n) -> bool:\n    \"\"\"Check if the given node has a parent of the given type.\"\"\"\n    parent = node.parent\n    while not isinstance(parent, node_type) and statement.parent_of(parent):\n        parent = parent.parent\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 631,
                  "startColumn": 20,
                  "endLine": 631,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        return callable_obj, parameters, \"lambda\"\n    if isinstance(callable_obj, nodes.ClassDef):\n        # Class instantiation, lookup __new__ instead.\n        # If we only find object.__new__, we can safely check __init__\n        # instead. If __new__ belongs to builtins, then we look\n        # again for __init__ in the locals, since we won't have\n        # argument information for the builtin __new__ function.\n",
                    "rendered": {
                      "text": "        return callable_obj, parameters, \"lambda\"\n    if isinstance(callable_obj, nodes.ClassDef):\n        # Class instantiation, lookup __new__ instead.\n        # If we only find object.__new__, we can safely check __init__\n        # instead. If __new__ belongs to builtins, then we look\n        # again for __init__ in the locals, since we won't have\n        # argument information for the builtin __new__ function.\n",
                      "markdown": "`        return callable_obj, parameters, \"lambda\"\n    if isinstance(callable_obj, nodes.ClassDef):\n        # Class instantiation, lookup __new__ instead.\n        # If we only find object.__new__, we can safely check __init__\n        # instead. If __new__ belongs to builtins, then we look\n        # again for __init__ in the locals, since we won't have\n        # argument information for the builtin __new__ function.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 597,
                  "startColumn": 5,
                  "endLine": 597,
                  "endColumn": 11,
                  "snippet": {
                    "text": "                dunder_new, returned_obj_name.name\n            )\n\n    # Find attributes defined in __init__\n    if dunder_init and dunder_init.body and dunder_init.args:\n        # Grab the name referring to `self` from the function def\n        enum_attributes |= _get_all_attribute_assignments(\n",
                    "rendered": {
                      "text": "                dunder_new, returned_obj_name.name\n            )\n\n    # Find attributes defined in __init__\n    if dunder_init and dunder_init.body and dunder_init.args:\n        # Grab the name referring to `self` from the function def\n        enum_attributes |= _get_all_attribute_assignments(\n",
                      "markdown": "`                dunder_new, returned_obj_name.name\n            )\n\n    # Find attributes defined in __init__\n    if dunder_init and dunder_init.body and dunder_init.args:\n        # Grab the name referring to `self` from the function def\n        enum_attributes |= _get_all_attribute_assignments(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 592,
                  "startColumn": 13,
                  "endLine": 592,
                  "endColumn": 19,
                  "snippet": {
                    "text": "            None,\n        )\n        if isinstance(returned_obj_name, nodes.Name):\n            # Find all attribute assignments to the returned object\n            enum_attributes |= _get_all_attribute_assignments(\n                dunder_new, returned_obj_name.name\n            )\n",
                    "rendered": {
                      "text": "            None,\n        )\n        if isinstance(returned_obj_name, nodes.Name):\n            # Find all attribute assignments to the returned object\n            enum_attributes |= _get_all_attribute_assignments(\n                dunder_new, returned_obj_name.name\n            )\n",
                      "markdown": "`            None,\n        )\n        if isinstance(returned_obj_name, nodes.Name):\n            # Find all attribute assignments to the returned object\n            enum_attributes |= _get_all_attribute_assignments(\n                dunder_new, returned_obj_name.name\n            )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 584,
                  "startColumn": 5,
                  "endLine": 584,
                  "endColumn": 11,
                  "snippet": {
                    "text": "\n    enum_attributes: set[str] = set()\n\n    # Find attributes defined in __new__\n    if dunder_new:\n        # Get the object returned in __new__\n        returned_obj_name = next(\n",
                    "rendered": {
                      "text": "\n    enum_attributes: set[str] = set()\n\n    # Find attributes defined in __new__\n    if dunder_new:\n        # Get the object returned in __new__\n        returned_obj_name = next(\n",
                      "markdown": "`\n    enum_attributes: set[str] = set()\n\n    # Find attributes defined in __new__\n    if dunder_new:\n        # Get the object returned in __new__\n        returned_obj_name = next(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 578,
                  "startColumn": 5,
                  "endLine": 578,
                  "endColumn": 11,
                  "snippet": {
                    "text": "    else:\n        enum_def = owner\n\n    # Find __new__ and __init__\n    dunder_new = next((m for m in enum_def.methods() if m.name == \"__new__\"), None)\n    dunder_init = next((m for m in enum_def.methods() if m.name == \"__init__\"), None)\n\n",
                    "rendered": {
                      "text": "    else:\n        enum_def = owner\n\n    # Find __new__ and __init__\n    dunder_new = next((m for m in enum_def.methods() if m.name == \"__new__\"), None)\n    dunder_init = next((m for m in enum_def.methods() if m.name == \"__init__\"), None)\n\n",
                      "markdown": "`    else:\n        enum_def = owner\n\n    # Find __new__ and __init__\n    dunder_new = next((m for m in enum_def.methods() if m.name == \"__new__\"), None)\n    dunder_init = next((m for m in enum_def.methods() if m.name == \"__init__\"), None)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 569,
                  "startColumn": 22,
                  "endLine": 570,
                  "snippet": {
                    "text": "        if enum_def is None:\n            # We don't inherit from anything, so try to find the parent\n            # class definition and roll with that\n            enum_def = node\n            while enum_def is not None and not isinstance(enum_def, nodes.ClassDef):\n                enum_def = enum_def.parent\n\n        # If this blows, something is clearly wrong\n",
                    "rendered": {
                      "text": "        if enum_def is None:\n            # We don't inherit from anything, so try to find the parent\n            # class definition and roll with that\n            enum_def = node\n            while enum_def is not None and not isinstance(enum_def, nodes.ClassDef):\n                enum_def = enum_def.parent\n\n        # If this blows, something is clearly wrong\n",
                      "markdown": "`        if enum_def is None:\n            # We don't inherit from anything, so try to find the parent\n            # class definition and roll with that\n            enum_def = node\n            while enum_def is not None and not isinstance(enum_def, nodes.ClassDef):\n                enum_def = enum_def.parent\n\n        # If this blows, something is clearly wrong\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 567,
                  "startColumn": 55,
                  "endLine": 567,
                  "endColumn": 61,
                  "snippet": {
                    "text": "        )\n\n        if enum_def is None:\n            # We don't inherit from anything, so try to find the parent\n            # class definition and roll with that\n            enum_def = node\n            while enum_def is not None and not isinstance(enum_def, nodes.ClassDef):\n",
                    "rendered": {
                      "text": "        )\n\n        if enum_def is None:\n            # We don't inherit from anything, so try to find the parent\n            # class definition and roll with that\n            enum_def = node\n            while enum_def is not None and not isinstance(enum_def, nodes.ClassDef):\n",
                      "markdown": "`        )\n\n        if enum_def is None:\n            # We don't inherit from anything, so try to find the parent\n            # class definition and roll with that\n            enum_def = node\n            while enum_def is not None and not isinstance(enum_def, nodes.ClassDef):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 513,
                  "startColumn": 31,
                  "endLine": 514,
                  "snippet": {
                    "text": "    #       and whether the node is part of the `body`.\n    #   * Continue checking until scope of node is reached.\n    scope: nodes.NodeNG = node.scope()\n    node_origin: nodes.NodeNG = node\n    parent: nodes.NodeNG = node.parent\n    while parent != scope:\n        if isinstance(parent, (nodes.If, nodes.IfExp)):\n            inferred = safe_infer(parent.test)\n",
                    "rendered": {
                      "text": "    #       and whether the node is part of the `body`.\n    #   * Continue checking until scope of node is reached.\n    scope: nodes.NodeNG = node.scope()\n    node_origin: nodes.NodeNG = node\n    parent: nodes.NodeNG = node.parent\n    while parent != scope:\n        if isinstance(parent, (nodes.If, nodes.IfExp)):\n            inferred = safe_infer(parent.test)\n",
                      "markdown": "`    #       and whether the node is part of the `body`.\n    #   * Continue checking until scope of node is reached.\n    scope: nodes.NodeNG = node.scope()\n    node_origin: nodes.NodeNG = node\n    parent: nodes.NodeNG = node.parent\n    while parent != scope:\n        if isinstance(parent, (nodes.If, nodes.IfExp)):\n            inferred = safe_infer(parent.test)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 511,
                  "startColumn": 42,
                  "endLine": 511,
                  "endColumn": 48,
                  "snippet": {
                    "text": "    #   * Check if condition can be inferred as `Const`,\n    #       would evaluate as `False`,\n    #       and whether the node is part of the `body`.\n    #   * Continue checking until scope of node is reached.\n    scope: nodes.NodeNG = node.scope()\n    node_origin: nodes.NodeNG = node\n    parent: nodes.NodeNG = node.parent\n",
                    "rendered": {
                      "text": "    #   * Check if condition can be inferred as `Const`,\n    #       would evaluate as `False`,\n    #       and whether the node is part of the `body`.\n    #   * Continue checking until scope of node is reached.\n    scope: nodes.NodeNG = node.scope()\n    node_origin: nodes.NodeNG = node\n    parent: nodes.NodeNG = node.parent\n",
                      "markdown": "`    #   * Check if condition can be inferred as `Const`,\n    #       would evaluate as `False`,\n    #       and whether the node is part of the `body`.\n    #   * Continue checking until scope of node is reached.\n    scope: nodes.NodeNG = node.scope()\n    node_origin: nodes.NodeNG = node\n    parent: nodes.NodeNG = node.parent\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 510,
                  "startColumn": 27,
                  "endLine": 510,
                  "endColumn": 33,
                  "snippet": {
                    "text": "    #   * Walk up recursively until if statement is found.\n    #   * Check if condition can be inferred as `Const`,\n    #       would evaluate as `False`,\n    #       and whether the node is part of the `body`.\n    #   * Continue checking until scope of node is reached.\n    scope: nodes.NodeNG = node.scope()\n    node_origin: nodes.NodeNG = node\n",
                    "rendered": {
                      "text": "    #   * Walk up recursively until if statement is found.\n    #   * Check if condition can be inferred as `Const`,\n    #       would evaluate as `False`,\n    #       and whether the node is part of the `body`.\n    #   * Continue checking until scope of node is reached.\n    scope: nodes.NodeNG = node.scope()\n    node_origin: nodes.NodeNG = node\n",
                      "markdown": "`    #   * Walk up recursively until if statement is found.\n    #   * Check if condition can be inferred as `Const`,\n    #       would evaluate as `False`,\n    #       and whether the node is part of the `body`.\n    #   * Continue checking until scope of node is reached.\n    scope: nodes.NodeNG = node.scope()\n    node_origin: nodes.NodeNG = node\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 445,
                  "startColumn": 56,
                  "endLine": 446,
                  "snippet": {
                    "text": "        * the owner is a class and the name can be found in its metaclass.\n        * The access node is protected by an except handler, which handles\n          AttributeError, Exception or bare except.\n        * The node is guarded behind and `IF` or `IFExp` node\n    \"\"\"\n    # pylint: disable = too-many-return-statements, too-many-branches\n    if node_ignores_exception(node, AttributeError):\n        return False\n",
                    "rendered": {
                      "text": "        * the owner is a class and the name can be found in its metaclass.\n        * The access node is protected by an except handler, which handles\n          AttributeError, Exception or bare except.\n        * The node is guarded behind and `IF` or `IFExp` node\n    \"\"\"\n    # pylint: disable = too-many-return-statements, too-many-branches\n    if node_ignores_exception(node, AttributeError):\n        return False\n",
                      "markdown": "`        * the owner is a class and the name can be found in its metaclass.\n        * The access node is protected by an except handler, which handles\n          AttributeError, Exception or bare except.\n        * The node is guarded behind and `IF` or `IFExp` node\n    \"\"\"\n    # pylint: disable = too-many-return-statements, too-many-branches\n    if node_ignores_exception(node, AttributeError):\n        return False\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 445,
                  "startColumn": 13,
                  "endLine": 445,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        * the owner is a class and the name can be found in its metaclass.\n        * The access node is protected by an except handler, which handles\n          AttributeError, Exception or bare except.\n        * The node is guarded behind and `IF` or `IFExp` node\n    \"\"\"\n    # pylint: disable = too-many-return-statements, too-many-branches\n    if node_ignores_exception(node, AttributeError):\n",
                    "rendered": {
                      "text": "        * the owner is a class and the name can be found in its metaclass.\n        * The access node is protected by an except handler, which handles\n          AttributeError, Exception or bare except.\n        * The node is guarded behind and `IF` or `IFExp` node\n    \"\"\"\n    # pylint: disable = too-many-return-statements, too-many-branches\n    if node_ignores_exception(node, AttributeError):\n",
                      "markdown": "`        * the owner is a class and the name can be found in its metaclass.\n        * The access node is protected by an except handler, which handles\n          AttributeError, Exception or bare except.\n        * The node is guarded behind and `IF` or `IFExp` node\n    \"\"\"\n    # pylint: disable = too-many-return-statements, too-many-branches\n    if node_ignores_exception(node, AttributeError):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 443,
                  "startColumn": 20,
                  "endLine": 443,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        * the owner is an instance and it has __getattr__, __getattribute__ implemented\n        * the module is explicitly ignored from no-member checks\n        * the owner is a class and the name can be found in its metaclass.\n        * The access node is protected by an except handler, which handles\n          AttributeError, Exception or bare except.\n        * The node is guarded behind and `IF` or `IFExp` node\n    \"\"\"\n",
                    "rendered": {
                      "text": "        * the owner is an instance and it has __getattr__, __getattribute__ implemented\n        * the module is explicitly ignored from no-member checks\n        * the owner is a class and the name can be found in its metaclass.\n        * The access node is protected by an except handler, which handles\n          AttributeError, Exception or bare except.\n        * The node is guarded behind and `IF` or `IFExp` node\n    \"\"\"\n",
                      "markdown": "`        * the owner is an instance and it has __getattr__, __getattribute__ implemented\n        * the module is explicitly ignored from no-member checks\n        * the owner is a class and the name can be found in its metaclass.\n        * The access node is protected by an except handler, which handles\n          AttributeError, Exception or bare except.\n        * The node is guarded behind and `IF` or `IFExp` node\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 177,
                  "startColumn": 40,
                  "endLine": 177,
                  "endColumn": 46,
                  "snippet": {
                    "text": "    distance_threshold: int,\n    max_choices: int,\n) -> list[str]:\n    \"\"\"Given an owner and a name, try to find similar names.\n\n    The similar names are searched given a distance metric and only\n    a given number of choices will be returned.\n",
                    "rendered": {
                      "text": "    distance_threshold: int,\n    max_choices: int,\n) -> list[str]:\n    \"\"\"Given an owner and a name, try to find similar names.\n\n    The similar names are searched given a distance metric and only\n    a given number of choices will be returned.\n",
                      "markdown": "`    distance_threshold: int,\n    max_choices: int,\n) -> list[str]:\n    \"\"\"Given an owner and a name, try to find similar names.\n\n    The similar names are searched given a distance metric and only\n    a given number of choices will be returned.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/typecheck.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 9,
                  "endLine": 5,
                  "endColumn": 15,
                  "snippet": {
                    "text": "# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Try to find more bugs in the code using astroid inference capabilities.\"\"\"\n\nfrom __future__ import annotations\n\n",
                    "rendered": {
                      "text": "# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Try to find more bugs in the code using astroid inference capabilities.\"\"\"\n\nfrom __future__ import annotations\n\n",
                      "markdown": "`# For details: https://github.com/pylint-dev/pylint/blob/main/LICENSE\n# Copyright (c) https://github.com/pylint-dev/pylint/blob/main/CONTRIBUTORS.txt\n\n\"\"\"Try to find more bugs in the code using astroid inference capabilities.\"\"\"\n\nfrom __future__ import annotations\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/symilar.py"
                },
                "region": {
                  "startLine": 266,
                  "startColumn": 30,
                  "endLine": 266,
                  "endColumn": 38,
                  "snippet": {
                    "text": "\n    There are two successive keys (11, 34) and (12, 35).\n    It means there are two consecutive similar chunks of lines in both files.\n    Thus remove last entry and update the last line numbers in the first entry\n\n    >>> remove_successive(all_couples)\n    >>> all_couples\n",
                    "rendered": {
                      "text": "\n    There are two successive keys (11, 34) and (12, 35).\n    It means there are two consecutive similar chunks of lines in both files.\n    Thus remove last entry and update the last line numbers in the first entry\n\n    >>> remove_successive(all_couples)\n    >>> all_couples\n",
                      "markdown": "`\n    There are two successive keys (11, 34) and (12, 35).\n    It means there are two consecutive similar chunks of lines in both files.\n    Thus remove last entry and update the last line numbers in the first entry\n\n    >>> remove_successive(all_couples)\n    >>> all_couples\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/symilar.py"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 65,
                  "endLine": 142,
                  "endColumn": 69,
                  "snippet": {
                    "text": "\n    def __str__(self) -> str:\n        return (\n            f\"LinesChunk object for file {self._fileid}, starting at line {self._index} \\n\"\n            f\"Hash is {self._hash}\"\n        )\n\n",
                    "rendered": {
                      "text": "\n    def __str__(self) -> str:\n        return (\n            f\"LinesChunk object for file {self._fileid}, starting at line {self._index} \\n\"\n            f\"Hash is {self._hash}\"\n        )\n\n",
                      "markdown": "`\n    def __str__(self) -> str:\n        return (\n            f\"LinesChunk object for file {self._fileid}, starting at line {self._index} \\n\"\n            f\"Hash is {self._hash}\"\n        )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/symilar.py"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 49,
                  "endLine": 13,
                  "endColumn": 53,
                  "snippet": {
                    "text": "\nThose stripped lines are stored in the LineSet class which gives access to them.\nThen each index of the stripped lines collection is associated with the hash of n\nsuccessive entries of the stripped lines starting at the current index (n is the\nminimum common lines option).\n\nThe common hashes between both linesets are then looked for. If there are matches, then\n",
                    "rendered": {
                      "text": "\nThose stripped lines are stored in the LineSet class which gives access to them.\nThen each index of the stripped lines collection is associated with the hash of n\nsuccessive entries of the stripped lines starting at the current index (n is the\nminimum common lines option).\n\nThe common hashes between both linesets are then looked for. If there are matches, then\n",
                      "markdown": "`\nThose stripped lines are stored in the LineSet class which gives access to them.\nThen each index of the stripped lines collection is associated with the hash of n\nsuccessive entries of the stripped lines starting at the current index (n is the\nminimum common lines option).\n\nThe common hashes between both linesets are then looked for. If there are matches, then\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/symilar.py"
                },
                "region": {
                  "startLine": 608,
                  "startColumn": 19,
                  "endLine": 608,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n                tree.\n                \"\"\"\n                for node in tree.body:\n                    if isinstance(node, (nodes.FunctionDef, nodes.AsyncFunctionDef)):\n                        functions.append(node)\n\n",
                    "rendered": {
                      "text": "\n                tree.\n                \"\"\"\n                for node in tree.body:\n                    if isinstance(node, (nodes.FunctionDef, nodes.AsyncFunctionDef)):\n                        functions.append(node)\n\n",
                      "markdown": "`\n                tree.\n                \"\"\"\n                for node in tree.body:\n                    if isinstance(node, (nodes.FunctionDef, nodes.AsyncFunctionDef)):\n                        functions.append(node)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/symilar.py"
                },
                "region": {
                  "startLine": 595,
                  "startColumn": 23,
                  "endLine": 595,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            ignore_lines.update(\n                chain.from_iterable(\n                    range(node.lineno, (node.end_lineno or node.lineno) + 1)\n                    for node in tree.nodes_of_class((nodes.Import, nodes.ImportFrom))\n                )\n            )\n        if ignore_signatures:\n",
                    "rendered": {
                      "text": "            ignore_lines.update(\n                chain.from_iterable(\n                    range(node.lineno, (node.end_lineno or node.lineno) + 1)\n                    for node in tree.nodes_of_class((nodes.Import, nodes.ImportFrom))\n                )\n            )\n        if ignore_signatures:\n",
                      "markdown": "`            ignore_lines.update(\n                chain.from_iterable(\n                    range(node.lineno, (node.end_lineno or node.lineno) + 1)\n                    for node in tree.nodes_of_class((nodes.Import, nodes.ImportFrom))\n                )\n            )\n        if ignore_signatures:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/strings.py"
                },
                "region": {
                  "startLine": 900,
                  "startColumn": 61,
                  "endLine": 900,
                  "endColumn": 66,
                  "snippet": {
                    "text": "                    self.linter.config.check_str_concat_over_line_jumps\n                    # Allow implicitly concatenated strings in parens.\n                    # See https://github.com/pylint-dev/pylint/issues/8552.\n                    and not self._parenthesized_string_tokens.get(\n                        (elt.lineno, elt.col_offset)\n                    )\n                ):\n",
                    "rendered": {
                      "text": "                    self.linter.config.check_str_concat_over_line_jumps\n                    # Allow implicitly concatenated strings in parens.\n                    # See https://github.com/pylint-dev/pylint/issues/8552.\n                    and not self._parenthesized_string_tokens.get(\n                        (elt.lineno, elt.col_offset)\n                    )\n                ):\n",
                      "markdown": "`                    self.linter.config.check_str_concat_over_line_jumps\n                    # Allow implicitly concatenated strings in parens.\n                    # See https://github.com/pylint-dev/pylint/issues/8552.\n                    and not self._parenthesized_string_tokens.get(\n                        (elt.lineno, elt.col_offset)\n                    )\n                ):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/strings.py"
                },
                "region": {
                  "startLine": 335,
                  "startColumn": 52,
                  "endLine": 335,
                  "endColumn": 57,
                  "snippet": {
                    "text": "                for key, arg in args.items:\n                    if not isinstance(key, nodes.Const):\n                        continue\n                    format_type = required_key_types.get(key.value, None)\n                    arg_type = utils.safe_infer(arg)\n                    if (\n                        format_type is not None\n",
                    "rendered": {
                      "text": "                for key, arg in args.items:\n                    if not isinstance(key, nodes.Const):\n                        continue\n                    format_type = required_key_types.get(key.value, None)\n                    arg_type = utils.safe_infer(arg)\n                    if (\n                        format_type is not None\n",
                      "markdown": "`                for key, arg in args.items:\n                    if not isinstance(key, nodes.Const):\n                        continue\n                    format_type = required_key_types.get(key.value, None)\n                    arg_type = utils.safe_infer(arg)\n                    if (\n                        format_type is not None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/strings.py"
                },
                "region": {
                  "startLine": 961,
                  "startColumn": 64,
                  "endLine": 961,
                  "endColumn": 68,
                  "snippet": {
                    "text": "            index = string_body.find(\"\\\\\", index)\n            if index == -1:\n                break\n            # There must be a next character; having a backslash at the end\n            # of the string would be a SyntaxError.\n            next_char = string_body[index + 1]\n            match = string_body[index : index + 2]\n",
                    "rendered": {
                      "text": "            index = string_body.find(\"\\\\\", index)\n            if index == -1:\n                break\n            # There must be a next character; having a backslash at the end\n            # of the string would be a SyntaxError.\n            next_char = string_body[index + 1]\n            match = string_body[index : index + 2]\n",
                      "markdown": "`            index = string_body.find(\"\\\\\", index)\n            if index == -1:\n                break\n            # There must be a next character; having a backslash at the end\n            # of the string would be a SyntaxError.\n            next_char = string_body[index + 1]\n            match = string_body[index : index + 2]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/strings.py"
                },
                "region": {
                  "startLine": 928,
                  "startColumn": 42,
                  "endLine": 928,
                  "endColumn": 46,
                  "snippet": {
                    "text": "            3 if after_prefix[:3] == after_prefix[-3:] == 3 * quote_char else 1\n        )\n        string_body = after_prefix[quote_length:-quote_length]\n        # No special checks on raw strings at the moment.\n        if \"r\" not in prefix:\n            self.process_non_raw_string_token(\n                prefix,\n",
                    "rendered": {
                      "text": "            3 if after_prefix[:3] == after_prefix[-3:] == 3 * quote_char else 1\n        )\n        string_body = after_prefix[quote_length:-quote_length]\n        # No special checks on raw strings at the moment.\n        if \"r\" not in prefix:\n            self.process_non_raw_string_token(\n                prefix,\n",
                      "markdown": "`            3 if after_prefix[:3] == after_prefix[-3:] == 3 * quote_char else 1\n        )\n        string_body = after_prefix[quote_length:-quote_length]\n        # No special checks on raw strings at the moment.\n        if \"r\" not in prefix:\n            self.process_non_raw_string_token(\n                prefix,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/strings.py"
                },
                "region": {
                  "startLine": 731,
                  "startColumn": 67,
                  "endLine": 731,
                  "endColumn": 71,
                  "snippet": {
                    "text": "                # this is always the first token processed\n                encoding = token\n            elif token_type == tokenize.STRING:\n                # 'token' is the whole un-parsed token; we can look at the start\n                # of it to see whether it's a raw or unicode string etc.\n                self.process_string_token(token, start[0], start[1])\n                # We figure the next token, ignoring comments & newlines:\n",
                    "rendered": {
                      "text": "                # this is always the first token processed\n                encoding = token\n            elif token_type == tokenize.STRING:\n                # 'token' is the whole un-parsed token; we can look at the start\n                # of it to see whether it's a raw or unicode string etc.\n                self.process_string_token(token, start[0], start[1])\n                # We figure the next token, ignoring comments & newlines:\n",
                      "markdown": "`                # this is always the first token processed\n                encoding = token\n            elif token_type == tokenize.STRING:\n                # 'token' is the whole un-parsed token; we can look at the start\n                # of it to see whether it's a raw or unicode string etc.\n                self.process_string_token(token, start[0], start[1])\n                # We figure the next token, ignoring comments & newlines:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/strings.py"
                },
                "region": {
                  "startLine": 515,
                  "startColumn": 45,
                  "endLine": 515,
                  "endColumn": 49,
                  "snippet": {
                    "text": "                empty = not all(field for field in named_fields)\n                if named_arguments or empty:\n                    # Verify the required number of positional arguments\n                    # only if the .format got at least one keyword argument.\n                    # This means that the format strings accepts both\n                    # positional and named fields and we should warn\n                    # when one of them is missing or is extra.\n",
                    "rendered": {
                      "text": "                empty = not all(field for field in named_fields)\n                if named_arguments or empty:\n                    # Verify the required number of positional arguments\n                    # only if the .format got at least one keyword argument.\n                    # This means that the format strings accepts both\n                    # positional and named fields and we should warn\n                    # when one of them is missing or is extra.\n",
                      "markdown": "`                empty = not all(field for field in named_fields)\n                if named_arguments or empty:\n                    # Verify the required number of positional arguments\n                    # only if the .format got at least one keyword argument.\n                    # This means that the format strings accepts both\n                    # positional and named fields and we should warn\n                    # when one of them is missing or is extra.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/strings.py"
                },
                "region": {
                  "startLine": 458,
                  "startColumn": 50,
                  "endLine": 458,
                  "endColumn": 54,
                  "snippet": {
                    "text": "        # left side of the format operation.\n        # We do this because our inference engine can't properly handle\n        # redefinition of the original string.\n        # Note that there may not be any left side at all, if the format method\n        # has been assigned to another variable. See issue 351. For example:\n        #\n        #    fmt = 'some string {}'.format\n",
                    "rendered": {
                      "text": "        # left side of the format operation.\n        # We do this because our inference engine can't properly handle\n        # redefinition of the original string.\n        # Note that there may not be any left side at all, if the format method\n        # has been assigned to another variable. See issue 351. For example:\n        #\n        #    fmt = 'some string {}'.format\n",
                      "markdown": "`        # left side of the format operation.\n        # We do this because our inference engine can't properly handle\n        # redefinition of the original string.\n        # Note that there may not be any left side at all, if the format method\n        # has been assigned to another variable. See issue 351. For example:\n        #\n        #    fmt = 'some string {}'.format\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/strings.py"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 52,
                  "endLine": 71,
                  "endColumn": 56,
                  "snippet": {
                    "text": "MSGS: dict[str, MessageDefinitionTuple] = (\n    {  # pylint: disable=consider-using-namedtuple-or-dataclass\n        \"E1300\": (\n            \"Unsupported format character %r (%#02x) at index %d\",\n            \"bad-format-character\",\n            \"Used when an unsupported format character is used in a format string.\",\n        ),\n",
                    "rendered": {
                      "text": "MSGS: dict[str, MessageDefinitionTuple] = (\n    {  # pylint: disable=consider-using-namedtuple-or-dataclass\n        \"E1300\": (\n            \"Unsupported format character %r (%#02x) at index %d\",\n            \"bad-format-character\",\n            \"Used when an unsupported format character is used in a format string.\",\n        ),\n",
                      "markdown": "`MSGS: dict[str, MessageDefinitionTuple] = (\n    {  # pylint: disable=consider-using-namedtuple-or-dataclass\n        \"E1300\": (\n            \"Unsupported format character %r (%#02x) at index %d\",\n            \"bad-format-character\",\n            \"Used when an unsupported format character is used in a format string.\",\n        ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/strings.py"
                },
                "region": {
                  "startLine": 461,
                  "startColumn": 12,
                  "endLine": 461,
                  "endColumn": 17,
                  "snippet": {
                    "text": "        # Note that there may not be any left side at all, if the format method\n        # has been assigned to another variable. See issue 351. For example:\n        #\n        #    fmt = 'some string {}'.format\n        #    fmt('arg')\n        if isinstance(node.func, nodes.Attribute) and not isinstance(\n            node.func.expr, nodes.Const\n",
                    "rendered": {
                      "text": "        # Note that there may not be any left side at all, if the format method\n        # has been assigned to another variable. See issue 351. For example:\n        #\n        #    fmt = 'some string {}'.format\n        #    fmt('arg')\n        if isinstance(node.func, nodes.Attribute) and not isinstance(\n            node.func.expr, nodes.Const\n",
                      "markdown": "`        # Note that there may not be any left side at all, if the format method\n        # has been assigned to another variable. See issue 351. For example:\n        #\n        #    fmt = 'some string {}'.format\n        #    fmt('arg')\n        if isinstance(node.func, nodes.Attribute) and not isinstance(\n            node.func.expr, nodes.Const\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/stdlib.py"
                },
                "region": {
                  "startLine": 965,
                  "startColumn": 39,
                  "endLine": 965,
                  "endColumn": 44,
                  "snippet": {
                    "text": "        return self._deprecated_arguments.get(method, ())\n\n    def deprecated_classes(self, module: str) -> Iterable[str]:\n        return self._deprecated_classes.get(module, ())\n\n    def deprecated_decorators(self) -> Iterable[str]:\n        return self._deprecated_decorators\n",
                    "rendered": {
                      "text": "        return self._deprecated_arguments.get(method, ())\n\n    def deprecated_classes(self, module: str) -> Iterable[str]:\n        return self._deprecated_classes.get(module, ())\n\n    def deprecated_decorators(self) -> Iterable[str]:\n        return self._deprecated_decorators\n",
                      "markdown": "`        return self._deprecated_arguments.get(method, ())\n\n    def deprecated_classes(self, module: str) -> Iterable[str]:\n        return self._deprecated_classes.get(module, ())\n\n    def deprecated_decorators(self) -> Iterable[str]:\n        return self._deprecated_decorators\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/stdlib.py"
                },
                "region": {
                  "startLine": 962,
                  "startColumn": 41,
                  "endLine": 962,
                  "endColumn": 46,
                  "snippet": {
                    "text": "        return self._deprecated_methods\n\n    def deprecated_arguments(self, method: str) -> tuple[tuple[int | None, str], ...]:\n        return self._deprecated_arguments.get(method, ())\n\n    def deprecated_classes(self, module: str) -> Iterable[str]:\n        return self._deprecated_classes.get(module, ())\n",
                    "rendered": {
                      "text": "        return self._deprecated_methods\n\n    def deprecated_arguments(self, method: str) -> tuple[tuple[int | None, str], ...]:\n        return self._deprecated_arguments.get(method, ())\n\n    def deprecated_classes(self, module: str) -> Iterable[str]:\n        return self._deprecated_classes.get(module, ())\n",
                      "markdown": "`        return self._deprecated_methods\n\n    def deprecated_arguments(self, method: str) -> tuple[tuple[int | None, str], ...]:\n        return self._deprecated_arguments.get(method, ())\n\n    def deprecated_classes(self, module: str) -> Iterable[str]:\n        return self._deprecated_classes.get(module, ())\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/stdlib.py"
                },
                "region": {
                  "startLine": 896,
                  "startColumn": 15,
                  "endLine": 896,
                  "endColumn": 69,
                  "snippet": {
                    "text": "                        \"unspecified-encoding\", node=node, confidence=confidence\n                    )\n\n    def _check_env_function(self, node: nodes.Call, infer: nodes.FunctionDef) -> None:\n        env_name_kwarg = \"key\"\n        env_value_kwarg = \"default\"\n        if node.keywords:\n",
                    "rendered": {
                      "text": "                        \"unspecified-encoding\", node=node, confidence=confidence\n                    )\n\n    def _check_env_function(self, node: nodes.Call, infer: nodes.FunctionDef) -> None:\n        env_name_kwarg = \"key\"\n        env_value_kwarg = \"default\"\n        if node.keywords:\n",
                      "markdown": "`                        \"unspecified-encoding\", node=node, confidence=confidence\n                    )\n\n    def _check_env_function(self, node: nodes.Call, infer: nodes.FunctionDef) -> None:\n        env_name_kwarg = \"key\"\n        env_value_kwarg = \"default\"\n        if node.keywords:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/stdlib.py"
                },
                "region": {
                  "startLine": 690,
                  "startColumn": 32,
                  "endLine": 690,
                  "endColumn": 40,
                  "snippet": {
                    "text": "                if name == COPY_COPY:\n                    self._check_shallow_copy_environ(node)\n                elif name in ENV_GETTERS:\n                    self._check_env_function(node, inferred)\n                elif name == SUBPROCESS_RUN:\n                    self._check_for_check_kw_in_run(node)\n                elif name in DEBUG_BREAKPOINTS:\n",
                    "rendered": {
                      "text": "                if name == COPY_COPY:\n                    self._check_shallow_copy_environ(node)\n                elif name in ENV_GETTERS:\n                    self._check_env_function(node, inferred)\n                elif name == SUBPROCESS_RUN:\n                    self._check_for_check_kw_in_run(node)\n                elif name in DEBUG_BREAKPOINTS:\n",
                      "markdown": "`                if name == COPY_COPY:\n                    self._check_shallow_copy_environ(node)\n                elif name in ENV_GETTERS:\n                    self._check_env_function(node, inferred)\n                elif name == SUBPROCESS_RUN:\n                    self._check_for_check_kw_in_run(node)\n                elif name in DEBUG_BREAKPOINTS:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/stdlib.py"
                },
                "region": {
                  "startLine": 689,
                  "startColumn": 29,
                  "endLine": 689,
                  "endColumn": 36,
                  "snippet": {
                    "text": "                name = inferred.qname()\n                if name == COPY_COPY:\n                    self._check_shallow_copy_environ(node)\n                elif name in ENV_GETTERS:\n                    self._check_env_function(node, inferred)\n                elif name == SUBPROCESS_RUN:\n                    self._check_for_check_kw_in_run(node)\n",
                    "rendered": {
                      "text": "                name = inferred.qname()\n                if name == COPY_COPY:\n                    self._check_shallow_copy_environ(node)\n                elif name in ENV_GETTERS:\n                    self._check_env_function(node, inferred)\n                elif name == SUBPROCESS_RUN:\n                    self._check_for_check_kw_in_run(node)\n",
                      "markdown": "`                name = inferred.qname()\n                if name == COPY_COPY:\n                    self._check_shallow_copy_environ(node)\n                elif name in ENV_GETTERS:\n                    self._check_env_function(node, inferred)\n                elif name == SUBPROCESS_RUN:\n                    self._check_for_check_kw_in_run(node)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/stdlib.py"
                },
                "region": {
                  "startLine": 645,
                  "startColumn": 34,
                  "endLine": 645,
                  "endColumn": 75,
                  "snippet": {
                    "text": "        for inferred in inferred_args:\n            if inferred.qname() == OS_ENVIRON:\n                self.add_message(\n                    \"shallow-copy-environ\", node=node, confidence=confidence\n                )\n                break\n\n",
                    "rendered": {
                      "text": "        for inferred in inferred_args:\n            if inferred.qname() == OS_ENVIRON:\n                self.add_message(\n                    \"shallow-copy-environ\", node=node, confidence=confidence\n                )\n                break\n\n",
                      "markdown": "`        for inferred in inferred_args:\n            if inferred.qname() == OS_ENVIRON:\n                self.add_message(\n                    \"shallow-copy-environ\", node=node, confidence=confidence\n                )\n                break\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/stdlib.py"
                },
                "region": {
                  "startLine": 530,
                  "startColumn": 13,
                  "endLine": 530,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        \"W1508\": (\n            \"%s default type is %s. Expected str or None.\",\n            \"invalid-envvar-default\",\n            \"Env manipulation functions return None or str values. \"\n            \"Supplying anything different as a default may cause bugs. \"\n            \"See https://docs.python.org/3/library/os.html#os.getenv.\",\n        ),\n",
                    "rendered": {
                      "text": "        \"W1508\": (\n            \"%s default type is %s. Expected str or None.\",\n            \"invalid-envvar-default\",\n            \"Env manipulation functions return None or str values. \"\n            \"Supplying anything different as a default may cause bugs. \"\n            \"See https://docs.python.org/3/library/os.html#os.getenv.\",\n        ),\n",
                      "markdown": "`        \"W1508\": (\n            \"%s default type is %s. Expected str or None.\",\n            \"invalid-envvar-default\",\n            \"Env manipulation functions return None or str values. \"\n            \"Supplying anything different as a default may cause bugs. \"\n            \"See https://docs.python.org/3/library/os.html#os.getenv.\",\n        ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/stdlib.py"
                },
                "region": {
                  "startLine": 510,
                  "startColumn": 13,
                  "endLine": 510,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        \"E1507\": (\n            \"%s does not support %s type argument\",\n            \"invalid-envvar-value\",\n            \"Env manipulation functions support only string type arguments. \"\n            \"See https://docs.python.org/3/library/os.html#os.getenv.\",\n        ),\n        \"E1519\": (\n",
                    "rendered": {
                      "text": "        \"E1507\": (\n            \"%s does not support %s type argument\",\n            \"invalid-envvar-value\",\n            \"Env manipulation functions support only string type arguments. \"\n            \"See https://docs.python.org/3/library/os.html#os.getenv.\",\n        ),\n        \"E1519\": (\n",
                      "markdown": "`        \"E1507\": (\n            \"%s does not support %s type argument\",\n            \"invalid-envvar-value\",\n            \"Env manipulation functions support only string type arguments. \"\n            \"See https://docs.python.org/3/library/os.html#os.getenv.\",\n        ),\n        \"E1519\": (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/stdlib.py"
                },
                "region": {
                  "startLine": 33,
                  "endLine": 33,
                  "endColumn": 22,
                  "snippet": {
                    "text": "THREADING_THREAD = \"threading.Thread\"\nCOPY_COPY = \"copy.copy\"\nOS_ENVIRON = \"os._Environ\"\nENV_GETTERS = (\"os.getenv\",)\nSUBPROCESS_POPEN = \"subprocess.Popen\"\nSUBPROCESS_RUN = \"subprocess.run\"\nOPEN_MODULE = {\"_io\", \"pathlib\", \"pathlib._local\"}\n",
                    "rendered": {
                      "text": "THREADING_THREAD = \"threading.Thread\"\nCOPY_COPY = \"copy.copy\"\nOS_ENVIRON = \"os._Environ\"\nENV_GETTERS = (\"os.getenv\",)\nSUBPROCESS_POPEN = \"subprocess.Popen\"\nSUBPROCESS_RUN = \"subprocess.run\"\nOPEN_MODULE = {\"_io\", \"pathlib\", \"pathlib._local\"}\n",
                      "markdown": "`THREADING_THREAD = \"threading.Thread\"\nCOPY_COPY = \"copy.copy\"\nOS_ENVIRON = \"os._Environ\"\nENV_GETTERS = (\"os.getenv\",)\nSUBPROCESS_POPEN = \"subprocess.Popen\"\nSUBPROCESS_RUN = \"subprocess.run\"\nOPEN_MODULE = {\"_io\", \"pathlib\", \"pathlib._local\"}\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/stdlib.py"
                },
                "region": {
                  "startLine": 222,
                  "startColumn": 23,
                  "endLine": 222,
                  "endColumn": 31,
                  "snippet": {
                    "text": "            \"asyncio.Task.all_task\",\n            \"locale.format\",\n            \"ssl.wrap_socket\",\n            \"ssl.match_hostname\",\n            \"sunau.openfp\",\n            \"wave.openfp\",\n        },\n",
                    "rendered": {
                      "text": "            \"asyncio.Task.all_task\",\n            \"locale.format\",\n            \"ssl.wrap_socket\",\n            \"ssl.match_hostname\",\n            \"sunau.openfp\",\n            \"wave.openfp\",\n        },\n",
                      "markdown": "`            \"asyncio.Task.all_task\",\n            \"locale.format\",\n            \"ssl.wrap_socket\",\n            \"ssl.match_hostname\",\n            \"sunau.openfp\",\n            \"wave.openfp\",\n        },\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/stdlib.py"
                },
                "region": {
                  "startLine": 166,
                  "startColumn": 13,
                  "endLine": 166,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        },\n        (3, 1, 0): {\n            \"base64.encodestring\",\n            \"base64.decodestring\",\n            \"ntpath.splitunc\",\n            \"os.path.splitunc\",\n            \"os.stat_float_times\",\n",
                    "rendered": {
                      "text": "        },\n        (3, 1, 0): {\n            \"base64.encodestring\",\n            \"base64.decodestring\",\n            \"ntpath.splitunc\",\n            \"os.path.splitunc\",\n            \"os.stat_float_times\",\n",
                      "markdown": "`        },\n        (3, 1, 0): {\n            \"base64.encodestring\",\n            \"base64.decodestring\",\n            \"ntpath.splitunc\",\n            \"os.path.splitunc\",\n            \"os.stat_float_times\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/stdlib.py"
                },
                "region": {
                  "startLine": 165,
                  "startColumn": 13,
                  "endLine": 165,
                  "endColumn": 19,
                  "snippet": {
                    "text": "            \"assertNotRegexpMatches\",\n        },\n        (3, 1, 0): {\n            \"base64.encodestring\",\n            \"base64.decodestring\",\n            \"ntpath.splitunc\",\n            \"os.path.splitunc\",\n",
                    "rendered": {
                      "text": "            \"assertNotRegexpMatches\",\n        },\n        (3, 1, 0): {\n            \"base64.encodestring\",\n            \"base64.decodestring\",\n            \"ntpath.splitunc\",\n            \"os.path.splitunc\",\n",
                      "markdown": "`            \"assertNotRegexpMatches\",\n        },\n        (3, 1, 0): {\n            \"base64.encodestring\",\n            \"base64.decodestring\",\n            \"ntpath.splitunc\",\n            \"os.path.splitunc\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/stdlib.py"
                },
                "region": {
                  "startLine": 480,
                  "startColumn": 33,
                  "endLine": 480,
                  "endColumn": 39,
                  "snippet": {
                    "text": "            \"Using datetime.time in a boolean context.\",\n            \"boolean-datetime\",\n            \"Using datetime.time in a boolean context can hide \"\n            \"subtle bugs when the time they represent matches \"\n            \"midnight UTC. This behaviour was fixed in Python 3.5. \"\n            \"See https://bugs.python.org/issue13936 for reference.\",\n            {\"maxversion\": (3, 5)},\n",
                    "rendered": {
                      "text": "            \"Using datetime.time in a boolean context.\",\n            \"boolean-datetime\",\n            \"Using datetime.time in a boolean context can hide \"\n            \"subtle bugs when the time they represent matches \"\n            \"midnight UTC. This behaviour was fixed in Python 3.5. \"\n            \"See https://bugs.python.org/issue13936 for reference.\",\n            {\"maxversion\": (3, 5)},\n",
                      "markdown": "`            \"Using datetime.time in a boolean context.\",\n            \"boolean-datetime\",\n            \"Using datetime.time in a boolean context can hide \"\n            \"subtle bugs when the time they represent matches \"\n            \"midnight UTC. This behaviour was fixed in Python 3.5. \"\n            \"See https://bugs.python.org/issue13936 for reference.\",\n            {\"maxversion\": (3, 5)},\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/spelling.py"
                },
                "region": {
                  "startLine": 349,
                  "startColumn": 63,
                  "endLine": 349,
                  "endColumn": 67,
                  "snippet": {
                    "text": "            initial_space = 0\n        if line.strip().startswith(\"#\") and \"docstring\" not in msgid:\n            line = line.strip()[1:]\n            # A ``Filter`` cannot determine if the directive is at the beginning of a line,\n            #   nor determine if a colon is present or not (``pyenchant`` strips trailing colons).\n            #   So implementing this here.\n            for iter_directive in self.ignore_comment_directive_list:\n",
                    "rendered": {
                      "text": "            initial_space = 0\n        if line.strip().startswith(\"#\") and \"docstring\" not in msgid:\n            line = line.strip()[1:]\n            # A ``Filter`` cannot determine if the directive is at the beginning of a line,\n            #   nor determine if a colon is present or not (``pyenchant`` strips trailing colons).\n            #   So implementing this here.\n            for iter_directive in self.ignore_comment_directive_list:\n",
                      "markdown": "`            initial_space = 0\n        if line.strip().startswith(\"#\") and \"docstring\" not in msgid:\n            line = line.strip()[1:]\n            # A ``Filter`` cannot determine if the directive is at the beginning of a line,\n            #   nor determine if a colon is present or not (``pyenchant`` strips trailing colons).\n            #   So implementing this here.\n            for iter_directive in self.ignore_comment_directive_list:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/spelling.py"
                },
                "region": {
                  "startLine": 288,
                  "startColumn": 42,
                  "endLine": 288,
                  "endColumn": 46,
                  "snippet": {
                    "text": "                \"type\": \"string\",\n                \"metavar\": \"<comma separated words>\",\n                \"help\": \"List of comma separated words that should be considered \"\n                \"directives if they appear at the beginning of a comment \"\n                \"and should not be checked.\",\n            },\n        ),\n",
                    "rendered": {
                      "text": "                \"type\": \"string\",\n                \"metavar\": \"<comma separated words>\",\n                \"help\": \"List of comma separated words that should be considered \"\n                \"directives if they appear at the beginning of a comment \"\n                \"and should not be checked.\",\n            },\n        ),\n",
                      "markdown": "`                \"type\": \"string\",\n                \"metavar\": \"<comma separated words>\",\n                \"help\": \"List of comma separated words that should be considered \"\n                \"directives if they appear at the beginning of a comment \"\n                \"and should not be checked.\",\n            },\n        ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/spelling.py"
                },
                "region": {
                  "startLine": 196,
                  "startColumn": 26,
                  "endLine": 196,
                  "endColumn": 30,
                  "snippet": {
                    "text": "    \"\"\"Alter line so code flanked in back-ticks is ignored.\n\n    Pyenchant automatically strips back-ticks when parsing tokens,\n    so this cannot be done at the individual filter level.\n    \"\"\"\n\n    def replace_code_but_leave_surrounding_characters(match_obj: re.Match[str]) -> str:\n",
                    "rendered": {
                      "text": "    \"\"\"Alter line so code flanked in back-ticks is ignored.\n\n    Pyenchant automatically strips back-ticks when parsing tokens,\n    so this cannot be done at the individual filter level.\n    \"\"\"\n\n    def replace_code_but_leave_surrounding_characters(match_obj: re.Match[str]) -> str:\n",
                      "markdown": "`    \"\"\"Alter line so code flanked in back-ticks is ignored.\n\n    Pyenchant automatically strips back-ticks when parsing tokens,\n    so this cannot be done at the individual filter level.\n    \"\"\"\n\n    def replace_code_but_leave_surrounding_characters(match_obj: re.Match[str]) -> str:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/spelling.py"
                },
                "region": {
                  "startLine": 462,
                  "startColumn": 23,
                  "endLine": 462,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            nodes.FunctionDef | nodes.AsyncFunctionDef | nodes.ClassDef | nodes.Module\n        ),\n    ) -> None:\n        \"\"\"Check if the node has any spelling errors.\"\"\"\n        if not self.initialized:\n            return\n        if not node.doc_node:\n",
                    "rendered": {
                      "text": "            nodes.FunctionDef | nodes.AsyncFunctionDef | nodes.ClassDef | nodes.Module\n        ),\n    ) -> None:\n        \"\"\"Check if the node has any spelling errors.\"\"\"\n        if not self.initialized:\n            return\n        if not node.doc_node:\n",
                      "markdown": "`            nodes.FunctionDef | nodes.AsyncFunctionDef | nodes.ClassDef | nodes.Module\n        ),\n    ) -> None:\n        \"\"\"Check if the node has any spelling errors.\"\"\"\n        if not self.initialized:\n            return\n        if not node.doc_node:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base_checker.py"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 32,
                  "endLine": 38,
                  "endColumn": 41,
                  "snippet": {
                    "text": "class BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n",
                    "rendered": {
                      "text": "class BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n",
                      "markdown": "`class BaseChecker(_ArgumentsProvider):\n    # checker name (you may reuse an existing one)\n    name: str = \"\"\n    # ordered list of options to control the checker behaviour\n    options: Options = ()\n    # messages issued by this checker\n    msgs: dict[str, MessageDefinitionTuple] = {}\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/utils.py"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 36,
                  "endLine": 57,
                  "endColumn": 41,
                  "snippet": {
                    "text": "def _test_environ_pythonpath(\n    new_pythonpath: str | None = None,\n) -> Generator[None]:\n    original_pythonpath = os.environ.get(\"PYTHONPATH\")\n    if new_pythonpath:\n        os.environ[\"PYTHONPATH\"] = new_pythonpath\n    elif new_pythonpath is None and original_pythonpath is not None:\n",
                    "rendered": {
                      "text": "def _test_environ_pythonpath(\n    new_pythonpath: str | None = None,\n) -> Generator[None]:\n    original_pythonpath = os.environ.get(\"PYTHONPATH\")\n    if new_pythonpath:\n        os.environ[\"PYTHONPATH\"] = new_pythonpath\n    elif new_pythonpath is None and original_pythonpath is not None:\n",
                      "markdown": "`def _test_environ_pythonpath(\n    new_pythonpath: str | None = None,\n) -> Generator[None]:\n    original_pythonpath = os.environ.get(\"PYTHONPATH\")\n    if new_pythonpath:\n        os.environ[\"PYTHONPATH\"] = new_pythonpath\n    elif new_pythonpath is None and original_pythonpath is not None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/utils.py"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 29,
                  "endLine": 57,
                  "endColumn": 40,
                  "snippet": {
                    "text": "def _test_environ_pythonpath(\n    new_pythonpath: str | None = None,\n) -> Generator[None]:\n    original_pythonpath = os.environ.get(\"PYTHONPATH\")\n    if new_pythonpath:\n        os.environ[\"PYTHONPATH\"] = new_pythonpath\n    elif new_pythonpath is None and original_pythonpath is not None:\n",
                    "rendered": {
                      "text": "def _test_environ_pythonpath(\n    new_pythonpath: str | None = None,\n) -> Generator[None]:\n    original_pythonpath = os.environ.get(\"PYTHONPATH\")\n    if new_pythonpath:\n        os.environ[\"PYTHONPATH\"] = new_pythonpath\n    elif new_pythonpath is None and original_pythonpath is not None:\n",
                      "markdown": "`def _test_environ_pythonpath(\n    new_pythonpath: str | None = None,\n) -> Generator[None]:\n    original_pythonpath = os.environ.get(\"PYTHONPATH\")\n    if new_pythonpath:\n        os.environ[\"PYTHONPATH\"] = new_pythonpath\n    elif new_pythonpath is None and original_pythonpath is not None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/unittest_linter.py"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 36,
                  "endLine": 48,
                  "endColumn": 42,
                  "snippet": {
                    "text": "        if confidence is None:\n            confidence = UNDEFINED\n\n        # Look up \"location\" data of node if not yet supplied\n        if node:\n            if node.position:\n                if not line:\n",
                    "rendered": {
                      "text": "        if confidence is None:\n            confidence = UNDEFINED\n\n        # Look up \"location\" data of node if not yet supplied\n        if node:\n            if node.position:\n                if not line:\n",
                      "markdown": "`        if confidence is None:\n            confidence = UNDEFINED\n\n        # Look up \"location\" data of node if not yet supplied\n        if node:\n            if node.position:\n                if not line:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/unittest_linter.py"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 20,
                  "endLine": 35,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        self,\n        msgid: str,\n        line: int | None = None,\n        # TODO: Make node non optional\n        node: nodes.NodeNG | None = None,\n        args: Any = None,\n        confidence: Confidence | None = None,\n",
                    "rendered": {
                      "text": "        self,\n        msgid: str,\n        line: int | None = None,\n        # TODO: Make node non optional\n        node: nodes.NodeNG | None = None,\n        args: Any = None,\n        confidence: Confidence | None = None,\n",
                      "markdown": "`        self,\n        msgid: str,\n        line: int | None = None,\n        # TODO: Make node non optional\n        node: nodes.NodeNG | None = None,\n        args: Any = None,\n        confidence: Confidence | None = None,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/interfaces.py"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 55,
                  "endLine": 28,
                  "endColumn": 64,
                  "snippet": {
                    "text": "# Warning Certainties\nHIGH = Confidence(\"HIGH\", \"Warning that is not based on inference result.\")\nCONTROL_FLOW = Confidence(\n    \"CONTROL_FLOW\", \"Warning based on assumptions about control flow.\"\n)\nINFERENCE = Confidence(\"INFERENCE\", \"Warning based on inference result.\")\nINFERENCE_FAILURE = Confidence(\n",
                    "rendered": {
                      "text": "# Warning Certainties\nHIGH = Confidence(\"HIGH\", \"Warning that is not based on inference result.\")\nCONTROL_FLOW = Confidence(\n    \"CONTROL_FLOW\", \"Warning based on assumptions about control flow.\"\n)\nINFERENCE = Confidence(\"INFERENCE\", \"Warning based on inference result.\")\nINFERENCE_FAILURE = Confidence(\n",
                      "markdown": "`# Warning Certainties\nHIGH = Confidence(\"HIGH\", \"Warning that is not based on inference result.\")\nCONTROL_FLOW = Confidence(\n    \"CONTROL_FLOW\", \"Warning based on assumptions about control flow.\"\n)\nINFERENCE = Confidence(\"INFERENCE\", \"Warning based on inference result.\")\nINFERENCE_FAILURE = Confidence(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/graph.py"
                },
                "region": {
                  "startLine": 207,
                  "startColumn": 14,
                  "endLine": 207,
                  "endColumn": 20,
                  "snippet": {
                    "text": "    try:\n        for node in graph_dict[vertice]:\n            # don't check already visited nodes again\n            if node not in visited:\n                _get_cycles(graph_dict, path, visited, result, node)\n                visited.add(node)\n    except KeyError:\n",
                    "rendered": {
                      "text": "    try:\n        for node in graph_dict[vertice]:\n            # don't check already visited nodes again\n            if node not in visited:\n                _get_cycles(graph_dict, path, visited, result, node)\n                visited.add(node)\n    except KeyError:\n",
                      "markdown": "`    try:\n        for node in graph_dict[vertice]:\n            # don't check already visited nodes again\n            if node not in visited:\n                _get_cycles(graph_dict, path, visited, result, node)\n                visited.add(node)\n    except KeyError:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/graph.py"
                },
                "region": {
                  "startLine": 205,
                  "startColumn": 11,
                  "endLine": 205,
                  "endColumn": 17,
                  "snippet": {
                    "text": "        return\n    path.append(vertice)\n    try:\n        for node in graph_dict[vertice]:\n            # don't check already visited nodes again\n            if node not in visited:\n                _get_cycles(graph_dict, path, visited, result, node)\n",
                    "rendered": {
                      "text": "        return\n    path.append(vertice)\n    try:\n        for node in graph_dict[vertice]:\n            # don't check already visited nodes again\n            if node not in visited:\n                _get_cycles(graph_dict, path, visited, result, node)\n",
                      "markdown": "`        return\n    path.append(vertice)\n    try:\n        for node in graph_dict[vertice]:\n            # don't check already visited nodes again\n            if node not in visited:\n                _get_cycles(graph_dict, path, visited, result, node)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/graph.py"
                },
                "region": {
                  "startLine": 192,
                  "startColumn": 14,
                  "endLine": 192,
                  "endColumn": 20,
                  "snippet": {
                    "text": "    if vertice in path:\n        cycle = [vertice]\n        for node in path[::-1]:\n            if node == vertice:\n                break\n            cycle.insert(0, node)\n        # make a canonical representation\n",
                    "rendered": {
                      "text": "    if vertice in path:\n        cycle = [vertice]\n        for node in path[::-1]:\n            if node == vertice:\n                break\n            cycle.insert(0, node)\n        # make a canonical representation\n",
                      "markdown": "`    if vertice in path:\n        cycle = [vertice]\n        for node in path[::-1]:\n            if node == vertice:\n                break\n            cycle.insert(0, node)\n        # make a canonical representation\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/graph.py"
                },
                "region": {
                  "startLine": 191,
                  "startColumn": 11,
                  "endLine": 191,
                  "endColumn": 17,
                  "snippet": {
                    "text": "    \"\"\"Recursive function doing the real work for get_cycles.\"\"\"\n    if vertice in path:\n        cycle = [vertice]\n        for node in path[::-1]:\n            if node == vertice:\n                break\n            cycle.insert(0, node)\n",
                    "rendered": {
                      "text": "    \"\"\"Recursive function doing the real work for get_cycles.\"\"\"\n    if vertice in path:\n        cycle = [vertice]\n        for node in path[::-1]:\n            if node == vertice:\n                break\n            cycle.insert(0, node)\n",
                      "markdown": "`    \"\"\"Recursive function doing the real work for get_cycles.\"\"\"\n    if vertice in path:\n        cycle = [vertice]\n        for node in path[::-1]:\n            if node == vertice:\n                break\n            cycle.insert(0, node)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/graph.py"
                },
                "region": {
                  "startLine": 161,
                  "startColumn": 29,
                  "endLine": 161,
                  "endColumn": 35,
                  "snippet": {
                    "text": "\n\ndef normalize_node_id(nid: str) -> str:\n    \"\"\"Returns a suitable DOT node id for `nid`.\"\"\"\n    return f'\"{nid}\"'\n\n\n",
                    "rendered": {
                      "text": "\n\ndef normalize_node_id(nid: str) -> str:\n    \"\"\"Returns a suitable DOT node id for `nid`.\"\"\"\n    return f'\"{nid}\"'\n\n\n",
                      "markdown": "`\n\ndef normalize_node_id(nid: str) -> str:\n    \"\"\"Returns a suitable DOT node id for `nid`.\"\"\"\n    return f'\"{nid}\"'\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/graph.py"
                },
                "region": {
                  "startLine": 154,
                  "startColumn": 11,
                  "endLine": 154,
                  "endColumn": 17,
                  "snippet": {
                    "text": "    def emit_node(self, name: str, **props: Any) -> None:\n        \"\"\"Emit a node with given properties.\n\n        For node properties: see https://www.graphviz.org/doc/info/attrs.html\n        \"\"\"\n        attrs = [f'{prop}=\"{value}\"' for prop, value in props.items()]\n        self.emit(f\"{normalize_node_id(name)} [{', '.join(sorted(attrs))}];\")\n",
                    "rendered": {
                      "text": "    def emit_node(self, name: str, **props: Any) -> None:\n        \"\"\"Emit a node with given properties.\n\n        For node properties: see https://www.graphviz.org/doc/info/attrs.html\n        \"\"\"\n        attrs = [f'{prop}=\"{value}\"' for prop, value in props.items()]\n        self.emit(f\"{normalize_node_id(name)} [{', '.join(sorted(attrs))}];\")\n",
                      "markdown": "`    def emit_node(self, name: str, **props: Any) -> None:\n        \"\"\"Emit a node with given properties.\n\n        For node properties: see https://www.graphviz.org/doc/info/attrs.html\n        \"\"\"\n        attrs = [f'{prop}=\"{value}\"' for prop, value in props.items()]\n        self.emit(f\"{normalize_node_id(name)} [{', '.join(sorted(attrs))}];\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/graph.py"
                },
                "region": {
                  "startLine": 152,
                  "startColumn": 17,
                  "endLine": 152,
                  "endColumn": 23,
                  "snippet": {
                    "text": "        self.emit(f\"{n_from} -> {n_to} [{', '.join(sorted(attrs))}];\")\n\n    def emit_node(self, name: str, **props: Any) -> None:\n        \"\"\"Emit a node with given properties.\n\n        For node properties: see https://www.graphviz.org/doc/info/attrs.html\n        \"\"\"\n",
                    "rendered": {
                      "text": "        self.emit(f\"{n_from} -> {n_to} [{', '.join(sorted(attrs))}];\")\n\n    def emit_node(self, name: str, **props: Any) -> None:\n        \"\"\"Emit a node with given properties.\n\n        For node properties: see https://www.graphviz.org/doc/info/attrs.html\n        \"\"\"\n",
                      "markdown": "`        self.emit(f\"{n_from} -> {n_to} [{', '.join(sorted(attrs))}];\")\n\n    def emit_node(self, name: str, **props: Any) -> None:\n        \"\"\"Emit a node with given properties.\n\n        For node properties: see https://www.graphviz.org/doc/info/attrs.html\n        \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/typing.py"
                },
                "region": {
                  "startLine": 383,
                  "startColumn": 41,
                  "endLine": 383,
                  "endColumn": 46,
                  "snippet": {
                    "text": "        inferred = safe_infer(node)\n        if not isinstance(inferred, nodes.ClassDef):\n            return\n        alias = DEPRECATED_TYPING_ALIASES.get(inferred.qname(), None)\n        if alias is None:\n            return\n\n",
                    "rendered": {
                      "text": "        inferred = safe_infer(node)\n        if not isinstance(inferred, nodes.ClassDef):\n            return\n        alias = DEPRECATED_TYPING_ALIASES.get(inferred.qname(), None)\n        if alias is None:\n            return\n\n",
                      "markdown": "`        inferred = safe_infer(node)\n        if not isinstance(inferred, nodes.ClassDef):\n            return\n        alias = DEPRECATED_TYPING_ALIASES.get(inferred.qname(), None)\n        if alias is None:\n            return\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/typing.py"
                },
                "region": {
                  "startLine": 499,
                  "startColumn": 19,
                  "endLine": 499,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        self.add_message(\"broken-collections-callable\", node=node, confidence=INFERENCE)\n\n    def _broken_callable_location(self, node: nodes.Name | nodes.Attribute) -> bool:\n        \"\"\"Check if node would be a broken location for collections.abc.Callable.\"\"\"\n        if (\n            in_type_checking_block(node)\n            or is_postponed_evaluation_enabled(node)\n",
                    "rendered": {
                      "text": "        self.add_message(\"broken-collections-callable\", node=node, confidence=INFERENCE)\n\n    def _broken_callable_location(self, node: nodes.Name | nodes.Attribute) -> bool:\n        \"\"\"Check if node would be a broken location for collections.abc.Callable.\"\"\"\n        if (\n            in_type_checking_block(node)\n            or is_postponed_evaluation_enabled(node)\n",
                      "markdown": "`        self.add_message(\"broken-collections-callable\", node=node, confidence=INFERENCE)\n\n    def _broken_callable_location(self, node: nodes.Name | nodes.Attribute) -> bool:\n        \"\"\"Check if node would be a broken location for collections.abc.Callable.\"\"\"\n        if (\n            in_type_checking_block(node)\n            or is_postponed_evaluation_enabled(node)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/typing.py"
                },
                "region": {
                  "startLine": 389,
                  "startColumn": 15,
                  "endLine": 390,
                  "snippet": {
                    "text": "\n        if self._py39_plus:\n            if inferred.qname() == \"typing.Callable\" and self._broken_callable_location(\n                node\n            ):\n                self._found_broken_callable_location = True\n            self._deprecated_typing_alias_msgs.append(\n                DeprecatedTypingAliasMsg(\n",
                    "rendered": {
                      "text": "\n        if self._py39_plus:\n            if inferred.qname() == \"typing.Callable\" and self._broken_callable_location(\n                node\n            ):\n                self._found_broken_callable_location = True\n            self._deprecated_typing_alias_msgs.append(\n                DeprecatedTypingAliasMsg(\n",
                      "markdown": "`\n        if self._py39_plus:\n            if inferred.qname() == \"typing.Callable\" and self._broken_callable_location(\n                node\n            ):\n                self._found_broken_callable_location = True\n            self._deprecated_typing_alias_msgs.append(\n                DeprecatedTypingAliasMsg(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/redefined_variable_type.py"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 3,
                  "endLine": 21,
                  "endColumn": 7,
                  "snippet": {
                    "text": "class MultipleTypesChecker(BaseChecker):\n    \"\"\"Checks for variable type redefinition (NoneType excepted).\n\n    At a function, method, class or module scope\n\n    This rule could be improved:\n\n",
                    "rendered": {
                      "text": "class MultipleTypesChecker(BaseChecker):\n    \"\"\"Checks for variable type redefinition (NoneType excepted).\n\n    At a function, method, class or module scope\n\n    This rule could be improved:\n\n",
                      "markdown": "`class MultipleTypesChecker(BaseChecker):\n    \"\"\"Checks for variable type redefinition (NoneType excepted).\n\n    At a function, method, class or module scope\n\n    This rule could be improved:\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/redefined_loop_name.py"
                },
                "region": {
                  "startLine": 70,
                  "startColumn": 30,
                  "endLine": 71,
                  "snippet": {
                    "text": "                if node_scope is not outer_for_scope:\n                    continue\n                if variable in outer_variables and not utils.in_for_else_branch(\n                    outer_for, node\n                ):\n                    self.add_message(\n                        \"redefined-loop-name\",\n                        args=(variable, outer_for.fromlineno),\n",
                    "rendered": {
                      "text": "                if node_scope is not outer_for_scope:\n                    continue\n                if variable in outer_variables and not utils.in_for_else_branch(\n                    outer_for, node\n                ):\n                    self.add_message(\n                        \"redefined-loop-name\",\n                        args=(variable, outer_for.fromlineno),\n",
                      "markdown": "`                if node_scope is not outer_for_scope:\n                    continue\n                if variable in outer_variables and not utils.in_for_else_branch(\n                    outer_for, node\n                ):\n                    self.add_message(\n                        \"redefined-loop-name\",\n                        args=(variable, outer_for.fromlineno),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/redefined_loop_name.py"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 26,
                  "endLine": 45,
                  "snippet": {
                    "text": "            if node_scope is not outer_for_scope:\n                continue\n            if node.name in outer_variables and not utils.in_for_else_branch(\n                outer_for, node\n            ):\n                self.add_message(\n                    \"redefined-loop-name\",\n                    args=(node.name, outer_for.fromlineno),\n",
                    "rendered": {
                      "text": "            if node_scope is not outer_for_scope:\n                continue\n            if node.name in outer_variables and not utils.in_for_else_branch(\n                outer_for, node\n            ):\n                self.add_message(\n                    \"redefined-loop-name\",\n                    args=(node.name, outer_for.fromlineno),\n",
                      "markdown": "`            if node_scope is not outer_for_scope:\n                continue\n            if node.name in outer_variables and not utils.in_for_else_branch(\n                outer_for, node\n            ):\n                self.add_message(\n                    \"redefined-loop-name\",\n                    args=(node.name, outer_for.fromlineno),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/private_import.py"
                },
                "region": {
                  "startLine": 177,
                  "startColumn": 20,
                  "endLine": 177,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        self, node: nodes.FunctionDef, all_used_type_annotations: dict[str, bool]\n    ) -> None:\n        \"\"\"Adds all names used as type annotation in the arguments and return type of\n        the function node into the dict `all_used_type_annotations`.\n        \"\"\"\n        if node.args and node.args.annotations:\n            for annotation in node.args.annotations:\n",
                    "rendered": {
                      "text": "        self, node: nodes.FunctionDef, all_used_type_annotations: dict[str, bool]\n    ) -> None:\n        \"\"\"Adds all names used as type annotation in the arguments and return type of\n        the function node into the dict `all_used_type_annotations`.\n        \"\"\"\n        if node.args and node.args.annotations:\n            for annotation in node.args.annotations:\n",
                      "markdown": "`        self, node: nodes.FunctionDef, all_used_type_annotations: dict[str, bool]\n    ) -> None:\n        \"\"\"Adds all names used as type annotation in the arguments and return type of\n        the function node into the dict `all_used_type_annotations`.\n        \"\"\"\n        if node.args and node.args.annotations:\n            for annotation in node.args.annotations:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/private_import.py"
                },
                "region": {
                  "startLine": 141,
                  "startColumn": 19,
                  "endLine": 141,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        in the node's (nested) scopes and whether they are only used as annotation.\n        \"\"\"\n        for name in node.locals:\n            # If we find a private type annotation, make sure we do not mask illegal usages\n            private_name = None\n            # All the assignments using this variable that we might have to check for\n            # illegal usages later\n",
                    "rendered": {
                      "text": "        in the node's (nested) scopes and whether they are only used as annotation.\n        \"\"\"\n        for name in node.locals:\n            # If we find a private type annotation, make sure we do not mask illegal usages\n            private_name = None\n            # All the assignments using this variable that we might have to check for\n            # illegal usages later\n",
                      "markdown": "`        in the node's (nested) scopes and whether they are only used as annotation.\n        \"\"\"\n        for name in node.locals:\n            # If we find a private type annotation, make sure we do not mask illegal usages\n            private_name = None\n            # All the assignments using this variable that we might have to check for\n            # illegal usages later\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/mccabe.py"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 26,
                  "endLine": 67,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    def dispatch(self, node: nodes.NodeNG, *args: Any) -> Any:\n        self.node = node\n        klass = node.__class__\n        meth = self._cache.get(klass)\n        if meth is None:\n            class_name = klass.__name__\n            meth = getattr(self.visitor, \"visit\" + class_name, self.default)\n",
                    "rendered": {
                      "text": "    def dispatch(self, node: nodes.NodeNG, *args: Any) -> Any:\n        self.node = node\n        klass = node.__class__\n        meth = self._cache.get(klass)\n        if meth is None:\n            class_name = klass.__name__\n            meth = getattr(self.visitor, \"visit\" + class_name, self.default)\n",
                      "markdown": "`    def dispatch(self, node: nodes.NodeNG, *args: Any) -> Any:\n        self.node = node\n        klass = node.__class__\n        meth = self._cache.get(klass)\n        if meth is None:\n            class_name = klass.__name__\n            meth = getattr(self.visitor, \"visit\" + class_name, self.default)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/mccabe.py"
                },
                "region": {
                  "startLine": 199,
                  "startColumn": 11,
                  "endLine": 199,
                  "endColumn": 17,
                  "snippet": {
                    "text": "            visitor.preorder(child, visitor)\n        for graph in visitor.graphs.values():\n            complexity = graph.complexity()\n            node = graph.root\n            if hasattr(node, \"name\"):\n                node_name = f\"'{node.name}'\"\n            else:\n",
                    "rendered": {
                      "text": "            visitor.preorder(child, visitor)\n        for graph in visitor.graphs.values():\n            complexity = graph.complexity()\n            node = graph.root\n            if hasattr(node, \"name\"):\n                node_name = f\"'{node.name}'\"\n            else:\n",
                      "markdown": "`            visitor.preorder(child, visitor)\n        for graph in visitor.graphs.values():\n            complexity = graph.complexity()\n            node = graph.root\n            if hasattr(node, \"name\"):\n                node_name = f\"'{node.name}'\"\n            else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/mccabe.py"
                },
                "region": {
                  "startLine": 191,
                  "startColumn": 34,
                  "endLine": 191,
                  "endColumn": 40,
                  "snippet": {
                    "text": "\n    @only_required_for_messages(\"too-complex\")\n    def visit_module(self, node: nodes.Module) -> None:\n        \"\"\"Visit an astroid.Module node to check too complex rating and\n        add message if is greater than max_complexity stored from options.\n        \"\"\"\n        visitor = PathGraphingAstVisitor()\n",
                    "rendered": {
                      "text": "\n    @only_required_for_messages(\"too-complex\")\n    def visit_module(self, node: nodes.Module) -> None:\n        \"\"\"Visit an astroid.Module node to check too complex rating and\n        add message if is greater than max_complexity stored from options.\n        \"\"\"\n        visitor = PathGraphingAstVisitor()\n",
                      "markdown": "`\n    @only_required_for_messages(\"too-complex\")\n    def visit_module(self, node: nodes.Module) -> None:\n        \"\"\"Visit an astroid.Module node to check too complex rating and\n        add message if is greater than max_complexity stored from options.\n        \"\"\"\n        visitor = PathGraphingAstVisitor()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/mccabe.py"
                },
                "region": {
                  "startLine": 154,
                  "startColumn": 10,
                  "endLine": 154,
                  "endColumn": 16,
                  "snippet": {
                    "text": "            loose_ends.append(self.tail)\n        else:\n            loose_ends.append(node)\n        if node and self.graph:\n            bottom = f\"{self._bottom_counter}\"\n            self._bottom_counter += 1\n            for end in loose_ends:\n",
                    "rendered": {
                      "text": "            loose_ends.append(self.tail)\n        else:\n            loose_ends.append(node)\n        if node and self.graph:\n            bottom = f\"{self._bottom_counter}\"\n            self._bottom_counter += 1\n            for end in loose_ends:\n",
                      "markdown": "`            loose_ends.append(self.tail)\n        else:\n            loose_ends.append(node)\n        if node and self.graph:\n            bottom = f\"{self._bottom_counter}\"\n            self._bottom_counter += 1\n            for end in loose_ends:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/mccabe.py"
                },
                "region": {
                  "startLine": 149,
                  "startColumn": 23,
                  "endLine": 150,
                  "snippet": {
                    "text": "            self.dispatch_list(extra.body)\n            loose_ends.append(self.tail)\n        if node.orelse:\n            self.tail = node\n            self.dispatch_list(node.orelse)\n            loose_ends.append(self.tail)\n        else:\n            loose_ends.append(node)\n",
                    "rendered": {
                      "text": "            self.dispatch_list(extra.body)\n            loose_ends.append(self.tail)\n        if node.orelse:\n            self.tail = node\n            self.dispatch_list(node.orelse)\n            loose_ends.append(self.tail)\n        else:\n            loose_ends.append(node)\n",
                      "markdown": "`            self.dispatch_list(extra.body)\n            loose_ends.append(self.tail)\n        if node.orelse:\n            self.tail = node\n            self.dispatch_list(node.orelse)\n            loose_ends.append(self.tail)\n        else:\n            loose_ends.append(node)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/mccabe.py"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 23,
                  "endLine": 146,
                  "snippet": {
                    "text": "        self.dispatch_list(node.body)\n        loose_ends.append(self.tail)\n        for extra in extra_blocks:\n            self.tail = node\n            self.dispatch_list(extra.body)\n            loose_ends.append(self.tail)\n        if node.orelse:\n            self.tail = node\n",
                    "rendered": {
                      "text": "        self.dispatch_list(node.body)\n        loose_ends.append(self.tail)\n        for extra in extra_blocks:\n            self.tail = node\n            self.dispatch_list(extra.body)\n            loose_ends.append(self.tail)\n        if node.orelse:\n            self.tail = node\n",
                      "markdown": "`        self.dispatch_list(node.body)\n        loose_ends.append(self.tail)\n        for extra in extra_blocks:\n            self.tail = node\n            self.dispatch_list(extra.body)\n            loose_ends.append(self.tail)\n        if node.orelse:\n            self.tail = node\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/mccabe.py"
                },
                "region": {
                  "startLine": 141,
                  "startColumn": 19,
                  "endLine": 142,
                  "snippet": {
                    "text": "    ) -> None:\n        \"\"\"Parse the body and any `else` block of `if` and `for` statements.\"\"\"\n        loose_ends = []\n        self.tail = node\n        self.dispatch_list(node.body)\n        loose_ends.append(self.tail)\n        for extra in extra_blocks:\n            self.tail = node\n",
                    "rendered": {
                      "text": "    ) -> None:\n        \"\"\"Parse the body and any `else` block of `if` and `for` statements.\"\"\"\n        loose_ends = []\n        self.tail = node\n        self.dispatch_list(node.body)\n        loose_ends.append(self.tail)\n        for extra in extra_blocks:\n            self.tail = node\n",
                      "markdown": "`    ) -> None:\n        \"\"\"Parse the body and any `else` block of `if` and `for` statements.\"\"\"\n        loose_ends = []\n        self.tail = node\n        self.dispatch_list(node.body)\n        loose_ends.append(self.tail)\n        for extra in extra_blocks:\n            self.tail = node\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/mccabe.py"
                },
                "region": {
                  "startLine": 114,
                  "startColumn": 14,
                  "endLine": 115,
                  "snippet": {
                    "text": "            return None\n        self.graph.connect(self.tail, node)\n        self.tail = node\n        return node\n\n    def _subgraph(\n        self,\n        node: _SubGraphNodes,\n",
                    "rendered": {
                      "text": "            return None\n        self.graph.connect(self.tail, node)\n        self.tail = node\n        return node\n\n    def _subgraph(\n        self,\n        node: _SubGraphNodes,\n",
                      "markdown": "`            return None\n        self.graph.connect(self.tail, node)\n        self.tail = node\n        return node\n\n    def _subgraph(\n        self,\n        node: _SubGraphNodes,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/mccabe.py"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 19,
                  "endLine": 114,
                  "snippet": {
                    "text": "        if not self.tail or not self.graph:\n            return None\n        self.graph.connect(self.tail, node)\n        self.tail = node\n        return node\n\n    def _subgraph(\n        self,\n",
                    "rendered": {
                      "text": "        if not self.tail or not self.graph:\n            return None\n        self.graph.connect(self.tail, node)\n        self.tail = node\n        return node\n\n    def _subgraph(\n        self,\n",
                      "markdown": "`        if not self.tail or not self.graph:\n            return None\n        self.graph.connect(self.tail, node)\n        self.tail = node\n        return node\n\n    def _subgraph(\n        self,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/mccabe.py"
                },
                "region": {
                  "startLine": 87,
                  "startColumn": 23,
                  "endLine": 88,
                  "snippet": {
                    "text": "            self.tail = bottom\n        else:\n            self.graph = PathGraph(node)\n            self.tail = node\n            self.dispatch_list(node.body)\n            self.graphs[f\"{self.classname}{node.name}\"] = self.graph\n            self.reset()\n\n",
                    "rendered": {
                      "text": "            self.tail = bottom\n        else:\n            self.graph = PathGraph(node)\n            self.tail = node\n            self.dispatch_list(node.body)\n            self.graphs[f\"{self.classname}{node.name}\"] = self.graph\n            self.reset()\n\n",
                      "markdown": "`            self.tail = bottom\n        else:\n            self.graph = PathGraph(node)\n            self.tail = node\n            self.dispatch_list(node.body)\n            self.graphs[f\"{self.classname}{node.name}\"] = self.graph\n            self.reset()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/mccabe.py"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 19,
                  "endLine": 66,
                  "snippet": {
                    "text": "            self.dispatch(child, *args)\n\n    def dispatch(self, node: nodes.NodeNG, *args: Any) -> Any:\n        self.node = node\n        klass = node.__class__\n        meth = self._cache.get(klass)\n        if meth is None:\n            class_name = klass.__name__\n",
                    "rendered": {
                      "text": "            self.dispatch(child, *args)\n\n    def dispatch(self, node: nodes.NodeNG, *args: Any) -> Any:\n        self.node = node\n        klass = node.__class__\n        meth = self._cache.get(klass)\n        if meth is None:\n            class_name = klass.__name__\n",
                      "markdown": "`            self.dispatch(child, *args)\n\n    def dispatch(self, node: nodes.NodeNG, *args: Any) -> Any:\n        self.node = node\n        klass = node.__class__\n        meth = self._cache.get(klass)\n        if meth is None:\n            class_name = klass.__name__\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/mccabe.py"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 19,
                  "endLine": 52,
                  "snippet": {
                    "text": "class PathGraph(Mccabe_PathGraph):  # type: ignore[misc]\n    def __init__(self, node: _SubGraphNodes | nodes.FunctionDef):\n        super().__init__(name=\"\", entity=\"\", lineno=1)\n        self.root = node\n\n\nclass PathGraphingAstVisitor(Mccabe_PathGraphingAstVisitor):  # type: ignore[misc]\n    def __init__(self) -> None:\n",
                    "rendered": {
                      "text": "class PathGraph(Mccabe_PathGraph):  # type: ignore[misc]\n    def __init__(self, node: _SubGraphNodes | nodes.FunctionDef):\n        super().__init__(name=\"\", entity=\"\", lineno=1)\n        self.root = node\n\n\nclass PathGraphingAstVisitor(Mccabe_PathGraphingAstVisitor):  # type: ignore[misc]\n    def __init__(self) -> None:\n",
                      "markdown": "`class PathGraph(Mccabe_PathGraph):  # type: ignore[misc]\n    def __init__(self, node: _SubGraphNodes | nodes.FunctionDef):\n        super().__init__(name=\"\", entity=\"\", lineno=1)\n        self.root = node\n\n\nclass PathGraphingAstVisitor(Mccabe_PathGraphingAstVisitor):  # type: ignore[misc]\n    def __init__(self) -> None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/for_any_all.py"
                },
                "region": {
                  "startLine": 151,
                  "startColumn": 51,
                  "endLine": 151,
                  "endColumn": 57,
                  "snippet": {
                    "text": "        test_node = next(node.body[0].get_children())\n\n        if isinstance(test_node, nodes.UnaryOp) and test_node.op == \"not\":\n            # The condition is negated. Advance the node to the operand and modify the suggestion\n            test_node = test_node.operand\n            suggested_function = \"all\" if final_return_bool else \"not all\"\n        else:\n",
                    "rendered": {
                      "text": "        test_node = next(node.body[0].get_children())\n\n        if isinstance(test_node, nodes.UnaryOp) and test_node.op == \"not\":\n            # The condition is negated. Advance the node to the operand and modify the suggestion\n            test_node = test_node.operand\n            suggested_function = \"all\" if final_return_bool else \"not all\"\n        else:\n",
                      "markdown": "`        test_node = next(node.body[0].get_children())\n\n        if isinstance(test_node, nodes.UnaryOp) and test_node.op == \"not\":\n            # The condition is negated. Advance the node to the operand and modify the suggestion\n            test_node = test_node.operand\n            suggested_function = \"all\" if final_return_bool else \"not all\"\n        else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/for_any_all.py"
                },
                "region": {
                  "startLine": 140,
                  "startColumn": 27,
                  "endLine": 140,
                  "endColumn": 33,
                  "snippet": {
                    "text": "\n    @staticmethod\n    def _build_suggested_string(node: nodes.For, final_return_bool: bool) -> str:\n        \"\"\"When a nodes.For node can be rewritten as an any/all statement, return a\n        suggestion for that statement.\n\n        'final_return_bool' is the boolean literal returned after the for loop if all\n",
                    "rendered": {
                      "text": "\n    @staticmethod\n    def _build_suggested_string(node: nodes.For, final_return_bool: bool) -> str:\n        \"\"\"When a nodes.For node can be rewritten as an any/all statement, return a\n        suggestion for that statement.\n\n        'final_return_bool' is the boolean literal returned after the for loop if all\n",
                      "markdown": "`\n    @staticmethod\n    def _build_suggested_string(node: nodes.For, final_return_bool: bool) -> str:\n        \"\"\"When a nodes.For node can be rewritten as an any/all statement, return a\n        suggestion for that statement.\n\n        'final_return_bool' is the boolean literal returned after the for loop if all\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/for_any_all.py"
                },
                "region": {
                  "startLine": 120,
                  "startColumn": 43,
                  "endLine": 120,
                  "endColumn": 49,
                  "snippet": {
                    "text": "            # if-nodes inside loop aren't assignments\n            return False\n\n        # We only care for the first assign node of the if-children. Otherwise it breaks the pattern.\n        first_target = assign_children[0].targets[0]\n        target_before_loop = node_before_loop.targets[0]\n\n",
                    "rendered": {
                      "text": "            # if-nodes inside loop aren't assignments\n            return False\n\n        # We only care for the first assign node of the if-children. Otherwise it breaks the pattern.\n        first_target = assign_children[0].targets[0]\n        target_before_loop = node_before_loop.targets[0]\n\n",
                      "markdown": "`            # if-nodes inside loop aren't assignments\n            return False\n\n        # We only care for the first assign node of the if-children. Otherwise it breaks the pattern.\n        first_target = assign_children[0].targets[0]\n        target_before_loop = node_before_loop.targets[0]\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/for_any_all.py"
                },
                "region": {
                  "startLine": 112,
                  "startColumn": 13,
                  "endLine": 112,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        node_before_loop = node.previous_sibling()\n\n        if not assigned_bool(node_before_loop):\n            # node before loop isn't assigning to boolean\n            return False\n\n        assign_children = [x for x in if_children if isinstance(x, nodes.Assign)]\n",
                    "rendered": {
                      "text": "        node_before_loop = node.previous_sibling()\n\n        if not assigned_bool(node_before_loop):\n            # node before loop isn't assigning to boolean\n            return False\n\n        assign_children = [x for x in if_children if isinstance(x, nodes.Assign)]\n",
                      "markdown": "`        node_before_loop = node.previous_sibling()\n\n        if not assigned_bool(node_before_loop):\n            # node before loop isn't assigning to boolean\n            return False\n\n        assign_children = [x for x in if_children if isinstance(x, nodes.Assign)]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/for_any_all.py"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 20,
                  "endLine": 86,
                  "endColumn": 26,
                  "snippet": {
                    "text": "                return False\n        \"\"\"\n        if not len(if_children) == 2:\n            # The If node has only a comparison and return\n            return False\n        if not returns_bool(if_children[1]):\n            return False\n",
                    "rendered": {
                      "text": "                return False\n        \"\"\"\n        if not len(if_children) == 2:\n            # The If node has only a comparison and return\n            return False\n        if not returns_bool(if_children[1]):\n            return False\n",
                      "markdown": "`                return False\n        \"\"\"\n        if not len(if_children) == 2:\n            # The If node has only a comparison and return\n            return False\n        if not returns_bool(if_children[1]):\n            return False\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/for_any_all.py"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 19,
                  "endLine": 44,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n        if_children = list(node.body[0].get_children())\n        if any(isinstance(child, nodes.If) for child in if_children):\n            # an if node within the if-children indicates an elif clause,\n            # suggesting complex logic.\n            return\n\n",
                    "rendered": {
                      "text": "\n        if_children = list(node.body[0].get_children())\n        if any(isinstance(child, nodes.If) for child in if_children):\n            # an if node within the if-children indicates an elif clause,\n            # suggesting complex logic.\n            return\n\n",
                      "markdown": "`\n        if_children = list(node.body[0].get_children())\n        if any(isinstance(child, nodes.If) for child in if_children):\n            # an if node within the if-children indicates an elif clause,\n            # suggesting complex logic.\n            return\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/for_any_all.py"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 42,
                  "endLine": 37,
                  "endColumn": 48,
                  "snippet": {
                    "text": "\n    @only_required_for_messages(\"consider-using-any-or-all\")\n    def visit_for(self, node: nodes.For) -> None:\n        if len(node.body) != 1:  # Only If node with no Else\n            return\n        if not isinstance(node.body[0], nodes.If):\n            return\n",
                    "rendered": {
                      "text": "\n    @only_required_for_messages(\"consider-using-any-or-all\")\n    def visit_for(self, node: nodes.For) -> None:\n        if len(node.body) != 1:  # Only If node with no Else\n            return\n        if not isinstance(node.body[0], nodes.If):\n            return\n",
                      "markdown": "`\n    @only_required_for_messages(\"consider-using-any-or-all\")\n    def visit_for(self, node: nodes.For) -> None:\n        if len(node.body) != 1:  # Only If node with no Else\n            return\n        if not isinstance(node.body[0], nodes.If):\n            return\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/empty_comment.py"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 27,
                  "endLine": 28,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n\ndef comment_part_of_string(line: bytes, comment_idx: int) -> bool:\n    \"\"\"Checks if the symbol at comment_idx is part of a string.\"\"\"\n    if (\n        line[:comment_idx].count(b\"'\") % 2 == 1\n        and line[comment_idx:].count(b\"'\") % 2 == 1\n",
                    "rendered": {
                      "text": "\n\ndef comment_part_of_string(line: bytes, comment_idx: int) -> bool:\n    \"\"\"Checks if the symbol at comment_idx is part of a string.\"\"\"\n    if (\n        line[:comment_idx].count(b\"'\") % 2 == 1\n        and line[comment_idx:].count(b\"'\") % 2 == 1\n",
                      "markdown": "`\n\ndef comment_part_of_string(line: bytes, comment_idx: int) -> bool:\n    \"\"\"Checks if the symbol at comment_idx is part of a string.\"\"\"\n    if (\n        line[:comment_idx].count(b\"'\") % 2 == 1\n        and line[comment_idx:].count(b\"'\") % 2 == 1\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/design_analysis.py"
                },
                "region": {
                  "startLine": 494,
                  "startColumn": 39,
                  "endLine": 494,
                  "endColumn": 48,
                  "snippet": {
                    "text": "\n        # Does the class contain less than n public methods ?\n        # This checks only the methods defined in the current class,\n        # since the user might not have control over the classes\n        # from the ancestors. It avoids some false positives\n        # for classes such as unittest.TestCase, which provides\n        # a lot of assert methods. It doesn't make sense to warn\n",
                    "rendered": {
                      "text": "\n        # Does the class contain less than n public methods ?\n        # This checks only the methods defined in the current class,\n        # since the user might not have control over the classes\n        # from the ancestors. It avoids some false positives\n        # for classes such as unittest.TestCase, which provides\n        # a lot of assert methods. It doesn't make sense to warn\n",
                      "markdown": "`\n        # Does the class contain less than n public methods ?\n        # This checks only the methods defined in the current class,\n        # since the user might not have control over the classes\n        # from the ancestors. It avoids some false positives\n        # for classes such as unittest.TestCase, which provides\n        # a lot of assert methods. It doesn't make sense to warn\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/design_analysis.py"
                },
                "region": {
                  "startLine": 469,
                  "startColumn": 19,
                  "endLine": 469,
                  "endColumn": 23,
                  "snippet": {
                    "text": "                args=(nb_parents, self.linter.config.max_parents),\n            )\n\n        # Something at inference time is modifying instance_attrs to add\n        # properties from parent classes. Given how much we cache inference\n        # results, mutating instance_attrs can become a real mess. Filter\n        # them out here until the root cause is solved.\n",
                    "rendered": {
                      "text": "                args=(nb_parents, self.linter.config.max_parents),\n            )\n\n        # Something at inference time is modifying instance_attrs to add\n        # properties from parent classes. Given how much we cache inference\n        # results, mutating instance_attrs can become a real mess. Filter\n        # them out here until the root cause is solved.\n",
                      "markdown": "`                args=(nb_parents, self.linter.config.max_parents),\n            )\n\n        # Something at inference time is modifying instance_attrs to add\n        # properties from parent classes. Given how much we cache inference\n        # results, mutating instance_attrs can become a real mess. Filter\n        # them out here until the root cause is solved.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/design_analysis.py"
                },
                "region": {
                  "startLine": 674,
                  "startColumn": 19,
                  "endLine": 674,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n    def _check_boolean_expressions(self, node: nodes.If) -> None:\n        \"\"\"Go through \"if\" node `node` and count its boolean expressions\n        if the 'if' node test is a BoolOp node.\n        \"\"\"\n        condition = node.test\n        if not isinstance(condition, astroid.BoolOp):\n",
                    "rendered": {
                      "text": "\n    def _check_boolean_expressions(self, node: nodes.If) -> None:\n        \"\"\"Go through \"if\" node `node` and count its boolean expressions\n        if the 'if' node test is a BoolOp node.\n        \"\"\"\n        condition = node.test\n        if not isinstance(condition, astroid.BoolOp):\n",
                      "markdown": "`\n    def _check_boolean_expressions(self, node: nodes.If) -> None:\n        \"\"\"Go through \"if\" node `node` and count its boolean expressions\n        if the 'if' node test is a BoolOp node.\n        \"\"\"\n        condition = node.test\n        if not isinstance(condition, astroid.BoolOp):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/design_analysis.py"
                },
                "region": {
                  "startLine": 673,
                  "startColumn": 26,
                  "endLine": 673,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        self._inc_all_stmts(branches)\n\n    def _check_boolean_expressions(self, node: nodes.If) -> None:\n        \"\"\"Go through \"if\" node `node` and count its boolean expressions\n        if the 'if' node test is a BoolOp node.\n        \"\"\"\n        condition = node.test\n",
                    "rendered": {
                      "text": "        self._inc_all_stmts(branches)\n\n    def _check_boolean_expressions(self, node: nodes.If) -> None:\n        \"\"\"Go through \"if\" node `node` and count its boolean expressions\n        if the 'if' node test is a BoolOp node.\n        \"\"\"\n        condition = node.test\n",
                      "markdown": "`        self._inc_all_stmts(branches)\n\n    def _check_boolean_expressions(self, node: nodes.If) -> None:\n        \"\"\"Go through \"if\" node `node` and count its boolean expressions\n        if the 'if' node test is a BoolOp node.\n        \"\"\"\n        condition = node.test\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/design_analysis.py"
                },
                "region": {
                  "startLine": 469,
                  "startColumn": 32,
                  "endLine": 469,
                  "endColumn": 38,
                  "snippet": {
                    "text": "                args=(nb_parents, self.linter.config.max_parents),\n            )\n\n        # Something at inference time is modifying instance_attrs to add\n        # properties from parent classes. Given how much we cache inference\n        # results, mutating instance_attrs can become a real mess. Filter\n        # them out here until the root cause is solved.\n",
                    "rendered": {
                      "text": "                args=(nb_parents, self.linter.config.max_parents),\n            )\n\n        # Something at inference time is modifying instance_attrs to add\n        # properties from parent classes. Given how much we cache inference\n        # results, mutating instance_attrs can become a real mess. Filter\n        # them out here until the root cause is solved.\n",
                      "markdown": "`                args=(nb_parents, self.linter.config.max_parents),\n            )\n\n        # Something at inference time is modifying instance_attrs to add\n        # properties from parent classes. Given how much we cache inference\n        # results, mutating instance_attrs can become a real mess. Filter\n        # them out here until the root cause is solved.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/deprecated.py"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 44,
                  "endLine": 102,
                  "endColumn": 50,
                  "snippet": {
                    "text": "        \"deprecated-class\",\n    )\n    def visit_call(self, node: nodes.Call) -> None:\n        \"\"\"Called when a :class:`nodes.Call` node is visited.\"\"\"\n        self.check_deprecated_class_in_call(node)\n        for inferred in infer_all(node.func):\n            # Calling entry point for deprecation check logic.\n",
                    "rendered": {
                      "text": "        \"deprecated-class\",\n    )\n    def visit_call(self, node: nodes.Call) -> None:\n        \"\"\"Called when a :class:`nodes.Call` node is visited.\"\"\"\n        self.check_deprecated_class_in_call(node)\n        for inferred in infer_all(node.func):\n            # Calling entry point for deprecation check logic.\n",
                      "markdown": "`        \"deprecated-class\",\n    )\n    def visit_call(self, node: nodes.Call) -> None:\n        \"\"\"Called when a :class:`nodes.Call` node is visited.\"\"\"\n        self.check_deprecated_class_in_call(node)\n        for inferred in infer_all(node.func):\n            # Calling entry point for deprecation check logic.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/deprecated.py"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 45,
                  "endLine": 93,
                  "endColumn": 51,
                  "snippet": {
                    "text": "\n    @utils.only_required_for_messages(\"deprecated-attribute\")\n    def visit_attribute(self, node: astroid.Attribute) -> None:\n        \"\"\"Called when an `astroid.Attribute` node is visited.\"\"\"\n        self.check_deprecated_attribute(node)\n\n    @utils.only_required_for_messages(\n",
                    "rendered": {
                      "text": "\n    @utils.only_required_for_messages(\"deprecated-attribute\")\n    def visit_attribute(self, node: astroid.Attribute) -> None:\n        \"\"\"Called when an `astroid.Attribute` node is visited.\"\"\"\n        self.check_deprecated_attribute(node)\n\n    @utils.only_required_for_messages(\n",
                      "markdown": "`\n    @utils.only_required_for_messages(\"deprecated-attribute\")\n    def visit_attribute(self, node: astroid.Attribute) -> None:\n        \"\"\"Called when an `astroid.Attribute` node is visited.\"\"\"\n        self.check_deprecated_attribute(node)\n\n    @utils.only_required_for_messages(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/dataclass_checker.py"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 60,
                  "endLine": 96,
                  "endColumn": 66,
                  "snippet": {
                    "text": "            )\n            return\n\n        if not (isinstance(node.parent, nodes.AnnAssign) and node == node.parent.value):\n            self.add_message(\n                \"invalid-field-call\",\n                node=node,\n",
                    "rendered": {
                      "text": "            )\n            return\n\n        if not (isinstance(node.parent, nodes.AnnAssign) and node == node.parent.value):\n            self.add_message(\n                \"invalid-field-call\",\n                node=node,\n",
                      "markdown": "`            )\n            return\n\n        if not (isinstance(node.parent, nodes.AnnAssign) and node == node.parent.value):\n            self.add_message(\n                \"invalid-field-call\",\n                node=node,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/dataclass_checker.py"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 35,
                  "endLine": 22,
                  "endColumn": 41,
                  "snippet": {
                    "text": "\n\ndef _is_dataclasses_module(node: nodes.Module) -> bool:\n    \"\"\"Utility function to check if node is from dataclasses_module.\"\"\"\n    return node.name in DATACLASS_MODULES\n\n\n",
                    "rendered": {
                      "text": "\n\ndef _is_dataclasses_module(node: nodes.Module) -> bool:\n    \"\"\"Utility function to check if node is from dataclasses_module.\"\"\"\n    return node.name in DATACLASS_MODULES\n\n\n",
                      "markdown": "`\n\ndef _is_dataclasses_module(node: nodes.Module) -> bool:\n    \"\"\"Utility function to check if node is from dataclasses_module.\"\"\"\n    return node.name in DATACLASS_MODULES\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/pylinter.py"
                },
                "region": {
                  "startLine": 1202,
                  "startColumn": 9,
                  "endLine": 1202,
                  "endColumn": 17,
                  "snippet": {
                    "text": "            )\n            return\n\n        # update stats\n        msg_cat = MSG_TYPES[message_definition.msgid[0]]\n        self.msg_status |= MSG_TYPES_STATUS[message_definition.msgid[0]]\n        self.stats.increase_single_message_count(msg_cat, 1)\n",
                    "rendered": {
                      "text": "            )\n            return\n\n        # update stats\n        msg_cat = MSG_TYPES[message_definition.msgid[0]]\n        self.msg_status |= MSG_TYPES_STATUS[message_definition.msgid[0]]\n        self.stats.increase_single_message_count(msg_cat, 1)\n",
                      "markdown": "`            )\n            return\n\n        # update stats\n        msg_cat = MSG_TYPES[message_definition.msgid[0]]\n        self.msg_status |= MSG_TYPES_STATUS[message_definition.msgid[0]]\n        self.stats.increase_single_message_count(msg_cat, 1)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/pylinter.py"
                },
                "region": {
                  "startLine": 1138,
                  "startColumn": 44,
                  "endLine": 1138,
                  "endColumn": 48,
                  "snippet": {
                    "text": "            msg = f\"An exception occurred while rating: {ex}\"\n        else:\n            self.stats.global_note = note\n            msg = f\"Your code has been rated at {note:.2f}/10\"\n            if previous_stats:\n                pnote = previous_stats.global_note\n                if pnote is not None:\n",
                    "rendered": {
                      "text": "            msg = f\"An exception occurred while rating: {ex}\"\n        else:\n            self.stats.global_note = note\n            msg = f\"Your code has been rated at {note:.2f}/10\"\n            if previous_stats:\n                pnote = previous_stats.global_note\n                if pnote is not None:\n",
                      "markdown": "`            msg = f\"An exception occurred while rating: {ex}\"\n        else:\n            self.stats.global_note = note\n            msg = f\"Your code has been rated at {note:.2f}/10\"\n            if previous_stats:\n                pnote = previous_stats.global_note\n                if pnote is not None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/pylinter.py"
                },
                "region": {
                  "startLine": 1114,
                  "startColumn": 20,
                  "endLine": 1114,
                  "endColumn": 24,
                  "snippet": {
                    "text": "\n    def _report_evaluation(self, verbose: bool = False) -> int | None:\n        \"\"\"Make the global evaluation report.\"\"\"\n        # check with at least a statement (usually 0 when there is a\n        # syntax error preventing pylint from further processing)\n        note = None\n        previous_stats = load_results(self.file_state.base_name)\n",
                    "rendered": {
                      "text": "\n    def _report_evaluation(self, verbose: bool = False) -> int | None:\n        \"\"\"Make the global evaluation report.\"\"\"\n        # check with at least a statement (usually 0 when there is a\n        # syntax error preventing pylint from further processing)\n        note = None\n        previous_stats = load_results(self.file_state.base_name)\n",
                      "markdown": "`\n    def _report_evaluation(self, verbose: bool = False) -> int | None:\n        \"\"\"Make the global evaluation report.\"\"\"\n        # check with at least a statement (usually 0 when there is a\n        # syntax error preventing pylint from further processing)\n        note = None\n        previous_stats = load_results(self.file_state.base_name)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/pylinter.py"
                },
                "region": {
                  "startLine": 910,
                  "startColumn": 57,
                  "endLine": 910,
                  "endColumn": 65,
                  "snippet": {
                    "text": "        self.current_file = filepath or modname\n        self.stats.init_single_module(modname or \"\")\n\n        # If there is an actual filepath we might need to update the config attribute\n        if filepath:\n            namespace = self._get_namespace_for_file(\n                Path(filepath), self._directory_namespaces\n",
                    "rendered": {
                      "text": "        self.current_file = filepath or modname\n        self.stats.init_single_module(modname or \"\")\n\n        # If there is an actual filepath we might need to update the config attribute\n        if filepath:\n            namespace = self._get_namespace_for_file(\n                Path(filepath), self._directory_namespaces\n",
                      "markdown": "`        self.current_file = filepath or modname\n        self.stats.init_single_module(modname or \"\")\n\n        # If there is an actual filepath we might need to update the config attribute\n        if filepath:\n            namespace = self._get_namespace_for_file(\n                Path(filepath), self._directory_namespaces\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/pylinter.py"
                },
                "region": {
                  "startLine": 475,
                  "startColumn": 13,
                  "endLine": 475,
                  "endColumn": 17,
                  "snippet": {
                    "text": "        reports = sorted(self._reports, key=lambda x: getattr(x, \"name\", \"\"))\n        try:\n            # Remove the current reporter and add it\n            # at the end of the list.\n            reports.pop(reports.index(self))\n        except ValueError:\n            pass\n",
                    "rendered": {
                      "text": "        reports = sorted(self._reports, key=lambda x: getattr(x, \"name\", \"\"))\n        try:\n            # Remove the current reporter and add it\n            # at the end of the list.\n            reports.pop(reports.index(self))\n        except ValueError:\n            pass\n",
                      "markdown": "`        reports = sorted(self._reports, key=lambda x: getattr(x, \"name\", \"\"))\n        try:\n            # Remove the current reporter and add it\n            # at the end of the list.\n            reports.pop(reports.index(self))\n        except ValueError:\n            pass\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/pylinter.py"
                },
                "region": {
                  "startLine": 265,
                  "startColumn": 46,
                  "endLine": 265,
                  "endColumn": 50,
                  "snippet": {
                    "text": "    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n",
                    "rendered": {
                      "text": "    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n",
                      "markdown": "`    This is the main checker controlling the other ones and the reports\n    generation. It is itself both a raw checker and an astroid checker in order\n    to:\n    * handle message activation / deactivation at the module level\n    * handle some basic but necessary stats' data (number of classes, methods...)\n\n    IDE plugin developers: you may have to call\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/pylinter.py"
                },
                "region": {
                  "startLine": 1261,
                  "startColumn": 37,
                  "endLine": 1261,
                  "endColumn": 43,
                  "snippet": {
                    "text": "\n        If provided, the message string is expanded using args.\n\n        AST checkers must provide the node argument (but may optionally\n        provide line if the line number is different), raw and token checkers\n        must provide the line argument.\n        \"\"\"\n",
                    "rendered": {
                      "text": "\n        If provided, the message string is expanded using args.\n\n        AST checkers must provide the node argument (but may optionally\n        provide line if the line number is different), raw and token checkers\n        must provide the line argument.\n        \"\"\"\n",
                      "markdown": "`\n        If provided, the message string is expanded using args.\n\n        AST checkers must provide the node argument (but may optionally\n        provide line if the line number is different), raw and token checkers\n        must provide the line argument.\n        \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/pylinter.py"
                },
                "region": {
                  "startLine": 1216,
                  "startColumn": 10,
                  "endLine": 1216,
                  "endColumn": 16,
                  "snippet": {
                    "text": "        if args is not None:\n            msg %= args\n        # get module and object\n        if node is None:\n            module, obj = self.current_name, \"\"\n            abspath = self.current_file\n        else:\n",
                    "rendered": {
                      "text": "        if args is not None:\n            msg %= args\n        # get module and object\n        if node is None:\n            module, obj = self.current_name, \"\"\n            abspath = self.current_file\n        else:\n",
                      "markdown": "`        if args is not None:\n            msg %= args\n        # get module and object\n        if node is None:\n            module, obj = self.current_name, \"\"\n            abspath = self.current_file\n        else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/pylinter.py"
                },
                "region": {
                  "startLine": 1170,
                  "startColumn": 36,
                  "endLine": 1170,
                  "endColumn": 42,
                  "snippet": {
                    "text": "        \"\"\"\n        message_definition.check_message_definition(line, node)\n\n        # Look up \"location\" data of node if not yet supplied\n        if node:\n            if node.position:\n                if not line:\n",
                    "rendered": {
                      "text": "        \"\"\"\n        message_definition.check_message_definition(line, node)\n\n        # Look up \"location\" data of node if not yet supplied\n        if node:\n            if node.position:\n                if not line:\n",
                      "markdown": "`        \"\"\"\n        message_definition.check_message_definition(line, node)\n\n        # Look up \"location\" data of node if not yet supplied\n        if node:\n            if node.position:\n                if not line:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/pylinter.py"
                },
                "region": {
                  "startLine": 1086,
                  "startColumn": 48,
                  "endLine": 1086,
                  "endColumn": 54,
                  "snippet": {
                    "text": "        self.stats.reset_message_count()\n\n    def generate_reports(self, verbose: bool = False) -> int | None:\n        \"\"\"Close the whole package /module, it's time to make reports !\n\n        if persistent run, pickle results for later comparison\n        \"\"\"\n",
                    "rendered": {
                      "text": "        self.stats.reset_message_count()\n\n    def generate_reports(self, verbose: bool = False) -> int | None:\n        \"\"\"Close the whole package /module, it's time to make reports !\n\n        if persistent run, pickle results for later comparison\n        \"\"\"\n",
                      "markdown": "`        self.stats.reset_message_count()\n\n    def generate_reports(self, verbose: bool = False) -> int | None:\n        \"\"\"Close the whole package /module, it's time to make reports !\n\n        if persistent run, pickle results for later comparison\n        \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/pylinter.py"
                },
                "region": {
                  "startLine": 1035,
                  "startColumn": 45,
                  "endLine": 1035,
                  "endColumn": 51,
                  "snippet": {
                    "text": "    ) -> bool | None:\n        \"\"\"Check given AST node with given walker and checkers.\n\n        :param astroid.nodes.Module node: AST node of the module to check\n        :param pylint.utils.ast_walker.ASTWalker walker: AST walker\n        :param list rawcheckers: List of token checkers to use\n        :param list tokencheckers: List of raw checkers to use\n",
                    "rendered": {
                      "text": "    ) -> bool | None:\n        \"\"\"Check given AST node with given walker and checkers.\n\n        :param astroid.nodes.Module node: AST node of the module to check\n        :param pylint.utils.ast_walker.ASTWalker walker: AST walker\n        :param list rawcheckers: List of token checkers to use\n        :param list tokencheckers: List of raw checkers to use\n",
                      "markdown": "`    ) -> bool | None:\n        \"\"\"Check given AST node with given walker and checkers.\n\n        :param astroid.nodes.Module node: AST node of the module to check\n        :param pylint.utils.ast_walker.ASTWalker walker: AST walker\n        :param list rawcheckers: List of token checkers to use\n        :param list tokencheckers: List of raw checkers to use\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/pylinter.py"
                },
                "region": {
                  "startLine": 1033,
                  "startColumn": 26,
                  "endLine": 1033,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        rawcheckers: list[checkers.BaseRawFileChecker],\n        tokencheckers: list[checkers.BaseTokenChecker],\n    ) -> bool | None:\n        \"\"\"Check given AST node with given walker and checkers.\n\n        :param astroid.nodes.Module node: AST node of the module to check\n        :param pylint.utils.ast_walker.ASTWalker walker: AST walker\n",
                    "rendered": {
                      "text": "        rawcheckers: list[checkers.BaseRawFileChecker],\n        tokencheckers: list[checkers.BaseTokenChecker],\n    ) -> bool | None:\n        \"\"\"Check given AST node with given walker and checkers.\n\n        :param astroid.nodes.Module node: AST node of the module to check\n        :param pylint.utils.ast_walker.ASTWalker walker: AST walker\n",
                      "markdown": "`        rawcheckers: list[checkers.BaseRawFileChecker],\n        tokencheckers: list[checkers.BaseTokenChecker],\n    ) -> bool | None:\n        \"\"\"Check given AST node with given walker and checkers.\n\n        :param astroid.nodes.Module node: AST node of the module to check\n        :param pylint.utils.ast_walker.ASTWalker walker: AST walker\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/pylinter.py"
                },
                "region": {
                  "startLine": 518,
                  "startColumn": 48,
                  "endLine": 518,
                  "endColumn": 53,
                  "snippet": {
                    "text": "            else:\n                fail_on_msgs.add(val)\n\n        # For every message in every checker, if cat or msg flagged, enable check\n        for all_checkers in self._checkers.values():\n            for checker in all_checkers:\n                for msg in checker.messages:\n",
                    "rendered": {
                      "text": "            else:\n                fail_on_msgs.add(val)\n\n        # For every message in every checker, if cat or msg flagged, enable check\n        for all_checkers in self._checkers.values():\n            for checker in all_checkers:\n                for msg in checker.messages:\n",
                      "markdown": "`            else:\n                fail_on_msgs.add(val)\n\n        # For every message in every checker, if cat or msg flagged, enable check\n        for all_checkers in self._checkers.values():\n            for checker in all_checkers:\n                for msg in checker.messages:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/pylinter.py"
                },
                "region": {
                  "startLine": 240,
                  "startColumn": 45,
                  "endLine": 240,
                  "endColumn": 50,
                  "snippet": {
                    "text": "    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n",
                    "rendered": {
                      "text": "    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n",
                      "markdown": "`    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n        {\"scope\": WarningScope.LINE},\n    ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/pylinter.py"
                },
                "region": {
                  "startLine": 238,
                  "startColumn": 44,
                  "endLine": 238,
                  "endColumn": 49,
                  "snippet": {
                    "text": "        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n",
                    "rendered": {
                      "text": "        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n",
                      "markdown": "`        {\"scope\": WarningScope.LINE},\n    ),\n    \"E0014\": (\n        \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n        \"bad-configuration-section\",\n        \"Used when we detect a setting in the top level of a toml configuration that\"\n        \" shouldn't be there.\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/pylinter.py"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 31,
                  "endLine": 104,
                  "endColumn": 37,
                  "snippet": {
                    "text": "        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n",
                    "rendered": {
                      "text": "        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n",
                      "markdown": "`        \"%s\",\n        \"fatal\",\n        \"Used when an error occurred preventing the analysis of a \\\n              module (unable to find it for instance).\",\n        {\"scope\": WarningScope.LINE},\n    ),\n    \"F0002\": (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/message_state_handler.py"
                },
                "region": {
                  "startLine": 313,
                  "startColumn": 35,
                  "endLine": 313,
                  "endColumn": 40,
                  "snippet": {
                    "text": "                    fallback = fallback_iter\n\n                return self._msgs_state.get(msgid, fallback)\n            return self._msgs_state.get(msgid, True)\n\n    def is_message_enabled(\n        self,\n",
                    "rendered": {
                      "text": "                    fallback = fallback_iter\n\n                return self._msgs_state.get(msgid, fallback)\n            return self._msgs_state.get(msgid, True)\n\n    def is_message_enabled(\n        self,\n",
                      "markdown": "`                    fallback = fallback_iter\n\n                return self._msgs_state.get(msgid, fallback)\n            return self._msgs_state.get(msgid, True)\n\n    def is_message_enabled(\n        self,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/message_state_handler.py"
                },
                "region": {
                  "startLine": 312,
                  "startColumn": 39,
                  "endLine": 312,
                  "endColumn": 44,
                  "snippet": {
                    "text": "                if fallback_iter is not None:\n                    fallback = fallback_iter\n\n                return self._msgs_state.get(msgid, fallback)\n            return self._msgs_state.get(msgid, True)\n\n    def is_message_enabled(\n",
                    "rendered": {
                      "text": "                if fallback_iter is not None:\n                    fallback = fallback_iter\n\n                return self._msgs_state.get(msgid, fallback)\n            return self._msgs_state.get(msgid, True)\n\n    def is_message_enabled(\n",
                      "markdown": "`                if fallback_iter is not None:\n                    fallback = fallback_iter\n\n                return self._msgs_state.get(msgid, fallback)\n            return self._msgs_state.get(msgid, True)\n\n    def is_message_enabled(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/message_state_handler.py"
                },
                "region": {
                  "startLine": 297,
                  "startColumn": 69,
                  "endLine": 297,
                  "endColumn": 74,
                  "snippet": {
                    "text": "            max_line_number = self.linter.file_state.get_effective_max_line_number()\n            if max_line_number and line > max_line_number:\n                fallback = True\n                lines = self.linter.file_state._raw_module_msgs_state.get(msgid, {})\n\n                # Doesn't consider scopes, as a 'disable' can be in a\n                # different scope than that of the current line.\n",
                    "rendered": {
                      "text": "            max_line_number = self.linter.file_state.get_effective_max_line_number()\n            if max_line_number and line > max_line_number:\n                fallback = True\n                lines = self.linter.file_state._raw_module_msgs_state.get(msgid, {})\n\n                # Doesn't consider scopes, as a 'disable' can be in a\n                # different scope than that of the current line.\n",
                      "markdown": "`            max_line_number = self.linter.file_state.get_effective_max_line_number()\n            if max_line_number and line > max_line_number:\n                fallback = True\n                lines = self.linter.file_state._raw_module_msgs_state.get(msgid, {})\n\n                # Doesn't consider scopes, as a 'disable' can be in a\n                # different scope than that of the current line.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/message_state_handler.py"
                },
                "region": {
                  "startLine": 286,
                  "startColumn": 35,
                  "endLine": 286,
                  "endColumn": 40,
                  "snippet": {
                    "text": "        change.\n        \"\"\"\n        if line is None:\n            return self._msgs_state.get(msgid, True)\n        try:\n            return self.linter.file_state._module_msgs_state[msgid][line]\n        except KeyError:\n",
                    "rendered": {
                      "text": "        change.\n        \"\"\"\n        if line is None:\n            return self._msgs_state.get(msgid, True)\n        try:\n            return self.linter.file_state._module_msgs_state[msgid][line]\n        except KeyError:\n",
                      "markdown": "`        change.\n        \"\"\"\n        if line is None:\n            return self._msgs_state.get(msgid, True)\n        try:\n            return self.linter.file_state._module_msgs_state[msgid][line]\n        except KeyError:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/message_state_handler.py"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 50,
                  "endLine": 105,
                  "endColumn": 55,
                  "snippet": {
                    "text": "        # msgid is a category?\n        category_id = msgid.upper()\n        if category_id not in MSG_TYPES:\n            category_id_formatted = MSG_TYPES_LONG.get(category_id)\n        else:\n            category_id_formatted = category_id\n        if category_id_formatted is not None:\n",
                    "rendered": {
                      "text": "        # msgid is a category?\n        category_id = msgid.upper()\n        if category_id not in MSG_TYPES:\n            category_id_formatted = MSG_TYPES_LONG.get(category_id)\n        else:\n            category_id_formatted = category_id\n        if category_id_formatted is not None:\n",
                      "markdown": "`        # msgid is a category?\n        category_id = msgid.upper()\n        if category_id not in MSG_TYPES:\n            category_id_formatted = MSG_TYPES_LONG.get(category_id)\n        else:\n            category_id_formatted = category_id\n        if category_id_formatted is not None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/message_state_handler.py"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 34,
                  "endLine": 43,
                  "endColumn": 39,
                  "snippet": {
                    "text": "        self.default_enabled_messages: dict[str, MessageDefinitionTuple] = {\n            k: v\n            for k, v in self.linter.msgs.items()\n            if len(v) == 3 or v[3].get(\"default_enabled\", True)\n        }\n        self._msgs_state: dict[str, bool] = {}\n        self._options_methods = {\n",
                    "rendered": {
                      "text": "        self.default_enabled_messages: dict[str, MessageDefinitionTuple] = {\n            k: v\n            for k, v in self.linter.msgs.items()\n            if len(v) == 3 or v[3].get(\"default_enabled\", True)\n        }\n        self._msgs_state: dict[str, bool] = {}\n        self._options_methods = {\n",
                      "markdown": "`        self.default_enabled_messages: dict[str, MessageDefinitionTuple] = {\n            k: v\n            for k, v in self.linter.msgs.items()\n            if len(v) == 3 or v[3].get(\"default_enabled\", True)\n        }\n        self._msgs_state: dict[str, bool] = {}\n        self._options_methods = {\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/message_state_handler.py"
                },
                "region": {
                  "startLine": 397,
                  "startColumn": 46,
                  "endLine": 397,
                  "endColumn": 55,
                  "snippet": {
                    "text": "                            ),\n                        )\n                    for msgid in pragma_repr.messages:\n                        # Add the line where a control pragma was encountered.\n                        if pragma_repr.action in control_pragmas:\n                            self._pragma_lineno[msgid] = start[0]\n\n",
                    "rendered": {
                      "text": "                            ),\n                        )\n                    for msgid in pragma_repr.messages:\n                        # Add the line where a control pragma was encountered.\n                        if pragma_repr.action in control_pragmas:\n                            self._pragma_lineno[msgid] = start[0]\n\n",
                      "markdown": "`                            ),\n                        )\n                    for msgid in pragma_repr.messages:\n                        # Add the line where a control pragma was encountered.\n                        if pragma_repr.action in control_pragmas:\n                            self._pragma_lineno[msgid] = start[0]\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/message_state_handler.py"
                },
                "region": {
                  "startLine": 293,
                  "startColumn": 60,
                  "endLine": 293,
                  "endColumn": 64,
                  "snippet": {
                    "text": "            # Check if the message's line is after the maximum line existing in ast tree.\n            # This line won't appear in the ast tree and won't be referred in\n            # self.file_state._module_msgs_state\n            # This happens for example with a commented line at the end of a module.\n            max_line_number = self.linter.file_state.get_effective_max_line_number()\n            if max_line_number and line > max_line_number:\n                fallback = True\n",
                    "rendered": {
                      "text": "            # Check if the message's line is after the maximum line existing in ast tree.\n            # This line won't appear in the ast tree and won't be referred in\n            # self.file_state._module_msgs_state\n            # This happens for example with a commented line at the end of a module.\n            max_line_number = self.linter.file_state.get_effective_max_line_number()\n            if max_line_number and line > max_line_number:\n                fallback = True\n",
                      "markdown": "`            # Check if the message's line is after the maximum line existing in ast tree.\n            # This line won't appear in the ast tree and won't be referred in\n            # self.file_state._module_msgs_state\n            # This happens for example with a commented line at the end of a module.\n            max_line_number = self.linter.file_state.get_effective_max_line_number()\n            if max_line_number and line > max_line_number:\n                fallback = True\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/message_state_handler.py"
                },
                "region": {
                  "startLine": 267,
                  "startColumn": 28,
                  "endLine": 267,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        line: int | None = None,\n        confidence: interfaces.Confidence | None = None,\n    ) -> Literal[0, 1, 2] | None:\n        \"\"\"Returns the scope at which a message was enabled/disabled.\"\"\"\n        if confidence is None:\n            confidence = interfaces.UNDEFINED\n        if confidence.name not in self.linter.config.confidence:\n",
                    "rendered": {
                      "text": "        line: int | None = None,\n        confidence: interfaces.Confidence | None = None,\n    ) -> Literal[0, 1, 2] | None:\n        \"\"\"Returns the scope at which a message was enabled/disabled.\"\"\"\n        if confidence is None:\n            confidence = interfaces.UNDEFINED\n        if confidence.name not in self.linter.config.confidence:\n",
                      "markdown": "`        line: int | None = None,\n        confidence: interfaces.Confidence | None = None,\n    ) -> Literal[0, 1, 2] | None:\n        \"\"\"Returns the scope at which a message was enabled/disabled.\"\"\"\n        if confidence is None:\n            confidence = interfaces.UNDEFINED\n        if confidence.name not in self.linter.config.confidence:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/message_state_handler.py"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 28,
                  "endLine": 85,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    def _get_messages_to_set(\n        self, msgid: str, enable: bool, ignore_unknown: bool = False\n    ) -> list[MessageDefinition]:\n        \"\"\"Do some tests and find the actual messages of which the status should be set.\"\"\"\n        message_definitions: list[MessageDefinition] = []\n        if msgid == \"all\":\n            for _msgid in MSG_TYPES:\n",
                    "rendered": {
                      "text": "    def _get_messages_to_set(\n        self, msgid: str, enable: bool, ignore_unknown: bool = False\n    ) -> list[MessageDefinition]:\n        \"\"\"Do some tests and find the actual messages of which the status should be set.\"\"\"\n        message_definitions: list[MessageDefinition] = []\n        if msgid == \"all\":\n            for _msgid in MSG_TYPES:\n",
                      "markdown": "`    def _get_messages_to_set(\n        self, msgid: str, enable: bool, ignore_unknown: bool = False\n    ) -> list[MessageDefinition]:\n        \"\"\"Do some tests and find the actual messages of which the status should be set.\"\"\"\n        message_definitions: list[MessageDefinition] = []\n        if msgid == \"all\":\n            for _msgid in MSG_TYPES:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/base_options.py"
                },
                "region": {
                  "startLine": 195,
                  "startColumn": 67,
                  "endLine": 195,
                  "endColumn": 73,
                  "snippet": {
                    "text": "                \"group\": \"Messages control\",\n                \"help\": \"Enable the message, report, category or checker with the \"\n                \"given id(s). You can either give multiple identifier \"\n                \"separated by comma (,) or put this option multiple time \"\n                \"(only on the command line, not in the configuration file \"\n                \"where it should appear only once). \"\n                'See also the \"--disable\" option for examples.',\n",
                    "rendered": {
                      "text": "                \"group\": \"Messages control\",\n                \"help\": \"Enable the message, report, category or checker with the \"\n                \"given id(s). You can either give multiple identifier \"\n                \"separated by comma (,) or put this option multiple time \"\n                \"(only on the command line, not in the configuration file \"\n                \"where it should appear only once). \"\n                'See also the \"--disable\" option for examples.',\n",
                      "markdown": "`                \"group\": \"Messages control\",\n                \"help\": \"Enable the message, report, category or checker with the \"\n                \"given id(s). You can either give multiple identifier \"\n                \"separated by comma (,) or put this option multiple time \"\n                \"(only on the command line, not in the configuration file \"\n                \"where it should appear only once). \"\n                'See also the \"--disable\" option for examples.',\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/lint/base_options.py"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 24,
                  "endLine": 61,
                  "endColumn": 31,
                  "snippet": {
                    "text": "                \"default\": (re.compile(r\"^\\.#\"),),\n                \"help\": \"Files or directories matching the regular expression patterns are\"\n                \" skipped. The regex matches against base names, not paths. The default value \"\n                \"ignores Emacs file locks\",\n            },\n        ),\n        (\n",
                    "rendered": {
                      "text": "                \"default\": (re.compile(r\"^\\.#\"),),\n                \"help\": \"Files or directories matching the regular expression patterns are\"\n                \" skipped. The regex matches against base names, not paths. The default value \"\n                \"ignores Emacs file locks\",\n            },\n        ),\n        (\n",
                      "markdown": "`                \"default\": (re.compile(r\"^\\.#\"),),\n                \"help\": \"Files or directories matching the regular expression patterns are\"\n                \" skipped. The regex matches against base names, not paths. The default value \"\n                \"ignores Emacs file locks\",\n            },\n        ),\n        (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/non_ascii_names.py"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 32,
                  "endLine": 49,
                  "endColumn": 36,
                  "snippet": {
                    "text": "            '%s name \"%s\" contains a non-ASCII character.',\n            \"non-ascii-file-name\",\n            (\n                # Some = PyCharm at the time of writing didn't display the non_ascii_name_lo\n                # files. That's also why this is a warning and not only a convention!\n                \"Under python 3.5, PEP 3131 allows non-ascii identifiers, but not non-ascii file names.\"\n                \"Since Python 3.5, even though Python supports UTF-8 files, some editors or tools \"\n",
                    "rendered": {
                      "text": "            '%s name \"%s\" contains a non-ASCII character.',\n            \"non-ascii-file-name\",\n            (\n                # Some = PyCharm at the time of writing didn't display the non_ascii_name_lo\n                # files. That's also why this is a warning and not only a convention!\n                \"Under python 3.5, PEP 3131 allows non-ascii identifiers, but not non-ascii file names.\"\n                \"Since Python 3.5, even though Python supports UTF-8 files, some editors or tools \"\n",
                      "markdown": "`            '%s name \"%s\" contains a non-ASCII character.',\n            \"non-ascii-file-name\",\n            (\n                # Some = PyCharm at the time of writing didn't display the non_ascii_name_lo\n                # files. That's also why this is a warning and not only a convention!\n                \"Under python 3.5, PEP 3131 allows non-ascii identifiers, but not non-ascii file names.\"\n                \"Since Python 3.5, even though Python supports UTF-8 files, some editors or tools \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/non_ascii_names.py"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 32,
                  "endLine": 21,
                  "endColumn": 36,
                  "snippet": {
                    "text": "from pylint.checkers import base_checker, utils\n\nNON_ASCII_HELP = (\n    \"Used when the name contains at least one non-ASCII unicode character. \"\n    \"See https://peps.python.org/pep-0672/#confusing-features\"\n    \" for a background why this could be bad. \\n\"\n    \"If your programming guideline defines that you are programming in \"\n",
                    "rendered": {
                      "text": "from pylint.checkers import base_checker, utils\n\nNON_ASCII_HELP = (\n    \"Used when the name contains at least one non-ASCII unicode character. \"\n    \"See https://peps.python.org/pep-0672/#confusing-features\"\n    \" for a background why this could be bad. \\n\"\n    \"If your programming guideline defines that you are programming in \"\n",
                      "markdown": "`from pylint.checkers import base_checker, utils\n\nNON_ASCII_HELP = (\n    \"Used when the name contains at least one non-ASCII unicode character. \"\n    \"See https://peps.python.org/pep-0672/#confusing-features\"\n    \" for a background why this could be bad. \\n\"\n    \"If your programming guideline defines that you are programming in \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/non_ascii_names.py"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 18,
                  "endLine": 78,
                  "endColumn": 24,
                  "snippet": {
                    "text": "\n            msg = \"non-ascii-name\"\n\n            # Some node types have customized messages\n            if node_type == \"file\":\n                msg = \"non-ascii-file-name\"\n            elif node_type == \"module\":\n",
                    "rendered": {
                      "text": "\n            msg = \"non-ascii-name\"\n\n            # Some node types have customized messages\n            if node_type == \"file\":\n                msg = \"non-ascii-file-name\"\n            elif node_type == \"module\":\n",
                      "markdown": "`\n            msg = \"non-ascii-name\"\n\n            # Some node types have customized messages\n            if node_type == \"file\":\n                msg = \"non-ascii-file-name\"\n            elif node_type == \"module\":\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/non_ascii_names.py"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 39,
                  "endLine": 49,
                  "endColumn": 45,
                  "snippet": {
                    "text": "            '%s name \"%s\" contains a non-ASCII character.',\n            \"non-ascii-file-name\",\n            (\n                # Some = PyCharm at the time of writing didn't display the non_ascii_name_lo\n                # files. That's also why this is a warning and not only a convention!\n                \"Under python 3.5, PEP 3131 allows non-ascii identifiers, but not non-ascii file names.\"\n                \"Since Python 3.5, even though Python supports UTF-8 files, some editors or tools \"\n",
                    "rendered": {
                      "text": "            '%s name \"%s\" contains a non-ASCII character.',\n            \"non-ascii-file-name\",\n            (\n                # Some = PyCharm at the time of writing didn't display the non_ascii_name_lo\n                # files. That's also why this is a warning and not only a convention!\n                \"Under python 3.5, PEP 3131 allows non-ascii identifiers, but not non-ascii file names.\"\n                \"Since Python 3.5, even though Python supports UTF-8 files, some editors or tools \"\n",
                      "markdown": "`            '%s name \"%s\" contains a non-ASCII character.',\n            \"non-ascii-file-name\",\n            (\n                # Some = PyCharm at the time of writing didn't display the non_ascii_name_lo\n                # files. That's also why this is a warning and not only a convention!\n                \"Under python 3.5, PEP 3131 allows non-ascii identifiers, but not non-ascii file names.\"\n                \"Since Python 3.5, even though Python supports UTF-8 files, some editors or tools \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/function_checker.py"
                },
                "region": {
                  "startLine": 138,
                  "startColumn": 27,
                  "endLine": 138,
                  "endColumn": 31,
                  "snippet": {
                    "text": "            if any(try_node.nodes_of_class(nodes.Yield))\n        ]\n        if not try_with_yield_nodes:\n            # no try blocks at all, so checks after this line do not apply\n            return True\n        # if the contextmanager has a finally block, then it is fine\n        if all(try_node.finalbody for try_node in try_with_yield_nodes):\n",
                    "rendered": {
                      "text": "            if any(try_node.nodes_of_class(nodes.Yield))\n        ]\n        if not try_with_yield_nodes:\n            # no try blocks at all, so checks after this line do not apply\n            return True\n        # if the contextmanager has a finally block, then it is fine\n        if all(try_node.finalbody for try_node in try_with_yield_nodes):\n",
                      "markdown": "`            if any(try_node.nodes_of_class(nodes.Yield))\n        ]\n        if not try_with_yield_nodes:\n            # no try blocks at all, so checks after this line do not apply\n            return True\n        # if the contextmanager has a finally block, then it is fine\n        if all(try_node.finalbody for try_node in try_with_yield_nodes):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/function_checker.py"
                },
                "region": {
                  "startLine": 131,
                  "startColumn": 86,
                  "endLine": 132,
                  "snippet": {
                    "text": "                # No next statement found\n                return False\n\n        # if function body has multiple Try, filter down to the ones that have a yield node\n        try_with_yield_nodes = [\n            try_node\n            for try_node in node.nodes_of_class(nodes.Try)\n            if any(try_node.nodes_of_class(nodes.Yield))\n",
                    "rendered": {
                      "text": "                # No next statement found\n                return False\n\n        # if function body has multiple Try, filter down to the ones that have a yield node\n        try_with_yield_nodes = [\n            try_node\n            for try_node in node.nodes_of_class(nodes.Try)\n            if any(try_node.nodes_of_class(nodes.Yield))\n",
                      "markdown": "`                # No next statement found\n                return False\n\n        # if function body has multiple Try, filter down to the ones that have a yield node\n        try_with_yield_nodes = [\n            try_node\n            for try_node in node.nodes_of_class(nodes.Try)\n            if any(try_node.nodes_of_class(nodes.Yield))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/function_checker.py"
                },
                "region": {
                  "startLine": 90,
                  "startColumn": 20,
                  "endLine": 90,
                  "endColumn": 26,
                  "snippet": {
                    "text": "            - only if the context manager lacks a finally, or does not catch GeneratorExit\n            - only if some statement follows the yield, some manually cleanup happens\n\n        :param node: Node to check\n        :type node: nodes.FunctionDef\n        :return: True if fails, False otherwise\n        :param yield_nodes: List of Yield nodes in the function body\n",
                    "rendered": {
                      "text": "            - only if the context manager lacks a finally, or does not catch GeneratorExit\n            - only if some statement follows the yield, some manually cleanup happens\n\n        :param node: Node to check\n        :type node: nodes.FunctionDef\n        :return: True if fails, False otherwise\n        :param yield_nodes: List of Yield nodes in the function body\n",
                      "markdown": "`            - only if the context manager lacks a finally, or does not catch GeneratorExit\n            - only if some statement follows the yield, some manually cleanup happens\n\n        :param node: Node to check\n        :type node: nodes.FunctionDef\n        :return: True if fails, False otherwise\n        :param yield_nodes: List of Yield nodes in the function body\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/function_checker.py"
                },
                "region": {
                  "startLine": 83,
                  "startColumn": 21,
                  "endLine": 83,
                  "endColumn": 27,
                  "snippet": {
                    "text": "    def _node_fails_contextmanager_cleanup(\n        node: nodes.FunctionDef, yield_nodes: list[nodes.Yield]\n    ) -> bool:\n        \"\"\"Check if a node fails contextmanager cleanup.\n\n        Current checks for a contextmanager:\n            - only if the context manager yields a non-constant value\n",
                    "rendered": {
                      "text": "    def _node_fails_contextmanager_cleanup(\n        node: nodes.FunctionDef, yield_nodes: list[nodes.Yield]\n    ) -> bool:\n        \"\"\"Check if a node fails contextmanager cleanup.\n\n        Current checks for a contextmanager:\n            - only if the context manager yields a non-constant value\n",
                      "markdown": "`    def _node_fails_contextmanager_cleanup(\n        node: nodes.FunctionDef, yield_nodes: list[nodes.Yield]\n    ) -> bool:\n        \"\"\"Check if a node fails contextmanager cleanup.\n\n        Current checks for a contextmanager:\n            - only if the context manager yields a non-constant value\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/function_checker.py"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 32,
                  "endLine": 45,
                  "endColumn": 38,
                  "snippet": {
                    "text": "\n        If it is, check if the contextmanager is properly cleaned up. Otherwise, add message.\n\n        :param node: FunctionDef node to check\n        :type node: nodes.FunctionDef\n        \"\"\"\n        # if function does not use a Yield statement, it can't be a generator\n",
                    "rendered": {
                      "text": "\n        If it is, check if the contextmanager is properly cleaned up. Otherwise, add message.\n\n        :param node: FunctionDef node to check\n        :type node: nodes.FunctionDef\n        \"\"\"\n        # if function does not use a Yield statement, it can't be a generator\n",
                      "markdown": "`\n        If it is, check if the contextmanager is properly cleaned up. Otherwise, add message.\n\n        :param node: FunctionDef node to check\n        :type node: nodes.FunctionDef\n        \"\"\"\n        # if function does not use a Yield statement, it can't be a generator\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/function_checker.py"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 33,
                  "endLine": 40,
                  "endColumn": 39,
                  "snippet": {
                    "text": "    def _check_contextmanager_generator_missing_cleanup(\n        self, node: nodes.FunctionDef\n    ) -> None:\n        \"\"\"Check a FunctionDef to find if it is a generator\n        that uses a contextmanager internally.\n\n        If it is, check if the contextmanager is properly cleaned up. Otherwise, add message.\n",
                    "rendered": {
                      "text": "    def _check_contextmanager_generator_missing_cleanup(\n        self, node: nodes.FunctionDef\n    ) -> None:\n        \"\"\"Check a FunctionDef to find if it is a generator\n        that uses a contextmanager internally.\n\n        If it is, check if the contextmanager is properly cleaned up. Otherwise, add message.\n",
                      "markdown": "`    def _check_contextmanager_generator_missing_cleanup(\n        self, node: nodes.FunctionDef\n    ) -> None:\n        \"\"\"Check a FunctionDef to find if it is a generator\n        that uses a contextmanager internally.\n\n        If it is, check if the contextmanager is properly cleaned up. Otherwise, add message.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/docstring_checker.py"
                },
                "region": {
                  "startLine": 159,
                  "startColumn": 23,
                  "endLine": 159,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        report_missing: bool = True,\n        confidence: interfaces.Confidence = interfaces.HIGH,\n    ) -> None:\n        \"\"\"Check if the node has a non-empty docstring.\"\"\"\n        docstring = node.doc_node.value if node.doc_node else None\n        if docstring is None:\n            docstring = _infer_dunder_doc_attribute(node)\n",
                    "rendered": {
                      "text": "        report_missing: bool = True,\n        confidence: interfaces.Confidence = interfaces.HIGH,\n    ) -> None:\n        \"\"\"Check if the node has a non-empty docstring.\"\"\"\n        docstring = node.doc_node.value if node.doc_node else None\n        if docstring is None:\n            docstring = _infer_dunder_doc_attribute(node)\n",
                      "markdown": "`        report_missing: bool = True,\n        confidence: interfaces.Confidence = interfaces.HIGH,\n    ) -> None:\n        \"\"\"Check if the node has a non-empty docstring.\"\"\"\n        docstring = node.doc_node.value if node.doc_node else None\n        if docstring is None:\n            docstring = _infer_dunder_doc_attribute(node)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/docstring_checker.py"
                },
                "region": {
                  "startLine": 133,
                  "startColumn": 26,
                  "endLine": 133,
                  "endColumn": 32,
                  "snippet": {
                    "text": "                    if utils.has_known_bases(node.parent.frame())\n                    else interfaces.INFERENCE_FAILURE\n                )\n                # check if node is from a method overridden by its ancestor\n                for ancestor in node.parent.frame().ancestors():\n                    if ancestor.qname() == \"builtins.object\":\n                        continue\n",
                    "rendered": {
                      "text": "                    if utils.has_known_bases(node.parent.frame())\n                    else interfaces.INFERENCE_FAILURE\n                )\n                # check if node is from a method overridden by its ancestor\n                for ancestor in node.parent.frame().ancestors():\n                    if ancestor.qname() == \"builtins.object\":\n                        continue\n",
                      "markdown": "`                    if utils.has_known_bases(node.parent.frame())\n                    else interfaces.INFERENCE_FAILURE\n                )\n                # check if node is from a method overridden by its ancestor\n                for ancestor in node.parent.frame().ancestors():\n                    if ancestor.qname() == \"builtins.object\":\n                        continue\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint-3.3.1.dist-info/RECORD"
                },
                "region": {
                  "startLine": 148,
                  "startColumn": 61,
                  "endLine": 148,
                  "endColumn": 77,
                  "snippet": {
                    "text": "6=WcGtCmHJjlp3YT-KRFHLQ6w1KkrVQeQeITfXvrb5WYo,3440\npylint/reporters/ureports/nodes.py,sha256=VvOWfrGIqmrIsUID7DbELpMGkaTktcupFkxmdPy4EEk,5255\npylint/reporters/ureports/text_writer.py,sha256=4qsrpWU7vr8whu0xbZtgRXzZo7KSaQF-5mZHp8VnEUQ,3616\npylint/testutils/__init__.py,sha256=Sx8j8fvAJDwokpmLgvPv2gsNQeNVjtws-ow_aHNNcYM,1319\npylint/testutils/_run.py,sha256=lukrQmA9nD5iEuQ-hVOVgMMXHQu99NCw8FOh1RJF35Y,1430\npylint/testutils/checker_test_case.py,sha256=jnTFL-m7ueC7BmHymsXnZ7R5cKtVsMpMRgQ4I0a6qbk,3325\npylint/testutils/configuration_test.py,sha256=4nbzk1AnEz80u324ZE7SY_FswkWcdXXkhiH_MFkPv0U,5416\npylint/testutils/const",
                    "rendered": {
                      "text": "6=WcGtCmHJjlp3YT-KRFHLQ6w1KkrVQeQeITfXvrb5WYo,3440\npylint/reporters/ureports/nodes.py,sha256=VvOWfrGIqmrIsUID7DbELpMGkaTktcupFkxmdPy4EEk,5255\npylint/reporters/ureports/text_writer.py,sha256=4qsrpWU7vr8whu0xbZtgRXzZo7KSaQF-5mZHp8VnEUQ,3616\npylint/testutils/__init__.py,sha256=Sx8j8fvAJDwokpmLgvPv2gsNQeNVjtws-ow_aHNNcYM,1319\npylint/testutils/_run.py,sha256=lukrQmA9nD5iEuQ-hVOVgMMXHQu99NCw8FOh1RJF35Y,1430\npylint/testutils/checker_test_case.py,sha256=jnTFL-m7ueC7BmHymsXnZ7R5cKtVsMpMRgQ4I0a6qbk,3325\npylint/testutils/configuration_test.py,sha256=4nbzk1AnEz80u324ZE7SY_FswkWcdXXkhiH_MFkPv0U,5416\npylint/testutils/const",
                      "markdown": "`6=WcGtCmHJjlp3YT-KRFHLQ6w1KkrVQeQeITfXvrb5WYo,3440\npylint/reporters/ureports/nodes.py,sha256=VvOWfrGIqmrIsUID7DbELpMGkaTktcupFkxmdPy4EEk,5255\npylint/reporters/ureports/text_writer.py,sha256=4qsrpWU7vr8whu0xbZtgRXzZo7KSaQF-5mZHp8VnEUQ,3616\npylint/testutils/__init__.py,sha256=Sx8j8fvAJDwokpmLgvPv2gsNQeNVjtws-ow_aHNNcYM,1319\npylint/testutils/_run.py,sha256=lukrQmA9nD5iEuQ-hVOVgMMXHQu99NCw8FOh1RJF35Y,1430\npylint/testutils/checker_test_case.py,sha256=jnTFL-m7ueC7BmHymsXnZ7R5cKtVsMpMRgQ4I0a6qbk,3325\npylint/testutils/configuration_test.py,sha256=4nbzk1AnEz80u324ZE7SY_FswkWcdXXkhiH_MFkPv0U,5416\npylint/testutils/const`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint-3.3.1.dist-info/METADATA"
                },
                "region": {
                  "startLine": 174,
                  "startColumn": 37,
                  "endLine": 174,
                  "endColumn": 41,
                  "snippet": {
                    "text": "    to start is ``PyPI`` which often returns a plugin by searching for\n    ``pylint <library>``. `pylint-pydantic`_, `pylint-django`_ and\n    `pylint-sonarjson`_ are examples of such plugins. More information about plugins\n    and how to load them can be found at `plugins`_.\n\n.. _`plugins`: https://pylint.readthedocs.io/en/latest/development_guide/how_tos/plugins.html#plugins\n.. _`pylint-pydantic`: https://pypi.org/project/pylint-pydantic\n",
                    "rendered": {
                      "text": "    to start is ``PyPI`` which often returns a plugin by searching for\n    ``pylint <library>``. `pylint-pydantic`_, `pylint-django`_ and\n    `pylint-sonarjson`_ are examples of such plugins. More information about plugins\n    and how to load them can be found at `plugins`_.\n\n.. _`plugins`: https://pylint.readthedocs.io/en/latest/development_guide/how_tos/plugins.html#plugins\n.. _`pylint-pydantic`: https://pypi.org/project/pylint-pydantic\n",
                      "markdown": "`    to start is ``PyPI`` which often returns a plugin by searching for\n    ``pylint <library>``. `pylint-pydantic`_, `pylint-django`_ and\n    `pylint-sonarjson`_ are examples of such plugins. More information about plugins\n    and how to load them can be found at `plugins`_.\n\n.. _`plugins`: https://pylint.readthedocs.io/en/latest/development_guide/how_tos/plugins.html#plugins\n.. _`pylint-pydantic`: https://pypi.org/project/pylint-pydantic\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint-3.3.1.dist-info/METADATA"
                },
                "region": {
                  "startLine": 141,
                  "startColumn": 64,
                  "endLine": 141,
                  "endColumn": 70,
                  "snippet": {
                    "text": "start because there was no typing when pylint started off) using its internal code\nrepresentation (astroid). If your code is ``import logging as argparse``, Pylint\ncan check and know that ``argparse.error(...)`` is in fact a logging call and not an\nargparse call. This makes pylint slower, but it also lets pylint find more issues if\nyour code is not fully typed.\n\n    [inference] is the killer feature that keeps us using [pylint] in our project despite how painfully slow it is.\n",
                    "rendered": {
                      "text": "start because there was no typing when pylint started off) using its internal code\nrepresentation (astroid). If your code is ``import logging as argparse``, Pylint\ncan check and know that ``argparse.error(...)`` is in fact a logging call and not an\nargparse call. This makes pylint slower, but it also lets pylint find more issues if\nyour code is not fully typed.\n\n    [inference] is the killer feature that keeps us using [pylint] in our project despite how painfully slow it is.\n",
                      "markdown": "`start because there was no typing when pylint started off) using its internal code\nrepresentation (astroid). If your code is ``import logging as argparse``, Pylint\ncan check and know that ``argparse.error(...)`` is in fact a logging call and not an\nargparse call. This makes pylint slower, but it also lets pylint find more issues if\nyour code is not fully typed.\n\n    [inference] is the killer feature that keeps us using [pylint] in our project despite how painfully slow it is.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint-3.3.1.dist-info/METADATA"
                },
                "region": {
                  "startLine": 125,
                  "startColumn": 2,
                  "endLine": 125,
                  "endColumn": 7,
                  "snippet": {
                    "text": "\n.. code-block:: sh\n\n   pip install pylint[spelling]\n\nIt can also be integrated in most editors or IDEs. More information can be found\n`in the documentation`_.\n",
                    "rendered": {
                      "text": "\n.. code-block:: sh\n\n   pip install pylint[spelling]\n\nIt can also be integrated in most editors or IDEs. More information can be found\n`in the documentation`_.\n",
                      "markdown": "`\n.. code-block:: sh\n\n   pip install pylint[spelling]\n\nIt can also be integrated in most editors or IDEs. More information can be found\n`in the documentation`_.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint-3.3.1.dist-info/METADATA"
                },
                "region": {
                  "startLine": 118,
                  "startColumn": 3,
                  "endLine": 118,
                  "endColumn": 8,
                  "snippet": {
                    "text": "\nFor command line use, pylint is installed with::\n\n    pip install pylint\n\nOr if you want to also check spelling with ``enchant`` (you might need to\n`install the enchant C library <https://pyenchant.github.io/pyenchant/install.html#installing-the-enchant-c-library>`_):\n",
                    "rendered": {
                      "text": "\nFor command line use, pylint is installed with::\n\n    pip install pylint\n\nOr if you want to also check spelling with ``enchant`` (you might need to\n`install the enchant C library <https://pyenchant.github.io/pyenchant/install.html#installing-the-enchant-c-library>`_):\n",
                      "markdown": "`\nFor command line use, pylint is installed with::\n\n    pip install pylint\n\nOr if you want to also check spelling with ``enchant`` (you might need to\n`install the enchant C library <https://pyenchant.github.io/pyenchant/install.html#installing-the-enchant-c-library>`_):\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/utils.py"
                },
                "region": {
                  "startLine": 335,
                  "startColumn": 26,
                  "endLine": 335,
                  "endColumn": 31,
                  "snippet": {
                    "text": "            if \"new_names\" in optdict[\"kwargs\"]:\n                continue\n        value = _format_option_value(optdict, value)\n        help_opt = optdict.get(\"help\")\n        if help_opt:\n            assert isinstance(help_opt, str)\n            help_opt = normalize_text(help_opt, indent=\"# \")\n",
                    "rendered": {
                      "text": "            if \"new_names\" in optdict[\"kwargs\"]:\n                continue\n        value = _format_option_value(optdict, value)\n        help_opt = optdict.get(\"help\")\n        if help_opt:\n            assert isinstance(help_opt, str)\n            help_opt = normalize_text(help_opt, indent=\"# \")\n",
                      "markdown": "`            if \"new_names\" in optdict[\"kwargs\"]:\n                continue\n        value = _format_option_value(optdict, value)\n        help_opt = optdict.get(\"help\")\n        if help_opt:\n            assert isinstance(help_opt, str)\n            help_opt = normalize_text(help_opt, indent=\"# \")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/utils.py"
                },
                "region": {
                  "startLine": 294,
                  "startColumn": 16,
                  "endLine": 294,
                  "endColumn": 21,
                  "snippet": {
                    "text": "    elif hasattr(value, \"match\"):  # optdict.get('type') == 'regexp'\n        # compiled regexp\n        value = value.pattern\n    elif optdict.get(\"type\") == \"yn\":\n        value = \"yes\" if value else \"no\"\n    elif isinstance(value, str) and value.isspace():\n        value = f\"'{value}'\"\n",
                    "rendered": {
                      "text": "    elif hasattr(value, \"match\"):  # optdict.get('type') == 'regexp'\n        # compiled regexp\n        value = value.pattern\n    elif optdict.get(\"type\") == \"yn\":\n        value = \"yes\" if value else \"no\"\n    elif isinstance(value, str) and value.isspace():\n        value = f\"'{value}'\"\n",
                      "markdown": "`    elif hasattr(value, \"match\"):  # optdict.get('type') == 'regexp'\n        # compiled regexp\n        value = value.pattern\n    elif optdict.get(\"type\") == \"yn\":\n        value = \"yes\" if value else \"no\"\n    elif isinstance(value, str) and value.isspace():\n        value = f\"'{value}'\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/utils.py"
                },
                "region": {
                  "startLine": 291,
                  "startColumn": 44,
                  "endLine": 291,
                  "endColumn": 49,
                  "snippet": {
                    "text": "        value = \",\".join(_format_option_value(optdict, item) for item in value)\n    elif isinstance(value, dict):\n        value = \",\".join(f\"{k}:{v}\" for k, v in value.items())\n    elif hasattr(value, \"match\"):  # optdict.get('type') == 'regexp'\n        # compiled regexp\n        value = value.pattern\n    elif optdict.get(\"type\") == \"yn\":\n",
                    "rendered": {
                      "text": "        value = \",\".join(_format_option_value(optdict, item) for item in value)\n    elif isinstance(value, dict):\n        value = \",\".join(f\"{k}:{v}\" for k, v in value.items())\n    elif hasattr(value, \"match\"):  # optdict.get('type') == 'regexp'\n        # compiled regexp\n        value = value.pattern\n    elif optdict.get(\"type\") == \"yn\":\n",
                      "markdown": "`        value = \",\".join(_format_option_value(optdict, item) for item in value)\n    elif isinstance(value, dict):\n        value = \",\".join(f\"{k}:{v}\" for k, v in value.items())\n    elif hasattr(value, \"match\"):  # optdict.get('type') == 'regexp'\n        # compiled regexp\n        value = value.pattern\n    elif optdict.get(\"type\") == \"yn\":\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/utils.py"
                },
                "region": {
                  "startLine": 285,
                  "startColumn": 14,
                  "endLine": 285,
                  "endColumn": 19,
                  "snippet": {
                    "text": "\n    TODO: Refactor the code to not use this deprecated function\n    \"\"\"\n    if optdict.get(\"type\", None) == \"py_version\":\n        value = \".\".join(str(item) for item in value)\n    elif isinstance(value, (list, tuple)):\n        value = \",\".join(_format_option_value(optdict, item) for item in value)\n",
                    "rendered": {
                      "text": "\n    TODO: Refactor the code to not use this deprecated function\n    \"\"\"\n    if optdict.get(\"type\", None) == \"py_version\":\n        value = \".\".join(str(item) for item in value)\n    elif isinstance(value, (list, tuple)):\n        value = \",\".join(_format_option_value(optdict, item) for item in value)\n",
                      "markdown": "`\n    TODO: Refactor the code to not use this deprecated function\n    \"\"\"\n    if optdict.get(\"type\", None) == \"py_version\":\n        value = \".\".join(str(item) for item in value)\n    elif isinstance(value, (list, tuple)):\n        value = \",\".join(_format_option_value(optdict, item) for item in value)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/utils.py"
                },
                "region": {
                  "startLine": 140,
                  "startColumn": 26,
                  "endLine": 140,
                  "endColumn": 31,
                  "snippet": {
                    "text": "        formatted_doc = normalize_text(doc)\n        result += f\"{formatted_doc}\\n\\n\"\n    for optname, optdict, value in options:\n        help_opt = optdict.get(\"help\")\n        result += f\":{optname}:\\n\"\n        if help_opt:\n            assert isinstance(help_opt, str)\n",
                    "rendered": {
                      "text": "        formatted_doc = normalize_text(doc)\n        result += f\"{formatted_doc}\\n\\n\"\n    for optname, optdict, value in options:\n        help_opt = optdict.get(\"help\")\n        result += f\":{optname}:\\n\"\n        if help_opt:\n            assert isinstance(help_opt, str)\n",
                      "markdown": "`        formatted_doc = normalize_text(doc)\n        result += f\"{formatted_doc}\\n\\n\"\n    for optname, optdict, value in options:\n        help_opt = optdict.get(\"help\")\n        result += f\":{optname}:\\n\"\n        if help_opt:\n            assert isinstance(help_opt, str)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/utils.py"
                },
                "region": {
                  "startLine": 193,
                  "startColumn": 44,
                  "endLine": 193,
                  "endColumn": 51,
                  "snippet": {
                    "text": "                    os.path.join(directory, filename)\n                )\n            except ValueError:\n                # empty module name (usually Emacs auto-save files)\n                continue\n            except ImportError as exc:\n                print(f\"Problem importing module {filename}: {exc}\", file=sys.stderr)\n",
                    "rendered": {
                      "text": "                    os.path.join(directory, filename)\n                )\n            except ValueError:\n                # empty module name (usually Emacs auto-save files)\n                continue\n            except ImportError as exc:\n                print(f\"Problem importing module {filename}: {exc}\", file=sys.stderr)\n",
                      "markdown": "`                    os.path.join(directory, filename)\n                )\n            except ValueError:\n                # empty module name (usually Emacs auto-save files)\n                continue\n            except ImportError as exc:\n                print(f\"Problem importing module {filename}: {exc}\", file=sys.stderr)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/utils.py"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 3,
                  "endLine": 98,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\ndef diff_string(old: float, new: float) -> str:\n    \"\"\"Given an old and new value, return a string representing the difference.\"\"\"\n    diff = abs(old - new)\n    diff_str = f\"{CMPS[cmp(old, new)]}{diff and f'{diff:.2f}' or ''}\"\n    return diff_str\n\n",
                    "rendered": {
                      "text": "\ndef diff_string(old: float, new: float) -> str:\n    \"\"\"Given an old and new value, return a string representing the difference.\"\"\"\n    diff = abs(old - new)\n    diff_str = f\"{CMPS[cmp(old, new)]}{diff and f'{diff:.2f}' or ''}\"\n    return diff_str\n\n",
                      "markdown": "`\ndef diff_string(old: float, new: float) -> str:\n    \"\"\"Given an old and new value, return a string representing the difference.\"\"\"\n    diff = abs(old - new)\n    diff_str = f\"{CMPS[cmp(old, new)]}{diff and f'{diff:.2f}' or ''}\"\n    return diff_str\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/pragma_parser.py"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 25,
                  "endLine": 111,
                  "endColumn": 29,
                  "snippet": {
                    "text": "                    raise UnRecognizedOptionError(\n                        \"The keyword is unknown\", previous_token\n                    )\n                # Nothing at all detected before this assignment\n                raise InvalidPragmaError(\"Missing keyword before assignment\", \"\")\n            assignment_required = False\n        elif assignment_required:\n",
                    "rendered": {
                      "text": "                    raise UnRecognizedOptionError(\n                        \"The keyword is unknown\", previous_token\n                    )\n                # Nothing at all detected before this assignment\n                raise InvalidPragmaError(\"Missing keyword before assignment\", \"\")\n            assignment_required = False\n        elif assignment_required:\n",
                      "markdown": "`                    raise UnRecognizedOptionError(\n                        \"The keyword is unknown\", previous_token\n                    )\n                # Nothing at all detected before this assignment\n                raise InvalidPragmaError(\"Missing keyword before assignment\", \"\")\n            assignment_required = False\n        elif assignment_required:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/linterstats.py"
                },
                "region": {
                  "startLine": 299,
                  "startColumn": 38,
                  "endLine": 299,
                  "endColumn": 43,
                  "snippet": {
                    "text": "        self, modname: str, type_name: MessageTypesFullName\n    ) -> int:\n        \"\"\"Get a module message count.\"\"\"\n        return self.by_module[modname].get(type_name, 0)\n\n    def increase_single_message_count(self, type_name: str, increase: int) -> None:\n        \"\"\"Increase the message type count of an individual message type.\"\"\"\n",
                    "rendered": {
                      "text": "        self, modname: str, type_name: MessageTypesFullName\n    ) -> int:\n        \"\"\"Get a module message count.\"\"\"\n        return self.by_module[modname].get(type_name, 0)\n\n    def increase_single_message_count(self, type_name: str, increase: int) -> None:\n        \"\"\"Increase the message type count of an individual message type.\"\"\"\n",
                      "markdown": "`        self, modname: str, type_name: MessageTypesFullName\n    ) -> int:\n        \"\"\"Get a module message count.\"\"\"\n        return self.by_module[modname].get(type_name, 0)\n\n    def increase_single_message_count(self, type_name: str, increase: int) -> None:\n        \"\"\"Increase the message type count of an individual message type.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/linterstats.py"
                },
                "region": {
                  "startLine": 273,
                  "startColumn": 30,
                  "endLine": 273,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        \"\"\"Get a node count while handling some extra conditions.\"\"\"\n        if node_name == \"class\":\n            return self.node_count.get(\"klass\", 0)\n        return self.node_count.get(node_name, 0)\n\n    def reset_node_count(self) -> None:\n        \"\"\"Resets the node count attribute.\"\"\"\n",
                    "rendered": {
                      "text": "        \"\"\"Get a node count while handling some extra conditions.\"\"\"\n        if node_name == \"class\":\n            return self.node_count.get(\"klass\", 0)\n        return self.node_count.get(node_name, 0)\n\n    def reset_node_count(self) -> None:\n        \"\"\"Resets the node count attribute.\"\"\"\n",
                      "markdown": "`        \"\"\"Get a node count while handling some extra conditions.\"\"\"\n        if node_name == \"class\":\n            return self.node_count.get(\"klass\", 0)\n        return self.node_count.get(node_name, 0)\n\n    def reset_node_count(self) -> None:\n        \"\"\"Resets the node count attribute.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/linterstats.py"
                },
                "region": {
                  "startLine": 272,
                  "startColumn": 34,
                  "endLine": 272,
                  "endColumn": 39,
                  "snippet": {
                    "text": "    ) -> int:\n        \"\"\"Get a node count while handling some extra conditions.\"\"\"\n        if node_name == \"class\":\n            return self.node_count.get(\"klass\", 0)\n        return self.node_count.get(node_name, 0)\n\n    def reset_node_count(self) -> None:\n",
                    "rendered": {
                      "text": "    ) -> int:\n        \"\"\"Get a node count while handling some extra conditions.\"\"\"\n        if node_name == \"class\":\n            return self.node_count.get(\"klass\", 0)\n        return self.node_count.get(node_name, 0)\n\n    def reset_node_count(self) -> None:\n",
                      "markdown": "`    ) -> int:\n        \"\"\"Get a node count while handling some extra conditions.\"\"\"\n        if node_name == \"class\":\n            return self.node_count.get(\"klass\", 0)\n        return self.node_count.get(node_name, 0)\n\n    def reset_node_count(self) -> None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/linterstats.py"
                },
                "region": {
                  "startLine": 253,
                  "startColumn": 35,
                  "endLine": 253,
                  "endColumn": 40,
                  "snippet": {
                    "text": "        self, type_name: Literal[\"code\", \"comment\", \"docstring\", \"empty\", \"total\"]\n    ) -> int:\n        \"\"\"Get a code type count.\"\"\"\n        return self.code_type_count.get(type_name, 0)\n\n    def reset_code_count(self) -> None:\n        \"\"\"Resets the code_type_count attribute.\"\"\"\n",
                    "rendered": {
                      "text": "        self, type_name: Literal[\"code\", \"comment\", \"docstring\", \"empty\", \"total\"]\n    ) -> int:\n        \"\"\"Get a code type count.\"\"\"\n        return self.code_type_count.get(type_name, 0)\n\n    def reset_code_count(self) -> None:\n        \"\"\"Resets the code_type_count attribute.\"\"\"\n",
                      "markdown": "`        self, type_name: Literal[\"code\", \"comment\", \"docstring\", \"empty\", \"total\"]\n    ) -> int:\n        \"\"\"Get a code type count.\"\"\"\n        return self.code_type_count.get(type_name, 0)\n\n    def reset_code_count(self) -> None:\n        \"\"\"Resets the code_type_count attribute.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/linterstats.py"
                },
                "region": {
                  "startLine": 187,
                  "startColumn": 29,
                  "endLine": 187,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        \"\"\"Get a bad names node count.\"\"\"\n        if node_name == \"class\":\n            return self.bad_names.get(\"klass\", 0)\n        return self.bad_names.get(node_name, 0)\n\n    def increase_bad_name(self, node_name: str, increase: int) -> None:\n        \"\"\"Increase a bad names node count.\"\"\"\n",
                    "rendered": {
                      "text": "        \"\"\"Get a bad names node count.\"\"\"\n        if node_name == \"class\":\n            return self.bad_names.get(\"klass\", 0)\n        return self.bad_names.get(node_name, 0)\n\n    def increase_bad_name(self, node_name: str, increase: int) -> None:\n        \"\"\"Increase a bad names node count.\"\"\"\n",
                      "markdown": "`        \"\"\"Get a bad names node count.\"\"\"\n        if node_name == \"class\":\n            return self.bad_names.get(\"klass\", 0)\n        return self.bad_names.get(node_name, 0)\n\n    def increase_bad_name(self, node_name: str, increase: int) -> None:\n        \"\"\"Increase a bad names node count.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/linterstats.py"
                },
                "region": {
                  "startLine": 186,
                  "startColumn": 33,
                  "endLine": 186,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    ) -> int:\n        \"\"\"Get a bad names node count.\"\"\"\n        if node_name == \"class\":\n            return self.bad_names.get(\"klass\", 0)\n        return self.bad_names.get(node_name, 0)\n\n    def increase_bad_name(self, node_name: str, increase: int) -> None:\n",
                    "rendered": {
                      "text": "    ) -> int:\n        \"\"\"Get a bad names node count.\"\"\"\n        if node_name == \"class\":\n            return self.bad_names.get(\"klass\", 0)\n        return self.bad_names.get(node_name, 0)\n\n    def increase_bad_name(self, node_name: str, increase: int) -> None:\n",
                      "markdown": "`    ) -> int:\n        \"\"\"Get a bad names node count.\"\"\"\n        if node_name == \"class\":\n            return self.bad_names.get(\"klass\", 0)\n        return self.bad_names.get(node_name, 0)\n\n    def increase_bad_name(self, node_name: str, increase: int) -> None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/linterstats.py"
                },
                "region": {
                  "startLine": 282,
                  "startColumn": 29,
                  "endLine": 282,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    def get_undocumented(\n        self, node_name: Literal[\"function\", \"class\", \"method\", \"module\"]\n    ) -> float:\n        \"\"\"Get a undocumented node count.\"\"\"\n        if node_name == \"class\":\n            return self.undocumented[\"klass\"]\n        return self.undocumented[node_name]\n",
                    "rendered": {
                      "text": "    def get_undocumented(\n        self, node_name: Literal[\"function\", \"class\", \"method\", \"module\"]\n    ) -> float:\n        \"\"\"Get a undocumented node count.\"\"\"\n        if node_name == \"class\":\n            return self.undocumented[\"klass\"]\n        return self.undocumented[node_name]\n",
                      "markdown": "`    def get_undocumented(\n        self, node_name: Literal[\"function\", \"class\", \"method\", \"module\"]\n    ) -> float:\n        \"\"\"Get a undocumented node count.\"\"\"\n        if node_name == \"class\":\n            return self.undocumented[\"klass\"]\n        return self.undocumented[node_name]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/linterstats.py"
                },
                "region": {
                  "startLine": 276,
                  "startColumn": 21,
                  "endLine": 276,
                  "endColumn": 27,
                  "snippet": {
                    "text": "        return self.node_count.get(node_name, 0)\n\n    def reset_node_count(self) -> None:\n        \"\"\"Resets the node count attribute.\"\"\"\n        self.node_count = NodeCount(function=0, klass=0, method=0, module=0)\n\n    def get_undocumented(\n",
                    "rendered": {
                      "text": "        return self.node_count.get(node_name, 0)\n\n    def reset_node_count(self) -> None:\n        \"\"\"Resets the node count attribute.\"\"\"\n        self.node_count = NodeCount(function=0, klass=0, method=0, module=0)\n\n    def get_undocumented(\n",
                      "markdown": "`        return self.node_count.get(node_name, 0)\n\n    def reset_node_count(self) -> None:\n        \"\"\"Resets the node count attribute.\"\"\"\n        self.node_count = NodeCount(function=0, klass=0, method=0, module=0)\n\n    def get_undocumented(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/linterstats.py"
                },
                "region": {
                  "startLine": 270,
                  "startColumn": 16,
                  "endLine": 270,
                  "endColumn": 22,
                  "snippet": {
                    "text": "    def get_node_count(\n        self, node_name: Literal[\"function\", \"class\", \"method\", \"module\"]\n    ) -> int:\n        \"\"\"Get a node count while handling some extra conditions.\"\"\"\n        if node_name == \"class\":\n            return self.node_count.get(\"klass\", 0)\n        return self.node_count.get(node_name, 0)\n",
                    "rendered": {
                      "text": "    def get_node_count(\n        self, node_name: Literal[\"function\", \"class\", \"method\", \"module\"]\n    ) -> int:\n        \"\"\"Get a node count while handling some extra conditions.\"\"\"\n        if node_name == \"class\":\n            return self.node_count.get(\"klass\", 0)\n        return self.node_count.get(node_name, 0)\n",
                      "markdown": "`    def get_node_count(\n        self, node_name: Literal[\"function\", \"class\", \"method\", \"module\"]\n    ) -> int:\n        \"\"\"Get a node count while handling some extra conditions.\"\"\"\n        if node_name == \"class\":\n            return self.node_count.get(\"klass\", 0)\n        return self.node_count.get(node_name, 0)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/linterstats.py"
                },
                "region": {
                  "startLine": 190,
                  "startColumn": 31,
                  "endLine": 190,
                  "endColumn": 37,
                  "snippet": {
                    "text": "        return self.bad_names.get(node_name, 0)\n\n    def increase_bad_name(self, node_name: str, increase: int) -> None:\n        \"\"\"Increase a bad names node count.\"\"\"\n        if node_name not in {\n            \"argument\",\n            \"attr\",\n",
                    "rendered": {
                      "text": "        return self.bad_names.get(node_name, 0)\n\n    def increase_bad_name(self, node_name: str, increase: int) -> None:\n        \"\"\"Increase a bad names node count.\"\"\"\n        if node_name not in {\n            \"argument\",\n            \"attr\",\n",
                      "markdown": "`        return self.bad_names.get(node_name, 0)\n\n    def increase_bad_name(self, node_name: str, increase: int) -> None:\n        \"\"\"Increase a bad names node count.\"\"\"\n        if node_name not in {\n            \"argument\",\n            \"attr\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/linterstats.py"
                },
                "region": {
                  "startLine": 184,
                  "startColumn": 26,
                  "endLine": 184,
                  "endColumn": 32,
                  "snippet": {
                    "text": "            \"typealias\",\n        ],\n    ) -> int:\n        \"\"\"Get a bad names node count.\"\"\"\n        if node_name == \"class\":\n            return self.bad_names.get(\"klass\", 0)\n        return self.bad_names.get(node_name, 0)\n",
                    "rendered": {
                      "text": "            \"typealias\",\n        ],\n    ) -> int:\n        \"\"\"Get a bad names node count.\"\"\"\n        if node_name == \"class\":\n            return self.bad_names.get(\"klass\", 0)\n        return self.bad_names.get(node_name, 0)\n",
                      "markdown": "`            \"typealias\",\n        ],\n    ) -> int:\n        \"\"\"Get a bad names node count.\"\"\"\n        if node_name == \"class\":\n            return self.bad_names.get(\"klass\", 0)\n        return self.bad_names.get(node_name, 0)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/linterstats.py"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 48,
                  "endLine": 57,
                  "endColumn": 54,
                  "snippet": {
                    "text": "\n\nclass UndocumentedNodes(TypedDict):\n    \"\"\"TypedDict to store counts of undocumented node types.\"\"\"\n\n    function: int\n    klass: int\n",
                    "rendered": {
                      "text": "\n\nclass UndocumentedNodes(TypedDict):\n    \"\"\"TypedDict to store counts of undocumented node types.\"\"\"\n\n    function: int\n    klass: int\n",
                      "markdown": "`\n\nclass UndocumentedNodes(TypedDict):\n    \"\"\"TypedDict to store counts of undocumented node types.\"\"\"\n\n    function: int\n    klass: int\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/linterstats.py"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 35,
                  "endLine": 13,
                  "endColumn": 41,
                  "snippet": {
                    "text": "\n\nclass BadNames(TypedDict):\n    \"\"\"TypedDict to store counts of node types with bad names.\"\"\"\n\n    argument: int\n    attr: int\n",
                    "rendered": {
                      "text": "\n\nclass BadNames(TypedDict):\n    \"\"\"TypedDict to store counts of node types with bad names.\"\"\"\n\n    argument: int\n    attr: int\n",
                      "markdown": "`\n\nclass BadNames(TypedDict):\n    \"\"\"TypedDict to store counts of node types with bad names.\"\"\"\n\n    argument: int\n    attr: int\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/file_state.py"
                },
                "region": {
                  "startLine": 154,
                  "startColumn": 53,
                  "endLine": 154,
                  "endColumn": 58,
                  "snippet": {
                    "text": "                        not isinstance(node, nodes.Module)\n                        and node.fromlineno < line < lineno\n                    )\n                ) and line in self._module_msgs_state.get(msg.msgid, ()):\n                    continue\n                if line in lines:  # state change in the same block\n                    state = lines[line]\n",
                    "rendered": {
                      "text": "                        not isinstance(node, nodes.Module)\n                        and node.fromlineno < line < lineno\n                    )\n                ) and line in self._module_msgs_state.get(msg.msgid, ()):\n                    continue\n                if line in lines:  # state change in the same block\n                    state = lines[line]\n",
                      "markdown": "`                        not isinstance(node, nodes.Module)\n                        and node.fromlineno < line < lineno\n                    )\n                ) and line in self._module_msgs_state.get(msg.msgid, ()):\n                    continue\n                if line in lines:  # state change in the same block\n                    state = lines[line]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/file_state.py"
                },
                "region": {
                  "startLine": 134,
                  "startColumn": 66,
                  "endLine": 134,
                  "endColumn": 71,
                  "snippet": {
                    "text": "                if (\n                    first_ == node.fromlineno\n                    and first_ >= firstchildlineno\n                    and node.fromlineno in self._module_msgs_state.get(msg.msgid, ())\n                ):\n                    first_ = lineno\n\n",
                    "rendered": {
                      "text": "                if (\n                    first_ == node.fromlineno\n                    and first_ >= firstchildlineno\n                    and node.fromlineno in self._module_msgs_state.get(msg.msgid, ())\n                ):\n                    first_ = lineno\n\n",
                      "markdown": "`                if (\n                    first_ == node.fromlineno\n                    and first_ >= firstchildlineno\n                    and node.fromlineno in self._module_msgs_state.get(msg.msgid, ())\n                ):\n                    first_ = lineno\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/file_state.py"
                },
                "region": {
                  "startLine": 194,
                  "startColumn": 13,
                  "endLine": 194,
                  "endColumn": 21,
                  "snippet": {
                    "text": "        \"\"\"Set status (enabled/disable) for a given message at a given line.\"\"\"\n        assert line > 0\n        if scope != \"line\":\n            # Expand the status to cover all relevant block lines\n            self._set_state_on_block_lines(\n                self._msgs_store, self._module, msg, {line: status}\n            )\n",
                    "rendered": {
                      "text": "        \"\"\"Set status (enabled/disable) for a given message at a given line.\"\"\"\n        assert line > 0\n        if scope != \"line\":\n            # Expand the status to cover all relevant block lines\n            self._set_state_on_block_lines(\n                self._msgs_store, self._module, msg, {line: status}\n            )\n",
                      "markdown": "`        \"\"\"Set status (enabled/disable) for a given message at a given line.\"\"\"\n        assert line > 0\n        if scope != \"line\":\n            # Expand the status to cover all relevant block lines\n            self._set_state_on_block_lines(\n                self._msgs_store, self._module, msg, {line: status}\n            )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/file_state.py"
                },
                "region": {
                  "startLine": 191,
                  "startColumn": 59,
                  "endLine": 191,
                  "endColumn": 63,
                  "snippet": {
                    "text": "        status: bool,\n        scope: str = \"package\",\n    ) -> None:\n        \"\"\"Set status (enabled/disable) for a given message at a given line.\"\"\"\n        assert line > 0\n        if scope != \"line\":\n            # Expand the status to cover all relevant block lines\n",
                    "rendered": {
                      "text": "        status: bool,\n        scope: str = \"package\",\n    ) -> None:\n        \"\"\"Set status (enabled/disable) for a given message at a given line.\"\"\"\n        assert line > 0\n        if scope != \"line\":\n            # Expand the status to cover all relevant block lines\n",
                      "markdown": "`        status: bool,\n        scope: str = \"package\",\n    ) -> None:\n        \"\"\"Set status (enabled/disable) for a given message at a given line.\"\"\"\n        assert line > 0\n        if scope != \"line\":\n            # Expand the status to cover all relevant block lines\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/file_state.py"
                },
                "region": {
                  "startLine": 178,
                  "startColumn": 9,
                  "endLine": 178,
                  "endColumn": 17,
                  "snippet": {
                    "text": "        else:\n            self._suppression_mapping.pop((msg.msgid, line), None)\n\n        # Update message state for respective line\n        try:\n            self._module_msgs_state[msg.msgid][line] = state\n        except KeyError:\n",
                    "rendered": {
                      "text": "        else:\n            self._suppression_mapping.pop((msg.msgid, line), None)\n\n        # Update message state for respective line\n        try:\n            self._module_msgs_state[msg.msgid][line] = state\n        except KeyError:\n",
                      "markdown": "`        else:\n            self._suppression_mapping.pop((msg.msgid, line), None)\n\n        # Update message state for respective line\n        try:\n            self._module_msgs_state[msg.msgid][line] = state\n        except KeyError:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/file_state.py"
                },
                "region": {
                  "startLine": 172,
                  "startColumn": 9,
                  "endLine": 172,
                  "endColumn": 17,
                  "snippet": {
                    "text": "        original_lineno: int,\n    ) -> None:\n        \"\"\"Set the state of a message on a line.\"\"\"\n        # Update suppression mapping\n        if not state:\n            self._suppression_mapping[(msg.msgid, line)] = original_lineno\n        else:\n",
                    "rendered": {
                      "text": "        original_lineno: int,\n    ) -> None:\n        \"\"\"Set the state of a message on a line.\"\"\"\n        # Update suppression mapping\n        if not state:\n            self._suppression_mapping[(msg.msgid, line)] = original_lineno\n        else:\n",
                      "markdown": "`        original_lineno: int,\n    ) -> None:\n        \"\"\"Set the state of a message on a line.\"\"\"\n        # Update suppression mapping\n        if not state:\n            self._suppression_mapping[(msg.msgid, line)] = original_lineno\n        else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/file_state.py"
                },
                "region": {
                  "startLine": 194,
                  "startColumn": 13,
                  "endLine": 194,
                  "endColumn": 21,
                  "snippet": {
                    "text": "        \"\"\"Set status (enabled/disable) for a given message at a given line.\"\"\"\n        assert line > 0\n        if scope != \"line\":\n            # Expand the status to cover all relevant block lines\n            self._set_state_on_block_lines(\n                self._msgs_store, self._module, msg, {line: status}\n            )\n",
                    "rendered": {
                      "text": "        \"\"\"Set status (enabled/disable) for a given message at a given line.\"\"\"\n        assert line > 0\n        if scope != \"line\":\n            # Expand the status to cover all relevant block lines\n            self._set_state_on_block_lines(\n                self._msgs_store, self._module, msg, {line: status}\n            )\n",
                      "markdown": "`        \"\"\"Set status (enabled/disable) for a given message at a given line.\"\"\"\n        assert line > 0\n        if scope != \"line\":\n            # Expand the status to cover all relevant block lines\n            self._set_state_on_block_lines(\n                self._msgs_store, self._module, msg, {line: status}\n            )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/file_state.py"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 54,
                  "endLine": 143,
                  "endColumn": 60,
                  "snippet": {
                    "text": "                last_ = last\n            for line in range(first_, last_ + 1):\n                # Do not override existing entries. This is especially important\n                # when parsing the states for a scoped node where some line-disables\n                # have already been parsed.\n                if (\n                    (\n",
                    "rendered": {
                      "text": "                last_ = last\n            for line in range(first_, last_ + 1):\n                # Do not override existing entries. This is especially important\n                # when parsing the states for a scoped node where some line-disables\n                # have already been parsed.\n                if (\n                    (\n",
                      "markdown": "`                last_ = last\n            for line in range(first_, last_ + 1):\n                # Do not override existing entries. This is especially important\n                # when parsing the states for a scoped node where some line-disables\n                # have already been parsed.\n                if (\n                    (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/file_state.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 45,
                  "endLine": 69,
                  "endColumn": 51,
                  "snippet": {
                    "text": "        for child in node.get_children():\n            self._set_state_on_block_lines(msgs_store, child, msg, msg_state)\n        # first child line number used to distinguish between disable\n        # which are the first child of scoped node with those defined later.\n        # For instance in the code below:\n        #\n        # 1.   def meth8(self):\n",
                    "rendered": {
                      "text": "        for child in node.get_children():\n            self._set_state_on_block_lines(msgs_store, child, msg, msg_state)\n        # first child line number used to distinguish between disable\n        # which are the first child of scoped node with those defined later.\n        # For instance in the code below:\n        #\n        # 1.   def meth8(self):\n",
                      "markdown": "`        for child in node.get_children():\n            self._set_state_on_block_lines(msgs_store, child, msg, msg_state)\n        # first child line number used to distinguish between disable\n        # which are the first child of scoped node with those defined later.\n        # For instance in the code below:\n        #\n        # 1.   def meth8(self):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/file_state.py"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 22,
                  "endLine": 46,
                  "snippet": {
                    "text": "            collections.defaultdict(set)\n        )\n        self._suppression_mapping: dict[tuple[str, int], int] = {}\n        self._module = node\n        if node:\n            self._effective_max_line_number = node.tolineno\n        else:\n            self._effective_max_line_number = None\n",
                    "rendered": {
                      "text": "            collections.defaultdict(set)\n        )\n        self._suppression_mapping: dict[tuple[str, int], int] = {}\n        self._module = node\n        if node:\n            self._effective_max_line_number = node.tolineno\n        else:\n            self._effective_max_line_number = None\n",
                      "markdown": "`            collections.defaultdict(set)\n        )\n        self._suppression_mapping: dict[tuple[str, int], int] = {}\n        self._module = node\n        if node:\n            self._effective_max_line_number = node.tolineno\n        else:\n            self._effective_max_line_number = None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/docs.py"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 14,
                  "endLine": 72,
                  "endColumn": 23,
                  "snippet": {
                    "text": "\nPylint checkers can provide three set of features:\n\n* options that control their execution,\n* messages that they can raise,\n* reports that they can generate.\n\n",
                    "rendered": {
                      "text": "\nPylint checkers can provide three set of features:\n\n* options that control their execution,\n* messages that they can raise,\n* reports that they can generate.\n\n",
                      "markdown": "`\nPylint checkers can provide three set of features:\n\n* options that control their execution,\n* messages that they can raise,\n* reports that they can generate.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/ast_walker.py"
                },
                "region": {
                  "startLine": 97,
                  "startColumn": 34,
                  "endLine": 97,
                  "endColumn": 40,
                  "snippet": {
                    "text": "            if self.exception_msg is False:\n                file = getattr(astroid.root(), \"file\", None)\n                print(\n                    f\"Exception on node {astroid!r} in file '{file}'\",\n                    file=sys.stderr,\n                )\n                traceback.print_exc()\n",
                    "rendered": {
                      "text": "            if self.exception_msg is False:\n                file = getattr(astroid.root(), \"file\", None)\n                print(\n                    f\"Exception on node {astroid!r} in file '{file}'\",\n                    file=sys.stderr,\n                )\n                traceback.print_exc()\n",
                      "markdown": "`            if self.exception_msg is False:\n                file = getattr(astroid.root(), \"file\", None)\n                print(\n                    f\"Exception on node {astroid!r} in file '{file}'\",\n                    file=sys.stderr,\n                )\n                traceback.print_exc()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/ast_walker.py"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 38,
                  "endLine": 85,
                  "endColumn": 44,
                  "snippet": {
                    "text": "        try:\n            if astroid.is_statement:\n                self.nbstatements += 1\n            # generate events for this node on each checker\n            for callback in visit_events:\n                callback(astroid)\n            # recurse on children\n",
                    "rendered": {
                      "text": "        try:\n            if astroid.is_statement:\n                self.nbstatements += 1\n            # generate events for this node on each checker\n            for callback in visit_events:\n                callback(astroid)\n            # recurse on children\n",
                      "markdown": "`        try:\n            if astroid.is_statement:\n                self.nbstatements += 1\n            # generate events for this node on each checker\n            for callback in visit_events:\n                callback(astroid)\n            # recurse on children\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/utils/ast_walker.py"
                },
                "region": {
                  "startLine": 30,
                  "startColumn": 23,
                  "endLine": 30,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\nclass ASTWalker:\n    def __init__(self, linter: PyLinter) -> None:\n        # callbacks per node types\n        self.nbstatements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n",
                    "rendered": {
                      "text": "\nclass ASTWalker:\n    def __init__(self, linter: PyLinter) -> None:\n        # callbacks per node types\n        self.nbstatements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n",
                      "markdown": "`\nclass ASTWalker:\n    def __init__(self, linter: PyLinter) -> None:\n        # callbacks per node types\n        self.nbstatements = 0\n        self.visit_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n        self.leave_events: defaultdict[str, list[AstCallback]] = defaultdict(list)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/reporters/reports_handler_mix_in.py"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 34,
                  "endLine": 63,
                  "endColumn": 39,
                  "snippet": {
                    "text": "\n    def report_is_enabled(self, reportid: str) -> bool:\n        \"\"\"Is the report associated to the given identifier enabled ?\"\"\"\n        return self._reports_state.get(reportid, True)\n\n    def make_reports(  # type: ignore[misc] # ReportsHandlerMixIn is always mixed with PyLinter\n        self: PyLinter,\n",
                    "rendered": {
                      "text": "\n    def report_is_enabled(self, reportid: str) -> bool:\n        \"\"\"Is the report associated to the given identifier enabled ?\"\"\"\n        return self._reports_state.get(reportid, True)\n\n    def make_reports(  # type: ignore[misc] # ReportsHandlerMixIn is always mixed with PyLinter\n        self: PyLinter,\n",
                      "markdown": "`\n    def report_is_enabled(self, reportid: str) -> bool:\n        \"\"\"Is the report associated to the given identifier enabled ?\"\"\"\n        return self._reports_state.get(reportid, True)\n\n    def make_reports(  # type: ignore[misc] # ReportsHandlerMixIn is always mixed with PyLinter\n        self: PyLinter,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/comparison_placement.py"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 33,
                  "endLine": 51,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    ) -> None:\n        if isinstance(right, nodes.Const):\n            return\n        operator = REVERSED_COMPS.get(operator, operator)\n        suggestion = f\"{right.as_string()} {operator} {left.value!r}\"\n        self.add_message(\"misplaced-comparison-constant\", node=node, args=(suggestion,))\n\n",
                    "rendered": {
                      "text": "    ) -> None:\n        if isinstance(right, nodes.Const):\n            return\n        operator = REVERSED_COMPS.get(operator, operator)\n        suggestion = f\"{right.as_string()} {operator} {left.value!r}\"\n        self.add_message(\"misplaced-comparison-constant\", node=node, args=(suggestion,))\n\n",
                      "markdown": "`    ) -> None:\n        if isinstance(right, nodes.Const):\n            return\n        operator = REVERSED_COMPS.get(operator, operator)\n        suggestion = f\"{right.as_string()} {operator} {left.value!r}\"\n        self.add_message(\"misplaced-comparison-constant\", node=node, args=(suggestion,))\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/code_style.py"
                },
                "region": {
                  "startLine": 202,
                  "startColumn": 23,
                  "endLine": 202,
                  "endColumn": 27,
                  "snippet": {
                    "text": "                if len(dict_value.elts) != list_length:\n                    return\n\n            # Make sure at least one list entry isn't a dict\n            for _, dict_value in node.items:\n                if all(isinstance(entry, nodes.Dict) for entry in dict_value.elts):\n                    return\n",
                    "rendered": {
                      "text": "                if len(dict_value.elts) != list_length:\n                    return\n\n            # Make sure at least one list entry isn't a dict\n            for _, dict_value in node.items:\n                if all(isinstance(entry, nodes.Dict) for entry in dict_value.elts):\n                    return\n",
                      "markdown": "`                if len(dict_value.elts) != list_length:\n                    return\n\n            # Make sure at least one list entry isn't a dict\n            for _, dict_value in node.items:\n                if all(isinstance(entry, nodes.Dict) for entry in dict_value.elts):\n                    return\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/code_style.py"
                },
                "region": {
                  "startLine": 173,
                  "startColumn": 42,
                  "endLine": 173,
                  "endColumn": 46,
                  "snippet": {
                    "text": "                        return\n                    keys_checked.add(key_tuple)\n\n            # Makes sure all subdicts have at least 1 common key\n            key_tuples: list[tuple[KeyTupleT, ...]] = []\n            for _, dict_value in node.items:\n                dict_value = cast(nodes.Dict, dict_value)\n",
                    "rendered": {
                      "text": "                        return\n                    keys_checked.add(key_tuple)\n\n            # Makes sure all subdicts have at least 1 common key\n            key_tuples: list[tuple[KeyTupleT, ...]] = []\n            for _, dict_value in node.items:\n                dict_value = cast(nodes.Dict, dict_value)\n",
                      "markdown": "`                        return\n                    keys_checked.add(key_tuple)\n\n            # Makes sure all subdicts have at least 1 common key\n            key_tuples: list[tuple[KeyTupleT, ...]] = []\n            for _, dict_value in node.items:\n                dict_value = cast(nodes.Dict, dict_value)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/code_style.py"
                },
                "region": {
                  "startLine": 243,
                  "startColumn": 32,
                  "endLine": 243,
                  "endColumn": 38,
                  "snippet": {
                    "text": "        else:\n            return\n\n        # Make sure the previous node is an assignment to the same name\n        # used in `node.test`. Furthermore, ignore if assignment spans multiple lines.\n        prev_sibling = node.previous_sibling()\n        if CodeStyleChecker._check_prev_sibling_to_if_stmt(\n",
                    "rendered": {
                      "text": "        else:\n            return\n\n        # Make sure the previous node is an assignment to the same name\n        # used in `node.test`. Furthermore, ignore if assignment spans multiple lines.\n        prev_sibling = node.previous_sibling()\n        if CodeStyleChecker._check_prev_sibling_to_if_stmt(\n",
                      "markdown": "`        else:\n            return\n\n        # Make sure the previous node is an assignment to the same name\n        # used in `node.test`. Furthermore, ignore if assignment spans multiple lines.\n        prev_sibling = node.previous_sibling()\n        if CodeStyleChecker._check_prev_sibling_to_if_stmt(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/code_style.py"
                },
                "region": {
                  "startLine": 224,
                  "startColumn": 48,
                  "endLine": 225,
                  "snippet": {
                    "text": "\n        Note: Assignment expressions were added in Python 3.8\n        \"\"\"\n        # Check if `node.test` contains a `Name` node\n        node_name: nodes.Name | None = None\n        if isinstance(node.test, nodes.Name):\n            node_name = node.test\n        elif (\n",
                    "rendered": {
                      "text": "\n        Note: Assignment expressions were added in Python 3.8\n        \"\"\"\n        # Check if `node.test` contains a `Name` node\n        node_name: nodes.Name | None = None\n        if isinstance(node.test, nodes.Name):\n            node_name = node.test\n        elif (\n",
                      "markdown": "`\n        Note: Assignment expressions were added in Python 3.8\n        \"\"\"\n        # Check if `node.test` contains a `Name` node\n        node_name: nodes.Name | None = None\n        if isinstance(node.test, nodes.Name):\n            node_name = node.test\n        elif (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/code_style.py"
                },
                "region": {
                  "startLine": 147,
                  "startColumn": 63,
                  "endLine": 147,
                  "endColumn": 69,
                  "snippet": {
                    "text": "            and isinstance(node.parent.target, nodes.AssignName)\n            and utils.is_assign_name_annotated_with(node.parent.target, \"Final\")\n        ):\n            # If dict is not part of an 'Assign' or 'AnnAssign' node in\n            # a module context OR 'AnnAssign' with 'Final' annotation, skip check.\n            return\n\n",
                    "rendered": {
                      "text": "            and isinstance(node.parent.target, nodes.AssignName)\n            and utils.is_assign_name_annotated_with(node.parent.target, \"Final\")\n        ):\n            # If dict is not part of an 'Assign' or 'AnnAssign' node in\n            # a module context OR 'AnnAssign' with 'Final' annotation, skip check.\n            return\n\n",
                      "markdown": "`            and isinstance(node.parent.target, nodes.AssignName)\n            and utils.is_assign_name_annotated_with(node.parent.target, \"Final\")\n        ):\n            # If dict is not part of an 'Assign' or 'AnnAssign' node in\n            # a module context OR 'AnnAssign' with 'Final' annotation, skip check.\n            return\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/check_elif.py"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 21,
                  "endLine": 53,
                  "endColumn": 27,
                  "snippet": {
                    "text": "\n    @only_required_for_messages(\"else-if-used\")\n    def visit_if(self, node: nodes.If) -> None:\n        \"\"\"Current if node must directly follow an 'else'.\"\"\"\n        if (\n            isinstance(node.parent, nodes.If)\n            and node.parent.orelse == [node]\n",
                    "rendered": {
                      "text": "\n    @only_required_for_messages(\"else-if-used\")\n    def visit_if(self, node: nodes.If) -> None:\n        \"\"\"Current if node must directly follow an 'else'.\"\"\"\n        if (\n            isinstance(node.parent, nodes.If)\n            and node.parent.orelse == [node]\n",
                      "markdown": "`\n    @only_required_for_messages(\"else-if-used\")\n    def visit_if(self, node: nodes.If) -> None:\n        \"\"\"Current if node must directly follow an 'else'.\"\"\"\n        if (\n            isinstance(node.parent, nodes.If)\n            and node.parent.orelse == [node]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/bad_builtin.py"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 40,
                  "endLine": 59,
                  "endColumn": 45,
                  "snippet": {
                    "text": "            # locals nor globals scope)\n            if not (name in node.frame() or name in node.root()):\n                if name in self.linter.config.bad_functions:\n                    hint = BUILTIN_HINTS.get(name)\n                    args = f\"{name!r}. {hint}\" if hint else repr(name)\n                    self.add_message(\"bad-builtin\", node=node, args=args)\n\n",
                    "rendered": {
                      "text": "            # locals nor globals scope)\n            if not (name in node.frame() or name in node.root()):\n                if name in self.linter.config.bad_functions:\n                    hint = BUILTIN_HINTS.get(name)\n                    args = f\"{name!r}. {hint}\" if hint else repr(name)\n                    self.add_message(\"bad-builtin\", node=node, args=args)\n\n",
                      "markdown": "`            # locals nor globals scope)\n            if not (name in node.frame() or name in node.root()):\n                if name in self.linter.config.bad_functions:\n                    hint = BUILTIN_HINTS.get(name)\n                    args = f\"{name!r}. {hint}\" if hint else repr(name)\n                    self.add_message(\"bad-builtin\", node=node, args=args)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/constants.py"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 3,
                  "endLine": 57,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\n\n\nfull_version = f\"\"\"pylint {__version__}\n",
                    "rendered": {
                      "text": "\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\n\n\nfull_version = f\"\"\"pylint {__version__}\n",
                      "markdown": "`\nclass WarningScope:\n    LINE = \"line-based-msg\"\n    NODE = \"node-based-msg\"\n\n\nfull_version = f\"\"\"pylint {__version__}\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 130,
                  "startColumn": 23,
                  "endLine": 130,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        arg_help=optdict.get(\"help\", \"\"),\n        metavar=optdict.get(\"metavar\", \"\"),\n        hide_help=optdict.get(\"hide\", False),\n        section=optdict.get(\"group\", None),\n    )\n\n\n",
                    "rendered": {
                      "text": "        arg_help=optdict.get(\"help\", \"\"),\n        metavar=optdict.get(\"metavar\", \"\"),\n        hide_help=optdict.get(\"hide\", False),\n        section=optdict.get(\"group\", None),\n    )\n\n\n",
                      "markdown": "`        arg_help=optdict.get(\"help\", \"\"),\n        metavar=optdict.get(\"metavar\", \"\"),\n        hide_help=optdict.get(\"hide\", False),\n        section=optdict.get(\"group\", None),\n    )\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 129,
                  "startColumn": 25,
                  "endLine": 129,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        choices=optdict.get(\"choices\", None),\n        arg_help=optdict.get(\"help\", \"\"),\n        metavar=optdict.get(\"metavar\", \"\"),\n        hide_help=optdict.get(\"hide\", False),\n        section=optdict.get(\"group\", None),\n    )\n\n",
                    "rendered": {
                      "text": "        choices=optdict.get(\"choices\", None),\n        arg_help=optdict.get(\"help\", \"\"),\n        metavar=optdict.get(\"metavar\", \"\"),\n        hide_help=optdict.get(\"hide\", False),\n        section=optdict.get(\"group\", None),\n    )\n\n",
                      "markdown": "`        choices=optdict.get(\"choices\", None),\n        arg_help=optdict.get(\"help\", \"\"),\n        metavar=optdict.get(\"metavar\", \"\"),\n        hide_help=optdict.get(\"hide\", False),\n        section=optdict.get(\"group\", None),\n    )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 23,
                  "endLine": 128,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        arg_type=optdict[\"type\"],\n        choices=optdict.get(\"choices\", None),\n        arg_help=optdict.get(\"help\", \"\"),\n        metavar=optdict.get(\"metavar\", \"\"),\n        hide_help=optdict.get(\"hide\", False),\n        section=optdict.get(\"group\", None),\n    )\n",
                    "rendered": {
                      "text": "        arg_type=optdict[\"type\"],\n        choices=optdict.get(\"choices\", None),\n        arg_help=optdict.get(\"help\", \"\"),\n        metavar=optdict.get(\"metavar\", \"\"),\n        hide_help=optdict.get(\"hide\", False),\n        section=optdict.get(\"group\", None),\n    )\n",
                      "markdown": "`        arg_type=optdict[\"type\"],\n        choices=optdict.get(\"choices\", None),\n        arg_help=optdict.get(\"help\", \"\"),\n        metavar=optdict.get(\"metavar\", \"\"),\n        hide_help=optdict.get(\"hide\", False),\n        section=optdict.get(\"group\", None),\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 127,
                  "startColumn": 24,
                  "endLine": 127,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        default=default,\n        arg_type=optdict[\"type\"],\n        choices=optdict.get(\"choices\", None),\n        arg_help=optdict.get(\"help\", \"\"),\n        metavar=optdict.get(\"metavar\", \"\"),\n        hide_help=optdict.get(\"hide\", False),\n        section=optdict.get(\"group\", None),\n",
                    "rendered": {
                      "text": "        default=default,\n        arg_type=optdict[\"type\"],\n        choices=optdict.get(\"choices\", None),\n        arg_help=optdict.get(\"help\", \"\"),\n        metavar=optdict.get(\"metavar\", \"\"),\n        hide_help=optdict.get(\"hide\", False),\n        section=optdict.get(\"group\", None),\n",
                      "markdown": "`        default=default,\n        arg_type=optdict[\"type\"],\n        choices=optdict.get(\"choices\", None),\n        arg_help=optdict.get(\"help\", \"\"),\n        metavar=optdict.get(\"metavar\", \"\"),\n        hide_help=optdict.get(\"hide\", False),\n        section=optdict.get(\"group\", None),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 126,
                  "startColumn": 23,
                  "endLine": 126,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        action=action,\n        default=default,\n        arg_type=optdict[\"type\"],\n        choices=optdict.get(\"choices\", None),\n        arg_help=optdict.get(\"help\", \"\"),\n        metavar=optdict.get(\"metavar\", \"\"),\n        hide_help=optdict.get(\"hide\", False),\n",
                    "rendered": {
                      "text": "        action=action,\n        default=default,\n        arg_type=optdict[\"type\"],\n        choices=optdict.get(\"choices\", None),\n        arg_help=optdict.get(\"help\", \"\"),\n        metavar=optdict.get(\"metavar\", \"\"),\n        hide_help=optdict.get(\"hide\", False),\n",
                      "markdown": "`        action=action,\n        default=default,\n        arg_type=optdict[\"type\"],\n        choices=optdict.get(\"choices\", None),\n        arg_help=optdict.get(\"help\", \"\"),\n        metavar=optdict.get(\"metavar\", \"\"),\n        hide_help=optdict.get(\"hide\", False),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 119,
                  "startColumn": 27,
                  "endLine": 119,
                  "endColumn": 32,
                  "snippet": {
                    "text": "            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            kwargs={\"old_names\": [optdict[\"dest\"]]},\n            section=optdict.get(\"group\", None),\n        )\n    return _StoreArgument(\n        flags=flags,\n",
                    "rendered": {
                      "text": "            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            kwargs={\"old_names\": [optdict[\"dest\"]]},\n            section=optdict.get(\"group\", None),\n        )\n    return _StoreArgument(\n        flags=flags,\n",
                      "markdown": "`            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            kwargs={\"old_names\": [optdict[\"dest\"]]},\n            section=optdict.get(\"group\", None),\n        )\n    return _StoreArgument(\n        flags=flags,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 117,
                  "startColumn": 29,
                  "endLine": 117,
                  "endColumn": 34,
                  "snippet": {
                    "text": "            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            kwargs={\"old_names\": [optdict[\"dest\"]]},\n            section=optdict.get(\"group\", None),\n        )\n",
                    "rendered": {
                      "text": "            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            kwargs={\"old_names\": [optdict[\"dest\"]]},\n            section=optdict.get(\"group\", None),\n        )\n",
                      "markdown": "`            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            kwargs={\"old_names\": [optdict[\"dest\"]]},\n            section=optdict.get(\"group\", None),\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 116,
                  "startColumn": 27,
                  "endLine": 116,
                  "endColumn": 32,
                  "snippet": {
                    "text": "            arg_type=optdict[\"type\"],\n            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            kwargs={\"old_names\": [optdict[\"dest\"]]},\n            section=optdict.get(\"group\", None),\n",
                    "rendered": {
                      "text": "            arg_type=optdict[\"type\"],\n            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            kwargs={\"old_names\": [optdict[\"dest\"]]},\n            section=optdict.get(\"group\", None),\n",
                      "markdown": "`            arg_type=optdict[\"type\"],\n            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            kwargs={\"old_names\": [optdict[\"dest\"]]},\n            section=optdict.get(\"group\", None),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 115,
                  "startColumn": 28,
                  "endLine": 115,
                  "endColumn": 33,
                  "snippet": {
                    "text": "            default=default,\n            arg_type=optdict[\"type\"],\n            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            kwargs={\"old_names\": [optdict[\"dest\"]]},\n",
                    "rendered": {
                      "text": "            default=default,\n            arg_type=optdict[\"type\"],\n            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            kwargs={\"old_names\": [optdict[\"dest\"]]},\n",
                      "markdown": "`            default=default,\n            arg_type=optdict[\"type\"],\n            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            kwargs={\"old_names\": [optdict[\"dest\"]]},\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 114,
                  "startColumn": 27,
                  "endLine": 114,
                  "endColumn": 32,
                  "snippet": {
                    "text": "            flags=flags,\n            default=default,\n            arg_type=optdict[\"type\"],\n            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n",
                    "rendered": {
                      "text": "            flags=flags,\n            default=default,\n            arg_type=optdict[\"type\"],\n            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n",
                      "markdown": "`            flags=flags,\n            default=default,\n            arg_type=optdict[\"type\"],\n            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 31,
                  "endLine": 107,
                  "endColumn": 36,
                  "snippet": {
                    "text": "                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n            )\n    if \"dest\" in optdict:\n        return _StoreOldNamesArgument(\n",
                    "rendered": {
                      "text": "                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n            )\n    if \"dest\" in optdict:\n        return _StoreOldNamesArgument(\n",
                      "markdown": "`                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n            )\n    if \"dest\" in optdict:\n        return _StoreOldNamesArgument(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 106,
                  "startColumn": 30,
                  "endLine": 106,
                  "endColumn": 35,
                  "snippet": {
                    "text": "                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n            )\n    if \"dest\" in optdict:\n",
                    "rendered": {
                      "text": "                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n            )\n    if \"dest\" in optdict:\n",
                      "markdown": "`                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n            )\n    if \"dest\" in optdict:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 33,
                  "endLine": 105,
                  "endColumn": 38,
                  "snippet": {
                    "text": "                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n            )\n",
                    "rendered": {
                      "text": "                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n            )\n",
                      "markdown": "`                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n            )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 31,
                  "endLine": 104,
                  "endColumn": 36,
                  "snippet": {
                    "text": "                arg_type=optdict[\"type\"],\n                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n",
                    "rendered": {
                      "text": "                arg_type=optdict[\"type\"],\n                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n",
                      "markdown": "`                arg_type=optdict[\"type\"],\n                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 32,
                  "endLine": 103,
                  "endColumn": 37,
                  "snippet": {
                    "text": "                default=default,\n                arg_type=optdict[\"type\"],\n                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n",
                    "rendered": {
                      "text": "                default=default,\n                arg_type=optdict[\"type\"],\n                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n",
                      "markdown": "`                default=default,\n                arg_type=optdict[\"type\"],\n                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 31,
                  "endLine": 102,
                  "endColumn": 36,
                  "snippet": {
                    "text": "                flags=flags,\n                default=default,\n                arg_type=optdict[\"type\"],\n                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n",
                    "rendered": {
                      "text": "                flags=flags,\n                default=default,\n                arg_type=optdict[\"type\"],\n                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n",
                      "markdown": "`                flags=flags,\n                default=default,\n                arg_type=optdict[\"type\"],\n                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 31,
                  "endLine": 95,
                  "endColumn": 36,
                  "snippet": {
                    "text": "                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n            )\n        if \"new_names\" in optdict[\"kwargs\"]:\n            return _StoreNewNamesArgument(\n",
                    "rendered": {
                      "text": "                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n            )\n        if \"new_names\" in optdict[\"kwargs\"]:\n            return _StoreNewNamesArgument(\n",
                      "markdown": "`                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n            )\n        if \"new_names\" in optdict[\"kwargs\"]:\n            return _StoreNewNamesArgument(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 30,
                  "endLine": 94,
                  "endColumn": 35,
                  "snippet": {
                    "text": "                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n            )\n        if \"new_names\" in optdict[\"kwargs\"]:\n",
                    "rendered": {
                      "text": "                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n            )\n        if \"new_names\" in optdict[\"kwargs\"]:\n",
                      "markdown": "`                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n            )\n        if \"new_names\" in optdict[\"kwargs\"]:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 33,
                  "endLine": 93,
                  "endColumn": 38,
                  "snippet": {
                    "text": "                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n            )\n",
                    "rendered": {
                      "text": "                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n            )\n",
                      "markdown": "`                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n            )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 92,
                  "startColumn": 31,
                  "endLine": 92,
                  "endColumn": 36,
                  "snippet": {
                    "text": "                arg_type=optdict[\"type\"],\n                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n",
                    "rendered": {
                      "text": "                arg_type=optdict[\"type\"],\n                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n",
                      "markdown": "`                arg_type=optdict[\"type\"],\n                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n                section=optdict.get(\"group\", None),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 91,
                  "startColumn": 32,
                  "endLine": 91,
                  "endColumn": 37,
                  "snippet": {
                    "text": "                default=default,\n                arg_type=optdict[\"type\"],\n                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n",
                    "rendered": {
                      "text": "                default=default,\n                arg_type=optdict[\"type\"],\n                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n",
                      "markdown": "`                default=default,\n                arg_type=optdict[\"type\"],\n                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n                kwargs=optdict.get(\"kwargs\", {}),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 90,
                  "startColumn": 31,
                  "endLine": 90,
                  "endColumn": 36,
                  "snippet": {
                    "text": "                flags=flags,\n                default=default,\n                arg_type=optdict[\"type\"],\n                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n",
                    "rendered": {
                      "text": "                flags=flags,\n                default=default,\n                arg_type=optdict[\"type\"],\n                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n",
                      "markdown": "`                flags=flags,\n                default=default,\n                arg_type=optdict[\"type\"],\n                choices=optdict.get(\"choices\", None),\n                arg_help=optdict.get(\"help\", \"\"),\n                metavar=optdict.get(\"metavar\", \"\"),\n                hide_help=optdict.get(\"hide\", False),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 24,
                  "endLine": 82,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            dest=optdict.get(\"dest\", None),\n        )\n    if \"kwargs\" in optdict:\n        if \"old_names\" in optdict[\"kwargs\"]:\n",
                    "rendered": {
                      "text": "            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            dest=optdict.get(\"dest\", None),\n        )\n    if \"kwargs\" in optdict:\n        if \"old_names\" in optdict[\"kwargs\"]:\n",
                      "markdown": "`            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            dest=optdict.get(\"dest\", None),\n        )\n    if \"kwargs\" in optdict:\n        if \"old_names\" in optdict[\"kwargs\"]:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 81,
                  "startColumn": 27,
                  "endLine": 81,
                  "endColumn": 32,
                  "snippet": {
                    "text": "            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            dest=optdict.get(\"dest\", None),\n        )\n    if \"kwargs\" in optdict:\n",
                    "rendered": {
                      "text": "            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            dest=optdict.get(\"dest\", None),\n        )\n    if \"kwargs\" in optdict:\n",
                      "markdown": "`            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            dest=optdict.get(\"dest\", None),\n        )\n    if \"kwargs\" in optdict:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 80,
                  "startColumn": 29,
                  "endLine": 80,
                  "endColumn": 34,
                  "snippet": {
                    "text": "            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            dest=optdict.get(\"dest\", None),\n        )\n",
                    "rendered": {
                      "text": "            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            dest=optdict.get(\"dest\", None),\n        )\n",
                      "markdown": "`            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            dest=optdict.get(\"dest\", None),\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 27,
                  "endLine": 79,
                  "endColumn": 32,
                  "snippet": {
                    "text": "            arg_type=optdict[\"type\"],\n            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            dest=optdict.get(\"dest\", None),\n",
                    "rendered": {
                      "text": "            arg_type=optdict[\"type\"],\n            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            dest=optdict.get(\"dest\", None),\n",
                      "markdown": "`            arg_type=optdict[\"type\"],\n            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            dest=optdict.get(\"dest\", None),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 28,
                  "endLine": 78,
                  "endColumn": 33,
                  "snippet": {
                    "text": "            default=[] if default is None else default,\n            arg_type=optdict[\"type\"],\n            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n",
                    "rendered": {
                      "text": "            default=[] if default is None else default,\n            arg_type=optdict[\"type\"],\n            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n",
                      "markdown": "`            default=[] if default is None else default,\n            arg_type=optdict[\"type\"],\n            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 27,
                  "endLine": 77,
                  "endColumn": 32,
                  "snippet": {
                    "text": "            action=action,\n            default=[] if default is None else default,\n            arg_type=optdict[\"type\"],\n            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n",
                    "rendered": {
                      "text": "            action=action,\n            default=[] if default is None else default,\n            arg_type=optdict[\"type\"],\n            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n",
                      "markdown": "`            action=action,\n            default=[] if default is None else default,\n            arg_type=optdict[\"type\"],\n            choices=optdict.get(\"choices\", None),\n            arg_help=optdict.get(\"help\", \"\"),\n            metavar=optdict.get(\"metavar\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 27,
                  "endLine": 66,
                  "endColumn": 32,
                  "snippet": {
                    "text": "            kwargs=optdict.get(\"kwargs\", {}),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            metavar=optdict.get(\"metavar\", None),\n        )\n\n    default = optdict[\"default\"]\n",
                    "rendered": {
                      "text": "            kwargs=optdict.get(\"kwargs\", {}),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            metavar=optdict.get(\"metavar\", None),\n        )\n\n    default = optdict[\"default\"]\n",
                      "markdown": "`            kwargs=optdict.get(\"kwargs\", {}),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            metavar=optdict.get(\"metavar\", None),\n        )\n\n    default = optdict[\"default\"]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 27,
                  "endLine": 65,
                  "endColumn": 32,
                  "snippet": {
                    "text": "            arg_help=optdict.get(\"help\", \"\"),\n            kwargs=optdict.get(\"kwargs\", {}),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            metavar=optdict.get(\"metavar\", None),\n        )\n\n",
                    "rendered": {
                      "text": "            arg_help=optdict.get(\"help\", \"\"),\n            kwargs=optdict.get(\"kwargs\", {}),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            metavar=optdict.get(\"metavar\", None),\n        )\n\n",
                      "markdown": "`            arg_help=optdict.get(\"help\", \"\"),\n            kwargs=optdict.get(\"kwargs\", {}),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            metavar=optdict.get(\"metavar\", None),\n        )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 64,
                  "startColumn": 29,
                  "endLine": 64,
                  "endColumn": 34,
                  "snippet": {
                    "text": "            action=action,\n            arg_help=optdict.get(\"help\", \"\"),\n            kwargs=optdict.get(\"kwargs\", {}),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            metavar=optdict.get(\"metavar\", None),\n        )\n",
                    "rendered": {
                      "text": "            action=action,\n            arg_help=optdict.get(\"help\", \"\"),\n            kwargs=optdict.get(\"kwargs\", {}),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            metavar=optdict.get(\"metavar\", None),\n        )\n",
                      "markdown": "`            action=action,\n            arg_help=optdict.get(\"help\", \"\"),\n            kwargs=optdict.get(\"kwargs\", {}),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            metavar=optdict.get(\"metavar\", None),\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 26,
                  "endLine": 63,
                  "endColumn": 31,
                  "snippet": {
                    "text": "            flags=flags,\n            action=action,\n            arg_help=optdict.get(\"help\", \"\"),\n            kwargs=optdict.get(\"kwargs\", {}),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            metavar=optdict.get(\"metavar\", None),\n",
                    "rendered": {
                      "text": "            flags=flags,\n            action=action,\n            arg_help=optdict.get(\"help\", \"\"),\n            kwargs=optdict.get(\"kwargs\", {}),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            metavar=optdict.get(\"metavar\", None),\n",
                      "markdown": "`            flags=flags,\n            action=action,\n            arg_help=optdict.get(\"help\", \"\"),\n            kwargs=optdict.get(\"kwargs\", {}),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n            metavar=optdict.get(\"metavar\", None),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 62,
                  "startColumn": 28,
                  "endLine": 62,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        return _CallableArgument(\n            flags=flags,\n            action=action,\n            arg_help=optdict.get(\"help\", \"\"),\n            kwargs=optdict.get(\"kwargs\", {}),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n",
                    "rendered": {
                      "text": "        return _CallableArgument(\n            flags=flags,\n            action=action,\n            arg_help=optdict.get(\"help\", \"\"),\n            kwargs=optdict.get(\"kwargs\", {}),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n",
                      "markdown": "`        return _CallableArgument(\n            flags=flags,\n            action=action,\n            arg_help=optdict.get(\"help\", \"\"),\n            kwargs=optdict.get(\"kwargs\", {}),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 27,
                  "endLine": 56,
                  "endColumn": 32,
                  "snippet": {
                    "text": "            default=optdict.get(\"default\", True),\n            arg_help=optdict.get(\"help\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n        )\n    if not isinstance(action, str) and issubclass(action, _CallbackAction):\n        return _CallableArgument(\n",
                    "rendered": {
                      "text": "            default=optdict.get(\"default\", True),\n            arg_help=optdict.get(\"help\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n        )\n    if not isinstance(action, str) and issubclass(action, _CallbackAction):\n        return _CallableArgument(\n",
                      "markdown": "`            default=optdict.get(\"default\", True),\n            arg_help=optdict.get(\"help\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n        )\n    if not isinstance(action, str) and issubclass(action, _CallbackAction):\n        return _CallableArgument(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 29,
                  "endLine": 55,
                  "endColumn": 34,
                  "snippet": {
                    "text": "            action=action,\n            default=optdict.get(\"default\", True),\n            arg_help=optdict.get(\"help\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n        )\n    if not isinstance(action, str) and issubclass(action, _CallbackAction):\n",
                    "rendered": {
                      "text": "            action=action,\n            default=optdict.get(\"default\", True),\n            arg_help=optdict.get(\"help\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n        )\n    if not isinstance(action, str) and issubclass(action, _CallbackAction):\n",
                      "markdown": "`            action=action,\n            default=optdict.get(\"default\", True),\n            arg_help=optdict.get(\"help\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n        )\n    if not isinstance(action, str) and issubclass(action, _CallbackAction):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 28,
                  "endLine": 54,
                  "endColumn": 33,
                  "snippet": {
                    "text": "            flags=flags,\n            action=action,\n            default=optdict.get(\"default\", True),\n            arg_help=optdict.get(\"help\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n        )\n",
                    "rendered": {
                      "text": "            flags=flags,\n            action=action,\n            default=optdict.get(\"default\", True),\n            arg_help=optdict.get(\"help\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n        )\n",
                      "markdown": "`            flags=flags,\n            action=action,\n            default=optdict.get(\"default\", True),\n            arg_help=optdict.get(\"help\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 27,
                  "endLine": 53,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        return _StoreTrueArgument(\n            flags=flags,\n            action=action,\n            default=optdict.get(\"default\", True),\n            arg_help=optdict.get(\"help\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n",
                    "rendered": {
                      "text": "        return _StoreTrueArgument(\n            flags=flags,\n            action=action,\n            default=optdict.get(\"default\", True),\n            arg_help=optdict.get(\"help\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n",
                      "markdown": "`        return _StoreTrueArgument(\n            flags=flags,\n            action=action,\n            default=optdict.get(\"default\", True),\n            arg_help=optdict.get(\"help\", \"\"),\n            hide_help=optdict.get(\"hide\", False),\n            section=optdict.get(\"group\", None),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 47,
                  "startColumn": 20,
                  "endLine": 47,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        flags += [f\"-{optdict['short']}\"]\n\n    # Get the action type\n    action = optdict.get(\"action\", \"store\")\n\n    if action == \"store_true\":\n        return _StoreTrueArgument(\n",
                    "rendered": {
                      "text": "        flags += [f\"-{optdict['short']}\"]\n\n    # Get the action type\n    action = optdict.get(\"action\", \"store\")\n\n    if action == \"store_true\":\n        return _StoreTrueArgument(\n",
                      "markdown": "`        flags += [f\"-{optdict['short']}\"]\n\n    # Get the action type\n    action = optdict.get(\"action\", \"store\")\n\n    if action == \"store_true\":\n        return _StoreTrueArgument(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 195,
                  "startColumn": 17,
                  "endLine": 195,
                  "endColumn": 21,
                  "snippet": {
                    "text": "    # Argparse by default allows abbreviations. It behaves differently\n    # if you turn this off, so we also turn it on. We mimic this\n    # by allowing some abbreviations or incorrect spelling here.\n    # The integer at the end of the tuple indicates how many letters\n    # should match, include the '-'. 0 indicates a full match.\n    #\n    # Clashes with --init-(import)\n",
                    "rendered": {
                      "text": "    # Argparse by default allows abbreviations. It behaves differently\n    # if you turn this off, so we also turn it on. We mimic this\n    # by allowing some abbreviations or incorrect spelling here.\n    # The integer at the end of the tuple indicates how many letters\n    # should match, include the '-'. 0 indicates a full match.\n    #\n    # Clashes with --init-(import)\n",
                      "markdown": "`    # Argparse by default allows abbreviations. It behaves differently\n    # if you turn this off, so we also turn it on. We mimic this\n    # by allowing some abbreviations or incorrect spelling here.\n    # The integer at the end of the tuple indicates how many letters\n    # should match, include the '-'. 0 indicates a full match.\n    #\n    # Clashes with --init-(import)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/utils.py"
                },
                "region": {
                  "startLine": 254,
                  "startColumn": 70,
                  "endLine": 254,
                  "endColumn": 78,
                  "snippet": {
                    "text": "                raise ArgumentPreprocessingError(f\"Option {option} expects a value\")\n            value = args[i]\n        elif not takearg and value is not None:\n            raise ArgumentPreprocessingError(f\"Option {option} doesn't expect a value\")\n\n        cb(run, value)\n        i += 1\n",
                    "rendered": {
                      "text": "                raise ArgumentPreprocessingError(f\"Option {option} expects a value\")\n            value = args[i]\n        elif not takearg and value is not None:\n            raise ArgumentPreprocessingError(f\"Option {option} doesn't expect a value\")\n\n        cb(run, value)\n        i += 1\n",
                      "markdown": "`                raise ArgumentPreprocessingError(f\"Option {option} expects a value\")\n            value = args[i]\n        elif not takearg and value is not None:\n            raise ArgumentPreprocessingError(f\"Option {option} doesn't expect a value\")\n\n        cb(run, value)\n        i += 1\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/find_default_config_files.py"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 30,
                  "endLine": 55,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        except tomllib.TOMLDecodeError as error:\n            print(f\"Failed to load '{path}': {error}\")\n            return False\n    return \"pylint\" in content.get(\"tool\", [])\n\n\ndef _cfg_or_ini_has_config(path: Path | str) -> bool:\n",
                    "rendered": {
                      "text": "        except tomllib.TOMLDecodeError as error:\n            print(f\"Failed to load '{path}': {error}\")\n            return False\n    return \"pylint\" in content.get(\"tool\", [])\n\n\ndef _cfg_or_ini_has_config(path: Path | str) -> bool:\n",
                      "markdown": "`        except tomllib.TOMLDecodeError as error:\n            print(f\"Failed to load '{path}': {error}\")\n            return False\n    return \"pylint\" in content.get(\"tool\", [])\n\n\ndef _cfg_or_ini_has_config(path: Path | str) -> bool:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/config/find_default_config_files.py"
                },
                "region": {
                  "startLine": 89,
                  "startColumn": 40,
                  "endLine": 89,
                  "endColumn": 46,
                  "snippet": {
                    "text": "\n\ndef _find_project_config() -> Iterator[Path]:\n    \"\"\"Traverse up the directory tree to find a config file.\n\n    Stop if no '__init__' is found and thus we are no longer in a package.\n    \"\"\"\n",
                    "rendered": {
                      "text": "\n\ndef _find_project_config() -> Iterator[Path]:\n    \"\"\"Traverse up the directory tree to find a config file.\n\n    Stop if no '__init__' is found and thus we are no longer in a package.\n    \"\"\"\n",
                      "markdown": "`\n\ndef _find_project_config() -> Iterator[Path]:\n    \"\"\"Traverse up the directory tree to find a config file.\n\n    Stop if no '__init__' is found and thus we are no longer in a package.\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/implicit_booleaness_checker.py"
                },
                "region": {
                  "startLine": 319,
                  "startColumn": 9,
                  "endLine": 319,
                  "endColumn": 14,
                  "snippet": {
                    "text": "            \"list\": \"[]\",\n            \"tuple\": \"()\",\n            \"dict\": \"{}\",\n        }.get(description, \"iterable\")\n        instance_name = \"x\"\n        if isinstance(target_node, nodes.Call) and target_node.func:\n            instance_name = f\"{target_node.func.as_string()}(...)\"\n",
                    "rendered": {
                      "text": "            \"list\": \"[]\",\n            \"tuple\": \"()\",\n            \"dict\": \"{}\",\n        }.get(description, \"iterable\")\n        instance_name = \"x\"\n        if isinstance(target_node, nodes.Call) and target_node.func:\n            instance_name = f\"{target_node.func.as_string()}(...)\"\n",
                      "markdown": "`            \"list\": \"[]\",\n            \"tuple\": \"()\",\n            \"dict\": \"{}\",\n        }.get(description, \"iterable\")\n        instance_name = \"x\"\n        if isinstance(target_node, nodes.Call) and target_node.func:\n            instance_name = f\"{target_node.func.as_string()}(...)\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/implicit_booleaness_checker.py"
                },
                "region": {
                  "startLine": 308,
                  "startColumn": 9,
                  "endLine": 308,
                  "endColumn": 14,
                  "snippet": {
                    "text": "            nodes.Tuple: \"tuple\",\n            nodes.Dict: \"dict\",\n            nodes.Const: \"str\",\n        }.get(type(node), \"iterable\")\n\n    def _implicit_booleaness_message_args(\n        self, literal_node: nodes.NodeNG, operator: str, target_node: nodes.NodeNG\n",
                    "rendered": {
                      "text": "            nodes.Tuple: \"tuple\",\n            nodes.Dict: \"dict\",\n            nodes.Const: \"str\",\n        }.get(type(node), \"iterable\")\n\n    def _implicit_booleaness_message_args(\n        self, literal_node: nodes.NodeNG, operator: str, target_node: nodes.NodeNG\n",
                      "markdown": "`            nodes.Tuple: \"tuple\",\n            nodes.Dict: \"dict\",\n            nodes.Const: \"str\",\n        }.get(type(node), \"iterable\")\n\n    def _implicit_booleaness_message_args(\n        self, literal_node: nodes.NodeNG, operator: str, target_node: nodes.NodeNG\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/implicit_booleaness_checker.py"
                },
                "region": {
                  "startLine": 291,
                  "startColumn": 69,
                  "endLine": 292,
                  "snippet": {
                    "text": "                ):\n                    continue\n\n                # No need to check for operator when visiting compare node\n                if operator in {\"==\", \"!=\", \">=\", \">\", \"<=\", \"<\"}:\n                    self.add_message(\n                        \"use-implicit-booleaness-not-comparison\",\n                        args=self._implicit_booleaness_message_args(\n",
                    "rendered": {
                      "text": "                ):\n                    continue\n\n                # No need to check for operator when visiting compare node\n                if operator in {\"==\", \"!=\", \">=\", \">\", \"<=\", \"<\"}:\n                    self.add_message(\n                        \"use-implicit-booleaness-not-comparison\",\n                        args=self._implicit_booleaness_message_args(\n",
                      "markdown": "`                ):\n                    continue\n\n                # No need to check for operator when visiting compare node\n                if operator in {\"==\", \"!=\", \">=\", \">\", \"<=\", \"<\"}:\n                    self.add_message(\n                        \"use-implicit-booleaness-not-comparison\",\n                        args=self._implicit_booleaness_message_args(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/implicit_booleaness_checker.py"
                },
                "region": {
                  "startLine": 284,
                  "startColumn": 22,
                  "endLine": 284,
                  "endColumn": 28,
                  "snippet": {
                    "text": "                    t in mother_classes for t in (\"tuple\", \"list\", \"dict\", \"set\")\n                )\n\n                # Only time we bypass check is when target_node is not inherited by\n                # collection literals and have its own __bool__ implementation.\n                if not is_base_comprehension_type and self.instance_has_bool(\n                    target_instance\n",
                    "rendered": {
                      "text": "                    t in mother_classes for t in (\"tuple\", \"list\", \"dict\", \"set\")\n                )\n\n                # Only time we bypass check is when target_node is not inherited by\n                # collection literals and have its own __bool__ implementation.\n                if not is_base_comprehension_type and self.instance_has_bool(\n                    target_instance\n",
                      "markdown": "`                    t in mother_classes for t in (\"tuple\", \"list\", \"dict\", \"set\")\n                )\n\n                # Only time we bypass check is when target_node is not inherited by\n                # collection literals and have its own __bool__ implementation.\n                if not is_base_comprehension_type and self.instance_has_bool(\n                    target_instance\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/implicit_booleaness_checker.py"
                },
                "region": {
                  "startLine": 275,
                  "startColumn": 23,
                  "endLine": 275,
                  "endColumn": 29,
                  "snippet": {
                    "text": "                # set target_node to opposite side of literal\n                target_node = node.left if is_right_empty_literal else comparator\n                literal_node = comparator if is_right_empty_literal else node.left\n                # Infer node to check\n                target_instance = utils.safe_infer(target_node)\n                if target_instance is None:\n                    continue\n",
                    "rendered": {
                      "text": "                # set target_node to opposite side of literal\n                target_node = node.left if is_right_empty_literal else comparator\n                literal_node = comparator if is_right_empty_literal else node.left\n                # Infer node to check\n                target_instance = utils.safe_infer(target_node)\n                if target_instance is None:\n                    continue\n",
                      "markdown": "`                # set target_node to opposite side of literal\n                target_node = node.left if is_right_empty_literal else comparator\n                literal_node = comparator if is_right_empty_literal else node.left\n                # Infer node to check\n                target_instance = utils.safe_infer(target_node)\n                if target_instance is None:\n                    continue\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/implicit_booleaness_checker.py"
                },
                "region": {
                  "startLine": 259,
                  "startColumn": 52,
                  "endLine": 259,
                  "endColumn": 58,
                  "snippet": {
                    "text": "    def _check_use_implicit_booleaness_not_comparison(\n        self, node: nodes.Compare\n    ) -> None:\n        \"\"\"Check for left side and right side of the node for empty literals.\"\"\"\n        is_left_empty_literal = utils.is_base_container(\n            node.left\n        ) or utils.is_empty_dict_literal(node.left)\n",
                    "rendered": {
                      "text": "    def _check_use_implicit_booleaness_not_comparison(\n        self, node: nodes.Compare\n    ) -> None:\n        \"\"\"Check for left side and right side of the node for empty literals.\"\"\"\n        is_left_empty_literal = utils.is_base_container(\n            node.left\n        ) or utils.is_empty_dict_literal(node.left)\n",
                      "markdown": "`    def _check_use_implicit_booleaness_not_comparison(\n        self, node: nodes.Compare\n    ) -> None:\n        \"\"\"Check for left side and right side of the node for empty literals.\"\"\"\n        is_left_empty_literal = utils.is_base_container(\n            node.left\n        ) or utils.is_empty_dict_literal(node.left)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/implicit_booleaness_checker.py"
                },
                "region": {
                  "startLine": 135,
                  "startColumn": 17,
                  "endLine": 135,
                  "endColumn": 23,
                  "snippet": {
                    "text": "            nodes.GeneratorExp,\n        )\n        if isinstance(len_arg, generator_or_comprehension):\n            # The node is a generator or comprehension as in len([x for x in ...])\n            self.add_message(\n                \"use-implicit-booleaness-not-len\",\n                node=node,\n",
                    "rendered": {
                      "text": "            nodes.GeneratorExp,\n        )\n        if isinstance(len_arg, generator_or_comprehension):\n            # The node is a generator or comprehension as in len([x for x in ...])\n            self.add_message(\n                \"use-implicit-booleaness-not-len\",\n                node=node,\n",
                      "markdown": "`            nodes.GeneratorExp,\n        )\n        if isinstance(len_arg, generator_or_comprehension):\n            # The node is a generator or comprehension as in len([x for x in ...])\n            self.add_message(\n                \"use-implicit-booleaness-not-len\",\n                node=node,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/comparison_checker.py"
                },
                "region": {
                  "startLine": 222,
                  "startColumn": 28,
                  "endLine": 223,
                  "snippet": {
                    "text": "    def _check_logical_tautology(self, node: nodes.Compare) -> None:\n        \"\"\"Check if identifier is compared against itself.\n\n        :param node: Compare node\n        :Example:\n        val = 786\n        if val == val:  # [comparison-with-itself]\n            pass\n",
                    "rendered": {
                      "text": "    def _check_logical_tautology(self, node: nodes.Compare) -> None:\n        \"\"\"Check if identifier is compared against itself.\n\n        :param node: Compare node\n        :Example:\n        val = 786\n        if val == val:  # [comparison-with-itself]\n            pass\n",
                      "markdown": "`    def _check_logical_tautology(self, node: nodes.Compare) -> None:\n        \"\"\"Check if identifier is compared against itself.\n\n        :param node: Compare node\n        :Example:\n        val = 786\n        if val == val:  # [comparison-with-itself]\n            pass\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/pyreverse.py"
                },
                "region": {
                  "startLine": 124,
                  "startColumn": 18,
                  "endLine": 124,
                  "endColumn": 23,
                  "snippet": {
                    "text": "            \"testoptions\", \"output_formats\", fallback=\"mmd\"\n        ).split(\",\"),\n        \"command_line_args\": shlex.split(\n            config.get(\"testoptions\", \"command_line_args\", fallback=\"\")\n        ),\n    }\n",
                    "rendered": {
                      "text": "            \"testoptions\", \"output_formats\", fallback=\"mmd\"\n        ).split(\",\"),\n        \"command_line_args\": shlex.split(\n            config.get(\"testoptions\", \"command_line_args\", fallback=\"\")\n        ),\n    }\n",
                      "markdown": "`            \"testoptions\", \"output_formats\", fallback=\"mmd\"\n        ).split(\",\"),\n        \"command_line_args\": shlex.split(\n            config.get(\"testoptions\", \"command_line_args\", fallback=\"\")\n        ),\n    }\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/pyreverse.py"
                },
                "region": {
                  "startLine": 120,
                  "startColumn": 32,
                  "endLine": 120,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    source_roots = config.get(\"testoptions\", \"source_roots\", fallback=None)\n    return {\n        \"source_roots\": source_roots.split(\",\") if source_roots else [],\n        \"output_formats\": config.get(\n            \"testoptions\", \"output_formats\", fallback=\"mmd\"\n        ).split(\",\"),\n        \"command_line_args\": shlex.split(\n",
                    "rendered": {
                      "text": "    source_roots = config.get(\"testoptions\", \"source_roots\", fallback=None)\n    return {\n        \"source_roots\": source_roots.split(\",\") if source_roots else [],\n        \"output_formats\": config.get(\n            \"testoptions\", \"output_formats\", fallback=\"mmd\"\n        ).split(\",\"),\n        \"command_line_args\": shlex.split(\n",
                      "markdown": "`    source_roots = config.get(\"testoptions\", \"source_roots\", fallback=None)\n    return {\n        \"source_roots\": source_roots.split(\",\") if source_roots else [],\n        \"output_formats\": config.get(\n            \"testoptions\", \"output_formats\", fallback=\"mmd\"\n        ).split(\",\"),\n        \"command_line_args\": shlex.split(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/pyreverse.py"
                },
                "region": {
                  "startLine": 117,
                  "startColumn": 25,
                  "endLine": 117,
                  "endColumn": 30,
                  "snippet": {
                    "text": "def _read_config(config_file: Path) -> TestFileOptions:\n    config = configparser.ConfigParser()\n    config.read(str(config_file))\n    source_roots = config.get(\"testoptions\", \"source_roots\", fallback=None)\n    return {\n        \"source_roots\": source_roots.split(\",\") if source_roots else [],\n        \"output_formats\": config.get(\n",
                    "rendered": {
                      "text": "def _read_config(config_file: Path) -> TestFileOptions:\n    config = configparser.ConfigParser()\n    config.read(str(config_file))\n    source_roots = config.get(\"testoptions\", \"source_roots\", fallback=None)\n    return {\n        \"source_roots\": source_roots.split(\",\") if source_roots else [],\n        \"output_formats\": config.get(\n",
                      "markdown": "`def _read_config(config_file: Path) -> TestFileOptions:\n    config = configparser.ConfigParser()\n    config.read(str(config_file))\n    source_roots = config.get(\"testoptions\", \"source_roots\", fallback=None)\n    return {\n        \"source_roots\": source_roots.split(\",\") if source_roots else [],\n        \"output_formats\": config.get(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/output_line.py"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 46,
                  "endLine": 98,
                  "endColumn": 54,
                  "snippet": {
                    "text": "                row[0], line, column, end_line, end_column, row[5], row[6], row[7]\n            )\n        except Exception:  # pylint: disable=broad-except\n            # We need this to not fail for the update script to work.\n            return cls(\"\", 0, 0, None, None, \"\", \"\", \"\")\n\n    def to_csv(self) -> tuple[str, str, str, str, str, str, str, str]:\n",
                    "rendered": {
                      "text": "                row[0], line, column, end_line, end_column, row[5], row[6], row[7]\n            )\n        except Exception:  # pylint: disable=broad-except\n            # We need this to not fail for the update script to work.\n            return cls(\"\", 0, 0, None, None, \"\", \"\", \"\")\n\n    def to_csv(self) -> tuple[str, str, str, str, str, str, str, str]:\n",
                      "markdown": "`                row[0], line, column, end_line, end_column, row[5], row[6], row[7]\n            )\n        except Exception:  # pylint: disable=broad-except\n            # We need this to not fail for the update script to work.\n            return cls(\"\", 0, 0, None, None, \"\", \"\", \"\")\n\n    def to_csv(self) -> tuple[str, str, str, str, str, str, str, str]:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/output_line.py"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 53,
                  "endLine": 98,
                  "endColumn": 61,
                  "snippet": {
                    "text": "                row[0], line, column, end_line, end_column, row[5], row[6], row[7]\n            )\n        except Exception:  # pylint: disable=broad-except\n            # We need this to not fail for the update script to work.\n            return cls(\"\", 0, 0, None, None, \"\", \"\", \"\")\n\n    def to_csv(self) -> tuple[str, str, str, str, str, str, str, str]:\n",
                    "rendered": {
                      "text": "                row[0], line, column, end_line, end_column, row[5], row[6], row[7]\n            )\n        except Exception:  # pylint: disable=broad-except\n            # We need this to not fail for the update script to work.\n            return cls(\"\", 0, 0, None, None, \"\", \"\", \"\")\n\n    def to_csv(self) -> tuple[str, str, str, str, str, str, str, str]:\n",
                      "markdown": "`                row[0], line, column, end_line, end_column, row[5], row[6], row[7]\n            )\n        except Exception:  # pylint: disable=broad-except\n            # We need this to not fail for the update script to work.\n            return cls(\"\", 0, 0, None, None, \"\", \"\", \"\")\n\n    def to_csv(self) -> tuple[str, str, str, str, str, str, str, str]:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/lint_module_test.py"
                },
                "region": {
                  "startLine": 316,
                  "startColumn": 59,
                  "endLine": 316,
                  "endColumn": 67,
                  "snippet": {
                    "text": "        expected_output: list[OutputLine],\n        actual_output: list[OutputLine],\n    ) -> None:\n        \"\"\"This is a function because we want to be able to update the text in\n        LintModuleOutputUpdate.\n        \"\"\"\n        assert expected_output == actual_output, self.error_msg_for_unequal_output(\n",
                    "rendered": {
                      "text": "        expected_output: list[OutputLine],\n        actual_output: list[OutputLine],\n    ) -> None:\n        \"\"\"This is a function because we want to be able to update the text in\n        LintModuleOutputUpdate.\n        \"\"\"\n        assert expected_output == actual_output, self.error_msg_for_unequal_output(\n",
                      "markdown": "`        expected_output: list[OutputLine],\n        actual_output: list[OutputLine],\n    ) -> None:\n        \"\"\"This is a function because we want to be able to update the text in\n        LintModuleOutputUpdate.\n        \"\"\"\n        assert expected_output == actual_output, self.error_msg_for_unequal_output(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/lint_module_test.py"
                },
                "region": {
                  "startLine": 301,
                  "startColumn": 27,
                  "endLine": 301,
                  "endColumn": 35,
                  "snippet": {
                    "text": "                \"\\nYou can update the expected output automatically with:\\n'\"\n                f\"python tests/test_functional.py {UPDATE_OPTION} -k \"\n                f'\"test_functional[{self._test_file.base}]\"\\'\\n\\n'\n                \"Here's the update text in case you can't:\\n\"\n            )\n            expected_csv = StringIO()\n            writer = csv.writer(expected_csv, dialect=\"test\")\n",
                    "rendered": {
                      "text": "                \"\\nYou can update the expected output automatically with:\\n'\"\n                f\"python tests/test_functional.py {UPDATE_OPTION} -k \"\n                f'\"test_functional[{self._test_file.base}]\"\\'\\n\\n'\n                \"Here's the update text in case you can't:\\n\"\n            )\n            expected_csv = StringIO()\n            writer = csv.writer(expected_csv, dialect=\"test\")\n",
                      "markdown": "`                \"\\nYou can update the expected output automatically with:\\n'\"\n                f\"python tests/test_functional.py {UPDATE_OPTION} -k \"\n                f'\"test_functional[{self._test_file.base}]\"\\'\\n\\n'\n                \"Here's the update text in case you can't:\\n\"\n            )\n            expected_csv = StringIO()\n            writer = csv.writer(expected_csv, dialect=\"test\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/lint_module_test.py"
                },
                "region": {
                  "startLine": 298,
                  "startColumn": 26,
                  "endLine": 298,
                  "endColumn": 34,
                  "snippet": {
                    "text": "            for line in sorted(unexpected, key=sort_by_line_number):\n                error_msg += f\"{line}\\n\"\n            error_msg += (\n                \"\\nYou can update the expected output automatically with:\\n'\"\n                f\"python tests/test_functional.py {UPDATE_OPTION} -k \"\n                f'\"test_functional[{self._test_file.base}]\"\\'\\n\\n'\n                \"Here's the update text in case you can't:\\n\"\n",
                    "rendered": {
                      "text": "            for line in sorted(unexpected, key=sort_by_line_number):\n                error_msg += f\"{line}\\n\"\n            error_msg += (\n                \"\\nYou can update the expected output automatically with:\\n'\"\n                f\"python tests/test_functional.py {UPDATE_OPTION} -k \"\n                f'\"test_functional[{self._test_file.base}]\"\\'\\n\\n'\n                \"Here's the update text in case you can't:\\n\"\n",
                      "markdown": "`            for line in sorted(unexpected, key=sort_by_line_number):\n                error_msg += f\"{line}\\n\"\n            error_msg += (\n                \"\\nYou can update the expected output automatically with:\\n'\"\n                f\"python tests/test_functional.py {UPDATE_OPTION} -k \"\n                f'\"test_functional[{self._test_file.base}]\"\\'\\n\\n'\n                \"Here's the update text in case you can't:\\n\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/functional/test_file.py"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 35,
                  "endLine": 84,
                  "endColumn": 40,
                  "snippet": {
                    "text": "            pass\n\n        for name, value in cp.items(\"testoptions\"):\n            conv = self._CONVERTERS.get(name, lambda v: v)\n\n            assert (\n                name in POSSIBLE_TEST_OPTIONS\n",
                    "rendered": {
                      "text": "            pass\n\n        for name, value in cp.items(\"testoptions\"):\n            conv = self._CONVERTERS.get(name, lambda v: v)\n\n            assert (\n                name in POSSIBLE_TEST_OPTIONS\n",
                      "markdown": "`            pass\n\n        for name, value in cp.items(\"testoptions\"):\n            conv = self._CONVERTERS.get(name, lambda v: v)\n\n            assert (\n                name in POSSIBLE_TEST_OPTIONS\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/functional/test_file.py"
                },
                "region": {
                  "startLine": 112,
                  "startColumn": 34,
                  "endLine": 112,
                  "endColumn": 40,
                  "snippet": {
                    "text": "        name = join(self._directory, self.base + ext)\n        if not check_exists or exists(name):\n            return name\n        raise NoFileError(f\"Cannot find '{name}'.\")\n",
                    "rendered": {
                      "text": "        name = join(self._directory, self.base + ext)\n        if not check_exists or exists(name):\n            return name\n        raise NoFileError(f\"Cannot find '{name}'.\")\n",
                      "markdown": "`        name = join(self._directory, self.base + ext)\n        if not check_exists or exists(name):\n            return name\n        raise NoFileError(f\"Cannot find '{name}'.\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/testutils/functional/test_file.py"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 7,
                  "endLine": 76,
                  "endColumn": 11,
                  "snippet": {
                    "text": "        return f\"FunctionalTest:{self.base}\"\n\n    def _parse_options(self) -> None:\n        cp = configparser.ConfigParser()\n        cp.add_section(\"testoptions\")\n        try:\n            cp.read(self.option_file)\n",
                    "rendered": {
                      "text": "        return f\"FunctionalTest:{self.base}\"\n\n    def _parse_options(self) -> None:\n        cp = configparser.ConfigParser()\n        cp.add_section(\"testoptions\")\n        try:\n            cp.read(self.option_file)\n",
                      "markdown": "`        return f\"FunctionalTest:{self.base}\"\n\n    def _parse_options(self) -> None:\n        cp = configparser.ConfigParser()\n        cp.add_section(\"testoptions\")\n        try:\n            cp.read(self.option_file)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/utils.py"
                },
                "region": {
                  "startLine": 186,
                  "startColumn": 29,
                  "endLine": 186,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        init_method = node.parent.parent\n        try:\n            annotations = dict(zip(init_method.locals, init_method.args.annotations))\n            ann = annotations.get(node.parent.value.name)\n        except AttributeError:\n            pass\n    else:\n",
                    "rendered": {
                      "text": "        init_method = node.parent.parent\n        try:\n            annotations = dict(zip(init_method.locals, init_method.args.annotations))\n            ann = annotations.get(node.parent.value.name)\n        except AttributeError:\n            pass\n    else:\n",
                      "markdown": "`        init_method = node.parent.parent\n        try:\n            annotations = dict(zip(init_method.locals, init_method.args.annotations))\n            ann = annotations.get(node.parent.value.name)\n        except AttributeError:\n            pass\n    else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/utils.py"
                },
                "region": {
                  "startLine": 136,
                  "startColumn": 29,
                  "endLine": 136,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    def get_callbacks(self, node: nodes.NodeNG) -> _CallbackTupleT:\n        \"\"\"Get callbacks from handler for the visited node.\"\"\"\n        klass = node.__class__\n        methods = self._cache.get(klass)\n        if methods is None:\n            kid = klass.__name__.lower()\n            e_method = getattr(\n",
                    "rendered": {
                      "text": "    def get_callbacks(self, node: nodes.NodeNG) -> _CallbackTupleT:\n        \"\"\"Get callbacks from handler for the visited node.\"\"\"\n        klass = node.__class__\n        methods = self._cache.get(klass)\n        if methods is None:\n            kid = klass.__name__.lower()\n            e_method = getattr(\n",
                      "markdown": "`    def get_callbacks(self, node: nodes.NodeNG) -> _CallbackTupleT:\n        \"\"\"Get callbacks from handler for the visited node.\"\"\"\n        klass = node.__class__\n        methods = self._cache.get(klass)\n        if methods is None:\n            kid = klass.__name__.lower()\n            e_method = getattr(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/utils.py"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 21,
                  "endLine": 37,
                  "endColumn": 26,
                  "snippet": {
                    "text": "def get_default_options() -> list[str]:\n    \"\"\"Read config file and return list of options.\"\"\"\n    options = []\n    home = os.environ.get(\"HOME\", \"\")\n    if home:\n        rcfile = os.path.join(home, RCFILE)\n        try:\n",
                    "rendered": {
                      "text": "def get_default_options() -> list[str]:\n    \"\"\"Read config file and return list of options.\"\"\"\n    options = []\n    home = os.environ.get(\"HOME\", \"\")\n    if home:\n        rcfile = os.path.join(home, RCFILE)\n        try:\n",
                      "markdown": "`def get_default_options() -> list[str]:\n    \"\"\"Read config file and return list of options.\"\"\"\n    options = []\n    home = os.environ.get(\"HOME\", \"\")\n    if home:\n        rcfile = os.path.join(home, RCFILE)\n        try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/utils.py"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 14,
                  "endLine": 37,
                  "endColumn": 25,
                  "snippet": {
                    "text": "def get_default_options() -> list[str]:\n    \"\"\"Read config file and return list of options.\"\"\"\n    options = []\n    home = os.environ.get(\"HOME\", \"\")\n    if home:\n        rcfile = os.path.join(home, RCFILE)\n        try:\n",
                    "rendered": {
                      "text": "def get_default_options() -> list[str]:\n    \"\"\"Read config file and return list of options.\"\"\"\n    options = []\n    home = os.environ.get(\"HOME\", \"\")\n    if home:\n        rcfile = os.path.join(home, RCFILE)\n        try:\n",
                      "markdown": "`def get_default_options() -> list[str]:\n    \"\"\"Read config file and return list of options.\"\"\"\n    options = []\n    home = os.environ.get(\"HOME\", \"\")\n    if home:\n        rcfile = os.path.join(home, RCFILE)\n        try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/utils.py"
                },
                "region": {
                  "startLine": 219,
                  "startColumn": 34,
                  "endLine": 219,
                  "endColumn": 40,
                  "snippet": {
                    "text": "\n\ndef infer_node(node: nodes.AssignAttr | nodes.AssignName) -> set[InferenceResult]:\n    \"\"\"Return a set containing the node annotation if it exists\n    otherwise return a set of the inferred types using the NodeNG.infer method.\n    \"\"\"\n    ann = get_annotation(node)\n",
                    "rendered": {
                      "text": "\n\ndef infer_node(node: nodes.AssignAttr | nodes.AssignName) -> set[InferenceResult]:\n    \"\"\"Return a set containing the node annotation if it exists\n    otherwise return a set of the inferred types using the NodeNG.infer method.\n    \"\"\"\n    ann = get_annotation(node)\n",
                      "markdown": "`\n\ndef infer_node(node: nodes.AssignAttr | nodes.AssignName) -> set[InferenceResult]:\n    \"\"\"Return a set containing the node annotation if it exists\n    otherwise return a set of the inferred types using the NodeNG.infer method.\n    \"\"\"\n    ann = get_annotation(node)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/utils.py"
                },
                "region": {
                  "startLine": 152,
                  "startColumn": 10,
                  "endLine": 152,
                  "endColumn": 16,
                  "snippet": {
                    "text": "\n    def visit(self, node: nodes.NodeNG) -> Any:\n        \"\"\"Launch the visit starting from the given node.\"\"\"\n        if node in self._visited:\n            return None\n\n        self._visited.add(node)\n",
                    "rendered": {
                      "text": "\n    def visit(self, node: nodes.NodeNG) -> Any:\n        \"\"\"Launch the visit starting from the given node.\"\"\"\n        if node in self._visited:\n            return None\n\n        self._visited.add(node)\n",
                      "markdown": "`\n    def visit(self, node: nodes.NodeNG) -> Any:\n        \"\"\"Launch the visit starting from the given node.\"\"\"\n        if node in self._visited:\n            return None\n\n        self._visited.add(node)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/utils.py"
                },
                "region": {
                  "startLine": 126,
                  "startColumn": 7,
                  "endLine": 126,
                  "endColumn": 13,
                  "snippet": {
                    "text": "    the node in lower case\n\n    * leave_<class name> on leaving a node, where class name is the class of\n    the node in lower case\n    \"\"\"\n\n    def __init__(self) -> None:\n",
                    "rendered": {
                      "text": "    the node in lower case\n\n    * leave_<class name> on leaving a node, where class name is the class of\n    the node in lower case\n    \"\"\"\n\n    def __init__(self) -> None:\n",
                      "markdown": "`    the node in lower case\n\n    * leave_<class name> on leaving a node, where class name is the class of\n    the node in lower case\n    \"\"\"\n\n    def __init__(self) -> None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/utils.py"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 7,
                  "endLine": 123,
                  "endColumn": 13,
                  "snippet": {
                    "text": "    \"\"\"Visit a project by traversing the locals dictionary.\n\n    * visit_<class name> on entering a node, where class name is the class of\n    the node in lower case\n\n    * leave_<class name> on leaving a node, where class name is the class of\n    the node in lower case\n",
                    "rendered": {
                      "text": "    \"\"\"Visit a project by traversing the locals dictionary.\n\n    * visit_<class name> on entering a node, where class name is the class of\n    the node in lower case\n\n    * leave_<class name> on leaving a node, where class name is the class of\n    the node in lower case\n",
                      "markdown": "`    \"\"\"Visit a project by traversing the locals dictionary.\n\n    * visit_<class name> on entering a node, where class name is the class of\n    the node in lower case\n\n    * leave_<class name> on leaving a node, where class name is the class of\n    the node in lower case\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/utils.py"
                },
                "region": {
                  "startLine": 114,
                  "startColumn": 29,
                  "endLine": 114,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        self.__mode = __mode\n\n    def show_attr(self, node: nodes.NodeNG | str) -> bool:\n        \"\"\"Return true if the node should be treated.\"\"\"\n        visibility = get_visibility(getattr(node, \"name\", node))\n        return not self.__mode & VIS_MOD[visibility]\n\n",
                    "rendered": {
                      "text": "        self.__mode = __mode\n\n    def show_attr(self, node: nodes.NodeNG | str) -> bool:\n        \"\"\"Return true if the node should be treated.\"\"\"\n        visibility = get_visibility(getattr(node, \"name\", node))\n        return not self.__mode & VIS_MOD[visibility]\n\n",
                      "markdown": "`        self.__mode = __mode\n\n    def show_attr(self, node: nodes.NodeNG | str) -> bool:\n        \"\"\"Return true if the node should be treated.\"\"\"\n        visibility = get_visibility(getattr(node, \"name\", node))\n        return not self.__mode & VIS_MOD[visibility]\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/printer_factory.py"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 30,
                  "endLine": 22,
                  "endColumn": 35,
                  "snippet": {
                    "text": "\n\ndef get_printer_for_filetype(filetype: str) -> type[Printer]:\n    return filetype_to_printer.get(filetype, DotPrinter)\n",
                    "rendered": {
                      "text": "\n\ndef get_printer_for_filetype(filetype: str) -> type[Printer]:\n    return filetype_to_printer.get(filetype, DotPrinter)\n",
                      "markdown": "`\n\ndef get_printer_for_filetype(filetype: str) -> type[Printer]:\n    return filetype_to_printer.get(filetype, DotPrinter)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/printer.py"
                },
                "region": {
                  "startLine": 114,
                  "startColumn": 29,
                  "endLine": 114,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        annotations = dict(zip(arguments, method.args.annotations[first_arg:]))\n        for arg in arguments:\n            annotation_label = \"\"\n            ann = annotations.get(arg)\n            if ann:\n                annotation_label = get_annotation_label(ann)\n            annotations[arg] = annotation_label\n",
                    "rendered": {
                      "text": "        annotations = dict(zip(arguments, method.args.annotations[first_arg:]))\n        for arg in arguments:\n            annotation_label = \"\"\n            ann = annotations.get(arg)\n            if ann:\n                annotation_label = get_annotation_label(ann)\n            annotations[arg] = annotation_label\n",
                      "markdown": "`        annotations = dict(zip(arguments, method.args.annotations[first_arg:]))\n        for arg in arguments:\n            annotation_label = \"\"\n            ann = annotations.get(arg)\n            if ann:\n                annotation_label = get_annotation_label(ann)\n            annotations[arg] = annotation_label\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/pyreverse/printer.py"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 34,
                  "endLine": 101,
                  "endColumn": 40,
                  "snippet": {
                    "text": "        type_: EdgeType,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Create an edge from one node to another to display relationships.\"\"\"\n\n    @staticmethod\n    def _get_method_arguments(method: nodes.FunctionDef) -> list[str]:\n",
                    "rendered": {
                      "text": "        type_: EdgeType,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Create an edge from one node to another to display relationships.\"\"\"\n\n    @staticmethod\n    def _get_method_arguments(method: nodes.FunctionDef) -> list[str]:\n",
                      "markdown": "`        type_: EdgeType,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Create an edge from one node to another to display relationships.\"\"\"\n\n    @staticmethod\n    def _get_method_arguments(method: nodes.FunctionDef) -> list[str]:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/modified_iterating_checker.py"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 17,
                  "endLine": 65,
                  "endColumn": 23,
                  "snippet": {
                    "text": "    def _modified_iterating_check_on_node_and_children(\n        self, body_node: nodes.NodeNG, iter_obj: nodes.NodeNG\n    ) -> None:\n        \"\"\"See if node or any of its children raises modified iterating messages.\"\"\"\n        self._modified_iterating_check(body_node, iter_obj)\n        for child in body_node.get_children():\n            self._modified_iterating_check_on_node_and_children(child, iter_obj)\n",
                    "rendered": {
                      "text": "    def _modified_iterating_check_on_node_and_children(\n        self, body_node: nodes.NodeNG, iter_obj: nodes.NodeNG\n    ) -> None:\n        \"\"\"See if node or any of its children raises modified iterating messages.\"\"\"\n        self._modified_iterating_check(body_node, iter_obj)\n        for child in body_node.get_children():\n            self._modified_iterating_check_on_node_and_children(child, iter_obj)\n",
                      "markdown": "`    def _modified_iterating_check_on_node_and_children(\n        self, body_node: nodes.NodeNG, iter_obj: nodes.NodeNG\n    ) -> None:\n        \"\"\"See if node or any of its children raises modified iterating messages.\"\"\"\n        self._modified_iterating_check(body_node, iter_obj)\n        for child in body_node.get_children():\n            self._modified_iterating_check_on_node_and_children(child, iter_obj)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/misc.py"
                },
                "region": {
                  "startLine": 132,
                  "startColumn": 32,
                  "endLine": 132,
                  "endColumn": 38,
                  "snippet": {
                    "text": "                self._check_encoding(lineno + 1, line, encoding)\n\n    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -> None:\n        \"\"\"Inspect the source to find fixme problems.\"\"\"\n        if not self.linter.config.notes:\n            return\n        for token_info in tokens:\n",
                    "rendered": {
                      "text": "                self._check_encoding(lineno + 1, line, encoding)\n\n    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -> None:\n        \"\"\"Inspect the source to find fixme problems.\"\"\"\n        if not self.linter.config.notes:\n            return\n        for token_info in tokens:\n",
                      "markdown": "`                self._check_encoding(lineno + 1, line, encoding)\n\n    def process_tokens(self, tokens: list[tokenize.TokenInfo]) -> None:\n        \"\"\"Inspect the source to find fixme problems.\"\"\"\n        if not self.linter.config.notes:\n            return\n        for token_info in tokens:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/misc.py"
                },
                "region": {
                  "startLine": 124,
                  "startColumn": 37,
                  "endLine": 124,
                  "endColumn": 43,
                  "snippet": {
                    "text": "        return None\n\n    def process_module(self, node: nodes.Module) -> None:\n        \"\"\"Inspect the source file to find encoding problem.\"\"\"\n        encoding = node.file_encoding if node.file_encoding else \"ascii\"\n\n        with node.stream() as stream:\n",
                    "rendered": {
                      "text": "        return None\n\n    def process_module(self, node: nodes.Module) -> None:\n        \"\"\"Inspect the source file to find encoding problem.\"\"\"\n        encoding = node.file_encoding if node.file_encoding else \"ascii\"\n\n        with node.stream() as stream:\n",
                      "markdown": "`        return None\n\n    def process_module(self, node: nodes.Module) -> None:\n        \"\"\"Inspect the source file to find encoding problem.\"\"\"\n        encoding = node.file_encoding if node.file_encoding else \"ascii\"\n\n        with node.stream() as stream:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/misc.py"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 37,
                  "endLine": 43,
                  "endColumn": 43,
                  "snippet": {
                    "text": "        return self.linter._by_id_managed_msgs\n\n    def process_module(self, node: nodes.Module) -> None:\n        \"\"\"Inspect the source file to find messages activated or deactivated by id.\"\"\"\n        managed_msgs = self._get_by_id_managed_msgs()\n        for mod_name, msgid, symbol, lineno, is_disabled in managed_msgs:\n            if mod_name == node.name:\n",
                    "rendered": {
                      "text": "        return self.linter._by_id_managed_msgs\n\n    def process_module(self, node: nodes.Module) -> None:\n        \"\"\"Inspect the source file to find messages activated or deactivated by id.\"\"\"\n        managed_msgs = self._get_by_id_managed_msgs()\n        for mod_name, msgid, symbol, lineno, is_disabled in managed_msgs:\n            if mod_name == node.name:\n",
                      "markdown": "`        return self.linter._by_id_managed_msgs\n\n    def process_module(self, node: nodes.Module) -> None:\n        \"\"\"Inspect the source file to find messages activated or deactivated by id.\"\"\"\n        managed_msgs = self._get_by_id_managed_msgs()\n        for mod_name, msgid, symbol, lineno, is_disabled in managed_msgs:\n            if mod_name == node.name:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/method_args.py"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 29,
                  "endLine": 79,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        \"\"\"Check if the call needs a timeout parameter based on package.func_name\n        configured in config.timeout_methods.\n\n        Package uses inferred node in order to know the package imported.\n        \"\"\"\n        inferred = utils.safe_infer(node.func)\n        call_site = arguments.CallSite.from_call(node)\n",
                    "rendered": {
                      "text": "        \"\"\"Check if the call needs a timeout parameter based on package.func_name\n        configured in config.timeout_methods.\n\n        Package uses inferred node in order to know the package imported.\n        \"\"\"\n        inferred = utils.safe_infer(node.func)\n        call_site = arguments.CallSite.from_call(node)\n",
                      "markdown": "`        \"\"\"Check if the call needs a timeout parameter based on package.func_name\n        configured in config.timeout_methods.\n\n        Package uses inferred node in order to know the package imported.\n        \"\"\"\n        inferred = utils.safe_infer(node.func)\n        call_site = arguments.CallSite.from_call(node)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/method_args.py"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 36,
                  "endLine": 76,
                  "endColumn": 45,
                  "snippet": {
                    "text": "        self._check_positional_only_arguments_expected(node)\n\n    def _check_missing_timeout(self, node: nodes.Call) -> None:\n        \"\"\"Check if the call needs a timeout parameter based on package.func_name\n        configured in config.timeout_methods.\n\n        Package uses inferred node in order to know the package imported.\n",
                    "rendered": {
                      "text": "        self._check_positional_only_arguments_expected(node)\n\n    def _check_missing_timeout(self, node: nodes.Call) -> None:\n        \"\"\"Check if the call needs a timeout parameter based on package.func_name\n        configured in config.timeout_methods.\n\n        Package uses inferred node in order to know the package imported.\n",
                      "markdown": "`        self._check_positional_only_arguments_expected(node)\n\n    def _check_missing_timeout(self, node: nodes.Call) -> None:\n        \"\"\"Check if the call needs a timeout parameter based on package.func_name\n        configured in config.timeout_methods.\n\n        Package uses inferred node in order to know the package imported.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/method_args.py"
                },
                "region": {
                  "startLine": 62,
                  "startColumn": 87,
                  "endLine": 62,
                  "endColumn": 96,
                  "snippet": {
                    "text": "                ),\n                \"type\": \"csv\",\n                \"metavar\": \"<comma separated list>\",\n                \"help\": \"List of qualified names (i.e., library.method) which require a timeout parameter \"\n                \"e.g. 'requests.api.get,requests.api.post'\",\n            },\n        ),\n",
                    "rendered": {
                      "text": "                ),\n                \"type\": \"csv\",\n                \"metavar\": \"<comma separated list>\",\n                \"help\": \"List of qualified names (i.e., library.method) which require a timeout parameter \"\n                \"e.g. 'requests.api.get,requests.api.post'\",\n            },\n        ),\n",
                      "markdown": "`                ),\n                \"type\": \"csv\",\n                \"metavar\": \"<comma separated list>\",\n                \"help\": \"List of qualified names (i.e., library.method) which require a timeout parameter \"\n                \"e.g. 'requests.api.get,requests.api.post'\",\n            },\n        ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/method_args.py"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 71,
                  "endLine": 36,
                  "endColumn": 77,
                  "snippet": {
                    "text": "            \"missing-timeout\",\n            \"Used when a method needs a 'timeout' parameter in order to avoid waiting \"\n            \"for a long time. If no timeout is specified explicitly the default value \"\n            \"is used. For example for 'requests' the program will never time out \"\n            \"(i.e. hang indefinitely).\",\n        ),\n        \"E3102\": (\n",
                    "rendered": {
                      "text": "            \"missing-timeout\",\n            \"Used when a method needs a 'timeout' parameter in order to avoid waiting \"\n            \"for a long time. If no timeout is specified explicitly the default value \"\n            \"is used. For example for 'requests' the program will never time out \"\n            \"(i.e. hang indefinitely).\",\n        ),\n        \"E3102\": (\n",
                      "markdown": "`            \"missing-timeout\",\n            \"Used when a method needs a 'timeout' parameter in order to avoid waiting \"\n            \"for a long time. If no timeout is specified explicitly the default value \"\n            \"is used. For example for 'requests' the program will never time out \"\n            \"(i.e. hang indefinitely).\",\n        ),\n        \"E3102\": (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/method_args.py"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 35,
                  "endLine": 35,
                  "endColumn": 44,
                  "snippet": {
                    "text": "            \"Missing timeout argument for method '%s' can cause your program to hang indefinitely\",\n            \"missing-timeout\",\n            \"Used when a method needs a 'timeout' parameter in order to avoid waiting \"\n            \"for a long time. If no timeout is specified explicitly the default value \"\n            \"is used. For example for 'requests' the program will never time out \"\n            \"(i.e. hang indefinitely).\",\n        ),\n",
                    "rendered": {
                      "text": "            \"Missing timeout argument for method '%s' can cause your program to hang indefinitely\",\n            \"missing-timeout\",\n            \"Used when a method needs a 'timeout' parameter in order to avoid waiting \"\n            \"for a long time. If no timeout is specified explicitly the default value \"\n            \"is used. For example for 'requests' the program will never time out \"\n            \"(i.e. hang indefinitely).\",\n        ),\n",
                      "markdown": "`            \"Missing timeout argument for method '%s' can cause your program to hang indefinitely\",\n            \"missing-timeout\",\n            \"Used when a method needs a 'timeout' parameter in order to avoid waiting \"\n            \"for a long time. If no timeout is specified explicitly the default value \"\n            \"is used. For example for 'requests' the program will never time out \"\n            \"(i.e. hang indefinitely).\",\n        ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/method_args.py"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 20,
                  "endLine": 32,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    name = \"method_args\"\n    msgs = {\n        \"W3101\": (\n            \"Missing timeout argument for method '%s' can cause your program to hang indefinitely\",\n            \"missing-timeout\",\n            \"Used when a method needs a 'timeout' parameter in order to avoid waiting \"\n            \"for a long time. If no timeout is specified explicitly the default value \"\n",
                    "rendered": {
                      "text": "    name = \"method_args\"\n    msgs = {\n        \"W3101\": (\n            \"Missing timeout argument for method '%s' can cause your program to hang indefinitely\",\n            \"missing-timeout\",\n            \"Used when a method needs a 'timeout' parameter in order to avoid waiting \"\n            \"for a long time. If no timeout is specified explicitly the default value \"\n",
                      "markdown": "`    name = \"method_args\"\n    msgs = {\n        \"W3101\": (\n            \"Missing timeout argument for method '%s' can cause your program to hang indefinitely\",\n            \"missing-timeout\",\n            \"Used when a method needs a 'timeout' parameter in order to avoid waiting \"\n            \"for a long time. If no timeout is specified explicitly the default value \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/logging.py"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 60,
                  "endLine": 67,
                  "endColumn": 64,
                  "snippet": {
                    "text": "            \"you can use % formatting as normal.\",\n        ),\n        \"E1200\": (\n            \"Unsupported logging format character %r (%#02x) at index %d\",\n            \"logging-unsupported-format\",\n            \"Used when an unsupported format character is used in a logging \"\n            \"statement format string.\",\n",
                    "rendered": {
                      "text": "            \"you can use % formatting as normal.\",\n        ),\n        \"E1200\": (\n            \"Unsupported logging format character %r (%#02x) at index %d\",\n            \"logging-unsupported-format\",\n            \"Used when an unsupported format character is used in a logging \"\n            \"statement format string.\",\n",
                      "markdown": "`            \"you can use % formatting as normal.\",\n        ),\n        \"E1200\": (\n            \"Unsupported logging format character %r (%#02x) at index %d\",\n            \"logging-unsupported-format\",\n            \"Used when an unsupported format character is used in a logging \"\n            \"statement format string.\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/logging.py"
                },
                "region": {
                  "startLine": 410,
                  "startColumn": 28,
                  "endLine": 410,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\n\ndef str_formatting_in_f_string(node: nodes.JoinedStr) -> bool:\n    \"\"\"Determine whether the node represents an f-string with string formatting.\n\n    For example: `f'Hello %s'`\n    \"\"\"\n",
                    "rendered": {
                      "text": "\n\ndef str_formatting_in_f_string(node: nodes.JoinedStr) -> bool:\n    \"\"\"Determine whether the node represents an f-string with string formatting.\n\n    For example: `f'Hello %s'`\n    \"\"\"\n",
                      "markdown": "`\n\ndef str_formatting_in_f_string(node: nodes.JoinedStr) -> bool:\n    \"\"\"Determine whether the node represents an f-string with string formatting.\n\n    For example: `f'Hello %s'`\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/logging.py"
                },
                "region": {
                  "startLine": 379,
                  "startColumn": 25,
                  "endLine": 379,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n\ndef is_complex_format_str(node: nodes.NodeNG) -> bool:\n    \"\"\"Return whether the node represents a string with complex formatting specs.\"\"\"\n    inferred = utils.safe_infer(node)\n    if inferred is None or not (\n        isinstance(inferred, nodes.Const) and isinstance(inferred.value, str)\n",
                    "rendered": {
                      "text": "\n\ndef is_complex_format_str(node: nodes.NodeNG) -> bool:\n    \"\"\"Return whether the node represents a string with complex formatting specs.\"\"\"\n    inferred = utils.safe_infer(node)\n    if inferred is None or not (\n        isinstance(inferred, nodes.Const) and isinstance(inferred.value, str)\n",
                      "markdown": "`\n\ndef is_complex_format_str(node: nodes.NodeNG) -> bool:\n    \"\"\"Return whether the node represents a string with complex formatting specs.\"\"\"\n    inferred = utils.safe_infer(node)\n    if inferred is None or not (\n        isinstance(inferred, nodes.Const) and isinstance(inferred.value, str)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/logging.py"
                },
                "region": {
                  "startLine": 326,
                  "startColumn": 55,
                  "endLine": 326,
                  "endColumn": 61,
                  "snippet": {
                    "text": "\n        Args:\n          node: AST node to be checked.\n          format_arg: Index of the format string in the node arguments.\n        \"\"\"\n        num_args = _count_supplied_tokens(node.args[format_arg + 1 :])\n        if not num_args:\n",
                    "rendered": {
                      "text": "\n        Args:\n          node: AST node to be checked.\n          format_arg: Index of the format string in the node arguments.\n        \"\"\"\n        num_args = _count_supplied_tokens(node.args[format_arg + 1 :])\n        if not num_args:\n",
                      "markdown": "`\n        Args:\n          node: AST node to be checked.\n          format_arg: Index of the format string in the node arguments.\n        \"\"\"\n        num_args = _count_supplied_tokens(node.args[format_arg + 1 :])\n        if not num_args:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/logging.py"
                },
                "region": {
                  "startLine": 325,
                  "startColumn": 19,
                  "endLine": 325,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        \"\"\"Checks that format string tokens match the supplied arguments.\n\n        Args:\n          node: AST node to be checked.\n          format_arg: Index of the format string in the node arguments.\n        \"\"\"\n        num_args = _count_supplied_tokens(node.args[format_arg + 1 :])\n",
                    "rendered": {
                      "text": "        \"\"\"Checks that format string tokens match the supplied arguments.\n\n        Args:\n          node: AST node to be checked.\n          format_arg: Index of the format string in the node arguments.\n        \"\"\"\n        num_args = _count_supplied_tokens(node.args[format_arg + 1 :])\n",
                      "markdown": "`        \"\"\"Checks that format string tokens match the supplied arguments.\n\n        Args:\n          node: AST node to be checked.\n          format_arg: Index of the format string in the node arguments.\n        \"\"\"\n        num_args = _count_supplied_tokens(node.args[format_arg + 1 :])\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/logging.py"
                },
                "region": {
                  "startLine": 294,
                  "startColumn": 29,
                  "endLine": 294,
                  "endColumn": 35,
                  "snippet": {
                    "text": "\n    @staticmethod\n    def _is_node_explicit_str_concatenation(node: nodes.NodeNG) -> bool:\n        \"\"\"Return True if the node represents an explicitly concatenated string.\"\"\"\n        if not isinstance(node, nodes.BinOp):\n            return False\n        return (\n",
                    "rendered": {
                      "text": "\n    @staticmethod\n    def _is_node_explicit_str_concatenation(node: nodes.NodeNG) -> bool:\n        \"\"\"Return True if the node represents an explicitly concatenated string.\"\"\"\n        if not isinstance(node, nodes.BinOp):\n            return False\n        return (\n",
                      "markdown": "`\n    @staticmethod\n    def _is_node_explicit_str_concatenation(node: nodes.NodeNG) -> bool:\n        \"\"\"Return True if the node represents an explicitly concatenated string.\"\"\"\n        if not isinstance(node, nodes.BinOp):\n            return False\n        return (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/logging.py"
                },
                "region": {
                  "startLine": 117,
                  "startColumn": 17,
                  "endLine": 117,
                  "endColumn": 23,
                  "snippet": {
                    "text": "      methods: Optional sequence of method names to restrict check.\n\n    Returns:\n      true if the node represents a method call for the given type and\n      method names, False otherwise.\n    \"\"\"\n    return (\n",
                    "rendered": {
                      "text": "      methods: Optional sequence of method names to restrict check.\n\n    Returns:\n      true if the node represents a method call for the given type and\n      method names, False otherwise.\n    \"\"\"\n    return (\n",
                      "markdown": "`      methods: Optional sequence of method names to restrict check.\n\n    Returns:\n      true if the node represents a method call for the given type and\n      method names, False otherwise.\n    \"\"\"\n    return (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/logging.py"
                },
                "region": {
                  "startLine": 112,
                  "startColumn": 31,
                  "endLine": 112,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    \"\"\"Determines if a BoundMethod node represents a method call.\n\n    Args:\n      func: The BoundMethod AST node to check.\n      types: Optional sequence of caller type names to restrict check.\n      methods: Optional sequence of method names to restrict check.\n\n",
                    "rendered": {
                      "text": "    \"\"\"Determines if a BoundMethod node represents a method call.\n\n    Args:\n      func: The BoundMethod AST node to check.\n      types: Optional sequence of caller type names to restrict check.\n      methods: Optional sequence of method names to restrict check.\n\n",
                      "markdown": "`    \"\"\"Determines if a BoundMethod node represents a method call.\n\n    Args:\n      func: The BoundMethod AST node to check.\n      types: Optional sequence of caller type names to restrict check.\n      methods: Optional sequence of method names to restrict check.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/logging.py"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 34,
                  "endLine": 109,
                  "endColumn": 40,
                  "snippet": {
                    "text": "def is_method_call(\n    func: bases.BoundMethod, types: tuple[str, ...] = (), methods: tuple[str, ...] = ()\n) -> bool:\n    \"\"\"Determines if a BoundMethod node represents a method call.\n\n    Args:\n      func: The BoundMethod AST node to check.\n",
                    "rendered": {
                      "text": "def is_method_call(\n    func: bases.BoundMethod, types: tuple[str, ...] = (), methods: tuple[str, ...] = ()\n) -> bool:\n    \"\"\"Determines if a BoundMethod node represents a method call.\n\n    Args:\n      func: The BoundMethod AST node to check.\n",
                      "markdown": "`def is_method_call(\n    func: bases.BoundMethod, types: tuple[str, ...] = (), methods: tuple[str, ...] = ()\n) -> bool:\n    \"\"\"Determines if a BoundMethod node represents a method call.\n\n    Args:\n      func: The BoundMethod AST node to check.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/async.py"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 31,
                  "endLine": 49,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    @checker_utils.only_required_for_messages(\"yield-inside-async-function\")\n    def visit_asyncfunctiondef(self, node: nodes.AsyncFunctionDef) -> None:\n        for child in node.nodes_of_class(nodes.Yield):\n            if child.scope() is node and (\n                sys.version_info[:2] == (3, 5) or isinstance(child, nodes.YieldFrom)\n            ):\n                self.add_message(\"yield-inside-async-function\", node=child)\n",
                    "rendered": {
                      "text": "    @checker_utils.only_required_for_messages(\"yield-inside-async-function\")\n    def visit_asyncfunctiondef(self, node: nodes.AsyncFunctionDef) -> None:\n        for child in node.nodes_of_class(nodes.Yield):\n            if child.scope() is node and (\n                sys.version_info[:2] == (3, 5) or isinstance(child, nodes.YieldFrom)\n            ):\n                self.add_message(\"yield-inside-async-function\", node=child)\n",
                      "markdown": "`    @checker_utils.only_required_for_messages(\"yield-inside-async-function\")\n    def visit_asyncfunctiondef(self, node: nodes.AsyncFunctionDef) -> None:\n        for child in node.nodes_of_class(nodes.Yield):\n            if child.scope() is node and (\n                sys.version_info[:2] == (3, 5) or isinstance(child, nodes.YieldFrom)\n            ):\n                self.add_message(\"yield-inside-async-function\", node=child)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/docstyle.py"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 44,
                  "endLine": 34,
                  "endColumn": 48,
                  "snippet": {
                    "text": "        \"C0199\": (\n            \"First line empty in %s docstring\",\n            \"docstring-first-line-empty\",\n            \"Used when a blank line is found at the beginning of a docstring.\",\n        ),\n    }\n\n",
                    "rendered": {
                      "text": "        \"C0199\": (\n            \"First line empty in %s docstring\",\n            \"docstring-first-line-empty\",\n            \"Used when a blank line is found at the beginning of a docstring.\",\n        ),\n    }\n\n",
                      "markdown": "`        \"C0199\": (\n            \"First line empty in %s docstring\",\n            \"docstring-first-line-empty\",\n            \"Used when a blank line is found at the beginning of a docstring.\",\n        ),\n    }\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/docparams.py"
                },
                "region": {
                  "startLine": 576,
                  "startColumn": 28,
                  "endLine": 576,
                  "endColumn": 36,
                  "snippet": {
                    "text": "        if not params_with_doc and not params_with_type and accept_no_param_doc:\n            tolerate_missing_params = True\n\n        # This is before the update of params_with_type because this must check only\n        # the type documented in a docstring, not the one using pep484\n        # See #4117 and #4593\n        self._compare_ignored_args(\n",
                    "rendered": {
                      "text": "        if not params_with_doc and not params_with_type and accept_no_param_doc:\n            tolerate_missing_params = True\n\n        # This is before the update of params_with_type because this must check only\n        # the type documented in a docstring, not the one using pep484\n        # See #4117 and #4593\n        self._compare_ignored_args(\n",
                      "markdown": "`        if not params_with_doc and not params_with_type and accept_no_param_doc:\n            tolerate_missing_params = True\n\n        # This is before the update of params_with_type because this must check only\n        # the type documented in a docstring, not the one using pep484\n        # See #4117 and #4593\n        self._compare_ignored_args(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/docparams.py"
                },
                "region": {
                  "startLine": 572,
                  "startColumn": 45,
                  "endLine": 572,
                  "endColumn": 49,
                  "snippet": {
                    "text": "            expected_argument_names.add(f\"**{arguments_node.kwarg}\")\n            not_needed_type_in_docstring.add(f\"**{arguments_node.kwarg}\")\n        params_with_doc, params_with_type = doc.match_param_docs()\n        # Tolerate no parameter documentation at all.\n        if not params_with_doc and not params_with_type and accept_no_param_doc:\n            tolerate_missing_params = True\n\n",
                    "rendered": {
                      "text": "            expected_argument_names.add(f\"**{arguments_node.kwarg}\")\n            not_needed_type_in_docstring.add(f\"**{arguments_node.kwarg}\")\n        params_with_doc, params_with_type = doc.match_param_docs()\n        # Tolerate no parameter documentation at all.\n        if not params_with_doc and not params_with_type and accept_no_param_doc:\n            tolerate_missing_params = True\n\n",
                      "markdown": "`            expected_argument_names.add(f\"**{arguments_node.kwarg}\")\n            not_needed_type_in_docstring.add(f\"**{arguments_node.kwarg}\")\n        params_with_doc, params_with_type = doc.match_param_docs()\n        # Tolerate no parameter documentation at all.\n        if not params_with_doc and not params_with_type and accept_no_param_doc:\n            tolerate_missing_params = True\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/docparams.py"
                },
                "region": {
                  "startLine": 522,
                  "startColumn": 23,
                  "endLine": 522,
                  "endColumn": 27,
                  "snippet": {
                    "text": "          see\" (ignoring additional white-space) is mentioned in the docstring,\n          missing parameter documentation is tolerated.\n        * If there's no Sphinx style, Google style or NumPy style parameter\n          documentation at all, i.e. ``:param`` is never mentioned etc., the\n          checker assumes that the parameters are documented in another format\n          and the absence is tolerated.\n\n",
                    "rendered": {
                      "text": "          see\" (ignoring additional white-space) is mentioned in the docstring,\n          missing parameter documentation is tolerated.\n        * If there's no Sphinx style, Google style or NumPy style parameter\n          documentation at all, i.e. ``:param`` is never mentioned etc., the\n          checker assumes that the parameters are documented in another format\n          and the absence is tolerated.\n\n",
                      "markdown": "`          see\" (ignoring additional white-space) is mentioned in the docstring,\n          missing parameter documentation is tolerated.\n        * If there's no Sphinx style, Google style or NumPy style parameter\n          documentation at all, i.e. ``:param`` is never mentioned etc., the\n          checker assumes that the parameters are documented in another format\n          and the absence is tolerated.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/docparams.py"
                },
                "region": {
                  "startLine": 659,
                  "startColumn": 24,
                  "endLine": 659,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        \"\"\"Adds a message on :param:`node` for the missing exception type.\n\n        :param missing_exceptions: A list of missing exception types.\n        :param node: The node to show the message on.\n        \"\"\"\n        if node.is_abstract():\n            try:\n",
                    "rendered": {
                      "text": "        \"\"\"Adds a message on :param:`node` for the missing exception type.\n\n        :param missing_exceptions: A list of missing exception types.\n        :param node: The node to show the message on.\n        \"\"\"\n        if node.is_abstract():\n            try:\n",
                      "markdown": "`        \"\"\"Adds a message on :param:`node` for the missing exception type.\n\n        :param missing_exceptions: A list of missing exception types.\n        :param node: The node to show the message on.\n        \"\"\"\n        if node.is_abstract():\n            try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/docparams.py"
                },
                "region": {
                  "startLine": 533,
                  "startColumn": 32,
                  "endLine": 533,
                  "endColumn": 38,
                  "snippet": {
                    "text": "            class constructor.\n        :type arguments_node: :class:`astroid.scoped_nodes.Arguments`\n\n        :param warning_node: The node to assign the warnings to\n        :type warning_node: :class:`astroid.scoped_nodes.Node`\n\n        :param accept_no_param_doc: Whether to allow no parameters to be\n",
                    "rendered": {
                      "text": "            class constructor.\n        :type arguments_node: :class:`astroid.scoped_nodes.Arguments`\n\n        :param warning_node: The node to assign the warnings to\n        :type warning_node: :class:`astroid.scoped_nodes.Node`\n\n        :param accept_no_param_doc: Whether to allow no parameters to be\n",
                      "markdown": "`            class constructor.\n        :type arguments_node: :class:`astroid.scoped_nodes.Arguments`\n\n        :param warning_node: The node to assign the warnings to\n        :type warning_node: :class:`astroid.scoped_nodes.Node`\n\n        :param accept_no_param_doc: Whether to allow no parameters to be\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/docparams.py"
                },
                "region": {
                  "startLine": 529,
                  "startColumn": 40,
                  "endLine": 529,
                  "endColumn": 46,
                  "snippet": {
                    "text": "        :param doc: Docstring for the function, method or class.\n        :type doc: :class:`Docstring`\n\n        :param arguments_node: Arguments node for the function, method or\n            class constructor.\n        :type arguments_node: :class:`astroid.scoped_nodes.Arguments`\n\n",
                    "rendered": {
                      "text": "        :param doc: Docstring for the function, method or class.\n        :type doc: :class:`Docstring`\n\n        :param arguments_node: Arguments node for the function, method or\n            class constructor.\n        :type arguments_node: :class:`astroid.scoped_nodes.Arguments`\n\n",
                      "markdown": "`        :param doc: Docstring for the function, method or class.\n        :type doc: :class:`Docstring`\n\n        :param arguments_node: Arguments node for the function, method or\n            class constructor.\n        :type arguments_node: :class:`astroid.scoped_nodes.Arguments`\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/docparams.py"
                },
                "region": {
                  "startLine": 491,
                  "startColumn": 32,
                  "endLine": 491,
                  "endColumn": 38,
                  "snippet": {
                    "text": "        :param found_argument_names: argument names found in the docstring\n        :param message_id: pylint message id\n        :param ignored_argument_names: Expected argument names\n        :param warning_node: The node to be analyzed\n        \"\"\"\n        existing_ignored_argument_names = ignored_argument_names & found_argument_names\n\n",
                    "rendered": {
                      "text": "        :param found_argument_names: argument names found in the docstring\n        :param message_id: pylint message id\n        :param ignored_argument_names: Expected argument names\n        :param warning_node: The node to be analyzed\n        \"\"\"\n        existing_ignored_argument_names = ignored_argument_names & found_argument_names\n\n",
                      "markdown": "`        :param found_argument_names: argument names found in the docstring\n        :param message_id: pylint message id\n        :param ignored_argument_names: Expected argument names\n        :param warning_node: The node to be analyzed\n        \"\"\"\n        existing_ignored_argument_names = ignored_argument_names & found_argument_names\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/docparams.py"
                },
                "region": {
                  "startLine": 454,
                  "startColumn": 32,
                  "endLine": 454,
                  "endColumn": 38,
                  "snippet": {
                    "text": "\n        :param expected_argument_names: Expected argument names\n\n        :param warning_node: The node to be analyzed\n        \"\"\"\n        # Handle variadic and keyword args without asterisks\n        modified_expected_argument_names: set[str] = set()\n",
                    "rendered": {
                      "text": "\n        :param expected_argument_names: Expected argument names\n\n        :param warning_node: The node to be analyzed\n        \"\"\"\n        # Handle variadic and keyword args without asterisks\n        modified_expected_argument_names: set[str] = set()\n",
                      "markdown": "`\n        :param expected_argument_names: Expected argument names\n\n        :param warning_node: The node to be analyzed\n        \"\"\"\n        # Handle variadic and keyword args without asterisks\n        modified_expected_argument_names: set[str] = set()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/docparams.py"
                },
                "region": {
                  "startLine": 414,
                  "startColumn": 32,
                  "endLine": 414,
                  "endColumn": 38,
                  "snippet": {
                    "text": "\n        :param expected_argument_names: Expected argument names\n\n        :param warning_node: The node to be analyzed\n        \"\"\"\n        potential_missing_argument_names = (\n            expected_argument_names - found_argument_names\n",
                    "rendered": {
                      "text": "\n        :param expected_argument_names: Expected argument names\n\n        :param warning_node: The node to be analyzed\n        \"\"\"\n        potential_missing_argument_names = (\n            expected_argument_names - found_argument_names\n",
                      "markdown": "`\n        :param expected_argument_names: Expected argument names\n\n        :param warning_node: The node to be analyzed\n        \"\"\"\n        potential_missing_argument_names = (\n            expected_argument_names - found_argument_names\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/docparams.py"
                },
                "region": {
                  "startLine": 196,
                  "startColumn": 20,
                  "endLine": 196,
                  "endColumn": 26,
                  "snippet": {
                    "text": "    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        \"\"\"Called for function and method definitions (def).\n\n        :param node: Node for a function or method definition in the AST\n        :type node: :class:`astroid.scoped_nodes.Function`\n        \"\"\"\n        if checker_utils.is_overload_stub(node):\n",
                    "rendered": {
                      "text": "    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        \"\"\"Called for function and method definitions (def).\n\n        :param node: Node for a function or method definition in the AST\n        :type node: :class:`astroid.scoped_nodes.Function`\n        \"\"\"\n        if checker_utils.is_overload_stub(node):\n",
                      "markdown": "`    def visit_functiondef(self, node: nodes.FunctionDef) -> None:\n        \"\"\"Called for function and method definitions (def).\n\n        :param node: Node for a function or method definition in the AST\n        :type node: :class:`astroid.scoped_nodes.Function`\n        \"\"\"\n        if checker_utils.is_overload_stub(node):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/docparams.py"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 44,
                  "endLine": 34,
                  "endColumn": 50,
                  "snippet": {
                    "text": "      but not both.\n    * Check that there are no naming inconsistencies between the signature and\n      the documentation, i.e. also report documented parameters that are missing\n      in the signature. This is important to find cases where parameters are\n      renamed only in the code, not in the documentation.\n    * Check that all explicitly raised exceptions in a function are documented\n      in the function docstring. Caught exceptions are ignored.\n",
                    "rendered": {
                      "text": "      but not both.\n    * Check that there are no naming inconsistencies between the signature and\n      the documentation, i.e. also report documented parameters that are missing\n      in the signature. This is important to find cases where parameters are\n      renamed only in the code, not in the documentation.\n    * Check that all explicitly raised exceptions in a function are documented\n      in the function docstring. Caught exceptions are ignored.\n",
                      "markdown": "`      but not both.\n    * Check that there are no naming inconsistencies between the signature and\n      the documentation, i.e. also report documented parameters that are missing\n      in the signature. This is important to find cases where parameters are\n      renamed only in the code, not in the documentation.\n    * Check that all explicitly raised exceptions in a function are documented\n      in the function docstring. Caught exceptions are ignored.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/extensions/dict_init_mutate.py"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 7,
                  "endLine": 36,
                  "endColumn": 11,
                  "snippet": {
                    "text": "        \"\"\"\n        Detect dictionary mutation immediately after initialization.\n\n        At this time, detecting nested mutation is not supported.\n        \"\"\"\n        if not isinstance(node.value, nodes.Dict):\n            return\n",
                    "rendered": {
                      "text": "        \"\"\"\n        Detect dictionary mutation immediately after initialization.\n\n        At this time, detecting nested mutation is not supported.\n        \"\"\"\n        if not isinstance(node.value, nodes.Dict):\n            return\n",
                      "markdown": "`        \"\"\"\n        Detect dictionary mutation immediately after initialization.\n\n        At this time, detecting nested mutation is not supported.\n        \"\"\"\n        if not isinstance(node.value, nodes.Dict):\n            return\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1190,
                  "startColumn": 32,
                  "endLine": 1190,
                  "endColumn": 37,
                  "snippet": {
                    "text": "\n    @staticmethod\n    def _has_exit_in_scope(scope: nodes.LocalsDictNodeNG) -> bool:\n        exit_func = scope.locals.get(\"exit\")\n        return bool(\n            exit_func and isinstance(exit_func[0], (nodes.ImportFrom, nodes.Import))\n        )\n",
                    "rendered": {
                      "text": "\n    @staticmethod\n    def _has_exit_in_scope(scope: nodes.LocalsDictNodeNG) -> bool:\n        exit_func = scope.locals.get(\"exit\")\n        return bool(\n            exit_func and isinstance(exit_func[0], (nodes.ImportFrom, nodes.Import))\n        )\n",
                      "markdown": "`\n    @staticmethod\n    def _has_exit_in_scope(scope: nodes.LocalsDictNodeNG) -> bool:\n        exit_func = scope.locals.get(\"exit\")\n        return bool(\n            exit_func and isinstance(exit_func[0], (nodes.ImportFrom, nodes.Import))\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 2352,
                  "startColumn": 29,
                  "endLine": 2352,
                  "endColumn": 38,
                  "snippet": {
                    "text": "\n        # Check if there are any if statements within the loop in question;\n        # If so, we will be more conservative about reporting errors as we\n        # can't yet do proper control flow analysis to be sure when\n        # reassignment will affect us\n        if_statements = itertools.chain.from_iterable(\n            child.nodes_of_class(nodes.If) for child in children\n",
                    "rendered": {
                      "text": "\n        # Check if there are any if statements within the loop in question;\n        # If so, we will be more conservative about reporting errors as we\n        # can't yet do proper control flow analysis to be sure when\n        # reassignment will affect us\n        if_statements = itertools.chain.from_iterable(\n            child.nodes_of_class(nodes.If) for child in children\n",
                      "markdown": "`\n        # Check if there are any if statements within the loop in question;\n        # If so, we will be more conservative about reporting errors as we\n        # can't yet do proper control flow analysis to be sure when\n        # reassignment will affect us\n        if_statements = itertools.chain.from_iterable(\n            child.nodes_of_class(nodes.If) for child in children\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 2343,
                  "startColumn": 29,
                  "endLine": 2343,
                  "endColumn": 38,
                  "snippet": {
                    "text": "\n        # Check if there are any for / while loops within the loop in question;\n        # If so, we will be more conservative about reporting errors as we\n        # can't yet do proper control flow analysis to be sure when\n        # reassignment will affect us\n        nested_loops = itertools.chain.from_iterable(\n            child.nodes_of_class((nodes.For, nodes.While)) for child in children\n",
                    "rendered": {
                      "text": "\n        # Check if there are any for / while loops within the loop in question;\n        # If so, we will be more conservative about reporting errors as we\n        # can't yet do proper control flow analysis to be sure when\n        # reassignment will affect us\n        nested_loops = itertools.chain.from_iterable(\n            child.nodes_of_class((nodes.For, nodes.While)) for child in children\n",
                      "markdown": "`\n        # Check if there are any for / while loops within the loop in question;\n        # If so, we will be more conservative about reporting errors as we\n        # can't yet do proper control flow analysis to be sure when\n        # reassignment will affect us\n        nested_loops = itertools.chain.from_iterable(\n            child.nodes_of_class((nodes.For, nodes.While)) for child in children\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 2173,
                  "startColumn": 33,
                  "endLine": 2173,
                  "endColumn": 42,
                  "snippet": {
                    "text": "\n            # Check if there are any for / while loops within the loop in question;\n            # If so, we will be more conservative about reporting errors as we\n            # can't yet do proper control flow analysis to be sure when\n            # reassignment will affect us\n            nested_loops = itertools.chain.from_iterable(\n                child.nodes_of_class((nodes.For, nodes.While)) for child in children\n",
                    "rendered": {
                      "text": "\n            # Check if there are any for / while loops within the loop in question;\n            # If so, we will be more conservative about reporting errors as we\n            # can't yet do proper control flow analysis to be sure when\n            # reassignment will affect us\n            nested_loops = itertools.chain.from_iterable(\n                child.nodes_of_class((nodes.For, nodes.While)) for child in children\n",
                      "markdown": "`\n            # Check if there are any for / while loops within the loop in question;\n            # If so, we will be more conservative about reporting errors as we\n            # can't yet do proper control flow analysis to be sure when\n            # reassignment will affect us\n            nested_loops = itertools.chain.from_iterable(\n                child.nodes_of_class((nodes.For, nodes.While)) for child in children\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 2115,
                  "startColumn": 67,
                  "endLine": 2115,
                  "endColumn": 71,
                  "snippet": {
                    "text": "\n        NOTE: produces a message only if there is a single return statement\n        in the function body. Otherwise _check_consistent_returns() is called!\n        Per its implementation and PEP8 we can have a \"return None\" at the end\n        of the function body if there are other return statements before that!\n        \"\"\"\n        if len(self._return_nodes[node.name]) != 1:\n",
                    "rendered": {
                      "text": "\n        NOTE: produces a message only if there is a single return statement\n        in the function body. Otherwise _check_consistent_returns() is called!\n        Per its implementation and PEP8 we can have a \"return None\" at the end\n        of the function body if there are other return statements before that!\n        \"\"\"\n        if len(self._return_nodes[node.name]) != 1:\n",
                      "markdown": "`\n        NOTE: produces a message only if there is a single return statement\n        in the function body. Otherwise _check_consistent_returns() is called!\n        Per its implementation and PEP8 we can have a \"return None\" at the end\n        of the function body if there are other return statements before that!\n        \"\"\"\n        if len(self._return_nodes[node.name]) != 1:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 2107,
                  "startColumn": 60,
                  "endLine": 2107,
                  "endColumn": 64,
                  "snippet": {
                    "text": "        )\n\n    def _check_return_at_the_end(self, node: nodes.FunctionDef) -> None:\n        \"\"\"Check for presence of a *single* return statement at the end of a\n        function.\n\n        \"return\" or \"return None\" are useless because None is the\n",
                    "rendered": {
                      "text": "        )\n\n    def _check_return_at_the_end(self, node: nodes.FunctionDef) -> None:\n        \"\"\"Check for presence of a *single* return statement at the end of a\n        function.\n\n        \"return\" or \"return None\" are useless because None is the\n",
                      "markdown": "`        )\n\n    def _check_return_at_the_end(self, node: nodes.FunctionDef) -> None:\n        \"\"\"Check for presence of a *single* return statement at the end of a\n        function.\n\n        \"return\" or \"return None\" are useless because None is the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 2069,
                  "startColumn": 35,
                  "endLine": 2069,
                  "endColumn": 39,
                  "snippet": {
                    "text": "\n    @staticmethod\n    def _has_return_in_siblings(node: nodes.NodeNG) -> bool:\n        \"\"\"Returns True if there is at least one return in the node's siblings.\"\"\"\n        next_sibling = node.next_sibling()\n        while next_sibling:\n            if isinstance(next_sibling, nodes.Return):\n",
                    "rendered": {
                      "text": "\n    @staticmethod\n    def _has_return_in_siblings(node: nodes.NodeNG) -> bool:\n        \"\"\"Returns True if there is at least one return in the node's siblings.\"\"\"\n        next_sibling = node.next_sibling()\n        while next_sibling:\n            if isinstance(next_sibling, nodes.Return):\n",
                      "markdown": "`\n    @staticmethod\n    def _has_return_in_siblings(node: nodes.NodeNG) -> bool:\n        \"\"\"Returns True if there is at least one return in the node's siblings.\"\"\"\n        next_sibling = node.next_sibling()\n        while next_sibling:\n            if isinstance(next_sibling, nodes.Return):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 2011,
                  "startColumn": 59,
                  "endLine": 2011,
                  "endColumn": 63,
                  "snippet": {
                    "text": "        handlers = utils.get_exception_handlers(node, exc_name)\n        handlers = list(handlers) if handlers is not None else []\n        if handlers:\n            # among all the handlers handling the exception at least one\n            # must end with a return statement\n            return any(self._is_node_return_ended(_handler) for _handler in handlers)\n        # if no handlers handle the exception then it's ok\n",
                    "rendered": {
                      "text": "        handlers = utils.get_exception_handlers(node, exc_name)\n        handlers = list(handlers) if handlers is not None else []\n        if handlers:\n            # among all the handlers handling the exception at least one\n            # must end with a return statement\n            return any(self._is_node_return_ended(_handler) for _handler in handlers)\n        # if no handlers handle the exception then it's ok\n",
                      "markdown": "`        handlers = utils.get_exception_handlers(node, exc_name)\n        handlers = list(handlers) if handlers is not None else []\n        if handlers:\n            # among all the handlers handling the exception at least one\n            # must end with a return statement\n            return any(self._is_node_return_ended(_handler) for _handler in handlers)\n        # if no handlers handle the exception then it's ok\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1967,
                  "startColumn": 24,
                  "endLine": 1967,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        )\n        if not node.orelse:\n            # If there is not orelse part then the if statement is returning if :\n            # - there is at least one return statement in its siblings;\n            # - the if body is itself returning.\n            if not self._has_return_in_siblings(node):\n                return False\n",
                    "rendered": {
                      "text": "        )\n        if not node.orelse:\n            # If there is not orelse part then the if statement is returning if :\n            # - there is at least one return statement in its siblings;\n            # - the if body is itself returning.\n            if not self._has_return_in_siblings(node):\n                return False\n",
                      "markdown": "`        )\n        if not node.orelse:\n            # If there is not orelse part then the if statement is returning if :\n            # - there is at least one return statement in its siblings;\n            # - the if body is itself returning.\n            if not self._has_return_in_siblings(node):\n                return False\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1667,
                  "startColumn": 69,
                  "endLine": 1667,
                  "endColumn": 73,
                  "snippet": {
                    "text": "            if varname in stack:\n                existing_node = stack[varname]\n                if astroid.are_exclusive(node, existing_node):\n                    # only one of the two assignments can be executed at runtime, thus it is fine\n                    stack[varname] = value\n                    continue\n                # variable was redefined before it was used in a ``with`` block\n",
                    "rendered": {
                      "text": "            if varname in stack:\n                existing_node = stack[varname]\n                if astroid.are_exclusive(node, existing_node):\n                    # only one of the two assignments can be executed at runtime, thus it is fine\n                    stack[varname] = value\n                    continue\n                # variable was redefined before it was used in a ``with`` block\n",
                      "markdown": "`            if varname in stack:\n                existing_node = stack[varname]\n                if astroid.are_exclusive(node, existing_node):\n                    # only one of the two assignments can be executed at runtime, thus it is fine\n                    stack[varname] = value\n                    continue\n                # variable was redefined before it was used in a ``with`` block\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1028,
                  "startColumn": 48,
                  "endLine": 1028,
                  "endColumn": 52,
                  "snippet": {
                    "text": "        self._nested_blocks = []\n        # check consistent return statements\n        self._check_consistent_returns(node)\n        # check for single return or return None at the end\n        self._check_return_at_the_end(node)\n        self._return_nodes[node.name] = []\n        # check for context managers that have been created but not used\n",
                    "rendered": {
                      "text": "        self._nested_blocks = []\n        # check consistent return statements\n        self._check_consistent_returns(node)\n        # check for single return or return None at the end\n        self._check_return_at_the_end(node)\n        self._return_nodes[node.name] = []\n        # check for context managers that have been created but not used\n",
                      "markdown": "`        self._nested_blocks = []\n        # check consistent return statements\n        self._check_consistent_returns(node)\n        # check for single return or return None at the end\n        self._check_return_at_the_end(node)\n        self._return_nodes[node.name] = []\n        # check for context managers that have been created but not used\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 692,
                  "startColumn": 87,
                  "endLine": 692,
                  "endColumn": 96,
                  "snippet": {
                    "text": "                or trailing_comma_tuple_enabled_once\n            ) and _is_trailing_comma(tokens, index):\n                # If \"trailing-comma-tuple\" is enabled globally we always check _is_trailing_comma\n                # it might be for nothing if there's a local disable, or if the message control is\n                # not enabling 'trailing-comma-tuple', but the alternative is having to check if\n                # it's enabled for a line each line (just to avoid calling '_is_trailing_comma').\n                self.add_message(\n",
                    "rendered": {
                      "text": "                or trailing_comma_tuple_enabled_once\n            ) and _is_trailing_comma(tokens, index):\n                # If \"trailing-comma-tuple\" is enabled globally we always check _is_trailing_comma\n                # it might be for nothing if there's a local disable, or if the message control is\n                # not enabling 'trailing-comma-tuple', but the alternative is having to check if\n                # it's enabled for a line each line (just to avoid calling '_is_trailing_comma').\n                self.add_message(\n",
                      "markdown": "`                or trailing_comma_tuple_enabled_once\n            ) and _is_trailing_comma(tokens, index):\n                # If \"trailing-comma-tuple\" is enabled globally we always check _is_trailing_comma\n                # it might be for nothing if there's a local disable, or if the message control is\n                # not enabling 'trailing-comma-tuple', but the alternative is having to check if\n                # it's enabled for a line each line (just to avoid calling '_is_trailing_comma').\n                self.add_message(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 677,
                  "startColumn": 56,
                  "endLine": 677,
                  "endColumn": 65,
                  "snippet": {
                    "text": "                # disabled on each line: Any enable for it during tokenization and\n                # we'll start using the costly '_is_trailing_comma' to check if we\n                # need to raise the message. We still won't raise if it's disabled\n                # again due to the usual generic message control handling later.\n                trailing_comma_tuple_enabled_once = True\n            if token_string == \"elif\":\n                # AST exists by the time process_tokens is called, so\n",
                    "rendered": {
                      "text": "                # disabled on each line: Any enable for it during tokenization and\n                # we'll start using the costly '_is_trailing_comma' to check if we\n                # need to raise the message. We still won't raise if it's disabled\n                # again due to the usual generic message control handling later.\n                trailing_comma_tuple_enabled_once = True\n            if token_string == \"elif\":\n                # AST exists by the time process_tokens is called, so\n",
                      "markdown": "`                # disabled on each line: Any enable for it during tokenization and\n                # we'll start using the costly '_is_trailing_comma' to check if we\n                # need to raise the message. We still won't raise if it's disabled\n                # again due to the usual generic message control handling later.\n                trailing_comma_tuple_enabled_once = True\n            if token_string == \"elif\":\n                # AST exists by the time process_tokens is called, so\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 667,
                  "startColumn": 87,
                  "endLine": 668,
                  "snippet": {
                    "text": "                and \"pylint:\" in token_string[1:]\n                # We have at least '#' 'pylint' ( + ':') (8 chars) at the start of the token\n                and \"enable\" in token_string[8:]\n                # We have at least '#', 'pylint', ( + ':'), 'enable' (+ '=') (15 chars) at\n                # the start of the token\n                and any(\n                    c in token_string[15:] for c in (\"trailing-comma-tuple\", \"R1707\")\n                )\n",
                    "rendered": {
                      "text": "                and \"pylint:\" in token_string[1:]\n                # We have at least '#' 'pylint' ( + ':') (8 chars) at the start of the token\n                and \"enable\" in token_string[8:]\n                # We have at least '#', 'pylint', ( + ':'), 'enable' (+ '=') (15 chars) at\n                # the start of the token\n                and any(\n                    c in token_string[15:] for c in (\"trailing-comma-tuple\", \"R1707\")\n                )\n",
                      "markdown": "`                and \"pylint:\" in token_string[1:]\n                # We have at least '#' 'pylint' ( + ':') (8 chars) at the start of the token\n                and \"enable\" in token_string[8:]\n                # We have at least '#', 'pylint', ( + ':'), 'enable' (+ '=') (15 chars) at\n                # the start of the token\n                and any(\n                    c in token_string[15:] for c in (\"trailing-comma-tuple\", \"R1707\")\n                )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 667,
                  "startColumn": 25,
                  "endLine": 667,
                  "endColumn": 29,
                  "snippet": {
                    "text": "                and \"pylint:\" in token_string[1:]\n                # We have at least '#' 'pylint' ( + ':') (8 chars) at the start of the token\n                and \"enable\" in token_string[8:]\n                # We have at least '#', 'pylint', ( + ':'), 'enable' (+ '=') (15 chars) at\n                # the start of the token\n                and any(\n                    c in token_string[15:] for c in (\"trailing-comma-tuple\", \"R1707\")\n",
                    "rendered": {
                      "text": "                and \"pylint:\" in token_string[1:]\n                # We have at least '#' 'pylint' ( + ':') (8 chars) at the start of the token\n                and \"enable\" in token_string[8:]\n                # We have at least '#', 'pylint', ( + ':'), 'enable' (+ '=') (15 chars) at\n                # the start of the token\n                and any(\n                    c in token_string[15:] for c in (\"trailing-comma-tuple\", \"R1707\")\n",
                      "markdown": "`                and \"pylint:\" in token_string[1:]\n                # We have at least '#' 'pylint' ( + ':') (8 chars) at the start of the token\n                and \"enable\" in token_string[8:]\n                # We have at least '#', 'pylint', ( + ':'), 'enable' (+ '=') (15 chars) at\n                # the start of the token\n                and any(\n                    c in token_string[15:] for c in (\"trailing-comma-tuple\", \"R1707\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 665,
                  "startColumn": 66,
                  "endLine": 665,
                  "endColumn": 70,
                  "snippet": {
                    "text": "                and token_string.startswith(\"#\")\n                # We have at least 1 '#' (one char) at the start of the token\n                and \"pylint:\" in token_string[1:]\n                # We have at least '#' 'pylint' ( + ':') (8 chars) at the start of the token\n                and \"enable\" in token_string[8:]\n                # We have at least '#', 'pylint', ( + ':'), 'enable' (+ '=') (15 chars) at\n                # the start of the token\n",
                    "rendered": {
                      "text": "                and token_string.startswith(\"#\")\n                # We have at least 1 '#' (one char) at the start of the token\n                and \"pylint:\" in token_string[1:]\n                # We have at least '#' 'pylint' ( + ':') (8 chars) at the start of the token\n                and \"enable\" in token_string[8:]\n                # We have at least '#', 'pylint', ( + ':'), 'enable' (+ '=') (15 chars) at\n                # the start of the token\n",
                      "markdown": "`                and token_string.startswith(\"#\")\n                # We have at least 1 '#' (one char) at the start of the token\n                and \"pylint:\" in token_string[1:]\n                # We have at least '#' 'pylint' ( + ':') (8 chars) at the start of the token\n                and \"enable\" in token_string[8:]\n                # We have at least '#', 'pylint', ( + ':'), 'enable' (+ '=') (15 chars) at\n                # the start of the token\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 665,
                  "startColumn": 25,
                  "endLine": 665,
                  "endColumn": 29,
                  "snippet": {
                    "text": "                and token_string.startswith(\"#\")\n                # We have at least 1 '#' (one char) at the start of the token\n                and \"pylint:\" in token_string[1:]\n                # We have at least '#' 'pylint' ( + ':') (8 chars) at the start of the token\n                and \"enable\" in token_string[8:]\n                # We have at least '#', 'pylint', ( + ':'), 'enable' (+ '=') (15 chars) at\n                # the start of the token\n",
                    "rendered": {
                      "text": "                and token_string.startswith(\"#\")\n                # We have at least 1 '#' (one char) at the start of the token\n                and \"pylint:\" in token_string[1:]\n                # We have at least '#' 'pylint' ( + ':') (8 chars) at the start of the token\n                and \"enable\" in token_string[8:]\n                # We have at least '#', 'pylint', ( + ':'), 'enable' (+ '=') (15 chars) at\n                # the start of the token\n",
                      "markdown": "`                and token_string.startswith(\"#\")\n                # We have at least 1 '#' (one char) at the start of the token\n                and \"pylint:\" in token_string[1:]\n                # We have at least '#' 'pylint' ( + ':') (8 chars) at the start of the token\n                and \"enable\" in token_string[8:]\n                # We have at least '#', 'pylint', ( + ':'), 'enable' (+ '=') (15 chars) at\n                # the start of the token\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 663,
                  "startColumn": 51,
                  "endLine": 663,
                  "endColumn": 55,
                  "snippet": {
                    "text": "            if (\n                not trailing_comma_tuple_enabled_once\n                and token_string.startswith(\"#\")\n                # We have at least 1 '#' (one char) at the start of the token\n                and \"pylint:\" in token_string[1:]\n                # We have at least '#' 'pylint' ( + ':') (8 chars) at the start of the token\n                and \"enable\" in token_string[8:]\n",
                    "rendered": {
                      "text": "            if (\n                not trailing_comma_tuple_enabled_once\n                and token_string.startswith(\"#\")\n                # We have at least 1 '#' (one char) at the start of the token\n                and \"pylint:\" in token_string[1:]\n                # We have at least '#' 'pylint' ( + ':') (8 chars) at the start of the token\n                and \"enable\" in token_string[8:]\n",
                      "markdown": "`            if (\n                not trailing_comma_tuple_enabled_once\n                and token_string.startswith(\"#\")\n                # We have at least 1 '#' (one char) at the start of the token\n                and \"pylint:\" in token_string[1:]\n                # We have at least '#' 'pylint' ( + ':') (8 chars) at the start of the token\n                and \"enable\" in token_string[8:]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 663,
                  "startColumn": 25,
                  "endLine": 663,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            if (\n                not trailing_comma_tuple_enabled_once\n                and token_string.startswith(\"#\")\n                # We have at least 1 '#' (one char) at the start of the token\n                and \"pylint:\" in token_string[1:]\n                # We have at least '#' 'pylint' ( + ':') (8 chars) at the start of the token\n                and \"enable\" in token_string[8:]\n",
                    "rendered": {
                      "text": "            if (\n                not trailing_comma_tuple_enabled_once\n                and token_string.startswith(\"#\")\n                # We have at least 1 '#' (one char) at the start of the token\n                and \"pylint:\" in token_string[1:]\n                # We have at least '#' 'pylint' ( + ':') (8 chars) at the start of the token\n                and \"enable\" in token_string[8:]\n",
                      "markdown": "`            if (\n                not trailing_comma_tuple_enabled_once\n                and token_string.startswith(\"#\")\n                # We have at least 1 '#' (one char) at the start of the token\n                and \"pylint:\" in token_string[1:]\n                # We have at least '#' 'pylint' ( + ':') (8 chars) at the start of the token\n                and \"enable\" in token_string[8:]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 319,
                  "startColumn": 27,
                  "endLine": 319,
                  "endColumn": 31,
                  "snippet": {
                    "text": "            \"should be present at the end of the function (if reachable)\",\n        ),\n        \"R1711\": (\n            \"Useless return at end of function or method\",\n            \"useless-return\",\n            'Emitted when a single \"return\" or \"return None\" statement is found '\n            \"at the end of function or method definition. This statement can safely be \"\n",
                    "rendered": {
                      "text": "            \"should be present at the end of the function (if reachable)\",\n        ),\n        \"R1711\": (\n            \"Useless return at end of function or method\",\n            \"useless-return\",\n            'Emitted when a single \"return\" or \"return None\" statement is found '\n            \"at the end of function or method definition. This statement can safely be \"\n",
                      "markdown": "`            \"should be present at the end of the function (if reachable)\",\n        ),\n        \"R1711\": (\n            \"Useless return at end of function or method\",\n            \"useless-return\",\n            'Emitted when a single \"return\" or \"return None\" statement is found '\n            \"at the end of function or method definition. This statement can safely be \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 316,
                  "startColumn": 30,
                  "endLine": 316,
                  "endColumn": 34,
                  "snippet": {
                    "text": "            \"According to PEP8, if any return statement returns an expression, \"\n            \"any return statements where no value is returned should explicitly \"\n            \"state this as return None, and an explicit return statement \"\n            \"should be present at the end of the function (if reachable)\",\n        ),\n        \"R1711\": (\n            \"Useless return at end of function or method\",\n",
                    "rendered": {
                      "text": "            \"According to PEP8, if any return statement returns an expression, \"\n            \"any return statements where no value is returned should explicitly \"\n            \"state this as return None, and an explicit return statement \"\n            \"should be present at the end of the function (if reachable)\",\n        ),\n        \"R1711\": (\n            \"Useless return at end of function or method\",\n",
                      "markdown": "`            \"According to PEP8, if any return statement returns an expression, \"\n            \"any return statements where no value is returned should explicitly \"\n            \"state this as return None, and an explicit return statement \"\n            \"should be present at the end of the function (if reachable)\",\n        ),\n        \"R1711\": (\n            \"Useless return at end of function or method\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 2083,
                  "startColumn": 80,
                  "endLine": 2083,
                  "endColumn": 86,
                  "snippet": {
                    "text": "        \"\"\"Return True if the function never returns, False otherwise.\n\n        Args:\n            node (nodes.FunctionDef or astroid.BoundMethod): function definition node to be analyzed.\n\n        Returns:\n            bool: True if the function never returns, False otherwise.\n",
                    "rendered": {
                      "text": "        \"\"\"Return True if the function never returns, False otherwise.\n\n        Args:\n            node (nodes.FunctionDef or astroid.BoundMethod): function definition node to be analyzed.\n\n        Returns:\n            bool: True if the function never returns, False otherwise.\n",
                      "markdown": "`        \"\"\"Return True if the function never returns, False otherwise.\n\n        Args:\n            node (nodes.FunctionDef or astroid.BoundMethod): function definition node to be analyzed.\n\n        Returns:\n            bool: True if the function never returns, False otherwise.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 2083,
                  "startColumn": 11,
                  "endLine": 2083,
                  "endColumn": 17,
                  "snippet": {
                    "text": "        \"\"\"Return True if the function never returns, False otherwise.\n\n        Args:\n            node (nodes.FunctionDef or astroid.BoundMethod): function definition node to be analyzed.\n\n        Returns:\n            bool: True if the function never returns, False otherwise.\n",
                    "rendered": {
                      "text": "        \"\"\"Return True if the function never returns, False otherwise.\n\n        Args:\n            node (nodes.FunctionDef or astroid.BoundMethod): function definition node to be analyzed.\n\n        Returns:\n            bool: True if the function never returns, False otherwise.\n",
                      "markdown": "`        \"\"\"Return True if the function never returns, False otherwise.\n\n        Args:\n            node (nodes.FunctionDef or astroid.BoundMethod): function definition node to be analyzed.\n\n        Returns:\n            bool: True if the function never returns, False otherwise.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 2064,
                  "startColumn": 41,
                  "endLine": 2065,
                  "snippet": {
                    "text": "        ):\n            # consider assert False as a return node\n            return True\n        # recurses on the children of the node\n        return any(self._is_node_return_ended(_child) for _child in node.get_children())\n\n    @staticmethod\n    def _has_return_in_siblings(node: nodes.NodeNG) -> bool:\n",
                    "rendered": {
                      "text": "        ):\n            # consider assert False as a return node\n            return True\n        # recurses on the children of the node\n        return any(self._is_node_return_ended(_child) for _child in node.get_children())\n\n    @staticmethod\n    def _has_return_in_siblings(node: nodes.NodeNG) -> bool:\n",
                      "markdown": "`        ):\n            # consider assert False as a return node\n            return True\n        # recurses on the children of the node\n        return any(self._is_node_return_ended(_child) for _child in node.get_children())\n\n    @staticmethod\n    def _has_return_in_siblings(node: nodes.NodeNG) -> bool:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 2062,
                  "startColumn": 47,
                  "endLine": 2063,
                  "snippet": {
                    "text": "            and isinstance(node.test, nodes.Const)\n            and not node.test.value\n        ):\n            # consider assert False as a return node\n            return True\n        # recurses on the children of the node\n        return any(self._is_node_return_ended(_child) for _child in node.get_children())\n\n",
                    "rendered": {
                      "text": "            and isinstance(node.test, nodes.Const)\n            and not node.test.value\n        ):\n            # consider assert False as a return node\n            return True\n        # recurses on the children of the node\n        return any(self._is_node_return_ended(_child) for _child in node.get_children())\n\n",
                      "markdown": "`            and isinstance(node.test, nodes.Const)\n            and not node.test.value\n        ):\n            # consider assert False as a return node\n            return True\n        # recurses on the children of the node\n        return any(self._is_node_return_ended(_child) for _child in node.get_children())\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 2024,
                  "startColumn": 29,
                  "endLine": 2024,
                  "endColumn": 35,
                  "snippet": {
                    "text": "            node (nodes.NodeNG): node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n        \"\"\"\n        # Recursion base case\n        if isinstance(node, nodes.Return):\n",
                    "rendered": {
                      "text": "            node (nodes.NodeNG): node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n        \"\"\"\n        # Recursion base case\n        if isinstance(node, nodes.Return):\n",
                      "markdown": "`            node (nodes.NodeNG): node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n        \"\"\"\n        # Recursion base case\n        if isinstance(node, nodes.Return):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 2021,
                  "startColumn": 32,
                  "endLine": 2021,
                  "endColumn": 38,
                  "snippet": {
                    "text": "        \"\"\"Check if the node ends with an explicit return statement.\n\n        Args:\n            node (nodes.NodeNG): node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n",
                    "rendered": {
                      "text": "        \"\"\"Check if the node ends with an explicit return statement.\n\n        Args:\n            node (nodes.NodeNG): node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n",
                      "markdown": "`        \"\"\"Check if the node ends with an explicit return statement.\n\n        Args:\n            node (nodes.NodeNG): node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 2021,
                  "startColumn": 11,
                  "endLine": 2021,
                  "endColumn": 17,
                  "snippet": {
                    "text": "        \"\"\"Check if the node ends with an explicit return statement.\n\n        Args:\n            node (nodes.NodeNG): node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n",
                    "rendered": {
                      "text": "        \"\"\"Check if the node ends with an explicit return statement.\n\n        Args:\n            node (nodes.NodeNG): node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n",
                      "markdown": "`        \"\"\"Check if the node ends with an explicit return statement.\n\n        Args:\n            node (nodes.NodeNG): node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 2018,
                  "startColumn": 23,
                  "endLine": 2018,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        return True\n\n    def _is_node_return_ended(self, node: nodes.NodeNG) -> bool:\n        \"\"\"Check if the node ends with an explicit return statement.\n\n        Args:\n            node (nodes.NodeNG): node to be checked.\n",
                    "rendered": {
                      "text": "        return True\n\n    def _is_node_return_ended(self, node: nodes.NodeNG) -> bool:\n        \"\"\"Check if the node ends with an explicit return statement.\n\n        Args:\n            node (nodes.NodeNG): node to be checked.\n",
                      "markdown": "`        return True\n\n    def _is_node_return_ended(self, node: nodes.NodeNG) -> bool:\n        \"\"\"Check if the node ends with an explicit return statement.\n\n        Args:\n            node (nodes.NodeNG): node to be checked.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1987,
                  "startColumn": 29,
                  "endLine": 1987,
                  "endColumn": 35,
                  "snippet": {
                    "text": "            node (nodes.Raise): Raise node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n        \"\"\"\n        # a Raise statement doesn't need to end with a return statement\n        # but if the exception raised is handled, then the handler has to\n",
                    "rendered": {
                      "text": "            node (nodes.Raise): Raise node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n        \"\"\"\n        # a Raise statement doesn't need to end with a return statement\n        # but if the exception raised is handled, then the handler has to\n",
                      "markdown": "`            node (nodes.Raise): Raise node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n        \"\"\"\n        # a Raise statement doesn't need to end with a return statement\n        # but if the exception raised is handled, then the handler has to\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1984,
                  "startColumn": 37,
                  "endLine": 1984,
                  "endColumn": 43,
                  "snippet": {
                    "text": "        \"\"\"Check if the Raise node ends with an explicit return statement.\n\n        Args:\n            node (nodes.Raise): Raise node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n",
                    "rendered": {
                      "text": "        \"\"\"Check if the Raise node ends with an explicit return statement.\n\n        Args:\n            node (nodes.Raise): Raise node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n",
                      "markdown": "`        \"\"\"Check if the Raise node ends with an explicit return statement.\n\n        Args:\n            node (nodes.Raise): Raise node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1984,
                  "startColumn": 11,
                  "endLine": 1984,
                  "endColumn": 17,
                  "snippet": {
                    "text": "        \"\"\"Check if the Raise node ends with an explicit return statement.\n\n        Args:\n            node (nodes.Raise): Raise node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n",
                    "rendered": {
                      "text": "        \"\"\"Check if the Raise node ends with an explicit return statement.\n\n        Args:\n            node (nodes.Raise): Raise node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n",
                      "markdown": "`        \"\"\"Check if the Raise node ends with an explicit return statement.\n\n        Args:\n            node (nodes.Raise): Raise node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1981,
                  "startColumn": 29,
                  "endLine": 1981,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        return is_if_returning and is_orelse_returning\n\n    def _is_raise_node_return_ended(self, node: nodes.Raise) -> bool:\n        \"\"\"Check if the Raise node ends with an explicit return statement.\n\n        Args:\n            node (nodes.Raise): Raise node to be checked.\n",
                    "rendered": {
                      "text": "        return is_if_returning and is_orelse_returning\n\n    def _is_raise_node_return_ended(self, node: nodes.Raise) -> bool:\n        \"\"\"Check if the Raise node ends with an explicit return statement.\n\n        Args:\n            node (nodes.Raise): Raise node to be checked.\n",
                      "markdown": "`        return is_if_returning and is_orelse_returning\n\n    def _is_raise_node_return_ended(self, node: nodes.Raise) -> bool:\n        \"\"\"Check if the Raise node ends with an explicit return statement.\n\n        Args:\n            node (nodes.Raise): Raise node to be checked.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1957,
                  "startColumn": 29,
                  "endLine": 1957,
                  "endColumn": 35,
                  "snippet": {
                    "text": "            node (nodes.If): If node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n        \"\"\"\n        # Do not check if inner function definition are return ended.\n        is_if_returning = any(\n",
                    "rendered": {
                      "text": "            node (nodes.If): If node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n        \"\"\"\n        # Do not check if inner function definition are return ended.\n        is_if_returning = any(\n",
                      "markdown": "`            node (nodes.If): If node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n        \"\"\"\n        # Do not check if inner function definition are return ended.\n        is_if_returning = any(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1954,
                  "startColumn": 31,
                  "endLine": 1954,
                  "endColumn": 37,
                  "snippet": {
                    "text": "        \"\"\"Check if the If node ends with an explicit return statement.\n\n        Args:\n            node (nodes.If): If node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n",
                    "rendered": {
                      "text": "        \"\"\"Check if the If node ends with an explicit return statement.\n\n        Args:\n            node (nodes.If): If node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n",
                      "markdown": "`        \"\"\"Check if the If node ends with an explicit return statement.\n\n        Args:\n            node (nodes.If): If node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1954,
                  "startColumn": 11,
                  "endLine": 1954,
                  "endColumn": 17,
                  "snippet": {
                    "text": "        \"\"\"Check if the If node ends with an explicit return statement.\n\n        Args:\n            node (nodes.If): If node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n",
                    "rendered": {
                      "text": "        \"\"\"Check if the If node ends with an explicit return statement.\n\n        Args:\n            node (nodes.If): If node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n",
                      "markdown": "`        \"\"\"Check if the If node ends with an explicit return statement.\n\n        Args:\n            node (nodes.If): If node to be checked.\n\n        Returns:\n            bool: True if the node ends with an explicit statement, False otherwise.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1951,
                  "startColumn": 26,
                  "endLine": 1951,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        self.add_message(\"inconsistent-return-statements\", node=node)\n\n    def _is_if_node_return_ended(self, node: nodes.If) -> bool:\n        \"\"\"Check if the If node ends with an explicit return statement.\n\n        Args:\n            node (nodes.If): If node to be checked.\n",
                    "rendered": {
                      "text": "        self.add_message(\"inconsistent-return-statements\", node=node)\n\n    def _is_if_node_return_ended(self, node: nodes.If) -> bool:\n        \"\"\"Check if the If node ends with an explicit return statement.\n\n        Args:\n            node (nodes.If): If node to be checked.\n",
                      "markdown": "`        self.add_message(\"inconsistent-return-statements\", node=node)\n\n    def _is_if_node_return_ended(self, node: nodes.If) -> bool:\n        \"\"\"Check if the If node ends with an explicit return statement.\n\n        Args:\n            node (nodes.If): If node to be checked.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1936,
                  "startColumn": 11,
                  "endLine": 1936,
                  "endColumn": 17,
                  "snippet": {
                    "text": "            - all returns are empty and if there is, possibly, an implicit return.\n\n        Args:\n            node (nodes.FunctionDef): the function holding the return statements.\n        \"\"\"\n        # explicit return statements are those with a not None value\n        explicit_returns = [\n",
                    "rendered": {
                      "text": "            - all returns are empty and if there is, possibly, an implicit return.\n\n        Args:\n            node (nodes.FunctionDef): the function holding the return statements.\n        \"\"\"\n        # explicit return statements are those with a not None value\n        explicit_returns = [\n",
                      "markdown": "`            - all returns are empty and if there is, possibly, an implicit return.\n\n        Args:\n            node (nodes.FunctionDef): the function holding the return statements.\n        \"\"\"\n        # explicit return statements are those with a not None value\n        explicit_returns = [\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1900,
                  "startColumn": 26,
                  "endLine": 1900,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n    @staticmethod\n    def _is_and_or_ternary(node: nodes.NodeNG | None) -> bool:\n        \"\"\"Returns true if node is 'condition and true_value or false_value' form.\n\n        All of: condition, true_value and false_value should not be a complex boolean expression\n        \"\"\"\n",
                    "rendered": {
                      "text": "\n    @staticmethod\n    def _is_and_or_ternary(node: nodes.NodeNG | None) -> bool:\n        \"\"\"Returns true if node is 'condition and true_value or false_value' form.\n\n        All of: condition, true_value and false_value should not be a complex boolean expression\n        \"\"\"\n",
                      "markdown": "`\n    @staticmethod\n    def _is_and_or_ternary(node: nodes.NodeNG | None) -> bool:\n        \"\"\"Returns true if node is 'condition and true_value or false_value' form.\n\n        All of: condition, true_value and false_value should not be a complex boolean expression\n        \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1685,
                  "startColumn": 11,
                  "endLine": 1686,
                  "snippet": {
                    "text": "            # a context manager he should use properly (i.e. in a ``with``).\n            return\n        if (\n            node\n            in self._consider_using_with_stack.get_stack_for_frame(\n                node.frame()\n            ).values()\n        ):\n",
                    "rendered": {
                      "text": "            # a context manager he should use properly (i.e. in a ``with``).\n            return\n        if (\n            node\n            in self._consider_using_with_stack.get_stack_for_frame(\n                node.frame()\n            ).values()\n        ):\n",
                      "markdown": "`            # a context manager he should use properly (i.e. in a ``with``).\n            return\n        if (\n            node\n            in self._consider_using_with_stack.get_stack_for_frame(\n                node.frame()\n            ).values()\n        ):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1681,
                  "startColumn": 20,
                  "endLine": 1681,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        if _is_inside_context_manager(node) or _is_a_return_statement(node):\n            # If we are inside a context manager itself, we assume that it will handle the\n            # resource management itself.\n            # If the node is a child of a return, we assume that the caller knows he is getting\n            # a context manager he should use properly (i.e. in a ``with``).\n            return\n        if (\n",
                    "rendered": {
                      "text": "        if _is_inside_context_manager(node) or _is_a_return_statement(node):\n            # If we are inside a context manager itself, we assume that it will handle the\n            # resource management itself.\n            # If the node is a child of a return, we assume that the caller knows he is getting\n            # a context manager he should use properly (i.e. in a ``with``).\n            return\n        if (\n",
                      "markdown": "`        if _is_inside_context_manager(node) or _is_a_return_statement(node):\n            # If we are inside a context manager itself, we assume that it will handle the\n            # resource management itself.\n            # If the node is a child of a return, we assume that the caller knows he is getting\n            # a context manager he should use properly (i.e. in a ``with``).\n            return\n        if (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1583,
                  "startColumn": 36,
                  "endLine": 1583,
                  "endColumn": 42,
                  "snippet": {
                    "text": "        if any(node in self._reported_swap_nodes for node in assignments):\n            return\n        left = [node.targets[0].name for node in assignments]\n        right = [node.value.name for node in assignments]\n        if left[0] == right[-1] and left[1:] == right[:-1]:\n            self._reported_swap_nodes.update(assignments)\n            message = \"consider-swap-variables\"\n",
                    "rendered": {
                      "text": "        if any(node in self._reported_swap_nodes for node in assignments):\n            return\n        left = [node.targets[0].name for node in assignments]\n        right = [node.value.name for node in assignments]\n        if left[0] == right[-1] and left[1:] == right[:-1]:\n            self._reported_swap_nodes.update(assignments)\n            message = \"consider-swap-variables\"\n",
                      "markdown": "`        if any(node in self._reported_swap_nodes for node in assignments):\n            return\n        left = [node.targets[0].name for node in assignments]\n        right = [node.value.name for node in assignments]\n        if left[0] == right[-1] and left[1:] == right[:-1]:\n            self._reported_swap_nodes.update(assignments)\n            message = \"consider-swap-variables\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1582,
                  "startColumn": 40,
                  "endLine": 1582,
                  "endColumn": 46,
                  "snippet": {
                    "text": "            return\n        if any(node in self._reported_swap_nodes for node in assignments):\n            return\n        left = [node.targets[0].name for node in assignments]\n        right = [node.value.name for node in assignments]\n        if left[0] == right[-1] and left[1:] == right[:-1]:\n            self._reported_swap_nodes.update(assignments)\n",
                    "rendered": {
                      "text": "            return\n        if any(node in self._reported_swap_nodes for node in assignments):\n            return\n        left = [node.targets[0].name for node in assignments]\n        right = [node.value.name for node in assignments]\n        if left[0] == right[-1] and left[1:] == right[:-1]:\n            self._reported_swap_nodes.update(assignments)\n",
                      "markdown": "`            return\n        if any(node in self._reported_swap_nodes for node in assignments):\n            return\n        left = [node.targets[0].name for node in assignments]\n        right = [node.value.name for node in assignments]\n        if left[0] == right[-1] and left[1:] == right[:-1]:\n            self._reported_swap_nodes.update(assignments)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1580,
                  "startColumn": 52,
                  "endLine": 1580,
                  "endColumn": 58,
                  "snippet": {
                    "text": "        assignments = [node, node.next_sibling(), node.next_sibling().next_sibling()]\n        if not all(self._is_simple_assignment(node) for node in assignments):\n            return\n        if any(node in self._reported_swap_nodes for node in assignments):\n            return\n        left = [node.targets[0].name for node in assignments]\n        right = [node.value.name for node in assignments]\n",
                    "rendered": {
                      "text": "        assignments = [node, node.next_sibling(), node.next_sibling().next_sibling()]\n        if not all(self._is_simple_assignment(node) for node in assignments):\n            return\n        if any(node in self._reported_swap_nodes for node in assignments):\n            return\n        left = [node.targets[0].name for node in assignments]\n        right = [node.value.name for node in assignments]\n",
                      "markdown": "`        assignments = [node, node.next_sibling(), node.next_sibling().next_sibling()]\n        if not all(self._is_simple_assignment(node) for node in assignments):\n            return\n        if any(node in self._reported_swap_nodes for node in assignments):\n            return\n        left = [node.targets[0].name for node in assignments]\n        right = [node.value.name for node in assignments]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1578,
                  "startColumn": 55,
                  "endLine": 1578,
                  "endColumn": 61,
                  "snippet": {
                    "text": "        if not node.next_sibling() or not node.next_sibling().next_sibling():\n            return\n        assignments = [node, node.next_sibling(), node.next_sibling().next_sibling()]\n        if not all(self._is_simple_assignment(node) for node in assignments):\n            return\n        if any(node in self._reported_swap_nodes for node in assignments):\n            return\n",
                    "rendered": {
                      "text": "        if not node.next_sibling() or not node.next_sibling().next_sibling():\n            return\n        assignments = [node, node.next_sibling(), node.next_sibling().next_sibling()]\n        if not all(self._is_simple_assignment(node) for node in assignments):\n            return\n        if any(node in self._reported_swap_nodes for node in assignments):\n            return\n",
                      "markdown": "`        if not node.next_sibling() or not node.next_sibling().next_sibling():\n            return\n        assignments = [node, node.next_sibling(), node.next_sibling().next_sibling()]\n        if not all(self._is_simple_assignment(node) for node in assignments):\n            return\n        if any(node in self._reported_swap_nodes for node in assignments):\n            return\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1317,
                  "startColumn": 33,
                  "endLine": 1317,
                  "endColumn": 39,
                  "snippet": {
                    "text": "    def _duplicated_isinstance_types(node: nodes.BoolOp) -> dict[str, set[str]]:\n        \"\"\"Get the duplicated types from the underlying isinstance calls.\n\n        :param nodes.BoolOp node: Node which should contain a bunch of isinstance calls.\n        :returns: Dictionary of the comparison objects from the isinstance calls,\n                  to duplicate values from consecutive calls.\n        :rtype: dict\n",
                    "rendered": {
                      "text": "    def _duplicated_isinstance_types(node: nodes.BoolOp) -> dict[str, set[str]]:\n        \"\"\"Get the duplicated types from the underlying isinstance calls.\n\n        :param nodes.BoolOp node: Node which should contain a bunch of isinstance calls.\n        :returns: Dictionary of the comparison objects from the isinstance calls,\n                  to duplicate values from consecutive calls.\n        :rtype: dict\n",
                      "markdown": "`    def _duplicated_isinstance_types(node: nodes.BoolOp) -> dict[str, set[str]]:\n        \"\"\"Get the duplicated types from the underlying isinstance calls.\n\n        :param nodes.BoolOp node: Node which should contain a bunch of isinstance calls.\n        :returns: Dictionary of the comparison objects from the isinstance calls,\n                  to duplicate values from consecutive calls.\n        :rtype: dict\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1310,
                  "startColumn": 11,
                  "endLine": 1310,
                  "endColumn": 17,
                  "snippet": {
                    "text": "    def _emit_consider_using_with_if_needed(\n        self, stack: dict[str, nodes.NodeNG]\n    ) -> None:\n        for node in stack.values():\n            self.add_message(\"consider-using-with\", node=node)\n\n    @staticmethod\n",
                    "rendered": {
                      "text": "    def _emit_consider_using_with_if_needed(\n        self, stack: dict[str, nodes.NodeNG]\n    ) -> None:\n        for node in stack.values():\n            self.add_message(\"consider-using-with\", node=node)\n\n    @staticmethod\n",
                      "markdown": "`    def _emit_consider_using_with_if_needed(\n        self, stack: dict[str, nodes.NodeNG]\n    ) -> None:\n        for node in stack.values():\n            self.add_message(\"consider-using-with\", node=node)\n\n    @staticmethod\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1287,
                  "startColumn": 20,
                  "endLine": 1287,
                  "endColumn": 26,
                  "snippet": {
                    "text": "                if ancestor_node == node.parent:\n                    break\n                self._nested_blocks.pop()\n            # if the node is an elif, this should not be another nesting level\n            if isinstance(node, nodes.If) and self._is_actual_elif(node):\n                if self._nested_blocks:\n                    self._nested_blocks.pop()\n",
                    "rendered": {
                      "text": "                if ancestor_node == node.parent:\n                    break\n                self._nested_blocks.pop()\n            # if the node is an elif, this should not be another nesting level\n            if isinstance(node, nodes.If) and self._is_actual_elif(node):\n                if self._nested_blocks:\n                    self._nested_blocks.pop()\n",
                      "markdown": "`                if ancestor_node == node.parent:\n                    break\n                self._nested_blocks.pop()\n            # if the node is an elif, this should not be another nesting level\n            if isinstance(node, nodes.If) and self._is_actual_elif(node):\n                if self._nested_blocks:\n                    self._nested_blocks.pop()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1277,
                  "startColumn": 35,
                  "endLine": 1277,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        if not isinstance(node.scope(), nodes.FunctionDef):\n            return\n        # messages are triggered on leaving the nested block. Here we save the\n        # stack in case the current node isn't nested in the previous one\n        nested_blocks = self._nested_blocks[:]\n        if node.parent == node.scope():\n            self._nested_blocks = [node]\n",
                    "rendered": {
                      "text": "        if not isinstance(node.scope(), nodes.FunctionDef):\n            return\n        # messages are triggered on leaving the nested block. Here we save the\n        # stack in case the current node isn't nested in the previous one\n        nested_blocks = self._nested_blocks[:]\n        if node.parent == node.scope():\n            self._nested_blocks = [node]\n",
                      "markdown": "`        if not isinstance(node.scope(), nodes.FunctionDef):\n            return\n        # messages are triggered on leaving the nested block. Here we save the\n        # stack in case the current node isn't nested in the previous one\n        nested_blocks = self._nested_blocks[:]\n        if node.parent == node.scope():\n            self._nested_blocks = [node]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1228,
                  "startColumn": 46,
                  "endLine": 1228,
                  "endColumn": 52,
                  "snippet": {
                    "text": "\n        If the next value has a default value, then do not add message.\n\n        :param node: Check to see if this Call node is a next function\n        :type node: :class:`nodes.Call`\n        \"\"\"\n\n",
                    "rendered": {
                      "text": "\n        If the next value has a default value, then do not add message.\n\n        :param node: Check to see if this Call node is a next function\n        :type node: :class:`nodes.Call`\n        \"\"\"\n\n",
                      "markdown": "`\n        If the next value has a default value, then do not add message.\n\n        :param node: Check to see if this Call node is a next function\n        :type node: :class:`nodes.Call`\n        \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 1068,
                  "startColumn": 39,
                  "endLine": 1068,
                  "endColumn": 45,
                  "snippet": {
                    "text": "    def _check_exception_inherit_from_stopiteration(\n        exc: nodes.ClassDef | bases.Instance,\n    ) -> bool:\n        \"\"\"Return True if the exception node in argument inherit from StopIteration.\"\"\"\n        stopiteration_qname = f\"{utils.EXCEPTIONS_MODULE}.StopIteration\"\n        return any(_class.qname() == stopiteration_qname for _class in exc.mro())\n\n",
                    "rendered": {
                      "text": "    def _check_exception_inherit_from_stopiteration(\n        exc: nodes.ClassDef | bases.Instance,\n    ) -> bool:\n        \"\"\"Return True if the exception node in argument inherit from StopIteration.\"\"\"\n        stopiteration_qname = f\"{utils.EXCEPTIONS_MODULE}.StopIteration\"\n        return any(_class.qname() == stopiteration_qname for _class in exc.mro())\n\n",
                      "markdown": "`    def _check_exception_inherit_from_stopiteration(\n        exc: nodes.ClassDef | bases.Instance,\n    ) -> bool:\n        \"\"\"Return True if the exception node in argument inherit from StopIteration.\"\"\"\n        stopiteration_qname = f\"{utils.EXCEPTIONS_MODULE}.StopIteration\"\n        return any(_class.qname() == stopiteration_qname for _class in exc.mro())\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 920,
                  "startColumn": 50,
                  "endLine": 920,
                  "endColumn": 56,
                  "snippet": {
                    "text": "            return\n\n        def get_node_name(node: nodes.NodeNG) -> str:\n            \"\"\"Obtain simplest representation of a node as a string.\"\"\"\n            if isinstance(node, nodes.Name):\n                return node.name  # type: ignore[no-any-return]\n            if isinstance(node, nodes.Const):\n",
                    "rendered": {
                      "text": "            return\n\n        def get_node_name(node: nodes.NodeNG) -> str:\n            \"\"\"Obtain simplest representation of a node as a string.\"\"\"\n            if isinstance(node, nodes.Name):\n                return node.name  # type: ignore[no-any-return]\n            if isinstance(node, nodes.Const):\n",
                      "markdown": "`            return\n\n        def get_node_name(node: nodes.NodeNG) -> str:\n            \"\"\"Obtain simplest representation of a node as a string.\"\"\"\n            if isinstance(node, nodes.Name):\n                return node.name  # type: ignore[no-any-return]\n            if isinstance(node, nodes.Const):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 906,
                  "startColumn": 32,
                  "endLine": 906,
                  "endColumn": 38,
                  "snippet": {
                    "text": "        self._check_consider_using_min_max_builtin(node)\n\n    def _check_consider_using_min_max_builtin(self, node: nodes.If) -> None:\n        \"\"\"Check if the given if node can be refactored as a min/max python builtin.\"\"\"\n        # This function is written expecting a test condition of form:\n        #  if a < b: # [consider-using-max-builtin]\n        #    a = b\n",
                    "rendered": {
                      "text": "        self._check_consider_using_min_max_builtin(node)\n\n    def _check_consider_using_min_max_builtin(self, node: nodes.If) -> None:\n        \"\"\"Check if the given if node can be refactored as a min/max python builtin.\"\"\"\n        # This function is written expecting a test condition of form:\n        #  if a < b: # [consider-using-max-builtin]\n        #    a = b\n",
                      "markdown": "`        self._check_consider_using_min_max_builtin(node)\n\n    def _check_consider_using_min_max_builtin(self, node: nodes.If) -> None:\n        \"\"\"Check if the given if node can be refactored as a min/max python builtin.\"\"\"\n        # This function is written expecting a test condition of form:\n        #  if a < b: # [consider-using-max-builtin]\n        #    a = b\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 680,
                  "startColumn": 35,
                  "endLine": 680,
                  "endColumn": 41,
                  "snippet": {
                    "text": "                # again due to the usual generic message control handling later.\n                trailing_comma_tuple_enabled_once = True\n            if token_string == \"elif\":\n                # AST exists by the time process_tokens is called, so\n                # it's safe to assume tokens[index+1] exists.\n                # tokens[index+1][2] is the elif's position as\n                # reported by CPython and PyPy,\n",
                    "rendered": {
                      "text": "                # again due to the usual generic message control handling later.\n                trailing_comma_tuple_enabled_once = True\n            if token_string == \"elif\":\n                # AST exists by the time process_tokens is called, so\n                # it's safe to assume tokens[index+1] exists.\n                # tokens[index+1][2] is the elif's position as\n                # reported by CPython and PyPy,\n",
                      "markdown": "`                # again due to the usual generic message control handling later.\n                trailing_comma_tuple_enabled_once = True\n            if token_string == \"elif\":\n                # AST exists by the time process_tokens is called, so\n                # it's safe to assume tokens[index+1] exists.\n                # tokens[index+1][2] is the elif's position as\n                # reported by CPython and PyPy,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 582,
                  "startColumn": 32,
                  "endLine": 582,
                  "endColumn": 38,
                  "snippet": {
                    "text": "        return False\n\n    def _check_simplifiable_if(self, node: nodes.If) -> None:\n        \"\"\"Check if the given if node can be simplified.\n\n        The if statement can be reduced to a boolean expression\n        in some cases. For instance, if there are two branches\n",
                    "rendered": {
                      "text": "        return False\n\n    def _check_simplifiable_if(self, node: nodes.If) -> None:\n        \"\"\"Check if the given if node can be simplified.\n\n        The if statement can be reduced to a boolean expression\n        in some cases. For instance, if there are two branches\n",
                      "markdown": "`        return False\n\n    def _check_simplifiable_if(self, node: nodes.If) -> None:\n        \"\"\"Check if the given if node can be simplified.\n\n        The if statement can be reduced to a boolean expression\n        in some cases. For instance, if there are two branches\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 575,
                  "startColumn": 24,
                  "endLine": 575,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        \"\"\"\n        if isinstance(node.parent, nodes.If):\n            orelse = node.parent.orelse\n            # current if node must directly follow an \"else\"\n            if orelse and orelse == [node]:\n                if (node.lineno, node.col_offset) in self._elifs:\n                    return True\n",
                    "rendered": {
                      "text": "        \"\"\"\n        if isinstance(node.parent, nodes.If):\n            orelse = node.parent.orelse\n            # current if node must directly follow an \"else\"\n            if orelse and orelse == [node]:\n                if (node.lineno, node.col_offset) in self._elifs:\n                    return True\n",
                      "markdown": "`        \"\"\"\n        if isinstance(node.parent, nodes.If):\n            orelse = node.parent.orelse\n            # current if node must directly follow an \"else\"\n            if orelse and orelse == [node]:\n                if (node.lineno, node.col_offset) in self._elifs:\n                    return True\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 566,
                  "startColumn": 29,
                  "endLine": 566,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        )\n\n    def _is_actual_elif(self, node: nodes.If | nodes.Try) -> bool:\n        \"\"\"Check if the given node is an actual elif.\n\n        This is a problem we're having with the builtin ast module,\n        which splits `elif` branches into a separate if statement.\n",
                    "rendered": {
                      "text": "        )\n\n    def _is_actual_elif(self, node: nodes.If | nodes.Try) -> bool:\n        \"\"\"Check if the given node is an actual elif.\n\n        This is a problem we're having with the builtin ast module,\n        which splits `elif` branches into a separate if statement.\n",
                      "markdown": "`        )\n\n    def _is_actual_elif(self, node: nodes.If | nodes.Try) -> bool:\n        \"\"\"Check if the given node is an actual elif.\n\n        This is a problem we're having with the builtin ast module,\n        which splits `elif` branches into a separate if statement.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 306,
                  "startColumn": 44,
                  "endLine": 306,
                  "endColumn": 50,
                  "snippet": {
                    "text": "            \"Do not raise StopIteration in generator, use return statement instead\",\n            \"stop-iteration-return\",\n            \"According to PEP479, the raise of StopIteration to end the loop of \"\n            \"a generator may lead to hard to find bugs. This PEP specify that \"\n            \"raise StopIteration has to be replaced by a simple return statement\",\n        ),\n        \"R1710\": (\n",
                    "rendered": {
                      "text": "            \"Do not raise StopIteration in generator, use return statement instead\",\n            \"stop-iteration-return\",\n            \"According to PEP479, the raise of StopIteration to end the loop of \"\n            \"a generator may lead to hard to find bugs. This PEP specify that \"\n            \"raise StopIteration has to be replaced by a simple return statement\",\n        ),\n        \"R1710\": (\n",
                      "markdown": "`            \"Do not raise StopIteration in generator, use return statement instead\",\n            \"stop-iteration-return\",\n            \"According to PEP479, the raise of StopIteration to end the loop of \"\n            \"a generator may lead to hard to find bugs. This PEP specify that \"\n            \"raise StopIteration has to be replaced by a simple return statement\",\n        ),\n        \"R1710\": (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 230,
                  "startColumn": 59,
                  "endLine": 231,
                  "snippet": {
                    "text": "    \"\"\"Looks for code which can be refactored.\n\n    This checker also mixes the astroid and the token approaches\n    in order to create knowledge about whether an \"else if\" node\n    is a true \"else if\" node, or an \"elif\" node.\n    \"\"\"\n\n    name = \"refactoring\"\n",
                    "rendered": {
                      "text": "    \"\"\"Looks for code which can be refactored.\n\n    This checker also mixes the astroid and the token approaches\n    in order to create knowledge about whether an \"else if\" node\n    is a true \"else if\" node, or an \"elif\" node.\n    \"\"\"\n\n    name = \"refactoring\"\n",
                      "markdown": "`    \"\"\"Looks for code which can be refactored.\n\n    This checker also mixes the astroid and the token approaches\n    in order to create knowledge about whether an \"else if\" node\n    is a true \"else if\" node, or an \"elif\" node.\n    \"\"\"\n\n    name = \"refactoring\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 190,
                  "startColumn": 14,
                  "endLine": 190,
                  "endColumn": 20,
                  "snippet": {
                    "text": "        return node in node.parent.targets\n\n    if isinstance(node.parent, nodes.AugAssign):\n        return node == node.parent.target  # type: ignore[no-any-return]\n\n    if isinstance(node.parent, (nodes.Tuple, nodes.List)):\n        return _is_part_of_assignment_target(node.parent)\n",
                    "rendered": {
                      "text": "        return node in node.parent.targets\n\n    if isinstance(node.parent, nodes.AugAssign):\n        return node == node.parent.target  # type: ignore[no-any-return]\n\n    if isinstance(node.parent, (nodes.Tuple, nodes.List)):\n        return _is_part_of_assignment_target(node.parent)\n",
                      "markdown": "`        return node in node.parent.targets\n\n    if isinstance(node.parent, nodes.AugAssign):\n        return node == node.parent.target  # type: ignore[no-any-return]\n\n    if isinstance(node.parent, (nodes.Tuple, nodes.List)):\n        return _is_part_of_assignment_target(node.parent)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 187,
                  "startColumn": 14,
                  "endLine": 187,
                  "endColumn": 20,
                  "snippet": {
                    "text": "    arbitrarily nested tuples and lists to unpack.\n    \"\"\"\n    if isinstance(node.parent, nodes.Assign):\n        return node in node.parent.targets\n\n    if isinstance(node.parent, nodes.AugAssign):\n        return node == node.parent.target  # type: ignore[no-any-return]\n",
                    "rendered": {
                      "text": "    arbitrarily nested tuples and lists to unpack.\n    \"\"\"\n    if isinstance(node.parent, nodes.Assign):\n        return node in node.parent.targets\n\n    if isinstance(node.parent, nodes.AugAssign):\n        return node == node.parent.target  # type: ignore[no-any-return]\n",
                      "markdown": "`    arbitrarily nested tuples and lists to unpack.\n    \"\"\"\n    if isinstance(node.parent, nodes.Assign):\n        return node in node.parent.targets\n\n    if isinstance(node.parent, nodes.AugAssign):\n        return node == node.parent.target  # type: ignore[no-any-return]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 151,
                  "startColumn": 13,
                  "endLine": 152,
                  "snippet": {
                    "text": "    itself is located somewhere under its ``items``.\n    \"\"\"\n    frame = node.frame()\n    current = node\n    while current != frame:\n        if isinstance(current, nodes.With):\n            items_start = current.items[0][0].lineno\n            items_end = current.items[-1][0].tolineno\n",
                    "rendered": {
                      "text": "    itself is located somewhere under its ``items``.\n    \"\"\"\n    frame = node.frame()\n    current = node\n    while current != frame:\n        if isinstance(current, nodes.With):\n            items_start = current.items[0][0].lineno\n            items_end = current.items[-1][0].tolineno\n",
                      "markdown": "`    itself is located somewhere under its ``items``.\n    \"\"\"\n    frame = node.frame()\n    current = node\n    while current != frame:\n        if isinstance(current, nodes.With):\n            items_start = current.items[0][0].lineno\n            items_end = current.items[-1][0].tolineno\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 147,
                  "startColumn": 80,
                  "endLine": 148,
                  "snippet": {
                    "text": "\n\ndef _is_part_of_with_items(node: nodes.Call) -> bool:\n    \"\"\"Checks if one of the node's parents is a ``nodes.With`` node and that the node\n    itself is located somewhere under its ``items``.\n    \"\"\"\n    frame = node.frame()\n    current = node\n",
                    "rendered": {
                      "text": "\n\ndef _is_part_of_with_items(node: nodes.Call) -> bool:\n    \"\"\"Checks if one of the node's parents is a ``nodes.With`` node and that the node\n    itself is located somewhere under its ``items``.\n    \"\"\"\n    frame = node.frame()\n    current = node\n",
                      "markdown": "`\n\ndef _is_part_of_with_items(node: nodes.Call) -> bool:\n    \"\"\"Checks if one of the node's parents is a ``nodes.With`` node and that the node\n    itself is located somewhere under its ``items``.\n    \"\"\"\n    frame = node.frame()\n    current = node\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 147,
                  "startColumn": 62,
                  "endLine": 147,
                  "endColumn": 68,
                  "snippet": {
                    "text": "\n\ndef _is_part_of_with_items(node: nodes.Call) -> bool:\n    \"\"\"Checks if one of the node's parents is a ``nodes.With`` node and that the node\n    itself is located somewhere under its ``items``.\n    \"\"\"\n    frame = node.frame()\n",
                    "rendered": {
                      "text": "\n\ndef _is_part_of_with_items(node: nodes.Call) -> bool:\n    \"\"\"Checks if one of the node's parents is a ``nodes.With`` node and that the node\n    itself is located somewhere under its ``items``.\n    \"\"\"\n    frame = node.frame()\n",
                      "markdown": "`\n\ndef _is_part_of_with_items(node: nodes.Call) -> bool:\n    \"\"\"Checks if one of the node's parents is a ``nodes.With`` node and that the node\n    itself is located somewhere under its ``items``.\n    \"\"\"\n    frame = node.frame()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/refactoring_checker.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 57,
                  "endLine": 69,
                  "endColumn": 63,
                  "snippet": {
                    "text": "def _if_statement_is_always_returning(\n    if_node: nodes.If, returning_node_class: nodes.NodeNG\n) -> bool:\n    return any(isinstance(node, returning_node_class) for node in if_node.body)\n\n\ndef _except_statement_is_always_returning(\n",
                    "rendered": {
                      "text": "def _if_statement_is_always_returning(\n    if_node: nodes.If, returning_node_class: nodes.NodeNG\n) -> bool:\n    return any(isinstance(node, returning_node_class) for node in if_node.body)\n\n\ndef _except_statement_is_always_returning(\n",
                      "markdown": "`def _if_statement_is_always_returning(\n    if_node: nodes.If, returning_node_class: nodes.NodeNG\n) -> bool:\n    return any(isinstance(node, returning_node_class) for node in if_node.body)\n\n\ndef _except_statement_is_always_returning(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/refactoring/recommendation_checker.py"
                },
                "region": {
                  "startLine": 154,
                  "startColumn": 63,
                  "endLine": 155,
                  "snippet": {
                    "text": "\n            # Check for cases where variable (Name) subscripts may be mutated within a loop\n            if isinstance(node.parent.slice, nodes.Name):\n                # Check if loop present within the scope of the node\n                scope = node.scope()\n                for loop_node in scope.nodes_of_class((nodes.For, nodes.While)):\n                    if not loop_node.parent_of(node):\n                        continue\n",
                    "rendered": {
                      "text": "\n            # Check for cases where variable (Name) subscripts may be mutated within a loop\n            if isinstance(node.parent.slice, nodes.Name):\n                # Check if loop present within the scope of the node\n                scope = node.scope()\n                for loop_node in scope.nodes_of_class((nodes.For, nodes.While)):\n                    if not loop_node.parent_of(node):\n                        continue\n",
                      "markdown": "`\n            # Check for cases where variable (Name) subscripts may be mutated within a loop\n            if isinstance(node.parent.slice, nodes.Name):\n                # Check if loop present within the scope of the node\n                scope = node.scope()\n                for loop_node in scope.nodes_of_class((nodes.For, nodes.While)):\n                    if not loop_node.parent_of(node):\n                        continue\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_error_checker.py"
                },
                "region": {
                  "startLine": 315,
                  "startColumn": 48,
                  "endLine": 315,
                  "endColumn": 53,
                  "snippet": {
                    "text": "                continue\n\n            name = node_name.name\n            corresponding_global = scope_globals.get(name)\n            if not corresponding_global:\n                continue\n\n",
                    "rendered": {
                      "text": "                continue\n\n            name = node_name.name\n            corresponding_global = scope_globals.get(name)\n            if not corresponding_global:\n                continue\n\n",
                      "markdown": "`                continue\n\n            name = node_name.name\n            corresponding_global = scope_globals.get(name)\n            if not corresponding_global:\n                continue\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_error_checker.py"
                },
                "region": {
                  "startLine": 520,
                  "startColumn": 30,
                  "endLine": 520,
                  "endColumn": 36,
                  "snippet": {
                    "text": "            (local for local in redefinitions if not utils.is_overload_stub(local)),\n            node,\n        )\n        if defined_self is not node and not astroid.are_exclusive(node, defined_self):\n            # Additional checks for methods which are not considered\n            # redefined, since they are already part of the base API.\n            if (\n",
                    "rendered": {
                      "text": "            (local for local in redefinitions if not utils.is_overload_stub(local)),\n            node,\n        )\n        if defined_self is not node and not astroid.are_exclusive(node, defined_self):\n            # Additional checks for methods which are not considered\n            # redefined, since they are already part of the base API.\n            if (\n",
                      "markdown": "`            (local for local in redefinitions if not utils.is_overload_stub(local)),\n            node,\n        )\n        if defined_self is not node and not astroid.are_exclusive(node, defined_self):\n            # Additional checks for methods which are not considered\n            # redefined, since they are already part of the base API.\n            if (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_error_checker.py"
                },
                "region": {
                  "startLine": 496,
                  "startColumn": 19,
                  "endLine": 496,
                  "endColumn": 25,
                  "snippet": {
                    "text": "                break\n            if (\n                isinstance(parent, nodes.Try)\n                and node in parent.finalbody\n                and isinstance(node, nodes.Continue)\n                and not self._py38_plus\n            ):\n",
                    "rendered": {
                      "text": "                break\n            if (\n                isinstance(parent, nodes.Try)\n                and node in parent.finalbody\n                and isinstance(node, nodes.Continue)\n                and not self._py38_plus\n            ):\n",
                      "markdown": "`                break\n            if (\n                isinstance(parent, nodes.Try)\n                and node in parent.finalbody\n                and isinstance(node, nodes.Continue)\n                and not self._py38_plus\n            ):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_error_checker.py"
                },
                "region": {
                  "startLine": 489,
                  "startColumn": 18,
                  "endLine": 489,
                  "endColumn": 24,
                  "snippet": {
                    "text": "        \"\"\"Check that a node is inside a for or while loop.\"\"\"\n        for parent in node.node_ancestors():\n            if isinstance(parent, (nodes.For, nodes.While)):\n                if node not in parent.orelse:\n                    return\n\n            if isinstance(parent, (nodes.ClassDef, nodes.FunctionDef)):\n",
                    "rendered": {
                      "text": "        \"\"\"Check that a node is inside a for or while loop.\"\"\"\n        for parent in node.node_ancestors():\n            if isinstance(parent, (nodes.For, nodes.While)):\n                if node not in parent.orelse:\n                    return\n\n            if isinstance(parent, (nodes.ClassDef, nodes.FunctionDef)):\n",
                      "markdown": "`        \"\"\"Check that a node is inside a for or while loop.\"\"\"\n        for parent in node.node_ancestors():\n            if isinstance(parent, (nodes.For, nodes.While)):\n                if node not in parent.orelse:\n                    return\n\n            if isinstance(parent, (nodes.ClassDef, nodes.FunctionDef)):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_error_checker.py"
                },
                "region": {
                  "startLine": 486,
                  "startColumn": 23,
                  "endLine": 486,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    def _check_in_loop(\n        self, node: nodes.Continue | nodes.Break, node_name: str\n    ) -> None:\n        \"\"\"Check that a node is inside a for or while loop.\"\"\"\n        for parent in node.node_ancestors():\n            if isinstance(parent, (nodes.For, nodes.While)):\n                if node not in parent.orelse:\n",
                    "rendered": {
                      "text": "    def _check_in_loop(\n        self, node: nodes.Continue | nodes.Break, node_name: str\n    ) -> None:\n        \"\"\"Check that a node is inside a for or while loop.\"\"\"\n        for parent in node.node_ancestors():\n            if isinstance(parent, (nodes.For, nodes.While)):\n                if node not in parent.orelse:\n",
                      "markdown": "`    def _check_in_loop(\n        self, node: nodes.Continue | nodes.Break, node_name: str\n    ) -> None:\n        \"\"\"Check that a node is inside a for or while loop.\"\"\"\n        for parent in node.node_ancestors():\n            if isinstance(parent, (nodes.For, nodes.While)):\n                if node not in parent.orelse:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_error_checker.py"
                },
                "region": {
                  "startLine": 329,
                  "startColumn": 37,
                  "endLine": 330,
                  "snippet": {
                    "text": "        \"\"\"Check that a name is both nonlocal and global.\"\"\"\n\n        def same_scope(current: nodes.Global | nodes.Nonlocal) -> bool:\n            return current.scope() is node\n\n        from_iter = itertools.chain.from_iterable\n        nonlocals = set(\n            from_iter(\n",
                    "rendered": {
                      "text": "        \"\"\"Check that a name is both nonlocal and global.\"\"\"\n\n        def same_scope(current: nodes.Global | nodes.Nonlocal) -> bool:\n            return current.scope() is node\n\n        from_iter = itertools.chain.from_iterable\n        nonlocals = set(\n            from_iter(\n",
                      "markdown": "`        \"\"\"Check that a name is both nonlocal and global.\"\"\"\n\n        def same_scope(current: nodes.Global | nodes.Nonlocal) -> bool:\n            return current.scope() is node\n\n        from_iter = itertools.chain.from_iterable\n        nonlocals = set(\n            from_iter(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_error_checker.py"
                },
                "region": {
                  "startLine": 304,
                  "startColumn": 31,
                  "endLine": 305,
                  "snippet": {
                    "text": "            name: child\n            for child in node.nodes_of_class(nodes.Global)\n            for name in child.names\n            if child.scope() is node\n        }\n\n        if not scope_globals:\n            return\n",
                    "rendered": {
                      "text": "            name: child\n            for child in node.nodes_of_class(nodes.Global)\n            for name in child.names\n            if child.scope() is node\n        }\n\n        if not scope_globals:\n            return\n",
                      "markdown": "`            name: child\n            for child in node.nodes_of_class(nodes.Global)\n            for name in child.names\n            if child.scope() is node\n        }\n\n        if not scope_globals:\n            return\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_error_checker.py"
                },
                "region": {
                  "startLine": 269,
                  "startColumn": 11,
                  "endLine": 270,
                  "snippet": {
                    "text": "        self._check_nonlocal_and_global(node)\n        self._check_name_used_prior_global(node)\n        if not redefined_by_decorator(\n            node\n        ) and not utils.is_registered_in_singledispatch_function(node):\n            self._check_redefinition(node.is_method() and \"method\" or \"function\", node)\n        # checks for max returns, branch, return in __init__\n        returns = node.nodes_of_class(\n",
                    "rendered": {
                      "text": "        self._check_nonlocal_and_global(node)\n        self._check_name_used_prior_global(node)\n        if not redefined_by_decorator(\n            node\n        ) and not utils.is_registered_in_singledispatch_function(node):\n            self._check_redefinition(node.is_method() and \"method\" or \"function\", node)\n        # checks for max returns, branch, return in __init__\n        returns = node.nodes_of_class(\n",
                      "markdown": "`        self._check_nonlocal_and_global(node)\n        self._check_name_used_prior_global(node)\n        if not redefined_by_decorator(\n            node\n        ) and not utils.is_registered_in_singledispatch_function(node):\n            self._check_redefinition(node.is_method() and \"method\" or \"function\", node)\n        # checks for max returns, branch, return in __init__\n        returns = node.nodes_of_class(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_error_checker.py"
                },
                "region": {
                  "startLine": 253,
                  "startColumn": 24,
                  "endLine": 253,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        if not isinstance(stmt, nodes.Assign):\n            return\n\n        if stmt.value is node or stmt.value.parent_of(node):\n            self.add_message(\"star-needs-assignment-target\", node=node)\n\n    @utils.only_required_for_messages(\n",
                    "rendered": {
                      "text": "        if not isinstance(stmt, nodes.Assign):\n            return\n\n        if stmt.value is node or stmt.value.parent_of(node):\n            self.add_message(\"star-needs-assignment-target\", node=node)\n\n    @utils.only_required_for_messages(\n",
                      "markdown": "`        if not isinstance(stmt, nodes.Assign):\n            return\n\n        if stmt.value is node or stmt.value.parent_of(node):\n            self.add_message(\"star-needs-assignment-target\", node=node)\n\n    @utils.only_required_for_messages(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_error_checker.py"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 51,
                  "endLine": 51,
                  "endColumn": 57,
                  "snippet": {
                    "text": "    \"\"\"Returns true if a loop may end with a break statement.\n\n    Args:\n        loop (astroid.For, astroid.While): the loop node inspected.\n\n    Returns:\n        bool: True if the loop may end with a break statement, False otherwise.\n",
                    "rendered": {
                      "text": "    \"\"\"Returns true if a loop may end with a break statement.\n\n    Args:\n        loop (astroid.For, astroid.While): the loop node inspected.\n\n    Returns:\n        bool: True if the loop may end with a break statement, False otherwise.\n",
                      "markdown": "`    \"\"\"Returns true if a loop may end with a break statement.\n\n    Args:\n        loop (astroid.For, astroid.While): the loop node inspected.\n\n    Returns:\n        bool: True if the loop may end with a break statement, False otherwise.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_error_checker.py"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 46,
                  "endLine": 33,
                  "endColumn": 52,
                  "snippet": {
                    "text": "        break_node (astroid.Break): the break node of interest.\n\n    Returns:\n        astroid.For or astroid.While: the loop node holding the break node.\n    \"\"\"\n    loop_nodes = (nodes.For, nodes.While)\n    parent = break_node.parent\n",
                    "rendered": {
                      "text": "        break_node (astroid.Break): the break node of interest.\n\n    Returns:\n        astroid.For or astroid.While: the loop node holding the break node.\n    \"\"\"\n    loop_nodes = (nodes.For, nodes.While)\n    parent = break_node.parent\n",
                      "markdown": "`        break_node (astroid.Break): the break node of interest.\n\n    Returns:\n        astroid.For or astroid.While: the loop node holding the break node.\n    \"\"\"\n    loop_nodes = (nodes.For, nodes.While)\n    parent = break_node.parent\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_error_checker.py"
                },
                "region": {
                  "startLine": 30,
                  "startColumn": 45,
                  "endLine": 30,
                  "endColumn": 51,
                  "snippet": {
                    "text": "    \"\"\"Returns the loop node that holds the break node in arguments.\n\n    Args:\n        break_node (astroid.Break): the break node of interest.\n\n    Returns:\n        astroid.For or astroid.While: the loop node holding the break node.\n",
                    "rendered": {
                      "text": "    \"\"\"Returns the loop node that holds the break node in arguments.\n\n    Args:\n        break_node (astroid.Break): the break node of interest.\n\n    Returns:\n        astroid.For or astroid.While: the loop node holding the break node.\n",
                      "markdown": "`    \"\"\"Returns the loop node that holds the break node in arguments.\n\n    Args:\n        break_node (astroid.Break): the break node of interest.\n\n    Returns:\n        astroid.For or astroid.While: the loop node holding the break node.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_error_checker.py"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 49,
                  "endLine": 27,
                  "endColumn": 55,
                  "snippet": {
                    "text": "\n\ndef _get_break_loop_node(break_node: nodes.Break) -> nodes.For | nodes.While | None:\n    \"\"\"Returns the loop node that holds the break node in arguments.\n\n    Args:\n        break_node (astroid.Break): the break node of interest.\n",
                    "rendered": {
                      "text": "\n\ndef _get_break_loop_node(break_node: nodes.Break) -> nodes.For | nodes.While | None:\n    \"\"\"Returns the loop node that holds the break node in arguments.\n\n    Args:\n        break_node (astroid.Break): the break node of interest.\n",
                      "markdown": "`\n\ndef _get_break_loop_node(break_node: nodes.Break) -> nodes.For | nodes.While | None:\n    \"\"\"Returns the loop node that holds the break node in arguments.\n\n    Args:\n        break_node (astroid.Break): the break node of interest.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_error_checker.py"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 23,
                  "endLine": 27,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n\ndef _get_break_loop_node(break_node: nodes.Break) -> nodes.For | nodes.While | None:\n    \"\"\"Returns the loop node that holds the break node in arguments.\n\n    Args:\n        break_node (astroid.Break): the break node of interest.\n",
                    "rendered": {
                      "text": "\n\ndef _get_break_loop_node(break_node: nodes.Break) -> nodes.For | nodes.While | None:\n    \"\"\"Returns the loop node that holds the break node in arguments.\n\n    Args:\n        break_node (astroid.Break): the break node of interest.\n",
                      "markdown": "`\n\ndef _get_break_loop_node(break_node: nodes.Break) -> nodes.For | nodes.While | None:\n    \"\"\"Returns the loop node that holds the break node in arguments.\n\n    Args:\n        break_node (astroid.Break): the break node of interest.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 33,
                  "endLine": 96,
                  "endColumn": 38,
                  "snippet": {
                    "text": "            str(old) if old else \"NC\",\n            diff_str if diff_str else \"NC\",\n            nice_stats[node_type].get(\"percent_documented\", \"0\"),\n            nice_stats[node_type].get(\"percent_badname\", \"0\"),\n        ]\n    sect.append(reporter_nodes.Table(children=lines, cols=6, rheaders=1))\n\n",
                    "rendered": {
                      "text": "            str(old) if old else \"NC\",\n            diff_str if diff_str else \"NC\",\n            nice_stats[node_type].get(\"percent_documented\", \"0\"),\n            nice_stats[node_type].get(\"percent_badname\", \"0\"),\n        ]\n    sect.append(reporter_nodes.Table(children=lines, cols=6, rheaders=1))\n\n",
                      "markdown": "`            str(old) if old else \"NC\",\n            diff_str if diff_str else \"NC\",\n            nice_stats[node_type].get(\"percent_documented\", \"0\"),\n            nice_stats[node_type].get(\"percent_badname\", \"0\"),\n        ]\n    sect.append(reporter_nodes.Table(children=lines, cols=6, rheaders=1))\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 33,
                  "endLine": 95,
                  "endColumn": 38,
                  "snippet": {
                    "text": "            str(new),\n            str(old) if old else \"NC\",\n            diff_str if diff_str else \"NC\",\n            nice_stats[node_type].get(\"percent_documented\", \"0\"),\n            nice_stats[node_type].get(\"percent_badname\", \"0\"),\n        ]\n    sect.append(reporter_nodes.Table(children=lines, cols=6, rheaders=1))\n",
                    "rendered": {
                      "text": "            str(new),\n            str(old) if old else \"NC\",\n            diff_str if diff_str else \"NC\",\n            nice_stats[node_type].get(\"percent_documented\", \"0\"),\n            nice_stats[node_type].get(\"percent_badname\", \"0\"),\n        ]\n    sect.append(reporter_nodes.Table(children=lines, cols=6, rheaders=1))\n",
                      "markdown": "`            str(new),\n            str(old) if old else \"NC\",\n            diff_str if diff_str else \"NC\",\n            nice_stats[node_type].get(\"percent_documented\", \"0\"),\n            nice_stats[node_type].get(\"percent_badname\", \"0\"),\n        ]\n    sect.append(reporter_nodes.Table(children=lines, cols=6, rheaders=1))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 531,
                  "startColumn": 34,
                  "endLine": 531,
                  "endColumn": 38,
                  "snippet": {
                    "text": "        \"\"\"Check whether the lambda is suspicious.\"\"\"\n        # if the body of the lambda is a call expression with the same\n        # argument list as the lambda itself, then the lambda is\n        # possibly unnecessary and at least suspicious.\n        if node.args.defaults:\n            # If the arguments of the lambda include defaults, then a\n            # judgment cannot be made because there is no way to check\n",
                    "rendered": {
                      "text": "        \"\"\"Check whether the lambda is suspicious.\"\"\"\n        # if the body of the lambda is a call expression with the same\n        # argument list as the lambda itself, then the lambda is\n        # possibly unnecessary and at least suspicious.\n        if node.args.defaults:\n            # If the arguments of the lambda include defaults, then a\n            # judgment cannot be made because there is no way to check\n",
                      "markdown": "`        \"\"\"Check whether the lambda is suspicious.\"\"\"\n        # if the body of the lambda is a call expression with the same\n        # argument list as the lambda itself, then the lambda is\n        # possibly unnecessary and at least suspicious.\n        if node.args.defaults:\n            # If the arguments of the lambda include defaults, then a\n            # judgment cannot be made because there is no way to check\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 439,
                  "startColumn": 27,
                  "endLine": 439,
                  "endColumn": 31,
                  "snippet": {
                    "text": "            # treat string statement in a separated message\n            # Handle PEP-257 attribute docstrings.\n            # An attribute docstring is defined as being a string right after\n            # an assignment at the module level, class level or __init__ level.\n            scope = expr.scope()\n            if isinstance(scope, (nodes.ClassDef, nodes.Module, nodes.FunctionDef)):\n                if isinstance(scope, nodes.FunctionDef) and scope.name != \"__init__\":\n",
                    "rendered": {
                      "text": "            # treat string statement in a separated message\n            # Handle PEP-257 attribute docstrings.\n            # An attribute docstring is defined as being a string right after\n            # an assignment at the module level, class level or __init__ level.\n            scope = expr.scope()\n            if isinstance(scope, (nodes.ClassDef, nodes.Module, nodes.FunctionDef)):\n                if isinstance(scope, nodes.FunctionDef) and scope.name != \"__init__\":\n",
                      "markdown": "`            # treat string statement in a separated message\n            # Handle PEP-257 attribute docstrings.\n            # An attribute docstring is defined as being a string right after\n            # an assignment at the module level, class level or __init__ level.\n            scope = expr.scope()\n            if isinstance(scope, (nodes.ClassDef, nodes.Module, nodes.FunctionDef)):\n                if isinstance(scope, nodes.FunctionDef) and scope.name != \"__init__\":\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 132,
                  "startColumn": 51,
                  "endLine": 132,
                  "endColumn": 55,
                  "snippet": {
                    "text": "        \"W0104\": (\n            \"Statement seems to have no effect\",\n            \"pointless-statement\",\n            \"Used when a statement doesn't have (or at least seems to) any effect.\",\n        ),\n        \"W0105\": (\n            \"String statement has no effect\",\n",
                    "rendered": {
                      "text": "        \"W0104\": (\n            \"Statement seems to have no effect\",\n            \"pointless-statement\",\n            \"Used when a statement doesn't have (or at least seems to) any effect.\",\n        ),\n        \"W0105\": (\n            \"String statement has no effect\",\n",
                      "markdown": "`        \"W0104\": (\n            \"Statement seems to have no effect\",\n            \"pointless-statement\",\n            \"Used when a statement doesn't have (or at least seems to) any effect.\",\n        ),\n        \"W0105\": (\n            \"String statement has no effect\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 885,
                  "startColumn": 27,
                  "endLine": 885,
                  "endColumn": 33,
                  "snippet": {
                    "text": "    @utils.only_required_for_messages(\"confusing-with-statement\")\n    def visit_with(self, node: nodes.With) -> None:\n        # a \"with\" statement with multiple managers corresponds\n        # to one AST \"With\" node with multiple items\n        pairs = node.items\n        if pairs:\n            for prev_pair, pair in zip(pairs, pairs[1:]):\n",
                    "rendered": {
                      "text": "    @utils.only_required_for_messages(\"confusing-with-statement\")\n    def visit_with(self, node: nodes.With) -> None:\n        # a \"with\" statement with multiple managers corresponds\n        # to one AST \"With\" node with multiple items\n        pairs = node.items\n        if pairs:\n            for prev_pair, pair in zip(pairs, pairs[1:]):\n",
                      "markdown": "`    @utils.only_required_for_messages(\"confusing-with-statement\")\n    def visit_with(self, node: nodes.With) -> None:\n        # a \"with\" statement with multiple managers corresponds\n        # to one AST \"With\" node with multiple items\n        pairs = node.items\n        if pairs:\n            for prev_pair, pair in zip(pairs, pairs[1:]):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 817,
                  "startColumn": 15,
                  "endLine": 818,
                  "snippet": {
                    "text": "            return\n        # the node could be a grand-grand...-child of the 'try...finally'\n        _parent = node.parent\n        _node = node\n        while _parent and not isinstance(_parent, breaker_classes):\n            if hasattr(_parent, \"finalbody\") and _node in _parent.finalbody:\n                self.add_message(\"lost-exception\", node=node, args=node_name)\n                return\n",
                    "rendered": {
                      "text": "            return\n        # the node could be a grand-grand...-child of the 'try...finally'\n        _parent = node.parent\n        _node = node\n        while _parent and not isinstance(_parent, breaker_classes):\n            if hasattr(_parent, \"finalbody\") and _node in _parent.finalbody:\n                self.add_message(\"lost-exception\", node=node, args=node_name)\n                return\n",
                      "markdown": "`            return\n        # the node could be a grand-grand...-child of the 'try...finally'\n        _parent = node.parent\n        _node = node\n        while _parent and not isinstance(_parent, breaker_classes):\n            if hasattr(_parent, \"finalbody\") and _node in _parent.finalbody:\n                self.add_message(\"lost-exception\", node=node, args=node_name)\n                return\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 815,
                  "startColumn": 13,
                  "endLine": 815,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        # if self._trys is empty, we're not an in try block\n        if not self._trys:\n            return\n        # the node could be a grand-grand...-child of the 'try...finally'\n        _parent = node.parent\n        _node = node\n        while _parent and not isinstance(_parent, breaker_classes):\n",
                    "rendered": {
                      "text": "        # if self._trys is empty, we're not an in try block\n        if not self._trys:\n            return\n        # the node could be a grand-grand...-child of the 'try...finally'\n        _parent = node.parent\n        _node = node\n        while _parent and not isinstance(_parent, breaker_classes):\n",
                      "markdown": "`        # if self._trys is empty, we're not an in try block\n        if not self._trys:\n            return\n        # the node could be a grand-grand...-child of the 'try...finally'\n        _parent = node.parent\n        _node = node\n        while _parent and not isinstance(_parent, breaker_classes):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 809,
                  "startColumn": 13,
                  "endLine": 809,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        \"\"\"Check that a node is not inside a 'finally' clause of a\n        'try...finally' statement.\n\n        If we find a parent which type is in breaker_classes before\n        a 'try...finally' block we skip the whole check.\n        \"\"\"\n        # if self._trys is empty, we're not an in try block\n",
                    "rendered": {
                      "text": "        \"\"\"Check that a node is not inside a 'finally' clause of a\n        'try...finally' statement.\n\n        If we find a parent which type is in breaker_classes before\n        a 'try...finally' block we skip the whole check.\n        \"\"\"\n        # if self._trys is empty, we're not an in try block\n",
                      "markdown": "`        \"\"\"Check that a node is not inside a 'finally' clause of a\n        'try...finally' statement.\n\n        If we find a parent which type is in breaker_classes before\n        a 'try...finally' block we skip the whole check.\n        \"\"\"\n        # if self._trys is empty, we're not an in try block\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 806,
                  "startColumn": 23,
                  "endLine": 806,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        node_name: str,\n        breaker_classes: tuple[nodes.NodeNG, ...] = (),\n    ) -> None:\n        \"\"\"Check that a node is not inside a 'finally' clause of a\n        'try...finally' statement.\n\n        If we find a parent which type is in breaker_classes before\n",
                    "rendered": {
                      "text": "        node_name: str,\n        breaker_classes: tuple[nodes.NodeNG, ...] = (),\n    ) -> None:\n        \"\"\"Check that a node is not inside a 'finally' clause of a\n        'try...finally' statement.\n\n        If we find a parent which type is in breaker_classes before\n",
                      "markdown": "`        node_name: str,\n        breaker_classes: tuple[nodes.NodeNG, ...] = (),\n    ) -> None:\n        \"\"\"Check that a node is not inside a 'finally' clause of a\n        'try...finally' statement.\n\n        If we find a parent which type is in breaker_classes before\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 673,
                  "startColumn": 23,
                  "endLine": 673,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n    @utils.only_required_for_messages(\"unreachable\")\n    def visit_raise(self, node: nodes.Raise) -> None:\n        \"\"\"Check if the node has a right sibling (if so, that's some unreachable\n        code).\n        \"\"\"\n        self._check_unreachable(node)\n",
                    "rendered": {
                      "text": "\n    @utils.only_required_for_messages(\"unreachable\")\n    def visit_raise(self, node: nodes.Raise) -> None:\n        \"\"\"Check if the node has a right sibling (if so, that's some unreachable\n        code).\n        \"\"\"\n        self._check_unreachable(node)\n",
                      "markdown": "`\n    @utils.only_required_for_messages(\"unreachable\")\n    def visit_raise(self, node: nodes.Raise) -> None:\n        \"\"\"Check if the node has a right sibling (if so, that's some unreachable\n        code).\n        \"\"\"\n        self._check_unreachable(node)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 663,
                  "startColumn": 24,
                  "endLine": 663,
                  "endColumn": 30,
                  "snippet": {
                    "text": "\n        1 - check if the node has a right sibling (if so, that's some\n        unreachable code)\n        2 - check if the node is inside the 'finally' clause of a 'try...finally'\n        block\n        \"\"\"\n        # 1 - Is it right sibling ?\n",
                    "rendered": {
                      "text": "\n        1 - check if the node has a right sibling (if so, that's some\n        unreachable code)\n        2 - check if the node is inside the 'finally' clause of a 'try...finally'\n        block\n        \"\"\"\n        # 1 - Is it right sibling ?\n",
                      "markdown": "`\n        1 - check if the node has a right sibling (if so, that's some\n        unreachable code)\n        2 - check if the node is inside the 'finally' clause of a 'try...finally'\n        block\n        \"\"\"\n        # 1 - Is it right sibling ?\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 661,
                  "startColumn": 24,
                  "endLine": 661,
                  "endColumn": 30,
                  "snippet": {
                    "text": "    def visit_break(self, node: nodes.Break) -> None:\n        \"\"\"Break node visitor.\n\n        1 - check if the node has a right sibling (if so, that's some\n        unreachable code)\n        2 - check if the node is inside the 'finally' clause of a 'try...finally'\n        block\n",
                    "rendered": {
                      "text": "    def visit_break(self, node: nodes.Break) -> None:\n        \"\"\"Break node visitor.\n\n        1 - check if the node has a right sibling (if so, that's some\n        unreachable code)\n        2 - check if the node is inside the 'finally' clause of a 'try...finally'\n        block\n",
                      "markdown": "`    def visit_break(self, node: nodes.Break) -> None:\n        \"\"\"Break node visitor.\n\n        1 - check if the node has a right sibling (if so, that's some\n        unreachable code)\n        2 - check if the node is inside the 'finally' clause of a 'try...finally'\n        block\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 659,
                  "startColumn": 16,
                  "endLine": 659,
                  "endColumn": 22,
                  "snippet": {
                    "text": "\n    @utils.only_required_for_messages(\"unreachable\", \"lost-exception\")\n    def visit_break(self, node: nodes.Break) -> None:\n        \"\"\"Break node visitor.\n\n        1 - check if the node has a right sibling (if so, that's some\n        unreachable code)\n",
                    "rendered": {
                      "text": "\n    @utils.only_required_for_messages(\"unreachable\", \"lost-exception\")\n    def visit_break(self, node: nodes.Break) -> None:\n        \"\"\"Break node visitor.\n\n        1 - check if the node has a right sibling (if so, that's some\n        unreachable code)\n",
                      "markdown": "`\n    @utils.only_required_for_messages(\"unreachable\", \"lost-exception\")\n    def visit_break(self, node: nodes.Break) -> None:\n        \"\"\"Break node visitor.\n\n        1 - check if the node has a right sibling (if so, that's some\n        unreachable code)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 652,
                  "startColumn": 23,
                  "endLine": 652,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n    @utils.only_required_for_messages(\"unreachable\")\n    def visit_continue(self, node: nodes.Continue) -> None:\n        \"\"\"Check is the node has a right sibling (if so, that's some unreachable\n        code).\n        \"\"\"\n        self._check_unreachable(node)\n",
                    "rendered": {
                      "text": "\n    @utils.only_required_for_messages(\"unreachable\")\n    def visit_continue(self, node: nodes.Continue) -> None:\n        \"\"\"Check is the node has a right sibling (if so, that's some unreachable\n        code).\n        \"\"\"\n        self._check_unreachable(node)\n",
                      "markdown": "`\n    @utils.only_required_for_messages(\"unreachable\")\n    def visit_continue(self, node: nodes.Continue) -> None:\n        \"\"\"Check is the node has a right sibling (if so, that's some unreachable\n        code).\n        \"\"\"\n        self._check_unreachable(node)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 643,
                  "startColumn": 24,
                  "endLine": 643,
                  "endColumn": 30,
                  "snippet": {
                    "text": "\n        1 - check if the node has a right sibling (if so, that's some\n        unreachable code)\n        2 - check if the node is inside the 'finally' clause of a 'try...finally'\n        block\n        \"\"\"\n        self._check_unreachable(node)\n",
                    "rendered": {
                      "text": "\n        1 - check if the node has a right sibling (if so, that's some\n        unreachable code)\n        2 - check if the node is inside the 'finally' clause of a 'try...finally'\n        block\n        \"\"\"\n        self._check_unreachable(node)\n",
                      "markdown": "`\n        1 - check if the node has a right sibling (if so, that's some\n        unreachable code)\n        2 - check if the node is inside the 'finally' clause of a 'try...finally'\n        block\n        \"\"\"\n        self._check_unreachable(node)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 641,
                  "startColumn": 24,
                  "endLine": 641,
                  "endColumn": 30,
                  "snippet": {
                    "text": "    def visit_return(self, node: nodes.Return) -> None:\n        \"\"\"Return node visitor.\n\n        1 - check if the node has a right sibling (if so, that's some\n        unreachable code)\n        2 - check if the node is inside the 'finally' clause of a 'try...finally'\n        block\n",
                    "rendered": {
                      "text": "    def visit_return(self, node: nodes.Return) -> None:\n        \"\"\"Return node visitor.\n\n        1 - check if the node has a right sibling (if so, that's some\n        unreachable code)\n        2 - check if the node is inside the 'finally' clause of a 'try...finally'\n        block\n",
                      "markdown": "`    def visit_return(self, node: nodes.Return) -> None:\n        \"\"\"Return node visitor.\n\n        1 - check if the node has a right sibling (if so, that's some\n        unreachable code)\n        2 - check if the node is inside the 'finally' clause of a 'try...finally'\n        block\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 639,
                  "startColumn": 17,
                  "endLine": 639,
                  "endColumn": 23,
                  "snippet": {
                    "text": "\n    @utils.only_required_for_messages(\"unreachable\", \"lost-exception\")\n    def visit_return(self, node: nodes.Return) -> None:\n        \"\"\"Return node visitor.\n\n        1 - check if the node has a right sibling (if so, that's some\n        unreachable code)\n",
                    "rendered": {
                      "text": "\n    @utils.only_required_for_messages(\"unreachable\", \"lost-exception\")\n    def visit_return(self, node: nodes.Return) -> None:\n        \"\"\"Return node visitor.\n\n        1 - check if the node has a right sibling (if so, that's some\n        unreachable code)\n",
                      "markdown": "`\n    @utils.only_required_for_messages(\"unreachable\", \"lost-exception\")\n    def visit_return(self, node: nodes.Return) -> None:\n        \"\"\"Return node visitor.\n\n        1 - check if the node has a right sibling (if so, that's some\n        unreachable code)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 621,
                  "startColumn": 37,
                  "endLine": 621,
                  "endColumn": 43,
                  "snippet": {
                    "text": "                elif isinstance(value, astroid.Instance) or is_iterable(value):\n                    # We are here in the following situation(s):\n                    #   * a dict/set/list/tuple call which wasn't inferred\n                    #     to a syntax node ({}, () etc.). This can happen\n                    #     when the arguments are invalid or unknown to\n                    #     the inference.\n                    #   * a variable from somewhere else, which turns out to be a list\n",
                    "rendered": {
                      "text": "                elif isinstance(value, astroid.Instance) or is_iterable(value):\n                    # We are here in the following situation(s):\n                    #   * a dict/set/list/tuple call which wasn't inferred\n                    #     to a syntax node ({}, () etc.). This can happen\n                    #     when the arguments are invalid or unknown to\n                    #     the inference.\n                    #   * a variable from somewhere else, which turns out to be a list\n",
                      "markdown": "`                elif isinstance(value, astroid.Instance) or is_iterable(value):\n                    # We are here in the following situation(s):\n                    #   * a dict/set/list/tuple call which wasn't inferred\n                    #     to a syntax node ({}, () etc.). This can happen\n                    #     when the arguments are invalid or unknown to\n                    #     the inference.\n                    #   * a variable from somewhere else, which turns out to be a list\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 364,
                  "startColumn": 29,
                  "endLine": 364,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        if emit:\n            self.add_message(\"using-constant-test\", node=test, confidence=INFERENCE)\n        elif isinstance(inferred, const_nodes):\n            # If the constant node is a FunctionDef or Lambda then\n            # it may be an illicit function call due to missing parentheses\n            call_inferred = None\n            try:\n",
                    "rendered": {
                      "text": "        if emit:\n            self.add_message(\"using-constant-test\", node=test, confidence=INFERENCE)\n        elif isinstance(inferred, const_nodes):\n            # If the constant node is a FunctionDef or Lambda then\n            # it may be an illicit function call due to missing parentheses\n            call_inferred = None\n            try:\n",
                      "markdown": "`        if emit:\n            self.add_message(\"using-constant-test\", node=test, confidence=INFERENCE)\n        elif isinstance(inferred, const_nodes):\n            # If the constant node is a FunctionDef or Lambda then\n            # it may be an illicit function call due to missing parentheses\n            call_inferred = None\n            try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/checkers/base/basic_checker.py"
                },
                "region": {
                  "startLine": 198,
                  "startColumn": 67,
                  "endLine": 198,
                  "endColumn": 73,
                  "snippet": {
                    "text": "            \"Emitted when a `with` statement component returns multiple values \"\n            \"and uses name binding with `as` only for a part of those values, \"\n            \"as in with ctx() as a, b. This can be misleading, since it's not \"\n            \"clear if the context manager returns a tuple or if the node without \"\n            \"a name binding is another context manager.\",\n        ),\n        \"W0125\": (\n",
                    "rendered": {
                      "text": "            \"Emitted when a `with` statement component returns multiple values \"\n            \"and uses name binding with `as` only for a part of those values, \"\n            \"as in with ctx() as a, b. This can be misleading, since it's not \"\n            \"clear if the context manager returns a tuple or if the node without \"\n            \"a name binding is another context manager.\",\n        ),\n        \"W0125\": (\n",
                      "markdown": "`            \"Emitted when a `with` statement component returns multiple values \"\n            \"and uses name binding with `as` only for a part of those values, \"\n            \"as in with ctx() as a, b. This can be misleading, since it's not \"\n            \"clear if the context manager returns a tuple or if the node without \"\n            \"a name binding is another context manager.\",\n        ),\n        \"W0125\": (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/__init__.py"
                },
                "region": {
                  "startLine": 91,
                  "startColumn": 31,
                  "endLine": 91,
                  "endColumn": 36,
                  "snippet": {
                    "text": "    cwd = os.getcwd()\n    if sys.path[0] in (\"\", \".\", cwd):\n        sys.path.pop(0)\n    env_pythonpath = os.environ.get(\"PYTHONPATH\", \"\")\n    if env_pythonpath.startswith(\":\") and env_pythonpath not in (f\":{cwd}\", \":.\"):\n        sys.path.pop(0)\n    elif env_pythonpath.endswith(\":\") and env_pythonpath not in (f\"{cwd}:\", \".:\"):\n",
                    "rendered": {
                      "text": "    cwd = os.getcwd()\n    if sys.path[0] in (\"\", \".\", cwd):\n        sys.path.pop(0)\n    env_pythonpath = os.environ.get(\"PYTHONPATH\", \"\")\n    if env_pythonpath.startswith(\":\") and env_pythonpath not in (f\":{cwd}\", \":.\"):\n        sys.path.pop(0)\n    elif env_pythonpath.endswith(\":\") and env_pythonpath not in (f\"{cwd}:\", \".:\"):\n",
                      "markdown": "`    cwd = os.getcwd()\n    if sys.path[0] in (\"\", \".\", cwd):\n        sys.path.pop(0)\n    env_pythonpath = os.environ.get(\"PYTHONPATH\", \"\")\n    if env_pythonpath.startswith(\":\") and env_pythonpath not in (f\":{cwd}\", \":.\"):\n        sys.path.pop(0)\n    elif env_pythonpath.endswith(\":\") and env_pythonpath not in (f\"{cwd}:\", \".:\"):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/__init__.py"
                },
                "region": {
                  "startLine": 91,
                  "startColumn": 4,
                  "endLine": 91,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    cwd = os.getcwd()\n    if sys.path[0] in (\"\", \".\", cwd):\n        sys.path.pop(0)\n    env_pythonpath = os.environ.get(\"PYTHONPATH\", \"\")\n    if env_pythonpath.startswith(\":\") and env_pythonpath not in (f\":{cwd}\", \":.\"):\n        sys.path.pop(0)\n    elif env_pythonpath.endswith(\":\") and env_pythonpath not in (f\"{cwd}:\", \".:\"):\n",
                    "rendered": {
                      "text": "    cwd = os.getcwd()\n    if sys.path[0] in (\"\", \".\", cwd):\n        sys.path.pop(0)\n    env_pythonpath = os.environ.get(\"PYTHONPATH\", \"\")\n    if env_pythonpath.startswith(\":\") and env_pythonpath not in (f\":{cwd}\", \":.\"):\n        sys.path.pop(0)\n    elif env_pythonpath.endswith(\":\") and env_pythonpath not in (f\"{cwd}:\", \".:\"):\n",
                      "markdown": "`    cwd = os.getcwd()\n    if sys.path[0] in (\"\", \".\", cwd):\n        sys.path.pop(0)\n    env_pythonpath = os.environ.get(\"PYTHONPATH\", \"\")\n    if env_pythonpath.startswith(\":\") and env_pythonpath not in (f\":{cwd}\", \":.\"):\n        sys.path.pop(0)\n    elif env_pythonpath.endswith(\":\") and env_pythonpath not in (f\"{cwd}:\", \".:\"):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/pylint-3.3.1-r0.apk/pylint-3.3.1-r0/usr/lib/python3.12/site-packages/pylint/__init__.py"
                },
                "region": {
                  "startLine": 80,
                  "startColumn": 34,
                  "endLine": 80,
                  "endColumn": 38,
                  "snippet": {
                    "text": "\n    - Remove the first entry. This will always be either \"\" or the working directory\n    - Remove the working directory from the second and third entries\n      if PYTHONPATH includes a \":\" at the beginning or the end.\n      https://github.com/pylint-dev/pylint/issues/3636\n      Don't remove it if PYTHONPATH contains the cwd or '.' as the entry will\n      only be added once.\n",
                    "rendered": {
                      "text": "\n    - Remove the first entry. This will always be either \"\" or the working directory\n    - Remove the working directory from the second and third entries\n      if PYTHONPATH includes a \":\" at the beginning or the end.\n      https://github.com/pylint-dev/pylint/issues/3636\n      Don't remove it if PYTHONPATH contains the cwd or '.' as the entry will\n      only be added once.\n",
                      "markdown": "`\n    - Remove the first entry. This will always be either \"\" or the working directory\n    - Remove the working directory from the second and third entries\n      if PYTHONPATH includes a \":\" at the beginning or the end.\n      https://github.com/pylint-dev/pylint/issues/3636\n      Don't remove it if PYTHONPATH contains the cwd or '.' as the entry will\n      only be added once.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        }
      ],
      "columnKind": "utf16CodeUnits"
    }
  ]
}