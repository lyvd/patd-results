{
  "$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.6.json",
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "oss-detect-backdoor",
          "organization": "Microsoft Corporation",
          "product": "OSSGadget (https://github.com/Microsoft/OSSGadget)",
          "version": "0.0.0+ed0e2cfe6a"
        }
      },
      "results": [
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_cli.py"
                },
                "region": {
                  "startLine": 248,
                  "startColumn": 21,
                  "endLine": 248,
                  "endColumn": 26,
                  "snippet": {
                    "text": "            message = sanitize_output(ex.stderr)\n        else:\n            message = \"Failed to invoke Azure CLI\"\n        if within_dac.get():\n            raise CredentialUnavailableError(message=message) from ex\n        raise ClientAuthenticationError(message=message) from ex\n    except OSError as ex:\n",
                    "rendered": {
                      "text": "            message = sanitize_output(ex.stderr)\n        else:\n            message = \"Failed to invoke Azure CLI\"\n        if within_dac.get():\n            raise CredentialUnavailableError(message=message) from ex\n        raise ClientAuthenticationError(message=message) from ex\n    except OSError as ex:\n",
                      "markdown": "`            message = sanitize_output(ex.stderr)\n        else:\n            message = \"Failed to invoke Azure CLI\"\n        if within_dac.get():\n            raise CredentialUnavailableError(message=message) from ex\n        raise ClientAuthenticationError(message=message) from ex\n    except OSError as ex:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_cli.py"
                },
                "region": {
                  "startLine": 196,
                  "startColumn": 25,
                  "endLine": 196,
                  "endColumn": 30,
                  "snippet": {
                    "text": "    \"\"\"\n\n    if sys.platform.startswith(\"win\"):\n        path = os.environ.get(\"SYSTEMROOT\")\n        if not path:\n            raise CredentialUnavailableError(message=\"Environment variable 'SYSTEMROOT' has no value\")\n        return path\n",
                    "rendered": {
                      "text": "    \"\"\"\n\n    if sys.platform.startswith(\"win\"):\n        path = os.environ.get(\"SYSTEMROOT\")\n        if not path:\n            raise CredentialUnavailableError(message=\"Environment variable 'SYSTEMROOT' has no value\")\n        return path\n",
                      "markdown": "`    \"\"\"\n\n    if sys.platform.startswith(\"win\"):\n        path = os.environ.get(\"SYSTEMROOT\")\n        if not path:\n            raise CredentialUnavailableError(message=\"Environment variable 'SYSTEMROOT' has no value\")\n        return path\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_cli.py"
                },
                "region": {
                  "startLine": 157,
                  "startColumn": 25,
                  "endLine": 157,
                  "endColumn": 30,
                  "snippet": {
                    "text": "                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n                raise CredentialUnavailableError(message=message)\n            raise ClientAuthenticationError(message=message)\n\n",
                    "rendered": {
                      "text": "                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n                raise CredentialUnavailableError(message=message)\n            raise ClientAuthenticationError(message=message)\n\n",
                      "markdown": "`                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n                raise CredentialUnavailableError(message=message)\n            raise ClientAuthenticationError(message=message)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_cli.py"
                },
                "region": {
                  "startLine": 131,
                  "startColumn": 27,
                  "endLine": 131,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        self, *scopes: str, options: Optional[TokenRequestOptions] = None, **kwargs: Any\n    ) -> AccessTokenInfo:\n\n        tenant_id = options.get(\"tenant_id\") if options else None\n        if tenant_id:\n            validate_tenant_id(tenant_id)\n        for scope in scopes:\n",
                    "rendered": {
                      "text": "        self, *scopes: str, options: Optional[TokenRequestOptions] = None, **kwargs: Any\n    ) -> AccessTokenInfo:\n\n        tenant_id = options.get(\"tenant_id\") if options else None\n        if tenant_id:\n            validate_tenant_id(tenant_id)\n        for scope in scopes:\n",
                      "markdown": "`        self, *scopes: str, options: Optional[TokenRequestOptions] = None, **kwargs: Any\n    ) -> AccessTokenInfo:\n\n        tenant_id = options.get(\"tenant_id\") if options else None\n        if tenant_id:\n            validate_tenant_id(tenant_id)\n        for scope in scopes:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_cli.py"
                },
                "region": {
                  "startLine": 196,
                  "startColumn": 18,
                  "endLine": 196,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    \"\"\"\n\n    if sys.platform.startswith(\"win\"):\n        path = os.environ.get(\"SYSTEMROOT\")\n        if not path:\n            raise CredentialUnavailableError(message=\"Environment variable 'SYSTEMROOT' has no value\")\n        return path\n",
                    "rendered": {
                      "text": "    \"\"\"\n\n    if sys.platform.startswith(\"win\"):\n        path = os.environ.get(\"SYSTEMROOT\")\n        if not path:\n            raise CredentialUnavailableError(message=\"Environment variable 'SYSTEMROOT' has no value\")\n        return path\n",
                      "markdown": "`    \"\"\"\n\n    if sys.platform.startswith(\"win\"):\n        path = os.environ.get(\"SYSTEMROOT\")\n        if not path:\n            raise CredentialUnavailableError(message=\"Environment variable 'SYSTEMROOT' has no value\")\n        return path\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_cli.py"
                },
                "region": {
                  "startLine": 154,
                  "startColumn": 93,
                  "endLine": 154,
                  "endColumn": 97,
                  "snippet": {
                    "text": "            sanitized_output = sanitize_output(output)\n            message = (\n                f\"Unexpected output from Azure CLI: '{sanitized_output}'. \\n\"\n                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n",
                    "rendered": {
                      "text": "            sanitized_output = sanitize_output(output)\n            message = (\n                f\"Unexpected output from Azure CLI: '{sanitized_output}'. \\n\"\n                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n",
                      "markdown": "`            sanitized_output = sanitize_output(output)\n            message = (\n                f\"Unexpected output from Azure CLI: '{sanitized_output}'. \\n\"\n                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1456,
                  "startColumn": 12,
                  "endLine": 1456,
                  "endColumn": 20,
                  "snippet": {
                    "text": "- Added credentials for authenticating users:\n - `DeviceCodeCredential`\n - `InteractiveBrowserCredential`\n - `UsernamePasswordCredential`\n  - async versions of these credentials will be added in a future release\n\n## 1.0.0b1 (2019-06-28)\n",
                    "rendered": {
                      "text": "- Added credentials for authenticating users:\n - `DeviceCodeCredential`\n - `InteractiveBrowserCredential`\n - `UsernamePasswordCredential`\n  - async versions of these credentials will be added in a future release\n\n## 1.0.0b1 (2019-06-28)\n",
                      "markdown": "`- Added credentials for authenticating users:\n - `DeviceCodeCredential`\n - `InteractiveBrowserCredential`\n - `UsernamePasswordCredential`\n  - async versions of these credentials will be added in a future release\n\n## 1.0.0b1 (2019-06-28)\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1416,
                  "startColumn": 11,
                  "endLine": 1416,
                  "endColumn": 19,
                  "snippet": {
                    "text": "- Removed `client_secret` parameter from `InteractiveBrowserCredential`\n\n### Fixes and improvements:\n- `UsernamePasswordCredential` correctly handles environment configuration with\nno tenant information ([#7260](https://github.com/Azure/azure-sdk-for-python/pull/7260))\n- user realm discovery requests are sent through credential pipelines\n([#7260](https://github.com/Azure/azure-sdk-for-python/pull/7260))\n",
                    "rendered": {
                      "text": "- Removed `client_secret` parameter from `InteractiveBrowserCredential`\n\n### Fixes and improvements:\n- `UsernamePasswordCredential` correctly handles environment configuration with\nno tenant information ([#7260](https://github.com/Azure/azure-sdk-for-python/pull/7260))\n- user realm discovery requests are sent through credential pipelines\n([#7260](https://github.com/Azure/azure-sdk-for-python/pull/7260))\n",
                      "markdown": "`- Removed `client_secret` parameter from `InteractiveBrowserCredential`\n\n### Fixes and improvements:\n- `UsernamePasswordCredential` correctly handles environment configuration with\nno tenant information ([#7260](https://github.com/Azure/azure-sdk-for-python/pull/7260))\n- user realm discovery requests are sent through credential pipelines\n([#7260](https://github.com/Azure/azure-sdk-for-python/pull/7260))\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1319,
                  "startColumn": 35,
                  "endLine": 1319,
                  "endColumn": 43,
                  "snippet": {
                    "text": "- Credentials raise `CredentialUnavailableError` when they can't attempt to\nauthenticate due to missing data or state\n([#9372](https://github.com/Azure/azure-sdk-for-python/pull/9372))\n- `CertificateCredential` supports password-protected private keys\n([#9434](https://github.com/Azure/azure-sdk-for-python/pull/9434))\n\n\n",
                    "rendered": {
                      "text": "- Credentials raise `CredentialUnavailableError` when they can't attempt to\nauthenticate due to missing data or state\n([#9372](https://github.com/Azure/azure-sdk-for-python/pull/9372))\n- `CertificateCredential` supports password-protected private keys\n([#9434](https://github.com/Azure/azure-sdk-for-python/pull/9434))\n\n\n",
                      "markdown": "`- Credentials raise `CredentialUnavailableError` when they can't attempt to\nauthenticate due to missing data or state\n([#9372](https://github.com/Azure/azure-sdk-for-python/pull/9372))\n- `CertificateCredential` supports password-protected private keys\n([#9434](https://github.com/Azure/azure-sdk-for-python/pull/9434))\n\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1251,
                  "startColumn": 57,
                  "endLine": 1251,
                  "endColumn": 65,
                  "snippet": {
                    "text": "    keyword argument `allow_unencrypted_cache=True`.\n\n## 1.4.0b3 (2020-05-04)\n- `EnvironmentCredential` correctly initializes `UsernamePasswordCredential`\nwith the value of `AZURE_TENANT_ID`\n([#11127](https://github.com/Azure/azure-sdk-for-python/pull/11127))\n- Values for the constructor keyword argument `authority` and\n",
                    "rendered": {
                      "text": "    keyword argument `allow_unencrypted_cache=True`.\n\n## 1.4.0b3 (2020-05-04)\n- `EnvironmentCredential` correctly initializes `UsernamePasswordCredential`\nwith the value of `AZURE_TENANT_ID`\n([#11127](https://github.com/Azure/azure-sdk-for-python/pull/11127))\n- Values for the constructor keyword argument `authority` and\n",
                      "markdown": "`    keyword argument `allow_unencrypted_cache=True`.\n\n## 1.4.0b3 (2020-05-04)\n- `EnvironmentCredential` correctly initializes `UsernamePasswordCredential`\nwith the value of `AZURE_TENANT_ID`\n([#11127](https://github.com/Azure/azure-sdk-for-python/pull/11127))\n- Values for the constructor keyword argument `authority` and\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1238,
                  "startColumn": 11,
                  "endLine": 1238,
                  "endColumn": 19,
                  "snippet": {
                    "text": "  ([#11448](https://github.com/Azure/azure-sdk-for-python/issues/11448))\n- The user authentication API added to `DeviceCodeCredential` and\n  `InteractiveBrowserCredential` in 1.4.0b3 is available on\n  `UsernamePasswordCredential` as well.\n  ([#11449](https://github.com/Azure/azure-sdk-for-python/issues/11449))\n- The optional persistent cache for `DeviceCodeCredential` and\n  `InteractiveBrowserCredential` added in 1.4.0b3 is now available on Linux and\n",
                    "rendered": {
                      "text": "  ([#11448](https://github.com/Azure/azure-sdk-for-python/issues/11448))\n- The user authentication API added to `DeviceCodeCredential` and\n  `InteractiveBrowserCredential` in 1.4.0b3 is available on\n  `UsernamePasswordCredential` as well.\n  ([#11449](https://github.com/Azure/azure-sdk-for-python/issues/11449))\n- The optional persistent cache for `DeviceCodeCredential` and\n  `InteractiveBrowserCredential` added in 1.4.0b3 is now available on Linux and\n",
                      "markdown": "`  ([#11448](https://github.com/Azure/azure-sdk-for-python/issues/11448))\n- The user authentication API added to `DeviceCodeCredential` and\n  `InteractiveBrowserCredential` in 1.4.0b3 is available on\n  `UsernamePasswordCredential` as well.\n  ([#11449](https://github.com/Azure/azure-sdk-for-python/issues/11449))\n- The optional persistent cache for `DeviceCodeCredential` and\n  `InteractiveBrowserCredential` added in 1.4.0b3 is now available on Linux and\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1165,
                  "startColumn": 13,
                  "endLine": 1165,
                  "endColumn": 21,
                  "snippet": {
                    "text": "  - Removed `allow_unencrypted_cache` and `enable_persistent_cache` keyword\n    arguments from `CertificateCredential`, `ClientSecretCredential`,\n    `DeviceCodeCredential`, `InteractiveBrowserCredential`, and\n    `UsernamePasswordCredential`\n  - Removed `disable_automatic_authentication` keyword argument from\n    `DeviceCodeCredential` and `InteractiveBrowserCredential`\n  - Removed `allow_unencrypted_cache` keyword argument from\n",
                    "rendered": {
                      "text": "  - Removed `allow_unencrypted_cache` and `enable_persistent_cache` keyword\n    arguments from `CertificateCredential`, `ClientSecretCredential`,\n    `DeviceCodeCredential`, `InteractiveBrowserCredential`, and\n    `UsernamePasswordCredential`\n  - Removed `disable_automatic_authentication` keyword argument from\n    `DeviceCodeCredential` and `InteractiveBrowserCredential`\n  - Removed `allow_unencrypted_cache` keyword argument from\n",
                      "markdown": "`  - Removed `allow_unencrypted_cache` and `enable_persistent_cache` keyword\n    arguments from `CertificateCredential`, `ClientSecretCredential`,\n    `DeviceCodeCredential`, `InteractiveBrowserCredential`, and\n    `UsernamePasswordCredential`\n  - Removed `disable_automatic_authentication` keyword argument from\n    `DeviceCodeCredential` and `InteractiveBrowserCredential`\n  - Removed `allow_unencrypted_cache` keyword argument from\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1161,
                  "startColumn": 49,
                  "endLine": 1161,
                  "endColumn": 57,
                  "snippet": {
                    "text": "  will be reintroduced in 1.5.0b1. Passing the keyword arguments below\n  generally won't cause a runtime error, but the arguments have no effect.\n  - Removed `authenticate` method from `DeviceCodeCredential`,\n    `InteractiveBrowserCredential`, and `UsernamePasswordCredential`\n  - Removed `allow_unencrypted_cache` and `enable_persistent_cache` keyword\n    arguments from `CertificateCredential`, `ClientSecretCredential`,\n    `DeviceCodeCredential`, `InteractiveBrowserCredential`, and\n",
                    "rendered": {
                      "text": "  will be reintroduced in 1.5.0b1. Passing the keyword arguments below\n  generally won't cause a runtime error, but the arguments have no effect.\n  - Removed `authenticate` method from `DeviceCodeCredential`,\n    `InteractiveBrowserCredential`, and `UsernamePasswordCredential`\n  - Removed `allow_unencrypted_cache` and `enable_persistent_cache` keyword\n    arguments from `CertificateCredential`, `ClientSecretCredential`,\n    `DeviceCodeCredential`, `InteractiveBrowserCredential`, and\n",
                      "markdown": "`  will be reintroduced in 1.5.0b1. Passing the keyword arguments below\n  generally won't cause a runtime error, but the arguments have no effect.\n  - Removed `authenticate` method from `DeviceCodeCredential`,\n    `InteractiveBrowserCredential`, and `UsernamePasswordCredential`\n  - Removed `allow_unencrypted_cache` and `enable_persistent_cache` keyword\n    arguments from `CertificateCredential`, `ClientSecretCredential`,\n    `DeviceCodeCredential`, `InteractiveBrowserCredential`, and\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1068,
                  "startColumn": 13,
                  "endLine": 1068,
                  "endColumn": 21,
                  "snippet": {
                    "text": "  - Removed `allow_unencrypted_cache` and `enable_persistent_cache` keyword\n    arguments from `CertificateCredential`, `ClientSecretCredential`,\n    `DeviceCodeCredential`, `InteractiveBrowserCredential`, and\n    `UsernamePasswordCredential`\n  - Removed `disable_automatic_authentication` keyword argument from\n    `DeviceCodeCredential` and `InteractiveBrowserCredential`\n  - Removed `allow_unencrypted_cache` keyword argument from\n",
                    "rendered": {
                      "text": "  - Removed `allow_unencrypted_cache` and `enable_persistent_cache` keyword\n    arguments from `CertificateCredential`, `ClientSecretCredential`,\n    `DeviceCodeCredential`, `InteractiveBrowserCredential`, and\n    `UsernamePasswordCredential`\n  - Removed `disable_automatic_authentication` keyword argument from\n    `DeviceCodeCredential` and `InteractiveBrowserCredential`\n  - Removed `allow_unencrypted_cache` keyword argument from\n",
                      "markdown": "`  - Removed `allow_unencrypted_cache` and `enable_persistent_cache` keyword\n    arguments from `CertificateCredential`, `ClientSecretCredential`,\n    `DeviceCodeCredential`, `InteractiveBrowserCredential`, and\n    `UsernamePasswordCredential`\n  - Removed `disable_automatic_authentication` keyword argument from\n    `DeviceCodeCredential` and `InteractiveBrowserCredential`\n  - Removed `allow_unencrypted_cache` keyword argument from\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1064,
                  "startColumn": 49,
                  "endLine": 1064,
                  "endColumn": 57,
                  "snippet": {
                    "text": "  generally won't cause a runtime error, but the arguments have no effect.\n  ([#14601](https://github.com/Azure/azure-sdk-for-python/issues/14601))\n  - Removed `authenticate` method from `DeviceCodeCredential`,\n    `InteractiveBrowserCredential`, and `UsernamePasswordCredential`\n  - Removed `allow_unencrypted_cache` and `enable_persistent_cache` keyword\n    arguments from `CertificateCredential`, `ClientSecretCredential`,\n    `DeviceCodeCredential`, `InteractiveBrowserCredential`, and\n",
                    "rendered": {
                      "text": "  generally won't cause a runtime error, but the arguments have no effect.\n  ([#14601](https://github.com/Azure/azure-sdk-for-python/issues/14601))\n  - Removed `authenticate` method from `DeviceCodeCredential`,\n    `InteractiveBrowserCredential`, and `UsernamePasswordCredential`\n  - Removed `allow_unencrypted_cache` and `enable_persistent_cache` keyword\n    arguments from `CertificateCredential`, `ClientSecretCredential`,\n    `DeviceCodeCredential`, `InteractiveBrowserCredential`, and\n",
                      "markdown": "`  generally won't cause a runtime error, but the arguments have no effect.\n  ([#14601](https://github.com/Azure/azure-sdk-for-python/issues/14601))\n  - Removed `authenticate` method from `DeviceCodeCredential`,\n    `InteractiveBrowserCredential`, and `UsernamePasswordCredential`\n  - Removed `allow_unencrypted_cache` and `enable_persistent_cache` keyword\n    arguments from `CertificateCredential`, `ClientSecretCredential`,\n    `DeviceCodeCredential`, `InteractiveBrowserCredential`, and\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 848,
                  "startColumn": 13,
                  "endLine": 848,
                  "endColumn": 21,
                  "snippet": {
                    "text": "  - `InteractiveBrowserCredential`\n  - `DeviceCodeCredential`\n  - `EnvironmentCredential`\n  - `UsernamePasswordCredential`\n\n   it is ignored by other types of credentials.\n\n",
                    "rendered": {
                      "text": "  - `InteractiveBrowserCredential`\n  - `DeviceCodeCredential`\n  - `EnvironmentCredential`\n  - `UsernamePasswordCredential`\n\n   it is ignored by other types of credentials.\n\n",
                      "markdown": "`  - `InteractiveBrowserCredential`\n  - `DeviceCodeCredential`\n  - `EnvironmentCredential`\n  - `UsernamePasswordCredential`\n\n   it is ignored by other types of credentials.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 773,
                  "startColumn": 89,
                  "endLine": 773,
                  "endColumn": 97,
                  "snippet": {
                    "text": "\n### Features Added\n\n- `EnvironmentCredential` added `AZURE_CLIENT_CERTIFICATE_PASSWORD` support for the cert password    ([#24652](https://github.com/Azure/azure-sdk-for-python/issues/24652))\n\n### Bugs Fixed\n\n",
                    "rendered": {
                      "text": "\n### Features Added\n\n- `EnvironmentCredential` added `AZURE_CLIENT_CERTIFICATE_PASSWORD` support for the cert password    ([#24652](https://github.com/Azure/azure-sdk-for-python/issues/24652))\n\n### Bugs Fixed\n\n",
                      "markdown": "`\n### Features Added\n\n- `EnvironmentCredential` added `AZURE_CLIENT_CERTIFICATE_PASSWORD` support for the cert password    ([#24652](https://github.com/Azure/azure-sdk-for-python/issues/24652))\n\n### Bugs Fixed\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 773,
                  "startColumn": 58,
                  "endLine": 773,
                  "endColumn": 66,
                  "snippet": {
                    "text": "\n### Features Added\n\n- `EnvironmentCredential` added `AZURE_CLIENT_CERTIFICATE_PASSWORD` support for the cert password    ([#24652](https://github.com/Azure/azure-sdk-for-python/issues/24652))\n\n### Bugs Fixed\n\n",
                    "rendered": {
                      "text": "\n### Features Added\n\n- `EnvironmentCredential` added `AZURE_CLIENT_CERTIFICATE_PASSWORD` support for the cert password    ([#24652](https://github.com/Azure/azure-sdk-for-python/issues/24652))\n\n### Bugs Fixed\n\n",
                      "markdown": "`\n### Features Added\n\n- `EnvironmentCredential` added `AZURE_CLIENT_CERTIFICATE_PASSWORD` support for the cert password    ([#24652](https://github.com/Azure/azure-sdk-for-python/issues/24652))\n\n### Bugs Fixed\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 754,
                  "startColumn": 30,
                  "endLine": 754,
                  "endColumn": 38,
                  "snippet": {
                    "text": "- These beta features in 1.11.0b3 have been removed from this release and will be added back in 1.12.0b1\n  - `tenant_id` for `AzureCliCredential`\n  - removed `VisualStudioCodeCredential` from `DefaultAzureCredential` token chain\n  - `AZURE_CLIENT_CERTIFICATE_PASSWORD` support for `EnvironmentCredential`\n  - `validate_authority` support\n\n## 1.11.0b3 (2022-08-09)\n",
                    "rendered": {
                      "text": "- These beta features in 1.11.0b3 have been removed from this release and will be added back in 1.12.0b1\n  - `tenant_id` for `AzureCliCredential`\n  - removed `VisualStudioCodeCredential` from `DefaultAzureCredential` token chain\n  - `AZURE_CLIENT_CERTIFICATE_PASSWORD` support for `EnvironmentCredential`\n  - `validate_authority` support\n\n## 1.11.0b3 (2022-08-09)\n",
                      "markdown": "`- These beta features in 1.11.0b3 have been removed from this release and will be added back in 1.12.0b1\n  - `tenant_id` for `AzureCliCredential`\n  - removed `VisualStudioCodeCredential` from `DefaultAzureCredential` token chain\n  - `AZURE_CLIENT_CERTIFICATE_PASSWORD` support for `EnvironmentCredential`\n  - `validate_authority` support\n\n## 1.11.0b3 (2022-08-09)\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 742,
                  "startColumn": 13,
                  "endLine": 742,
                  "endColumn": 21,
                  "snippet": {
                    "text": "  - `ClientSecretCredential`\n  - `DefaultAzureCredential`\n  - `OnBehalfOfCredential`\n  - `UsernamePasswordCredential`\n  - `VisualStudioCodeCredential`\n\n### Breaking Changes\n",
                    "rendered": {
                      "text": "  - `ClientSecretCredential`\n  - `DefaultAzureCredential`\n  - `OnBehalfOfCredential`\n  - `UsernamePasswordCredential`\n  - `VisualStudioCodeCredential`\n\n### Breaking Changes\n",
                      "markdown": "`  - `ClientSecretCredential`\n  - `DefaultAzureCredential`\n  - `OnBehalfOfCredential`\n  - `UsernamePasswordCredential`\n  - `VisualStudioCodeCredential`\n\n### Breaking Changes\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 726,
                  "startColumn": 89,
                  "endLine": 726,
                  "endColumn": 97,
                  "snippet": {
                    "text": "ttps://github.com/Azure/azure-sdk-for-python/pull/25207))\n- Removed `VisualStudioCodeCredential` from `DefaultAzureCredential` token chain. ([#23249](https://github.com/Azure/azure-sdk-for-python/issues/23249))\n- `EnvironmentCredential` added `AZURE_CLIENT_CERTIFICATE_PASSWORD` support for the cert password    ([#24652](https://github.com/Azure/azure-sdk-for-python/issues/24652))\n- Added `validate_authority` support for msal client  ([#22625](https://github.com/Azure/azure-sdk-for-python/issues/22625))\n\n## 1.11.0 (2022-09-19)\n\n### Features Added\n\n- Added `additionally_allowed_tenants` to the following",
                    "rendered": {
                      "text": "ttps://github.com/Azure/azure-sdk-for-python/pull/25207))\n- Removed `VisualStudioCodeCredential` from `DefaultAzureCredential` token chain. ([#23249](https://github.com/Azure/azure-sdk-for-python/issues/23249))\n- `EnvironmentCredential` added `AZURE_CLIENT_CERTIFICATE_PASSWORD` support for the cert password    ([#24652](https://github.com/Azure/azure-sdk-for-python/issues/24652))\n- Added `validate_authority` support for msal client  ([#22625](https://github.com/Azure/azure-sdk-for-python/issues/22625))\n\n## 1.11.0 (2022-09-19)\n\n### Features Added\n\n- Added `additionally_allowed_tenants` to the following",
                      "markdown": "`ttps://github.com/Azure/azure-sdk-for-python/pull/25207))\n- Removed `VisualStudioCodeCredential` from `DefaultAzureCredential` token chain. ([#23249](https://github.com/Azure/azure-sdk-for-python/issues/23249))\n- `EnvironmentCredential` added `AZURE_CLIENT_CERTIFICATE_PASSWORD` support for the cert password    ([#24652](https://github.com/Azure/azure-sdk-for-python/issues/24652))\n- Added `validate_authority` support for msal client  ([#22625](https://github.com/Azure/azure-sdk-for-python/issues/22625))\n\n## 1.11.0 (2022-09-19)\n\n### Features Added\n\n- Added `additionally_allowed_tenants` to the following`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 726,
                  "startColumn": 58,
                  "endLine": 726,
                  "endColumn": 66,
                  "snippet": {
                    "text": "anks @tikicoder)    ([#25207](https://github.com/Azure/azure-sdk-for-python/pull/25207))\n- Removed `VisualStudioCodeCredential` from `DefaultAzureCredential` token chain. ([#23249](https://github.com/Azure/azure-sdk-for-python/issues/23249))\n- `EnvironmentCredential` added `AZURE_CLIENT_CERTIFICATE_PASSWORD` support for the cert password    ([#24652](https://github.com/Azure/azure-sdk-for-python/issues/24652))\n- Added `validate_authority` support for msal client  ([#22625](https://github.com/Azure/azure-sdk-for-python/issues/22625))\n\n## 1.11.0 (2022-09-19)\n\n### Features Added\n\n- Added `additionally_al",
                    "rendered": {
                      "text": "anks @tikicoder)    ([#25207](https://github.com/Azure/azure-sdk-for-python/pull/25207))\n- Removed `VisualStudioCodeCredential` from `DefaultAzureCredential` token chain. ([#23249](https://github.com/Azure/azure-sdk-for-python/issues/23249))\n- `EnvironmentCredential` added `AZURE_CLIENT_CERTIFICATE_PASSWORD` support for the cert password    ([#24652](https://github.com/Azure/azure-sdk-for-python/issues/24652))\n- Added `validate_authority` support for msal client  ([#22625](https://github.com/Azure/azure-sdk-for-python/issues/22625))\n\n## 1.11.0 (2022-09-19)\n\n### Features Added\n\n- Added `additionally_al",
                      "markdown": "`anks @tikicoder)    ([#25207](https://github.com/Azure/azure-sdk-for-python/pull/25207))\n- Removed `VisualStudioCodeCredential` from `DefaultAzureCredential` token chain. ([#23249](https://github.com/Azure/azure-sdk-for-python/issues/23249))\n- `EnvironmentCredential` added `AZURE_CLIENT_CERTIFICATE_PASSWORD` support for the cert password    ([#24652](https://github.com/Azure/azure-sdk-for-python/issues/24652))\n- Added `validate_authority` support for msal client  ([#22625](https://github.com/Azure/azure-sdk-for-python/issues/22625))\n\n## 1.11.0 (2022-09-19)\n\n### Features Added\n\n- Added `additionally_al`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 442,
                  "startColumn": 66,
                  "endLine": 442,
                  "endColumn": 74,
                  "snippet": {
                    "text": "ps://learn.microsoft.com/python/api/azure-core/azure.core.credentials.supportstokeninfo?view=azure-python\n[troubleshooting_guide]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/identity/azure-identity/TROUBLESHOOTING.md\n[userpass_cred_ref]: https://aka.ms/azsdk/python/identity/usernamepasswordcredential\n[vscode_cred_ref]: https://aka.ms/azsdk/python/identity/vscodecredential\n[workload_id_cred_ref]: https://aka.ms/azsdk/python/identity/workloadidentitycredential\n\n![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fsdk%2Fidentity%2Fazure-id",
                    "rendered": {
                      "text": "ps://learn.microsoft.com/python/api/azure-core/azure.core.credentials.supportstokeninfo?view=azure-python\n[troubleshooting_guide]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/identity/azure-identity/TROUBLESHOOTING.md\n[userpass_cred_ref]: https://aka.ms/azsdk/python/identity/usernamepasswordcredential\n[vscode_cred_ref]: https://aka.ms/azsdk/python/identity/vscodecredential\n[workload_id_cred_ref]: https://aka.ms/azsdk/python/identity/workloadidentitycredential\n\n![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fsdk%2Fidentity%2Fazure-id",
                      "markdown": "`ps://learn.microsoft.com/python/api/azure-core/azure.core.credentials.supportstokeninfo?view=azure-python\n[troubleshooting_guide]: https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/identity/azure-identity/TROUBLESHOOTING.md\n[userpass_cred_ref]: https://aka.ms/azsdk/python/identity/usernamepasswordcredential\n[vscode_cred_ref]: https://aka.ms/azsdk/python/identity/vscodecredential\n[workload_id_cred_ref]: https://aka.ms/azsdk/python/identity/workloadidentitycredential\n\n![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fsdk%2Fidentity%2Fazure-id`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 340,
                  "startColumn": 30,
                  "endLine": 340,
                  "endColumn": 38,
                  "snippet": {
                    "text": "|-|-\n|`AZURE_CLIENT_ID`|ID of a Microsoft Entra application\n|`AZURE_USERNAME`|a username (usually an email address)\n|`AZURE_PASSWORD`|that user's password\n\nConfiguration is attempted in the preceding order. For example, if values for a client secret and certificate are both present, the client secret is used.\n\n",
                    "rendered": {
                      "text": "|-|-\n|`AZURE_CLIENT_ID`|ID of a Microsoft Entra application\n|`AZURE_USERNAME`|a username (usually an email address)\n|`AZURE_PASSWORD`|that user's password\n\nConfiguration is attempted in the preceding order. For example, if values for a client secret and certificate are both present, the client secret is used.\n\n",
                      "markdown": "`|-|-\n|`AZURE_CLIENT_ID`|ID of a Microsoft Entra application\n|`AZURE_USERNAME`|a username (usually an email address)\n|`AZURE_PASSWORD`|that user's password\n\nConfiguration is attempted in the preceding order. For example, if values for a client secret and certificate are both present, the client secret is used.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 340,
                  "startColumn": 8,
                  "endLine": 340,
                  "endColumn": 16,
                  "snippet": {
                    "text": "|-|-\n|`AZURE_CLIENT_ID`|ID of a Microsoft Entra application\n|`AZURE_USERNAME`|a username (usually an email address)\n|`AZURE_PASSWORD`|that user's password\n\nConfiguration is attempted in the preceding order. For example, if values for a client secret and certificate are both present, the client secret is used.\n\n",
                    "rendered": {
                      "text": "|-|-\n|`AZURE_CLIENT_ID`|ID of a Microsoft Entra application\n|`AZURE_USERNAME`|a username (usually an email address)\n|`AZURE_PASSWORD`|that user's password\n\nConfiguration is attempted in the preceding order. For example, if values for a client secret and certificate are both present, the client secret is used.\n\n",
                      "markdown": "`|-|-\n|`AZURE_CLIENT_ID`|ID of a Microsoft Entra application\n|`AZURE_USERNAME`|a username (usually an email address)\n|`AZURE_PASSWORD`|that user's password\n\nConfiguration is attempted in the preceding order. For example, if values for a client secret and certificate are both present, the client secret is used.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 334,
                  "startColumn": 17,
                  "endLine": 334,
                  "endColumn": 25,
                  "snippet": {
                    "text": "|`AZURE_CLIENT_CERTIFICATE_PASSWORD`|password of the certificate file, if any|\n|`AZURE_CLIENT_SEND_CERTIFICATE_CHAIN`|If `True`, the credential sends the public certificate chain in the x5c header of each token request's JWT. This is required for Subject Name/Issuer (SNI) authentication. Defaults to False. There's a [known limitation](https://github.com/Azure/azure-sdk-for-python/issues/13349) that async SNI authentication isn't supported.|\n\n### Username and password\n\n|Variable name|Value\n|-|-\n",
                    "rendered": {
                      "text": "|`AZURE_CLIENT_CERTIFICATE_PASSWORD`|password of the certificate file, if any|\n|`AZURE_CLIENT_SEND_CERTIFICATE_CHAIN`|If `True`, the credential sends the public certificate chain in the x5c header of each token request's JWT. This is required for Subject Name/Issuer (SNI) authentication. Defaults to False. There's a [known limitation](https://github.com/Azure/azure-sdk-for-python/issues/13349) that async SNI authentication isn't supported.|\n\n### Username and password\n\n|Variable name|Value\n|-|-\n",
                      "markdown": "`|`AZURE_CLIENT_CERTIFICATE_PASSWORD`|password of the certificate file, if any|\n|`AZURE_CLIENT_SEND_CERTIFICATE_CHAIN`|If `True`, the credential sends the public certificate chain in the x5c header of each token request's JWT. This is required for Subject Name/Issuer (SNI) authentication. Defaults to False. There's a [known limitation](https://github.com/Azure/azure-sdk-for-python/issues/13349) that async SNI authentication isn't supported.|\n\n### Username and password\n\n|Variable name|Value\n|-|-\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 331,
                  "startColumn": 37,
                  "endLine": 331,
                  "endColumn": 45,
                  "snippet": {
                    "text": "e\n\n|Variable name|Value|Required\n|-|-|-\n|`AZURE_CLIENT_ID`|ID of a Microsoft Entra application|X\n|`AZURE_TENANT_ID`|ID of the application's Microsoft Entra tenant|X\n|`AZURE_CLIENT_CERTIFICATE_PATH`|path to a PEM or PKCS12 certificate file including private key|X\n|`AZURE_CLIENT_CERTIFICATE_PASSWORD`|password of the certificate file, if any|\n|`AZURE_CLIENT_SEND_CERTIFICATE_CHAIN`|If `True`, the credential sends the public certificate chain in the x5c header of each token request's JWT. This is required for Subject Name/Issuer (SNI) authentication. Defaults to False. There's a [known limitation](https://",
                    "rendered": {
                      "text": "e\n\n|Variable name|Value|Required\n|-|-|-\n|`AZURE_CLIENT_ID`|ID of a Microsoft Entra application|X\n|`AZURE_TENANT_ID`|ID of the application's Microsoft Entra tenant|X\n|`AZURE_CLIENT_CERTIFICATE_PATH`|path to a PEM or PKCS12 certificate file including private key|X\n|`AZURE_CLIENT_CERTIFICATE_PASSWORD`|password of the certificate file, if any|\n|`AZURE_CLIENT_SEND_CERTIFICATE_CHAIN`|If `True`, the credential sends the public certificate chain in the x5c header of each token request's JWT. This is required for Subject Name/Issuer (SNI) authentication. Defaults to False. There's a [known limitation](https://",
                      "markdown": "`e\n\n|Variable name|Value|Required\n|-|-|-\n|`AZURE_CLIENT_ID`|ID of a Microsoft Entra application|X\n|`AZURE_TENANT_ID`|ID of the application's Microsoft Entra tenant|X\n|`AZURE_CLIENT_CERTIFICATE_PATH`|path to a PEM or PKCS12 certificate file including private key|X\n|`AZURE_CLIENT_CERTIFICATE_PASSWORD`|password of the certificate file, if any|\n|`AZURE_CLIENT_SEND_CERTIFICATE_CHAIN`|If `True`, the credential sends the public certificate chain in the x5c header of each token request's JWT. This is required for Subject Name/Issuer (SNI) authentication. Defaults to False. There's a [known limitation](https://`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 331,
                  "startColumn": 27,
                  "endLine": 331,
                  "endColumn": 35,
                  "snippet": {
                    "text": "certificate\n\n|Variable name|Value|Required\n|-|-|-\n|`AZURE_CLIENT_ID`|ID of a Microsoft Entra application|X\n|`AZURE_TENANT_ID`|ID of the application's Microsoft Entra tenant|X\n|`AZURE_CLIENT_CERTIFICATE_PATH`|path to a PEM or PKCS12 certificate file including private key|X\n|`AZURE_CLIENT_CERTIFICATE_PASSWORD`|password of the certificate file, if any|\n|`AZURE_CLIENT_SEND_CERTIFICATE_CHAIN`|If `True`, the credential sends the public certificate chain in the x5c header of each token request's JWT. This is required for Subject Name/Issuer (SNI) authentication. Defaults to False. There's a [known limitation",
                    "rendered": {
                      "text": "certificate\n\n|Variable name|Value|Required\n|-|-|-\n|`AZURE_CLIENT_ID`|ID of a Microsoft Entra application|X\n|`AZURE_TENANT_ID`|ID of the application's Microsoft Entra tenant|X\n|`AZURE_CLIENT_CERTIFICATE_PATH`|path to a PEM or PKCS12 certificate file including private key|X\n|`AZURE_CLIENT_CERTIFICATE_PASSWORD`|password of the certificate file, if any|\n|`AZURE_CLIENT_SEND_CERTIFICATE_CHAIN`|If `True`, the credential sends the public certificate chain in the x5c header of each token request's JWT. This is required for Subject Name/Issuer (SNI) authentication. Defaults to False. There's a [known limitation",
                      "markdown": "`certificate\n\n|Variable name|Value|Required\n|-|-|-\n|`AZURE_CLIENT_ID`|ID of a Microsoft Entra application|X\n|`AZURE_TENANT_ID`|ID of the application's Microsoft Entra tenant|X\n|`AZURE_CLIENT_CERTIFICATE_PATH`|path to a PEM or PKCS12 certificate file including private key|X\n|`AZURE_CLIENT_CERTIFICATE_PASSWORD`|password of the certificate file, if any|\n|`AZURE_CLIENT_SEND_CERTIFICATE_CHAIN`|If `True`, the credential sends the public certificate chain in the x5c header of each token request's JWT. This is required for Subject Name/Issuer (SNI) authentication. Defaults to False. There's a [known limitation`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 300,
                  "startColumn": 162,
                  "endLine": 300,
                  "endColumn": 170,
                  "snippet": {
                    "text": "ough the request chain. | [On-behalf-of authentication](https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow)|\n|[`UsernamePasswordCredential`][userpass_cred_ref]| Authenticates a user with a username and password (doesn't support multifactor authentication). | [Username + password authentication](https://learn.microsoft.com/entra/identity-platform/v2-oauth-ropc)|\n\n### Authenticate via development tools\n\n|Credential|Usage|Reference\n|-|-|-\n|[`AzureCliCredential`][cli_cred_ref]| Authenticates in a development environment with the Azure CLI. | [Azure CLI authentication](https://",
                    "rendered": {
                      "text": "ough the request chain. | [On-behalf-of authentication](https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow)|\n|[`UsernamePasswordCredential`][userpass_cred_ref]| Authenticates a user with a username and password (doesn't support multifactor authentication). | [Username + password authentication](https://learn.microsoft.com/entra/identity-platform/v2-oauth-ropc)|\n\n### Authenticate via development tools\n\n|Credential|Usage|Reference\n|-|-|-\n|[`AzureCliCredential`][cli_cred_ref]| Authenticates in a development environment with the Azure CLI. | [Azure CLI authentication](https://",
                      "markdown": "`ough the request chain. | [On-behalf-of authentication](https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow)|\n|[`UsernamePasswordCredential`][userpass_cred_ref]| Authenticates a user with a username and password (doesn't support multifactor authentication). | [Username + password authentication](https://learn.microsoft.com/entra/identity-platform/v2-oauth-ropc)|\n\n### Authenticate via development tools\n\n|Credential|Usage|Reference\n|-|-|-\n|[`AzureCliCredential`][cli_cred_ref]| Authenticates in a development environment with the Azure CLI. | [Azure CLI authentication](https://`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 300,
                  "startColumn": 93,
                  "endLine": 300,
                  "endColumn": 101,
                  "snippet": {
                    "text": "cred_ref]| Propagates the delegated user identity and permissions through the request chain. | [On-behalf-of authentication](https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow)|\n|[`UsernamePasswordCredential`][userpass_cred_ref]| Authenticates a user with a username and password (doesn't support multifactor authentication). | [Username + password authentication](https://learn.microsoft.com/entra/identity-platform/v2-oauth-ropc)|\n\n### Authenticate via development tools\n\n|Credential|Usage|Reference\n|-|-|-\n|[`AzureCliCredential`][cli_cred_ref]| Authenticates in a development ",
                    "rendered": {
                      "text": "cred_ref]| Propagates the delegated user identity and permissions through the request chain. | [On-behalf-of authentication](https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow)|\n|[`UsernamePasswordCredential`][userpass_cred_ref]| Authenticates a user with a username and password (doesn't support multifactor authentication). | [Username + password authentication](https://learn.microsoft.com/entra/identity-platform/v2-oauth-ropc)|\n\n### Authenticate via development tools\n\n|Credential|Usage|Reference\n|-|-|-\n|[`AzureCliCredential`][cli_cred_ref]| Authenticates in a development ",
                      "markdown": "`cred_ref]| Propagates the delegated user identity and permissions through the request chain. | [On-behalf-of authentication](https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow)|\n|[`UsernamePasswordCredential`][userpass_cred_ref]| Authenticates a user with a username and password (doesn't support multifactor authentication). | [Username + password authentication](https://learn.microsoft.com/entra/identity-platform/v2-oauth-ropc)|\n\n### Authenticate via development tools\n\n|Credential|Usage|Reference\n|-|-|-\n|[`AzureCliCredential`][cli_cred_ref]| Authenticates in a development `"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 300,
                  "startColumn": 11,
                  "endLine": 300,
                  "endColumn": 19,
                  "snippet": {
                    "text": "use [`DeviceCodeCredential`][device_code_cred_ref].\n|[`OnBehalfOfCredential`][obo_cred_ref]| Propagates the delegated user identity and permissions through the request chain. | [On-behalf-of authentication](https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow)|\n|[`UsernamePasswordCredential`][userpass_cred_ref]| Authenticates a user with a username and password (doesn't support multifactor authentication). | [Username + password authentication](https://learn.microsoft.com/entra/identity-platform/v2-oauth-ropc)|\n\n### Authenticate via development tools\n\n|Credential|Usage|Refer",
                    "rendered": {
                      "text": "use [`DeviceCodeCredential`][device_code_cred_ref].\n|[`OnBehalfOfCredential`][obo_cred_ref]| Propagates the delegated user identity and permissions through the request chain. | [On-behalf-of authentication](https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow)|\n|[`UsernamePasswordCredential`][userpass_cred_ref]| Authenticates a user with a username and password (doesn't support multifactor authentication). | [Username + password authentication](https://learn.microsoft.com/entra/identity-platform/v2-oauth-ropc)|\n\n### Authenticate via development tools\n\n|Credential|Usage|Refer",
                      "markdown": "`use [`DeviceCodeCredential`][device_code_cred_ref].\n|[`OnBehalfOfCredential`][obo_cred_ref]| Propagates the delegated user identity and permissions through the request chain. | [On-behalf-of authentication](https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow)|\n|[`UsernamePasswordCredential`][userpass_cred_ref]| Authenticates a user with a username and password (doesn't support multifactor authentication). | [Username + password authentication](https://learn.microsoft.com/entra/identity-platform/v2-oauth-ropc)|\n\n### Authenticate via development tools\n\n|Credential|Usage|Refer`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 367,
                  "startColumn": 242,
                  "endLine": 367,
                  "endColumn": 291,
                  "snippet": {
                    "text": " diagnose various failure scenarios.\n\n### Error handling\n\nCredentials raise `CredentialUnavailableError` when they're unable to attempt authentication because they lack required data or state. For example, [EnvironmentCredential][environment_cred_ref] raises this exception when [its configuration](#environment-variables \"its configuration\") is incomplete.\n\nCredentials raise `azure.core.exceptions.ClientAuthenticationError` when they fail to authenticate. `ClientAuthenticationError` has a `message` attribute, which describes why authentication failed. When raised by `DefaultAzureCredential` or `ChainedTokenCredential`, the message collects er",
                    "rendered": {
                      "text": " diagnose various failure scenarios.\n\n### Error handling\n\nCredentials raise `CredentialUnavailableError` when they're unable to attempt authentication because they lack required data or state. For example, [EnvironmentCredential][environment_cred_ref] raises this exception when [its configuration](#environment-variables \"its configuration\") is incomplete.\n\nCredentials raise `azure.core.exceptions.ClientAuthenticationError` when they fail to authenticate. `ClientAuthenticationError` has a `message` attribute, which describes why authentication failed. When raised by `DefaultAzureCredential` or `ChainedTokenCredential`, the message collects er",
                      "markdown": "` diagnose various failure scenarios.\n\n### Error handling\n\nCredentials raise `CredentialUnavailableError` when they're unable to attempt authentication because they lack required data or state. For example, [EnvironmentCredential][environment_cred_ref] raises this exception when [its configuration](#environment-variables \"its configuration\") is incomplete.\n\nCredentials raise `azure.core.exceptions.ClientAuthenticationError` when they fail to authenticate. `ClientAuthenticationError` has a `message` attribute, which describes why authentication failed. When raised by `DefaultAzureCredential` or `ChainedTokenCredential`, the message collects er`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 279,
                  "startColumn": 27,
                  "endLine": 279,
                  "endColumn": 79,
                  "snippet": {
                    "text": "\n|Credential|Usage\n|-|-\n|[`EnvironmentCredential`][environment_cred_ref]| Authenticates a service principal or user via credential information specified in environment variables.\n|[`ManagedIdentityCredential`][managed_id_cred_ref]| Authenticates the managed identity of an Azure resource.\n|[`WorkloadIdentityCredential`][workload_id_cred_ref]| Supports [Microsoft Entra Workload ID](https://learn.microsoft.com/azure/aks/workload-identity-overview) on Kubernetes.\n\n",
                    "rendered": {
                      "text": "\n|Credential|Usage\n|-|-\n|[`EnvironmentCredential`][environment_cred_ref]| Authenticates a service principal or user via credential information specified in environment variables.\n|[`ManagedIdentityCredential`][managed_id_cred_ref]| Authenticates the managed identity of an Azure resource.\n|[`WorkloadIdentityCredential`][workload_id_cred_ref]| Supports [Microsoft Entra Workload ID](https://learn.microsoft.com/azure/aks/workload-identity-overview) on Kubernetes.\n\n",
                      "markdown": "`\n|Credential|Usage\n|-|-\n|[`EnvironmentCredential`][environment_cred_ref]| Authenticates a service principal or user via credential information specified in environment variables.\n|[`ManagedIdentityCredential`][managed_id_cred_ref]| Authenticates the managed identity of an Azure resource.\n|[`WorkloadIdentityCredential`][workload_id_cred_ref]| Supports [Microsoft Entra Workload ID](https://learn.microsoft.com/azure/aks/workload-identity-overview) on Kubernetes.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1282,
                  "startColumn": 46,
                  "endLine": 1282,
                  "endColumn": 50,
                  "snippet": {
                    "text": "makes subsequent requests more efficient, and prevents unexpected changes of\nauthentication method.\n([#10349](https://github.com/Azure/azure-sdk-for-python/pull/10349))\n- All `get_token` methods consistently require at least one scope argument,\nraising an error when none is passed. Although `get_token()` may sometimes\nhave succeeded in prior versions, it couldn't do so consistently because its\nbehavior was undefined, and dependened on the credential's type and internal\n",
                    "rendered": {
                      "text": "makes subsequent requests more efficient, and prevents unexpected changes of\nauthentication method.\n([#10349](https://github.com/Azure/azure-sdk-for-python/pull/10349))\n- All `get_token` methods consistently require at least one scope argument,\nraising an error when none is passed. Although `get_token()` may sometimes\nhave succeeded in prior versions, it couldn't do so consistently because its\nbehavior was undefined, and dependened on the credential's type and internal\n",
                      "markdown": "`makes subsequent requests more efficient, and prevents unexpected changes of\nauthentication method.\n([#10349](https://github.com/Azure/azure-sdk-for-python/pull/10349))\n- All `get_token` methods consistently require at least one scope argument,\nraising an error when none is passed. Although `get_token()` may sometimes\nhave succeeded in prior versions, it couldn't do so consistently because its\nbehavior was undefined, and dependened on the credential's type and internal\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1005,
                  "startColumn": 50,
                  "endLine": 1005,
                  "endColumn": 55,
                  "snippet": {
                    "text": "- ManagedIdentityCredential caches tokens correctly\n\n### Added\n- `InteractiveBrowserCredential` functions in more WSL environments\n  ([#17615](https://github.com/Azure/azure-sdk-for-python/issues/17615))\n\n## 1.6.0b2 (2021-03-09)\n",
                    "rendered": {
                      "text": "- ManagedIdentityCredential caches tokens correctly\n\n### Added\n- `InteractiveBrowserCredential` functions in more WSL environments\n  ([#17615](https://github.com/Azure/azure-sdk-for-python/issues/17615))\n\n## 1.6.0b2 (2021-03-09)\n",
                      "markdown": "`- ManagedIdentityCredential caches tokens correctly\n\n### Added\n- `InteractiveBrowserCredential` functions in more WSL environments\n  ([#17615](https://github.com/Azure/azure-sdk-for-python/issues/17615))\n\n## 1.6.0b2 (2021-03-09)\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 944,
                  "startColumn": 46,
                  "endLine": 944,
                  "endColumn": 50,
                  "snippet": {
                    "text": "\n### Bugs Fixed\n- `azure.identity.aio.ManagedIdentityCredential` is an async context manager\n  that closes its underlying transport session at the end of a `with` block\n\n### Other Changes\n- Most credentials can use tenant ID values returned from authentication\n",
                    "rendered": {
                      "text": "\n### Bugs Fixed\n- `azure.identity.aio.ManagedIdentityCredential` is an async context manager\n  that closes its underlying transport session at the end of a `with` block\n\n### Other Changes\n- Most credentials can use tenant ID values returned from authentication\n",
                      "markdown": "`\n### Bugs Fixed\n- `azure.identity.aio.ManagedIdentityCredential` is an async context manager\n  that closes its underlying transport session at the end of a `with` block\n\n### Other Changes\n- Most credentials can use tenant ID values returned from authentication\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 890,
                  "startColumn": 29,
                  "endLine": 890,
                  "endColumn": 33,
                  "snippet": {
                    "text": "\n### Other Changes\n- Added context manager methods and `close()` to credentials in the\n  `azure.identity` namespace. At the end of a `with` block, or when `close()`\n  is called, these credentials close their underlying transport sessions.\n  ([#18798](https://github.com/Azure/azure-sdk-for-python/issues/18798))\n\n",
                    "rendered": {
                      "text": "\n### Other Changes\n- Added context manager methods and `close()` to credentials in the\n  `azure.identity` namespace. At the end of a `with` block, or when `close()`\n  is called, these credentials close their underlying transport sessions.\n  ([#18798](https://github.com/Azure/azure-sdk-for-python/issues/18798))\n\n",
                      "markdown": "`\n### Other Changes\n- Added context manager methods and `close()` to credentials in the\n  `azure.identity` namespace. At the end of a `with` block, or when `close()`\n  is called, these credentials close their underlying transport sessions.\n  ([#18798](https://github.com/Azure/azure-sdk-for-python/issues/18798))\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 610,
                  "startColumn": 1,
                  "endLine": 610,
                  "endColumn": 9,
                  "snippet": {
                    "text": "-for-python/pull/31544))\n- `ManagedIdentityCredential` will fall through to the next credential in the chain in the case that Docker Desktop returns a 403 response when attempting to access the IMDS endpoint.  ([#31824](https://github.com/Azure/azure-sdk-for-python/pull/31824))\n\n### Other Changes\n\n- Update typing of async credentials to match the `AsyncTokenCredential` protocol.\n- If within `DefaultAzureCredential`, `EnvironmentCredential` will now use log level INFO instead of WARNING to inform users of an incomplete environment configuration.  ([#31814](https://github.com/Azure/azure-sdk-for-python/",
                    "rendered": {
                      "text": "-for-python/pull/31544))\n- `ManagedIdentityCredential` will fall through to the next credential in the chain in the case that Docker Desktop returns a 403 response when attempting to access the IMDS endpoint.  ([#31824](https://github.com/Azure/azure-sdk-for-python/pull/31824))\n\n### Other Changes\n\n- Update typing of async credentials to match the `AsyncTokenCredential` protocol.\n- If within `DefaultAzureCredential`, `EnvironmentCredential` will now use log level INFO instead of WARNING to inform users of an incomplete environment configuration.  ([#31814](https://github.com/Azure/azure-sdk-for-python/",
                      "markdown": "`-for-python/pull/31544))\n- `ManagedIdentityCredential` will fall through to the next credential in the chain in the case that Docker Desktop returns a 403 response when attempting to access the IMDS endpoint.  ([#31824](https://github.com/Azure/azure-sdk-for-python/pull/31824))\n\n### Other Changes\n\n- Update typing of async credentials to match the `AsyncTokenCredential` protocol.\n- If within `DefaultAzureCredential`, `EnvironmentCredential` will now use log level INFO instead of WARNING to inform users of an incomplete environment configuration.  ([#31814](https://github.com/Azure/azure-sdk-for-python/`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 375,
                  "startColumn": 190,
                  "endLine": 375,
                  "endColumn": 194,
                  "snippet": {
                    "text": "\n### Logging\n\nThis library uses the standard [logging](https://docs.python.org/3/library/logging.html) library for logging. Credentials log basic information, including HTTP sessions (URLs, headers, etc.) at INFO level. These log entries don't contain authentication secrets.\n\nDetailed DEBUG-level logging, including request/response bodies and header values, isn't enabled by default. It can be enabled with the `logging_enable` argument. For example:\n\n",
                    "rendered": {
                      "text": "\n### Logging\n\nThis library uses the standard [logging](https://docs.python.org/3/library/logging.html) library for logging. Credentials log basic information, including HTTP sessions (URLs, headers, etc.) at INFO level. These log entries don't contain authentication secrets.\n\nDetailed DEBUG-level logging, including request/response bodies and header values, isn't enabled by default. It can be enabled with the `logging_enable` argument. For example:\n\n",
                      "markdown": "`\n### Logging\n\nThis library uses the standard [logging](https://docs.python.org/3/library/logging.html) library for logging. Credentials log basic information, including HTTP sessions (URLs, headers, etc.) at INFO level. These log entries don't contain authentication secrets.\n\nDetailed DEBUG-level logging, including request/response bodies and header values, isn't enabled by default. It can be enabled with the `logging_enable` argument. For example:\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1465,
                  "startColumn": 21,
                  "endLine": 1465,
                  "endColumn": 30,
                  "snippet": {
                    "text": "information about preview releases of other Azure SDK libraries, please visit\nhttps://aka.ms/azure-sdk-preview1-python.\n\nThis release supports service principal and managed identity authentication.\nSee the\n[documentation](https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/identity/azure-identity/README.md)\nfor more details. User authentication will be added in an upcoming preview\n",
                    "rendered": {
                      "text": "information about preview releases of other Azure SDK libraries, please visit\nhttps://aka.ms/azure-sdk-preview1-python.\n\nThis release supports service principal and managed identity authentication.\nSee the\n[documentation](https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/identity/azure-identity/README.md)\nfor more details. User authentication will be added in an upcoming preview\n",
                      "markdown": "`information about preview releases of other Azure SDK libraries, please visit\nhttps://aka.ms/azure-sdk-preview1-python.\n\nThis release supports service principal and managed identity authentication.\nSee the\n[documentation](https://github.com/Azure/azure-sdk-for-python/blob/main/sdk/identity/azure-identity/README.md)\nfor more details. User authentication will be added in an upcoming preview\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1372,
                  "startColumn": 12,
                  "endLine": 1372,
                  "endColumn": 18,
                  "snippet": {
                    "text": "- Changes to `DeviceCodeCredential`\n  - optional positional parameter `prompt_callback` is now a keyword argument\n  - `prompt_callback`'s third argument is now a `datetime` representing the\n  expiration time of the device code\n  - optional keyword argument `tenant` renamed `tenant_id`\n- Changes to `ManagedIdentityCredential`\n  - now accepts no positional arguments, and only one keyword argument:\n",
                    "rendered": {
                      "text": "- Changes to `DeviceCodeCredential`\n  - optional positional parameter `prompt_callback` is now a keyword argument\n  - `prompt_callback`'s third argument is now a `datetime` representing the\n  expiration time of the device code\n  - optional keyword argument `tenant` renamed `tenant_id`\n- Changes to `ManagedIdentityCredential`\n  - now accepts no positional arguments, and only one keyword argument:\n",
                      "markdown": "`- Changes to `DeviceCodeCredential`\n  - optional positional parameter `prompt_callback` is now a keyword argument\n  - `prompt_callback`'s third argument is now a `datetime` representing the\n  expiration time of the device code\n  - optional keyword argument `tenant` renamed `tenant_id`\n- Changes to `ManagedIdentityCredential`\n  - now accepts no positional arguments, and only one keyword argument:\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1314,
                  "startColumn": 54,
                  "endLine": 1315,
                  "snippet": {
                    "text": "\n## 1.3.0 (2020-02-11)\n\n- Correctly parse token expiration time on Windows App Service\n([#9393](https://github.com/Azure/azure-sdk-for-python/issues/9393))\n- Credentials raise `CredentialUnavailableError` when they can't attempt to\nauthenticate due to missing data or state\n([#9372](https://github.com/Azure/azure-sdk-for-python/pull/9372))\n",
                    "rendered": {
                      "text": "\n## 1.3.0 (2020-02-11)\n\n- Correctly parse token expiration time on Windows App Service\n([#9393](https://github.com/Azure/azure-sdk-for-python/issues/9393))\n- Credentials raise `CredentialUnavailableError` when they can't attempt to\nauthenticate due to missing data or state\n([#9372](https://github.com/Azure/azure-sdk-for-python/pull/9372))\n",
                      "markdown": "`\n## 1.3.0 (2020-02-11)\n\n- Correctly parse token expiration time on Windows App Service\n([#9393](https://github.com/Azure/azure-sdk-for-python/issues/9393))\n- Credentials raise `CredentialUnavailableError` when they can't attempt to\nauthenticate due to missing data or state\n([#9372](https://github.com/Azure/azure-sdk-for-python/pull/9372))\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1314,
                  "startColumn": 34,
                  "endLine": 1314,
                  "endColumn": 40,
                  "snippet": {
                    "text": "\n## 1.3.0 (2020-02-11)\n\n- Correctly parse token expiration time on Windows App Service\n([#9393](https://github.com/Azure/azure-sdk-for-python/issues/9393))\n- Credentials raise `CredentialUnavailableError` when they can't attempt to\nauthenticate due to missing data or state\n",
                    "rendered": {
                      "text": "\n## 1.3.0 (2020-02-11)\n\n- Correctly parse token expiration time on Windows App Service\n([#9393](https://github.com/Azure/azure-sdk-for-python/issues/9393))\n- Credentials raise `CredentialUnavailableError` when they can't attempt to\nauthenticate due to missing data or state\n",
                      "markdown": "`\n## 1.3.0 (2020-02-11)\n\n- Correctly parse token expiration time on Windows App Service\n([#9393](https://github.com/Azure/azure-sdk-for-python/issues/9393))\n- Credentials raise `CredentialUnavailableError` when they can't attempt to\nauthenticate due to missing data or state\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1245,
                  "startColumn": 57,
                  "endLine": 1245,
                  "endColumn": 62,
                  "snippet": {
                    "text": "  macOS as well as Windows.\n  ([#11134](https://github.com/Azure/azure-sdk-for-python/issues/11134))\n  - On Linux, the persistent cache requires libsecret and `pygobject`. If these\n    are unavailable, or libsecret is unusable (e.g. in an SSH session), loading\n    the persistent cache will raise an error. You may optionally configure the\n    credential to fall back to an unencrypted cache by constructing it with\n    keyword argument `allow_unencrypted_cache=True`.\n",
                    "rendered": {
                      "text": "  macOS as well as Windows.\n  ([#11134](https://github.com/Azure/azure-sdk-for-python/issues/11134))\n  - On Linux, the persistent cache requires libsecret and `pygobject`. If these\n    are unavailable, or libsecret is unusable (e.g. in an SSH session), loading\n    the persistent cache will raise an error. You may optionally configure the\n    credential to fall back to an unencrypted cache by constructing it with\n    keyword argument `allow_unencrypted_cache=True`.\n",
                      "markdown": "`  macOS as well as Windows.\n  ([#11134](https://github.com/Azure/azure-sdk-for-python/issues/11134))\n  - On Linux, the persistent cache requires libsecret and `pygobject`. If these\n    are unavailable, or libsecret is unusable (e.g. in an SSH session), loading\n    the persistent cache will raise an error. You may optionally configure the\n    credential to fall back to an unencrypted cache by constructing it with\n    keyword argument `allow_unencrypted_cache=True`.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1209,
                  "startColumn": 22,
                  "endLine": 1209,
                  "endColumn": 27,
                  "snippet": {
                    "text": "  access tokens they acquire in a persistent cache. To enable this, construct\n  the credential with `enable_persistent_cache=True`. On Linux, the persistent\n  cache requires libsecret and `pygobject`. If these are unavailable or\n  unusable (e.g. in an SSH session), loading the persistent cache will raise an\n  error. You may optionally configure the credential to fall back to an\n  unencrypted cache by constructing it with keyword argument\n  `allow_unencrypted_cache=True`.\n",
                    "rendered": {
                      "text": "  access tokens they acquire in a persistent cache. To enable this, construct\n  the credential with `enable_persistent_cache=True`. On Linux, the persistent\n  cache requires libsecret and `pygobject`. If these are unavailable or\n  unusable (e.g. in an SSH session), loading the persistent cache will raise an\n  error. You may optionally configure the credential to fall back to an\n  unencrypted cache by constructing it with keyword argument\n  `allow_unencrypted_cache=True`.\n",
                      "markdown": "`  access tokens they acquire in a persistent cache. To enable this, construct\n  the credential with `enable_persistent_cache=True`. On Linux, the persistent\n  cache requires libsecret and `pygobject`. If these are unavailable or\n  unusable (e.g. in an SSH session), loading the persistent cache will raise an\n  error. You may optionally configure the credential to fall back to an\n  unencrypted cache by constructing it with keyword argument\n  `allow_unencrypted_cache=True`.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1123,
                  "startColumn": 64,
                  "endLine": 1124,
                  "snippet": {
                    "text": "## 1.5.0b1 (2020-09-08)\n### Added\n- Application authentication APIs from 1.4.0b7\n- `ManagedIdentityCredential` supports the latest version of App Service\n  ([#11346](https://github.com/Azure/azure-sdk-for-python/issues/11346))\n- `DefaultAzureCredential` allows specifying the client ID of a user-assigned\n  managed identity via keyword argument `managed_identity_client_id`\n  ([#12991](https://github.com/Azure/azure-sdk-for-python/issues/12991))\n",
                    "rendered": {
                      "text": "## 1.5.0b1 (2020-09-08)\n### Added\n- Application authentication APIs from 1.4.0b7\n- `ManagedIdentityCredential` supports the latest version of App Service\n  ([#11346](https://github.com/Azure/azure-sdk-for-python/issues/11346))\n- `DefaultAzureCredential` allows specifying the client ID of a user-assigned\n  managed identity via keyword argument `managed_identity_client_id`\n  ([#12991](https://github.com/Azure/azure-sdk-for-python/issues/12991))\n",
                      "markdown": "`## 1.5.0b1 (2020-09-08)\n### Added\n- Application authentication APIs from 1.4.0b7\n- `ManagedIdentityCredential` supports the latest version of App Service\n  ([#11346](https://github.com/Azure/azure-sdk-for-python/issues/11346))\n- `DefaultAzureCredential` allows specifying the client ID of a user-assigned\n  managed identity via keyword argument `managed_identity_client_id`\n  ([#12991](https://github.com/Azure/azure-sdk-for-python/issues/12991))\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 1088,
                  "startColumn": 38,
                  "endLine": 1088,
                  "endColumn": 47,
                  "snippet": {
                    "text": "- Raised minimum msal version to 1.6.0\n\n### Added\n- `ManagedIdentityCredential` supports Service Fabric\n  ([#12705](https://github.com/Azure/azure-sdk-for-python/issues/12705))\n  and Azure Arc\n  ([#12702](https://github.com/Azure/azure-sdk-for-python/issues/12702))\n",
                    "rendered": {
                      "text": "- Raised minimum msal version to 1.6.0\n\n### Added\n- `ManagedIdentityCredential` supports Service Fabric\n  ([#12705](https://github.com/Azure/azure-sdk-for-python/issues/12705))\n  and Azure Arc\n  ([#12702](https://github.com/Azure/azure-sdk-for-python/issues/12702))\n",
                      "markdown": "`- Raised minimum msal version to 1.6.0\n\n### Added\n- `ManagedIdentityCredential` supports Service Fabric\n  ([#12705](https://github.com/Azure/azure-sdk-for-python/issues/12705))\n  and Azure Arc\n  ([#12702](https://github.com/Azure/azure-sdk-for-python/issues/12702))\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 832,
                  "startColumn": 13,
                  "endLine": 832,
                  "endColumn": 22,
                  "snippet": {
                    "text": "- Added `validate_authority` support for msal client  ([#22625](https://github.com/Azure/azure-sdk-for-python/issues/22625))\n- Added `resource_id` support for user-assigned managed identity  ([#22329](https://github.com/Azure/azure-sdk-for-python/issues/22329))\n- Added `ClientAssertionCredential` support  ([#22328](https://github.com/Azure/azure-sdk-for-python/issues/22328))\n- Updated App service API version to \"2019-08-01\" ([#23034](https://github.com/Azure/azure-sdk-for-python/issues/23034))\n\n## 1.8.0 (2022-03-01)\n\n",
                    "rendered": {
                      "text": "- Added `validate_authority` support for msal client  ([#22625](https://github.com/Azure/azure-sdk-for-python/issues/22625))\n- Added `resource_id` support for user-assigned managed identity  ([#22329](https://github.com/Azure/azure-sdk-for-python/issues/22329))\n- Added `ClientAssertionCredential` support  ([#22328](https://github.com/Azure/azure-sdk-for-python/issues/22328))\n- Updated App service API version to \"2019-08-01\" ([#23034](https://github.com/Azure/azure-sdk-for-python/issues/23034))\n\n## 1.8.0 (2022-03-01)\n\n",
                      "markdown": "`- Added `validate_authority` support for msal client  ([#22625](https://github.com/Azure/azure-sdk-for-python/issues/22625))\n- Added `resource_id` support for user-assigned managed identity  ([#22329](https://github.com/Azure/azure-sdk-for-python/issues/22329))\n- Added `ClientAssertionCredential` support  ([#22328](https://github.com/Azure/azure-sdk-for-python/issues/22328))\n- Updated App service API version to \"2019-08-01\" ([#23034](https://github.com/Azure/azure-sdk-for-python/issues/23034))\n\n## 1.8.0 (2022-03-01)\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 670,
                  "startColumn": 1,
                  "endLine": 670,
                  "endColumn": 10,
                  "snippet": {
                    "text": "### Features Added\n\n- Changed parameter from `instance_discovery` to `disable_instance_discovery` to make it more explicit.\n- Service principal credentials now enable support for [Continuous Access Evaluation (CAE)](https://learn.microsoft.com/entra/identity/conditional-access/concept-continuous-access-evaluation-workload). This indicates to Microsoft Entra ID that your application can handle CAE claims challenges.\n\n## 1.13.0b2 (2023-02-07)\n\n",
                    "rendered": {
                      "text": "### Features Added\n\n- Changed parameter from `instance_discovery` to `disable_instance_discovery` to make it more explicit.\n- Service principal credentials now enable support for [Continuous Access Evaluation (CAE)](https://learn.microsoft.com/entra/identity/conditional-access/concept-continuous-access-evaluation-workload). This indicates to Microsoft Entra ID that your application can handle CAE claims challenges.\n\n## 1.13.0b2 (2023-02-07)\n\n",
                      "markdown": "`### Features Added\n\n- Changed parameter from `instance_discovery` to `disable_instance_discovery` to make it more explicit.\n- Service principal credentials now enable support for [Continuous Access Evaluation (CAE)](https://learn.microsoft.com/entra/identity/conditional-access/concept-continuous-access-evaluation-workload). This indicates to Microsoft Entra ID that your application can handle CAE claims challenges.\n\n## 1.13.0b2 (2023-02-07)\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 663,
                  "startColumn": 243,
                  "endLine": 663,
                  "endColumn": 252,
                  "snippet": {
                    "text": "e tokens.\n\n## 1.13.0b4 (2023-04-11)\n\n### Features Added\n\n- Credentials that are implemented via launching a subprocess to acquire tokens now have configurable timeouts using the `process_timeout` keyword argument. This addresses scenarios where these proceses can take longer than the current default timeout values. The affected credentials are `AzureCliCredential`, `AzureDeveloperCliCredential`, and `AzurePowerShellCredential`. (Note: For `DefaultAzureCredential`, the `developer_credential_timeout` keyword argument allows users to propagate this option to `AzureCliCredential`, `AzureDeveloperCliCredent",
                    "rendered": {
                      "text": "e tokens.\n\n## 1.13.0b4 (2023-04-11)\n\n### Features Added\n\n- Credentials that are implemented via launching a subprocess to acquire tokens now have configurable timeouts using the `process_timeout` keyword argument. This addresses scenarios where these proceses can take longer than the current default timeout values. The affected credentials are `AzureCliCredential`, `AzureDeveloperCliCredential`, and `AzurePowerShellCredential`. (Note: For `DefaultAzureCredential`, the `developer_credential_timeout` keyword argument allows users to propagate this option to `AzureCliCredential`, `AzureDeveloperCliCredent",
                      "markdown": "`e tokens.\n\n## 1.13.0b4 (2023-04-11)\n\n### Features Added\n\n- Credentials that are implemented via launching a subprocess to acquire tokens now have configurable timeouts using the `process_timeout` keyword argument. This addresses scenarios where these proceses can take longer than the current default timeout values. The affected credentials are `AzureCliCredential`, `AzureDeveloperCliCredential`, and `AzurePowerShellCredential`. (Note: For `DefaultAzureCredential`, the `developer_credential_timeout` keyword argument allows users to propagate this option to `AzureCliCredential`, `AzureDeveloperCliCredent`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 656,
                  "startColumn": 59,
                  "endLine": 656,
                  "endColumn": 68,
                  "snippet": {
                    "text": ".\n> Only code written against a beta version such as 1.13.0b4 may be affected.\n- Windows Web Account Manager (WAM) Brokered Authentication is still in preview and not available in this release. It will be available in the next beta release.\n- Additional Continuous Access Evaluation (CAE) support for service principal credentials is still in preview and not available in this release. It will be available in the next beta release.\n- Renamed keyword argument `developer_credential_timeout` to `process_timeout` in `DefaultAzureCredential` to remain consistent with the other credentials that launch a subproc",
                    "rendered": {
                      "text": ".\n> Only code written against a beta version such as 1.13.0b4 may be affected.\n- Windows Web Account Manager (WAM) Brokered Authentication is still in preview and not available in this release. It will be available in the next beta release.\n- Additional Continuous Access Evaluation (CAE) support for service principal credentials is still in preview and not available in this release. It will be available in the next beta release.\n- Renamed keyword argument `developer_credential_timeout` to `process_timeout` in `DefaultAzureCredential` to remain consistent with the other credentials that launch a subproc",
                      "markdown": "`.\n> Only code written against a beta version such as 1.13.0b4 may be affected.\n- Windows Web Account Manager (WAM) Brokered Authentication is still in preview and not available in this release. It will be available in the next beta release.\n- Additional Continuous Access Evaluation (CAE) support for service principal credentials is still in preview and not available in this release. It will be available in the next beta release.\n- Renamed keyword argument `developer_credential_timeout` to `process_timeout` in `DefaultAzureCredential` to remain consistent with the other credentials that launch a subproc`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 620,
                  "startColumn": 176,
                  "endLine": 620,
                  "endColumn": 185,
                  "snippet": {
                    "text": "\n### Features Added\n\n- Continuous Access Evaluation (CAE) is now configurable per-request by setting the `enable_cae` keyword argument to `True` in `get_token`. This applies to user credentials and service principal credentials.  ([#30777](https://github.com/Azure/azure-sdk-for-python/pull/30777))\n\n### Breaking Changes\n\n",
                    "rendered": {
                      "text": "\n### Features Added\n\n- Continuous Access Evaluation (CAE) is now configurable per-request by setting the `enable_cae` keyword argument to `True` in `get_token`. This applies to user credentials and service principal credentials.  ([#30777](https://github.com/Azure/azure-sdk-for-python/pull/30777))\n\n### Breaking Changes\n\n",
                      "markdown": "`\n### Features Added\n\n- Continuous Access Evaluation (CAE) is now configurable per-request by setting the `enable_cae` keyword argument to `True` in `get_token`. This applies to user credentials and service principal credentials.  ([#30777](https://github.com/Azure/azure-sdk-for-python/pull/30777))\n\n### Breaking Changes\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 614,
                  "startColumn": 157,
                  "endLine": 614,
                  "endColumn": 166,
                  "snippet": {
                    "text": "evious attempts failed. This is to prevent credential instances from potentially being permanently disabled after a temporary network failure.\n- IMDS endpoint probes in `ManagedIdentityCredential` will now only occur when inside a credential chain such as `DefaultAzureCredential`. This probe request timeout has been increased to 1 second from 0.3 seconds to reduce the likelihood of false negatives.\n\n## 1.14.0 (2023-08-08)\n\n### Features Added\n\n- Continuous Access Evaluation (CAE) is now configurable per-request by setting the `enable_cae` keyword argument to `True` in `get_token`. This applies to user c",
                    "rendered": {
                      "text": "evious attempts failed. This is to prevent credential instances from potentially being permanently disabled after a temporary network failure.\n- IMDS endpoint probes in `ManagedIdentityCredential` will now only occur when inside a credential chain such as `DefaultAzureCredential`. This probe request timeout has been increased to 1 second from 0.3 seconds to reduce the likelihood of false negatives.\n\n## 1.14.0 (2023-08-08)\n\n### Features Added\n\n- Continuous Access Evaluation (CAE) is now configurable per-request by setting the `enable_cae` keyword argument to `True` in `get_token`. This applies to user c",
                      "markdown": "`evious attempts failed. This is to prevent credential instances from potentially being permanently disabled after a temporary network failure.\n- IMDS endpoint probes in `ManagedIdentityCredential` will now only occur when inside a credential chain such as `DefaultAzureCredential`. This probe request timeout has been increased to 1 second from 0.3 seconds to reduce the likelihood of false negatives.\n\n## 1.14.0 (2023-08-08)\n\n### Features Added\n\n- Continuous Access Evaluation (CAE) is now configurable per-request by setting the `enable_cae` keyword argument to `True` in `get_token`. This applies to user c`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 606,
                  "startColumn": 100,
                  "endLine": 606,
                  "endColumn": 108,
                  "snippet": {
                    "text": "ure-sdk-for-python/pull/31534))\n- Fixed an issue with `ClientAssertionCredential` not properly checking if CAE should be enabled.  ([#31544](https://github.com/Azure/azure-sdk-for-python/pull/31544))\n- `ManagedIdentityCredential` will fall through to the next credential in the chain in the case that Docker Desktop returns a 403 response when attempting to access the IMDS endpoint.  ([#31824](https://github.com/Azure/azure-sdk-for-python/pull/31824))\n\n### Other Changes\n\n- Update typing of async credentials to match the `AsyncTokenCredential` protocol.\n- If within `DefaultAzureCredential`, `EnvironmentC",
                    "rendered": {
                      "text": "ure-sdk-for-python/pull/31534))\n- Fixed an issue with `ClientAssertionCredential` not properly checking if CAE should be enabled.  ([#31544](https://github.com/Azure/azure-sdk-for-python/pull/31544))\n- `ManagedIdentityCredential` will fall through to the next credential in the chain in the case that Docker Desktop returns a 403 response when attempting to access the IMDS endpoint.  ([#31824](https://github.com/Azure/azure-sdk-for-python/pull/31824))\n\n### Other Changes\n\n- Update typing of async credentials to match the `AsyncTokenCredential` protocol.\n- If within `DefaultAzureCredential`, `EnvironmentC",
                      "markdown": "`ure-sdk-for-python/pull/31534))\n- Fixed an issue with `ClientAssertionCredential` not properly checking if CAE should be enabled.  ([#31544](https://github.com/Azure/azure-sdk-for-python/pull/31544))\n- `ManagedIdentityCredential` will fall through to the next credential in the chain in the case that Docker Desktop returns a 403 response when attempting to access the IMDS endpoint.  ([#31824](https://github.com/Azure/azure-sdk-for-python/pull/31824))\n\n### Other Changes\n\n- Update typing of async credentials to match the `AsyncTokenCredential` protocol.\n- If within `DefaultAzureCredential`, `EnvironmentC`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 555,
                  "startColumn": 153,
                  "endLine": 555,
                  "endColumn": 161,
                  "snippet": {
                    "text": "### Bugs Fixed\n\n- Fixed the bug that `ClientAssertionCredential` constructor fails if kwargs are provided. ([#33673](https://github.com/Azure/azure-sdk-for-python/issues/33673))\n- `ManagedIdentityCredential` is more lenient with the error message it matches when falling through to the next credential in the chain in the case that Docker Desktop returns a 403 response when attempting to access the IMDS endpoint. ([#33928](https://github.com/Azure/azure-sdk-for-python/pull/33928))\n\n### Other Changes\n\n",
                    "rendered": {
                      "text": "### Bugs Fixed\n\n- Fixed the bug that `ClientAssertionCredential` constructor fails if kwargs are provided. ([#33673](https://github.com/Azure/azure-sdk-for-python/issues/33673))\n- `ManagedIdentityCredential` is more lenient with the error message it matches when falling through to the next credential in the chain in the case that Docker Desktop returns a 403 response when attempting to access the IMDS endpoint. ([#33928](https://github.com/Azure/azure-sdk-for-python/pull/33928))\n\n### Other Changes\n\n",
                      "markdown": "`### Bugs Fixed\n\n- Fixed the bug that `ClientAssertionCredential` constructor fails if kwargs are provided. ([#33673](https://github.com/Azure/azure-sdk-for-python/issues/33673))\n- `ManagedIdentityCredential` is more lenient with the error message it matches when falling through to the next credential in the chain in the case that Docker Desktop returns a 403 response when attempting to access the IMDS endpoint. ([#33928](https://github.com/Azure/azure-sdk-for-python/pull/33928))\n\n### Other Changes\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 528,
                  "startColumn": 126,
                  "endLine": 528,
                  "endColumn": 135,
                  "snippet": {
                    "text": "### Features Added\n\n- Added environment variable `AZURE_CLIENT_SEND_CERTIFICATE_CHAIN` support for `EnvironmentCredential`.\n- Introduced a new credential, `AzurePipelinesCredential`, for supporting workload identity federation in Azure Pipelines with service connections ([#35397](https://github.com/Azure/azure-sdk-for-python/pull/35397)).\n\n### Bugs Fixed\n\n",
                    "rendered": {
                      "text": "### Features Added\n\n- Added environment variable `AZURE_CLIENT_SEND_CERTIFICATE_CHAIN` support for `EnvironmentCredential`.\n- Introduced a new credential, `AzurePipelinesCredential`, for supporting workload identity federation in Azure Pipelines with service connections ([#35397](https://github.com/Azure/azure-sdk-for-python/pull/35397)).\n\n### Bugs Fixed\n\n",
                      "markdown": "`### Features Added\n\n- Added environment variable `AZURE_CLIENT_SEND_CERTIFICATE_CHAIN` support for `EnvironmentCredential`.\n- Introduced a new credential, `AzurePipelinesCredential`, for supporting workload identity federation in Azure Pipelines with service connections ([#35397](https://github.com/Azure/azure-sdk-for-python/pull/35397)).\n\n### Bugs Fixed\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 324,
                  "startColumn": 3,
                  "endLine": 324,
                  "endColumn": 12,
                  "snippet": {
                    "text": "|`AZURE_TENANT_ID`|ID of the application's Microsoft Entra tenant\n|`AZURE_CLIENT_SECRET`|one of the application's client secrets\n\n### Service principal with certificate\n\n|Variable name|Value|Required\n|-|-|-\n",
                    "rendered": {
                      "text": "|`AZURE_TENANT_ID`|ID of the application's Microsoft Entra tenant\n|`AZURE_CLIENT_SECRET`|one of the application's client secrets\n\n### Service principal with certificate\n\n|Variable name|Value|Required\n|-|-|-\n",
                      "markdown": "`|`AZURE_TENANT_ID`|ID of the application's Microsoft Entra tenant\n|`AZURE_CLIENT_SECRET`|one of the application's client secrets\n\n### Service principal with certificate\n\n|Variable name|Value|Required\n|-|-|-\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 316,
                  "startColumn": 3,
                  "endLine": 316,
                  "endColumn": 12,
                  "snippet": {
                    "text": "[DefaultAzureCredential][default_cred_ref] and [EnvironmentCredential][environment_cred_ref] can be configured with environment variables. Each type of authentication requires values for specific\nvariables:\n\n### Service principal with secret\n\n|Variable name|Value\n|-|-\n",
                    "rendered": {
                      "text": "[DefaultAzureCredential][default_cred_ref] and [EnvironmentCredential][environment_cred_ref] can be configured with environment variables. Each type of authentication requires values for specific\nvariables:\n\n### Service principal with secret\n\n|Variable name|Value\n|-|-\n",
                      "markdown": "`[DefaultAzureCredential][default_cred_ref] and [EnvironmentCredential][environment_cred_ref] can be configured with environment variables. Each type of authentication requires values for specific\nvariables:\n\n### Service principal with secret\n\n|Variable name|Value\n|-|-\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 290,
                  "startColumn": 68,
                  "endLine": 290,
                  "endColumn": 77,
                  "snippet": {
                    "text": "authentication](https://learn.microsoft.com/entra/identity-platform/app-objects-and-service-principals)\n|[`ClientAssertionCredential`][client_assertion_cred_ref]| Authenticates a service principal using a signed client assertion. |\n|[`ClientSecretCredential`][client_secret_cred_ref]| Authenticates a service principal using a secret. | [Service principal authentication](https://learn.microsoft.com/entra/identity-platform/app-objects-and-service-principals)\n\n### Authenticate users\n\n|Credential|Usage| Reference | Notes\n|-|-|-|-\n|[`AuthorizationCodeCredential`][auth_code_cred_ref]| Authenticates a user wit",
                    "rendered": {
                      "text": "authentication](https://learn.microsoft.com/entra/identity-platform/app-objects-and-service-principals)\n|[`ClientAssertionCredential`][client_assertion_cred_ref]| Authenticates a service principal using a signed client assertion. |\n|[`ClientSecretCredential`][client_secret_cred_ref]| Authenticates a service principal using a secret. | [Service principal authentication](https://learn.microsoft.com/entra/identity-platform/app-objects-and-service-principals)\n\n### Authenticate users\n\n|Credential|Usage| Reference | Notes\n|-|-|-|-\n|[`AuthorizationCodeCredential`][auth_code_cred_ref]| Authenticates a user wit",
                      "markdown": "`authentication](https://learn.microsoft.com/entra/identity-platform/app-objects-and-service-principals)\n|[`ClientAssertionCredential`][client_assertion_cred_ref]| Authenticates a service principal using a signed client assertion. |\n|[`ClientSecretCredential`][client_secret_cred_ref]| Authenticates a service principal using a secret. | [Service principal authentication](https://learn.microsoft.com/entra/identity-platform/app-objects-and-service-principals)\n\n### Authenticate users\n\n|Credential|Usage| Reference | Notes\n|-|-|-|-\n|[`AuthorizationCodeCredential`][auth_code_cred_ref]| Authenticates a user wit`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 289,
                  "startColumn": 74,
                  "endLine": 289,
                  "endColumn": 83,
                  "snippet": {
                    "text": " |\n|[`CertificateCredential`][cert_cred_ref]| Authenticates a service principal using a certificate. | [Service principal authentication](https://learn.microsoft.com/entra/identity-platform/app-objects-and-service-principals)\n|[`ClientAssertionCredential`][client_assertion_cred_ref]| Authenticates a service principal using a signed client assertion. |\n|[`ClientSecretCredential`][client_secret_cred_ref]| Authenticates a service principal using a secret. | [Service principal authentication](https://learn.microsoft.com/entra/identity-platform/app-objects-and-service-principals)\n\n### Authenticate users\n\n|C",
                    "rendered": {
                      "text": " |\n|[`CertificateCredential`][cert_cred_ref]| Authenticates a service principal using a certificate. | [Service principal authentication](https://learn.microsoft.com/entra/identity-platform/app-objects-and-service-principals)\n|[`ClientAssertionCredential`][client_assertion_cred_ref]| Authenticates a service principal using a signed client assertion. |\n|[`ClientSecretCredential`][client_secret_cred_ref]| Authenticates a service principal using a secret. | [Service principal authentication](https://learn.microsoft.com/entra/identity-platform/app-objects-and-service-principals)\n\n### Authenticate users\n\n|C",
                      "markdown": "` |\n|[`CertificateCredential`][cert_cred_ref]| Authenticates a service principal using a certificate. | [Service principal authentication](https://learn.microsoft.com/entra/identity-platform/app-objects-and-service-principals)\n|[`ClientAssertionCredential`][client_assertion_cred_ref]| Authenticates a service principal using a signed client assertion. |\n|[`ClientSecretCredential`][client_secret_cred_ref]| Authenticates a service principal using a secret. | [Service principal authentication](https://learn.microsoft.com/entra/identity-platform/app-objects-and-service-principals)\n\n### Authenticate users\n\n|C`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 288,
                  "startColumn": 58,
                  "endLine": 288,
                  "endColumn": 67,
                  "snippet": {
                    "text": "age|Reference\n|-|-|-\n|[`AzurePipelinesCredential`][az_pipelines_cred_ref]| Supports [Microsoft Entra Workload ID](https://learn.microsoft.com/azure/devops/pipelines/release/configure-workload-identity?view=azure-devops) on Azure Pipelines. |\n|[`CertificateCredential`][cert_cred_ref]| Authenticates a service principal using a certificate. | [Service principal authentication](https://learn.microsoft.com/entra/identity-platform/app-objects-and-service-principals)\n|[`ClientAssertionCredential`][client_assertion_cred_ref]| Authenticates a service principal using a signed client assertion. |\n|[`ClientSecretC",
                    "rendered": {
                      "text": "age|Reference\n|-|-|-\n|[`AzurePipelinesCredential`][az_pipelines_cred_ref]| Supports [Microsoft Entra Workload ID](https://learn.microsoft.com/azure/devops/pipelines/release/configure-workload-identity?view=azure-devops) on Azure Pipelines. |\n|[`CertificateCredential`][cert_cred_ref]| Authenticates a service principal using a certificate. | [Service principal authentication](https://learn.microsoft.com/entra/identity-platform/app-objects-and-service-principals)\n|[`ClientAssertionCredential`][client_assertion_cred_ref]| Authenticates a service principal using a signed client assertion. |\n|[`ClientSecretC",
                      "markdown": "`age|Reference\n|-|-|-\n|[`AzurePipelinesCredential`][az_pipelines_cred_ref]| Supports [Microsoft Entra Workload ID](https://learn.microsoft.com/azure/devops/pipelines/release/configure-workload-identity?view=azure-devops) on Azure Pipelines. |\n|[`CertificateCredential`][cert_cred_ref]| Authenticates a service principal using a certificate. | [Service principal authentication](https://learn.microsoft.com/entra/identity-platform/app-objects-and-service-principals)\n|[`ClientAssertionCredential`][client_assertion_cred_ref]| Authenticates a service principal using a signed client assertion. |\n|[`ClientSecretC`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 283,
                  "startColumn": 16,
                  "endLine": 283,
                  "endColumn": 25,
                  "snippet": {
                    "text": "|[`ManagedIdentityCredential`][managed_id_cred_ref]| Authenticates the managed identity of an Azure resource.\n|[`WorkloadIdentityCredential`][workload_id_cred_ref]| Supports [Microsoft Entra Workload ID](https://learn.microsoft.com/azure/aks/workload-identity-overview) on Kubernetes.\n\n### Authenticate service principals\n\n|Credential|Usage|Reference\n|-|-|-\n",
                    "rendered": {
                      "text": "|[`ManagedIdentityCredential`][managed_id_cred_ref]| Authenticates the managed identity of an Azure resource.\n|[`WorkloadIdentityCredential`][workload_id_cred_ref]| Supports [Microsoft Entra Workload ID](https://learn.microsoft.com/azure/aks/workload-identity-overview) on Kubernetes.\n\n### Authenticate service principals\n\n|Credential|Usage|Reference\n|-|-|-\n",
                      "markdown": "`|[`ManagedIdentityCredential`][managed_id_cred_ref]| Authenticates the managed identity of an Azure resource.\n|[`WorkloadIdentityCredential`][workload_id_cred_ref]| Supports [Microsoft Entra Workload ID](https://learn.microsoft.com/azure/aks/workload-identity-overview) on Kubernetes.\n\n### Authenticate service principals\n\n|Credential|Usage|Reference\n|-|-|-\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 279,
                  "startColumn": 65,
                  "endLine": 279,
                  "endColumn": 74,
                  "snippet": {
                    "text": "\n|Credential|Usage\n|-|-\n|[`EnvironmentCredential`][environment_cred_ref]| Authenticates a service principal or user via credential information specified in environment variables.\n|[`ManagedIdentityCredential`][managed_id_cred_ref]| Authenticates the managed identity of an Azure resource.\n|[`WorkloadIdentityCredential`][workload_id_cred_ref]| Supports [Microsoft Entra Workload ID](https://learn.microsoft.com/azure/aks/workload-identity-overview) on Kubernetes.\n\n",
                    "rendered": {
                      "text": "\n|Credential|Usage\n|-|-\n|[`EnvironmentCredential`][environment_cred_ref]| Authenticates a service principal or user via credential information specified in environment variables.\n|[`ManagedIdentityCredential`][managed_id_cred_ref]| Authenticates the managed identity of an Azure resource.\n|[`WorkloadIdentityCredential`][workload_id_cred_ref]| Supports [Microsoft Entra Workload ID](https://learn.microsoft.com/azure/aks/workload-identity-overview) on Kubernetes.\n\n",
                      "markdown": "`\n|Credential|Usage\n|-|-\n|[`EnvironmentCredential`][environment_cred_ref]| Authenticates a service principal or user via credential information specified in environment variables.\n|[`ManagedIdentityCredential`][managed_id_cred_ref]| Authenticates the managed identity of an Azure resource.\n|[`WorkloadIdentityCredential`][workload_id_cred_ref]| Supports [Microsoft Entra Workload ID](https://learn.microsoft.com/azure/aks/workload-identity-overview) on Kubernetes.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 187,
                  "startColumn": 8,
                  "endLine": 187,
                  "endColumn": 17,
                  "snippet": {
                    "text": "ity?tabs=python)\n- [Azure Arc](https://learn.microsoft.com/azure/azure-arc/servers/managed-identity-authentication)\n- [Azure Cloud Shell](https://learn.microsoft.com/azure/cloud-shell/msi-authorization)\n- [Azure Kubernetes Service](https://learn.microsoft.com/azure/aks/use-managed-identity)\n- [Azure Service Fabric](https://learn.microsoft.com/azure/service-fabric/concepts-managed-identity)\n- [Azure Virtual Machines](https://learn.microsoft.com/entra/identity/managed-identities-azure-resources/how-to-use-vm-token)\n- [Azure Virtual Machines Scale Sets](https://learn.microsoft.com/entra/identity/managed-i",
                    "rendered": {
                      "text": "ity?tabs=python)\n- [Azure Arc](https://learn.microsoft.com/azure/azure-arc/servers/managed-identity-authentication)\n- [Azure Cloud Shell](https://learn.microsoft.com/azure/cloud-shell/msi-authorization)\n- [Azure Kubernetes Service](https://learn.microsoft.com/azure/aks/use-managed-identity)\n- [Azure Service Fabric](https://learn.microsoft.com/azure/service-fabric/concepts-managed-identity)\n- [Azure Virtual Machines](https://learn.microsoft.com/entra/identity/managed-identities-azure-resources/how-to-use-vm-token)\n- [Azure Virtual Machines Scale Sets](https://learn.microsoft.com/entra/identity/managed-i",
                      "markdown": "`ity?tabs=python)\n- [Azure Arc](https://learn.microsoft.com/azure/azure-arc/servers/managed-identity-authentication)\n- [Azure Cloud Shell](https://learn.microsoft.com/azure/cloud-shell/msi-authorization)\n- [Azure Kubernetes Service](https://learn.microsoft.com/azure/aks/use-managed-identity)\n- [Azure Service Fabric](https://learn.microsoft.com/azure/service-fabric/concepts-managed-identity)\n- [Azure Virtual Machines](https://learn.microsoft.com/entra/identity/managed-identities-azure-resources/how-to-use-vm-token)\n- [Azure Virtual Machines Scale Sets](https://learn.microsoft.com/entra/identity/managed-i`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 183,
                  "startColumn": 12,
                  "endLine": 183,
                  "endColumn": 21,
                  "snippet": {
                    "text": "ential)\n```\n\n## Managed identity support\n\n[Managed identity authentication](https://learn.microsoft.com/entra/identity/managed-identities-azure-resources/overview) is supported via either `DefaultAzureCredential` or `ManagedIdentityCredential` directly for the following Azure services:\n\n- [Azure App Service and Azure Functions](https://learn.microsoft.com/azure/app-service/overview-managed-identity?tabs=python)\n- [Azure Arc](https://learn.microsoft.com/azure/azure-arc/servers/managed-identity-authentication)\n- [Azure Cloud Shell](https://learn.microsoft.com/azure/cloud-shell/msi-authorization)\n- [Azure",
                    "rendered": {
                      "text": "ential)\n```\n\n## Managed identity support\n\n[Managed identity authentication](https://learn.microsoft.com/entra/identity/managed-identities-azure-resources/overview) is supported via either `DefaultAzureCredential` or `ManagedIdentityCredential` directly for the following Azure services:\n\n- [Azure App Service and Azure Functions](https://learn.microsoft.com/azure/app-service/overview-managed-identity?tabs=python)\n- [Azure Arc](https://learn.microsoft.com/azure/azure-arc/servers/managed-identity-authentication)\n- [Azure Cloud Shell](https://learn.microsoft.com/azure/cloud-shell/msi-authorization)\n- [Azure",
                      "markdown": "`ential)\n```\n\n## Managed identity support\n\n[Managed identity authentication](https://learn.microsoft.com/entra/identity/managed-identities-azure-resources/overview) is supported via either `DefaultAzureCredential` or `ManagedIdentityCredential` directly for the following Azure services:\n\n- [Azure App Service and Azure Functions](https://learn.microsoft.com/azure/app-service/overview-managed-identity?tabs=python)\n- [Azure Arc](https://learn.microsoft.com/azure/azure-arc/servers/managed-identity-authentication)\n- [Azure Cloud Shell](https://learn.microsoft.com/azure/cloud-shell/msi-authorization)\n- [Azure`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 351,
                  "endLine": 94,
                  "endColumn": 360,
                  "snippet": {
                    "text": "mpts to authenticate with all developer credentials until one succeeds, regardless of any errors previous developer credentials experienced. For example, a developer credential may attempt to get a token and fail, so `DefaultAzureCredential` will continue to the next credential in the flow. Deployed service credentials stop the flow with a thrown exception if they're able to attempt token retrieval, but don't receive one. Prior to version 1.14.0, developer credentials would similarly stop the authentication flow if token retrieval failed, but this is no longer the case.\n\nThis allows for trying all of t",
                    "rendered": {
                      "text": "mpts to authenticate with all developer credentials until one succeeds, regardless of any errors previous developer credentials experienced. For example, a developer credential may attempt to get a token and fail, so `DefaultAzureCredential` will continue to the next credential in the flow. Deployed service credentials stop the flow with a thrown exception if they're able to attempt token retrieval, but don't receive one. Prior to version 1.14.0, developer credentials would similarly stop the authentication flow if token retrieval failed, but this is no longer the case.\n\nThis allows for trying all of t",
                      "markdown": "`mpts to authenticate with all developer credentials until one succeeds, regardless of any errors previous developer credentials experienced. For example, a developer credential may attempt to get a token and fail, so `DefaultAzureCredential` will continue to the next credential in the flow. Deployed service credentials stop the flow with a thrown exception if they're able to attempt token retrieval, but don't receive one. Prior to version 1.14.0, developer credentials would similarly stop the authentication flow if token retrieval failed, but this is no longer the case.\n\nThis allows for trying all of t`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 114,
                  "endLine": 84,
                  "endColumn": 123,
                  "snippet": {
                    "text": "\n### Credentials\n\nA credential is a class that contains or can obtain the data needed for a service client to authenticate requests. Service clients across the Azure SDK accept a credential instance when they're constructed, and use that credential to authenticate requests.\n\nThe Azure Identity library focuses on OAuth authentication with Microsoft Entra ID. It offers various credential classes capable of acquiring a Microsoft Entra access token. See the [Credential classes](#credential-classes \"Credential classes\") section for a list of this library's credential classes.\n\n",
                    "rendered": {
                      "text": "\n### Credentials\n\nA credential is a class that contains or can obtain the data needed for a service client to authenticate requests. Service clients across the Azure SDK accept a credential instance when they're constructed, and use that credential to authenticate requests.\n\nThe Azure Identity library focuses on OAuth authentication with Microsoft Entra ID. It offers various credential classes capable of acquiring a Microsoft Entra access token. See the [Credential classes](#credential-classes \"Credential classes\") section for a list of this library's credential classes.\n\n",
                      "markdown": "`\n### Credentials\n\nA credential is a class that contains or can obtain the data needed for a service client to authenticate requests. Service clients across the Azure SDK accept a credential instance when they're constructed, and use that credential to authenticate requests.\n\nThe Azure Identity library focuses on OAuth authentication with Microsoft Entra ID. It offers various credential classes capable of acquiring a Microsoft Entra access token. See the [Credential classes](#credential-classes \"Credential classes\") section for a list of this library's credential classes.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 73,
                  "endLine": 84,
                  "endColumn": 82,
                  "snippet": {
                    "text": "\n### Credentials\n\nA credential is a class that contains or can obtain the data needed for a service client to authenticate requests. Service clients across the Azure SDK accept a credential instance when they're constructed, and use that credential to authenticate requests.\n\nThe Azure Identity library focuses on OAuth authentication with Microsoft Entra ID. It offers various credential classes capable of acquiring a Microsoft Entra access token. See the [Credential classes](#credential-classes \"Credential classes\") section for a list of this library's credential classes.\n\n",
                    "rendered": {
                      "text": "\n### Credentials\n\nA credential is a class that contains or can obtain the data needed for a service client to authenticate requests. Service clients across the Azure SDK accept a credential instance when they're constructed, and use that credential to authenticate requests.\n\nThe Azure Identity library focuses on OAuth authentication with Microsoft Entra ID. It offers various credential classes capable of acquiring a Microsoft Entra access token. See the [Credential classes](#credential-classes \"Credential classes\") section for a list of this library's credential classes.\n\n",
                      "markdown": "`\n### Credentials\n\nA credential is a class that contains or can obtain the data needed for a service client to authenticate requests. Service clients across the Azure SDK accept a credential instance when they're constructed, and use that credential to authenticate requests.\n\nThe Azure Identity library focuses on OAuth authentication with Microsoft Entra ID. It offers various credential classes capable of acquiring a Microsoft Entra access token. See the [Credential classes](#credential-classes \"Credential classes\") section for a list of this library's credential classes.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/PKG-INFO"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 5,
                  "endLine": 46,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\nInstall Azure Identity with pip:\n\n```sh\npip install azure-identity\n```\n\n### Prerequisites\n",
                    "rendered": {
                      "text": "\nInstall Azure Identity with pip:\n\n```sh\npip install azure-identity\n```\n\n### Prerequisites\n",
                      "markdown": "`\nInstall Azure Identity with pip:\n\n```sh\npip install azure-identity\n```\n\n### Prerequisites\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/client_credential_base.py"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 29,
                  "endLine": 55,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        return AccessTokenInfo(\n            result[\"access_token\"],\n            request_time + int(result[\"expires_in\"]),\n            token_type=result.get(\"token_type\", \"Bearer\"),\n            refresh_on=refresh_on,\n        )\n",
                    "rendered": {
                      "text": "        return AccessTokenInfo(\n            result[\"access_token\"],\n            request_time + int(result[\"expires_in\"]),\n            token_type=result.get(\"token_type\", \"Bearer\"),\n            refresh_on=refresh_on,\n        )\n",
                      "markdown": "`        return AccessTokenInfo(\n            result[\"access_token\"],\n            request_time + int(result[\"expires_in\"]),\n            token_type=result.get(\"token_type\", \"Bearer\"),\n            refresh_on=refresh_on,\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/client_credential_base.py"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 98,
                  "endLine": 48,
                  "endColumn": 103,
                  "snippet": {
                    "text": "        request_time = int(time.time())\n        result = app.acquire_token_for_client(list(scopes), claims_challenge=kwargs.pop(\"claims\", None))\n        if \"access_token\" not in result:\n            message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n            raise ClientAuthenticationError(message=message)\n\n        refresh_on = int(result[\"refresh_on\"]) if \"refresh_on\" in result else None\n",
                    "rendered": {
                      "text": "        request_time = int(time.time())\n        result = app.acquire_token_for_client(list(scopes), claims_challenge=kwargs.pop(\"claims\", None))\n        if \"access_token\" not in result:\n            message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n            raise ClientAuthenticationError(message=message)\n\n        refresh_on = int(result[\"refresh_on\"]) if \"refresh_on\" in result else None\n",
                      "markdown": "`        request_time = int(time.time())\n        result = app.acquire_token_for_client(list(scopes), claims_challenge=kwargs.pop(\"claims\", None))\n        if \"access_token\" not in result:\n            message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n            raise ClientAuthenticationError(message=message)\n\n        refresh_on = int(result[\"refresh_on\"]) if \"refresh_on\" in result else None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/client_credential_base.py"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 63,
                  "endLine": 48,
                  "endColumn": 68,
                  "snippet": {
                    "text": "        request_time = int(time.time())\n        result = app.acquire_token_for_client(list(scopes), claims_challenge=kwargs.pop(\"claims\", None))\n        if \"access_token\" not in result:\n            message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n            raise ClientAuthenticationError(message=message)\n\n        refresh_on = int(result[\"refresh_on\"]) if \"refresh_on\" in result else None\n",
                    "rendered": {
                      "text": "        request_time = int(time.time())\n        result = app.acquire_token_for_client(list(scopes), claims_challenge=kwargs.pop(\"claims\", None))\n        if \"access_token\" not in result:\n            message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n            raise ClientAuthenticationError(message=message)\n\n        refresh_on = int(result[\"refresh_on\"]) if \"refresh_on\" in result else None\n",
                      "markdown": "`        request_time = int(time.time())\n        result = app.acquire_token_for_client(list(scopes), claims_challenge=kwargs.pop(\"claims\", None))\n        if \"access_token\" not in result:\n            message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n            raise ClientAuthenticationError(message=message)\n\n        refresh_on = int(result[\"refresh_on\"]) if \"refresh_on\" in result else None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/client_credential_base.py"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 33,
                  "endLine": 37,
                  "endColumn": 38,
                  "snippet": {
                    "text": "            return AccessTokenInfo(\n                result[\"access_token\"],\n                request_time + int(result[\"expires_in\"]),\n                token_type=result.get(\"token_type\", \"Bearer\"),\n                refresh_on=refresh_on,\n            )\n        return None\n",
                    "rendered": {
                      "text": "            return AccessTokenInfo(\n                result[\"access_token\"],\n                request_time + int(result[\"expires_in\"]),\n                token_type=result.get(\"token_type\", \"Bearer\"),\n                refresh_on=refresh_on,\n            )\n        return None\n",
                      "markdown": "`            return AccessTokenInfo(\n                result[\"access_token\"],\n                request_time + int(result[\"expires_in\"]),\n                token_type=result.get(\"token_type\", \"Bearer\"),\n                refresh_on=refresh_on,\n            )\n        return None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/client_credential_base.py"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 50,
                  "endLine": 23,
                  "endColumn": 59,
                  "snippet": {
                    "text": "\n\nclass ClientCredentialBase(MsalCredential, GetTokenMixin):\n    \"\"\"Base class for credentials authenticating a service principal with a certificate or secret\"\"\"\n\n    @wrap_exceptions\n    def _acquire_token_silently(self, *scopes: str, **kwargs: Any) -> Optional[AccessTokenInfo]:\n",
                    "rendered": {
                      "text": "\n\nclass ClientCredentialBase(MsalCredential, GetTokenMixin):\n    \"\"\"Base class for credentials authenticating a service principal with a certificate or secret\"\"\"\n\n    @wrap_exceptions\n    def _acquire_token_silently(self, *scopes: str, **kwargs: Any) -> Optional[AccessTokenInfo]:\n",
                      "markdown": "`\n\nclass ClientCredentialBase(MsalCredential, GetTokenMixin):\n    \"\"\"Base class for credentials authenticating a service principal with a certificate or secret\"\"\"\n\n    @wrap_exceptions\n    def _acquire_token_silently(self, *scopes: str, **kwargs: Any) -> Optional[AccessTokenInfo]:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/client_credential_base.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 6,
                  "endLine": 6,
                  "snippet": {
                    "text": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport time\nfrom typing import Any, Optional, Dict\n\nfrom azure.core.credentials import AccessTokenInfo\nfrom azure.core.exceptions import ClientAuthenticationError\n",
                    "rendered": {
                      "text": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport time\nfrom typing import Any, Optional, Dict\n\nfrom azure.core.credentials import AccessTokenInfo\nfrom azure.core.exceptions import ClientAuthenticationError\n",
                      "markdown": "`# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport time\nfrom typing import Any, Optional, Dict\n\nfrom azure.core.credentials import AccessTokenInfo\nfrom azure.core.exceptions import ClientAuthenticationError\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/auth_code_redirect_handler.py"
                },
                "region": {
                  "startLine": 42,
                  "startColumn": 35,
                  "endLine": 42,
                  "endColumn": 43,
                  "snippet": {
                    "text": "\n    def __init__(self, hostname, port, timeout):\n        # type: (str, int, int) -> None\n        HTTPServer.__init__(self, (hostname, port), AuthCodeRedirectHandler)\n        self.timeout = timeout\n\n    def wait_for_redirect(self):\n",
                    "rendered": {
                      "text": "\n    def __init__(self, hostname, port, timeout):\n        # type: (str, int, int) -> None\n        HTTPServer.__init__(self, (hostname, port), AuthCodeRedirectHandler)\n        self.timeout = timeout\n\n    def wait_for_redirect(self):\n",
                      "markdown": "`\n    def __init__(self, hostname, port, timeout):\n        # type: (str, int, int) -> None\n        HTTPServer.__init__(self, (hostname, port), AuthCodeRedirectHandler)\n        self.timeout = timeout\n\n    def wait_for_redirect(self):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/auth_code_redirect_handler.py"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 23,
                  "endLine": 40,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n    query_params = {}  # type: Mapping[str, Any]\n\n    def __init__(self, hostname, port, timeout):\n        # type: (str, int, int) -> None\n        HTTPServer.__init__(self, (hostname, port), AuthCodeRedirectHandler)\n        self.timeout = timeout\n",
                    "rendered": {
                      "text": "\n    query_params = {}  # type: Mapping[str, Any]\n\n    def __init__(self, hostname, port, timeout):\n        # type: (str, int, int) -> None\n        HTTPServer.__init__(self, (hostname, port), AuthCodeRedirectHandler)\n        self.timeout = timeout\n",
                      "markdown": "`\n    query_params = {}  # type: Mapping[str, Any]\n\n    def __init__(self, hostname, port, timeout):\n        # type: (str, int, int) -> None\n        HTTPServer.__init__(self, (hostname, port), AuthCodeRedirectHandler)\n        self.timeout = timeout\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/auth_code_redirect_handler.py"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 22,
                  "endLine": 44,
                  "snippet": {
                    "text": "    def __init__(self, hostname, port, timeout):\n        # type: (str, int, int) -> None\n        HTTPServer.__init__(self, (hostname, port), AuthCodeRedirectHandler)\n        self.timeout = timeout\n\n    def wait_for_redirect(self):\n        # type: () -> Mapping[str, Any]\n        while not self.query_params:\n",
                    "rendered": {
                      "text": "    def __init__(self, hostname, port, timeout):\n        # type: (str, int, int) -> None\n        HTTPServer.__init__(self, (hostname, port), AuthCodeRedirectHandler)\n        self.timeout = timeout\n\n    def wait_for_redirect(self):\n        # type: () -> Mapping[str, Any]\n        while not self.query_params:\n",
                      "markdown": "`    def __init__(self, hostname, port, timeout):\n        # type: (str, int, int) -> None\n        HTTPServer.__init__(self, (hostname, port), AuthCodeRedirectHandler)\n        self.timeout = timeout\n\n    def wait_for_redirect(self):\n        # type: () -> Mapping[str, Any]\n        while not self.query_params:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 55,
                  "endLine": 74,
                  "endColumn": 60,
                  "snippet": {
                    "text": "    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n                \"'tenant_id' is required. Please pass it in or set the \"\n",
                    "rendered": {
                      "text": "    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n                \"'tenant_id' is required. Please pass it in or set the \"\n",
                      "markdown": "`    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n                \"'tenant_id' is required. Please pass it in or set the \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 43,
                  "endLine": 73,
                  "endColumn": 48,
                  "snippet": {
                    "text": "        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n",
                    "rendered": {
                      "text": "        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n",
                      "markdown": "`        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 43,
                  "endLine": 72,
                  "endColumn": 48,
                  "snippet": {
                    "text": "        token_file_path: Optional[str] = None,\n        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n",
                    "rendered": {
                      "text": "        token_file_path: Optional[str] = None,\n        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n",
                      "markdown": "`        token_file_path: Optional[str] = None,\n        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 48,
                  "endLine": 74,
                  "endColumn": 59,
                  "snippet": {
                    "text": "    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n                \"'tenant_id' is required. Please pass it in or set the \"\n",
                    "rendered": {
                      "text": "    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n                \"'tenant_id' is required. Please pass it in or set the \"\n",
                      "markdown": "`    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n                \"'tenant_id' is required. Please pass it in or set the \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 36,
                  "endLine": 73,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n",
                    "rendered": {
                      "text": "        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n",
                      "markdown": "`        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 36,
                  "endLine": 72,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        token_file_path: Optional[str] = None,\n        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n",
                    "rendered": {
                      "text": "        token_file_path: Optional[str] = None,\n        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n",
                      "markdown": "`        token_file_path: Optional[str] = None,\n        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 76,
                  "endLine": 51,
                  "endColumn": 85,
                  "snippet": {
                    "text": "\n    :keyword str tenant_id: ID of the application's Microsoft Entra tenant. Also called its \"directory\" ID.\n    :keyword str client_id: The client ID of a Microsoft Entra app registration.\n    :keyword str token_file_path: The path to a file containing a Kubernetes service account token that authenticates\n        the identity.\n\n    .. admonition:: Example:\n",
                    "rendered": {
                      "text": "\n    :keyword str tenant_id: ID of the application's Microsoft Entra tenant. Also called its \"directory\" ID.\n    :keyword str client_id: The client ID of a Microsoft Entra app registration.\n    :keyword str token_file_path: The path to a file containing a Kubernetes service account token that authenticates\n        the identity.\n\n    .. admonition:: Example:\n",
                      "markdown": "`\n    :keyword str tenant_id: ID of the application's Microsoft Entra tenant. Also called its \"directory\" ID.\n    :keyword str client_id: The client ID of a Microsoft Entra app registration.\n    :keyword str token_file_path: The path to a file containing a Kubernetes service account token that authenticates\n        the identity.\n\n    .. admonition:: Example:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 21,
                  "endLine": 45,
                  "endColumn": 30,
                  "snippet": {
                    "text": "    Azure, you don't need to worry about storing and securing sensitive credentials themselves.\n\n    The WorkloadIdentityCredential supports Azure workload identity authentication on Azure Kubernetes and acquires\n    a token using the service account credentials available in the Azure Kubernetes environment. Refer\n    to `this workload identity overview <https://learn.microsoft.com/azure/aks/workload-identity-overview>`__\n    for more information.\n\n",
                    "rendered": {
                      "text": "    Azure, you don't need to worry about storing and securing sensitive credentials themselves.\n\n    The WorkloadIdentityCredential supports Azure workload identity authentication on Azure Kubernetes and acquires\n    a token using the service account credentials available in the Azure Kubernetes environment. Refer\n    to `this workload identity overview <https://learn.microsoft.com/azure/aks/workload-identity-overview>`__\n    for more information.\n\n",
                      "markdown": "`    Azure, you don't need to worry about storing and securing sensitive credentials themselves.\n\n    The WorkloadIdentityCredential supports Azure workload identity authentication on Azure Kubernetes and acquires\n    a token using the service account credentials available in the Azure Kubernetes environment. Refer\n    to `this workload identity overview <https://learn.microsoft.com/azure/aks/workload-identity-overview>`__\n    for more information.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 81,
                  "endLine": 40,
                  "endColumn": 90,
                  "snippet": {
                    "text": "incipal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using\n    workload identity authentication, you can avoid the need to manage and rotate service principals or managed\n    identities for each application on each VM. Additionally, because SACs are created automatically and managed by\n    Azure, you don't need to worry about storing and securing sensitive credentials themselves.\n\n    The WorkloadIdentityCredential supports Azure workload identi",
                    "rendered": {
                      "text": "incipal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using\n    workload identity authentication, you can avoid the need to manage and rotate service principals or managed\n    identities for each application on each VM. Additionally, because SACs are created automatically and managed by\n    Azure, you don't need to worry about storing and securing sensitive credentials themselves.\n\n    The WorkloadIdentityCredential supports Azure workload identi",
                      "markdown": "`incipal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using\n    workload identity authentication, you can avoid the need to manage and rotate service principals or managed\n    identities for each application on each VM. Additionally, because SACs are created automatically and managed by\n    Azure, you don't need to worry about storing and securing sensitive credentials themselves.\n\n    The WorkloadIdentityCredential supports Azure workload identi`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 111,
                  "endLine": 39,
                  "snippet": {
                    "text": "t the need for a service principal or managed identity. With workload\n    identity authentication, applications authenticate themselves using their own identity, rather than using a shared\n    service principal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using\n    workload identity authentication, you can avoid the need to manage and rotate service principals or managed\n    identities for each application on each VM. Additionally, because SACs ",
                    "rendered": {
                      "text": "t the need for a service principal or managed identity. With workload\n    identity authentication, applications authenticate themselves using their own identity, rather than using a shared\n    service principal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using\n    workload identity authentication, you can avoid the need to manage and rotate service principals or managed\n    identities for each application on each VM. Additionally, because SACs ",
                      "markdown": "`t the need for a service principal or managed identity. With workload\n    identity authentication, applications authenticate themselves using their own identity, rather than using a shared\n    service principal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using\n    workload identity authentication, you can avoid the need to manage and rotate service principals or managed\n    identities for each application on each VM. Additionally, because SACs `"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 3,
                  "endLine": 38,
                  "endColumn": 12,
                  "snippet": {
                    "text": " Azure that allows applications running on virtual machines (VMs)\n    to access other Azure resources without the need for a service principal or managed identity. With workload\n    identity authentication, applications authenticate themselves using their own identity, rather than using a shared\n    service principal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using\n    workload identity authentication, you can avoid the need to manage and rota",
                    "rendered": {
                      "text": " Azure that allows applications running on virtual machines (VMs)\n    to access other Azure resources without the need for a service principal or managed identity. With workload\n    identity authentication, applications authenticate themselves using their own identity, rather than using a shared\n    service principal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using\n    workload identity authentication, you can avoid the need to manage and rota",
                      "markdown": "` Azure that allows applications running on virtual machines (VMs)\n    to access other Azure resources without the need for a service principal or managed identity. With workload\n    identity authentication, applications authenticate themselves using their own identity, rather than using a shared\n    service principal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using\n    workload identity authentication, you can avoid the need to manage and rota`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 58,
                  "endLine": 36,
                  "endColumn": 67,
                  "snippet": {
                    "text": "loadIdentityCredential(ClientAssertionCredential, TokenFileMixin):\n    \"\"\"Authenticates using Microsoft Entra Workload ID.\n\n    Workload identity authentication is a feature in Azure that allows applications running on virtual machines (VMs)\n    to access other Azure resources without the need for a service principal or managed identity. With workload\n    identity authentication, applications authenticate themselves using their own identity, rather than using a shared\n    service principal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Cred",
                    "rendered": {
                      "text": "loadIdentityCredential(ClientAssertionCredential, TokenFileMixin):\n    \"\"\"Authenticates using Microsoft Entra Workload ID.\n\n    Workload identity authentication is a feature in Azure that allows applications running on virtual machines (VMs)\n    to access other Azure resources without the need for a service principal or managed identity. With workload\n    identity authentication, applications authenticate themselves using their own identity, rather than using a shared\n    service principal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Cred",
                      "markdown": "`loadIdentityCredential(ClientAssertionCredential, TokenFileMixin):\n    \"\"\"Authenticates using Microsoft Entra Workload ID.\n\n    Workload identity authentication is a feature in Azure that allows applications running on virtual machines (VMs)\n    to access other Azure resources without the need for a service principal or managed identity. With workload\n    identity authentication, applications authenticate themselves using their own identity, rather than using a shared\n    service principal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Cred`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 6,
                  "endLine": 7,
                  "snippet": {
                    "text": "# Licensed under the MIT License.\n# ------------------------------------\nimport os\nimport time\nfrom typing import Any\nfrom typing import Optional\n\nfrom .client_assertion import ClientAssertionCredential\n",
                    "rendered": {
                      "text": "# Licensed under the MIT License.\n# ------------------------------------\nimport os\nimport time\nfrom typing import Any\nfrom typing import Optional\n\nfrom .client_assertion import ClientAssertionCredential\n",
                      "markdown": "`# Licensed under the MIT License.\n# ------------------------------------\nimport os\nimport time\nfrom typing import Any\nfrom typing import Optional\n\nfrom .client_assertion import ClientAssertionCredential\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 274,
                  "startColumn": 21,
                  "endLine": 274,
                  "endColumn": 26,
                  "snippet": {
                    "text": "            message = sanitize_output(ex.stderr)\n        else:\n            message = \"Failed to invoke Azure Developer CLI\"\n        if within_dac.get():\n            raise CredentialUnavailableError(message=message) from ex\n        raise ClientAuthenticationError(message=message) from ex\n    except OSError as ex:\n",
                    "rendered": {
                      "text": "            message = sanitize_output(ex.stderr)\n        else:\n            message = \"Failed to invoke Azure Developer CLI\"\n        if within_dac.get():\n            raise CredentialUnavailableError(message=message) from ex\n        raise ClientAuthenticationError(message=message) from ex\n    except OSError as ex:\n",
                      "markdown": "`            message = sanitize_output(ex.stderr)\n        else:\n            message = \"Failed to invoke Azure Developer CLI\"\n        if within_dac.get():\n            raise CredentialUnavailableError(message=message) from ex\n        raise ClientAuthenticationError(message=message) from ex\n    except OSError as ex:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 219,
                  "startColumn": 25,
                  "endLine": 219,
                  "endColumn": 30,
                  "snippet": {
                    "text": "    \"\"\"\n\n    if sys.platform.startswith(\"win\"):\n        path = os.environ.get(\"SYSTEMROOT\")\n        if not path:\n            raise CredentialUnavailableError(\n                message=\"Azure Developer CLI credential\" + \" expects a 'SystemRoot' environment variable\"\n",
                    "rendered": {
                      "text": "    \"\"\"\n\n    if sys.platform.startswith(\"win\"):\n        path = os.environ.get(\"SYSTEMROOT\")\n        if not path:\n            raise CredentialUnavailableError(\n                message=\"Azure Developer CLI credential\" + \" expects a 'SystemRoot' environment variable\"\n",
                      "markdown": "`    \"\"\"\n\n    if sys.platform.startswith(\"win\"):\n        path = os.environ.get(\"SYSTEMROOT\")\n        if not path:\n            raise CredentialUnavailableError(\n                message=\"Azure Developer CLI credential\" + \" expects a 'SystemRoot' environment variable\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 183,
                  "startColumn": 25,
                  "endLine": 183,
                  "endColumn": 30,
                  "snippet": {
                    "text": "                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azdevclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n                raise CredentialUnavailableError(message=message)\n            raise ClientAuthenticationError(message=message)\n\n",
                    "rendered": {
                      "text": "                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azdevclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n                raise CredentialUnavailableError(message=message)\n            raise ClientAuthenticationError(message=message)\n\n",
                      "markdown": "`                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azdevclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n                raise CredentialUnavailableError(message=message)\n            raise ClientAuthenticationError(message=message)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 157,
                  "startColumn": 27,
                  "endLine": 157,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        if not scopes:\n            raise ValueError(\"Missing scope in request. \\n\")\n\n        tenant_id = options.get(\"tenant_id\") if options else None\n        if tenant_id:\n            validate_tenant_id(tenant_id)\n        for scope in scopes:\n",
                    "rendered": {
                      "text": "        if not scopes:\n            raise ValueError(\"Missing scope in request. \\n\")\n\n        tenant_id = options.get(\"tenant_id\") if options else None\n        if tenant_id:\n            validate_tenant_id(tenant_id)\n        for scope in scopes:\n",
                      "markdown": "`        if not scopes:\n            raise ValueError(\"Missing scope in request. \\n\")\n\n        tenant_id = options.get(\"tenant_id\") if options else None\n        if tenant_id:\n            validate_tenant_id(tenant_id)\n        for scope in scopes:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 219,
                  "startColumn": 18,
                  "endLine": 219,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    \"\"\"\n\n    if sys.platform.startswith(\"win\"):\n        path = os.environ.get(\"SYSTEMROOT\")\n        if not path:\n            raise CredentialUnavailableError(\n                message=\"Azure Developer CLI credential\" + \" expects a 'SystemRoot' environment variable\"\n",
                    "rendered": {
                      "text": "    \"\"\"\n\n    if sys.platform.startswith(\"win\"):\n        path = os.environ.get(\"SYSTEMROOT\")\n        if not path:\n            raise CredentialUnavailableError(\n                message=\"Azure Developer CLI credential\" + \" expects a 'SystemRoot' environment variable\"\n",
                      "markdown": "`    \"\"\"\n\n    if sys.platform.startswith(\"win\"):\n        path = os.environ.get(\"SYSTEMROOT\")\n        if not path:\n            raise CredentialUnavailableError(\n                message=\"Azure Developer CLI credential\" + \" expects a 'SystemRoot' environment variable\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 180,
                  "startColumn": 93,
                  "endLine": 180,
                  "endColumn": 97,
                  "snippet": {
                    "text": "            sanitized_output = sanitize_output(output)\n            message = (\n                f\"Unexpected output from Azure Developer CLI: '{sanitized_output}'. \\n\"\n                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azdevclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n",
                    "rendered": {
                      "text": "            sanitized_output = sanitize_output(output)\n            message = (\n                f\"Unexpected output from Azure Developer CLI: '{sanitized_output}'. \\n\"\n                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azdevclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n",
                      "markdown": "`            sanitized_output = sanitize_output(output)\n            message = (\n                f\"Unexpected output from Azure Developer CLI: '{sanitized_output}'. \\n\"\n                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azdevclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 136,
                  "startColumn": 84,
                  "endLine": 136,
                  "endColumn": 88,
                  "snippet": {
                    "text": "on the token. This method is called automatically by Azure SDK clients. Applications calling this method\n        directly must also handle token caching because this credential doesn't cache the tokens it acquires.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials",
                    "rendered": {
                      "text": "on the token. This method is called automatically by Azure SDK clients. Applications calling this method\n        directly must also handle token caching because this credential doesn't cache the tokens it acquires.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials",
                      "markdown": "`on the token. This method is called automatically by Azure SDK clients. Applications calling this method\n        directly must also handle token caching because this credential doesn't cache the tokens it acquires.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 55,
                  "endLine": 51,
                  "endColumn": 61,
                  "snippet": {
                    "text": "      * Run \"azd auth login --client-id 'client_id' --client-secret 'client_secret' --tenant-id 'tenant_id'\"\n        to authenticate as a service principal.\n\n    You may need to repeat this process after a certain time period, depending on the refresh token validity in your\n    organization. Generally, the refresh token validity period is a few weeks to a few months.\n    AzureDeveloperCliCredential will prompt you to sign in again.\n\n",
                    "rendered": {
                      "text": "      * Run \"azd auth login --client-id 'client_id' --client-secret 'client_secret' --tenant-id 'tenant_id'\"\n        to authenticate as a service principal.\n\n    You may need to repeat this process after a certain time period, depending on the refresh token validity in your\n    organization. Generally, the refresh token validity period is a few weeks to a few months.\n    AzureDeveloperCliCredential will prompt you to sign in again.\n\n",
                      "markdown": "`      * Run \"azd auth login --client-id 'client_id' --client-secret 'client_secret' --tenant-id 'tenant_id'\"\n        to authenticate as a service principal.\n\n    You may need to repeat this process after a certain time period, depending on the refresh token validity in your\n    organization. Generally, the refresh token validity period is a few weeks to a few months.\n    AzureDeveloperCliCredential will prompt you to sign in again.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 28,
                  "endLine": 49,
                  "endColumn": 37,
                  "snippet": {
                    "text": "\n      * Run \"azd auth login\" in Azure Developer CLI to authenticate interactively as a user.\n      * Run \"azd auth login --client-id 'client_id' --client-secret 'client_secret' --tenant-id 'tenant_id'\"\n        to authenticate as a service principal.\n\n    You may need to repeat this process after a certain time period, depending on the refresh token validity in your\n    organization. Generally, the refresh token validity period is a few weeks to a few months.\n",
                    "rendered": {
                      "text": "\n      * Run \"azd auth login\" in Azure Developer CLI to authenticate interactively as a user.\n      * Run \"azd auth login --client-id 'client_id' --client-secret 'client_secret' --tenant-id 'tenant_id'\"\n        to authenticate as a service principal.\n\n    You may need to repeat this process after a certain time period, depending on the refresh token validity in your\n    organization. Generally, the refresh token validity period is a few weeks to a few months.\n",
                      "markdown": "`\n      * Run \"azd auth login\" in Azure Developer CLI to authenticate interactively as a user.\n      * Run \"azd auth login --client-id 'client_id' --client-secret 'client_secret' --tenant-id 'tenant_id'\"\n        to authenticate as a service principal.\n\n    You may need to repeat this process after a certain time period, depending on the refresh token validity in your\n    organization. Generally, the refresh token validity period is a few weeks to a few months.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 6,
                  "endLine": 41,
                  "endColumn": 15,
                  "snippet": {
                    "text": "    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n    the logged-in user or service principal in Azure Developer CLI. It acts as the Azure Developer CLI logged-in user\n    or service principal and executes an Azure CLI command underneath to authenticate the application against\n    Microsoft Entra ID.\n\n    To use this credential, the developer needs to authenticate locally in Azure Developer CLI using one of the\n",
                    "rendered": {
                      "text": "    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n    the logged-in user or service principal in Azure Developer CLI. It acts as the Azure Developer CLI logged-in user\n    or service principal and executes an Azure CLI command underneath to authenticate the application against\n    Microsoft Entra ID.\n\n    To use this credential, the developer needs to authenticate locally in Azure Developer CLI using one of the\n",
                      "markdown": "`    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n    the logged-in user or service principal in Azure Developer CLI. It acts as the Azure Developer CLI logged-in user\n    or service principal and executes an Azure CLI command underneath to authenticate the application against\n    Microsoft Entra ID.\n\n    To use this credential, the developer needs to authenticate locally in Azure Developer CLI using one of the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 25,
                  "endLine": 40,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    to Azure developers. It allows users to authenticate as a user and/or a service principal against\n    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n    the logged-in user or service principal in Azure Developer CLI. It acts as the Azure Developer CLI logged-in user\n    or service principal and executes an Azure CLI command underneath to authenticate the application against\n    Microsoft Entra ID.\n\n",
                    "rendered": {
                      "text": "    to Azure developers. It allows users to authenticate as a user and/or a service principal against\n    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n    the logged-in user or service principal in Azure Developer CLI. It acts as the Azure Developer CLI logged-in user\n    or service principal and executes an Azure CLI command underneath to authenticate the application against\n    Microsoft Entra ID.\n\n",
                      "markdown": "`    to Azure developers. It allows users to authenticate as a user and/or a service principal against\n    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n    the logged-in user or service principal in Azure Developer CLI. It acts as the Azure Developer CLI logged-in user\n    or service principal and executes an Azure CLI command underneath to authenticate the application against\n    Microsoft Entra ID.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 75,
                  "endLine": 37,
                  "endColumn": 84,
                  "snippet": {
                    "text": "er CLI.\n\n    Azure Developer CLI is a command-line interface tool that allows developers to create, manage, and deploy\n    resources in Azure. It's built on top of the Azure CLI and provides additional functionality specific\n    to Azure developers. It allows users to authenticate as a user and/or a service principal against\n    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n    the logged-in user or service principal in Azure Developer CLI. It acts as the Azure ",
                    "rendered": {
                      "text": "er CLI.\n\n    Azure Developer CLI is a command-line interface tool that allows developers to create, manage, and deploy\n    resources in Azure. It's built on top of the Azure CLI and provides additional functionality specific\n    to Azure developers. It allows users to authenticate as a user and/or a service principal against\n    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n    the logged-in user or service principal in Azure Developer CLI. It acts as the Azure ",
                      "markdown": "`er CLI.\n\n    Azure Developer CLI is a command-line interface tool that allows developers to create, manage, and deploy\n    resources in Azure. It's built on top of the Azure CLI and provides additional functionality specific\n    to Azure developers. It allows users to authenticate as a user and/or a service principal against\n    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n    the logged-in user or service principal in Azure Developer CLI. It acts as the Azure `"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 37,
                  "endLine": 36,
                  "endColumn": 42,
                  "snippet": {
                    "text": "    \"\"\"Authenticates by requesting a token from the Azure Developer CLI.\n\n    Azure Developer CLI is a command-line interface tool that allows developers to create, manage, and deploy\n    resources in Azure. It's built on top of the Azure CLI and provides additional functionality specific\n    to Azure developers. It allows users to authenticate as a user and/or a service principal against\n    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n",
                    "rendered": {
                      "text": "    \"\"\"Authenticates by requesting a token from the Azure Developer CLI.\n\n    Azure Developer CLI is a command-line interface tool that allows developers to create, manage, and deploy\n    resources in Azure. It's built on top of the Azure CLI and provides additional functionality specific\n    to Azure developers. It allows users to authenticate as a user and/or a service principal against\n    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n",
                      "markdown": "`    \"\"\"Authenticates by requesting a token from the Azure Developer CLI.\n\n    Azure Developer CLI is a command-line interface tool that allows developers to create, manage, and deploy\n    resources in Azure. It's built on top of the Azure CLI and provides additional functionality specific\n    to Azure developers. It allows users to authenticate as a user and/or a service principal against\n    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/managed_identity_client.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 6,
                  "endLine": 6,
                  "snippet": {
                    "text": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport time\nfrom typing import TypeVar\n\nfrom azure.core.credentials import AccessTokenInfo\nfrom azure.core.pipeline import AsyncPipeline\n",
                    "rendered": {
                      "text": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport time\nfrom typing import TypeVar\n\nfrom azure.core.credentials import AccessTokenInfo\nfrom azure.core.pipeline import AsyncPipeline\n",
                      "markdown": "`# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport time\nfrom typing import TypeVar\n\nfrom azure.core.credentials import AccessTokenInfo\nfrom azure.core.pipeline import AsyncPipeline\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 158,
                  "startColumn": 56,
                  "endLine": 158,
                  "endColumn": 61,
                  "snippet": {
                    "text": "\n        except Exception as ex:\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s.%s failed: %s\",\n                self.__class__.__name__,\n                base_method_name,\n",
                    "rendered": {
                      "text": "\n        except Exception as ex:\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s.%s failed: %s\",\n                self.__class__.__name__,\n                base_method_name,\n",
                      "markdown": "`\n        except Exception as ex:\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s.%s failed: %s\",\n                self.__class__.__name__,\n                base_method_name,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 149,
                  "startColumn": 56,
                  "endLine": 149,
                  "endColumn": 61,
                  "snippet": {
                    "text": "                except Exception:  # pylint:disable=broad-except\n                    pass\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.INFO,\n                \"%s.%s succeeded\",\n                self.__class__.__name__,\n                base_method_name,\n",
                    "rendered": {
                      "text": "                except Exception:  # pylint:disable=broad-except\n                    pass\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.INFO,\n                \"%s.%s succeeded\",\n                self.__class__.__name__,\n                base_method_name,\n",
                      "markdown": "`                except Exception:  # pylint:disable=broad-except\n                    pass\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.INFO,\n                \"%s.%s succeeded\",\n                self.__class__.__name__,\n                base_method_name,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 129,
                  "startColumn": 28,
                  "endLine": 129,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        try:\n            token = await self._acquire_token_silently(\n",
                    "rendered": {
                      "text": "        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        try:\n            token = await self._acquire_token_silently(\n",
                      "markdown": "`        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        try:\n            token = await self._acquire_token_silently(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 27,
                  "endLine": 128,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        try:\n",
                    "rendered": {
                      "text": "\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        try:\n",
                      "markdown": "`\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 127,
                  "startColumn": 24,
                  "endLine": 127,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            raise ValueError(f'\"{base_method_name}\" requires at least one scope')\n\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n",
                    "rendered": {
                      "text": "            raise ValueError(f'\"{base_method_name}\" requires at least one scope')\n\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n",
                      "markdown": "`            raise ValueError(f'\"{base_method_name}\" requires at least one scope')\n\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 124,
                  "startColumn": 60,
                  "endLine": 124,
                  "endColumn": 64,
                  "snippet": {
                    "text": "        **kwargs: Any,\n    ) -> AccessTokenInfo:\n        if not scopes:\n            raise ValueError(f'\"{base_method_name}\" requires at least one scope')\n\n        options = options or {}\n        claims = options.get(\"claims\")\n",
                    "rendered": {
                      "text": "        **kwargs: Any,\n    ) -> AccessTokenInfo:\n        if not scopes:\n            raise ValueError(f'\"{base_method_name}\" requires at least one scope')\n\n        options = options or {}\n        claims = options.get(\"claims\")\n",
                      "markdown": "`        **kwargs: Any,\n    ) -> AccessTokenInfo:\n        if not scopes:\n            raise ValueError(f'\"{base_method_name}\" requires at least one scope')\n\n        options = options or {}\n        claims = options.get(\"claims\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 84,
                  "endLine": 102,
                  "endColumn": 88,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 70,
                  "startColumn": 84,
                  "endLine": 70,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 84,
                  "endLine": 40,
                  "endColumn": 88,
                  "snippet": {
                    "text": "    async def _request_token(self, *scopes: str, **kwargs) -> AccessTokenInfo:\n        \"\"\"Request an access token from the STS.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n\n",
                    "rendered": {
                      "text": "    async def _request_token(self, *scopes: str, **kwargs) -> AccessTokenInfo:\n        \"\"\"Request an access token from the STS.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n\n",
                      "markdown": "`    async def _request_token(self, *scopes: str, **kwargs) -> AccessTokenInfo:\n        \"\"\"Request an access token from the STS.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 84,
                  "endLine": 28,
                  "endColumn": 88,
                  "snippet": {
                    "text": "    async def _acquire_token_silently(self, *scopes: str, **kwargs) -> Optional[AccessTokenInfo]:\n        \"\"\"Attempt to acquire an access token from a cache or by redeeming a refresh token.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n\n",
                    "rendered": {
                      "text": "    async def _acquire_token_silently(self, *scopes: str, **kwargs) -> Optional[AccessTokenInfo]:\n        \"\"\"Attempt to acquire an access token from a cache or by redeeming a refresh token.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n\n",
                      "markdown": "`    async def _acquire_token_silently(self, *scopes: str, **kwargs) -> Optional[AccessTokenInfo]:\n        \"\"\"Attempt to acquire an access token from a cache or by redeeming a refresh token.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 6,
                  "endLine": 8,
                  "snippet": {
                    "text": "# ------------------------------------\nimport abc\nimport logging\nimport time\nfrom typing import Any, Optional\n\nfrom azure.core.credentials import AccessToken, AccessTokenInfo, TokenRequestOptions\nfrom ..._constants import DEFAULT_REFRESH_OFFSET, DEFAULT_TOKEN_REFRESH_RETRY_DELAY\n",
                    "rendered": {
                      "text": "# ------------------------------------\nimport abc\nimport logging\nimport time\nfrom typing import Any, Optional\n\nfrom azure.core.credentials import AccessToken, AccessTokenInfo, TokenRequestOptions\nfrom ..._constants import DEFAULT_REFRESH_OFFSET, DEFAULT_TOKEN_REFRESH_RETRY_DELAY\n",
                      "markdown": "`# ------------------------------------\nimport abc\nimport logging\nimport time\nfrom typing import Any, Optional\n\nfrom azure.core.credentials import AccessToken, AccessTokenInfo, TokenRequestOptions\nfrom ..._constants import DEFAULT_REFRESH_OFFSET, DEFAULT_TOKEN_REFRESH_RETRY_DELAY\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/shared_token_cache.py"
                },
                "region": {
                  "startLine": 247,
                  "startColumn": 69,
                  "endLine": 247,
                  "endColumn": 74,
                  "snippet": {
                    "text": "                refresh_on = int(token[\"refresh_on\"]) if \"refresh_on\" in token else None\n                if expires_on - 300 > int(time.time()):\n                    return AccessTokenInfo(\n                        token[\"secret\"], expires_on, token_type=token.get(\"token_type\", \"Bearer\"), refresh_on=refresh_on\n                    )\n        except Exception as ex:  # pylint:disable=broad-except\n            message = \"Error accessing cached data: {}\".format(ex)\n",
                    "rendered": {
                      "text": "                refresh_on = int(token[\"refresh_on\"]) if \"refresh_on\" in token else None\n                if expires_on - 300 > int(time.time()):\n                    return AccessTokenInfo(\n                        token[\"secret\"], expires_on, token_type=token.get(\"token_type\", \"Bearer\"), refresh_on=refresh_on\n                    )\n        except Exception as ex:  # pylint:disable=broad-except\n            message = \"Error accessing cached data: {}\".format(ex)\n",
                      "markdown": "`                refresh_on = int(token[\"refresh_on\"]) if \"refresh_on\" in token else None\n                if expires_on - 300 > int(time.time()):\n                    return AccessTokenInfo(\n                        token[\"secret\"], expires_on, token_type=token.get(\"token_type\", \"Bearer\"), refresh_on=refresh_on\n                    )\n        except Exception as ex:  # pylint:disable=broad-except\n            message = \"Error accessing cached data: {}\".format(ex)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/shared_token_cache.py"
                },
                "region": {
                  "startLine": 189,
                  "startColumn": 45,
                  "endLine": 189,
                  "endColumn": 50,
                  "snippet": {
                    "text": "                # which won't work for the shared cache because we don't know the IDs of\n                # all contributing apps. It should be unnecessary anyway because the\n                # apps should all belong to the family.\n                if home_account_id == account.get(\"home_account_id\") and \"family_id\" in refresh_token:\n                    accounts[account[\"home_account_id\"]] = account\n        return accounts.values()\n\n",
                    "rendered": {
                      "text": "                # which won't work for the shared cache because we don't know the IDs of\n                # all contributing apps. It should be unnecessary anyway because the\n                # apps should all belong to the family.\n                if home_account_id == account.get(\"home_account_id\") and \"family_id\" in refresh_token:\n                    accounts[account[\"home_account_id\"]] = account\n        return accounts.values()\n\n",
                      "markdown": "`                # which won't work for the shared cache because we don't know the IDs of\n                # all contributing apps. It should be unnecessary anyway because the\n                # apps should all belong to the family.\n                if home_account_id == account.get(\"home_account_id\") and \"family_id\" in refresh_token:\n                    accounts[account[\"home_account_id\"]] = account\n        return accounts.values()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/shared_token_cache.py"
                },
                "region": {
                  "startLine": 181,
                  "startColumn": 43,
                  "endLine": 181,
                  "endColumn": 48,
                  "snippet": {
                    "text": "\n        accounts = {}\n        for refresh_token in refresh_tokens:\n            home_account_id = refresh_token.get(\"home_account_id\")\n            if not home_account_id:\n                continue\n            for account in all_accounts:\n",
                    "rendered": {
                      "text": "\n        accounts = {}\n        for refresh_token in refresh_tokens:\n            home_account_id = refresh_token.get(\"home_account_id\")\n            if not home_account_id:\n                continue\n            for account in all_accounts:\n",
                      "markdown": "`\n        accounts = {}\n        for refresh_token in refresh_tokens:\n            home_account_id = refresh_token.get(\"home_account_id\")\n            if not home_account_id:\n                continue\n            for account in all_accounts:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/shared_token_cache.py"
                },
                "region": {
                  "startLine": 163,
                  "startColumn": 30,
                  "endLine": 163,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        cache = cast(msal.TokenCache, self._cae_cache if is_cae else self._cache)\n        items = []\n        for item in cache.search(credential_type):\n            environment = item.get(\"environment\")\n            if environment in self._environment_aliases:\n                items.append(item)\n        return items\n",
                    "rendered": {
                      "text": "        cache = cast(msal.TokenCache, self._cae_cache if is_cae else self._cache)\n        items = []\n        for item in cache.search(credential_type):\n            environment = item.get(\"environment\")\n            if environment in self._environment_aliases:\n                items.append(item)\n        return items\n",
                      "markdown": "`        cache = cast(msal.TokenCache, self._cae_cache if is_cae else self._cache)\n        items = []\n        for item in cache.search(credential_type):\n            environment = item.get(\"environment\")\n            if environment in self._environment_aliases:\n                items.append(item)\n        return items\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/shared_token_cache.py"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 49,
                  "endLine": 94,
                  "endColumn": 54,
                  "snippet": {
                    "text": "    ) -> None:  # pylint:disable=unused-argument\n        self._authority = normalize_authority(authority) if authority else get_default_authority()\n        environment = urlparse(self._authority).netloc\n        self._environment_aliases = KNOWN_ALIASES.get(environment) or frozenset((environment,))\n        self._username = username\n        self._tenant_id = tenant_id\n        self._cache = kwargs.pop(\"_cache\", None)\n",
                    "rendered": {
                      "text": "    ) -> None:  # pylint:disable=unused-argument\n        self._authority = normalize_authority(authority) if authority else get_default_authority()\n        environment = urlparse(self._authority).netloc\n        self._environment_aliases = KNOWN_ALIASES.get(environment) or frozenset((environment,))\n        self._username = username\n        self._tenant_id = tenant_id\n        self._cache = kwargs.pop(\"_cache\", None)\n",
                      "markdown": "`    ) -> None:  # pylint:disable=unused-argument\n        self._authority = normalize_authority(authority) if authority else get_default_authority()\n        environment = urlparse(self._authority).netloc\n        self._environment_aliases = KNOWN_ALIASES.get(environment) or frozenset((environment,))\n        self._username = username\n        self._tenant_id = tenant_id\n        self._cache = kwargs.pop(\"_cache\", None)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/shared_token_cache.py"
                },
                "region": {
                  "startLine": 70,
                  "startColumn": 31,
                  "endLine": 70,
                  "endColumn": 36,
                  "snippet": {
                    "text": "\n    filtered_accounts = []\n    for account in accounts:\n        if username and account.get(\"username\") != username:\n            continue\n        if tenant_id:\n            try:\n",
                    "rendered": {
                      "text": "\n    filtered_accounts = []\n    for account in accounts:\n        if username and account.get(\"username\") != username:\n            continue\n        if tenant_id:\n            try:\n",
                      "markdown": "`\n    filtered_accounts = []\n    for account in accounts:\n        if username and account.get(\"username\") != username:\n            continue\n        if tenant_id:\n            try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/shared_token_cache.py"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 29,
                  "endLine": 50,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\ndef _account_to_string(account):\n    username = account.get(\"username\")\n    home_account_id = account.get(\"home_account_id\", \"\").split(\".\")\n    tenant_id = home_account_id[-1] if len(home_account_id) == 2 else \"\"\n    return \"(username: {}, tenant: {})\".format(username, tenant_id)\n\n",
                    "rendered": {
                      "text": "\ndef _account_to_string(account):\n    username = account.get(\"username\")\n    home_account_id = account.get(\"home_account_id\", \"\").split(\".\")\n    tenant_id = home_account_id[-1] if len(home_account_id) == 2 else \"\"\n    return \"(username: {}, tenant: {})\".format(username, tenant_id)\n\n",
                      "markdown": "`\ndef _account_to_string(account):\n    username = account.get(\"username\")\n    home_account_id = account.get(\"home_account_id\", \"\").split(\".\")\n    tenant_id = home_account_id[-1] if len(home_account_id) == 2 else \"\"\n    return \"(username: {}, tenant: {})\".format(username, tenant_id)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/shared_token_cache.py"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 22,
                  "endLine": 49,
                  "endColumn": 27,
                  "snippet": {
                    "text": "\n\ndef _account_to_string(account):\n    username = account.get(\"username\")\n    home_account_id = account.get(\"home_account_id\", \"\").split(\".\")\n    tenant_id = home_account_id[-1] if len(home_account_id) == 2 else \"\"\n    return \"(username: {}, tenant: {})\".format(username, tenant_id)\n",
                    "rendered": {
                      "text": "\n\ndef _account_to_string(account):\n    username = account.get(\"username\")\n    home_account_id = account.get(\"home_account_id\", \"\").split(\".\")\n    tenant_id = home_account_id[-1] if len(home_account_id) == 2 else \"\"\n    return \"(username: {}, tenant: {})\".format(username, tenant_id)\n",
                      "markdown": "`\n\ndef _account_to_string(account):\n    username = account.get(\"username\")\n    home_account_id = account.get(\"home_account_id\", \"\").split(\".\")\n    tenant_id = home_account_id[-1] if len(home_account_id) == 2 else \"\"\n    return \"(username: {}, tenant: {})\".format(username, tenant_id)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/shared_token_cache.py"
                },
                "region": {
                  "startLine": 163,
                  "startColumn": 12,
                  "endLine": 163,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        cache = cast(msal.TokenCache, self._cae_cache if is_cae else self._cache)\n        items = []\n        for item in cache.search(credential_type):\n            environment = item.get(\"environment\")\n            if environment in self._environment_aliases:\n                items.append(item)\n        return items\n",
                    "rendered": {
                      "text": "        cache = cast(msal.TokenCache, self._cae_cache if is_cae else self._cache)\n        items = []\n        for item in cache.search(credential_type):\n            environment = item.get(\"environment\")\n            if environment in self._environment_aliases:\n                items.append(item)\n        return items\n",
                      "markdown": "`        cache = cast(msal.TokenCache, self._cae_cache if is_cae else self._cache)\n        items = []\n        for item in cache.search(credential_type):\n            environment = item.get(\"environment\")\n            if environment in self._environment_aliases:\n                items.append(item)\n        return items\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/shared_token_cache.py"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 14,
                  "endLine": 94,
                  "endColumn": 53,
                  "snippet": {
                    "text": "    ) -> None:  # pylint:disable=unused-argument\n        self._authority = normalize_authority(authority) if authority else get_default_authority()\n        environment = urlparse(self._authority).netloc\n        self._environment_aliases = KNOWN_ALIASES.get(environment) or frozenset((environment,))\n        self._username = username\n        self._tenant_id = tenant_id\n        self._cache = kwargs.pop(\"_cache\", None)\n",
                    "rendered": {
                      "text": "    ) -> None:  # pylint:disable=unused-argument\n        self._authority = normalize_authority(authority) if authority else get_default_authority()\n        environment = urlparse(self._authority).netloc\n        self._environment_aliases = KNOWN_ALIASES.get(environment) or frozenset((environment,))\n        self._username = username\n        self._tenant_id = tenant_id\n        self._cache = kwargs.pop(\"_cache\", None)\n",
                      "markdown": "`    ) -> None:  # pylint:disable=unused-argument\n        self._authority = normalize_authority(authority) if authority else get_default_authority()\n        environment = urlparse(self._authority).netloc\n        self._environment_aliases = KNOWN_ALIASES.get(environment) or frozenset((environment,))\n        self._username = username\n        self._tenant_id = tenant_id\n        self._cache = kwargs.pop(\"_cache\", None)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/shared_token_cache.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 6,
                  "endLine": 8,
                  "snippet": {
                    "text": "# ------------------------------------\nimport abc\nimport platform\nimport time\nfrom typing import Any, Iterable, List, Mapping, Optional, cast, Dict\nfrom urllib.parse import urlparse\nimport msal\n\n",
                    "rendered": {
                      "text": "# ------------------------------------\nimport abc\nimport platform\nimport time\nfrom typing import Any, Iterable, List, Mapping, Optional, cast, Dict\nfrom urllib.parse import urlparse\nimport msal\n\n",
                      "markdown": "`# ------------------------------------\nimport abc\nimport platform\nimport time\nfrom typing import Any, Iterable, List, Mapping, Optional, cast, Dict\nfrom urllib.parse import urlparse\nimport msal\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_managed_identity_client.py"
                },
                "region": {
                  "startLine": 191,
                  "startColumn": 56,
                  "endLine": 191,
                  "endColumn": 61,
                  "snippet": {
                    "text": "            raise ClientAuthenticationError(self.get_unavailable_message(str(ex))) from ex\n        except Exception as ex:  # pylint:disable=broad-except\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s.%s failed: %s\",\n                self.__class__.__name__,\n                base_method_name,\n",
                    "rendered": {
                      "text": "            raise ClientAuthenticationError(self.get_unavailable_message(str(ex))) from ex\n        except Exception as ex:  # pylint:disable=broad-except\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s.%s failed: %s\",\n                self.__class__.__name__,\n                base_method_name,\n",
                      "markdown": "`            raise ClientAuthenticationError(self.get_unavailable_message(str(ex))) from ex\n        except Exception as ex:  # pylint:disable=broad-except\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s.%s failed: %s\",\n                self.__class__.__name__,\n                base_method_name,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_managed_identity_client.py"
                },
                "region": {
                  "startLine": 181,
                  "startColumn": 56,
                  "endLine": 181,
                  "endColumn": 61,
                  "snippet": {
                    "text": "            raise CredentialUnavailableError(self.get_unavailable_message())\n        except msal.ManagedIdentityError as ex:\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s.%s failed: %s\",\n                self.__class__.__name__,\n                base_method_name,\n",
                    "rendered": {
                      "text": "            raise CredentialUnavailableError(self.get_unavailable_message())\n        except msal.ManagedIdentityError as ex:\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s.%s failed: %s\",\n                self.__class__.__name__,\n                base_method_name,\n",
                      "markdown": "`            raise CredentialUnavailableError(self.get_unavailable_message())\n        except msal.ManagedIdentityError as ex:\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s.%s failed: %s\",\n                self.__class__.__name__,\n                base_method_name,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_managed_identity_client.py"
                },
                "region": {
                  "startLine": 172,
                  "startColumn": 56,
                  "endLine": 172,
                  "endColumn": 61,
                  "snippet": {
                    "text": "                )\n                return token\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s.%s failed\",\n                self.__class__.__name__,\n                base_method_name,\n",
                    "rendered": {
                      "text": "                )\n                return token\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s.%s failed\",\n                self.__class__.__name__,\n                base_method_name,\n",
                      "markdown": "`                )\n                return token\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s.%s failed\",\n                self.__class__.__name__,\n                base_method_name,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_managed_identity_client.py"
                },
                "region": {
                  "startLine": 165,
                  "startColumn": 60,
                  "endLine": 165,
                  "endColumn": 65,
                  "snippet": {
                    "text": "            token = self._request_token(*scopes, claims=claims, tenant_id=tenant_id, enable_cae=enable_cae, **kwargs)\n            if token:\n                _LOGGER.log(\n                    logging.DEBUG if within_credential_chain.get() else logging.INFO,\n                    \"%s.%s succeeded\",\n                    self.__class__.__name__,\n                    base_method_name,\n",
                    "rendered": {
                      "text": "            token = self._request_token(*scopes, claims=claims, tenant_id=tenant_id, enable_cae=enable_cae, **kwargs)\n            if token:\n                _LOGGER.log(\n                    logging.DEBUG if within_credential_chain.get() else logging.INFO,\n                    \"%s.%s succeeded\",\n                    self.__class__.__name__,\n                    base_method_name,\n",
                      "markdown": "`            token = self._request_token(*scopes, claims=claims, tenant_id=tenant_id, enable_cae=enable_cae, **kwargs)\n            if token:\n                _LOGGER.log(\n                    logging.DEBUG if within_credential_chain.get() else logging.INFO,\n                    \"%s.%s succeeded\",\n                    self.__class__.__name__,\n                    base_method_name,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_managed_identity_client.py"
                },
                "region": {
                  "startLine": 159,
                  "startColumn": 28,
                  "endLine": 159,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        try:\n            token = self._request_token(*scopes, claims=claims, tenant_id=tenant_id, enable_cae=enable_cae, **kwargs)\n",
                    "rendered": {
                      "text": "        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        try:\n            token = self._request_token(*scopes, claims=claims, tenant_id=tenant_id, enable_cae=enable_cae, **kwargs)\n",
                      "markdown": "`        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        try:\n            token = self._request_token(*scopes, claims=claims, tenant_id=tenant_id, enable_cae=enable_cae, **kwargs)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_managed_identity_client.py"
                },
                "region": {
                  "startLine": 158,
                  "startColumn": 27,
                  "endLine": 158,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        try:\n",
                    "rendered": {
                      "text": "\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        try:\n",
                      "markdown": "`\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_managed_identity_client.py"
                },
                "region": {
                  "startLine": 157,
                  "startColumn": 24,
                  "endLine": 157,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        token = None\n\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n",
                    "rendered": {
                      "text": "        token = None\n\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n",
                      "markdown": "`        token = None\n\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_managed_identity_client.py"
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 51,
                  "endLine": 77,
                  "endColumn": 56,
                  "snippet": {
                    "text": "\n        if \"client_id\" in self._settings and self._settings[\"client_id\"]:\n            return msal.UserAssignedManagedIdentity(client_id=self._settings[\"client_id\"])\n        identity_config = cast(Dict, self._settings.get(\"identity_config\")) or {}\n        if \"client_id\" in identity_config and identity_config[\"client_id\"]:\n            return msal.UserAssignedManagedIdentity(client_id=identity_config[\"client_id\"])\n        if \"resource_id\" in identity_config and identity_config[\"resource_id\"]:\n",
                    "rendered": {
                      "text": "\n        if \"client_id\" in self._settings and self._settings[\"client_id\"]:\n            return msal.UserAssignedManagedIdentity(client_id=self._settings[\"client_id\"])\n        identity_config = cast(Dict, self._settings.get(\"identity_config\")) or {}\n        if \"client_id\" in identity_config and identity_config[\"client_id\"]:\n            return msal.UserAssignedManagedIdentity(client_id=identity_config[\"client_id\"])\n        if \"resource_id\" in identity_config and identity_config[\"resource_id\"]:\n",
                      "markdown": "`\n        if \"client_id\" in self._settings and self._settings[\"client_id\"]:\n            return msal.UserAssignedManagedIdentity(client_id=self._settings[\"client_id\"])\n        identity_config = cast(Dict, self._settings.get(\"identity_config\")) or {}\n        if \"client_id\" in identity_config and identity_config[\"client_id\"]:\n            return msal.UserAssignedManagedIdentity(client_id=identity_config[\"client_id\"])\n        if \"resource_id\" in identity_config and identity_config[\"resource_id\"]:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_managed_identity_client.py"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 33,
                  "endLine": 59,
                  "endColumn": 38,
                  "snippet": {
                    "text": "            return AccessTokenInfo(\n                result[\"access_token\"],\n                now + int(result[\"expires_in\"]),\n                token_type=result.get(\"token_type\", \"Bearer\"),\n                refresh_on=refresh_on,\n            )\n        if result and \"error\" in result:\n",
                    "rendered": {
                      "text": "            return AccessTokenInfo(\n                result[\"access_token\"],\n                now + int(result[\"expires_in\"]),\n                token_type=result.get(\"token_type\", \"Bearer\"),\n                refresh_on=refresh_on,\n            )\n        if result and \"error\" in result:\n",
                      "markdown": "`            return AccessTokenInfo(\n                result[\"access_token\"],\n                now + int(result[\"expires_in\"]),\n                token_type=result.get(\"token_type\", \"Bearer\"),\n                refresh_on=refresh_on,\n            )\n        if result and \"error\" in result:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_managed_identity_client.py"
                },
                "region": {
                  "startLine": 152,
                  "startColumn": 60,
                  "endLine": 152,
                  "endColumn": 64,
                  "snippet": {
                    "text": "        **kwargs: Any,\n    ) -> AccessTokenInfo:\n        if not scopes:\n            raise ValueError(f'\"{base_method_name}\" requires at least one scope')\n        _scopes_to_resource(*scopes)\n        token = None\n\n",
                    "rendered": {
                      "text": "        **kwargs: Any,\n    ) -> AccessTokenInfo:\n        if not scopes:\n            raise ValueError(f'\"{base_method_name}\" requires at least one scope')\n        _scopes_to_resource(*scopes)\n        token = None\n\n",
                      "markdown": "`        **kwargs: Any,\n    ) -> AccessTokenInfo:\n        if not scopes:\n            raise ValueError(f'\"{base_method_name}\" requires at least one scope')\n        _scopes_to_resource(*scopes)\n        token = None\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_managed_identity_client.py"
                },
                "region": {
                  "startLine": 130,
                  "startColumn": 84,
                  "endLine": 130,
                  "endColumn": 88,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_managed_identity_client.py"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 84,
                  "endLine": 98,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_managed_identity_client.py"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 50,
                  "endLine": 50,
                  "endColumn": 54,
                  "snippet": {
                    "text": "\n    def _request_token(self, *scopes: str, **kwargs: Any) -> AccessTokenInfo:  # pylint:disable=unused-argument\n        if not scopes:\n            raise ValueError('\"get_token\" requires at least one scope')\n        resource = _scopes_to_resource(*scopes)\n        result = self._msal_client.acquire_token_for_client(resource=resource)\n        now = int(time.time())\n",
                    "rendered": {
                      "text": "\n    def _request_token(self, *scopes: str, **kwargs: Any) -> AccessTokenInfo:  # pylint:disable=unused-argument\n        if not scopes:\n            raise ValueError('\"get_token\" requires at least one scope')\n        resource = _scopes_to_resource(*scopes)\n        result = self._msal_client.acquire_token_for_client(resource=resource)\n        now = int(time.time())\n",
                      "markdown": "`\n    def _request_token(self, *scopes: str, **kwargs: Any) -> AccessTokenInfo:  # pylint:disable=unused-argument\n        if not scopes:\n            raise ValueError('\"get_token\" requires at least one scope')\n        resource = _scopes_to_resource(*scopes)\n        result = self._msal_client.acquire_token_for_client(resource=resource)\n        now = int(time.time())\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_managed_identity_client.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 6,
                  "endLine": 8,
                  "snippet": {
                    "text": "# ------------------------------------\nfrom typing import Any, Optional, Dict, cast, Union, Mapping\nimport abc\nimport time\nimport logging\n\nimport msal\nfrom azure.core.credentials import AccessToken, AccessTokenInfo, TokenRequestOptions\n",
                    "rendered": {
                      "text": "# ------------------------------------\nfrom typing import Any, Optional, Dict, cast, Union, Mapping\nimport abc\nimport time\nimport logging\n\nimport msal\nfrom azure.core.credentials import AccessToken, AccessTokenInfo, TokenRequestOptions\n",
                      "markdown": "`# ------------------------------------\nfrom typing import Any, Optional, Dict, cast, Union, Mapping\nimport abc\nimport time\nimport logging\n\nimport msal\nfrom azure.core.credentials import AccessToken, AccessTokenInfo, TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_credentials.py"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 67,
                  "endLine": 104,
                  "endColumn": 72,
                  "snippet": {
                    "text": "            token_cache = self._cae_cache\n\n        if not token_cache:\n            token_cache = self._initialize_cache(is_cae=bool(kwargs.get(\"enable_cae\")))\n\n        if tenant_id not in client_applications_map:\n            try:\n",
                    "rendered": {
                      "text": "            token_cache = self._cae_cache\n\n        if not token_cache:\n            token_cache = self._initialize_cache(is_cae=bool(kwargs.get(\"enable_cae\")))\n\n        if tenant_id not in client_applications_map:\n            try:\n",
                      "markdown": "`            token_cache = self._cae_cache\n\n        if not token_cache:\n            token_cache = self._initialize_cache(is_cae=bool(kwargs.get(\"enable_cae\")))\n\n        if tenant_id not in client_applications_map:\n            try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_credentials.py"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 17,
                  "endLine": 98,
                  "endColumn": 22,
                  "snippet": {
                    "text": "\n        app_class = msal.ConfidentialClientApplication if self._client_credential else msal.PublicClientApplication\n\n        if kwargs.get(\"enable_cae\"):\n            client_applications_map = self._cae_client_applications\n            capabilities = [\"CP1\"]\n            token_cache = self._cae_cache\n",
                    "rendered": {
                      "text": "\n        app_class = msal.ConfidentialClientApplication if self._client_credential else msal.PublicClientApplication\n\n        if kwargs.get(\"enable_cae\"):\n            client_applications_map = self._cae_client_applications\n            capabilities = [\"CP1\"]\n            token_cache = self._cae_cache\n",
                      "markdown": "`\n        app_class = msal.ConfidentialClientApplication if self._client_credential else msal.PublicClientApplication\n\n        if kwargs.get(\"enable_cae\"):\n            client_applications_map = self._cae_client_applications\n            capabilities = [\"CP1\"]\n            token_cache = self._cae_cache\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_credentials.py"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 45,
                  "endLine": 39,
                  "endColumn": 50,
                  "snippet": {
                    "text": "    ) -> None:\n        self._instance_discovery = None if disable_instance_discovery is None else not disable_instance_discovery\n        self._authority = normalize_authority(authority) if authority else get_default_authority()\n        self._regional_authority = os.environ.get(EnvironmentVariables.AZURE_REGIONAL_AUTHORITY_NAME)\n        if self._regional_authority and self._regional_authority.lower() in [\"tryautodetect\", \"true\"]:\n            self._regional_authority = msal.ConfidentialClientApplication.ATTEMPT_REGION_DISCOVERY\n        self._tenant_id = tenant_id or \"organizations\"\n",
                    "rendered": {
                      "text": "    ) -> None:\n        self._instance_discovery = None if disable_instance_discovery is None else not disable_instance_discovery\n        self._authority = normalize_authority(authority) if authority else get_default_authority()\n        self._regional_authority = os.environ.get(EnvironmentVariables.AZURE_REGIONAL_AUTHORITY_NAME)\n        if self._regional_authority and self._regional_authority.lower() in [\"tryautodetect\", \"true\"]:\n            self._regional_authority = msal.ConfidentialClientApplication.ATTEMPT_REGION_DISCOVERY\n        self._tenant_id = tenant_id or \"organizations\"\n",
                      "markdown": "`    ) -> None:\n        self._instance_discovery = None if disable_instance_discovery is None else not disable_instance_discovery\n        self._authority = normalize_authority(authority) if authority else get_default_authority()\n        self._regional_authority = os.environ.get(EnvironmentVariables.AZURE_REGIONAL_AUTHORITY_NAME)\n        if self._regional_authority and self._regional_authority.lower() in [\"tryautodetect\", \"true\"]:\n            self._regional_authority = msal.ConfidentialClientApplication.ATTEMPT_REGION_DISCOVERY\n        self._tenant_id = tenant_id or \"organizations\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_credentials.py"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 38,
                  "endLine": 39,
                  "endColumn": 49,
                  "snippet": {
                    "text": "    ) -> None:\n        self._instance_discovery = None if disable_instance_discovery is None else not disable_instance_discovery\n        self._authority = normalize_authority(authority) if authority else get_default_authority()\n        self._regional_authority = os.environ.get(EnvironmentVariables.AZURE_REGIONAL_AUTHORITY_NAME)\n        if self._regional_authority and self._regional_authority.lower() in [\"tryautodetect\", \"true\"]:\n            self._regional_authority = msal.ConfidentialClientApplication.ATTEMPT_REGION_DISCOVERY\n        self._tenant_id = tenant_id or \"organizations\"\n",
                    "rendered": {
                      "text": "    ) -> None:\n        self._instance_discovery = None if disable_instance_discovery is None else not disable_instance_discovery\n        self._authority = normalize_authority(authority) if authority else get_default_authority()\n        self._regional_authority = os.environ.get(EnvironmentVariables.AZURE_REGIONAL_AUTHORITY_NAME)\n        if self._regional_authority and self._regional_authority.lower() in [\"tryautodetect\", \"true\"]:\n            self._regional_authority = msal.ConfidentialClientApplication.ATTEMPT_REGION_DISCOVERY\n        self._tenant_id = tenant_id or \"organizations\"\n",
                      "markdown": "`    ) -> None:\n        self._instance_discovery = None if disable_instance_discovery is None else not disable_instance_discovery\n        self._authority = normalize_authority(authority) if authority else get_default_authority()\n        self._regional_authority = os.environ.get(EnvironmentVariables.AZURE_REGIONAL_AUTHORITY_NAME)\n        if self._regional_authority and self._regional_authority.lower() in [\"tryautodetect\", \"true\"]:\n            self._regional_authority = msal.ConfidentialClientApplication.ATTEMPT_REGION_DISCOVERY\n        self._tenant_id = tenant_id or \"organizations\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 171,
                  "startColumn": 42,
                  "endLine": 171,
                  "endColumn": 50,
                  "snippet": {
                    "text": "\n    client_credential = {\"private_key\": cert.pem_bytes, \"thumbprint\": hexlify(cert.fingerprint).decode(\"utf-8\")}\n    if password:\n        client_credential[\"passphrase\"] = password\n\n    if send_certificate_chain:\n        try:\n",
                    "rendered": {
                      "text": "\n    client_credential = {\"private_key\": cert.pem_bytes, \"thumbprint\": hexlify(cert.fingerprint).decode(\"utf-8\")}\n    if password:\n        client_credential[\"passphrase\"] = password\n\n    if send_certificate_chain:\n        try:\n",
                      "markdown": "`\n    client_credential = {\"private_key\": cert.pem_bytes, \"thumbprint\": hexlify(cert.fingerprint).decode(\"utf-8\")}\n    if password:\n        client_credential[\"passphrase\"] = password\n\n    if send_certificate_chain:\n        try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 170,
                  "startColumn": 7,
                  "endLine": 170,
                  "endColumn": 15,
                  "snippet": {
                    "text": "        raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n\n    client_credential = {\"private_key\": cert.pem_bytes, \"thumbprint\": hexlify(cert.fingerprint).decode(\"utf-8\")}\n    if password:\n        client_credential[\"passphrase\"] = password\n\n    if send_certificate_chain:\n",
                    "rendered": {
                      "text": "        raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n\n    client_credential = {\"private_key\": cert.pem_bytes, \"thumbprint\": hexlify(cert.fingerprint).decode(\"utf-8\")}\n    if password:\n        client_credential[\"passphrase\"] = password\n\n    if send_certificate_chain:\n",
                      "markdown": "`        raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n\n    client_credential = {\"private_key\": cert.pem_bytes, \"thumbprint\": hexlify(cert.fingerprint).decode(\"utf-8\")}\n    if password:\n        client_credential[\"passphrase\"] = password\n\n    if send_certificate_chain:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 169,
                  "startColumn": 26,
                  "endLine": 169,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    if not isinstance(cert.private_key, RSAPrivateKey):\n        raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n\n    client_credential = {\"private_key\": cert.pem_bytes, \"thumbprint\": hexlify(cert.fingerprint).decode(\"utf-8\")}\n    if password:\n        client_credential[\"passphrase\"] = password\n\n",
                    "rendered": {
                      "text": "    if not isinstance(cert.private_key, RSAPrivateKey):\n        raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n\n    client_credential = {\"private_key\": cert.pem_bytes, \"thumbprint\": hexlify(cert.fingerprint).decode(\"utf-8\")}\n    if password:\n        client_credential[\"passphrase\"] = password\n\n",
                      "markdown": "`    if not isinstance(cert.private_key, RSAPrivateKey):\n        raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n\n    client_credential = {\"private_key\": cert.pem_bytes, \"thumbprint\": hexlify(cert.fingerprint).decode(\"utf-8\")}\n    if password:\n        client_credential[\"passphrase\"] = password\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 166,
                  "startColumn": 43,
                  "endLine": 166,
                  "endColumn": 53,
                  "snippet": {
                    "text": "        cert = load_pkcs12_certificate(certificate_data, password)\n        password = None  # load_pkcs12_certificate returns cert.pem_bytes decrypted\n\n    if not isinstance(cert.private_key, RSAPrivateKey):\n        raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n\n    client_credential = {\"private_key\": cert.pem_bytes, \"thumbprint\": hexlify(cert.fingerprint).decode(\"utf-8\")}\n",
                    "rendered": {
                      "text": "        cert = load_pkcs12_certificate(certificate_data, password)\n        password = None  # load_pkcs12_certificate returns cert.pem_bytes decrypted\n\n    if not isinstance(cert.private_key, RSAPrivateKey):\n        raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n\n    client_credential = {\"private_key\": cert.pem_bytes, \"thumbprint\": hexlify(cert.fingerprint).decode(\"utf-8\")}\n",
                      "markdown": "`        cert = load_pkcs12_certificate(certificate_data, password)\n        password = None  # load_pkcs12_certificate returns cert.pem_bytes decrypted\n\n    if not isinstance(cert.private_key, RSAPrivateKey):\n        raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n\n    client_credential = {\"private_key\": cert.pem_bytes, \"thumbprint\": hexlify(cert.fingerprint).decode(\"utf-8\")}\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 166,
                  "startColumn": 27,
                  "endLine": 166,
                  "endColumn": 38,
                  "snippet": {
                    "text": "        cert = load_pkcs12_certificate(certificate_data, password)\n        password = None  # load_pkcs12_certificate returns cert.pem_bytes decrypted\n\n    if not isinstance(cert.private_key, RSAPrivateKey):\n        raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n\n    client_credential = {\"private_key\": cert.pem_bytes, \"thumbprint\": hexlify(cert.fingerprint).decode(\"utf-8\")}\n",
                    "rendered": {
                      "text": "        cert = load_pkcs12_certificate(certificate_data, password)\n        password = None  # load_pkcs12_certificate returns cert.pem_bytes decrypted\n\n    if not isinstance(cert.private_key, RSAPrivateKey):\n        raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n\n    client_credential = {\"private_key\": cert.pem_bytes, \"thumbprint\": hexlify(cert.fingerprint).decode(\"utf-8\")}\n",
                      "markdown": "`        cert = load_pkcs12_certificate(certificate_data, password)\n        password = None  # load_pkcs12_certificate returns cert.pem_bytes decrypted\n\n    if not isinstance(cert.private_key, RSAPrivateKey):\n        raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n\n    client_credential = {\"private_key\": cert.pem_bytes, \"thumbprint\": hexlify(cert.fingerprint).decode(\"utf-8\")}\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 164,
                  "startColumn": 8,
                  "endLine": 164,
                  "endColumn": 16,
                  "snippet": {
                    "text": "        cert = load_pem_certificate(certificate_data, password)\n    else:\n        cert = load_pkcs12_certificate(certificate_data, password)\n        password = None  # load_pkcs12_certificate returns cert.pem_bytes decrypted\n\n    if not isinstance(cert.private_key, RSAPrivateKey):\n        raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n",
                    "rendered": {
                      "text": "        cert = load_pem_certificate(certificate_data, password)\n    else:\n        cert = load_pkcs12_certificate(certificate_data, password)\n        password = None  # load_pkcs12_certificate returns cert.pem_bytes decrypted\n\n    if not isinstance(cert.private_key, RSAPrivateKey):\n        raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n",
                      "markdown": "`        cert = load_pem_certificate(certificate_data, password)\n    else:\n        cert = load_pkcs12_certificate(certificate_data, password)\n        password = None  # load_pkcs12_certificate returns cert.pem_bytes decrypted\n\n    if not isinstance(cert.private_key, RSAPrivateKey):\n        raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 163,
                  "startColumn": 57,
                  "endLine": 163,
                  "endColumn": 65,
                  "snippet": {
                    "text": "    if b\"-----BEGIN\" in certificate_data:\n        cert = load_pem_certificate(certificate_data, password)\n    else:\n        cert = load_pkcs12_certificate(certificate_data, password)\n        password = None  # load_pkcs12_certificate returns cert.pem_bytes decrypted\n\n    if not isinstance(cert.private_key, RSAPrivateKey):\n",
                    "rendered": {
                      "text": "    if b\"-----BEGIN\" in certificate_data:\n        cert = load_pem_certificate(certificate_data, password)\n    else:\n        cert = load_pkcs12_certificate(certificate_data, password)\n        password = None  # load_pkcs12_certificate returns cert.pem_bytes decrypted\n\n    if not isinstance(cert.private_key, RSAPrivateKey):\n",
                      "markdown": "`    if b\"-----BEGIN\" in certificate_data:\n        cert = load_pem_certificate(certificate_data, password)\n    else:\n        cert = load_pkcs12_certificate(certificate_data, password)\n        password = None  # load_pkcs12_certificate returns cert.pem_bytes decrypted\n\n    if not isinstance(cert.private_key, RSAPrivateKey):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 161,
                  "startColumn": 54,
                  "endLine": 161,
                  "endColumn": 62,
                  "snippet": {
                    "text": "    password = cast(\"Optional[bytes]\", password)\n\n    if b\"-----BEGIN\" in certificate_data:\n        cert = load_pem_certificate(certificate_data, password)\n    else:\n        cert = load_pkcs12_certificate(certificate_data, password)\n        password = None  # load_pkcs12_certificate returns cert.pem_bytes decrypted\n",
                    "rendered": {
                      "text": "    password = cast(\"Optional[bytes]\", password)\n\n    if b\"-----BEGIN\" in certificate_data:\n        cert = load_pem_certificate(certificate_data, password)\n    else:\n        cert = load_pkcs12_certificate(certificate_data, password)\n        password = None  # load_pkcs12_certificate returns cert.pem_bytes decrypted\n",
                      "markdown": "`    password = cast(\"Optional[bytes]\", password)\n\n    if b\"-----BEGIN\" in certificate_data:\n        cert = load_pem_certificate(certificate_data, password)\n    else:\n        cert = load_pkcs12_certificate(certificate_data, password)\n        password = None  # load_pkcs12_certificate returns cert.pem_bytes decrypted\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 158,
                  "startColumn": 39,
                  "endLine": 158,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n    password = cast(\"Optional[bytes]\", password)\n\n    if b\"-----BEGIN\" in certificate_data:\n        cert = load_pem_certificate(certificate_data, password)\n",
                    "rendered": {
                      "text": "        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n    password = cast(\"Optional[bytes]\", password)\n\n    if b\"-----BEGIN\" in certificate_data:\n        cert = load_pem_certificate(certificate_data, password)\n",
                      "markdown": "`        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n    password = cast(\"Optional[bytes]\", password)\n\n    if b\"-----BEGIN\" in certificate_data:\n        cert = load_pem_certificate(certificate_data, password)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 158,
                  "startColumn": 4,
                  "endLine": 158,
                  "endColumn": 12,
                  "snippet": {
                    "text": "        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n    password = cast(\"Optional[bytes]\", password)\n\n    if b\"-----BEGIN\" in certificate_data:\n        cert = load_pem_certificate(certificate_data, password)\n",
                    "rendered": {
                      "text": "        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n    password = cast(\"Optional[bytes]\", password)\n\n    if b\"-----BEGIN\" in certificate_data:\n        cert = load_pem_certificate(certificate_data, password)\n",
                      "markdown": "`        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n    password = cast(\"Optional[bytes]\", password)\n\n    if b\"-----BEGIN\" in certificate_data:\n        cert = load_pem_certificate(certificate_data, password)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 157,
                  "startColumn": 23,
                  "endLine": 157,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    if password:\n        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n    password = cast(\"Optional[bytes]\", password)\n\n    if b\"-----BEGIN\" in certificate_data:\n",
                    "rendered": {
                      "text": "    if password:\n        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n    password = cast(\"Optional[bytes]\", password)\n\n    if b\"-----BEGIN\" in certificate_data:\n",
                      "markdown": "`    if password:\n        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n    password = cast(\"Optional[bytes]\", password)\n\n    if b\"-----BEGIN\" in certificate_data:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 157,
                  "startColumn": 12,
                  "endLine": 157,
                  "endColumn": 20,
                  "snippet": {
                    "text": "    if password:\n        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n    password = cast(\"Optional[bytes]\", password)\n\n    if b\"-----BEGIN\" in certificate_data:\n",
                    "rendered": {
                      "text": "    if password:\n        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n    password = cast(\"Optional[bytes]\", password)\n\n    if b\"-----BEGIN\" in certificate_data:\n",
                      "markdown": "`    if password:\n        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n    password = cast(\"Optional[bytes]\", password)\n\n    if b\"-----BEGIN\" in certificate_data:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 156,
                  "startColumn": 22,
                  "endLine": 156,
                  "endColumn": 30,
                  "snippet": {
                    "text": "\n    if password:\n        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n    password = cast(\"Optional[bytes]\", password)\n\n",
                    "rendered": {
                      "text": "\n    if password:\n        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n    password = cast(\"Optional[bytes]\", password)\n\n",
                      "markdown": "`\n    if password:\n        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n    password = cast(\"Optional[bytes]\", password)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 155,
                  "startColumn": 13,
                  "endLine": 155,
                  "endColumn": 21,
                  "snippet": {
                    "text": "        raise ValueError('CertificateCredential requires a value for either \"certificate_path\" or \"certificate_data\"')\n\n    if password:\n        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n    password = cast(\"Optional[bytes]\", password)\n",
                    "rendered": {
                      "text": "        raise ValueError('CertificateCredential requires a value for either \"certificate_path\" or \"certificate_data\"')\n\n    if password:\n        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n    password = cast(\"Optional[bytes]\", password)\n",
                      "markdown": "`        raise ValueError('CertificateCredential requires a value for either \"certificate_path\" or \"certificate_data\"')\n\n    if password:\n        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n    password = cast(\"Optional[bytes]\", password)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 154,
                  "startColumn": 7,
                  "endLine": 154,
                  "endColumn": 15,
                  "snippet": {
                    "text": "    elif not certificate_data:\n        raise ValueError('CertificateCredential requires a value for either \"certificate_path\" or \"certificate_data\"')\n\n    if password:\n        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n",
                    "rendered": {
                      "text": "    elif not certificate_data:\n        raise ValueError('CertificateCredential requires a value for either \"certificate_path\" or \"certificate_data\"')\n\n    if password:\n        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n",
                      "markdown": "`    elif not certificate_data:\n        raise ValueError('CertificateCredential requires a value for either \"certificate_path\" or \"certificate_data\"')\n\n    if password:\n        # if password is already bytes, no need to encode.\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 138,
                  "startColumn": 45,
                  "endLine": 138,
                  "endColumn": 53,
                  "snippet": {
                    "text": "    \"\"\"Load a certificate from a filesystem path or bytes, return it as a dict suitable for msal.ClientApplication.\n\n    :param str certificate_path: Path to a PEM or PKCS12 certificate file.\n    :param bytes password: The certificate's password, if any.\n    :param bytes certificate_data: The PEM or PKCS12 certificate's bytes.\n    :param bool send_certificate_chain: Whether to send the certificate chain. Defaults to False.\n\n",
                    "rendered": {
                      "text": "    \"\"\"Load a certificate from a filesystem path or bytes, return it as a dict suitable for msal.ClientApplication.\n\n    :param str certificate_path: Path to a PEM or PKCS12 certificate file.\n    :param bytes password: The certificate's password, if any.\n    :param bytes certificate_data: The PEM or PKCS12 certificate's bytes.\n    :param bool send_certificate_chain: Whether to send the certificate chain. Defaults to False.\n\n",
                      "markdown": "`    \"\"\"Load a certificate from a filesystem path or bytes, return it as a dict suitable for msal.ClientApplication.\n\n    :param str certificate_path: Path to a PEM or PKCS12 certificate file.\n    :param bytes password: The certificate's password, if any.\n    :param bytes certificate_data: The PEM or PKCS12 certificate's bytes.\n    :param bool send_certificate_chain: Whether to send the certificate chain. Defaults to False.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 138,
                  "startColumn": 17,
                  "endLine": 138,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    \"\"\"Load a certificate from a filesystem path or bytes, return it as a dict suitable for msal.ClientApplication.\n\n    :param str certificate_path: Path to a PEM or PKCS12 certificate file.\n    :param bytes password: The certificate's password, if any.\n    :param bytes certificate_data: The PEM or PKCS12 certificate's bytes.\n    :param bool send_certificate_chain: Whether to send the certificate chain. Defaults to False.\n\n",
                    "rendered": {
                      "text": "    \"\"\"Load a certificate from a filesystem path or bytes, return it as a dict suitable for msal.ClientApplication.\n\n    :param str certificate_path: Path to a PEM or PKCS12 certificate file.\n    :param bytes password: The certificate's password, if any.\n    :param bytes certificate_data: The PEM or PKCS12 certificate's bytes.\n    :param bool send_certificate_chain: Whether to send the certificate chain. Defaults to False.\n\n",
                      "markdown": "`    \"\"\"Load a certificate from a filesystem path or bytes, return it as a dict suitable for msal.ClientApplication.\n\n    :param str certificate_path: Path to a PEM or PKCS12 certificate file.\n    :param bytes password: The certificate's password, if any.\n    :param bytes certificate_data: The PEM or PKCS12 certificate's bytes.\n    :param bool send_certificate_chain: Whether to send the certificate chain. Defaults to False.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 130,
                  "startColumn": 4,
                  "endLine": 130,
                  "endColumn": 12,
                  "snippet": {
                    "text": "\ndef get_client_credential(\n    certificate_path: Optional[str] = None,\n    password: Optional[Union[bytes, str]] = None,\n    certificate_data: Optional[bytes] = None,\n    send_certificate_chain: bool = False,\n    **_: Any\n",
                    "rendered": {
                      "text": "\ndef get_client_credential(\n    certificate_path: Optional[str] = None,\n    password: Optional[Union[bytes, str]] = None,\n    certificate_data: Optional[bytes] = None,\n    send_certificate_chain: bool = False,\n    **_: Any\n",
                      "markdown": "`\ndef get_client_credential(\n    certificate_path: Optional[str] = None,\n    password: Optional[Union[bytes, str]] = None,\n    certificate_data: Optional[bytes] = None,\n    send_certificate_chain: bool = False,\n    **_: Any\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 125,
                  "startColumn": 28,
                  "endLine": 125,
                  "endColumn": 39,
                  "snippet": {
                    "text": "\n    fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n\n    return _Cert(pem_bytes, private_key, fingerprint)\n\n\ndef get_client_credential(\n",
                    "rendered": {
                      "text": "\n    fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n\n    return _Cert(pem_bytes, private_key, fingerprint)\n\n\ndef get_client_credential(\n",
                      "markdown": "`\n    fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n\n    return _Cert(pem_bytes, private_key, fingerprint)\n\n\ndef get_client_credential(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 119,
                  "startColumn": 16,
                  "endLine": 119,
                  "endColumn": 27,
                  "snippet": {
                    "text": "    # This serializes the private key without any encryption it may have had. Doing so doesn't violate security\n    # boundaries because this representation of the key is kept in memory. We already have the key and its\n    # password, if any, in memory.\n    key_bytes = private_key.private_bytes(Encoding.PEM, PrivateFormat.PKCS8, NoEncryption())\n    pem_sections = [key_bytes] + [c.public_bytes(Encoding.PEM) for c in [cert] + additional_certs]\n    pem_bytes = b\"\".join(pem_sections)\n\n",
                    "rendered": {
                      "text": "    # This serializes the private key without any encryption it may have had. Doing so doesn't violate security\n    # boundaries because this representation of the key is kept in memory. We already have the key and its\n    # password, if any, in memory.\n    key_bytes = private_key.private_bytes(Encoding.PEM, PrivateFormat.PKCS8, NoEncryption())\n    pem_sections = [key_bytes] + [c.public_bytes(Encoding.PEM) for c in [cert] + additional_certs]\n    pem_bytes = b\"\".join(pem_sections)\n\n",
                      "markdown": "`    # This serializes the private key without any encryption it may have had. Doing so doesn't violate security\n    # boundaries because this representation of the key is kept in memory. We already have the key and its\n    # password, if any, in memory.\n    key_bytes = private_key.private_bytes(Encoding.PEM, PrivateFormat.PKCS8, NoEncryption())\n    pem_sections = [key_bytes] + [c.public_bytes(Encoding.PEM) for c in [cert] + additional_certs]\n    pem_bytes = b\"\".join(pem_sections)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 118,
                  "startColumn": 6,
                  "endLine": 118,
                  "endColumn": 14,
                  "snippet": {
                    "text": "\n    # This serializes the private key without any encryption it may have had. Doing so doesn't violate security\n    # boundaries because this representation of the key is kept in memory. We already have the key and its\n    # password, if any, in memory.\n    key_bytes = private_key.private_bytes(Encoding.PEM, PrivateFormat.PKCS8, NoEncryption())\n    pem_sections = [key_bytes] + [c.public_bytes(Encoding.PEM) for c in [cert] + additional_certs]\n    pem_bytes = b\"\".join(pem_sections)\n",
                    "rendered": {
                      "text": "\n    # This serializes the private key without any encryption it may have had. Doing so doesn't violate security\n    # boundaries because this representation of the key is kept in memory. We already have the key and its\n    # password, if any, in memory.\n    key_bytes = private_key.private_bytes(Encoding.PEM, PrivateFormat.PKCS8, NoEncryption())\n    pem_sections = [key_bytes] + [c.public_bytes(Encoding.PEM) for c in [cert] + additional_certs]\n    pem_bytes = b\"\".join(pem_sections)\n",
                      "markdown": "`\n    # This serializes the private key without any encryption it may have had. Doing so doesn't violate security\n    # boundaries because this representation of the key is kept in memory. We already have the key and its\n    # password, if any, in memory.\n    key_bytes = private_key.private_bytes(Encoding.PEM, PrivateFormat.PKCS8, NoEncryption())\n    pem_sections = [key_bytes] + [c.public_bytes(Encoding.PEM) for c in [cert] + additional_certs]\n    pem_bytes = b\"\".join(pem_sections)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 11,
                  "endLine": 111,
                  "endColumn": 22,
                  "snippet": {
                    "text": "    except ValueError as ex:\n        # mentioning PEM here because we raise this error when certificate_data is garbage\n        raise ValueError(\"Failed to deserialize certificate in PEM or PKCS12 format\") from ex\n    if not private_key:\n        raise ValueError(\"The certificate must include its private key\")\n    if not cert:\n        raise ValueError(\"Failed to deserialize certificate in PEM or PKCS12 format\")\n",
                    "rendered": {
                      "text": "    except ValueError as ex:\n        # mentioning PEM here because we raise this error when certificate_data is garbage\n        raise ValueError(\"Failed to deserialize certificate in PEM or PKCS12 format\") from ex\n    if not private_key:\n        raise ValueError(\"The certificate must include its private key\")\n    if not cert:\n        raise ValueError(\"Failed to deserialize certificate in PEM or PKCS12 format\")\n",
                      "markdown": "`    except ValueError as ex:\n        # mentioning PEM here because we raise this error when certificate_data is garbage\n        raise ValueError(\"Failed to deserialize certificate in PEM or PKCS12 format\") from ex\n    if not private_key:\n        raise ValueError(\"The certificate must include its private key\")\n    if not cert:\n        raise ValueError(\"Failed to deserialize certificate in PEM or PKCS12 format\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 106,
                  "startColumn": 30,
                  "endLine": 106,
                  "endColumn": 38,
                  "snippet": {
                    "text": "\n    try:\n        private_key, cert, additional_certs = pkcs12.load_key_and_certificates(\n            certificate_data, password, backend=default_backend()\n        )\n    except ValueError as ex:\n        # mentioning PEM here because we raise this error when certificate_data is garbage\n",
                    "rendered": {
                      "text": "\n    try:\n        private_key, cert, additional_certs = pkcs12.load_key_and_certificates(\n            certificate_data, password, backend=default_backend()\n        )\n    except ValueError as ex:\n        # mentioning PEM here because we raise this error when certificate_data is garbage\n",
                      "markdown": "`\n    try:\n        private_key, cert, additional_certs = pkcs12.load_key_and_certificates(\n            certificate_data, password, backend=default_backend()\n        )\n    except ValueError as ex:\n        # mentioning PEM here because we raise this error when certificate_data is garbage\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 8,
                  "endLine": 105,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    from cryptography.hazmat.primitives.serialization import Encoding, NoEncryption, pkcs12, PrivateFormat\n\n    try:\n        private_key, cert, additional_certs = pkcs12.load_key_and_certificates(\n            certificate_data, password, backend=default_backend()\n        )\n    except ValueError as ex:\n",
                    "rendered": {
                      "text": "    from cryptography.hazmat.primitives.serialization import Encoding, NoEncryption, pkcs12, PrivateFormat\n\n    try:\n        private_key, cert, additional_certs = pkcs12.load_key_and_certificates(\n            certificate_data, password, backend=default_backend()\n        )\n    except ValueError as ex:\n",
                      "markdown": "`    from cryptography.hazmat.primitives.serialization import Encoding, NoEncryption, pkcs12, PrivateFormat\n\n    try:\n        private_key, cert, additional_certs = pkcs12.load_key_and_certificates(\n            certificate_data, password, backend=default_backend()\n        )\n    except ValueError as ex:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 53,
                  "endLine": 101,
                  "endColumn": 61,
                  "snippet": {
                    "text": "    return _Cert(certificate_data, private_key, fingerprint)\n\n\ndef load_pkcs12_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n    from cryptography.hazmat.primitives.serialization import Encoding, NoEncryption, pkcs12, PrivateFormat\n\n    try:\n",
                    "rendered": {
                      "text": "    return _Cert(certificate_data, private_key, fingerprint)\n\n\ndef load_pkcs12_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n    from cryptography.hazmat.primitives.serialization import Encoding, NoEncryption, pkcs12, PrivateFormat\n\n    try:\n",
                      "markdown": "`    return _Cert(certificate_data, private_key, fingerprint)\n\n\ndef load_pkcs12_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n    from cryptography.hazmat.primitives.serialization import Encoding, NoEncryption, pkcs12, PrivateFormat\n\n    try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 35,
                  "endLine": 98,
                  "endColumn": 46,
                  "snippet": {
                    "text": "    private_key = serialization.load_pem_private_key(certificate_data, password, backend=default_backend())\n    cert = x509.load_pem_x509_certificate(certificate_data, default_backend())\n    fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n    return _Cert(certificate_data, private_key, fingerprint)\n\n\ndef load_pkcs12_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n",
                    "rendered": {
                      "text": "    private_key = serialization.load_pem_private_key(certificate_data, password, backend=default_backend())\n    cert = x509.load_pem_x509_certificate(certificate_data, default_backend())\n    fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n    return _Cert(certificate_data, private_key, fingerprint)\n\n\ndef load_pkcs12_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n",
                      "markdown": "`    private_key = serialization.load_pem_private_key(certificate_data, password, backend=default_backend())\n    cert = x509.load_pem_x509_certificate(certificate_data, default_backend())\n    fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n    return _Cert(certificate_data, private_key, fingerprint)\n\n\ndef load_pkcs12_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 71,
                  "endLine": 95,
                  "endColumn": 79,
                  "snippet": {
                    "text": "\n\ndef load_pem_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n    private_key = serialization.load_pem_private_key(certificate_data, password, backend=default_backend())\n    cert = x509.load_pem_x509_certificate(certificate_data, default_backend())\n    fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n    return _Cert(certificate_data, private_key, fingerprint)\n",
                    "rendered": {
                      "text": "\n\ndef load_pem_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n    private_key = serialization.load_pem_private_key(certificate_data, password, backend=default_backend())\n    cert = x509.load_pem_x509_certificate(certificate_data, default_backend())\n    fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n    return _Cert(certificate_data, private_key, fingerprint)\n",
                      "markdown": "`\n\ndef load_pem_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n    private_key = serialization.load_pem_private_key(certificate_data, password, backend=default_backend())\n    cert = x509.load_pem_x509_certificate(certificate_data, default_backend())\n    fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n    return _Cert(certificate_data, private_key, fingerprint)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 41,
                  "endLine": 95,
                  "endColumn": 52,
                  "snippet": {
                    "text": "\n\ndef load_pem_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n    private_key = serialization.load_pem_private_key(certificate_data, password, backend=default_backend())\n    cert = x509.load_pem_x509_certificate(certificate_data, default_backend())\n    fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n    return _Cert(certificate_data, private_key, fingerprint)\n",
                    "rendered": {
                      "text": "\n\ndef load_pem_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n    private_key = serialization.load_pem_private_key(certificate_data, password, backend=default_backend())\n    cert = x509.load_pem_x509_certificate(certificate_data, default_backend())\n    fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n    return _Cert(certificate_data, private_key, fingerprint)\n",
                      "markdown": "`\n\ndef load_pem_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n    private_key = serialization.load_pem_private_key(certificate_data, password, backend=default_backend())\n    cert = x509.load_pem_x509_certificate(certificate_data, default_backend())\n    fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n    return _Cert(certificate_data, private_key, fingerprint)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 4,
                  "endLine": 95,
                  "endColumn": 15,
                  "snippet": {
                    "text": "\n\ndef load_pem_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n    private_key = serialization.load_pem_private_key(certificate_data, password, backend=default_backend())\n    cert = x509.load_pem_x509_certificate(certificate_data, default_backend())\n    fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n    return _Cert(certificate_data, private_key, fingerprint)\n",
                    "rendered": {
                      "text": "\n\ndef load_pem_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n    private_key = serialization.load_pem_private_key(certificate_data, password, backend=default_backend())\n    cert = x509.load_pem_x509_certificate(certificate_data, default_backend())\n    fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n    return _Cert(certificate_data, private_key, fingerprint)\n",
                      "markdown": "`\n\ndef load_pem_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n    private_key = serialization.load_pem_private_key(certificate_data, password, backend=default_backend())\n    cert = x509.load_pem_x509_certificate(certificate_data, default_backend())\n    fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n    return _Cert(certificate_data, private_key, fingerprint)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 50,
                  "endLine": 94,
                  "endColumn": 58,
                  "snippet": {
                    "text": "_Cert = NamedTuple(\"_Cert\", [(\"pem_bytes\", bytes), (\"private_key\", \"Any\"), (\"fingerprint\", bytes)])\n\n\ndef load_pem_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n    private_key = serialization.load_pem_private_key(certificate_data, password, backend=default_backend())\n    cert = x509.load_pem_x509_certificate(certificate_data, default_backend())\n    fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n",
                    "rendered": {
                      "text": "_Cert = NamedTuple(\"_Cert\", [(\"pem_bytes\", bytes), (\"private_key\", \"Any\"), (\"fingerprint\", bytes)])\n\n\ndef load_pem_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n    private_key = serialization.load_pem_private_key(certificate_data, password, backend=default_backend())\n    cert = x509.load_pem_x509_certificate(certificate_data, default_backend())\n    fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n",
                      "markdown": "`_Cert = NamedTuple(\"_Cert\", [(\"pem_bytes\", bytes), (\"private_key\", \"Any\"), (\"fingerprint\", bytes)])\n\n\ndef load_pem_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n    private_key = serialization.load_pem_private_key(certificate_data, password, backend=default_backend())\n    cert = x509.load_pem_x509_certificate(certificate_data, default_backend())\n    fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 91,
                  "startColumn": 53,
                  "endLine": 91,
                  "endColumn": 64,
                  "snippet": {
                    "text": "    return b\"\".join(chain.splitlines())\n\n\n_Cert = NamedTuple(\"_Cert\", [(\"pem_bytes\", bytes), (\"private_key\", \"Any\"), (\"fingerprint\", bytes)])\n\n\ndef load_pem_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n",
                    "rendered": {
                      "text": "    return b\"\".join(chain.splitlines())\n\n\n_Cert = NamedTuple(\"_Cert\", [(\"pem_bytes\", bytes), (\"private_key\", \"Any\"), (\"fingerprint\", bytes)])\n\n\ndef load_pem_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n",
                      "markdown": "`    return b\"\".join(chain.splitlines())\n\n\n_Cert = NamedTuple(\"_Cert\", [(\"pem_bytes\", bytes), (\"private_key\", \"Any\"), (\"fingerprint\", bytes)])\n\n\ndef load_pem_certificate(certificate_data: bytes, password: Optional[bytes] = None) -> _Cert:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 15,
                  "endLine": 36,
                  "endColumn": 23,
                  "snippet": {
                    "text": "    :keyword bytes certificate_data: The bytes of a certificate in PEM or PKCS12 format, including the private key\n    :keyword password: The certificate's password. If a unicode string, it will be encoded as UTF-8. If the certificate\n        requires a different encoding, pass appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword bool send_certificate_chain: If True, the credential will send the public certificate chain in the x5c\n        header of each token request's JWT. This is required for Subject Name/Issuer (SNI) authentication. Defaults to\n        False.\n",
                    "rendered": {
                      "text": "    :keyword bytes certificate_data: The bytes of a certificate in PEM or PKCS12 format, including the private key\n    :keyword password: The certificate's password. If a unicode string, it will be encoded as UTF-8. If the certificate\n        requires a different encoding, pass appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword bool send_certificate_chain: If True, the credential will send the public certificate chain in the x5c\n        header of each token request's JWT. This is required for Subject Name/Issuer (SNI) authentication. Defaults to\n        False.\n",
                      "markdown": "`    :keyword bytes certificate_data: The bytes of a certificate in PEM or PKCS12 format, including the private key\n    :keyword password: The certificate's password. If a unicode string, it will be encoded as UTF-8. If the certificate\n        requires a different encoding, pass appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword bool send_certificate_chain: If True, the credential will send the public certificate chain in the x5c\n        header of each token request's JWT. This is required for Subject Name/Issuer (SNI) authentication. Defaults to\n        False.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 41,
                  "endLine": 34,
                  "endColumn": 49,
                  "snippet": {
                    "text": "ority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n        defines authorities for other clouds.\n    :keyword bytes certificate_data: The bytes of a certificate in PEM or PKCS12 format, including the private key\n    :keyword password: The certificate's password. If a unicode string, it will be encoded as UTF-8. If the certificate\n        requires a different encoding, pass appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword bool send_certificate_chain: If True, the credential will send the public certificate chain in th",
                    "rendered": {
                      "text": "ority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n        defines authorities for other clouds.\n    :keyword bytes certificate_data: The bytes of a certificate in PEM or PKCS12 format, including the private key\n    :keyword password: The certificate's password. If a unicode string, it will be encoded as UTF-8. If the certificate\n        requires a different encoding, pass appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword bool send_certificate_chain: If True, the credential will send the public certificate chain in th",
                      "markdown": "`ority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n        defines authorities for other clouds.\n    :keyword bytes certificate_data: The bytes of a certificate in PEM or PKCS12 format, including the private key\n    :keyword password: The certificate's password. If a unicode string, it will be encoded as UTF-8. If the certificate\n        requires a different encoding, pass appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword bool send_certificate_chain: If True, the credential will send the public certificate chain in th`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 13,
                  "endLine": 34,
                  "endColumn": 21,
                  "snippet": {
                    "text": "nline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n        defines authorities for other clouds.\n    :keyword bytes certificate_data: The bytes of a certificate in PEM or PKCS12 format, including the private key\n    :keyword password: The certificate's password. If a unicode string, it will be encoded as UTF-8. If the certificate\n        requires a different encoding, pass appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword bool send_certificate_chain: If True, the credential will send the pu",
                    "rendered": {
                      "text": "nline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n        defines authorities for other clouds.\n    :keyword bytes certificate_data: The bytes of a certificate in PEM or PKCS12 format, including the private key\n    :keyword password: The certificate's password. If a unicode string, it will be encoded as UTF-8. If the certificate\n        requires a different encoding, pass appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword bool send_certificate_chain: If True, the credential will send the pu",
                      "markdown": "`nline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n        defines authorities for other clouds.\n    :keyword bytes certificate_data: The bytes of a certificate in PEM or PKCS12 format, including the private key\n    :keyword password: The certificate's password. If a unicode string, it will be encoded as UTF-8. If the certificate\n        requires a different encoding, pass appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword bool send_certificate_chain: If True, the credential will send the pu`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 61,
                  "endLine": 10,
                  "endColumn": 71,
                  "snippet": {
                    "text": "\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKey\nfrom cryptography.hazmat.backends import default_backend\n\nfrom .._internal import validate_tenant_id\n",
                    "rendered": {
                      "text": "\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKey\nfrom cryptography.hazmat.backends import default_backend\n\nfrom .._internal import validate_tenant_id\n",
                      "markdown": "`\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKey\nfrom cryptography.hazmat.backends import default_backend\n\nfrom .._internal import validate_tenant_id\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 29,
                  "endLine": 26,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    for more information on configuring certificate authentication.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID\n    :param str certificate_path: Optional path to a certificate file in PEM or PKCS12 format, including the private\n        key. If not provided, **certificate_data** is required.\n\n",
                    "rendered": {
                      "text": "    for more information on configuring certificate authentication.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID\n    :param str certificate_path: Optional path to a certificate file in PEM or PKCS12 format, including the private\n        key. If not provided, **certificate_data** is required.\n\n",
                      "markdown": "`    for more information on configuring certificate authentication.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID\n    :param str certificate_path: Optional path to a certificate file in PEM or PKCS12 format, including the private\n        key. If not provided, **certificate_data** is required.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 35,
                  "endLine": 25,
                  "endColumn": 44,
                  "snippet": {
                    "text": "    <https://learn.microsoft.com/entra/identity-platform/certificate-credentials#register-your-certificate-with-microsoft-identity-platform>`__\n    for more information on configuring certificate authentication.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID\n    :param str certificate_path: Optional path to a certificate file in PEM or PKCS12 format, including the private\n        key. If not provided, **certificate_data** is required.\n",
                    "rendered": {
                      "text": "    <https://learn.microsoft.com/entra/identity-platform/certificate-credentials#register-your-certificate-with-microsoft-identity-platform>`__\n    for more information on configuring certificate authentication.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID\n    :param str certificate_path: Optional path to a certificate file in PEM or PKCS12 format, including the private\n        key. If not provided, **certificate_data** is required.\n",
                      "markdown": "`    <https://learn.microsoft.com/entra/identity-platform/certificate-credentials#register-your-certificate-with-microsoft-identity-platform>`__\n    for more information on configuring certificate authentication.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID\n    :param str certificate_path: Optional path to a certificate file in PEM or PKCS12 format, including the private\n        key. If not provided, **certificate_data** is required.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 25,
                  "endLine": 18,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\n\nclass CertificateCredential(ClientCredentialBase):\n    \"\"\"Authenticates as a service principal using a certificate.\n\n    The certificate must have an RSA private key, because this credential signs assertions using RS256. See\n    `Microsoft Entra ID documentation\n",
                    "rendered": {
                      "text": "\n\nclass CertificateCredential(ClientCredentialBase):\n    \"\"\"Authenticates as a service principal using a certificate.\n\n    The certificate must have an RSA private key, because this credential signs assertions using RS256. See\n    `Microsoft Entra ID documentation\n",
                      "markdown": "`\n\nclass CertificateCredential(ClientCredentialBase):\n    \"\"\"Authenticates as a service principal using a certificate.\n\n    The certificate must have an RSA private key, because this credential signs assertions using RS256. See\n    `Microsoft Entra ID documentation\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/browser.py"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 25,
                  "endLine": 128,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        # block until the server times out or receives the post-authentication redirect\n        response = server.wait_for_redirect()\n        if not response:\n            if within_dac.get():\n                raise CredentialUnavailableError(\n                    message=\"Timed out after waiting {} seconds for the user to authenticate\".format(self._timeout)\n                )\n",
                    "rendered": {
                      "text": "        # block until the server times out or receives the post-authentication redirect\n        response = server.wait_for_redirect()\n        if not response:\n            if within_dac.get():\n                raise CredentialUnavailableError(\n                    message=\"Timed out after waiting {} seconds for the user to authenticate\".format(self._timeout)\n                )\n",
                      "markdown": "`        # block until the server times out or receives the post-authentication redirect\n        response = server.wait_for_redirect()\n        if not response:\n            if within_dac.get():\n                raise CredentialUnavailableError(\n                    message=\"Timed out after waiting {} seconds for the user to authenticate\".format(self._timeout)\n                )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/browser.py"
                },
                "region": {
                  "startLine": 110,
                  "startColumn": 23,
                  "endLine": 110,
                  "endColumn": 28,
                  "snippet": {
                    "text": "\n        # get the url the user must visit to authenticate\n        scopes = list(scopes)  # type: ignore\n        claims = kwargs.get(\"claims\")\n        app = self._get_app(**kwargs)\n        flow = app.initiate_auth_code_flow(\n            scopes,\n",
                    "rendered": {
                      "text": "\n        # get the url the user must visit to authenticate\n        scopes = list(scopes)  # type: ignore\n        claims = kwargs.get(\"claims\")\n        app = self._get_app(**kwargs)\n        flow = app.initiate_auth_code_flow(\n            scopes,\n",
                      "markdown": "`\n        # get the url the user must visit to authenticate\n        scopes = list(scopes)  # type: ignore\n        claims = kwargs.get(\"claims\")\n        app = self._get_app(**kwargs)\n        flow = app.initiate_auth_code_flow(\n            scopes,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/browser.py"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 61,
                  "endLine": 93,
                  "endColumn": 69,
                  "snippet": {
                    "text": "        if self._parsed_url:\n            try:\n                redirect_uri = \"http://{}:{}\".format(self._parsed_url.hostname, self._parsed_url.port)\n                server = self._server_class(self._parsed_url.hostname, self._parsed_url.port, timeout=self._timeout)\n            except socket.error as ex:\n                raise CredentialUnavailableError(message=\"Couldn't start an HTTP server on \" + redirect_uri) from ex\n        else:\n",
                    "rendered": {
                      "text": "        if self._parsed_url:\n            try:\n                redirect_uri = \"http://{}:{}\".format(self._parsed_url.hostname, self._parsed_url.port)\n                server = self._server_class(self._parsed_url.hostname, self._parsed_url.port, timeout=self._timeout)\n            except socket.error as ex:\n                raise CredentialUnavailableError(message=\"Couldn't start an HTTP server on \" + redirect_uri) from ex\n        else:\n",
                      "markdown": "`        if self._parsed_url:\n            try:\n                redirect_uri = \"http://{}:{}\".format(self._parsed_url.hostname, self._parsed_url.port)\n                server = self._server_class(self._parsed_url.hostname, self._parsed_url.port, timeout=self._timeout)\n            except socket.error as ex:\n                raise CredentialUnavailableError(message=\"Couldn't start an HTTP server on \" + redirect_uri) from ex\n        else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/browser.py"
                },
                "region": {
                  "startLine": 92,
                  "startColumn": 70,
                  "endLine": 92,
                  "endColumn": 78,
                  "snippet": {
                    "text": "        redirect_uri: str = \"\"\n        if self._parsed_url:\n            try:\n                redirect_uri = \"http://{}:{}\".format(self._parsed_url.hostname, self._parsed_url.port)\n                server = self._server_class(self._parsed_url.hostname, self._parsed_url.port, timeout=self._timeout)\n            except socket.error as ex:\n                raise CredentialUnavailableError(message=\"Couldn't start an HTTP server on \" + redirect_uri) from ex\n",
                    "rendered": {
                      "text": "        redirect_uri: str = \"\"\n        if self._parsed_url:\n            try:\n                redirect_uri = \"http://{}:{}\".format(self._parsed_url.hostname, self._parsed_url.port)\n                server = self._server_class(self._parsed_url.hostname, self._parsed_url.port, timeout=self._timeout)\n            except socket.error as ex:\n                raise CredentialUnavailableError(message=\"Couldn't start an HTTP server on \" + redirect_uri) from ex\n",
                      "markdown": "`        redirect_uri: str = \"\"\n        if self._parsed_url:\n            try:\n                redirect_uri = \"http://{}:{}\".format(self._parsed_url.hostname, self._parsed_url.port)\n                server = self._server_class(self._parsed_url.hostname, self._parsed_url.port, timeout=self._timeout)\n            except socket.error as ex:\n                raise CredentialUnavailableError(message=\"Couldn't start an HTTP server on \" + redirect_uri) from ex\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/browser.py"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 37,
                  "endLine": 73,
                  "endColumn": 45,
                  "snippet": {
                    "text": "        redirect_uri = kwargs.pop(\"redirect_uri\", None)\n        if redirect_uri:\n            self._parsed_url = urlparse(redirect_uri)\n            if not (self._parsed_url.hostname and self._parsed_url.port):\n                raise ValueError('\"redirect_uri\" must be a URL with port number, for example \"http://localhost:8400\"')\n        else:\n            self._parsed_url = None\n",
                    "rendered": {
                      "text": "        redirect_uri = kwargs.pop(\"redirect_uri\", None)\n        if redirect_uri:\n            self._parsed_url = urlparse(redirect_uri)\n            if not (self._parsed_url.hostname and self._parsed_url.port):\n                raise ValueError('\"redirect_uri\" must be a URL with port number, for example \"http://localhost:8400\"')\n        else:\n            self._parsed_url = None\n",
                      "markdown": "`        redirect_uri = kwargs.pop(\"redirect_uri\", None)\n        if redirect_uri:\n            self._parsed_url = urlparse(redirect_uri)\n            if not (self._parsed_url.hostname and self._parsed_url.port):\n                raise ValueError('\"redirect_uri\" must be a URL with port number, for example \"http://localhost:8400\"')\n        else:\n            self._parsed_url = None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/client_assertion.py"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 96,
                  "endLine": 20,
                  "endColumn": 102,
                  "snippet": {
                    "text": "\n    :param str tenant_id: ID of the principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The principal's client ID\n    :param func: A callable that returns a string assertion. The credential will call this every time it\n        acquires a new token.\n    :paramtype func: Callable[[], str]\n\n",
                    "rendered": {
                      "text": "\n    :param str tenant_id: ID of the principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The principal's client ID\n    :param func: A callable that returns a string assertion. The credential will call this every time it\n        acquires a new token.\n    :paramtype func: Callable[[], str]\n\n",
                      "markdown": "`\n    :param str tenant_id: ID of the principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The principal's client ID\n    :param func: A callable that returns a string assertion. The credential will call this every time it\n        acquires a new token.\n    :paramtype func: Callable[[], str]\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/client_assertion.py"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 75,
                  "endLine": 16,
                  "endColumn": 84,
                  "snippet": {
                    "text": "    \"\"\"Authenticates a service principal with a JWT assertion.\n\n    This credential is for advanced scenarios. :class:`~azure.identity.CertificateCredential` has a more\n    convenient API for the most common assertion scenario, authenticating a service principal with a certificate.\n\n    :param str tenant_id: ID of the principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The principal's client ID\n",
                    "rendered": {
                      "text": "    \"\"\"Authenticates a service principal with a JWT assertion.\n\n    This credential is for advanced scenarios. :class:`~azure.identity.CertificateCredential` has a more\n    convenient API for the most common assertion scenario, authenticating a service principal with a certificate.\n\n    :param str tenant_id: ID of the principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The principal's client ID\n",
                      "markdown": "`    \"\"\"Authenticates a service principal with a JWT assertion.\n\n    This credential is for advanced scenarios. :class:`~azure.identity.CertificateCredential` has a more\n    convenient API for the most common assertion scenario, authenticating a service principal with a certificate.\n\n    :param str tenant_id: ID of the principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The principal's client ID\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/client_assertion.py"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 22,
                  "endLine": 13,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n\nclass ClientAssertionCredential(AsyncContextManager, GetTokenMixin):\n    \"\"\"Authenticates a service principal with a JWT assertion.\n\n    This credential is for advanced scenarios. :class:`~azure.identity.CertificateCredential` has a more\n    convenient API for the most common assertion scenario, authenticating a service principal with a certificate.\n",
                    "rendered": {
                      "text": "\n\nclass ClientAssertionCredential(AsyncContextManager, GetTokenMixin):\n    \"\"\"Authenticates a service principal with a JWT assertion.\n\n    This credential is for advanced scenarios. :class:`~azure.identity.CertificateCredential` has a more\n    convenient API for the most common assertion scenario, authenticating a service principal with a certificate.\n",
                      "markdown": "`\n\nclass ClientAssertionCredential(AsyncContextManager, GetTokenMixin):\n    \"\"\"Authenticates a service principal with a JWT assertion.\n\n    This credential is for advanced scenarios. :class:`~azure.identity.CertificateCredential` has a more\n    convenient API for the most common assertion scenario, authenticating a service principal with a certificate.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/chained.py"
                },
                "region": {
                  "startLine": 156,
                  "startColumn": 30,
                  "endLine": 156,
                  "endColumn": 35,
                  "snippet": {
                    "text": "                if hasattr(credential, \"get_token_info\"):\n                    token_info = await cast(AsyncSupportsTokenInfo, credential).get_token_info(*scopes, options=options)\n                else:\n                    if options.get(\"pop\"):\n                        raise CredentialUnavailableError(\n                            \"Proof of possession arguments are not supported for this credential.\"\n                        )\n",
                    "rendered": {
                      "text": "                if hasattr(credential, \"get_token_info\"):\n                    token_info = await cast(AsyncSupportsTokenInfo, credential).get_token_info(*scopes, options=options)\n                else:\n                    if options.get(\"pop\"):\n                        raise CredentialUnavailableError(\n                            \"Proof of possession arguments are not supported for this credential.\"\n                        )\n",
                      "markdown": "`                if hasattr(credential, \"get_token_info\"):\n                    token_info = await cast(AsyncSupportsTokenInfo, credential).get_token_info(*scopes, options=options)\n                else:\n                    if options.get(\"pop\"):\n                        raise CredentialUnavailableError(\n                            \"Proof of possession arguments are not supported for this credential.\"\n                        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/chained.py"
                },
                "region": {
                  "startLine": 188,
                  "startColumn": 92,
                  "endLine": 188,
                  "endColumn": 96,
                  "snippet": {
                    "text": "            self.__class__.__name__\n            + \" failed to retrieve a token from the included credentials.\"\n            + attempts\n            + \"\\nTo mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/defaultazurecredential/troubleshoot.\"\n        )\n        _LOGGER.warning(message)\n",
                    "rendered": {
                      "text": "            self.__class__.__name__\n            + \" failed to retrieve a token from the included credentials.\"\n            + attempts\n            + \"\\nTo mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/defaultazurecredential/troubleshoot.\"\n        )\n        _LOGGER.warning(message)\n",
                      "markdown": "`            self.__class__.__name__\n            + \" failed to retrieve a token from the included credentials.\"\n            + attempts\n            + \"\\nTo mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/defaultazurecredential/troubleshoot.\"\n        )\n        _LOGGER.warning(message)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/chained.py"
                },
                "region": {
                  "startLine": 137,
                  "startColumn": 84,
                  "endLine": 137,
                  "endColumn": 88,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/chained.py"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 92,
                  "endLine": 123,
                  "endColumn": 96,
                  "snippet": {
                    "text": "            self.__class__.__name__\n            + \" failed to retrieve a token from the included credentials.\"\n            + attempts\n            + \"\\nTo mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/defaultazurecredential/troubleshoot.\"\n        )\n        raise ClientAuthenticationError(message=message)\n",
                    "rendered": {
                      "text": "            self.__class__.__name__\n            + \" failed to retrieve a token from the included credentials.\"\n            + attempts\n            + \"\\nTo mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/defaultazurecredential/troubleshoot.\"\n        )\n        raise ClientAuthenticationError(message=message)\n",
                      "markdown": "`            self.__class__.__name__\n            + \" failed to retrieve a token from the included credentials.\"\n            + attempts\n            + \"\\nTo mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/defaultazurecredential/troubleshoot.\"\n        )\n        raise ClientAuthenticationError(message=message)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/chained.py"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 84,
                  "endLine": 67,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 72,
                  "endLine": 57,
                  "endColumn": 77,
                  "snippet": {
                    "text": "        client_credential = get_client_credential(certificate_path, **kwargs)\n\n        self._certificate = AadClientCertificate(\n            client_credential[\"private_key\"], password=client_credential.get(\"passphrase\")\n        )\n\n        self._client = AadClient(tenant_id, client_id, **kwargs)\n",
                    "rendered": {
                      "text": "        client_credential = get_client_credential(certificate_path, **kwargs)\n\n        self._certificate = AadClientCertificate(\n            client_credential[\"private_key\"], password=client_credential.get(\"passphrase\")\n        )\n\n        self._client = AadClient(tenant_id, client_id, **kwargs)\n",
                      "markdown": "`        client_credential = get_client_credential(certificate_path, **kwargs)\n\n        self._certificate = AadClientCertificate(\n            client_credential[\"private_key\"], password=client_credential.get(\"passphrase\")\n        )\n\n        self._client = AadClient(tenant_id, client_id, **kwargs)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 46,
                  "endLine": 57,
                  "endColumn": 54,
                  "snippet": {
                    "text": "        client_credential = get_client_credential(certificate_path, **kwargs)\n\n        self._certificate = AadClientCertificate(\n            client_credential[\"private_key\"], password=client_credential.get(\"passphrase\")\n        )\n\n        self._client = AadClient(tenant_id, client_id, **kwargs)\n",
                    "rendered": {
                      "text": "        client_credential = get_client_credential(certificate_path, **kwargs)\n\n        self._certificate = AadClientCertificate(\n            client_credential[\"private_key\"], password=client_credential.get(\"passphrase\")\n        )\n\n        self._client = AadClient(tenant_id, client_id, **kwargs)\n",
                      "markdown": "`        client_credential = get_client_credential(certificate_path, **kwargs)\n\n        self._certificate = AadClientCertificate(\n            client_credential[\"private_key\"], password=client_credential.get(\"passphrase\")\n        )\n\n        self._client = AadClient(tenant_id, client_id, **kwargs)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 31,
                  "endLine": 57,
                  "endColumn": 42,
                  "snippet": {
                    "text": "        client_credential = get_client_credential(certificate_path, **kwargs)\n\n        self._certificate = AadClientCertificate(\n            client_credential[\"private_key\"], password=client_credential.get(\"passphrase\")\n        )\n\n        self._client = AadClient(tenant_id, client_id, **kwargs)\n",
                    "rendered": {
                      "text": "        client_credential = get_client_credential(certificate_path, **kwargs)\n\n        self._certificate = AadClientCertificate(\n            client_credential[\"private_key\"], password=client_credential.get(\"passphrase\")\n        )\n\n        self._client = AadClient(tenant_id, client_id, **kwargs)\n",
                      "markdown": "`        client_credential = get_client_credential(certificate_path, **kwargs)\n\n        self._certificate = AadClientCertificate(\n            client_credential[\"private_key\"], password=client_credential.get(\"passphrase\")\n        )\n\n        self._client = AadClient(tenant_id, client_id, **kwargs)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 15,
                  "endLine": 33,
                  "endColumn": 23,
                  "snippet": {
                    "text": "    :keyword bytes certificate_data: The bytes of a certificate in PEM format, including the private key\n    :keyword password: The certificate's password. If a unicode string, it will be encoded as UTF-8. If the certificate\n          requires a different encoding, pass appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword cache_persistence_options: Configuration for persistent token caching. If unspecified, the credential\n          will cache tokens in memory.\n    :paramtype cache_persistence_options: ~azure.identity.TokenCachePersistenceOptions\n",
                    "rendered": {
                      "text": "    :keyword bytes certificate_data: The bytes of a certificate in PEM format, including the private key\n    :keyword password: The certificate's password. If a unicode string, it will be encoded as UTF-8. If the certificate\n          requires a different encoding, pass appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword cache_persistence_options: Configuration for persistent token caching. If unspecified, the credential\n          will cache tokens in memory.\n    :paramtype cache_persistence_options: ~azure.identity.TokenCachePersistenceOptions\n",
                      "markdown": "`    :keyword bytes certificate_data: The bytes of a certificate in PEM format, including the private key\n    :keyword password: The certificate's password. If a unicode string, it will be encoded as UTF-8. If the certificate\n          requires a different encoding, pass appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword cache_persistence_options: Configuration for persistent token caching. If unspecified, the credential\n          will cache tokens in memory.\n    :paramtype cache_persistence_options: ~azure.identity.TokenCachePersistenceOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 41,
                  "endLine": 31,
                  "endColumn": 49,
                  "snippet": {
                    "text": "the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n          defines authorities for other clouds.\n    :keyword bytes certificate_data: The bytes of a certificate in PEM format, including the private key\n    :keyword password: The certificate's password. If a unicode string, it will be encoded as UTF-8. If the certificate\n          requires a different encoding, pass appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword cache_persistence_options: Configuration for persistent token caching. If unspecified, the cred",
                    "rendered": {
                      "text": "the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n          defines authorities for other clouds.\n    :keyword bytes certificate_data: The bytes of a certificate in PEM format, including the private key\n    :keyword password: The certificate's password. If a unicode string, it will be encoded as UTF-8. If the certificate\n          requires a different encoding, pass appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword cache_persistence_options: Configuration for persistent token caching. If unspecified, the cred",
                      "markdown": "`the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n          defines authorities for other clouds.\n    :keyword bytes certificate_data: The bytes of a certificate in PEM format, including the private key\n    :keyword password: The certificate's password. If a unicode string, it will be encoded as UTF-8. If the certificate\n          requires a different encoding, pass appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword cache_persistence_options: Configuration for persistent token caching. If unspecified, the cred`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 13,
                  "endLine": 31,
                  "endColumn": 21,
                  "snippet": {
                    "text": "osoftonline.com',\n          the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n          defines authorities for other clouds.\n    :keyword bytes certificate_data: The bytes of a certificate in PEM format, including the private key\n    :keyword password: The certificate's password. If a unicode string, it will be encoded as UTF-8. If the certificate\n          requires a different encoding, pass appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword cache_persistence_options: Configuration for persistent token cachi",
                    "rendered": {
                      "text": "osoftonline.com',\n          the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n          defines authorities for other clouds.\n    :keyword bytes certificate_data: The bytes of a certificate in PEM format, including the private key\n    :keyword password: The certificate's password. If a unicode string, it will be encoded as UTF-8. If the certificate\n          requires a different encoding, pass appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword cache_persistence_options: Configuration for persistent token cachi",
                      "markdown": "`osoftonline.com',\n          the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n          defines authorities for other clouds.\n    :keyword bytes certificate_data: The bytes of a certificate in PEM format, including the private key\n    :keyword password: The certificate's password. If a unicode string, it will be encoded as UTF-8. If the certificate\n          requires a different encoding, pass appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword cache_persistence_options: Configuration for persistent token cachi`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 29,
                  "endLine": 23,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    for more information on configuring certificate authentication.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its 'directory' ID.\n    :param str client_id: The service principal's client ID\n    :param str certificate_path: Path to a PEM-encoded certificate file including the private key. If not provided,\n          `certificate_data` is required.\n\n",
                    "rendered": {
                      "text": "    for more information on configuring certificate authentication.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its 'directory' ID.\n    :param str client_id: The service principal's client ID\n    :param str certificate_path: Path to a PEM-encoded certificate file including the private key. If not provided,\n          `certificate_data` is required.\n\n",
                      "markdown": "`    for more information on configuring certificate authentication.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its 'directory' ID.\n    :param str client_id: The service principal's client ID\n    :param str certificate_path: Path to a PEM-encoded certificate file including the private key. If not provided,\n          `certificate_data` is required.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 35,
                  "endLine": 22,
                  "endColumn": 44,
                  "snippet": {
                    "text": "    <https://learn.microsoft.com/entra/identity-platform/certificate-credentials#register-your-certificate-with-microsoft-identity-platform>`__\n    for more information on configuring certificate authentication.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its 'directory' ID.\n    :param str client_id: The service principal's client ID\n    :param str certificate_path: Path to a PEM-encoded certificate file including the private key. If not provided,\n          `certificate_data` is required.\n",
                    "rendered": {
                      "text": "    <https://learn.microsoft.com/entra/identity-platform/certificate-credentials#register-your-certificate-with-microsoft-identity-platform>`__\n    for more information on configuring certificate authentication.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its 'directory' ID.\n    :param str client_id: The service principal's client ID\n    :param str certificate_path: Path to a PEM-encoded certificate file including the private key. If not provided,\n          `certificate_data` is required.\n",
                      "markdown": "`    <https://learn.microsoft.com/entra/identity-platform/certificate-credentials#register-your-certificate-with-microsoft-identity-platform>`__\n    for more information on configuring certificate authentication.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its 'directory' ID.\n    :param str client_id: The service principal's client ID\n    :param str certificate_path: Path to a PEM-encoded certificate file including the private key. If not provided,\n          `certificate_data` is required.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/certificate.py"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 25,
                  "endLine": 15,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\n\nclass CertificateCredential(AsyncContextManager, GetTokenMixin):\n    \"\"\"Authenticates as a service principal using a certificate.\n\n    The certificate must have an RSA private key, because this credential signs assertions using RS256. See\n    `Microsoft Entra ID documentation\n",
                    "rendered": {
                      "text": "\n\nclass CertificateCredential(AsyncContextManager, GetTokenMixin):\n    \"\"\"Authenticates as a service principal using a certificate.\n\n    The certificate must have an RSA private key, because this credential signs assertions using RS256. See\n    `Microsoft Entra ID documentation\n",
                      "markdown": "`\n\nclass CertificateCredential(AsyncContextManager, GetTokenMixin):\n    \"\"\"Authenticates as a service principal using a certificate.\n\n    The certificate must have an RSA private key, because this credential signs assertions using RS256. See\n    `Microsoft Entra ID documentation\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_powershell.py"
                },
                "region": {
                  "startLine": 122,
                  "startColumn": 27,
                  "endLine": 122,
                  "endColumn": 32,
                  "snippet": {
                    "text": "    async def _get_token_base(\n        self, *scopes: str, options: Optional[TokenRequestOptions] = None, **kwargs: Any\n    ) -> AccessTokenInfo:\n        tenant_id = options.get(\"tenant_id\") if options else None\n        if tenant_id:\n            validate_tenant_id(tenant_id)\n        for scope in scopes:\n",
                    "rendered": {
                      "text": "    async def _get_token_base(\n        self, *scopes: str, options: Optional[TokenRequestOptions] = None, **kwargs: Any\n    ) -> AccessTokenInfo:\n        tenant_id = options.get(\"tenant_id\") if options else None\n        if tenant_id:\n            validate_tenant_id(tenant_id)\n        for scope in scopes:\n",
                      "markdown": "`    async def _get_token_base(\n        self, *scopes: str, options: Optional[TokenRequestOptions] = None, **kwargs: Any\n    ) -> AccessTokenInfo:\n        tenant_id = options.get(\"tenant_id\") if options else None\n        if tenant_id:\n            validate_tenant_id(tenant_id)\n        for scope in scopes:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_powershell.py"
                },
                "region": {
                  "startLine": 164,
                  "startColumn": 88,
                  "endLine": 164,
                  "endColumn": 92,
                  "snippet": {
                    "text": "        # failed to execute \"cmd\" or \"/bin/sh\"; Azure PowerShell may or may not be installed\n        error = CredentialUnavailableError(\n            message='Failed to execute \"{}\".\\n'\n            \"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/powershellcredential/troubleshoot.\".format(command_line[0])\n        )\n        raise error from ex\n",
                    "rendered": {
                      "text": "        # failed to execute \"cmd\" or \"/bin/sh\"; Azure PowerShell may or may not be installed\n        error = CredentialUnavailableError(\n            message='Failed to execute \"{}\".\\n'\n            \"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/powershellcredential/troubleshoot.\".format(command_line[0])\n        )\n        raise error from ex\n",
                      "markdown": "`        # failed to execute \"cmd\" or \"/bin/sh\"; Azure PowerShell may or may not be installed\n        error = CredentialUnavailableError(\n            message='Failed to execute \"{}\".\\n'\n            \"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/powershellcredential/troubleshoot.\".format(command_line[0])\n        )\n        raise error from ex\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_powershell.py"
                },
                "region": {
                  "startLine": 157,
                  "startColumn": 88,
                  "endLine": 157,
                  "endColumn": 92,
                  "snippet": {
                    "text": "        proc.kill()\n        raise CredentialUnavailableError(\n            message=\"Timed out waiting for Azure PowerShell.\\n\"\n            \"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/powershellcredential/troubleshoot.\"\n        ) from ex\n    except OSError as ex:\n",
                    "rendered": {
                      "text": "        proc.kill()\n        raise CredentialUnavailableError(\n            message=\"Timed out waiting for Azure PowerShell.\\n\"\n            \"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/powershellcredential/troubleshoot.\"\n        ) from ex\n    except OSError as ex:\n",
                      "markdown": "`        proc.kill()\n        raise CredentialUnavailableError(\n            message=\"Timed out waiting for Azure PowerShell.\\n\"\n            \"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/powershellcredential/troubleshoot.\"\n        ) from ex\n    except OSError as ex:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/linux_vscode_adapter.py"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 30,
                  "endLine": 67,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    schema.name = _c_str(\"org.freedesktop.Secret.Generic\")  # pylint: disable=attribute-defined-outside-init\n    schema.flags = 2  # pylint: disable=attribute-defined-outside-init\n    schema.attributes = pattributes  # pylint: disable=attribute-defined-outside-init\n    p_str = _libsecret.secret_password_lookup_sync(\n        pschema,\n        None,\n        ct.byref(err),\n",
                    "rendered": {
                      "text": "    schema.name = _c_str(\"org.freedesktop.Secret.Generic\")  # pylint: disable=attribute-defined-outside-init\n    schema.flags = 2  # pylint: disable=attribute-defined-outside-init\n    schema.attributes = pattributes  # pylint: disable=attribute-defined-outside-init\n    p_str = _libsecret.secret_password_lookup_sync(\n        pschema,\n        None,\n        ct.byref(err),\n",
                      "markdown": "`    schema.name = _c_str(\"org.freedesktop.Secret.Generic\")  # pylint: disable=attribute-defined-outside-init\n    schema.flags = 2  # pylint: disable=attribute-defined-outside-init\n    schema.attributes = pattributes  # pylint: disable=attribute-defined-outside-init\n    p_str = _libsecret.secret_password_lookup_sync(\n        pschema,\n        None,\n        ct.byref(err),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/linux_vscode_adapter.py"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 22,
                  "endLine": 49,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        ct.c_void_p,\n    ]\n    _libsecret.secret_password_lookup_sync.restype = ct.c_char_p\n    _libsecret.secret_password_free.argtypes = [ct.c_char_p]\nexcept OSError:\n    _libsecret = None  # type: ignore\n\n",
                    "rendered": {
                      "text": "        ct.c_void_p,\n    ]\n    _libsecret.secret_password_lookup_sync.restype = ct.c_char_p\n    _libsecret.secret_password_free.argtypes = [ct.c_char_p]\nexcept OSError:\n    _libsecret = None  # type: ignore\n\n",
                      "markdown": "`        ct.c_void_p,\n    ]\n    _libsecret.secret_password_lookup_sync.restype = ct.c_char_p\n    _libsecret.secret_password_free.argtypes = [ct.c_char_p]\nexcept OSError:\n    _libsecret = None  # type: ignore\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/linux_vscode_adapter.py"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 22,
                  "endLine": 48,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        ct.c_char_p,\n        ct.c_void_p,\n    ]\n    _libsecret.secret_password_lookup_sync.restype = ct.c_char_p\n    _libsecret.secret_password_free.argtypes = [ct.c_char_p]\nexcept OSError:\n    _libsecret = None  # type: ignore\n",
                    "rendered": {
                      "text": "        ct.c_char_p,\n        ct.c_void_p,\n    ]\n    _libsecret.secret_password_lookup_sync.restype = ct.c_char_p\n    _libsecret.secret_password_free.argtypes = [ct.c_char_p]\nexcept OSError:\n    _libsecret = None  # type: ignore\n",
                      "markdown": "`        ct.c_char_p,\n        ct.c_void_p,\n    ]\n    _libsecret.secret_password_lookup_sync.restype = ct.c_char_p\n    _libsecret.secret_password_free.argtypes = [ct.c_char_p]\nexcept OSError:\n    _libsecret = None  # type: ignore\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/linux_vscode_adapter.py"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 22,
                  "endLine": 38,
                  "endColumn": 30,
                  "snippet": {
                    "text": "\ntry:\n    _libsecret = ct.cdll.LoadLibrary(\"libsecret-1.so.0\")\n    _libsecret.secret_password_lookup_sync.argtypes = [\n        ct.c_void_p,\n        ct.c_void_p,\n        ct.c_void_p,\n",
                    "rendered": {
                      "text": "\ntry:\n    _libsecret = ct.cdll.LoadLibrary(\"libsecret-1.so.0\")\n    _libsecret.secret_password_lookup_sync.argtypes = [\n        ct.c_void_p,\n        ct.c_void_p,\n        ct.c_void_p,\n",
                      "markdown": "`\ntry:\n    _libsecret = ct.cdll.LoadLibrary(\"libsecret-1.so.0\")\n    _libsecret.secret_password_lookup_sync.argtypes = [\n        ct.c_void_p,\n        ct.c_void_p,\n        ct.c_void_p,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 290,
                  "startColumn": 41,
                  "endLine": 290,
                  "endColumn": 46,
                  "snippet": {
                    "text": "                    return AccessTokenInfo(\n                        result[\"access_token\"],\n                        now + int(result[\"expires_in\"]),\n                        token_type=result.get(\"token_type\", \"Bearer\"),\n                        refresh_on=refresh_on,\n                    )\n\n",
                    "rendered": {
                      "text": "                    return AccessTokenInfo(\n                        result[\"access_token\"],\n                        now + int(result[\"expires_in\"]),\n                        token_type=result.get(\"token_type\", \"Bearer\"),\n                        refresh_on=refresh_on,\n                    )\n\n",
                      "markdown": "`                    return AccessTokenInfo(\n                        result[\"access_token\"],\n                        now + int(result[\"expires_in\"]),\n                        token_type=result.get(\"token_type\", \"Bearer\"),\n                        refresh_on=refresh_on,\n                    )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 280,
                  "startColumn": 26,
                  "endLine": 280,
                  "endColumn": 31,
                  "snippet": {
                    "text": "        if self._auth_record:\n            app = self._get_app(**kwargs)\n            for account in app.get_accounts(username=self._auth_record.username):\n                if account.get(\"home_account_id\") != self._auth_record.home_account_id:\n                    continue\n\n                now = int(time.time())\n",
                    "rendered": {
                      "text": "        if self._auth_record:\n            app = self._get_app(**kwargs)\n            for account in app.get_accounts(username=self._auth_record.username):\n                if account.get(\"home_account_id\") != self._auth_record.home_account_id:\n                    continue\n\n                now = int(time.time())\n",
                      "markdown": "`        if self._auth_record:\n            app = self._get_app(**kwargs)\n            for account in app.get_accounts(username=self._auth_record.username):\n                if account.get(\"home_account_id\") != self._auth_record.home_account_id:\n                    continue\n\n                now = int(time.time())\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 276,
                  "startColumn": 23,
                  "endLine": 276,
                  "endColumn": 28,
                  "snippet": {
                    "text": "    @wrap_exceptions\n    def _acquire_token_silent(self, *scopes: str, **kwargs: Any) -> AccessTokenInfo:\n        result = None\n        claims = kwargs.get(\"claims\")\n        if self._auth_record:\n            app = self._get_app(**kwargs)\n            for account in app.get_accounts(username=self._auth_record.username):\n",
                    "rendered": {
                      "text": "    @wrap_exceptions\n    def _acquire_token_silent(self, *scopes: str, **kwargs: Any) -> AccessTokenInfo:\n        result = None\n        claims = kwargs.get(\"claims\")\n        if self._auth_record:\n            app = self._get_app(**kwargs)\n            for account in app.get_accounts(username=self._auth_record.username):\n",
                      "markdown": "`    @wrap_exceptions\n    def _acquire_token_silent(self, *scopes: str, **kwargs: Any) -> AccessTokenInfo:\n        result = None\n        claims = kwargs.get(\"claims\")\n        if self._auth_record:\n            app = self._get_app(**kwargs)\n            for account in app.get_accounts(username=self._auth_record.username):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 242,
                  "startColumn": 29,
                  "endLine": 242,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        return AccessTokenInfo(\n            result[\"access_token\"],\n            now + int(result[\"expires_in\"]),\n            token_type=result.get(\"token_type\", \"Bearer\"),\n            refresh_on=refresh_on,\n        )\n\n",
                    "rendered": {
                      "text": "        return AccessTokenInfo(\n            result[\"access_token\"],\n            now + int(result[\"expires_in\"]),\n            token_type=result.get(\"token_type\", \"Bearer\"),\n            refresh_on=refresh_on,\n        )\n\n",
                      "markdown": "`        return AccessTokenInfo(\n            result[\"access_token\"],\n            now + int(result[\"expires_in\"]),\n            token_type=result.get(\"token_type\", \"Bearer\"),\n            refresh_on=refresh_on,\n        )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 221,
                  "startColumn": 102,
                  "endLine": 221,
                  "endColumn": 107,
                  "snippet": {
                    "text": "        try:\n            result = self._request_token(*scopes, claims=claims, tenant_id=tenant_id, enable_cae=enable_cae, **kwargs)\n            if \"access_token\" not in result:\n                message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n                response = self._client.get_error_response(result)\n                raise ClientAuthenticationError(message=message, response=response)\n\n",
                    "rendered": {
                      "text": "        try:\n            result = self._request_token(*scopes, claims=claims, tenant_id=tenant_id, enable_cae=enable_cae, **kwargs)\n            if \"access_token\" not in result:\n                message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n                response = self._client.get_error_response(result)\n                raise ClientAuthenticationError(message=message, response=response)\n\n",
                      "markdown": "`        try:\n            result = self._request_token(*scopes, claims=claims, tenant_id=tenant_id, enable_cae=enable_cae, **kwargs)\n            if \"access_token\" not in result:\n                message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n                response = self._client.get_error_response(result)\n                raise ClientAuthenticationError(message=message, response=response)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 221,
                  "startColumn": 67,
                  "endLine": 221,
                  "endColumn": 72,
                  "snippet": {
                    "text": "        try:\n            result = self._request_token(*scopes, claims=claims, tenant_id=tenant_id, enable_cae=enable_cae, **kwargs)\n            if \"access_token\" not in result:\n                message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n                response = self._client.get_error_response(result)\n                raise ClientAuthenticationError(message=message, response=response)\n\n",
                    "rendered": {
                      "text": "        try:\n            result = self._request_token(*scopes, claims=claims, tenant_id=tenant_id, enable_cae=enable_cae, **kwargs)\n            if \"access_token\" not in result:\n                message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n                response = self._client.get_error_response(result)\n                raise ClientAuthenticationError(message=message, response=response)\n\n",
                      "markdown": "`        try:\n            result = self._request_token(*scopes, claims=claims, tenant_id=tenant_id, enable_cae=enable_cae, **kwargs)\n            if \"access_token\" not in result:\n                message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n                response = self._client.get_error_response(result)\n                raise ClientAuthenticationError(message=message, response=response)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 191,
                  "startColumn": 28,
                  "endLine": 191,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        # Check for arbitrary additional options to enable intermediary support for PoP tokens.\n        for key in options:\n",
                    "rendered": {
                      "text": "        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        # Check for arbitrary additional options to enable intermediary support for PoP tokens.\n        for key in options:\n",
                      "markdown": "`        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        # Check for arbitrary additional options to enable intermediary support for PoP tokens.\n        for key in options:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 190,
                  "startColumn": 27,
                  "endLine": 190,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        allow_prompt = kwargs.pop(\"_allow_prompt\", not self._disable_automatic_authentication)\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        # Check for arbitrary additional options to enable intermediary support for PoP tokens.\n",
                    "rendered": {
                      "text": "        allow_prompt = kwargs.pop(\"_allow_prompt\", not self._disable_automatic_authentication)\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        # Check for arbitrary additional options to enable intermediary support for PoP tokens.\n",
                      "markdown": "`        allow_prompt = kwargs.pop(\"_allow_prompt\", not self._disable_automatic_authentication)\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        # Check for arbitrary additional options to enable intermediary support for PoP tokens.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 189,
                  "startColumn": 24,
                  "endLine": 189,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n        allow_prompt = kwargs.pop(\"_allow_prompt\", not self._disable_automatic_authentication)\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n",
                    "rendered": {
                      "text": "\n        allow_prompt = kwargs.pop(\"_allow_prompt\", not self._disable_automatic_authentication)\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n",
                      "markdown": "`\n        allow_prompt = kwargs.pop(\"_allow_prompt\", not self._disable_automatic_authentication)\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 27,
                  "endLine": 75,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        tenant_id = id_token.get(\"tid\") or issuer.path.strip(\"/\")\n\n        # Microsoft Entra ID returns \"preferred_username\", ADFS returns \"upn\"\n        username = id_token.get(\"preferred_username\") or id_token[\"upn\"]\n\n        return AuthenticationRecord(\n            authority=issuer.netloc,\n",
                    "rendered": {
                      "text": "        tenant_id = id_token.get(\"tid\") or issuer.path.strip(\"/\")\n\n        # Microsoft Entra ID returns \"preferred_username\", ADFS returns \"upn\"\n        username = id_token.get(\"preferred_username\") or id_token[\"upn\"]\n\n        return AuthenticationRecord(\n            authority=issuer.netloc,\n",
                      "markdown": "`        tenant_id = id_token.get(\"tid\") or issuer.path.strip(\"/\")\n\n        # Microsoft Entra ID returns \"preferred_username\", ADFS returns \"upn\"\n        username = id_token.get(\"preferred_username\") or id_token[\"upn\"]\n\n        return AuthenticationRecord(\n            authority=issuer.netloc,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 28,
                  "endLine": 72,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        issuer = urlparse(id_token[\"iss\"])\n\n        # tenant which issued the token, not necessarily user's home tenant\n        tenant_id = id_token.get(\"tid\") or issuer.path.strip(\"/\")\n\n        # Microsoft Entra ID returns \"preferred_username\", ADFS returns \"upn\"\n        username = id_token.get(\"preferred_username\") or id_token[\"upn\"]\n",
                    "rendered": {
                      "text": "        issuer = urlparse(id_token[\"iss\"])\n\n        # tenant which issued the token, not necessarily user's home tenant\n        tenant_id = id_token.get(\"tid\") or issuer.path.strip(\"/\")\n\n        # Microsoft Entra ID returns \"preferred_username\", ADFS returns \"upn\"\n        username = id_token.get(\"preferred_username\") or id_token[\"upn\"]\n",
                      "markdown": "`        issuer = urlparse(id_token[\"iss\"])\n\n        # tenant which issued the token, not necessarily user's home tenant\n        tenant_id = id_token.get(\"tid\") or issuer.path.strip(\"/\")\n\n        # Microsoft Entra ID returns \"preferred_username\", ADFS returns \"upn\"\n        username = id_token.get(\"preferred_username\") or id_token[\"upn\"]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 11,
                  "endLine": 45,
                  "endColumn": 17,
                  "snippet": {
                    "text": "\n    raw += \"=\" * (-len(raw) % 4)\n    raw = str(raw)  # On Python 2.7, argument of urlsafe_b64decode must be str, not unicode.\n    return base64.urlsafe_b64decode(raw).decode(\"utf-8\")\n\n\ndef _build_auth_record(response):\n",
                    "rendered": {
                      "text": "\n    raw += \"=\" * (-len(raw) % 4)\n    raw = str(raw)  # On Python 2.7, argument of urlsafe_b64decode must be str, not unicode.\n    return base64.urlsafe_b64decode(raw).decode(\"utf-8\")\n\n\ndef _build_auth_record(response):\n",
                      "markdown": "`\n    raw += \"=\" * (-len(raw) % 4)\n    raw = str(raw)  # On Python 2.7, argument of urlsafe_b64decode must be str, not unicode.\n    return base64.urlsafe_b64decode(raw).decode(\"utf-8\")\n\n\ndef _build_auth_record(response):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 20,
                  "endLine": 38,
                  "endColumn": 26,
                  "snippet": {
                    "text": "def _decode_client_info(raw) -> str:\n    \"\"\"Decode client info. Taken from msal.oauth2cli.oidc.\n\n    :param str raw: base64-encoded client info\n    :return: decoded client info\n    :rtype: str\n    \"\"\"\n",
                    "rendered": {
                      "text": "def _decode_client_info(raw) -> str:\n    \"\"\"Decode client info. Taken from msal.oauth2cli.oidc.\n\n    :param str raw: base64-encoded client info\n    :return: decoded client info\n    :rtype: str\n    \"\"\"\n",
                      "markdown": "`def _decode_client_info(raw) -> str:\n    \"\"\"Decode client info. Taken from msal.oauth2cli.oidc.\n\n    :param str raw: base64-encoded client info\n    :return: decoded client info\n    :rtype: str\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 7,
                  "endLine": 8,
                  "endColumn": 13,
                  "snippet": {
                    "text": "\"\"\"Base class for credentials using MSAL for interactive user authentication\"\"\"\n\nimport abc\nimport base64\nimport json\nimport logging\nimport time\n",
                    "rendered": {
                      "text": "\"\"\"Base class for credentials using MSAL for interactive user authentication\"\"\"\n\nimport abc\nimport base64\nimport json\nimport logging\nimport time\n",
                      "markdown": "`\"\"\"Base class for credentials using MSAL for interactive user authentication\"\"\"\n\nimport abc\nimport base64\nimport json\nimport logging\nimport time\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 183,
                  "startColumn": 53,
                  "endLine": 183,
                  "endColumn": 57,
                  "snippet": {
                    "text": "        **kwargs: Any,\n    ) -> AccessTokenInfo:\n        if not scopes:\n            message = f\"'{base_method_name}' requires at least one scope\"\n            _LOGGER.warning(\"%s.%s failed: %s\", self.__class__.__name__, base_method_name, message)\n            raise ValueError(message)\n\n",
                    "rendered": {
                      "text": "        **kwargs: Any,\n    ) -> AccessTokenInfo:\n        if not scopes:\n            message = f\"'{base_method_name}' requires at least one scope\"\n            _LOGGER.warning(\"%s.%s failed: %s\", self.__class__.__name__, base_method_name, message)\n            raise ValueError(message)\n\n",
                      "markdown": "`        **kwargs: Any,\n    ) -> AccessTokenInfo:\n        if not scopes:\n            message = f\"'{base_method_name}' requires at least one scope\"\n            _LOGGER.warning(\"%s.%s failed: %s\", self.__class__.__name__, base_method_name, message)\n            raise ValueError(message)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 158,
                  "startColumn": 84,
                  "endLine": 158,
                  "endColumn": 88,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 125,
                  "startColumn": 84,
                  "endLine": 125,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 6,
                  "endLine": 12,
                  "snippet": {
                    "text": "import base64\nimport json\nimport logging\nimport time\nfrom typing import Any, Optional, Iterable, Dict\nfrom urllib.parse import urlparse\n\nfrom azure.core.credentials import AccessToken, AccessTokenInfo, TokenRequestOptions\n",
                    "rendered": {
                      "text": "import base64\nimport json\nimport logging\nimport time\nfrom typing import Any, Optional, Iterable, Dict\nfrom urllib.parse import urlparse\n\nfrom azure.core.credentials import AccessToken, AccessTokenInfo, TokenRequestOptions\n",
                      "markdown": "`import base64\nimport json\nimport logging\nimport time\nfrom typing import Any, Optional, Iterable, Dict\nfrom urllib.parse import urlparse\n\nfrom azure.core.credentials import AccessToken, AccessTokenInfo, TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/interactive.py"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 6,
                  "endLine": 9,
                  "snippet": {
                    "text": "\"\"\"Base class for credentials using MSAL for interactive user authentication\"\"\"\n\nimport abc\nimport base64\nimport json\nimport logging\nimport time\nfrom typing import Any, Optional, Iterable, Dict\n",
                    "rendered": {
                      "text": "\"\"\"Base class for credentials using MSAL for interactive user authentication\"\"\"\n\nimport abc\nimport base64\nimport json\nimport logging\nimport time\nfrom typing import Any, Optional, Iterable, Dict\n",
                      "markdown": "`\"\"\"Base class for credentials using MSAL for interactive user authentication\"\"\"\n\nimport abc\nimport base64\nimport json\nimport logging\nimport time\nfrom typing import Any, Optional, Iterable, Dict\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 56,
                  "endLine": 104,
                  "endColumn": 61,
                  "snippet": {
                    "text": "            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n            from .workload_identity import WorkloadIdentityCredential\n\n            workload_client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n            if not workload_client_id:\n                raise ValueError('Configure the environment with a client ID or pass a value for \"client_id\" argument')\n\n",
                    "rendered": {
                      "text": "            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n            from .workload_identity import WorkloadIdentityCredential\n\n            workload_client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n            if not workload_client_id:\n                raise ValueError('Configure the environment with a client ID or pass a value for \"client_id\" argument')\n\n",
                      "markdown": "`            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n            from .workload_identity import WorkloadIdentityCredential\n\n            workload_client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n            if not workload_client_id:\n                raise ValueError('Configure the environment with a client ID or pass a value for \"client_id\" argument')\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 26,
                  "endLine": 98,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n                self._credential = CloudShellCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif (\n            all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS)\n            and not exclude_workload_identity\n        ):\n            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n",
                    "rendered": {
                      "text": "\n                self._credential = CloudShellCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif (\n            all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS)\n            and not exclude_workload_identity\n        ):\n            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n",
                      "markdown": "`\n                self._credential = CloudShellCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif (\n            all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS)\n            and not exclude_workload_identity\n        ):\n            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 87,
                  "startColumn": 25,
                  "endLine": 87,
                  "endColumn": 30,
                  "snippet": {
                    "text": "\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n\n",
                    "rendered": {
                      "text": "\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n\n",
                      "markdown": "`\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 23,
                  "endLine": 86,
                  "endColumn": 28,
                  "snippet": {
                    "text": "                from .azure_arc import AzureArcCredential\n\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n",
                    "rendered": {
                      "text": "                from .azure_arc import AzureArcCredential\n\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n",
                      "markdown": "`                from .azure_arc import AzureArcCredential\n\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 81,
                  "startColumn": 27,
                  "endLine": 81,
                  "endColumn": 32,
                  "snippet": {
                    "text": "                    self._credential = AppServiceCredential(\n                        client_id=client_id, identity_config=identity_config, **kwargs\n                    )\n            elif os.environ.get(EnvironmentVariables.IMDS_ENDPOINT):\n                _LOGGER.info(\"%s will use Azure Arc managed identity\", self.__class__.__name__)\n                from .azure_arc import AzureArcCredential\n\n",
                    "rendered": {
                      "text": "                    self._credential = AppServiceCredential(\n                        client_id=client_id, identity_config=identity_config, **kwargs\n                    )\n            elif os.environ.get(EnvironmentVariables.IMDS_ENDPOINT):\n                _LOGGER.info(\"%s will use Azure Arc managed identity\", self.__class__.__name__)\n                from .azure_arc import AzureArcCredential\n\n",
                      "markdown": "`                    self._credential = AppServiceCredential(\n                        client_id=client_id, identity_config=identity_config, **kwargs\n                    )\n            elif os.environ.get(EnvironmentVariables.IMDS_ENDPOINT):\n                _LOGGER.info(\"%s will use Azure Arc managed identity\", self.__class__.__name__)\n                from .azure_arc import AzureArcCredential\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 29,
                  "endLine": 67,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n\n",
                    "rendered": {
                      "text": "        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n\n",
                      "markdown": "`        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 25,
                  "endLine": 66,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        self._credential: Optional[SupportsTokenInfo] = None\n        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n",
                    "rendered": {
                      "text": "        self._credential: Optional[SupportsTokenInfo] = None\n        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n",
                      "markdown": "`        self._credential: Optional[SupportsTokenInfo] = None\n        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 21,
                  "endLine": 65,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        validate_identity_config(client_id, identity_config)\n        self._credential: Optional[SupportsTokenInfo] = None\n        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n",
                    "rendered": {
                      "text": "        validate_identity_config(client_id, identity_config)\n        self._credential: Optional[SupportsTokenInfo] = None\n        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n",
                      "markdown": "`        validate_identity_config(client_id, identity_config)\n        self._credential: Optional[SupportsTokenInfo] = None\n        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 49,
                  "endLine": 104,
                  "endColumn": 60,
                  "snippet": {
                    "text": "            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n            from .workload_identity import WorkloadIdentityCredential\n\n            workload_client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n            if not workload_client_id:\n                raise ValueError('Configure the environment with a client ID or pass a value for \"client_id\" argument')\n\n",
                    "rendered": {
                      "text": "            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n            from .workload_identity import WorkloadIdentityCredential\n\n            workload_client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n            if not workload_client_id:\n                raise ValueError('Configure the environment with a client ID or pass a value for \"client_id\" argument')\n\n",
                      "markdown": "`            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n            from .workload_identity import WorkloadIdentityCredential\n\n            workload_client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n            if not workload_client_id:\n                raise ValueError('Configure the environment with a client ID or pass a value for \"client_id\" argument')\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 19,
                  "endLine": 98,
                  "endColumn": 30,
                  "snippet": {
                    "text": "\n                self._credential = CloudShellCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif (\n            all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS)\n            and not exclude_workload_identity\n        ):\n            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n",
                    "rendered": {
                      "text": "\n                self._credential = CloudShellCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif (\n            all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS)\n            and not exclude_workload_identity\n        ):\n            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n",
                      "markdown": "`\n                self._credential = CloudShellCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif (\n            all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS)\n            and not exclude_workload_identity\n        ):\n            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 87,
                  "startColumn": 18,
                  "endLine": 87,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n\n",
                    "rendered": {
                      "text": "\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n\n",
                      "markdown": "`\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 16,
                  "endLine": 86,
                  "endColumn": 27,
                  "snippet": {
                    "text": "                from .azure_arc import AzureArcCredential\n\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n",
                    "rendered": {
                      "text": "                from .azure_arc import AzureArcCredential\n\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n",
                      "markdown": "`                from .azure_arc import AzureArcCredential\n\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 81,
                  "startColumn": 20,
                  "endLine": 81,
                  "endColumn": 31,
                  "snippet": {
                    "text": "                    self._credential = AppServiceCredential(\n                        client_id=client_id, identity_config=identity_config, **kwargs\n                    )\n            elif os.environ.get(EnvironmentVariables.IMDS_ENDPOINT):\n                _LOGGER.info(\"%s will use Azure Arc managed identity\", self.__class__.__name__)\n                from .azure_arc import AzureArcCredential\n\n",
                    "rendered": {
                      "text": "                    self._credential = AppServiceCredential(\n                        client_id=client_id, identity_config=identity_config, **kwargs\n                    )\n            elif os.environ.get(EnvironmentVariables.IMDS_ENDPOINT):\n                _LOGGER.info(\"%s will use Azure Arc managed identity\", self.__class__.__name__)\n                from .azure_arc import AzureArcCredential\n\n",
                      "markdown": "`                    self._credential = AppServiceCredential(\n                        client_id=client_id, identity_config=identity_config, **kwargs\n                    )\n            elif os.environ.get(EnvironmentVariables.IMDS_ENDPOINT):\n                _LOGGER.info(\"%s will use Azure Arc managed identity\", self.__class__.__name__)\n                from .azure_arc import AzureArcCredential\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 22,
                  "endLine": 67,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n\n",
                    "rendered": {
                      "text": "        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n\n",
                      "markdown": "`        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 18,
                  "endLine": 66,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        self._credential: Optional[SupportsTokenInfo] = None\n        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n",
                    "rendered": {
                      "text": "        self._credential: Optional[SupportsTokenInfo] = None\n        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n",
                      "markdown": "`        self._credential: Optional[SupportsTokenInfo] = None\n        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 14,
                  "endLine": 65,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        validate_identity_config(client_id, identity_config)\n        self._credential: Optional[SupportsTokenInfo] = None\n        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n",
                    "rendered": {
                      "text": "        validate_identity_config(client_id, identity_config)\n        self._credential: Optional[SupportsTokenInfo] = None\n        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n",
                      "markdown": "`        validate_identity_config(client_id, identity_config)\n        self._credential: Optional[SupportsTokenInfo] = None\n        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 49,
                  "endLine": 75,
                  "endColumn": 58,
                  "snippet": {
                    "text": "                        client_id=client_id, identity_config=identity_config, **kwargs\n                    )\n                else:\n                    _LOGGER.info(\"%s will use App Service managed identity\", self.__class__.__name__)\n                    from .app_service import AppServiceCredential\n\n                    self._credential = AppServiceCredential(\n",
                    "rendered": {
                      "text": "                        client_id=client_id, identity_config=identity_config, **kwargs\n                    )\n                else:\n                    _LOGGER.info(\"%s will use App Service managed identity\", self.__class__.__name__)\n                    from .app_service import AppServiceCredential\n\n                    self._credential = AppServiceCredential(\n",
                      "markdown": "`                        client_id=client_id, identity_config=identity_config, **kwargs\n                    )\n                else:\n                    _LOGGER.info(\"%s will use App Service managed identity\", self.__class__.__name__)\n                    from .app_service import AppServiceCredential\n\n                    self._credential = AppServiceCredential(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 68,
                  "startColumn": 45,
                  "endLine": 68,
                  "endColumn": 54,
                  "snippet": {
                    "text": "        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n\n                    self._credential = ServiceFabricCredential(\n",
                    "rendered": {
                      "text": "        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n\n                    self._credential = ServiceFabricCredential(\n",
                      "markdown": "`        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n\n                    self._credential = ServiceFabricCredential(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/client_secret.py"
                },
                "region": {
                  "startLine": 14,
                  "startColumn": 40,
                  "endLine": 14,
                  "endColumn": 49,
                  "snippet": {
                    "text": "\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID\n    :param str client_secret: One of the service principal's client secrets\n\n    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n",
                    "rendered": {
                      "text": "\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID\n    :param str client_secret: One of the service principal's client secrets\n\n    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n",
                      "markdown": "`\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID\n    :param str client_secret: One of the service principal's client secrets\n\n    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/client_secret.py"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 29,
                  "endLine": 13,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    \"\"\"Authenticates as a service principal using a client secret.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID\n    :param str client_secret: One of the service principal's client secrets\n\n    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n",
                    "rendered": {
                      "text": "    \"\"\"Authenticates as a service principal using a client secret.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID\n    :param str client_secret: One of the service principal's client secrets\n\n    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n",
                      "markdown": "`    \"\"\"Authenticates as a service principal using a client secret.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID\n    :param str client_secret: One of the service principal's client secrets\n\n    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/client_secret.py"
                },
                "region": {
                  "startLine": 12,
                  "startColumn": 35,
                  "endLine": 12,
                  "endColumn": 44,
                  "snippet": {
                    "text": "class ClientSecretCredential(ClientCredentialBase):\n    \"\"\"Authenticates as a service principal using a client secret.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID\n    :param str client_secret: One of the service principal's client secrets\n\n",
                    "rendered": {
                      "text": "class ClientSecretCredential(ClientCredentialBase):\n    \"\"\"Authenticates as a service principal using a client secret.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID\n    :param str client_secret: One of the service principal's client secrets\n\n",
                      "markdown": "`class ClientSecretCredential(ClientCredentialBase):\n    \"\"\"Authenticates as a service principal using a client secret.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID\n    :param str client_secret: One of the service principal's client secrets\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/client_secret.py"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 25,
                  "endLine": 10,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\n\nclass ClientSecretCredential(ClientCredentialBase):\n    \"\"\"Authenticates as a service principal using a client secret.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID\n",
                    "rendered": {
                      "text": "\n\nclass ClientSecretCredential(ClientCredentialBase):\n    \"\"\"Authenticates as a service principal using a client secret.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID\n",
                      "markdown": "`\n\nclass ClientSecretCredential(ClientCredentialBase):\n    \"\"\"Authenticates as a service principal using a client secret.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/decorators.py"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 56,
                  "endLine": 43,
                  "endColumn": 61,
                  "snippet": {
                    "text": "            return token\n        except Exception as ex:  # pylint: disable=broad-except\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s failed: %s\",\n                fn.__qualname__,\n                ex,\n",
                    "rendered": {
                      "text": "            return token\n        except Exception as ex:  # pylint: disable=broad-except\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s failed: %s\",\n                fn.__qualname__,\n                ex,\n",
                      "markdown": "`            return token\n        except Exception as ex:  # pylint: disable=broad-except\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s failed: %s\",\n                fn.__qualname__,\n                ex,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/decorators.py"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 35,
                  "endLine": 32,
                  "endColumn": 40,
                  "snippet": {
                    "text": "                    json_bytes = base64.decodebytes(base64_meta_data)\n                    json_string = json_bytes.decode(\"utf-8\")\n                    json_dict = json.loads(json_string)\n                    upn = json_dict.get(\"upn\", \"unavailableUpn\")\n                    log_string = (\n                        \"[Authenticated account] Client ID: {}. Tenant ID: {}. User Principal Name: {}. \"\n                        \"Object ID (user): {}\".format(json_dict[\"appid\"], json_dict[\"tid\"], upn, json_dict[\"oid\"])\n",
                    "rendered": {
                      "text": "                    json_bytes = base64.decodebytes(base64_meta_data)\n                    json_string = json_bytes.decode(\"utf-8\")\n                    json_dict = json.loads(json_string)\n                    upn = json_dict.get(\"upn\", \"unavailableUpn\")\n                    log_string = (\n                        \"[Authenticated account] Client ID: {}. Tenant ID: {}. User Principal Name: {}. \"\n                        \"Object ID (user): {}\".format(json_dict[\"appid\"], json_dict[\"tid\"], upn, json_dict[\"oid\"])\n",
                      "markdown": "`                    json_bytes = base64.decodebytes(base64_meta_data)\n                    json_string = json_bytes.decode(\"utf-8\")\n                    json_dict = json.loads(json_string)\n                    upn = json_dict.get(\"upn\", \"unavailableUpn\")\n                    log_string = (\n                        \"[Authenticated account] Client ID: {}. Tenant ID: {}. User Principal Name: {}. \"\n                        \"Object ID (user): {}\".format(json_dict[\"appid\"], json_dict[\"tid\"], upn, json_dict[\"oid\"])\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/decorators.py"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 56,
                  "endLine": 24,
                  "endColumn": 61,
                  "snippet": {
                    "text": "        try:\n            token = await fn(*args, **kwargs)\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.INFO, \"%s succeeded\", fn.__qualname__\n            )\n            if _LOGGER.isEnabledFor(logging.DEBUG):\n                try:\n",
                    "rendered": {
                      "text": "        try:\n            token = await fn(*args, **kwargs)\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.INFO, \"%s succeeded\", fn.__qualname__\n            )\n            if _LOGGER.isEnabledFor(logging.DEBUG):\n                try:\n",
                      "markdown": "`        try:\n            token = await fn(*args, **kwargs)\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.INFO, \"%s succeeded\", fn.__qualname__\n            )\n            if _LOGGER.isEnabledFor(logging.DEBUG):\n                try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/decorators.py"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 33,
                  "endLine": 29,
                  "endColumn": 39,
                  "snippet": {
                    "text": "            if _LOGGER.isEnabledFor(logging.DEBUG):\n                try:\n                    base64_meta_data = token.token.split(\".\")[1].encode(\"utf-8\") + b\"==\"\n                    json_bytes = base64.decodebytes(base64_meta_data)\n                    json_string = json_bytes.decode(\"utf-8\")\n                    json_dict = json.loads(json_string)\n                    upn = json_dict.get(\"upn\", \"unavailableUpn\")\n",
                    "rendered": {
                      "text": "            if _LOGGER.isEnabledFor(logging.DEBUG):\n                try:\n                    base64_meta_data = token.token.split(\".\")[1].encode(\"utf-8\") + b\"==\"\n                    json_bytes = base64.decodebytes(base64_meta_data)\n                    json_string = json_bytes.decode(\"utf-8\")\n                    json_dict = json.loads(json_string)\n                    upn = json_dict.get(\"upn\", \"unavailableUpn\")\n",
                      "markdown": "`            if _LOGGER.isEnabledFor(logging.DEBUG):\n                try:\n                    base64_meta_data = token.token.split(\".\")[1].encode(\"utf-8\") + b\"==\"\n                    json_bytes = base64.decodebytes(base64_meta_data)\n                    json_string = json_bytes.decode(\"utf-8\")\n                    json_dict = json.loads(json_string)\n                    upn = json_dict.get(\"upn\", \"unavailableUpn\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/decorators.py"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 7,
                  "endLine": 8,
                  "endColumn": 13,
                  "snippet": {
                    "text": "import functools\nimport logging\nimport json\nimport base64\n\nfrom azure.core.exceptions import ClientAuthenticationError\n\n",
                    "rendered": {
                      "text": "import functools\nimport logging\nimport json\nimport base64\n\nfrom azure.core.exceptions import ClientAuthenticationError\n\n",
                      "markdown": "`import functools\nimport logging\nimport json\nimport base64\n\nfrom azure.core.exceptions import ClientAuthenticationError\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/decorators.py"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 6,
                  "endLine": 9,
                  "snippet": {
                    "text": "import functools\nimport logging\nimport json\nimport base64\n\nfrom azure.core.exceptions import ClientAuthenticationError\n\nfrom ..._internal import within_credential_chain\n",
                    "rendered": {
                      "text": "import functools\nimport logging\nimport json\nimport base64\n\nfrom azure.core.exceptions import ClientAuthenticationError\n\nfrom ..._internal import within_credential_chain\n",
                      "markdown": "`import functools\nimport logging\nimport json\nimport base64\n\nfrom azure.core.exceptions import ClientAuthenticationError\n\nfrom ..._internal import within_credential_chain\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/aad_client.py"
                },
                "region": {
                  "startLine": 90,
                  "startColumn": 48,
                  "endLine": 90,
                  "endColumn": 52,
                  "snippet": {
                    "text": "\n    async def _run_pipeline(self, request: HttpRequest, **kwargs) -> AccessTokenInfo:\n        # remove tenant_id and claims kwarg that could have been passed from credential's get_token method\n        # tenant_id is already part of `request` at this point\n        kwargs.pop(\"tenant_id\", None)\n        kwargs.pop(\"claims\", None)\n        kwargs.pop(\"client_secret\", None)\n",
                    "rendered": {
                      "text": "\n    async def _run_pipeline(self, request: HttpRequest, **kwargs) -> AccessTokenInfo:\n        # remove tenant_id and claims kwarg that could have been passed from credential's get_token method\n        # tenant_id is already part of `request` at this point\n        kwargs.pop(\"tenant_id\", None)\n        kwargs.pop(\"claims\", None)\n        kwargs.pop(\"client_secret\", None)\n",
                      "markdown": "`\n    async def _run_pipeline(self, request: HttpRequest, **kwargs) -> AccessTokenInfo:\n        # remove tenant_id and claims kwarg that could have been passed from credential's get_token method\n        # tenant_id is already part of `request` at this point\n        kwargs.pop(\"tenant_id\", None)\n        kwargs.pop(\"claims\", None)\n        kwargs.pop(\"client_secret\", None)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_internal/aad_client.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 6,
                  "endLine": 6,
                  "snippet": {
                    "text": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport time\nfrom typing import Iterable, Optional, Union, Dict, Any\n\nfrom azure.core.credentials import AccessTokenInfo\nfrom azure.core.pipeline import AsyncPipeline\n",
                    "rendered": {
                      "text": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport time\nfrom typing import Iterable, Optional, Union, Dict, Any\n\nfrom azure.core.credentials import AccessTokenInfo\nfrom azure.core.pipeline import AsyncPipeline\n",
                      "markdown": "`# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport time\nfrom typing import Iterable, Optional, Union, Dict, Any\n\nfrom azure.core.credentials import AccessTokenInfo\nfrom azure.core.pipeline import AsyncPipeline\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_client.py"
                },
                "region": {
                  "startLine": 132,
                  "startColumn": 38,
                  "endLine": 132,
                  "endColumn": 43,
                  "snippet": {
                    "text": "        if response.http_response.status_code >= 400:\n            # if the body doesn't contain \"error\", this isn't an OAuth 2 error, i.e. this isn't a\n            # response to an auth request, so no credential will want to include it with an exception\n            content = response.context.get(ContentDecodePolicy.CONTEXT_NAME)\n            if content and \"error\" in content:\n                self._local.error = (content[\"error\"], response.http_response)\n\n",
                    "rendered": {
                      "text": "        if response.http_response.status_code >= 400:\n            # if the body doesn't contain \"error\", this isn't an OAuth 2 error, i.e. this isn't a\n            # response to an auth request, so no credential will want to include it with an exception\n            content = response.context.get(ContentDecodePolicy.CONTEXT_NAME)\n            if content and \"error\" in content:\n                self._local.error = (content[\"error\"], response.http_response)\n\n",
                      "markdown": "`        if response.http_response.status_code >= 400:\n            # if the body doesn't contain \"error\", this isn't an OAuth 2 error, i.e. this isn't a\n            # response to an auth request, so no credential will want to include it with an exception\n            content = response.context.get(ContentDecodePolicy.CONTEXT_NAME)\n            if content and \"error\" in content:\n                self._local.error = (content[\"error\"], response.http_response)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_client.py"
                },
                "region": {
                  "startLine": 124,
                  "startColumn": 49,
                  "endLine": 124,
                  "endColumn": 54,
                  "snippet": {
                    "text": "        :rtype: ~azure.core.pipeline.transport.HttpResponse or None\n        \"\"\"\n        error_code, response = getattr(self._local, \"error\", (None, None))\n        if response and error_code == msal_result.get(\"error\"):\n            return response\n        return None\n\n",
                    "rendered": {
                      "text": "        :rtype: ~azure.core.pipeline.transport.HttpResponse or None\n        \"\"\"\n        error_code, response = getattr(self._local, \"error\", (None, None))\n        if response and error_code == msal_result.get(\"error\"):\n            return response\n        return None\n\n",
                      "markdown": "`        :rtype: ~azure.core.pipeline.transport.HttpResponse or None\n        \"\"\"\n        error_code, response = getattr(self._local, \"error\", (None, None))\n        if response and error_code == msal_result.get(\"error\"):\n            return response\n        return None\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_client.py"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 104,
                  "endLine": 49,
                  "endColumn": 109,
                  "snippet": {
                    "text": "            if not content:\n                message = \"Unexpected response from Microsoft Entra ID\"\n            elif \"error\" in content or \"error_description\" in content:\n                message = \"Authentication failed: {}\".format(content.get(\"error_description\") or content.get(\"error\"))\n            else:\n                for secret in (\"access_token\", \"refresh_token\"):\n                    if secret in content:\n",
                    "rendered": {
                      "text": "            if not content:\n                message = \"Unexpected response from Microsoft Entra ID\"\n            elif \"error\" in content or \"error_description\" in content:\n                message = \"Authentication failed: {}\".format(content.get(\"error_description\") or content.get(\"error\"))\n            else:\n                for secret in (\"access_token\", \"refresh_token\"):\n                    if secret in content:\n",
                      "markdown": "`            if not content:\n                message = \"Unexpected response from Microsoft Entra ID\"\n            elif \"error\" in content or \"error_description\" in content:\n                message = \"Authentication failed: {}\".format(content.get(\"error_description\") or content.get(\"error\"))\n            else:\n                for secret in (\"access_token\", \"refresh_token\"):\n                    if secret in content:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_client.py"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 68,
                  "endLine": 49,
                  "endColumn": 73,
                  "snippet": {
                    "text": "            if not content:\n                message = \"Unexpected response from Microsoft Entra ID\"\n            elif \"error\" in content or \"error_description\" in content:\n                message = \"Authentication failed: {}\".format(content.get(\"error_description\") or content.get(\"error\"))\n            else:\n                for secret in (\"access_token\", \"refresh_token\"):\n                    if secret in content:\n",
                    "rendered": {
                      "text": "            if not content:\n                message = \"Unexpected response from Microsoft Entra ID\"\n            elif \"error\" in content or \"error_description\" in content:\n                message = \"Authentication failed: {}\".format(content.get(\"error_description\") or content.get(\"error\"))\n            else:\n                for secret in (\"access_token\", \"refresh_token\"):\n                    if secret in content:\n",
                      "markdown": "`            if not content:\n                message = \"Unexpected response from Microsoft Entra ID\"\n            elif \"error\" in content or \"error_description\" in content:\n                message = \"Authentication failed: {}\".format(content.get(\"error_description\") or content.get(\"error\"))\n            else:\n                for secret in (\"access_token\", \"refresh_token\"):\n                    if secret in content:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000801"
          },
          "message": {
            "text": "Backdoor: Executing Obfuscated Code",
            "id": "BD000801"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/msal_client.py"
                },
                "region": {
                  "startLine": 132,
                  "startColumn": 38,
                  "endLine": 132,
                  "endColumn": 56,
                  "snippet": {
                    "text": "        if response.http_response.status_code >= 400:\n            # if the body doesn't contain \"error\", this isn't an OAuth 2 error, i.e. this isn't a\n            # response to an auth request, so no credential will want to include it with an exception\n            content = response.context.get(ContentDecodePolicy.CONTEXT_NAME)\n            if content and \"error\" in content:\n                self._local.error = (content[\"error\"], response.http_response)\n\n",
                    "rendered": {
                      "text": "        if response.http_response.status_code >= 400:\n            # if the body doesn't contain \"error\", this isn't an OAuth 2 error, i.e. this isn't a\n            # response to an auth request, so no credential will want to include it with an exception\n            content = response.context.get(ContentDecodePolicy.CONTEXT_NAME)\n            if content and \"error\" in content:\n                self._local.error = (content[\"error\"], response.http_response)\n\n",
                      "markdown": "`        if response.http_response.status_code >= 400:\n            # if the body doesn't contain \"error\", this isn't an OAuth 2 error, i.e. this isn't a\n            # response to an auth request, so no credential will want to include it with an exception\n            content = response.context.get(ContentDecodePolicy.CONTEXT_NAME)\n            if content and \"error\" in content:\n                self._local.error = (content[\"error\"], response.http_response)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/managed_identity_client.py"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 65,
                  "endLine": 102,
                  "endColumn": 70,
                  "snippet": {
                    "text": "            refresh_on = int(token[\"refresh_on\"]) if \"refresh_on\" in token else None\n            if expires_on > now and (not refresh_on or refresh_on > now):\n                return AccessTokenInfo(\n                    token[\"secret\"], expires_on, token_type=token.get(\"token_type\", \"Bearer\"), refresh_on=refresh_on\n                )\n\n        return None\n",
                    "rendered": {
                      "text": "            refresh_on = int(token[\"refresh_on\"]) if \"refresh_on\" in token else None\n            if expires_on > now and (not refresh_on or refresh_on > now):\n                return AccessTokenInfo(\n                    token[\"secret\"], expires_on, token_type=token.get(\"token_type\", \"Bearer\"), refresh_on=refresh_on\n                )\n\n        return None\n",
                      "markdown": "`            refresh_on = int(token[\"refresh_on\"]) if \"refresh_on\" in token else None\n            if expires_on > now and (not refresh_on or refresh_on > now):\n                return AccessTokenInfo(\n                    token[\"secret\"], expires_on, token_type=token.get(\"token_type\", \"Bearer\"), refresh_on=refresh_on\n                )\n\n        return None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/managed_identity_client.py"
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 30,
                  "endLine": 82,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        token = AccessTokenInfo(\n            content[\"access_token\"],\n            content[\"expires_on\"],\n            token_type=content.get(\"token_type\", \"Bearer\"),\n            refresh_on=refresh_on,\n        )\n\n",
                    "rendered": {
                      "text": "        token = AccessTokenInfo(\n            content[\"access_token\"],\n            content[\"expires_on\"],\n            token_type=content.get(\"token_type\", \"Bearer\"),\n            refresh_on=refresh_on,\n        )\n\n",
                      "markdown": "`        token = AccessTokenInfo(\n            content[\"access_token\"],\n            content[\"expires_on\"],\n            token_type=content.get(\"token_type\", \"Bearer\"),\n            refresh_on=refresh_on,\n        )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/managed_identity_client.py"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 32,
                  "endLine": 73,
                  "endColumn": 37,
                  "snippet": {
                    "text": "        expires_on = int(content.get(\"expires_on\") or int(content[\"expires_in\"]) + request_time)\n        content[\"expires_on\"] = expires_on\n\n        expires_in = int(content.get(\"expires_in\") or expires_on - request_time)\n        if \"refresh_in\" not in content and expires_in >= 7200:\n            # MSAL TokenCache expects \"refresh_in\"\n            content[\"refresh_in\"] = expires_in // 2\n",
                    "rendered": {
                      "text": "        expires_on = int(content.get(\"expires_on\") or int(content[\"expires_in\"]) + request_time)\n        content[\"expires_on\"] = expires_on\n\n        expires_in = int(content.get(\"expires_in\") or expires_on - request_time)\n        if \"refresh_in\" not in content and expires_in >= 7200:\n            # MSAL TokenCache expects \"refresh_in\"\n            content[\"refresh_in\"] = expires_in // 2\n",
                      "markdown": "`        expires_on = int(content.get(\"expires_on\") or int(content[\"expires_in\"]) + request_time)\n        content[\"expires_on\"] = expires_on\n\n        expires_in = int(content.get(\"expires_in\") or expires_on - request_time)\n        if \"refresh_in\" not in content and expires_in >= 7200:\n            # MSAL TokenCache expects \"refresh_in\"\n            content[\"refresh_in\"] = expires_in // 2\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/managed_identity_client.py"
                },
                "region": {
                  "startLine": 70,
                  "startColumn": 32,
                  "endLine": 70,
                  "endColumn": 37,
                  "snippet": {
                    "text": "        if self._content_callback:\n            self._content_callback(content)\n\n        expires_on = int(content.get(\"expires_on\") or int(content[\"expires_in\"]) + request_time)\n        content[\"expires_on\"] = expires_on\n\n        expires_in = int(content.get(\"expires_in\") or expires_on - request_time)\n",
                    "rendered": {
                      "text": "        if self._content_callback:\n            self._content_callback(content)\n\n        expires_on = int(content.get(\"expires_on\") or int(content[\"expires_in\"]) + request_time)\n        content[\"expires_on\"] = expires_on\n\n        expires_in = int(content.get(\"expires_in\") or expires_on - request_time)\n",
                      "markdown": "`        if self._content_callback:\n            self._content_callback(content)\n\n        expires_on = int(content.get(\"expires_on\") or int(content[\"expires_in\"]) + request_time)\n        content[\"expires_on\"] = expires_on\n\n        expires_in = int(content.get(\"expires_in\") or expires_on - request_time)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/managed_identity_client.py"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 34,
                  "endLine": 44,
                  "endColumn": 39,
                  "snippet": {
                    "text": "        self._request_factory = request_factory\n\n    def _process_response(self, response: PipelineResponse, request_time: int) -> AccessTokenInfo:\n        content = response.context.get(ContentDecodePolicy.CONTEXT_NAME)\n        if not content:\n            try:\n                content = ContentDecodePolicy.deserialize_from_text(\n",
                    "rendered": {
                      "text": "        self._request_factory = request_factory\n\n    def _process_response(self, response: PipelineResponse, request_time: int) -> AccessTokenInfo:\n        content = response.context.get(ContentDecodePolicy.CONTEXT_NAME)\n        if not content:\n            try:\n                content = ContentDecodePolicy.deserialize_from_text(\n",
                      "markdown": "`        self._request_factory = request_factory\n\n    def _process_response(self, response: PipelineResponse, request_time: int) -> AccessTokenInfo:\n        content = response.context.get(ContentDecodePolicy.CONTEXT_NAME)\n        if not content:\n            try:\n                content = ContentDecodePolicy.deserialize_from_text(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000801"
          },
          "message": {
            "text": "Backdoor: Executing Obfuscated Code",
            "id": "BD000801"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/managed_identity_client.py"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 34,
                  "endLine": 44,
                  "endColumn": 52,
                  "snippet": {
                    "text": "        self._request_factory = request_factory\n\n    def _process_response(self, response: PipelineResponse, request_time: int) -> AccessTokenInfo:\n        content = response.context.get(ContentDecodePolicy.CONTEXT_NAME)\n        if not content:\n            try:\n                content = ContentDecodePolicy.deserialize_from_text(\n",
                    "rendered": {
                      "text": "        self._request_factory = request_factory\n\n    def _process_response(self, response: PipelineResponse, request_time: int) -> AccessTokenInfo:\n        content = response.context.get(ContentDecodePolicy.CONTEXT_NAME)\n        if not content:\n            try:\n                content = ContentDecodePolicy.deserialize_from_text(\n",
                      "markdown": "`        self._request_factory = request_factory\n\n    def _process_response(self, response: PipelineResponse, request_time: int) -> AccessTokenInfo:\n        content = response.context.get(ContentDecodePolicy.CONTEXT_NAME)\n        if not content:\n            try:\n                content = ContentDecodePolicy.deserialize_from_text(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/managed_identity_client.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 6,
                  "endLine": 7,
                  "snippet": {
                    "text": "# Licensed under the MIT License.\n# ------------------------------------\nimport abc\nimport time\nfrom typing import Any, Callable, Dict, Optional\n\nfrom msal import TokenCache\n\n",
                    "rendered": {
                      "text": "# Licensed under the MIT License.\n# ------------------------------------\nimport abc\nimport time\nfrom typing import Any, Callable, Dict, Optional\n\nfrom msal import TokenCache\n\n",
                      "markdown": "`# Licensed under the MIT License.\n# ------------------------------------\nimport abc\nimport time\nfrom typing import Any, Callable, Dict, Optional\n\nfrom msal import TokenCache\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/macos_vscode_adapter.py"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 37,
                  "endLine": 27,
                  "endColumn": 45,
                  "snippet": {
                    "text": "def get_refresh_token(cloud_name):\n    try:\n        key_chain = Keychain()\n        return key_chain.get_generic_password(VSCODE_CREDENTIALS_SECTION, cloud_name)\n    except KeychainError:\n        return None\n    except Exception as ex:  # pylint:disable=broad-except\n",
                    "rendered": {
                      "text": "def get_refresh_token(cloud_name):\n    try:\n        key_chain = Keychain()\n        return key_chain.get_generic_password(VSCODE_CREDENTIALS_SECTION, cloud_name)\n    except KeychainError:\n        return None\n    except Exception as ex:  # pylint:disable=broad-except\n",
                      "markdown": "`def get_refresh_token(cloud_name):\n    try:\n        key_chain = Keychain()\n        return key_chain.get_generic_password(VSCODE_CREDENTIALS_SECTION, cloud_name)\n    except KeychainError:\n        return None\n    except Exception as ex:  # pylint:disable=broad-except\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/imds.py"
                },
                "region": {
                  "startLine": 81,
                  "startColumn": 34,
                  "endLine": 81,
                  "endColumn": 39,
                  "snippet": {
                    "text": "\n    def _request_token(self, *scopes: str, **kwargs: Any) -> AccessTokenInfo:\n\n        if within_credential_chain.get() and not self._endpoint_available:\n            # If within a chain (e.g. DefaultAzureCredential), we do a quick check to see if the IMDS endpoint\n            # is available to avoid hanging for a long time if the endpoint isn't available.\n            try:\n",
                    "rendered": {
                      "text": "\n    def _request_token(self, *scopes: str, **kwargs: Any) -> AccessTokenInfo:\n\n        if within_credential_chain.get() and not self._endpoint_available:\n            # If within a chain (e.g. DefaultAzureCredential), we do a quick check to see if the IMDS endpoint\n            # is available to avoid hanging for a long time if the endpoint isn't available.\n            try:\n",
                      "markdown": "`\n    def _request_token(self, *scopes: str, **kwargs: Any) -> AccessTokenInfo:\n\n        if within_credential_chain.get() and not self._endpoint_available:\n            # If within a chain (e.g. DefaultAzureCredential), we do a quick check to see if the IMDS endpoint\n            # is available to avoid hanging for a long time if the endpoint isn't available.\n            try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/imds.py"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 18,
                  "endLine": 36,
                  "endColumn": 23,
                  "snippet": {
                    "text": "\ndef _get_request(scope: str, identity_config: Dict) -> HttpRequest:\n    url = (\n        os.environ.get(EnvironmentVariables.AZURE_POD_IDENTITY_AUTHORITY_HOST, IMDS_AUTHORITY).strip(\"/\")\n        + IMDS_TOKEN_PATH\n    )\n    request = HttpRequest(\"GET\", url)\n",
                    "rendered": {
                      "text": "\ndef _get_request(scope: str, identity_config: Dict) -> HttpRequest:\n    url = (\n        os.environ.get(EnvironmentVariables.AZURE_POD_IDENTITY_AUTHORITY_HOST, IMDS_AUTHORITY).strip(\"/\")\n        + IMDS_TOKEN_PATH\n    )\n    request = HttpRequest(\"GET\", url)\n",
                      "markdown": "`\ndef _get_request(scope: str, identity_config: Dict) -> HttpRequest:\n    url = (\n        os.environ.get(EnvironmentVariables.AZURE_POD_IDENTITY_AUTHORITY_HOST, IMDS_AUTHORITY).strip(\"/\")\n        + IMDS_TOKEN_PATH\n    )\n    request = HttpRequest(\"GET\", url)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/imds.py"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 11,
                  "endLine": 36,
                  "endColumn": 22,
                  "snippet": {
                    "text": "\ndef _get_request(scope: str, identity_config: Dict) -> HttpRequest:\n    url = (\n        os.environ.get(EnvironmentVariables.AZURE_POD_IDENTITY_AUTHORITY_HOST, IMDS_AUTHORITY).strip(\"/\")\n        + IMDS_TOKEN_PATH\n    )\n    request = HttpRequest(\"GET\", url)\n",
                    "rendered": {
                      "text": "\ndef _get_request(scope: str, identity_config: Dict) -> HttpRequest:\n    url = (\n        os.environ.get(EnvironmentVariables.AZURE_POD_IDENTITY_AUTHORITY_HOST, IMDS_AUTHORITY).strip(\"/\")\n        + IMDS_TOKEN_PATH\n    )\n    request = HttpRequest(\"GET\", url)\n",
                      "markdown": "`\ndef _get_request(scope: str, identity_config: Dict) -> HttpRequest:\n    url = (\n        os.environ.get(EnvironmentVariables.AZURE_POD_IDENTITY_AUTHORITY_HOST, IMDS_AUTHORITY).strip(\"/\")\n        + IMDS_TOKEN_PATH\n    )\n    request = HttpRequest(\"GET\", url)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/imds.py"
                },
                "region": {
                  "startLine": 83,
                  "startColumn": 54,
                  "endLine": 83,
                  "endColumn": 60,
                  "snippet": {
                    "text": "\n        if within_credential_chain.get() and not self._endpoint_available:\n            # If within a chain (e.g. DefaultAzureCredential), we do a quick check to see if the IMDS endpoint\n            # is available to avoid hanging for a long time if the endpoint isn't available.\n            try:\n                client = ManagedIdentityClient(_get_request, **dict(PIPELINE_SETTINGS, **self._config))\n                client.request_token(*scopes, connection_timeout=1, retry_total=0)\n",
                    "rendered": {
                      "text": "\n        if within_credential_chain.get() and not self._endpoint_available:\n            # If within a chain (e.g. DefaultAzureCredential), we do a quick check to see if the IMDS endpoint\n            # is available to avoid hanging for a long time if the endpoint isn't available.\n            try:\n                client = ManagedIdentityClient(_get_request, **dict(PIPELINE_SETTINGS, **self._config))\n                client.request_token(*scopes, connection_timeout=1, retry_total=0)\n",
                      "markdown": "`\n        if within_credential_chain.get() and not self._endpoint_available:\n            # If within a chain (e.g. DefaultAzureCredential), we do a quick check to see if the IMDS endpoint\n            # is available to avoid hanging for a long time if the endpoint isn't available.\n            try:\n                client = ManagedIdentityClient(_get_request, **dict(PIPELINE_SETTINGS, **self._config))\n                client.request_token(*scopes, connection_timeout=1, retry_total=0)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/imds.py"
                },
                "region": {
                  "startLine": 47,
                  "startColumn": 3,
                  "endLine": 47,
                  "endColumn": 11,
                  "snippet": {
                    "text": "def _check_forbidden_response(ex: HttpResponseError) -> None:\n    \"\"\"Special case handling for Docker Desktop.\n\n    Docker Desktop proxies all HTTP traffic, and if the IMDS endpoint is unreachable, it\n    responds with a 403 with a message that contains \"unreachable\".\n\n    :param ~azure.core.exceptions.HttpResponseError ex: The exception raised by the request\n",
                    "rendered": {
                      "text": "def _check_forbidden_response(ex: HttpResponseError) -> None:\n    \"\"\"Special case handling for Docker Desktop.\n\n    Docker Desktop proxies all HTTP traffic, and if the IMDS endpoint is unreachable, it\n    responds with a 403 with a message that contains \"unreachable\".\n\n    :param ~azure.core.exceptions.HttpResponseError ex: The exception raised by the request\n",
                      "markdown": "`def _check_forbidden_response(ex: HttpResponseError) -> None:\n    \"\"\"Special case handling for Docker Desktop.\n\n    Docker Desktop proxies all HTTP traffic, and if the IMDS endpoint is unreachable, it\n    responds with a 403 with a message that contains \"unreachable\".\n\n    :param ~azure.core.exceptions.HttpResponseError ex: The exception raised by the request\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/imds.py"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 32,
                  "endLine": 45,
                  "endColumn": 40,
                  "snippet": {
                    "text": "\n\ndef _check_forbidden_response(ex: HttpResponseError) -> None:\n    \"\"\"Special case handling for Docker Desktop.\n\n    Docker Desktop proxies all HTTP traffic, and if the IMDS endpoint is unreachable, it\n    responds with a 403 with a message that contains \"unreachable\".\n",
                    "rendered": {
                      "text": "\n\ndef _check_forbidden_response(ex: HttpResponseError) -> None:\n    \"\"\"Special case handling for Docker Desktop.\n\n    Docker Desktop proxies all HTTP traffic, and if the IMDS endpoint is unreachable, it\n    responds with a 403 with a message that contains \"unreachable\".\n",
                      "markdown": "`\n\ndef _check_forbidden_response(ex: HttpResponseError) -> None:\n    \"\"\"Special case handling for Docker Desktop.\n\n    Docker Desktop proxies all HTTP traffic, and if the IMDS endpoint is unreachable, it\n    responds with a 403 with a message that contains \"unreachable\".\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 110,
                  "startColumn": 42,
                  "endLine": 110,
                  "endColumn": 47,
                  "snippet": {
                    "text": "            set_variables = [v for v in expected_variables if v in os.environ]\n            if set_variables:\n                _LOGGER.log(\n                    logging.INFO if kwargs.get(\"_within_dac\") else logging.WARNING,\n                    \"Incomplete environment configuration for EnvironmentCredential. These variables are set: %s\",\n                    \", \".join(set_variables),\n                )\n",
                    "rendered": {
                      "text": "            set_variables = [v for v in expected_variables if v in os.environ]\n            if set_variables:\n                _LOGGER.log(\n                    logging.INFO if kwargs.get(\"_within_dac\") else logging.WARNING,\n                    \"Incomplete environment configuration for EnvironmentCredential. These variables are set: %s\",\n                    \", \".join(set_variables),\n                )\n",
                      "markdown": "`            set_variables = [v for v in expected_variables if v in os.environ]\n            if set_variables:\n                _LOGGER.log(\n                    logging.INFO if kwargs.get(\"_within_dac\") else logging.WARNING,\n                    \"Incomplete environment configuration for EnvironmentCredential. These variables are set: %s\",\n                    \", \".join(set_variables),\n                )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 36,
                  "endLine": 95,
                  "endColumn": 41,
                  "snippet": {
                    "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n                password=os.environ[EnvironmentVariables.AZURE_PASSWORD],\n                tenant_id=os.environ.get(EnvironmentVariables.AZURE_TENANT_ID),  # optional for username/password auth\n                **kwargs\n            )\n\n",
                    "rendered": {
                      "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n                password=os.environ[EnvironmentVariables.AZURE_PASSWORD],\n                tenant_id=os.environ.get(EnvironmentVariables.AZURE_TENANT_ID),  # optional for username/password auth\n                **kwargs\n            )\n\n",
                      "markdown": "`                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n                password=os.environ[EnvironmentVariables.AZURE_PASSWORD],\n                tenant_id=os.environ.get(EnvironmentVariables.AZURE_TENANT_ID),  # optional for username/password auth\n                **kwargs\n            )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 90,
                  "startColumn": 27,
                  "endLine": 90,
                  "endColumn": 32,
                  "snippet": {
                    "text": "                ),\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.USERNAME_PASSWORD_VARS):\n            self._credential = UsernamePasswordCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n",
                    "rendered": {
                      "text": "                ),\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.USERNAME_PASSWORD_VARS):\n            self._credential = UsernamePasswordCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n",
                      "markdown": "`                ),\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.USERNAME_PASSWORD_VARS):\n            self._credential = UsernamePasswordCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 30,
                  "endLine": 86,
                  "endColumn": 35,
                  "snippet": {
                    "text": "                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n                **kwargs\n            )\n",
                    "rendered": {
                      "text": "                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n                **kwargs\n            )\n",
                      "markdown": "`                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n                **kwargs\n            )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 35,
                  "endLine": 84,
                  "endColumn": 40,
                  "snippet": {
                    "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n",
                    "rendered": {
                      "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n",
                      "markdown": "`                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 27,
                  "endLine": 79,
                  "endColumn": 32,
                  "snippet": {
                    "text": "                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.CERT_VARS):\n            self._credential = CertificateCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n",
                    "rendered": {
                      "text": "                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.CERT_VARS):\n            self._credential = CertificateCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n",
                      "markdown": "`                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.CERT_VARS):\n            self._credential = CertificateCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 25,
                  "endLine": 72,
                  "endColumn": 30,
                  "snippet": {
                    "text": "    def __init__(self, **kwargs: Any) -> None:\n        self._credential: Optional[EnvironmentCredentialTypes] = None\n\n        if all(os.environ.get(v) is not None for v in EnvironmentVariables.CLIENT_SECRET_VARS):\n            self._credential = ClientSecretCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                client_secret=os.environ[EnvironmentVariables.AZURE_CLIENT_SECRET],\n",
                    "rendered": {
                      "text": "    def __init__(self, **kwargs: Any) -> None:\n        self._credential: Optional[EnvironmentCredentialTypes] = None\n\n        if all(os.environ.get(v) is not None for v in EnvironmentVariables.CLIENT_SECRET_VARS):\n            self._credential = ClientSecretCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                client_secret=os.environ[EnvironmentVariables.AZURE_CLIENT_SECRET],\n",
                      "markdown": "`    def __init__(self, **kwargs: Any) -> None:\n        self._credential: Optional[EnvironmentCredentialTypes] = None\n\n        if all(os.environ.get(v) is not None for v in EnvironmentVariables.CLIENT_SECRET_VARS):\n            self._credential = ClientSecretCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                client_secret=os.environ[EnvironmentVariables.AZURE_CLIENT_SECRET],\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 48,
                  "endLine": 105,
                  "endColumn": 56,
                  "snippet": {
                    "text": "            expected_variables = set(\n                EnvironmentVariables.CERT_VARS\n                + EnvironmentVariables.CLIENT_SECRET_VARS\n                + EnvironmentVariables.USERNAME_PASSWORD_VARS\n            )\n            set_variables = [v for v in expected_variables if v in os.environ]\n            if set_variables:\n",
                    "rendered": {
                      "text": "            expected_variables = set(\n                EnvironmentVariables.CERT_VARS\n                + EnvironmentVariables.CLIENT_SECRET_VARS\n                + EnvironmentVariables.USERNAME_PASSWORD_VARS\n            )\n            set_variables = [v for v in expected_variables if v in os.environ]\n            if set_variables:\n",
                      "markdown": "`            expected_variables = set(\n                EnvironmentVariables.CERT_VARS\n                + EnvironmentVariables.CLIENT_SECRET_VARS\n                + EnvironmentVariables.USERNAME_PASSWORD_VARS\n            )\n            set_variables = [v for v in expected_variables if v in os.environ]\n            if set_variables:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 105,
                  "endLine": 95,
                  "endColumn": 113,
                  "snippet": {
                    "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n                password=os.environ[EnvironmentVariables.AZURE_PASSWORD],\n                tenant_id=os.environ.get(EnvironmentVariables.AZURE_TENANT_ID),  # optional for username/password auth\n                **kwargs\n            )\n\n",
                    "rendered": {
                      "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n                password=os.environ[EnvironmentVariables.AZURE_PASSWORD],\n                tenant_id=os.environ.get(EnvironmentVariables.AZURE_TENANT_ID),  # optional for username/password auth\n                **kwargs\n            )\n\n",
                      "markdown": "`                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n                password=os.environ[EnvironmentVariables.AZURE_PASSWORD],\n                tenant_id=os.environ.get(EnvironmentVariables.AZURE_TENANT_ID),  # optional for username/password auth\n                **kwargs\n            )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 63,
                  "endLine": 94,
                  "endColumn": 71,
                  "snippet": {
                    "text": "            self._credential = UsernamePasswordCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n                password=os.environ[EnvironmentVariables.AZURE_PASSWORD],\n                tenant_id=os.environ.get(EnvironmentVariables.AZURE_TENANT_ID),  # optional for username/password auth\n                **kwargs\n            )\n",
                    "rendered": {
                      "text": "            self._credential = UsernamePasswordCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n                password=os.environ[EnvironmentVariables.AZURE_PASSWORD],\n                tenant_id=os.environ.get(EnvironmentVariables.AZURE_TENANT_ID),  # optional for username/password auth\n                **kwargs\n            )\n",
                      "markdown": "`            self._credential = UsernamePasswordCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n                password=os.environ[EnvironmentVariables.AZURE_PASSWORD],\n                tenant_id=os.environ.get(EnvironmentVariables.AZURE_TENANT_ID),  # optional for username/password auth\n                **kwargs\n            )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 16,
                  "endLine": 94,
                  "endColumn": 24,
                  "snippet": {
                    "text": "            self._credential = UsernamePasswordCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n                password=os.environ[EnvironmentVariables.AZURE_PASSWORD],\n                tenant_id=os.environ.get(EnvironmentVariables.AZURE_TENANT_ID),  # optional for username/password auth\n                **kwargs\n            )\n",
                    "rendered": {
                      "text": "            self._credential = UsernamePasswordCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n                password=os.environ[EnvironmentVariables.AZURE_PASSWORD],\n                tenant_id=os.environ.get(EnvironmentVariables.AZURE_TENANT_ID),  # optional for username/password auth\n                **kwargs\n            )\n",
                      "markdown": "`            self._credential = UsernamePasswordCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n                password=os.environ[EnvironmentVariables.AZURE_PASSWORD],\n                tenant_id=os.environ.get(EnvironmentVariables.AZURE_TENANT_ID),  # optional for username/password auth\n                **kwargs\n            )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 91,
                  "startColumn": 39,
                  "endLine": 91,
                  "endColumn": 47,
                  "snippet": {
                    "text": "                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.USERNAME_PASSWORD_VARS):\n            self._credential = UsernamePasswordCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n                password=os.environ[EnvironmentVariables.AZURE_PASSWORD],\n",
                    "rendered": {
                      "text": "                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.USERNAME_PASSWORD_VARS):\n            self._credential = UsernamePasswordCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n                password=os.environ[EnvironmentVariables.AZURE_PASSWORD],\n",
                      "markdown": "`                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.USERNAME_PASSWORD_VARS):\n            self._credential = UsernamePasswordCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n                password=os.environ[EnvironmentVariables.AZURE_PASSWORD],\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 90,
                  "startColumn": 86,
                  "endLine": 90,
                  "endColumn": 94,
                  "snippet": {
                    "text": "                ),\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.USERNAME_PASSWORD_VARS):\n            self._credential = UsernamePasswordCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n",
                    "rendered": {
                      "text": "                ),\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.USERNAME_PASSWORD_VARS):\n            self._credential = UsernamePasswordCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n",
                      "markdown": "`                ),\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.USERNAME_PASSWORD_VARS):\n            self._credential = UsernamePasswordCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 86,
                  "endLine": 84,
                  "endColumn": 94,
                  "snippet": {
                    "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n",
                    "rendered": {
                      "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n",
                      "markdown": "`                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 16,
                  "endLine": 84,
                  "endColumn": 24,
                  "snippet": {
                    "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n",
                    "rendered": {
                      "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n",
                      "markdown": "`                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 40,
                  "endLine": 51,
                  "endColumn": 48,
                  "snippet": {
                    "text": "    User with username and password:\n      - **AZURE_CLIENT_ID**: the application's client ID\n      - **AZURE_USERNAME**: a username (usually an email address)\n      - **AZURE_PASSWORD**: that user's password\n      - **AZURE_TENANT_ID**: (optional) ID of the service principal's tenant. Also called its 'directory' ID.\n        If not provided, defaults to the 'organizations' tenant, which supports only Microsoft Entra work or\n        school accounts.\n",
                    "rendered": {
                      "text": "    User with username and password:\n      - **AZURE_CLIENT_ID**: the application's client ID\n      - **AZURE_USERNAME**: a username (usually an email address)\n      - **AZURE_PASSWORD**: that user's password\n      - **AZURE_TENANT_ID**: (optional) ID of the service principal's tenant. Also called its 'directory' ID.\n        If not provided, defaults to the 'organizations' tenant, which supports only Microsoft Entra work or\n        school accounts.\n",
                      "markdown": "`    User with username and password:\n      - **AZURE_CLIENT_ID**: the application's client ID\n      - **AZURE_USERNAME**: a username (usually an email address)\n      - **AZURE_PASSWORD**: that user's password\n      - **AZURE_TENANT_ID**: (optional) ID of the service principal's tenant. Also called its 'directory' ID.\n        If not provided, defaults to the 'organizations' tenant, which supports only Microsoft Entra work or\n        school accounts.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 16,
                  "endLine": 51,
                  "endColumn": 24,
                  "snippet": {
                    "text": "    User with username and password:\n      - **AZURE_CLIENT_ID**: the application's client ID\n      - **AZURE_USERNAME**: a username (usually an email address)\n      - **AZURE_PASSWORD**: that user's password\n      - **AZURE_TENANT_ID**: (optional) ID of the service principal's tenant. Also called its 'directory' ID.\n        If not provided, defaults to the 'organizations' tenant, which supports only Microsoft Entra work or\n        school accounts.\n",
                    "rendered": {
                      "text": "    User with username and password:\n      - **AZURE_CLIENT_ID**: the application's client ID\n      - **AZURE_USERNAME**: a username (usually an email address)\n      - **AZURE_PASSWORD**: that user's password\n      - **AZURE_TENANT_ID**: (optional) ID of the service principal's tenant. Also called its 'directory' ID.\n        If not provided, defaults to the 'organizations' tenant, which supports only Microsoft Entra work or\n        school accounts.\n",
                      "markdown": "`    User with username and password:\n      - **AZURE_CLIENT_ID**: the application's client ID\n      - **AZURE_USERNAME**: a username (usually an email address)\n      - **AZURE_PASSWORD**: that user's password\n      - **AZURE_TENANT_ID**: (optional) ID of the service principal's tenant. Also called its 'directory' ID.\n        If not provided, defaults to the 'organizations' tenant, which supports only Microsoft Entra work or\n        school accounts.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 27,
                  "endLine": 48,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n\n    User with username and password:\n      - **AZURE_CLIENT_ID**: the application's client ID\n      - **AZURE_USERNAME**: a username (usually an email address)\n      - **AZURE_PASSWORD**: that user's password\n",
                    "rendered": {
                      "text": "        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n\n    User with username and password:\n      - **AZURE_CLIENT_ID**: the application's client ID\n      - **AZURE_USERNAME**: a username (usually an email address)\n      - **AZURE_PASSWORD**: that user's password\n",
                      "markdown": "`        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n\n    User with username and password:\n      - **AZURE_CLIENT_ID**: the application's client ID\n      - **AZURE_USERNAME**: a username (usually an email address)\n      - **AZURE_PASSWORD**: that user's password\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 58,
                  "endLine": 40,
                  "endColumn": 66,
                  "snippet": {
                    "text": " of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n      - **AZURE_CLIENT_SEND_CERTIFICATE_CHAIN**: (optional) If True, the credential will send the public certificate\n        chain in the x5c header of each token request's JWT. This is required for Subject Name/Issuer (SNI)\n        authentication. Defaults to False",
                    "rendered": {
                      "text": " of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n      - **AZURE_CLIENT_SEND_CERTIFICATE_CHAIN**: (optional) If True, the credential will send the public certificate\n        chain in the x5c header of each token request's JWT. This is required for Subject Name/Issuer (SNI)\n        authentication. Defaults to False",
                      "markdown": "` of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n      - **AZURE_CLIENT_SEND_CERTIFICATE_CHAIN**: (optional) If True, the credential will send the public certificate\n        chain in the x5c header of each token request's JWT. This is required for Subject Name/Issuer (SNI)\n        authentication. Defaults to False`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 35,
                  "endLine": 40,
                  "endColumn": 43,
                  "snippet": {
                    "text": "**AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n      - **AZURE_CLIENT_SEND_CERTIFICATE_CHAIN**: (optional) If True, the credential will send the public certificate\n        chain in the x5c header of each token request's JWT. This is required for Subject Name/Issuer (SNI)\n        authentica",
                    "rendered": {
                      "text": "**AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n      - **AZURE_CLIENT_SEND_CERTIFICATE_CHAIN**: (optional) If True, the credential will send the public certificate\n        chain in the x5c header of each token request's JWT. This is required for Subject Name/Issuer (SNI)\n        authentica",
                      "markdown": "`**AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n      - **AZURE_CLIENT_SEND_CERTIFICATE_CHAIN**: (optional) If True, the credential will send the public certificate\n        chain in the x5c header of each token request's JWT. This is required for Subject Name/Issuer (SNI)\n        authentica`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 31,
                  "endLine": 26,
                  "endColumn": 39,
                  "snippet": {
                    "text": "    \"\"\"A credential configured by environment variables.\n\n    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n",
                    "rendered": {
                      "text": "    \"\"\"A credential configured by environment variables.\n\n    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n",
                      "markdown": "`    \"\"\"A credential configured by environment variables.\n\n    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 90,
                  "endLine": 17,
                  "endColumn": 98,
                  "snippet": {
                    "text": "from .client_secret import ClientSecretCredential\nfrom .user_password import UsernamePasswordCredential\n\nEnvironmentCredentialTypes = Union[CertificateCredential, ClientSecretCredential, UsernamePasswordCredential]\n\n_LOGGER = logging.getLogger(__name__)\n\n",
                    "rendered": {
                      "text": "from .client_secret import ClientSecretCredential\nfrom .user_password import UsernamePasswordCredential\n\nEnvironmentCredentialTypes = Union[CertificateCredential, ClientSecretCredential, UsernamePasswordCredential]\n\n_LOGGER = logging.getLogger(__name__)\n\n",
                      "markdown": "`from .client_secret import ClientSecretCredential\nfrom .user_password import UsernamePasswordCredential\n\nEnvironmentCredentialTypes = Union[CertificateCredential, ClientSecretCredential, UsernamePasswordCredential]\n\n_LOGGER = logging.getLogger(__name__)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 35,
                  "endLine": 15,
                  "endColumn": 43,
                  "snippet": {
                    "text": "from .._internal.decorators import log_get_token\nfrom .certificate import CertificateCredential\nfrom .client_secret import ClientSecretCredential\nfrom .user_password import UsernamePasswordCredential\n\nEnvironmentCredentialTypes = Union[CertificateCredential, ClientSecretCredential, UsernamePasswordCredential]\n\n",
                    "rendered": {
                      "text": "from .._internal.decorators import log_get_token\nfrom .certificate import CertificateCredential\nfrom .client_secret import ClientSecretCredential\nfrom .user_password import UsernamePasswordCredential\n\nEnvironmentCredentialTypes = Union[CertificateCredential, ClientSecretCredential, UsernamePasswordCredential]\n\n",
                      "markdown": "`from .._internal.decorators import log_get_token\nfrom .certificate import CertificateCredential\nfrom .client_secret import ClientSecretCredential\nfrom .user_password import UsernamePasswordCredential\n\nEnvironmentCredentialTypes = Union[CertificateCredential, ClientSecretCredential, UsernamePasswordCredential]\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 11,
                  "endLine": 15,
                  "endColumn": 19,
                  "snippet": {
                    "text": "from .._internal.decorators import log_get_token\nfrom .certificate import CertificateCredential\nfrom .client_secret import ClientSecretCredential\nfrom .user_password import UsernamePasswordCredential\n\nEnvironmentCredentialTypes = Union[CertificateCredential, ClientSecretCredential, UsernamePasswordCredential]\n\n",
                    "rendered": {
                      "text": "from .._internal.decorators import log_get_token\nfrom .certificate import CertificateCredential\nfrom .client_secret import ClientSecretCredential\nfrom .user_password import UsernamePasswordCredential\n\nEnvironmentCredentialTypes = Union[CertificateCredential, ClientSecretCredential, UsernamePasswordCredential]\n\n",
                      "markdown": "`from .._internal.decorators import log_get_token\nfrom .certificate import CertificateCredential\nfrom .client_secret import ClientSecretCredential\nfrom .user_password import UsernamePasswordCredential\n\nEnvironmentCredentialTypes = Union[CertificateCredential, ClientSecretCredential, UsernamePasswordCredential]\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 174,
                  "startColumn": 60,
                  "endLine": 174,
                  "endColumn": 101,
                  "snippet": {
                    "text": "        :rtype: AccessTokenInfo\n        :return: An AccessTokenInfo instance containing information about the token.\n\n        :raises ~azure.identity.CredentialUnavailableError: environment variable configuration is incomplete.\n        \"\"\"\n        if not self._credential:\n            message = (\n",
                    "rendered": {
                      "text": "        :rtype: AccessTokenInfo\n        :return: An AccessTokenInfo instance containing information about the token.\n\n        :raises ~azure.identity.CredentialUnavailableError: environment variable configuration is incomplete.\n        \"\"\"\n        if not self._credential:\n            message = (\n",
                      "markdown": "`        :rtype: AccessTokenInfo\n        :return: An AccessTokenInfo instance containing information about the token.\n\n        :raises ~azure.identity.CredentialUnavailableError: environment variable configuration is incomplete.\n        \"\"\"\n        if not self._credential:\n            message = (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 148,
                  "startColumn": 60,
                  "endLine": 148,
                  "endColumn": 101,
                  "snippet": {
                    "text": "        :return: An access token with the desired scopes.\n        :rtype: ~azure.core.credentials.AccessToken\n\n        :raises ~azure.identity.CredentialUnavailableError: environment variable configuration is incomplete\n        \"\"\"\n        if not self._credential:\n            message = (\n",
                    "rendered": {
                      "text": "        :return: An access token with the desired scopes.\n        :rtype: ~azure.core.credentials.AccessToken\n\n        :raises ~azure.identity.CredentialUnavailableError: environment variable configuration is incomplete\n        \"\"\"\n        if not self._credential:\n            message = (\n",
                      "markdown": "`        :return: An access token with the desired scopes.\n        :rtype: ~azure.core.credentials.AccessToken\n\n        :raises ~azure.identity.CredentialUnavailableError: environment variable configuration is incomplete\n        \"\"\"\n        if not self._credential:\n            message = (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 29,
                  "endLine": 95,
                  "endColumn": 40,
                  "snippet": {
                    "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n                password=os.environ[EnvironmentVariables.AZURE_PASSWORD],\n                tenant_id=os.environ.get(EnvironmentVariables.AZURE_TENANT_ID),  # optional for username/password auth\n                **kwargs\n            )\n\n",
                    "rendered": {
                      "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n                password=os.environ[EnvironmentVariables.AZURE_PASSWORD],\n                tenant_id=os.environ.get(EnvironmentVariables.AZURE_TENANT_ID),  # optional for username/password auth\n                **kwargs\n            )\n\n",
                      "markdown": "`                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n                password=os.environ[EnvironmentVariables.AZURE_PASSWORD],\n                tenant_id=os.environ.get(EnvironmentVariables.AZURE_TENANT_ID),  # optional for username/password auth\n                **kwargs\n            )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 90,
                  "startColumn": 20,
                  "endLine": 90,
                  "endColumn": 31,
                  "snippet": {
                    "text": "                ),\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.USERNAME_PASSWORD_VARS):\n            self._credential = UsernamePasswordCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n",
                    "rendered": {
                      "text": "                ),\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.USERNAME_PASSWORD_VARS):\n            self._credential = UsernamePasswordCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n",
                      "markdown": "`                ),\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.USERNAME_PASSWORD_VARS):\n            self._credential = UsernamePasswordCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                username=os.environ[EnvironmentVariables.AZURE_USERNAME],\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 23,
                  "endLine": 86,
                  "endColumn": 34,
                  "snippet": {
                    "text": "                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n                **kwargs\n            )\n",
                    "rendered": {
                      "text": "                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n                **kwargs\n            )\n",
                      "markdown": "`                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n                **kwargs\n            )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 28,
                  "endLine": 84,
                  "endColumn": 39,
                  "snippet": {
                    "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n",
                    "rendered": {
                      "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n",
                      "markdown": "`                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 20,
                  "endLine": 79,
                  "endColumn": 31,
                  "snippet": {
                    "text": "                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.CERT_VARS):\n            self._credential = CertificateCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n",
                    "rendered": {
                      "text": "                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.CERT_VARS):\n            self._credential = CertificateCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n",
                      "markdown": "`                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.CERT_VARS):\n            self._credential = CertificateCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 18,
                  "endLine": 72,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    def __init__(self, **kwargs: Any) -> None:\n        self._credential: Optional[EnvironmentCredentialTypes] = None\n\n        if all(os.environ.get(v) is not None for v in EnvironmentVariables.CLIENT_SECRET_VARS):\n            self._credential = ClientSecretCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                client_secret=os.environ[EnvironmentVariables.AZURE_CLIENT_SECRET],\n",
                    "rendered": {
                      "text": "    def __init__(self, **kwargs: Any) -> None:\n        self._credential: Optional[EnvironmentCredentialTypes] = None\n\n        if all(os.environ.get(v) is not None for v in EnvironmentVariables.CLIENT_SECRET_VARS):\n            self._credential = ClientSecretCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                client_secret=os.environ[EnvironmentVariables.AZURE_CLIENT_SECRET],\n",
                      "markdown": "`    def __init__(self, **kwargs: Any) -> None:\n        self._credential: Optional[EnvironmentCredentialTypes] = None\n\n        if all(os.environ.get(v) is not None for v in EnvironmentVariables.CLIENT_SECRET_VARS):\n            self._credential = ClientSecretCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                client_secret=os.environ[EnvironmentVariables.AZURE_CLIENT_SECRET],\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 166,
                  "startColumn": 83,
                  "endLine": 166,
                  "endColumn": 87,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scope for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scope for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scope for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 138,
                  "startColumn": 84,
                  "endLine": 138,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 49,
                  "endLine": 52,
                  "endColumn": 58,
                  "snippet": {
                    "text": "      - **AZURE_CLIENT_ID**: the application's client ID\n      - **AZURE_USERNAME**: a username (usually an email address)\n      - **AZURE_PASSWORD**: that user's password\n      - **AZURE_TENANT_ID**: (optional) ID of the service principal's tenant. Also called its 'directory' ID.\n        If not provided, defaults to the 'organizations' tenant, which supports only Microsoft Entra work or\n        school accounts.\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n",
                    "rendered": {
                      "text": "      - **AZURE_CLIENT_ID**: the application's client ID\n      - **AZURE_USERNAME**: a username (usually an email address)\n      - **AZURE_PASSWORD**: that user's password\n      - **AZURE_TENANT_ID**: (optional) ID of the service principal's tenant. Also called its 'directory' ID.\n        If not provided, defaults to the 'organizations' tenant, which supports only Microsoft Entra work or\n        school accounts.\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n",
                      "markdown": "`      - **AZURE_CLIENT_ID**: the application's client ID\n      - **AZURE_USERNAME**: a username (usually an email address)\n      - **AZURE_PASSWORD**: that user's password\n      - **AZURE_TENANT_ID**: (optional) ID of the service principal's tenant. Also called its 'directory' ID.\n        If not provided, defaults to the 'organizations' tenant, which supports only Microsoft Entra work or\n        school accounts.\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 32,
                  "endLine": 38,
                  "endColumn": 41,
                  "snippet": {
                    "text": "\n    Service principal with certificate:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n      - **AZURE_CLIENT_SEND_CERTIFICATE_CHAIN**: (optional) If True, the credential will send the public certificate\n",
                    "rendered": {
                      "text": "\n    Service principal with certificate:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n      - **AZURE_CLIENT_SEND_CERTIFICATE_CHAIN**: (optional) If True, the credential will send the public certificate\n",
                      "markdown": "`\n    Service principal with certificate:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n      - **AZURE_CLIENT_SEND_CERTIFICATE_CHAIN**: (optional) If True, the credential will send the public certificate\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 38,
                  "endLine": 37,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        when no value is given.\n\n    Service principal with certificate:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n",
                    "rendered": {
                      "text": "        when no value is given.\n\n    Service principal with certificate:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n",
                      "markdown": "`        when no value is given.\n\n    Service principal with certificate:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 3,
                  "endLine": 36,
                  "endColumn": 12,
                  "snippet": {
                    "text": "        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n\n    Service principal with certificate:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n",
                    "rendered": {
                      "text": "        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n\n    Service principal with certificate:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n",
                      "markdown": "`        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n\n    Service principal with certificate:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 43,
                  "endLine": 31,
                  "endColumn": 52,
                  "snippet": {
                    "text": "    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n",
                    "rendered": {
                      "text": "    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n",
                      "markdown": "`    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 30,
                  "startColumn": 32,
                  "endLine": 30,
                  "endColumn": 41,
                  "snippet": {
                    "text": "\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n",
                    "rendered": {
                      "text": "\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n",
                      "markdown": "`\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 38,
                  "endLine": 29,
                  "endColumn": 47,
                  "snippet": {
                    "text": "    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n",
                    "rendered": {
                      "text": "    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n",
                      "markdown": "`    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 3,
                  "endLine": 28,
                  "endColumn": 12,
                  "snippet": {
                    "text": "    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n",
                    "rendered": {
                      "text": "    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n",
                      "markdown": "`    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/environment.py"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 53,
                  "endLine": 25,
                  "endColumn": 62,
                  "snippet": {
                    "text": "class EnvironmentCredential:\n    \"\"\"A credential configured by environment variables.\n\n    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n",
                    "rendered": {
                      "text": "class EnvironmentCredential:\n    \"\"\"A credential configured by environment variables.\n\n    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n",
                      "markdown": "`class EnvironmentCredential:\n    \"\"\"A credential configured by environment variables.\n\n    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/authorization_code.py"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 84,
                  "endLine": 103,
                  "endColumn": 88,
                  "snippet": {
                    "text": "        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/authorization_code.py"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 84,
                  "endLine": 75,
                  "endColumn": 88,
                  "snippet": {
                    "text": "        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/authorization_code.py"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 17,
                  "endLine": 99,
                  "endColumn": 23,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        The first time this method is called, the credential will redeem its authorization code. On subsequent calls\n        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        The first time this method is called, the credential will redeem its authorization code. On subsequent calls\n        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        The first time this method is called, the credential will redeem its authorization code. On subsequent calls\n        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/authorization_code.py"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 17,
                  "endLine": 71,
                  "endColumn": 23,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        The first time this method is called, the credential will redeem its authorization code. On subsequent calls\n        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        The first time this method is called, the credential will redeem its authorization code. On subsequent calls\n        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        The first time this method is called, the credential will redeem its authorization code. On subsequent calls\n        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 112,
                  "startColumn": 83,
                  "endLine": 112,
                  "endColumn": 87,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scope for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scope for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scope for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 84,
                  "endLine": 85,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 62,
                  "startColumn": 78,
                  "endLine": 62,
                  "endColumn": 82,
                  "snippet": {
                    "text": "        if not system_access_token or not tenant_id or not client_id or not service_connection_id:\n            raise ValueError(\n                \"'tenant_id', 'client_id','service_connection_id', and 'system_access_token' must be passed in as \"\n                f\"keyword arguments. Please refer to the troubleshooting guide at {TROUBLESHOOTING_GUIDE}.\"\n            )\n        validate_tenant_id(tenant_id)\n\n",
                    "rendered": {
                      "text": "        if not system_access_token or not tenant_id or not client_id or not service_connection_id:\n            raise ValueError(\n                \"'tenant_id', 'client_id','service_connection_id', and 'system_access_token' must be passed in as \"\n                f\"keyword arguments. Please refer to the troubleshooting guide at {TROUBLESHOOTING_GUIDE}.\"\n            )\n        validate_tenant_id(tenant_id)\n\n",
                      "markdown": "`        if not system_access_token or not tenant_id or not client_id or not service_connection_id:\n            raise ValueError(\n                \"'tenant_id', 'client_id','service_connection_id', and 'system_access_token' must be passed in as \"\n                f\"keyword arguments. Please refer to the troubleshooting guide at {TROUBLESHOOTING_GUIDE}.\"\n            )\n        validate_tenant_id(tenant_id)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 26,
                  "endLine": 27,
                  "endColumn": 35,
                  "snippet": {
                    "text": "\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n    :keyword str system_access_token: The pipeline's System.AccessToken value. It is recommended to assign the value\n        of System.AccessToken to a secur",
                    "rendered": {
                      "text": "\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n    :keyword str system_access_token: The pipeline's System.AccessToken value. It is recommended to assign the value\n        of System.AccessToken to a secur",
                      "markdown": "`\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n    :keyword str system_access_token: The pipeline's System.AccessToken value. It is recommended to assign the value\n        of System.AccessToken to a secur`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 73,
                  "endLine": 26,
                  "endColumn": 82,
                  "snippet": {
                    "text": "\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n    :keyword str system_access_token: The pipeline's System.AccessToken value. It is recommended to assign the value\n",
                    "rendered": {
                      "text": "\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n    :keyword str system_access_token: The pipeline's System.AccessToken value. It is recommended to assign the value\n",
                      "markdown": "`\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n    :keyword str system_access_token: The pipeline's System.AccessToken value. It is recommended to assign the value\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 43,
                  "endLine": 26,
                  "endColumn": 52,
                  "snippet": {
                    "text": "\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n    :keyword str system_access_token: The pipeline's System.AccessToken value. It is recommended to assign the value\n",
                    "rendered": {
                      "text": "\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n    :keyword str system_access_token: The pipeline's System.AccessToken value. It is recommended to assign the value\n",
                      "markdown": "`\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n    :keyword str system_access_token: The pipeline's System.AccessToken value. It is recommended to assign the value\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 49,
                  "endLine": 25,
                  "endColumn": 58,
                  "snippet": {
                    "text": "    connections.\n\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n",
                    "rendered": {
                      "text": "    connections.\n\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n",
                      "markdown": "`    connections.\n\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 49,
                  "endLine": 24,
                  "endColumn": 58,
                  "snippet": {
                    "text": "    This credential enables authentication in Azure Pipelines using workload identity federation for Azure service\n    connections.\n\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n",
                    "rendered": {
                      "text": "    This credential enables authentication in Azure Pipelines using workload identity federation for Azure service\n    connections.\n\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n",
                      "markdown": "`    This credential enables authentication in Azure Pipelines using workload identity federation for Azure service\n    connections.\n\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 106,
                  "endLine": 22,
                  "snippet": {
                    "text": "class AzurePipelinesCredential(AsyncContextManager):\n    \"\"\"Authenticates using Microsoft Entra Workload ID in Azure Pipelines.\n\n    This credential enables authentication in Azure Pipelines using workload identity federation for Azure service\n    connections.\n\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n",
                    "rendered": {
                      "text": "class AzurePipelinesCredential(AsyncContextManager):\n    \"\"\"Authenticates using Microsoft Entra Workload ID in Azure Pipelines.\n\n    This credential enables authentication in Azure Pipelines using workload identity federation for Azure service\n    connections.\n\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n",
                      "markdown": "`class AzurePipelinesCredential(AsyncContextManager):\n    \"\"\"Authenticates using Microsoft Entra Workload ID in Azure Pipelines.\n\n    This credential enables authentication in Azure Pipelines using workload identity federation for Azure service\n    connections.\n\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_cli.py"
                },
                "region": {
                  "startLine": 207,
                  "startColumn": 17,
                  "endLine": 207,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        raise CredentialUnavailableError(message=NOT_LOGGED_IN)\n\n    message = sanitize_output(stderr) if stderr else \"Failed to invoke Azure CLI\"\n    if within_dac.get():\n        raise CredentialUnavailableError(message=message)\n    raise ClientAuthenticationError(message=message)\n",
                    "rendered": {
                      "text": "        raise CredentialUnavailableError(message=NOT_LOGGED_IN)\n\n    message = sanitize_output(stderr) if stderr else \"Failed to invoke Azure CLI\"\n    if within_dac.get():\n        raise CredentialUnavailableError(message=message)\n    raise ClientAuthenticationError(message=message)\n",
                      "markdown": "`        raise CredentialUnavailableError(message=NOT_LOGGED_IN)\n\n    message = sanitize_output(stderr) if stderr else \"Failed to invoke Azure CLI\"\n    if within_dac.get():\n        raise CredentialUnavailableError(message=message)\n    raise ClientAuthenticationError(message=message)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_cli.py"
                },
                "region": {
                  "startLine": 154,
                  "startColumn": 25,
                  "endLine": 154,
                  "endColumn": 30,
                  "snippet": {
                    "text": "                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n                raise CredentialUnavailableError(message=message)\n            raise ClientAuthenticationError(message=message)\n\n",
                    "rendered": {
                      "text": "                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n                raise CredentialUnavailableError(message=message)\n            raise ClientAuthenticationError(message=message)\n\n",
                      "markdown": "`                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n                raise CredentialUnavailableError(message=message)\n            raise ClientAuthenticationError(message=message)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_cli.py"
                },
                "region": {
                  "startLine": 127,
                  "startColumn": 27,
                  "endLine": 127,
                  "endColumn": 32,
                  "snippet": {
                    "text": "    async def _get_token_base(\n        self, *scopes: str, options: Optional[TokenRequestOptions] = None, **kwargs: Any\n    ) -> AccessTokenInfo:\n        tenant_id = options.get(\"tenant_id\") if options else None\n        if tenant_id:\n            validate_tenant_id(tenant_id)\n        for scope in scopes:\n",
                    "rendered": {
                      "text": "    async def _get_token_base(\n        self, *scopes: str, options: Optional[TokenRequestOptions] = None, **kwargs: Any\n    ) -> AccessTokenInfo:\n        tenant_id = options.get(\"tenant_id\") if options else None\n        if tenant_id:\n            validate_tenant_id(tenant_id)\n        for scope in scopes:\n",
                      "markdown": "`    async def _get_token_base(\n        self, *scopes: str, options: Optional[TokenRequestOptions] = None, **kwargs: Any\n    ) -> AccessTokenInfo:\n        tenant_id = options.get(\"tenant_id\") if options else None\n        if tenant_id:\n            validate_tenant_id(tenant_id)\n        for scope in scopes:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_cli.py"
                },
                "region": {
                  "startLine": 151,
                  "startColumn": 93,
                  "endLine": 151,
                  "endColumn": 97,
                  "snippet": {
                    "text": "            sanitized_output = sanitize_output(output)\n            message = (\n                f\"Unexpected output from Azure CLI: '{sanitized_output}'. \\n\"\n                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n",
                    "rendered": {
                      "text": "            sanitized_output = sanitize_output(output)\n            message = (\n                f\"Unexpected output from Azure CLI: '{sanitized_output}'. \\n\"\n                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n",
                      "markdown": "`            sanitized_output = sanitize_output(output)\n            message = (\n                f\"Unexpected output from Azure CLI: '{sanitized_output}'. \\n\"\n                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_arc.py"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 25,
                  "endLine": 20,
                  "endColumn": 30,
                  "snippet": {
                    "text": "class AzureArcCredential(AsyncManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[AsyncManagedIdentityClient]:\n        url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n        imds = os.environ.get(EnvironmentVariables.IMDS_ENDPOINT)\n        if url and imds:\n            return AsyncManagedIdentityClient(\n                _per_retry_policies=[ArcChallengeAuthPolicy()],\n",
                    "rendered": {
                      "text": "class AzureArcCredential(AsyncManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[AsyncManagedIdentityClient]:\n        url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n        imds = os.environ.get(EnvironmentVariables.IMDS_ENDPOINT)\n        if url and imds:\n            return AsyncManagedIdentityClient(\n                _per_retry_policies=[ArcChallengeAuthPolicy()],\n",
                      "markdown": "`class AzureArcCredential(AsyncManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[AsyncManagedIdentityClient]:\n        url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n        imds = os.environ.get(EnvironmentVariables.IMDS_ENDPOINT)\n        if url and imds:\n            return AsyncManagedIdentityClient(\n                _per_retry_policies=[ArcChallengeAuthPolicy()],\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_arc.py"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 24,
                  "endLine": 19,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\nclass AzureArcCredential(AsyncManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[AsyncManagedIdentityClient]:\n        url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n        imds = os.environ.get(EnvironmentVariables.IMDS_ENDPOINT)\n        if url and imds:\n            return AsyncManagedIdentityClient(\n",
                    "rendered": {
                      "text": "\nclass AzureArcCredential(AsyncManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[AsyncManagedIdentityClient]:\n        url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n        imds = os.environ.get(EnvironmentVariables.IMDS_ENDPOINT)\n        if url and imds:\n            return AsyncManagedIdentityClient(\n",
                      "markdown": "`\nclass AzureArcCredential(AsyncManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[AsyncManagedIdentityClient]:\n        url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n        imds = os.environ.get(EnvironmentVariables.IMDS_ENDPOINT)\n        if url and imds:\n            return AsyncManagedIdentityClient(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_arc.py"
                },
                "region": {
                  "startLine": 42,
                  "startColumn": 78,
                  "endLine": 42,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        if response.http_response.status_code == 401:\n            secret_key = _get_secret_key(response)\n            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)\n            response = await self.next.send(request)\n\n        return response\n",
                    "rendered": {
                      "text": "\n        if response.http_response.status_code == 401:\n            secret_key = _get_secret_key(response)\n            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)\n            response = await self.next.send(request)\n\n        return response\n",
                      "markdown": "`\n        if response.http_response.status_code == 401:\n            secret_key = _get_secret_key(response)\n            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)\n            response = await self.next.send(request)\n\n        return response\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_arc.py"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 30,
                  "endLine": 41,
                  "endColumn": 40,
                  "snippet": {
                    "text": "        response = await self.next.send(request)\n\n        if response.http_response.status_code == 401:\n            secret_key = _get_secret_key(response)\n            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)\n            response = await self.next.send(request)\n\n",
                    "rendered": {
                      "text": "        response = await self.next.send(request)\n\n        if response.http_response.status_code == 401:\n            secret_key = _get_secret_key(response)\n            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)\n            response = await self.next.send(request)\n\n",
                      "markdown": "`        response = await self.next.send(request)\n\n        if response.http_response.status_code == 401:\n            secret_key = _get_secret_key(response)\n            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)\n            response = await self.next.send(request)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_arc.py"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 12,
                  "endLine": 41,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        response = await self.next.send(request)\n\n        if response.http_response.status_code == 401:\n            secret_key = _get_secret_key(response)\n            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)\n            response = await self.next.send(request)\n\n",
                    "rendered": {
                      "text": "        response = await self.next.send(request)\n\n        if response.http_response.status_code == 401:\n            secret_key = _get_secret_key(response)\n            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)\n            response = await self.next.send(request)\n\n",
                      "markdown": "`        response = await self.next.send(request)\n\n        if response.http_response.status_code == 401:\n            secret_key = _get_secret_key(response)\n            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)\n            response = await self.next.send(request)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_arc.py"
                },
                "region": {
                  "startLine": 14,
                  "startColumn": 57,
                  "endLine": 14,
                  "endColumn": 67,
                  "snippet": {
                    "text": "from .._internal.managed_identity_base import AsyncManagedIdentityBase\nfrom .._internal.managed_identity_client import AsyncManagedIdentityClient\nfrom ..._constants import EnvironmentVariables\nfrom ..._credentials.azure_arc import _get_request, _get_secret_key\n\n\nclass AzureArcCredential(AsyncManagedIdentityBase):\n",
                    "rendered": {
                      "text": "from .._internal.managed_identity_base import AsyncManagedIdentityBase\nfrom .._internal.managed_identity_client import AsyncManagedIdentityClient\nfrom ..._constants import EnvironmentVariables\nfrom ..._credentials.azure_arc import _get_request, _get_secret_key\n\n\nclass AzureArcCredential(AsyncManagedIdentityBase):\n",
                      "markdown": "`from .._internal.managed_identity_base import AsyncManagedIdentityBase\nfrom .._internal.managed_identity_client import AsyncManagedIdentityClient\nfrom ..._constants import EnvironmentVariables\nfrom ..._credentials.azure_arc import _get_request, _get_secret_key\n\n\nclass AzureArcCredential(AsyncManagedIdentityBase):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_arc.py"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 18,
                  "endLine": 20,
                  "endColumn": 29,
                  "snippet": {
                    "text": "class AzureArcCredential(AsyncManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[AsyncManagedIdentityClient]:\n        url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n        imds = os.environ.get(EnvironmentVariables.IMDS_ENDPOINT)\n        if url and imds:\n            return AsyncManagedIdentityClient(\n                _per_retry_policies=[ArcChallengeAuthPolicy()],\n",
                    "rendered": {
                      "text": "class AzureArcCredential(AsyncManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[AsyncManagedIdentityClient]:\n        url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n        imds = os.environ.get(EnvironmentVariables.IMDS_ENDPOINT)\n        if url and imds:\n            return AsyncManagedIdentityClient(\n                _per_retry_policies=[ArcChallengeAuthPolicy()],\n",
                      "markdown": "`class AzureArcCredential(AsyncManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[AsyncManagedIdentityClient]:\n        url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n        imds = os.environ.get(EnvironmentVariables.IMDS_ENDPOINT)\n        if url and imds:\n            return AsyncManagedIdentityClient(\n                _per_retry_policies=[ArcChallengeAuthPolicy()],\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azure_arc.py"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 17,
                  "endLine": 19,
                  "endColumn": 28,
                  "snippet": {
                    "text": "\nclass AzureArcCredential(AsyncManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[AsyncManagedIdentityClient]:\n        url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n        imds = os.environ.get(EnvironmentVariables.IMDS_ENDPOINT)\n        if url and imds:\n            return AsyncManagedIdentityClient(\n",
                    "rendered": {
                      "text": "\nclass AzureArcCredential(AsyncManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[AsyncManagedIdentityClient]:\n        url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n        imds = os.environ.get(EnvironmentVariables.IMDS_ENDPOINT)\n        if url and imds:\n            return AsyncManagedIdentityClient(\n",
                      "markdown": "`\nclass AzureArcCredential(AsyncManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[AsyncManagedIdentityClient]:\n        url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n        imds = os.environ.get(EnvironmentVariables.IMDS_ENDPOINT)\n        if url and imds:\n            return AsyncManagedIdentityClient(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/silent.py"
                },
                "region": {
                  "startLine": 203,
                  "startColumn": 63,
                  "endLine": 203,
                  "endColumn": 68,
                  "snippet": {
                    "text": "        if result:\n            # cache contains a matching refresh token but STS returned an error response when MSAL tried to use it\n            message = \"Token acquisition failed\"\n            details = result.get(\"error_description\") or result.get(\"error\")\n            if details:\n                message += \": {}\".format(details)\n            raise ClientAuthenticationError(message=message)\n",
                    "rendered": {
                      "text": "        if result:\n            # cache contains a matching refresh token but STS returned an error response when MSAL tried to use it\n            message = \"Token acquisition failed\"\n            details = result.get(\"error_description\") or result.get(\"error\")\n            if details:\n                message += \": {}\".format(details)\n            raise ClientAuthenticationError(message=message)\n",
                      "markdown": "`        if result:\n            # cache contains a matching refresh token but STS returned an error response when MSAL tried to use it\n            message = \"Token acquisition failed\"\n            details = result.get(\"error_description\") or result.get(\"error\")\n            if details:\n                message += \": {}\".format(details)\n            raise ClientAuthenticationError(message=message)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/silent.py"
                },
                "region": {
                  "startLine": 203,
                  "startColumn": 28,
                  "endLine": 203,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        if result:\n            # cache contains a matching refresh token but STS returned an error response when MSAL tried to use it\n            message = \"Token acquisition failed\"\n            details = result.get(\"error_description\") or result.get(\"error\")\n            if details:\n                message += \": {}\".format(details)\n            raise ClientAuthenticationError(message=message)\n",
                    "rendered": {
                      "text": "        if result:\n            # cache contains a matching refresh token but STS returned an error response when MSAL tried to use it\n            message = \"Token acquisition failed\"\n            details = result.get(\"error_description\") or result.get(\"error\")\n            if details:\n                message += \": {}\".format(details)\n            raise ClientAuthenticationError(message=message)\n",
                      "markdown": "`        if result:\n            # cache contains a matching refresh token but STS returned an error response when MSAL tried to use it\n            message = \"Token acquisition failed\"\n            details = result.get(\"error_description\") or result.get(\"error\")\n            if details:\n                message += \": {}\".format(details)\n            raise ClientAuthenticationError(message=message)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/silent.py"
                },
                "region": {
                  "startLine": 195,
                  "startColumn": 37,
                  "endLine": 195,
                  "endColumn": 42,
                  "snippet": {
                    "text": "                return AccessTokenInfo(\n                    result[\"access_token\"],\n                    now + int(result[\"expires_in\"]),\n                    token_type=result.get(\"token_type\", \"Bearer\"),\n                    refresh_on=refresh_on,\n                )\n\n",
                    "rendered": {
                      "text": "                return AccessTokenInfo(\n                    result[\"access_token\"],\n                    now + int(result[\"expires_in\"]),\n                    token_type=result.get(\"token_type\", \"Bearer\"),\n                    refresh_on=refresh_on,\n                )\n\n",
                      "markdown": "`                return AccessTokenInfo(\n                    result[\"access_token\"],\n                    now + int(result[\"expires_in\"]),\n                    token_type=result.get(\"token_type\", \"Bearer\"),\n                    refresh_on=refresh_on,\n                )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/silent.py"
                },
                "region": {
                  "startLine": 187,
                  "startColumn": 70,
                  "endLine": 187,
                  "endColumn": 75,
                  "snippet": {
                    "text": "\n            now = int(time.time())\n            result = client_application.acquire_token_silent_with_error(\n                list(scopes), account=account, claims_challenge=kwargs.get(\"claims\")\n            )\n\n            if result and \"access_token\" in result and \"expires_in\" in result:\n",
                    "rendered": {
                      "text": "\n            now = int(time.time())\n            result = client_application.acquire_token_silent_with_error(\n                list(scopes), account=account, claims_challenge=kwargs.get(\"claims\")\n            )\n\n            if result and \"access_token\" in result and \"expires_in\" in result:\n",
                      "markdown": "`\n            now = int(time.time())\n            result = client_application.acquire_token_silent_with_error(\n                list(scopes), account=account, claims_challenge=kwargs.get(\"claims\")\n            )\n\n            if result and \"access_token\" in result and \"expires_in\" in result:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/silent.py"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 22,
                  "endLine": 182,
                  "endColumn": 27,
                  "snippet": {
                    "text": "            raise CredentialUnavailableError(\"The cache contains no account matching the given AuthenticationRecord.\")\n\n        for account in accounts_for_user:\n            if account.get(\"home_account_id\") != self._auth_record.home_account_id:\n                continue\n\n            now = int(time.time())\n",
                    "rendered": {
                      "text": "            raise CredentialUnavailableError(\"The cache contains no account matching the given AuthenticationRecord.\")\n\n        for account in accounts_for_user:\n            if account.get(\"home_account_id\") != self._auth_record.home_account_id:\n                continue\n\n            now = int(time.time())\n",
                      "markdown": "`            raise CredentialUnavailableError(\"The cache contains no account matching the given AuthenticationRecord.\")\n\n        for account in accounts_for_user:\n            if account.get(\"home_account_id\") != self._auth_record.home_account_id:\n                continue\n\n            now = int(time.time())\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/silent.py"
                },
                "region": {
                  "startLine": 149,
                  "startColumn": 17,
                  "endLine": 149,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        capabilities = None\n        token_cache = self._cache\n\n        if kwargs.get(\"enable_cae\"):\n            client_applications_map = self._cae_client_applications\n            # CP1 = can handle claims challenges (CAE)\n            capabilities = [\"CP1\"]\n",
                    "rendered": {
                      "text": "        capabilities = None\n        token_cache = self._cache\n\n        if kwargs.get(\"enable_cae\"):\n            client_applications_map = self._cae_client_applications\n            # CP1 = can handle claims challenges (CAE)\n            capabilities = [\"CP1\"]\n",
                      "markdown": "`        capabilities = None\n        token_cache = self._cache\n\n        if kwargs.get(\"enable_cae\"):\n            client_applications_map = self._cae_client_applications\n            # CP1 = can handle claims challenges (CAE)\n            capabilities = [\"CP1\"]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/silent.py"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 29,
                  "endLine": 109,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\n            # If the cache is still None, raise an error.\n            if not token_cache:\n                if within_dac.get():\n                    raise CredentialUnavailableError(message=\"Shared token cache unavailable\")\n                raise ClientAuthenticationError(message=\"Shared token cache unavailable\")\n\n",
                    "rendered": {
                      "text": "\n            # If the cache is still None, raise an error.\n            if not token_cache:\n                if within_dac.get():\n                    raise CredentialUnavailableError(message=\"Shared token cache unavailable\")\n                raise ClientAuthenticationError(message=\"Shared token cache unavailable\")\n\n",
                      "markdown": "`\n            # If the cache is still None, raise an error.\n            if not token_cache:\n                if within_dac.get():\n                    raise CredentialUnavailableError(message=\"Shared token cache unavailable\")\n                raise ClientAuthenticationError(message=\"Shared token cache unavailable\")\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/silent.py"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 28,
                  "endLine": 99,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        token_cache = self._cae_cache if enable_cae else self._cache\n\n",
                    "rendered": {
                      "text": "        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        token_cache = self._cae_cache if enable_cae else self._cache\n\n",
                      "markdown": "`        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        token_cache = self._cae_cache if enable_cae else self._cache\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/silent.py"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 27,
                  "endLine": 98,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        token_cache = self._cae_cache if enable_cae else self._cache\n",
                    "rendered": {
                      "text": "\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        token_cache = self._cae_cache if enable_cae else self._cache\n",
                      "markdown": "`\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        token_cache = self._cae_cache if enable_cae else self._cache\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/silent.py"
                },
                "region": {
                  "startLine": 97,
                  "startColumn": 24,
                  "endLine": 97,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            raise ValueError(f\"'{base_method_name}' requires at least one scope\")\n\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n",
                    "rendered": {
                      "text": "            raise ValueError(f\"'{base_method_name}' requires at least one scope\")\n\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n",
                      "markdown": "`            raise ValueError(f\"'{base_method_name}' requires at least one scope\")\n\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/silent.py"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 60,
                  "endLine": 94,
                  "endColumn": 64,
                  "snippet": {
                    "text": "    ) -> AccessTokenInfo:\n\n        if not scopes:\n            raise ValueError(f\"'{base_method_name}' requires at least one scope\")\n\n        options = options or {}\n        claims = options.get(\"claims\")\n",
                    "rendered": {
                      "text": "    ) -> AccessTokenInfo:\n\n        if not scopes:\n            raise ValueError(f\"'{base_method_name}' requires at least one scope\")\n\n        options = options or {}\n        claims = options.get(\"claims\")\n",
                      "markdown": "`    ) -> AccessTokenInfo:\n\n        if not scopes:\n            raise ValueError(f\"'{base_method_name}' requires at least one scope\")\n\n        options = options or {}\n        claims = options.get(\"claims\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/silent.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 6,
                  "endLine": 7,
                  "snippet": {
                    "text": "# Licensed under the MIT License.\n# ------------------------------------\nimport platform\nimport time\nfrom typing import Dict, Optional, Any\n\nfrom msal import PublicClientApplication, TokenCache\n\n",
                    "rendered": {
                      "text": "# Licensed under the MIT License.\n# ------------------------------------\nimport platform\nimport time\nfrom typing import Dict, Optional, Any\n\nfrom msal import PublicClientApplication, TokenCache\n\n",
                      "markdown": "`# Licensed under the MIT License.\n# ------------------------------------\nimport platform\nimport time\nfrom typing import Dict, Optional, Any\n\nfrom msal import PublicClientApplication, TokenCache\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/shared_cache.py"
                },
                "region": {
                  "startLine": 199,
                  "startColumn": 72,
                  "endLine": 199,
                  "endColumn": 77,
                  "snippet": {
                    "text": "            )\n            return token\n\n        raise CredentialUnavailableError(message=NO_TOKEN.format(account.get(\"username\")))\n\n    def _get_auth_client(self, **kwargs: Any) -> AadClientBase:\n        return AadClient(client_id=DEVELOPER_SIGN_ON_CLIENT_ID, **kwargs)\n",
                    "rendered": {
                      "text": "            )\n            return token\n\n        raise CredentialUnavailableError(message=NO_TOKEN.format(account.get(\"username\")))\n\n    def _get_auth_client(self, **kwargs: Any) -> AadClientBase:\n        return AadClient(client_id=DEVELOPER_SIGN_ON_CLIENT_ID, **kwargs)\n",
                      "markdown": "`            )\n            return token\n\n        raise CredentialUnavailableError(message=NO_TOKEN.format(account.get(\"username\")))\n\n    def _get_auth_client(self, **kwargs: Any) -> AadClientBase:\n        return AadClient(client_id=DEVELOPER_SIGN_ON_CLIENT_ID, **kwargs)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/shared_cache.py"
                },
                "region": {
                  "startLine": 174,
                  "startColumn": 24,
                  "endLine": 174,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        is_cae = options.get(\"enable_cae\", False)\n\n        token_cache = self._cae_cache if is_cae else self._cache\n\n",
                    "rendered": {
                      "text": "        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        is_cae = options.get(\"enable_cae\", False)\n\n        token_cache = self._cae_cache if is_cae else self._cache\n\n",
                      "markdown": "`        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        is_cae = options.get(\"enable_cae\", False)\n\n        token_cache = self._cae_cache if is_cae else self._cache\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/shared_cache.py"
                },
                "region": {
                  "startLine": 173,
                  "startColumn": 27,
                  "endLine": 173,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        is_cae = options.get(\"enable_cae\", False)\n\n        token_cache = self._cae_cache if is_cae else self._cache\n",
                    "rendered": {
                      "text": "\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        is_cae = options.get(\"enable_cae\", False)\n\n        token_cache = self._cae_cache if is_cae else self._cache\n",
                      "markdown": "`\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        is_cae = options.get(\"enable_cae\", False)\n\n        token_cache = self._cae_cache if is_cae else self._cache\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/shared_cache.py"
                },
                "region": {
                  "startLine": 172,
                  "startColumn": 24,
                  "endLine": 172,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            self._initialize_client()\n\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        is_cae = options.get(\"enable_cae\", False)\n\n",
                    "rendered": {
                      "text": "            self._initialize_client()\n\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        is_cae = options.get(\"enable_cae\", False)\n\n",
                      "markdown": "`            self._initialize_client()\n\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        is_cae = options.get(\"enable_cae\", False)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/shared_cache.py"
                },
                "region": {
                  "startLine": 166,
                  "startColumn": 60,
                  "endLine": 166,
                  "endColumn": 64,
                  "snippet": {
                    "text": "        **kwargs: Any,\n    ) -> AccessTokenInfo:\n        if not scopes:\n            raise ValueError(f\"'{base_method_name}' requires at least one scope\")\n\n        if not self._client_initialized:\n            self._initialize_client()\n",
                    "rendered": {
                      "text": "        **kwargs: Any,\n    ) -> AccessTokenInfo:\n        if not scopes:\n            raise ValueError(f\"'{base_method_name}' requires at least one scope\")\n\n        if not self._client_initialized:\n            self._initialize_client()\n",
                      "markdown": "`        **kwargs: Any,\n    ) -> AccessTokenInfo:\n        if not scopes:\n            raise ValueError(f\"'{base_method_name}' requires at least one scope\")\n\n        if not self._client_initialized:\n            self._initialize_client()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/shared_cache.py"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 83,
                  "endLine": 98,
                  "endColumn": 87,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scope for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scope for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scope for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/shared_cache.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 84,
                  "endLine": 69,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/service_fabric.py"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 27,
                  "endLine": 23,
                  "endColumn": 32,
                  "snippet": {
                    "text": "def _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n        # Service Fabric managed identity isn't available in this environment\n        return None\n",
                    "rendered": {
                      "text": "def _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n        # Service Fabric managed identity isn't available in this environment\n        return None\n",
                      "markdown": "`def _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n        # Service Fabric managed identity isn't available in this environment\n        return None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/service_fabric.py"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 23,
                  "endLine": 22,
                  "endColumn": 28,
                  "snippet": {
                    "text": "\ndef _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n        # Service Fabric managed identity isn't available in this environment\n",
                    "rendered": {
                      "text": "\ndef _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n        # Service Fabric managed identity isn't available in this environment\n",
                      "markdown": "`\ndef _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n        # Service Fabric managed identity isn't available in this environment\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/service_fabric.py"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 20,
                  "endLine": 21,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n\ndef _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n",
                    "rendered": {
                      "text": "\n\ndef _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n",
                      "markdown": "`\n\ndef _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/service_fabric.py"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 20,
                  "endLine": 23,
                  "endColumn": 31,
                  "snippet": {
                    "text": "def _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n        # Service Fabric managed identity isn't available in this environment\n        return None\n",
                    "rendered": {
                      "text": "def _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n        # Service Fabric managed identity isn't available in this environment\n        return None\n",
                      "markdown": "`def _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n        # Service Fabric managed identity isn't available in this environment\n        return None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/service_fabric.py"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 16,
                  "endLine": 22,
                  "endColumn": 27,
                  "snippet": {
                    "text": "\ndef _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n        # Service Fabric managed identity isn't available in this environment\n",
                    "rendered": {
                      "text": "\ndef _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n        # Service Fabric managed identity isn't available in this environment\n",
                      "markdown": "`\ndef _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n        # Service Fabric managed identity isn't available in this environment\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/service_fabric.py"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 13,
                  "endLine": 21,
                  "endColumn": 24,
                  "snippet": {
                    "text": "\n\ndef _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n",
                    "rendered": {
                      "text": "\n\ndef _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n",
                      "markdown": "`\n\ndef _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/service_fabric.py"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 9,
                  "endLine": 25,
                  "endColumn": 18,
                  "snippet": {
                    "text": "    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n        # Service Fabric managed identity isn't available in this environment\n        return None\n\n    return dict(\n",
                    "rendered": {
                      "text": "    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n        # Service Fabric managed identity isn't available in this environment\n        return None\n\n    return dict(\n",
                      "markdown": "`    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    thumbprint = os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT)\n    if not (url and secret and thumbprint):\n        # Service Fabric managed identity isn't available in this environment\n        return None\n\n    return dict(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 166,
                  "startColumn": 29,
                  "endLine": 166,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        return AccessTokenInfo(\n            result[\"access_token\"],\n            request_time + int(result[\"expires_in\"]),\n            token_type=result.get(\"token_type\", \"Bearer\"),\n            refresh_on=refresh_on,\n        )\n",
                    "rendered": {
                      "text": "        return AccessTokenInfo(\n            result[\"access_token\"],\n            request_time + int(result[\"expires_in\"]),\n            token_type=result.get(\"token_type\", \"Bearer\"),\n            refresh_on=refresh_on,\n        )\n",
                      "markdown": "`        return AccessTokenInfo(\n            result[\"access_token\"],\n            request_time + int(result[\"expires_in\"]),\n            token_type=result.get(\"token_type\", \"Bearer\"),\n            refresh_on=refresh_on,\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 153,
                  "startColumn": 98,
                  "endLine": 153,
                  "endColumn": 103,
                  "snippet": {
                    "text": "        request_time = int(time.time())\n        result = app.acquire_token_on_behalf_of(self._assertion, list(scopes), claims_challenge=kwargs.get(\"claims\"))\n        if \"access_token\" not in result or \"expires_in\" not in result:\n            message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n            response = self._client.get_error_response(result)\n            raise ClientAuthenticationError(message=message, response=response)\n\n",
                    "rendered": {
                      "text": "        request_time = int(time.time())\n        result = app.acquire_token_on_behalf_of(self._assertion, list(scopes), claims_challenge=kwargs.get(\"claims\"))\n        if \"access_token\" not in result or \"expires_in\" not in result:\n            message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n            response = self._client.get_error_response(result)\n            raise ClientAuthenticationError(message=message, response=response)\n\n",
                      "markdown": "`        request_time = int(time.time())\n        result = app.acquire_token_on_behalf_of(self._assertion, list(scopes), claims_challenge=kwargs.get(\"claims\"))\n        if \"access_token\" not in result or \"expires_in\" not in result:\n            message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n            response = self._client.get_error_response(result)\n            raise ClientAuthenticationError(message=message, response=response)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 153,
                  "startColumn": 63,
                  "endLine": 153,
                  "endColumn": 68,
                  "snippet": {
                    "text": "        request_time = int(time.time())\n        result = app.acquire_token_on_behalf_of(self._assertion, list(scopes), claims_challenge=kwargs.get(\"claims\"))\n        if \"access_token\" not in result or \"expires_in\" not in result:\n            message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n            response = self._client.get_error_response(result)\n            raise ClientAuthenticationError(message=message, response=response)\n\n",
                    "rendered": {
                      "text": "        request_time = int(time.time())\n        result = app.acquire_token_on_behalf_of(self._assertion, list(scopes), claims_challenge=kwargs.get(\"claims\"))\n        if \"access_token\" not in result or \"expires_in\" not in result:\n            message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n            response = self._client.get_error_response(result)\n            raise ClientAuthenticationError(message=message, response=response)\n\n",
                      "markdown": "`        request_time = int(time.time())\n        result = app.acquire_token_on_behalf_of(self._assertion, list(scopes), claims_challenge=kwargs.get(\"claims\"))\n        if \"access_token\" not in result or \"expires_in\" not in result:\n            message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n            response = self._client.get_error_response(result)\n            raise ClientAuthenticationError(message=message, response=response)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 151,
                  "startColumn": 102,
                  "endLine": 151,
                  "endColumn": 107,
                  "snippet": {
                    "text": "    def _request_token(self, *scopes: str, **kwargs: Any) -> AccessTokenInfo:\n        app: msal.ConfidentialClientApplication = self._get_app(**kwargs)\n        request_time = int(time.time())\n        result = app.acquire_token_on_behalf_of(self._assertion, list(scopes), claims_challenge=kwargs.get(\"claims\"))\n        if \"access_token\" not in result or \"expires_in\" not in result:\n            message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n            response = self._client.get_error_response(result)\n",
                    "rendered": {
                      "text": "    def _request_token(self, *scopes: str, **kwargs: Any) -> AccessTokenInfo:\n        app: msal.ConfidentialClientApplication = self._get_app(**kwargs)\n        request_time = int(time.time())\n        result = app.acquire_token_on_behalf_of(self._assertion, list(scopes), claims_challenge=kwargs.get(\"claims\"))\n        if \"access_token\" not in result or \"expires_in\" not in result:\n            message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n            response = self._client.get_error_response(result)\n",
                      "markdown": "`    def _request_token(self, *scopes: str, **kwargs: Any) -> AccessTokenInfo:\n        app: msal.ConfidentialClientApplication = self._get_app(**kwargs)\n        request_time = int(time.time())\n        result = app.acquire_token_on_behalf_of(self._assertion, list(scopes), claims_challenge=kwargs.get(\"claims\"))\n        if \"access_token\" not in result or \"expires_in\" not in result:\n            message = \"Authentication failed: {}\".format(result.get(\"error_description\") or result.get(\"error\"))\n            response = self._client.get_error_response(result)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 141,
                  "startColumn": 41,
                  "endLine": 141,
                  "endColumn": 46,
                  "snippet": {
                    "text": "                    return AccessTokenInfo(\n                        result[\"access_token\"],\n                        now + int(result[\"expires_in\"]),\n                        token_type=result.get(\"token_type\", \"Bearer\"),\n                        refresh_on=refresh_on,\n                    )\n\n",
                    "rendered": {
                      "text": "                    return AccessTokenInfo(\n                        result[\"access_token\"],\n                        now + int(result[\"expires_in\"]),\n                        token_type=result.get(\"token_type\", \"Bearer\"),\n                        refresh_on=refresh_on,\n                    )\n\n",
                      "markdown": "`                    return AccessTokenInfo(\n                        result[\"access_token\"],\n                        now + int(result[\"expires_in\"]),\n                        token_type=result.get(\"token_type\", \"Bearer\"),\n                        refresh_on=refresh_on,\n                    )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 131,
                  "startColumn": 26,
                  "endLine": 131,
                  "endColumn": 31,
                  "snippet": {
                    "text": "            claims = kwargs.get(\"claims\")\n            app = self._get_app(**kwargs)\n            for account in app.get_accounts(username=self._auth_record.username):\n                if account.get(\"home_account_id\") != self._auth_record.home_account_id:\n                    continue\n\n                now = int(time.time())\n",
                    "rendered": {
                      "text": "            claims = kwargs.get(\"claims\")\n            app = self._get_app(**kwargs)\n            for account in app.get_accounts(username=self._auth_record.username):\n                if account.get(\"home_account_id\") != self._auth_record.home_account_id:\n                    continue\n\n                now = int(time.time())\n",
                      "markdown": "`            claims = kwargs.get(\"claims\")\n            app = self._get_app(**kwargs)\n            for account in app.get_accounts(username=self._auth_record.username):\n                if account.get(\"home_account_id\") != self._auth_record.home_account_id:\n                    continue\n\n                now = int(time.time())\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 27,
                  "endLine": 128,
                  "endColumn": 32,
                  "snippet": {
                    "text": "    @wrap_exceptions\n    def _acquire_token_silently(self, *scopes: str, **kwargs: Any) -> Optional[AccessTokenInfo]:\n        if self._auth_record:\n            claims = kwargs.get(\"claims\")\n            app = self._get_app(**kwargs)\n            for account in app.get_accounts(username=self._auth_record.username):\n                if account.get(\"home_account_id\") != self._auth_record.home_account_id:\n",
                    "rendered": {
                      "text": "    @wrap_exceptions\n    def _acquire_token_silently(self, *scopes: str, **kwargs: Any) -> Optional[AccessTokenInfo]:\n        if self._auth_record:\n            claims = kwargs.get(\"claims\")\n            app = self._get_app(**kwargs)\n            for account in app.get_accounts(username=self._auth_record.username):\n                if account.get(\"home_account_id\") != self._auth_record.home_account_id:\n",
                      "markdown": "`    @wrap_exceptions\n    def _acquire_token_silently(self, *scopes: str, **kwargs: Any) -> Optional[AccessTokenInfo]:\n        if self._auth_record:\n            claims = kwargs.get(\"claims\")\n            app = self._get_app(**kwargs)\n            for account in app.get_accounts(username=self._auth_record.username):\n                if account.get(\"home_account_id\") != self._auth_record.home_account_id:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 29,
                  "endLine": 107,
                  "endColumn": 37,
                  "snippet": {
                    "text": "            try:\n                credential = get_client_credential(\n                    certificate_path=None,\n                    password=password,\n                    certificate_data=client_certificate,\n                    send_certificate_chain=send_certificate_chain,\n                )\n",
                    "rendered": {
                      "text": "            try:\n                credential = get_client_credential(\n                    certificate_path=None,\n                    password=password,\n                    certificate_data=client_certificate,\n                    send_certificate_chain=send_certificate_chain,\n                )\n",
                      "markdown": "`            try:\n                credential = get_client_credential(\n                    certificate_path=None,\n                    password=password,\n                    certificate_data=client_certificate,\n                    send_certificate_chain=send_certificate_chain,\n                )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 20,
                  "endLine": 107,
                  "endColumn": 28,
                  "snippet": {
                    "text": "            try:\n                credential = get_client_credential(\n                    certificate_path=None,\n                    password=password,\n                    certificate_data=client_certificate,\n                    send_certificate_chain=send_certificate_chain,\n                )\n",
                    "rendered": {
                      "text": "            try:\n                credential = get_client_credential(\n                    certificate_path=None,\n                    password=password,\n                    certificate_data=client_certificate,\n                    send_certificate_chain=send_certificate_chain,\n                )\n",
                      "markdown": "`            try:\n                credential = get_client_credential(\n                    certificate_path=None,\n                    password=password,\n                    certificate_data=client_certificate,\n                    send_certificate_chain=send_certificate_chain,\n                )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 8,
                  "endLine": 84,
                  "endColumn": 16,
                  "snippet": {
                    "text": "        client_secret: Optional[str] = None,\n        client_assertion_func: Optional[Callable[[], str]] = None,\n        user_assertion: str,\n        password: Optional[Union[bytes, str]] = None,\n        send_certificate_chain: bool = False,\n        **kwargs: Any\n    ) -> None:\n",
                    "rendered": {
                      "text": "        client_secret: Optional[str] = None,\n        client_assertion_func: Optional[Callable[[], str]] = None,\n        user_assertion: str,\n        password: Optional[Union[bytes, str]] = None,\n        send_certificate_chain: bool = False,\n        **kwargs: Any\n    ) -> None:\n",
                      "markdown": "`        client_secret: Optional[str] = None,\n        client_assertion_func: Optional[Callable[[], str]] = None,\n        user_assertion: str,\n        password: Optional[Union[bytes, str]] = None,\n        send_certificate_chain: bool = False,\n        **kwargs: Any\n    ) -> None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 15,
                  "endLine": 50,
                  "endColumn": 23,
                  "snippet": {
                    "text": "    :keyword password: A certificate password. Used only when **client_certificate** is provided. If this value\n        is a unicode string, it will be encoded as UTF-8. If the certificate requires a different encoding, pass\n        appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword bool send_certificate_chain: If True when **client_certificate** is provided, the credential will send\n        the public certificate chain in the x5c header of each token request's JWT. This is required for Subject\n        Name/Issuer (SNI) authentication. Defaults to False.\n",
                    "rendered": {
                      "text": "    :keyword password: A certificate password. Used only when **client_certificate** is provided. If this value\n        is a unicode string, it will be encoded as UTF-8. If the certificate requires a different encoding, pass\n        appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword bool send_certificate_chain: If True when **client_certificate** is provided, the credential will send\n        the public certificate chain in the x5c header of each token request's JWT. This is required for Subject\n        Name/Issuer (SNI) authentication. Defaults to False.\n",
                      "markdown": "`    :keyword password: A certificate password. Used only when **client_certificate** is provided. If this value\n        is a unicode string, it will be encoded as UTF-8. If the certificate requires a different encoding, pass\n        appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword bool send_certificate_chain: If True when **client_certificate** is provided, the credential will send\n        the public certificate chain in the x5c header of each token request's JWT. This is required for Subject\n        Name/Issuer (SNI) authentication. Defaults to False.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 47,
                  "startColumn": 37,
                  "endLine": 47,
                  "endColumn": 45,
                  "snippet": {
                    "text": "    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n        defines authorities for other clouds.\n    :keyword password: A certificate password. Used only when **client_certificate** is provided. If this value\n        is a unicode string, it will be encoded as UTF-8. If the certificate requires a different encoding, pass\n        appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n",
                    "rendered": {
                      "text": "    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n        defines authorities for other clouds.\n    :keyword password: A certificate password. Used only when **client_certificate** is provided. If this value\n        is a unicode string, it will be encoded as UTF-8. If the certificate requires a different encoding, pass\n        appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n",
                      "markdown": "`    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n        defines authorities for other clouds.\n    :keyword password: A certificate password. Used only when **client_certificate** is provided. If this value\n        is a unicode string, it will be encoded as UTF-8. If the certificate requires a different encoding, pass\n        appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 47,
                  "startColumn": 13,
                  "endLine": 47,
                  "endColumn": 21,
                  "snippet": {
                    "text": "    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n        defines authorities for other clouds.\n    :keyword password: A certificate password. Used only when **client_certificate** is provided. If this value\n        is a unicode string, it will be encoded as UTF-8. If the certificate requires a different encoding, pass\n        appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n",
                    "rendered": {
                      "text": "    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n        defines authorities for other clouds.\n    :keyword password: A certificate password. Used only when **client_certificate** is provided. If this value\n        is a unicode string, it will be encoded as UTF-8. If the certificate requires a different encoding, pass\n        appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n",
                      "markdown": "`    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n        defines authorities for other clouds.\n    :keyword password: A certificate password. Used only when **client_certificate** is provided. If this value\n        is a unicode string, it will be encoded as UTF-8. If the certificate requires a different encoding, pass\n        appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 160,
                  "startColumn": 65,
                  "endLine": 160,
                  "endColumn": 71,
                  "snippet": {
                    "text": "        try:\n            self._auth_record = _build_auth_record(result)\n        except ClientAuthenticationError:\n            pass  # non-fatal; we'll use the assertion again next time instead of a refresh token\n\n        refresh_on = int(result[\"refresh_on\"]) if \"refresh_on\" in result else None\n        return AccessTokenInfo(\n",
                    "rendered": {
                      "text": "        try:\n            self._auth_record = _build_auth_record(result)\n        except ClientAuthenticationError:\n            pass  # non-fatal; we'll use the assertion again next time instead of a refresh token\n\n        refresh_on = int(result[\"refresh_on\"]) if \"refresh_on\" in result else None\n        return AccessTokenInfo(\n",
                      "markdown": "`        try:\n            self._auth_record = _build_auth_record(result)\n        except ClientAuthenticationError:\n            pass  # non-fatal; we'll use the assertion again next time instead of a refresh token\n\n        refresh_on = int(result[\"refresh_on\"]) if \"refresh_on\" in result else None\n        return AccessTokenInfo(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 71,
                  "endLine": 38,
                  "endColumn": 77,
                  "snippet": {
                    "text": "vice principal. One of **client_secret**, **client_certificate**,\n        or **client_assertion_func** must be provided.\n    :keyword client_assertion_func: Optional. Function that returns client assertions that authenticate the\n        application to Microsoft Entra ID. This function is called each time the credential requests a token. It must\n        return a valid assertion for the target resource.\n    :paramtype client_assertion_func: Callable[[], str]\n    :keyword str user_assertion: Required. The access token the credential will use as the user assertion when\n        requesting on-behalf-of to",
                    "rendered": {
                      "text": "vice principal. One of **client_secret**, **client_certificate**,\n        or **client_assertion_func** must be provided.\n    :keyword client_assertion_func: Optional. Function that returns client assertions that authenticate the\n        application to Microsoft Entra ID. This function is called each time the credential requests a token. It must\n        return a valid assertion for the target resource.\n    :paramtype client_assertion_func: Callable[[], str]\n    :keyword str user_assertion: Required. The access token the credential will use as the user assertion when\n        requesting on-behalf-of to",
                      "markdown": "`vice principal. One of **client_secret**, **client_certificate**,\n        or **client_assertion_func** must be provided.\n    :keyword client_assertion_func: Optional. Function that returns client assertions that authenticate the\n        application to Microsoft Entra ID. This function is called each time the credential requests a token. It must\n        return a valid assertion for the target resource.\n    :paramtype client_assertion_func: Callable[[], str]\n    :keyword str user_assertion: Required. The access token the credential will use as the user assertion when\n        requesting on-behalf-of to`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 43,
                  "endLine": 35,
                  "endColumn": 52,
                  "snippet": {
                    "text": "et to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n    :keyword bytes client_certificate: Optional. The bytes of a certificate in PEM or PKCS12 format including\n        the private key to authenticate the service principal. One of **client_secret**, **client_certificate**,\n        or **client_assertion_func** must be provided.\n    :keyword client_assertion_func: Optional. Function that returns client assertions that authenticate the\n        application to Microsoft Entra ID. This function is called each time",
                    "rendered": {
                      "text": "et to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n    :keyword bytes client_certificate: Optional. The bytes of a certificate in PEM or PKCS12 format including\n        the private key to authenticate the service principal. One of **client_secret**, **client_certificate**,\n        or **client_assertion_func** must be provided.\n    :keyword client_assertion_func: Optional. Function that returns client assertions that authenticate the\n        application to Microsoft Entra ID. This function is called each time",
                      "markdown": "`et to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n    :keyword bytes client_certificate: Optional. The bytes of a certificate in PEM or PKCS12 format including\n        the private key to authenticate the service principal. One of **client_secret**, **client_certificate**,\n        or **client_assertion_func** must be provided.\n    :keyword client_assertion_func: Optional. Function that returns client assertions that authenticate the\n        application to Microsoft Entra ID. This function is called each time`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 77,
                  "endLine": 32,
                  "endColumn": 86,
                  "snippet": {
                    "text": "\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID.\n    :keyword str client_secret: Optional. A client secret to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n    :keyword bytes client_certificate: Optional. The bytes of a certificate in PEM or PKCS12 format including\n        the private key to authenticate the service principal. One of **client_secret**, **client_certificate**,\n",
                    "rendered": {
                      "text": "\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID.\n    :keyword str client_secret: Optional. A client secret to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n    :keyword bytes client_certificate: Optional. The bytes of a certificate in PEM or PKCS12 format including\n        the private key to authenticate the service principal. One of **client_secret**, **client_certificate**,\n",
                      "markdown": "`\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID.\n    :keyword str client_secret: Optional. A client secret to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n    :keyword bytes client_certificate: Optional. The bytes of a certificate in PEM or PKCS12 format including\n        the private key to authenticate the service principal. One of **client_secret**, **client_certificate**,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 29,
                  "endLine": 31,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    description of the on-behalf-of flow.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID.\n    :keyword str client_secret: Optional. A client secret to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n    :keyword bytes client_certificate: Optional. The bytes of a certificate in PEM or PKCS12 format including\n",
                    "rendered": {
                      "text": "    description of the on-behalf-of flow.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID.\n    :keyword str client_secret: Optional. A client secret to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n    :keyword bytes client_certificate: Optional. The bytes of a certificate in PEM or PKCS12 format including\n",
                      "markdown": "`    description of the on-behalf-of flow.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID.\n    :keyword str client_secret: Optional. A client secret to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n    :keyword bytes client_certificate: Optional. The bytes of a certificate in PEM or PKCS12 format including\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 30,
                  "startColumn": 35,
                  "endLine": 30,
                  "endColumn": 44,
                  "snippet": {
                    "text": "    <https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow>`__ for a more detailed\n    description of the on-behalf-of flow.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID.\n    :keyword str client_secret: Optional. A client secret to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n",
                    "rendered": {
                      "text": "    <https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow>`__ for a more detailed\n    description of the on-behalf-of flow.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID.\n    :keyword str client_secret: Optional. A client secret to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n",
                      "markdown": "`    <https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow>`__ for a more detailed\n    description of the on-behalf-of flow.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID.\n    :keyword str client_secret: Optional. A client secret to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 22,
                  "endLine": 22,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n\nclass OnBehalfOfCredential(MsalCredential, GetTokenMixin):\n    \"\"\"Authenticates a service principal via the on-behalf-of flow.\n\n    This flow is typically used by middle-tier services that authorize requests to other services with a delegated\n    user identity. Because this is not an interactive authentication flow, an application using it must have admin\n",
                    "rendered": {
                      "text": "\n\nclass OnBehalfOfCredential(MsalCredential, GetTokenMixin):\n    \"\"\"Authenticates a service principal via the on-behalf-of flow.\n\n    This flow is typically used by middle-tier services that authorize requests to other services with a delegated\n    user identity. Because this is not an interactive authentication flow, an application using it must have admin\n",
                      "markdown": "`\n\nclass OnBehalfOfCredential(MsalCredential, GetTokenMixin):\n    \"\"\"Authenticates a service principal via the on-behalf-of flow.\n\n    This flow is typically used by middle-tier services that authorize requests to other services with a delegated\n    user identity. Because this is not an interactive authentication flow, an application using it must have admin\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 6,
                  "endLine": 6,
                  "snippet": {
                    "text": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport time\nfrom typing import Any, Optional, Callable, Union, Dict\n\nimport msal\n\n",
                    "rendered": {
                      "text": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport time\nfrom typing import Any, Optional, Callable, Union, Dict\n\nimport msal\n\n",
                      "markdown": "`# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport time\nfrom typing import Any, Optional, Callable, Union, Dict\n\nimport msal\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/application.py"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 52,
                  "endLine": 59,
                  "endColumn": 57,
                  "snippet": {
                    "text": "        authority = kwargs.pop(\"authority\", None)\n        authority = normalize_authority(authority) if authority else get_default_authority()\n        managed_identity_client_id = kwargs.pop(\n            \"managed_identity_client_id\", os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        )\n        super(AzureApplicationCredential, self).__init__(\n            EnvironmentCredential(authority=authority, **kwargs),\n",
                    "rendered": {
                      "text": "        authority = kwargs.pop(\"authority\", None)\n        authority = normalize_authority(authority) if authority else get_default_authority()\n        managed_identity_client_id = kwargs.pop(\n            \"managed_identity_client_id\", os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        )\n        super(AzureApplicationCredential, self).__init__(\n            EnvironmentCredential(authority=authority, **kwargs),\n",
                      "markdown": "`        authority = kwargs.pop(\"authority\", None)\n        authority = normalize_authority(authority) if authority else get_default_authority()\n        managed_identity_client_id = kwargs.pop(\n            \"managed_identity_client_id\", os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        )\n        super(AzureApplicationCredential, self).__init__(\n            EnvironmentCredential(authority=authority, **kwargs),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/application.py"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 34,
                  "endLine": 37,
                  "endColumn": 42,
                  "snippet": {
                    "text": "        **or**\n\n        - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM-encoded certificate file including the private key. The\n          certificate must not be password-protected.\n\n    See `Azure CLI documentation <https://learn.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli>`_\n    for more information about creating and managing service principals.\n",
                    "rendered": {
                      "text": "        **or**\n\n        - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM-encoded certificate file including the private key. The\n          certificate must not be password-protected.\n\n    See `Azure CLI documentation <https://learn.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli>`_\n    for more information about creating and managing service principals.\n",
                      "markdown": "`        **or**\n\n        - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM-encoded certificate file including the private key. The\n          certificate must not be password-protected.\n\n    See `Azure CLI documentation <https://learn.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli>`_\n    for more information about creating and managing service principals.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/application.py"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 45,
                  "endLine": 59,
                  "endColumn": 56,
                  "snippet": {
                    "text": "        authority = kwargs.pop(\"authority\", None)\n        authority = normalize_authority(authority) if authority else get_default_authority()\n        managed_identity_client_id = kwargs.pop(\n            \"managed_identity_client_id\", os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        )\n        super(AzureApplicationCredential, self).__init__(\n            EnvironmentCredential(authority=authority, **kwargs),\n",
                    "rendered": {
                      "text": "        authority = kwargs.pop(\"authority\", None)\n        authority = normalize_authority(authority) if authority else get_default_authority()\n        managed_identity_client_id = kwargs.pop(\n            \"managed_identity_client_id\", os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        )\n        super(AzureApplicationCredential, self).__init__(\n            EnvironmentCredential(authority=authority, **kwargs),\n",
                      "markdown": "`        authority = kwargs.pop(\"authority\", None)\n        authority = normalize_authority(authority) if authority else get_default_authority()\n        managed_identity_client_id = kwargs.pop(\n            \"managed_identity_client_id\", os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        )\n        super(AzureApplicationCredential, self).__init__(\n            EnvironmentCredential(authority=authority, **kwargs),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/application.py"
                },
                "region": {
                  "startLine": 42,
                  "startColumn": 14,
                  "endLine": 42,
                  "endColumn": 46,
                  "snippet": {
                    "text": "    See `Azure CLI documentation <https://learn.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli>`_\n    for more information about creating and managing service principals.\n\n    When this environment configuration is incomplete, the credential will attempt to authenticate a managed identity.\n    See `Microsoft Entra ID documentation\n    <https://learn.microsoft.com/entra/identity/managed-identities-azure-resources/overview>`__ for an overview\n    of managed identities.\n",
                    "rendered": {
                      "text": "    See `Azure CLI documentation <https://learn.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli>`_\n    for more information about creating and managing service principals.\n\n    When this environment configuration is incomplete, the credential will attempt to authenticate a managed identity.\n    See `Microsoft Entra ID documentation\n    <https://learn.microsoft.com/entra/identity/managed-identities-azure-resources/overview>`__ for an overview\n    of managed identities.\n",
                      "markdown": "`    See `Azure CLI documentation <https://learn.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli>`_\n    for more information about creating and managing service principals.\n\n    When this environment configuration is incomplete, the credential will attempt to authenticate a managed identity.\n    See `Microsoft Entra ID documentation\n    <https://learn.microsoft.com/entra/identity/managed-identities-azure-resources/overview>`__ for an overview\n    of managed identities.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/application.py"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 52,
                  "endLine": 25,
                  "endColumn": 93,
                  "snippet": {
                    "text": "    This credential is designed for applications deployed to Azure (:class:`~azure.identity.DefaultAzureCredential` is\n    better suited to local development). It authenticates service principals and managed identities.\n\n    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n",
                    "rendered": {
                      "text": "    This credential is designed for applications deployed to Azure (:class:`~azure.identity.DefaultAzureCredential` is\n    better suited to local development). It authenticates service principals and managed identities.\n\n    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n",
                      "markdown": "`    This credential is designed for applications deployed to Azure (:class:`~azure.identity.DefaultAzureCredential` is\n    better suited to local development). It authenticates service principals and managed identities.\n\n    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/application.py"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 84,
                  "endLine": 102,
                  "endColumn": 88,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/application.py"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 84,
                  "endLine": 73,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/application.py"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 61,
                  "endLine": 50,
                  "endColumn": 70,
                  "snippet": {
                    "text": "        the authority for Azure Public Cloud, which is the default when no value is given for this keyword argument or\n        environment variable AZURE_AUTHORITY_HOST. :class:`~azure.identity.AzureAuthorityHosts` defines authorities for\n        other clouds. Authority configuration applies only to service principal authentication.\n    :keyword str managed_identity_client_id: The client ID of a user-assigned managed identity. Defaults to the value\n        of the environment variable AZURE_CLIENT_ID, if any. If not specified, a system-assigned identity will be used.\n    \"\"\"\n\n    def __init__(self, **kw",
                    "rendered": {
                      "text": "        the authority for Azure Public Cloud, which is the default when no value is given for this keyword argument or\n        environment variable AZURE_AUTHORITY_HOST. :class:`~azure.identity.AzureAuthorityHosts` defines authorities for\n        other clouds. Authority configuration applies only to service principal authentication.\n    :keyword str managed_identity_client_id: The client ID of a user-assigned managed identity. Defaults to the value\n        of the environment variable AZURE_CLIENT_ID, if any. If not specified, a system-assigned identity will be used.\n    \"\"\"\n\n    def __init__(self, **kw",
                      "markdown": "`        the authority for Azure Public Cloud, which is the default when no value is given for this keyword argument or\n        environment variable AZURE_AUTHORITY_HOST. :class:`~azure.identity.AzureAuthorityHosts` defines authorities for\n        other clouds. Authority configuration applies only to service principal authentication.\n    :keyword str managed_identity_client_id: The client ID of a user-assigned managed identity. Defaults to the value\n        of the environment variable AZURE_CLIENT_ID, if any. If not specified, a system-assigned identity will be used.\n    \"\"\"\n\n    def __init__(self, **kw`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/application.py"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 52,
                  "endLine": 40,
                  "endColumn": 61,
                  "snippet": {
                    "text": "          certificate must not be password-protected.\n\n    See `Azure CLI documentation <https://learn.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli>`_\n    for more information about creating and managing service principals.\n\n    When this environment configuration is incomplete, the credential will attempt to authenticate a managed identity.\n    See `Microsoft Entra ID documentation\n",
                    "rendered": {
                      "text": "          certificate must not be password-protected.\n\n    See `Azure CLI documentation <https://learn.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli>`_\n    for more information about creating and managing service principals.\n\n    When this environment configuration is incomplete, the credential will attempt to authenticate a managed identity.\n    See `Microsoft Entra ID documentation\n",
                      "markdown": "`          certificate must not be password-protected.\n\n    See `Azure CLI documentation <https://learn.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli>`_\n    for more information about creating and managing service principals.\n\n    When this environment configuration is incomplete, the credential will attempt to authenticate a managed identity.\n    See `Microsoft Entra ID documentation\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/application.py"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 45,
                  "endLine": 32,
                  "endColumn": 54,
                  "snippet": {
                    "text": "\n    And one of these to authenticate that principal:\n\n        - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n\n        **or**\n\n",
                    "rendered": {
                      "text": "\n    And one of these to authenticate that principal:\n\n        - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n\n        **or**\n\n",
                      "markdown": "`\n    And one of these to authenticate that principal:\n\n        - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n\n        **or**\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/application.py"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 34,
                  "endLine": 28,
                  "endColumn": 43,
                  "snippet": {
                    "text": "    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n\n    And one of these to authenticate that principal:\n\n",
                    "rendered": {
                      "text": "    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n\n    And one of these to authenticate that principal:\n\n",
                      "markdown": "`    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n\n    And one of these to authenticate that principal:\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/application.py"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 40,
                  "endLine": 27,
                  "endColumn": 49,
                  "snippet": {
                    "text": "\n    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n\n    And one of these to authenticate that principal:\n",
                    "rendered": {
                      "text": "\n    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n\n    And one of these to authenticate that principal:\n",
                      "markdown": "`\n    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n\n    And one of these to authenticate that principal:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/application.py"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 7,
                  "endLine": 25,
                  "endColumn": 16,
                  "snippet": {
                    "text": "    This credential is designed for applications deployed to Azure (:class:`~azure.identity.DefaultAzureCredential` is\n    better suited to local development). It authenticates service principals and managed identities.\n\n    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n",
                    "rendered": {
                      "text": "    This credential is designed for applications deployed to Azure (:class:`~azure.identity.DefaultAzureCredential` is\n    better suited to local development). It authenticates service principals and managed identities.\n\n    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n",
                      "markdown": "`    This credential is designed for applications deployed to Azure (:class:`~azure.identity.DefaultAzureCredential` is\n    better suited to local development). It authenticates service principals and managed identities.\n\n    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/application.py"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 57,
                  "endLine": 23,
                  "endColumn": 66,
                  "snippet": {
                    "text": "    \"\"\"A credential for Microsoft Entra applications.\n\n    This credential is designed for applications deployed to Azure (:class:`~azure.identity.DefaultAzureCredential` is\n    better suited to local development). It authenticates service principals and managed identities.\n\n    For service principal authentication, set these environment variables to identify a principal:\n\n",
                    "rendered": {
                      "text": "    \"\"\"A credential for Microsoft Entra applications.\n\n    This credential is designed for applications deployed to Azure (:class:`~azure.identity.DefaultAzureCredential` is\n    better suited to local development). It authenticates service principals and managed identities.\n\n    For service principal authentication, set these environment variables to identify a principal:\n\n",
                      "markdown": "`    \"\"\"A credential for Microsoft Entra applications.\n\n    This credential is designed for applications deployed to Azure (:class:`~azure.identity.DefaultAzureCredential` is\n    better suited to local development). It authenticates service principals and managed identities.\n\n    For service principal authentication, set these environment variables to identify a principal:\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/app_service.py"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 23,
                  "endLine": 23,
                  "endColumn": 28,
                  "snippet": {
                    "text": "    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    if not (url and secret):\n        # App Service managed identity isn't available in this environment\n        return None\n",
                    "rendered": {
                      "text": "    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    if not (url and secret):\n        # App Service managed identity isn't available in this environment\n        return None\n",
                      "markdown": "`    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    if not (url and secret):\n        # App Service managed identity isn't available in this environment\n        return None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/app_service.py"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 20,
                  "endLine": 22,
                  "endColumn": 25,
                  "snippet": {
                    "text": "def _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    if not (url and secret):\n        # App Service managed identity isn't available in this environment\n",
                    "rendered": {
                      "text": "def _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    if not (url and secret):\n        # App Service managed identity isn't available in this environment\n",
                      "markdown": "`def _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    if not (url and secret):\n        # App Service managed identity isn't available in this environment\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/app_service.py"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 16,
                  "endLine": 23,
                  "endColumn": 27,
                  "snippet": {
                    "text": "    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    if not (url and secret):\n        # App Service managed identity isn't available in this environment\n        return None\n",
                    "rendered": {
                      "text": "    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    if not (url and secret):\n        # App Service managed identity isn't available in this environment\n        return None\n",
                      "markdown": "`    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    if not (url and secret):\n        # App Service managed identity isn't available in this environment\n        return None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/app_service.py"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 13,
                  "endLine": 22,
                  "endColumn": 24,
                  "snippet": {
                    "text": "def _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    if not (url and secret):\n        # App Service managed identity isn't available in this environment\n",
                    "rendered": {
                      "text": "def _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    if not (url and secret):\n        # App Service managed identity isn't available in this environment\n",
                      "markdown": "`def _get_client_args(**kwargs: Any) -> Optional[Dict]:\n    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    if not (url and secret):\n        # App Service managed identity isn't available in this environment\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/app_service.py"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 13,
                  "endLine": 25,
                  "endColumn": 22,
                  "snippet": {
                    "text": "    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    if not (url and secret):\n        # App Service managed identity isn't available in this environment\n        return None\n\n    return dict(\n",
                    "rendered": {
                      "text": "    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    if not (url and secret):\n        # App Service managed identity isn't available in this environment\n        return None\n\n    return dict(\n",
                      "markdown": "`    url = os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.IDENTITY_HEADER)\n    if not (url and secret):\n        # App Service managed identity isn't available in this environment\n        return None\n\n    return dict(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/app_service.py"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 20,
                  "endLine": 16,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\nclass AppServiceCredential(MsalManagedIdentityClient):\n    def get_unavailable_message(self, desc: str = \"\") -> str:\n        return f\"App Service managed identity configuration not found in environment. {desc}\"\n\n\ndef _get_client_args(**kwargs: Any) -> Optional[Dict]:\n",
                    "rendered": {
                      "text": "\nclass AppServiceCredential(MsalManagedIdentityClient):\n    def get_unavailable_message(self, desc: str = \"\") -> str:\n        return f\"App Service managed identity configuration not found in environment. {desc}\"\n\n\ndef _get_client_args(**kwargs: Any) -> Optional[Dict]:\n",
                      "markdown": "`\nclass AppServiceCredential(MsalManagedIdentityClient):\n    def get_unavailable_message(self, desc: str = \"\") -> str:\n        return f\"App Service managed identity configuration not found in environment. {desc}\"\n\n\ndef _get_client_args(**kwargs: Any) -> Optional[Dict]:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/SOURCES.txt"
                },
                "region": {
                  "startLine": 184,
                  "startColumn": 20,
                  "endLine": 184,
                  "endColumn": 28,
                  "snippet": {
                    "text": "tests/test_powershell_credential_async.py\ntests/test_shared_cache_credential.py\ntests/test_shared_cache_credential_async.py\ntests/test_username_password_credential.py\ntests/test_vscode_credential.py\ntests/test_vscode_credential_async.py\ntests/test_workload_identity_credential.py\n",
                    "rendered": {
                      "text": "tests/test_powershell_credential_async.py\ntests/test_shared_cache_credential.py\ntests/test_shared_cache_credential_async.py\ntests/test_username_password_credential.py\ntests/test_vscode_credential.py\ntests/test_vscode_credential_async.py\ntests/test_workload_identity_credential.py\n",
                      "markdown": "`tests/test_powershell_credential_async.py\ntests/test_shared_cache_credential.py\ntests/test_shared_cache_credential_async.py\ntests/test_username_password_credential.py\ntests/test_vscode_credential.py\ntests/test_vscode_credential_async.py\ntests/test_workload_identity_credential.py\n`"
                    }
                  },
                  "sourceLanguage": "plaintext"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/SOURCES.txt"
                },
                "region": {
                  "startLine": 47,
                  "startColumn": 33,
                  "endLine": 47,
                  "endColumn": 41,
                  "snippet": {
                    "text": "azure/identity/_credentials/service_fabric.py\nazure/identity/_credentials/shared_cache.py\nazure/identity/_credentials/silent.py\nazure/identity/_credentials/user_password.py\nazure/identity/_credentials/vscode.py\nazure/identity/_credentials/workload_identity.py\nazure/identity/_internal/__init__.py\n",
                    "rendered": {
                      "text": "azure/identity/_credentials/service_fabric.py\nazure/identity/_credentials/shared_cache.py\nazure/identity/_credentials/silent.py\nazure/identity/_credentials/user_password.py\nazure/identity/_credentials/vscode.py\nazure/identity/_credentials/workload_identity.py\nazure/identity/_internal/__init__.py\n",
                      "markdown": "`azure/identity/_credentials/service_fabric.py\nazure/identity/_credentials/shared_cache.py\nazure/identity/_credentials/silent.py\nazure/identity/_credentials/user_password.py\nazure/identity/_credentials/vscode.py\nazure/identity/_credentials/workload_identity.py\nazure/identity/_internal/__init__.py\n`"
                    }
                  },
                  "sourceLanguage": "plaintext"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure_identity-1.19.0-py3.12.egg-info/SOURCES.txt"
                },
                "region": {
                  "startLine": 157,
                  "startColumn": 11,
                  "endLine": 157,
                  "endColumn": 39,
                  "snippet": {
                    "text": "tests/test_default_async.py\ntests/test_device_code_credential.py\ntests/test_environment_credential.py\ntests/test_environment_credential_async.py\ntests/test_get_token_mixin.py\ntests/test_get_token_mixin_async.py\ntests/test_imds_credential.py\n",
                    "rendered": {
                      "text": "tests/test_default_async.py\ntests/test_device_code_credential.py\ntests/test_environment_credential.py\ntests/test_environment_credential_async.py\ntests/test_get_token_mixin.py\ntests/test_get_token_mixin_async.py\ntests/test_imds_credential.py\n",
                      "markdown": "`tests/test_default_async.py\ntests/test_device_code_credential.py\ntests/test_environment_credential.py\ntests/test_environment_credential_async.py\ntests/test_get_token_mixin.py\ntests/test_get_token_mixin_async.py\ntests/test_imds_credential.py\n`"
                    }
                  },
                  "sourceLanguage": "plaintext"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 230,
                  "startColumn": 17,
                  "endLine": 230,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        raise CredentialUnavailableError(message=NOT_LOGGED_IN)\n\n    message = sanitize_output(stderr) if stderr else \"Failed to invoke Azure Developer CLI\"\n    if within_dac.get():\n        raise CredentialUnavailableError(message=message)\n    raise ClientAuthenticationError(message=message)\n",
                    "rendered": {
                      "text": "        raise CredentialUnavailableError(message=NOT_LOGGED_IN)\n\n    message = sanitize_output(stderr) if stderr else \"Failed to invoke Azure Developer CLI\"\n    if within_dac.get():\n        raise CredentialUnavailableError(message=message)\n    raise ClientAuthenticationError(message=message)\n",
                      "markdown": "`        raise CredentialUnavailableError(message=NOT_LOGGED_IN)\n\n    message = sanitize_output(stderr) if stderr else \"Failed to invoke Azure Developer CLI\"\n    if within_dac.get():\n        raise CredentialUnavailableError(message=message)\n    raise ClientAuthenticationError(message=message)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 177,
                  "startColumn": 25,
                  "endLine": 177,
                  "endColumn": 30,
                  "snippet": {
                    "text": "                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azdevclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n                raise CredentialUnavailableError(message=message)\n            raise ClientAuthenticationError(message=message)\n\n",
                    "rendered": {
                      "text": "                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azdevclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n                raise CredentialUnavailableError(message=message)\n            raise ClientAuthenticationError(message=message)\n\n",
                      "markdown": "`                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azdevclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n                raise CredentialUnavailableError(message=message)\n            raise ClientAuthenticationError(message=message)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 150,
                  "startColumn": 27,
                  "endLine": 150,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        if not scopes:\n            raise ValueError(\"Missing scope in request. \\n\")\n\n        tenant_id = options.get(\"tenant_id\") if options else None\n        if tenant_id:\n            validate_tenant_id(tenant_id)\n        for scope in scopes:\n",
                    "rendered": {
                      "text": "        if not scopes:\n            raise ValueError(\"Missing scope in request. \\n\")\n\n        tenant_id = options.get(\"tenant_id\") if options else None\n        if tenant_id:\n            validate_tenant_id(tenant_id)\n        for scope in scopes:\n",
                      "markdown": "`        if not scopes:\n            raise ValueError(\"Missing scope in request. \\n\")\n\n        tenant_id = options.get(\"tenant_id\") if options else None\n        if tenant_id:\n            validate_tenant_id(tenant_id)\n        for scope in scopes:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 174,
                  "startColumn": 93,
                  "endLine": 174,
                  "endColumn": 97,
                  "snippet": {
                    "text": "            sanitized_output = sanitize_output(output)\n            message = (\n                f\"Unexpected output from Azure Developer CLI: '{sanitized_output}'. \\n\"\n                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azdevclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n",
                    "rendered": {
                      "text": "            sanitized_output = sanitize_output(output)\n            message = (\n                f\"Unexpected output from Azure Developer CLI: '{sanitized_output}'. \\n\"\n                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azdevclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n",
                      "markdown": "`            sanitized_output = sanitize_output(output)\n            message = (\n                f\"Unexpected output from Azure Developer CLI: '{sanitized_output}'. \\n\"\n                f\"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n                f\"https://aka.ms/azsdk/python/identity/azdevclicredential/troubleshoot.\"\n            )\n            if within_dac.get():\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 126,
                  "startColumn": 84,
                  "endLine": 126,
                  "endColumn": 88,
                  "snippet": {
                    "text": "on the token. This method is called automatically by Azure SDK clients. Applications calling this method\n        directly must also handle token caching because this credential doesn't cache the tokens it acquires.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials",
                    "rendered": {
                      "text": "on the token. This method is called automatically by Azure SDK clients. Applications calling this method\n        directly must also handle token caching because this credential doesn't cache the tokens it acquires.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials",
                      "markdown": "`on the token. This method is called automatically by Azure SDK clients. Applications calling this method\n        directly must also handle token caching because this credential doesn't cache the tokens it acquires.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 55,
                  "endLine": 48,
                  "endColumn": 61,
                  "snippet": {
                    "text": "      * Run \"azd auth login --client-id 'client_id' --client-secret 'client_secret' --tenant-id 'tenant_id'\"\n        to authenticate as a service principal.\n\n    You may need to repeat this process after a certain time period, depending on the refresh token validity in your\n    organization. Generally, the refresh token validity period is a few weeks to a few months.\n    AzureDeveloperCliCredential will prompt you to sign in again.\n\n",
                    "rendered": {
                      "text": "      * Run \"azd auth login --client-id 'client_id' --client-secret 'client_secret' --tenant-id 'tenant_id'\"\n        to authenticate as a service principal.\n\n    You may need to repeat this process after a certain time period, depending on the refresh token validity in your\n    organization. Generally, the refresh token validity period is a few weeks to a few months.\n    AzureDeveloperCliCredential will prompt you to sign in again.\n\n",
                      "markdown": "`      * Run \"azd auth login --client-id 'client_id' --client-secret 'client_secret' --tenant-id 'tenant_id'\"\n        to authenticate as a service principal.\n\n    You may need to repeat this process after a certain time period, depending on the refresh token validity in your\n    organization. Generally, the refresh token validity period is a few weeks to a few months.\n    AzureDeveloperCliCredential will prompt you to sign in again.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 28,
                  "endLine": 46,
                  "endColumn": 37,
                  "snippet": {
                    "text": "\n      * Run \"azd auth login\" in Azure Developer CLI to authenticate interactively as a user.\n      * Run \"azd auth login --client-id 'client_id' --client-secret 'client_secret' --tenant-id 'tenant_id'\"\n        to authenticate as a service principal.\n\n    You may need to repeat this process after a certain time period, depending on the refresh token validity in your\n    organization. Generally, the refresh token validity period is a few weeks to a few months.\n",
                    "rendered": {
                      "text": "\n      * Run \"azd auth login\" in Azure Developer CLI to authenticate interactively as a user.\n      * Run \"azd auth login --client-id 'client_id' --client-secret 'client_secret' --tenant-id 'tenant_id'\"\n        to authenticate as a service principal.\n\n    You may need to repeat this process after a certain time period, depending on the refresh token validity in your\n    organization. Generally, the refresh token validity period is a few weeks to a few months.\n",
                      "markdown": "`\n      * Run \"azd auth login\" in Azure Developer CLI to authenticate interactively as a user.\n      * Run \"azd auth login --client-id 'client_id' --client-secret 'client_secret' --tenant-id 'tenant_id'\"\n        to authenticate as a service principal.\n\n    You may need to repeat this process after a certain time period, depending on the refresh token validity in your\n    organization. Generally, the refresh token validity period is a few weeks to a few months.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 6,
                  "endLine": 38,
                  "endColumn": 15,
                  "snippet": {
                    "text": "    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n    the logged-in user or service principal in Azure Developer CLI. It acts as the Azure Developer CLI logged-in user\n    or service principal and executes an Azure CLI command underneath to authenticate the application against\n    Microsoft Entra ID.\n\n    To use this credential, the developer needs to authenticate locally in Azure Developer CLI using one of the\n",
                    "rendered": {
                      "text": "    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n    the logged-in user or service principal in Azure Developer CLI. It acts as the Azure Developer CLI logged-in user\n    or service principal and executes an Azure CLI command underneath to authenticate the application against\n    Microsoft Entra ID.\n\n    To use this credential, the developer needs to authenticate locally in Azure Developer CLI using one of the\n",
                      "markdown": "`    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n    the logged-in user or service principal in Azure Developer CLI. It acts as the Azure Developer CLI logged-in user\n    or service principal and executes an Azure CLI command underneath to authenticate the application against\n    Microsoft Entra ID.\n\n    To use this credential, the developer needs to authenticate locally in Azure Developer CLI using one of the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 25,
                  "endLine": 37,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    to Azure developers. It allows users to authenticate as a user and/or a service principal against\n    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n    the logged-in user or service principal in Azure Developer CLI. It acts as the Azure Developer CLI logged-in user\n    or service principal and executes an Azure CLI command underneath to authenticate the application against\n    Microsoft Entra ID.\n\n",
                    "rendered": {
                      "text": "    to Azure developers. It allows users to authenticate as a user and/or a service principal against\n    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n    the logged-in user or service principal in Azure Developer CLI. It acts as the Azure Developer CLI logged-in user\n    or service principal and executes an Azure CLI command underneath to authenticate the application against\n    Microsoft Entra ID.\n\n",
                      "markdown": "`    to Azure developers. It allows users to authenticate as a user and/or a service principal against\n    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n    the logged-in user or service principal in Azure Developer CLI. It acts as the Azure Developer CLI logged-in user\n    or service principal and executes an Azure CLI command underneath to authenticate the application against\n    Microsoft Entra ID.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 75,
                  "endLine": 34,
                  "endColumn": 84,
                  "snippet": {
                    "text": "er CLI.\n\n    Azure Developer CLI is a command-line interface tool that allows developers to create, manage, and deploy\n    resources in Azure. It's built on top of the Azure CLI and provides additional functionality specific\n    to Azure developers. It allows users to authenticate as a user and/or a service principal against\n    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n    the logged-in user or service principal in Azure Developer CLI. It acts as the Azure ",
                    "rendered": {
                      "text": "er CLI.\n\n    Azure Developer CLI is a command-line interface tool that allows developers to create, manage, and deploy\n    resources in Azure. It's built on top of the Azure CLI and provides additional functionality specific\n    to Azure developers. It allows users to authenticate as a user and/or a service principal against\n    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n    the logged-in user or service principal in Azure Developer CLI. It acts as the Azure ",
                      "markdown": "`er CLI.\n\n    Azure Developer CLI is a command-line interface tool that allows developers to create, manage, and deploy\n    resources in Azure. It's built on top of the Azure CLI and provides additional functionality specific\n    to Azure developers. It allows users to authenticate as a user and/or a service principal against\n    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n    the logged-in user or service principal in Azure Developer CLI. It acts as the Azure `"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/azd_cli.py"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 37,
                  "endLine": 33,
                  "endColumn": 42,
                  "snippet": {
                    "text": "    \"\"\"Authenticates by requesting a token from the Azure Developer CLI.\n\n    Azure Developer CLI is a command-line interface tool that allows developers to create, manage, and deploy\n    resources in Azure. It's built on top of the Azure CLI and provides additional functionality specific\n    to Azure developers. It allows users to authenticate as a user and/or a service principal against\n    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n",
                    "rendered": {
                      "text": "    \"\"\"Authenticates by requesting a token from the Azure Developer CLI.\n\n    Azure Developer CLI is a command-line interface tool that allows developers to create, manage, and deploy\n    resources in Azure. It's built on top of the Azure CLI and provides additional functionality specific\n    to Azure developers. It allows users to authenticate as a user and/or a service principal against\n    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n",
                      "markdown": "`    \"\"\"Authenticates by requesting a token from the Azure Developer CLI.\n\n    Azure Developer CLI is a command-line interface tool that allows developers to create, manage, and deploy\n    resources in Azure. It's built on top of the Azure CLI and provides additional functionality specific\n    to Azure developers. It allows users to authenticate as a user and/or a service principal against\n    `Microsoft Entra ID <\"https://learn.microsoft.com/entra/fundamentals/\">`__.\n    The AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/authorization_code.py"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 84,
                  "endLine": 109,
                  "endColumn": 88,
                  "snippet": {
                    "text": "        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/authorization_code.py"
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 84,
                  "endLine": 82,
                  "endColumn": 88,
                  "snippet": {
                    "text": "        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/authorization_code.py"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 17,
                  "endLine": 105,
                  "endColumn": 23,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        The first time this method is called, the credential will redeem its authorization code. On subsequent calls\n        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        The first time this method is called, the credential will redeem its authorization code. On subsequent calls\n        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        The first time this method is called, the credential will redeem its authorization code. On subsequent calls\n        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/authorization_code.py"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 17,
                  "endLine": 78,
                  "endColumn": 23,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        The first time this method is called, the credential will redeem its authorization code. On subsequent calls\n        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        The first time this method is called, the credential will redeem its authorization code. On subsequent calls\n        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        The first time this method is called, the credential will redeem its authorization code. On subsequent calls\n        the credential will return a cached access token or redeem a refresh token, if it acquired a refresh token upon\n        redeeming the authorization code.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/application.py"
                },
                "region": {
                  "startLine": 60,
                  "startColumn": 77,
                  "endLine": 60,
                  "endColumn": 82,
                  "snippet": {
                    "text": "        self, *, authority: Optional[str] = None, managed_identity_client_id: Optional[str] = None, **kwargs: Any\n    ) -> None:\n        authority = normalize_authority(authority) if authority else get_default_authority()\n        managed_identity_client_id = managed_identity_client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        super().__init__(\n            EnvironmentCredential(authority=authority, **kwargs),\n            ManagedIdentityCredential(client_id=managed_identity_client_id, **kwargs),\n",
                    "rendered": {
                      "text": "        self, *, authority: Optional[str] = None, managed_identity_client_id: Optional[str] = None, **kwargs: Any\n    ) -> None:\n        authority = normalize_authority(authority) if authority else get_default_authority()\n        managed_identity_client_id = managed_identity_client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        super().__init__(\n            EnvironmentCredential(authority=authority, **kwargs),\n            ManagedIdentityCredential(client_id=managed_identity_client_id, **kwargs),\n",
                      "markdown": "`        self, *, authority: Optional[str] = None, managed_identity_client_id: Optional[str] = None, **kwargs: Any\n    ) -> None:\n        authority = normalize_authority(authority) if authority else get_default_authority()\n        managed_identity_client_id = managed_identity_client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        super().__init__(\n            EnvironmentCredential(authority=authority, **kwargs),\n            ManagedIdentityCredential(client_id=managed_identity_client_id, **kwargs),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/application.py"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 34,
                  "endLine": 38,
                  "endColumn": 42,
                  "snippet": {
                    "text": "        **or**\n\n        - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM-encoded certificate file including the private key. The\n          certificate must not be password-protected.\n\n    See `Azure CLI documentation <https://learn.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli>`_\n    for more information about creating and managing service principals.\n",
                    "rendered": {
                      "text": "        **or**\n\n        - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM-encoded certificate file including the private key. The\n          certificate must not be password-protected.\n\n    See `Azure CLI documentation <https://learn.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli>`_\n    for more information about creating and managing service principals.\n",
                      "markdown": "`        **or**\n\n        - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM-encoded certificate file including the private key. The\n          certificate must not be password-protected.\n\n    See `Azure CLI documentation <https://learn.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli>`_\n    for more information about creating and managing service principals.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/application.py"
                },
                "region": {
                  "startLine": 60,
                  "startColumn": 70,
                  "endLine": 60,
                  "endColumn": 81,
                  "snippet": {
                    "text": "        self, *, authority: Optional[str] = None, managed_identity_client_id: Optional[str] = None, **kwargs: Any\n    ) -> None:\n        authority = normalize_authority(authority) if authority else get_default_authority()\n        managed_identity_client_id = managed_identity_client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        super().__init__(\n            EnvironmentCredential(authority=authority, **kwargs),\n            ManagedIdentityCredential(client_id=managed_identity_client_id, **kwargs),\n",
                    "rendered": {
                      "text": "        self, *, authority: Optional[str] = None, managed_identity_client_id: Optional[str] = None, **kwargs: Any\n    ) -> None:\n        authority = normalize_authority(authority) if authority else get_default_authority()\n        managed_identity_client_id = managed_identity_client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        super().__init__(\n            EnvironmentCredential(authority=authority, **kwargs),\n            ManagedIdentityCredential(client_id=managed_identity_client_id, **kwargs),\n",
                      "markdown": "`        self, *, authority: Optional[str] = None, managed_identity_client_id: Optional[str] = None, **kwargs: Any\n    ) -> None:\n        authority = normalize_authority(authority) if authority else get_default_authority()\n        managed_identity_client_id = managed_identity_client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        super().__init__(\n            EnvironmentCredential(authority=authority, **kwargs),\n            ManagedIdentityCredential(client_id=managed_identity_client_id, **kwargs),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/application.py"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 14,
                  "endLine": 43,
                  "endColumn": 46,
                  "snippet": {
                    "text": "    See `Azure CLI documentation <https://learn.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli>`_\n    for more information about creating and managing service principals.\n\n    When this environment configuration is incomplete, the credential will attempt to authenticate a managed identity.\n    See `Microsoft Entra ID documentation\n    <https://learn.microsoft.com/entra/identity/managed-identities-azure-resources/overview>`__ for an overview\n    of managed identities.\n",
                    "rendered": {
                      "text": "    See `Azure CLI documentation <https://learn.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli>`_\n    for more information about creating and managing service principals.\n\n    When this environment configuration is incomplete, the credential will attempt to authenticate a managed identity.\n    See `Microsoft Entra ID documentation\n    <https://learn.microsoft.com/entra/identity/managed-identities-azure-resources/overview>`__ for an overview\n    of managed identities.\n",
                      "markdown": "`    See `Azure CLI documentation <https://learn.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli>`_\n    for more information about creating and managing service principals.\n\n    When this environment configuration is incomplete, the credential will attempt to authenticate a managed identity.\n    See `Microsoft Entra ID documentation\n    <https://learn.microsoft.com/entra/identity/managed-identities-azure-resources/overview>`__ for an overview\n    of managed identities.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/application.py"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 52,
                  "endLine": 26,
                  "endColumn": 93,
                  "snippet": {
                    "text": "    This credential is designed for applications deployed to Azure (:class:`~azure.identity.aio.DefaultAzureCredential`\n    is better suited to local development). It authenticates service principals and managed identities.\n\n    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n",
                    "rendered": {
                      "text": "    This credential is designed for applications deployed to Azure (:class:`~azure.identity.aio.DefaultAzureCredential`\n    is better suited to local development). It authenticates service principals and managed identities.\n\n    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n",
                      "markdown": "`    This credential is designed for applications deployed to Azure (:class:`~azure.identity.aio.DefaultAzureCredential`\n    is better suited to local development). It authenticates service principals and managed identities.\n\n    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/application.py"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 84,
                  "endLine": 102,
                  "endColumn": 88,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/application.py"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 84,
                  "endLine": 73,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/application.py"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 61,
                  "endLine": 51,
                  "endColumn": 70,
                  "snippet": {
                    "text": "        the authority for Azure Public Cloud, which is the default when no value is given for this keyword argument or\n        environment variable AZURE_AUTHORITY_HOST. :class:`~azure.identity.AzureAuthorityHosts` defines authorities for\n        other clouds. Authority configuration applies only to service principal authentication.\n    :keyword str managed_identity_client_id: The client ID of a user-assigned managed identity. Defaults to the value\n        of the environment variable AZURE_CLIENT_ID, if any. If not specified, a system-assigned identity will be used.\n    \"\"\"\n\n    def __init__(\n        s",
                    "rendered": {
                      "text": "        the authority for Azure Public Cloud, which is the default when no value is given for this keyword argument or\n        environment variable AZURE_AUTHORITY_HOST. :class:`~azure.identity.AzureAuthorityHosts` defines authorities for\n        other clouds. Authority configuration applies only to service principal authentication.\n    :keyword str managed_identity_client_id: The client ID of a user-assigned managed identity. Defaults to the value\n        of the environment variable AZURE_CLIENT_ID, if any. If not specified, a system-assigned identity will be used.\n    \"\"\"\n\n    def __init__(\n        s",
                      "markdown": "`        the authority for Azure Public Cloud, which is the default when no value is given for this keyword argument or\n        environment variable AZURE_AUTHORITY_HOST. :class:`~azure.identity.AzureAuthorityHosts` defines authorities for\n        other clouds. Authority configuration applies only to service principal authentication.\n    :keyword str managed_identity_client_id: The client ID of a user-assigned managed identity. Defaults to the value\n        of the environment variable AZURE_CLIENT_ID, if any. If not specified, a system-assigned identity will be used.\n    \"\"\"\n\n    def __init__(\n        s`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/application.py"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 52,
                  "endLine": 41,
                  "endColumn": 61,
                  "snippet": {
                    "text": "          certificate must not be password-protected.\n\n    See `Azure CLI documentation <https://learn.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli>`_\n    for more information about creating and managing service principals.\n\n    When this environment configuration is incomplete, the credential will attempt to authenticate a managed identity.\n    See `Microsoft Entra ID documentation\n",
                    "rendered": {
                      "text": "          certificate must not be password-protected.\n\n    See `Azure CLI documentation <https://learn.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli>`_\n    for more information about creating and managing service principals.\n\n    When this environment configuration is incomplete, the credential will attempt to authenticate a managed identity.\n    See `Microsoft Entra ID documentation\n",
                      "markdown": "`          certificate must not be password-protected.\n\n    See `Azure CLI documentation <https://learn.microsoft.com/cli/azure/create-an-azure-service-principal-azure-cli>`_\n    for more information about creating and managing service principals.\n\n    When this environment configuration is incomplete, the credential will attempt to authenticate a managed identity.\n    See `Microsoft Entra ID documentation\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/application.py"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 45,
                  "endLine": 33,
                  "endColumn": 54,
                  "snippet": {
                    "text": "\n    And one of these to authenticate that principal:\n\n        - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n\n        **or**\n\n",
                    "rendered": {
                      "text": "\n    And one of these to authenticate that principal:\n\n        - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n\n        **or**\n\n",
                      "markdown": "`\n    And one of these to authenticate that principal:\n\n        - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n\n        **or**\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/application.py"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 34,
                  "endLine": 29,
                  "endColumn": 43,
                  "snippet": {
                    "text": "    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n\n    And one of these to authenticate that principal:\n\n",
                    "rendered": {
                      "text": "    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n\n    And one of these to authenticate that principal:\n\n",
                      "markdown": "`    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n\n    And one of these to authenticate that principal:\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/application.py"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 40,
                  "endLine": 28,
                  "endColumn": 49,
                  "snippet": {
                    "text": "\n    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n\n    And one of these to authenticate that principal:\n",
                    "rendered": {
                      "text": "\n    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n\n    And one of these to authenticate that principal:\n",
                      "markdown": "`\n    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n\n    And one of these to authenticate that principal:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/application.py"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 7,
                  "endLine": 26,
                  "endColumn": 16,
                  "snippet": {
                    "text": "    This credential is designed for applications deployed to Azure (:class:`~azure.identity.aio.DefaultAzureCredential`\n    is better suited to local development). It authenticates service principals and managed identities.\n\n    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n",
                    "rendered": {
                      "text": "    This credential is designed for applications deployed to Azure (:class:`~azure.identity.aio.DefaultAzureCredential`\n    is better suited to local development). It authenticates service principals and managed identities.\n\n    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n",
                      "markdown": "`    This credential is designed for applications deployed to Azure (:class:`~azure.identity.aio.DefaultAzureCredential`\n    is better suited to local development). It authenticates service principals and managed identities.\n\n    For service principal authentication, set these environment variables to identify a principal:\n\n        - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its \"directory\" ID.\n        - **AZURE_CLIENT_ID**: the service principal's client ID\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/application.py"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 60,
                  "endLine": 24,
                  "endColumn": 69,
                  "snippet": {
                    "text": "    \"\"\"A credential for Microsoft Entra applications.\n\n    This credential is designed for applications deployed to Azure (:class:`~azure.identity.aio.DefaultAzureCredential`\n    is better suited to local development). It authenticates service principals and managed identities.\n\n    For service principal authentication, set these environment variables to identify a principal:\n\n",
                    "rendered": {
                      "text": "    \"\"\"A credential for Microsoft Entra applications.\n\n    This credential is designed for applications deployed to Azure (:class:`~azure.identity.aio.DefaultAzureCredential`\n    is better suited to local development). It authenticates service principals and managed identities.\n\n    For service principal authentication, set these environment variables to identify a principal:\n\n",
                      "markdown": "`    \"\"\"A credential for Microsoft Entra applications.\n\n    This credential is designed for applications deployed to Azure (:class:`~azure.identity.aio.DefaultAzureCredential`\n    is better suited to local development). It authenticates service principals and managed identities.\n\n    For service principal authentication, set these environment variables to identify a principal:\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/app_service.py"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 20,
                  "endLine": 20,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        return None\n\n    def get_unavailable_message(self, desc: str = \"\") -> str:\n        return f\"App Service managed identity configuration not found in environment. {desc}\"\n",
                    "rendered": {
                      "text": "        return None\n\n    def get_unavailable_message(self, desc: str = \"\") -> str:\n        return f\"App Service managed identity configuration not found in environment. {desc}\"\n",
                      "markdown": "`        return None\n\n    def get_unavailable_message(self, desc: str = \"\") -> str:\n        return f\"App Service managed identity configuration not found in environment. {desc}\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/vscode.py"
                },
                "region": {
                  "startLine": 198,
                  "startColumn": 21,
                  "endLine": 198,
                  "endColumn": 26,
                  "snippet": {
                    "text": "                \" to troubleshoot this issue.\"\n            )\n            raise CredentialUnavailableError(message=error_message)\n        if within_dac.get():\n            try:\n                token = super().get_token_info(*scopes, options=options)\n                return token\n",
                    "rendered": {
                      "text": "                \" to troubleshoot this issue.\"\n            )\n            raise CredentialUnavailableError(message=error_message)\n        if within_dac.get():\n            try:\n                token = super().get_token_info(*scopes, options=options)\n                return token\n",
                      "markdown": "`                \" to troubleshoot this issue.\"\n            )\n            raise CredentialUnavailableError(message=error_message)\n        if within_dac.get():\n            try:\n                token = super().get_token_info(*scopes, options=options)\n                return token\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/vscode.py"
                },
                "region": {
                  "startLine": 167,
                  "startColumn": 21,
                  "endLine": 167,
                  "endColumn": 26,
                  "snippet": {
                    "text": "                \" to troubleshoot this issue.\"\n            )\n            raise CredentialUnavailableError(message=error_message)\n        if within_dac.get():\n            try:\n                token = super().get_token(*scopes, claims=claims, tenant_id=tenant_id, **kwargs)\n                return token\n",
                    "rendered": {
                      "text": "                \" to troubleshoot this issue.\"\n            )\n            raise CredentialUnavailableError(message=error_message)\n        if within_dac.get():\n            try:\n                token = super().get_token(*scopes, claims=claims, tenant_id=tenant_id, **kwargs)\n                return token\n",
                      "markdown": "`                \" to troubleshoot this issue.\"\n            )\n            raise CredentialUnavailableError(message=error_message)\n        if within_dac.get():\n            try:\n                token = super().get_token(*scopes, claims=claims, tenant_id=tenant_id, **kwargs)\n                return token\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/vscode.py"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 73,
                  "endLine": 96,
                  "endColumn": 78,
                  "snippet": {
                    "text": "        #  1) VisualStudioCodeCredential(tenant_id=...)\n        #  2) \"azure.tenant\" in VS Code user settings\n        #  3) default: organizations\n        tenant_id = kwargs.pop(\"tenant_id\", None) or vscode_user_settings.get(\"azure.tenant\", \"organizations\")\n        validate_tenant_id(tenant_id)\n        if tenant_id.lower() == \"adfs\":\n            self._unavailable_reason = \"VisualStudioCodeCredential authentication unavailable. ADFS is not supported.\"\n",
                    "rendered": {
                      "text": "        #  1) VisualStudioCodeCredential(tenant_id=...)\n        #  2) \"azure.tenant\" in VS Code user settings\n        #  3) default: organizations\n        tenant_id = kwargs.pop(\"tenant_id\", None) or vscode_user_settings.get(\"azure.tenant\", \"organizations\")\n        validate_tenant_id(tenant_id)\n        if tenant_id.lower() == \"adfs\":\n            self._unavailable_reason = \"VisualStudioCodeCredential authentication unavailable. ADFS is not supported.\"\n",
                      "markdown": "`        #  1) VisualStudioCodeCredential(tenant_id=...)\n        #  2) \"azure.tenant\" in VS Code user settings\n        #  3) default: organizations\n        tenant_id = kwargs.pop(\"tenant_id\", None) or vscode_user_settings.get(\"azure.tenant\", \"organizations\")\n        validate_tenant_id(tenant_id)\n        if tenant_id.lower() == \"adfs\":\n            self._unavailable_reason = \"VisualStudioCodeCredential authentication unavailable. ADFS is not supported.\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/vscode.py"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 63,
                  "endLine": 73,
                  "endColumn": 68,
                  "snippet": {
                    "text": "        #  2) $AZURE_AUTHORITY_HOST\n        #  3) authority matching VS Code's \"azure.cloud\" setting\n        #  4) default: Public Cloud\n        authority = kwargs.pop(\"authority\", None) or os.environ.get(EnvironmentVariables.AZURE_AUTHORITY_HOST)\n        if not authority:\n            # the application didn't specify an authority, so we figure it out from VS Code settings\n            if self._cloud == \"AzureCloud\":\n",
                    "rendered": {
                      "text": "        #  2) $AZURE_AUTHORITY_HOST\n        #  3) authority matching VS Code's \"azure.cloud\" setting\n        #  4) default: Public Cloud\n        authority = kwargs.pop(\"authority\", None) or os.environ.get(EnvironmentVariables.AZURE_AUTHORITY_HOST)\n        if not authority:\n            # the application didn't specify an authority, so we figure it out from VS Code settings\n            if self._cloud == \"AzureCloud\":\n",
                      "markdown": "`        #  2) $AZURE_AUTHORITY_HOST\n        #  3) authority matching VS Code's \"azure.cloud\" setting\n        #  4) default: Public Cloud\n        authority = kwargs.pop(\"authority\", None) or os.environ.get(EnvironmentVariables.AZURE_AUTHORITY_HOST)\n        if not authority:\n            # the application didn't specify an authority, so we figure it out from VS Code settings\n            if self._cloud == \"AzureCloud\":\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/vscode.py"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 29,
                  "endLine": 36,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        self._refresh_token = None\n        self._unavailable_reason = \"\"\n\n        self._client = kwargs.get(\"_client\")\n        if not self._client:\n            self._initialize(user_settings, **kwargs)\n        if not (self._client or self._unavailable_reason):\n",
                    "rendered": {
                      "text": "        self._refresh_token = None\n        self._unavailable_reason = \"\"\n\n        self._client = kwargs.get(\"_client\")\n        if not self._client:\n            self._initialize(user_settings, **kwargs)\n        if not (self._client or self._unavailable_reason):\n",
                      "markdown": "`        self._refresh_token = None\n        self._unavailable_reason = \"\"\n\n        self._client = kwargs.get(\"_client\")\n        if not self._client:\n            self._initialize(user_settings, **kwargs)\n        if not (self._client or self._unavailable_reason):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/vscode.py"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 35,
                  "endLine": 32,
                  "endColumn": 40,
                  "snippet": {
                    "text": "        super(_VSCodeCredentialBase, self).__init__()\n\n        user_settings = get_user_settings()\n        self._cloud = user_settings.get(\"azure.cloud\", \"AzureCloud\")\n        self._refresh_token = None\n        self._unavailable_reason = \"\"\n\n",
                    "rendered": {
                      "text": "        super(_VSCodeCredentialBase, self).__init__()\n\n        user_settings = get_user_settings()\n        self._cloud = user_settings.get(\"azure.cloud\", \"AzureCloud\")\n        self._refresh_token = None\n        self._unavailable_reason = \"\"\n\n",
                      "markdown": "`        super(_VSCodeCredentialBase, self).__init__()\n\n        user_settings = get_user_settings()\n        self._cloud = user_settings.get(\"azure.cloud\", \"AzureCloud\")\n        self._refresh_token = None\n        self._unavailable_reason = \"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/vscode.py"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 56,
                  "endLine": 73,
                  "endColumn": 67,
                  "snippet": {
                    "text": "        #  2) $AZURE_AUTHORITY_HOST\n        #  3) authority matching VS Code's \"azure.cloud\" setting\n        #  4) default: Public Cloud\n        authority = kwargs.pop(\"authority\", None) or os.environ.get(EnvironmentVariables.AZURE_AUTHORITY_HOST)\n        if not authority:\n            # the application didn't specify an authority, so we figure it out from VS Code settings\n            if self._cloud == \"AzureCloud\":\n",
                    "rendered": {
                      "text": "        #  2) $AZURE_AUTHORITY_HOST\n        #  3) authority matching VS Code's \"azure.cloud\" setting\n        #  4) default: Public Cloud\n        authority = kwargs.pop(\"authority\", None) or os.environ.get(EnvironmentVariables.AZURE_AUTHORITY_HOST)\n        if not authority:\n            # the application didn't specify an authority, so we figure it out from VS Code settings\n            if self._cloud == \"AzureCloud\":\n",
                      "markdown": "`        #  2) $AZURE_AUTHORITY_HOST\n        #  3) authority matching VS Code's \"azure.cloud\" setting\n        #  4) default: Public Cloud\n        authority = kwargs.pop(\"authority\", None) or os.environ.get(EnvironmentVariables.AZURE_AUTHORITY_HOST)\n        if not authority:\n            # the application didn't specify an authority, so we figure it out from VS Code settings\n            if self._cloud == \"AzureCloud\":\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/vscode.py"
                },
                "region": {
                  "startLine": 181,
                  "startColumn": 84,
                  "endLine": 181,
                  "endColumn": 88,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/vscode.py"
                },
                "region": {
                  "startLine": 148,
                  "startColumn": 84,
                  "endLine": 148,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/user_password.py"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 35,
                  "endLine": 78,
                  "endColumn": 40,
                  "snippet": {
                    "text": "            username=self._username,\n            password=self._password,\n            scopes=list(scopes),\n            claims_challenge=kwargs.get(\"claims\"),\n        )\n",
                    "rendered": {
                      "text": "            username=self._username,\n            password=self._password,\n            scopes=list(scopes),\n            claims_challenge=kwargs.get(\"claims\"),\n        )\n",
                      "markdown": "`            username=self._username,\n            password=self._password,\n            scopes=list(scopes),\n            claims_challenge=kwargs.get(\"claims\"),\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/user_password.py"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 27,
                  "endLine": 76,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        app = self._get_app(**kwargs)\n        return app.acquire_token_by_username_password(\n            username=self._username,\n            password=self._password,\n            scopes=list(scopes),\n            claims_challenge=kwargs.get(\"claims\"),\n        )\n",
                    "rendered": {
                      "text": "        app = self._get_app(**kwargs)\n        return app.acquire_token_by_username_password(\n            username=self._username,\n            password=self._password,\n            scopes=list(scopes),\n            claims_challenge=kwargs.get(\"claims\"),\n        )\n",
                      "markdown": "`        app = self._get_app(**kwargs)\n        return app.acquire_token_by_username_password(\n            username=self._username,\n            password=self._password,\n            scopes=list(scopes),\n            claims_challenge=kwargs.get(\"claims\"),\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/user_password.py"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 12,
                  "endLine": 76,
                  "endColumn": 20,
                  "snippet": {
                    "text": "        app = self._get_app(**kwargs)\n        return app.acquire_token_by_username_password(\n            username=self._username,\n            password=self._password,\n            scopes=list(scopes),\n            claims_challenge=kwargs.get(\"claims\"),\n        )\n",
                    "rendered": {
                      "text": "        app = self._get_app(**kwargs)\n        return app.acquire_token_by_username_password(\n            username=self._username,\n            password=self._password,\n            scopes=list(scopes),\n            claims_challenge=kwargs.get(\"claims\"),\n        )\n",
                      "markdown": "`        app = self._get_app(**kwargs)\n        return app.acquire_token_by_username_password(\n            username=self._username,\n            password=self._password,\n            scopes=list(scopes),\n            claims_challenge=kwargs.get(\"claims\"),\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/user_password.py"
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 45,
                  "endLine": 74,
                  "endColumn": 53,
                  "snippet": {
                    "text": "    @wrap_exceptions\n    def _request_token(self, *scopes: str, **kwargs: Any) -> Dict:\n        app = self._get_app(**kwargs)\n        return app.acquire_token_by_username_password(\n            username=self._username,\n            password=self._password,\n            scopes=list(scopes),\n",
                    "rendered": {
                      "text": "    @wrap_exceptions\n    def _request_token(self, *scopes: str, **kwargs: Any) -> Dict:\n        app = self._get_app(**kwargs)\n        return app.acquire_token_by_username_password(\n            username=self._username,\n            password=self._password,\n            scopes=list(scopes),\n",
                      "markdown": "`    @wrap_exceptions\n    def _request_token(self, *scopes: str, **kwargs: Any) -> Dict:\n        app = self._get_app(**kwargs)\n        return app.acquire_token_by_username_password(\n            username=self._username,\n            password=self._password,\n            scopes=list(scopes),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/user_password.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 25,
                  "endLine": 69,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        kwargs.pop(\"authentication_record\", None)\n        super(UsernamePasswordCredential, self).__init__(client_id=client_id, **kwargs)\n        self._username = username\n        self._password = password\n\n    @wrap_exceptions\n    def _request_token(self, *scopes: str, **kwargs: Any) -> Dict:\n",
                    "rendered": {
                      "text": "        kwargs.pop(\"authentication_record\", None)\n        super(UsernamePasswordCredential, self).__init__(client_id=client_id, **kwargs)\n        self._username = username\n        self._password = password\n\n    @wrap_exceptions\n    def _request_token(self, *scopes: str, **kwargs: Any) -> Dict:\n",
                      "markdown": "`        kwargs.pop(\"authentication_record\", None)\n        super(UsernamePasswordCredential, self).__init__(client_id=client_id, **kwargs)\n        self._username = username\n        self._password = password\n\n    @wrap_exceptions\n    def _request_token(self, *scopes: str, **kwargs: Any) -> Dict:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/user_password.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 14,
                  "endLine": 69,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        kwargs.pop(\"authentication_record\", None)\n        super(UsernamePasswordCredential, self).__init__(client_id=client_id, **kwargs)\n        self._username = username\n        self._password = password\n\n    @wrap_exceptions\n    def _request_token(self, *scopes: str, **kwargs: Any) -> Dict:\n",
                    "rendered": {
                      "text": "        kwargs.pop(\"authentication_record\", None)\n        super(UsernamePasswordCredential, self).__init__(client_id=client_id, **kwargs)\n        self._username = username\n        self._password = password\n\n    @wrap_exceptions\n    def _request_token(self, *scopes: str, **kwargs: Any) -> Dict:\n",
                      "markdown": "`        kwargs.pop(\"authentication_record\", None)\n        super(UsernamePasswordCredential, self).__init__(client_id=client_id, **kwargs)\n        self._username = username\n        self._password = password\n\n    @wrap_exceptions\n    def _request_token(self, *scopes: str, **kwargs: Any) -> Dict:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/user_password.py"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 22,
                  "endLine": 67,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        # validate the given password. This class therefore doesn't document the authentication_record argument, and we\n        # discard it here.\n        kwargs.pop(\"authentication_record\", None)\n        super(UsernamePasswordCredential, self).__init__(client_id=client_id, **kwargs)\n        self._username = username\n        self._password = password\n\n",
                    "rendered": {
                      "text": "        # validate the given password. This class therefore doesn't document the authentication_record argument, and we\n        # discard it here.\n        kwargs.pop(\"authentication_record\", None)\n        super(UsernamePasswordCredential, self).__init__(client_id=client_id, **kwargs)\n        self._username = username\n        self._password = password\n\n",
                      "markdown": "`        # validate the given password. This class therefore doesn't document the authentication_record argument, and we\n        # discard it here.\n        kwargs.pop(\"authentication_record\", None)\n        super(UsernamePasswordCredential, self).__init__(client_id=client_id, **kwargs)\n        self._username = username\n        self._password = password\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/user_password.py"
                },
                "region": {
                  "startLine": 64,
                  "startColumn": 29,
                  "endLine": 64,
                  "endColumn": 37,
                  "snippet": {
                    "text": "password: str, **kwargs: Any) -> None:\n        # The base class will accept an AuthenticationRecord, allowing this credential to authenticate silently the\n        # first time it's asked for a token. However, we want to ensure this first authentication is not silent, to\n        # validate the given password. This class therefore doesn't document the authentication_record argument, and we\n        # discard it here.\n        kwargs.pop(\"authentication_record\", None)\n        super(UsernamePasswordCredential, self).__init__(client_id=client_id, **kwargs)\n        self._username = username\n        self._pass",
                    "rendered": {
                      "text": "password: str, **kwargs: Any) -> None:\n        # The base class will accept an AuthenticationRecord, allowing this credential to authenticate silently the\n        # first time it's asked for a token. However, we want to ensure this first authentication is not silent, to\n        # validate the given password. This class therefore doesn't document the authentication_record argument, and we\n        # discard it here.\n        kwargs.pop(\"authentication_record\", None)\n        super(UsernamePasswordCredential, self).__init__(client_id=client_id, **kwargs)\n        self._username = username\n        self._pass",
                      "markdown": "`password: str, **kwargs: Any) -> None:\n        # The base class will accept an AuthenticationRecord, allowing this credential to authenticate silently the\n        # first time it's asked for a token. However, we want to ensure this first authentication is not silent, to\n        # validate the given password. This class therefore doesn't document the authentication_record argument, and we\n        # discard it here.\n        kwargs.pop(\"authentication_record\", None)\n        super(UsernamePasswordCredential, self).__init__(client_id=client_id, **kwargs)\n        self._username = username\n        self._pass`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/user_password.py"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 54,
                  "endLine": 61,
                  "endColumn": 62,
                  "snippet": {
                    "text": "            :caption: Create a UsernamePasswordCredential.\n    \"\"\"\n\n    def __init__(self, client_id: str, username: str, password: str, **kwargs: Any) -> None:\n        # The base class will accept an AuthenticationRecord, allowing this credential to authenticate silently the\n        # first time it's asked for a token. However, we want to ensure this first authentication is not silent, to\n        # validate the given password. This class therefore doesn't document the authentication_record argument, and we\n",
                    "rendered": {
                      "text": "            :caption: Create a UsernamePasswordCredential.\n    \"\"\"\n\n    def __init__(self, client_id: str, username: str, password: str, **kwargs: Any) -> None:\n        # The base class will accept an AuthenticationRecord, allowing this credential to authenticate silently the\n        # first time it's asked for a token. However, we want to ensure this first authentication is not silent, to\n        # validate the given password. This class therefore doesn't document the authentication_record argument, and we\n",
                      "markdown": "`            :caption: Create a UsernamePasswordCredential.\n    \"\"\"\n\n    def __init__(self, client_id: str, username: str, password: str, **kwargs: Any) -> None:\n        # The base class will accept an AuthenticationRecord, allowing this credential to authenticate silently the\n        # first time it's asked for a token. However, we want to ensure this first authentication is not silent, to\n        # validate the given password. This class therefore doesn't document the authentication_record argument, and we\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/user_password.py"
                },
                "region": {
                  "startLine": 58,
                  "startColumn": 39,
                  "endLine": 58,
                  "endColumn": 47,
                  "snippet": {
                    "text": "            :end-before: [END create_username_password_credential]\n            :language: python\n            :dedent: 4\n            :caption: Create a UsernamePasswordCredential.\n    \"\"\"\n\n    def __init__(self, client_id: str, username: str, password: str, **kwargs: Any) -> None:\n",
                    "rendered": {
                      "text": "            :end-before: [END create_username_password_credential]\n            :language: python\n            :dedent: 4\n            :caption: Create a UsernamePasswordCredential.\n    \"\"\"\n\n    def __init__(self, client_id: str, username: str, password: str, **kwargs: Any) -> None:\n",
                      "markdown": "`            :end-before: [END create_username_password_credential]\n            :language: python\n            :dedent: 4\n            :caption: Create a UsernamePasswordCredential.\n    \"\"\"\n\n    def __init__(self, client_id: str, username: str, password: str, **kwargs: Any) -> None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/user_password.py"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 46,
                  "endLine": 55,
                  "endColumn": 54,
                  "snippet": {
                    "text": "\n        .. literalinclude:: ../samples/credential_creation_code_snippets.py\n            :start-after: [START create_username_password_credential]\n            :end-before: [END create_username_password_credential]\n            :language: python\n            :dedent: 4\n            :caption: Create a UsernamePasswordCredential.\n",
                    "rendered": {
                      "text": "\n        .. literalinclude:: ../samples/credential_creation_code_snippets.py\n            :start-after: [START create_username_password_credential]\n            :end-before: [END create_username_password_credential]\n            :language: python\n            :dedent: 4\n            :caption: Create a UsernamePasswordCredential.\n",
                      "markdown": "`\n        .. literalinclude:: ../samples/credential_creation_code_snippets.py\n            :start-after: [START create_username_password_credential]\n            :end-before: [END create_username_password_credential]\n            :language: python\n            :dedent: 4\n            :caption: Create a UsernamePasswordCredential.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/user_password.py"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 49,
                  "endLine": 54,
                  "endColumn": 57,
                  "snippet": {
                    "text": "    .. admonition:: Example:\n\n        .. literalinclude:: ../samples/credential_creation_code_snippets.py\n            :start-after: [START create_username_password_credential]\n            :end-before: [END create_username_password_credential]\n            :language: python\n            :dedent: 4\n",
                    "rendered": {
                      "text": "    .. admonition:: Example:\n\n        .. literalinclude:: ../samples/credential_creation_code_snippets.py\n            :start-after: [START create_username_password_credential]\n            :end-before: [END create_username_password_credential]\n            :language: python\n            :dedent: 4\n",
                      "markdown": "`    .. admonition:: Example:\n\n        .. literalinclude:: ../samples/credential_creation_code_snippets.py\n            :start-after: [START create_username_password_credential]\n            :end-before: [END create_username_password_credential]\n            :language: python\n            :dedent: 4\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/user_password.py"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 36,
                  "endLine": 27,
                  "endColumn": 44,
                  "snippet": {
                    "text": "\n    :param str client_id: The application's client ID\n    :param str username: The user's username (usually an email address)\n    :param str password: The user's password\n\n    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n",
                    "rendered": {
                      "text": "\n    :param str client_id: The application's client ID\n    :param str username: The user's username (usually an email address)\n    :param str password: The user's password\n\n    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n",
                      "markdown": "`\n    :param str client_id: The application's client ID\n    :param str username: The user's username (usually an email address)\n    :param str password: The user's password\n\n    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/user_password.py"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 15,
                  "endLine": 27,
                  "endColumn": 23,
                  "snippet": {
                    "text": "\n    :param str client_id: The application's client ID\n    :param str username: The user's username (usually an email address)\n    :param str password: The user's password\n\n    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n",
                    "rendered": {
                      "text": "\n    :param str client_id: The application's client ID\n    :param str username: The user's username (usually an email address)\n    :param str password: The user's password\n\n    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n",
                      "markdown": "`\n    :param str client_id: The application's client ID\n    :param str username: The user's username (usually an email address)\n    :param str password: The user's password\n\n    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/user_password.py"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 48,
                  "endLine": 11,
                  "endColumn": 56,
                  "snippet": {
                    "text": "\n\nclass UsernamePasswordCredential(InteractiveCredential):\n    \"\"\"Authenticates a user with a username and password.\n\n    In general, Microsoft doesn't recommend this kind of authentication, because it's less secure than other\n    authentication flows.\n",
                    "rendered": {
                      "text": "\n\nclass UsernamePasswordCredential(InteractiveCredential):\n    \"\"\"Authenticates a user with a username and password.\n\n    In general, Microsoft doesn't recommend this kind of authentication, because it's less secure than other\n    authentication flows.\n",
                      "markdown": "`\n\nclass UsernamePasswordCredential(InteractiveCredential):\n    \"\"\"Authenticates a user with a username and password.\n\n    In general, Microsoft doesn't recommend this kind of authentication, because it's less secure than other\n    authentication flows.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/user_password.py"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 14,
                  "endLine": 10,
                  "endColumn": 22,
                  "snippet": {
                    "text": "from .._internal import InteractiveCredential, wrap_exceptions\n\n\nclass UsernamePasswordCredential(InteractiveCredential):\n    \"\"\"Authenticates a user with a username and password.\n\n    In general, Microsoft doesn't recommend this kind of authentication, because it's less secure than other\n",
                    "rendered": {
                      "text": "from .._internal import InteractiveCredential, wrap_exceptions\n\n\nclass UsernamePasswordCredential(InteractiveCredential):\n    \"\"\"Authenticates a user with a username and password.\n\n    In general, Microsoft doesn't recommend this kind of authentication, because it's less secure than other\n",
                      "markdown": "`from .._internal import InteractiveCredential, wrap_exceptions\n\n\nclass UsernamePasswordCredential(InteractiveCredential):\n    \"\"\"Authenticates a user with a username and password.\n\n    In general, Microsoft doesn't recommend this kind of authentication, because it's less secure than other\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/user_password.py"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 15,
                  "endLine": 63,
                  "endColumn": 21,
                  "snippet": {
                    "text": "\n    def __init__(self, client_id: str, username: str, password: str, **kwargs: Any) -> None:\n        # The base class will accept an AuthenticationRecord, allowing this credential to authenticate silently the\n        # first time it's asked for a token. However, we want to ensure this first authentication is not silent, to\n        # validate the given password. This class therefore doesn't document the authentication_record argument, and we\n        # discard it here.\n        kwargs.pop(\"authentication_record\", None)\n",
                    "rendered": {
                      "text": "\n    def __init__(self, client_id: str, username: str, password: str, **kwargs: Any) -> None:\n        # The base class will accept an AuthenticationRecord, allowing this credential to authenticate silently the\n        # first time it's asked for a token. However, we want to ensure this first authentication is not silent, to\n        # validate the given password. This class therefore doesn't document the authentication_record argument, and we\n        # discard it here.\n        kwargs.pop(\"authentication_record\", None)\n",
                      "markdown": "`\n    def __init__(self, client_id: str, username: str, password: str, **kwargs: Any) -> None:\n        # The base class will accept an AuthenticationRecord, allowing this credential to authenticate silently the\n        # first time it's asked for a token. However, we want to ensure this first authentication is not silent, to\n        # validate the given password. This class therefore doesn't document the authentication_record argument, and we\n        # discard it here.\n        kwargs.pop(\"authentication_record\", None)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/device_code.py"
                },
                "region": {
                  "startLine": 114,
                  "startColumn": 50,
                  "endLine": 114,
                  "endColumn": 55,
                  "snippet": {
                    "text": "            result = app.acquire_token_by_device_flow(flow, claims_challenge=kwargs.get(\"claims\"))\n\n        # raise for a timeout here because the error is particular to this class\n        if \"access_token\" not in result and result.get(\"error\") == \"authorization_pending\":\n            raise ClientAuthenticationError(message=\"Timed out waiting for user to authenticate\")\n\n        # base class will raise for other errors\n",
                    "rendered": {
                      "text": "            result = app.acquire_token_by_device_flow(flow, claims_challenge=kwargs.get(\"claims\"))\n\n        # raise for a timeout here because the error is particular to this class\n        if \"access_token\" not in result and result.get(\"error\") == \"authorization_pending\":\n            raise ClientAuthenticationError(message=\"Timed out waiting for user to authenticate\")\n\n        # base class will raise for other errors\n",
                      "markdown": "`            result = app.acquire_token_by_device_flow(flow, claims_challenge=kwargs.get(\"claims\"))\n\n        # raise for a timeout here because the error is particular to this class\n        if \"access_token\" not in result and result.get(\"error\") == \"authorization_pending\":\n            raise ClientAuthenticationError(message=\"Timed out waiting for user to authenticate\")\n\n        # base class will raise for other errors\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/device_code.py"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 83,
                  "endLine": 111,
                  "endColumn": 88,
                  "snippet": {
                    "text": "            )\n        else:\n            # MSAL will stop polling when the device code expires\n            result = app.acquire_token_by_device_flow(flow, claims_challenge=kwargs.get(\"claims\"))\n\n        # raise for a timeout here because the error is particular to this class\n        if \"access_token\" not in result and result.get(\"error\") == \"authorization_pending\":\n",
                    "rendered": {
                      "text": "            )\n        else:\n            # MSAL will stop polling when the device code expires\n            result = app.acquire_token_by_device_flow(flow, claims_challenge=kwargs.get(\"claims\"))\n\n        # raise for a timeout here because the error is particular to this class\n        if \"access_token\" not in result and result.get(\"error\") == \"authorization_pending\":\n",
                      "markdown": "`            )\n        else:\n            # MSAL will stop polling when the device code expires\n            result = app.acquire_token_by_device_flow(flow, claims_challenge=kwargs.get(\"claims\"))\n\n        # raise for a timeout here because the error is particular to this class\n        if \"access_token\" not in result and result.get(\"error\") == \"authorization_pending\":\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/device_code.py"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 97,
                  "endLine": 107,
                  "endColumn": 102,
                  "snippet": {
                    "text": "            # user specified an effective timeout we will observe\n            deadline = int(time.time()) + self._timeout\n            result = app.acquire_token_by_device_flow(\n                flow, exit_condition=lambda flow: time.time() > deadline, claims_challenge=kwargs.get(\"claims\")\n            )\n        else:\n            # MSAL will stop polling when the device code expires\n",
                    "rendered": {
                      "text": "            # user specified an effective timeout we will observe\n            deadline = int(time.time()) + self._timeout\n            result = app.acquire_token_by_device_flow(\n                flow, exit_condition=lambda flow: time.time() > deadline, claims_challenge=kwargs.get(\"claims\")\n            )\n        else:\n            # MSAL will stop polling when the device code expires\n",
                      "markdown": "`            # user specified an effective timeout we will observe\n            deadline = int(time.time()) + self._timeout\n            result = app.acquire_token_by_device_flow(\n                flow, exit_condition=lambda flow: time.time() > deadline, claims_challenge=kwargs.get(\"claims\")\n            )\n        else:\n            # MSAL will stop polling when the device code expires\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/device_code.py"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 104,
                  "endLine": 94,
                  "endColumn": 109,
                  "snippet": {
                    "text": "        flow = app.initiate_device_flow(scopes)\n        if \"error\" in flow:\n            raise ClientAuthenticationError(\n                message=\"Couldn't begin authentication: {}\".format(flow.get(\"error_description\") or flow.get(\"error\"))\n            )\n        if self._prompt_callback:\n            self._prompt_callback(\n",
                    "rendered": {
                      "text": "        flow = app.initiate_device_flow(scopes)\n        if \"error\" in flow:\n            raise ClientAuthenticationError(\n                message=\"Couldn't begin authentication: {}\".format(flow.get(\"error_description\") or flow.get(\"error\"))\n            )\n        if self._prompt_callback:\n            self._prompt_callback(\n",
                      "markdown": "`        flow = app.initiate_device_flow(scopes)\n        if \"error\" in flow:\n            raise ClientAuthenticationError(\n                message=\"Couldn't begin authentication: {}\".format(flow.get(\"error_description\") or flow.get(\"error\"))\n            )\n        if self._prompt_callback:\n            self._prompt_callback(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/device_code.py"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 71,
                  "endLine": 94,
                  "endColumn": 76,
                  "snippet": {
                    "text": "        flow = app.initiate_device_flow(scopes)\n        if \"error\" in flow:\n            raise ClientAuthenticationError(\n                message=\"Couldn't begin authentication: {}\".format(flow.get(\"error_description\") or flow.get(\"error\"))\n            )\n        if self._prompt_callback:\n            self._prompt_callback(\n",
                    "rendered": {
                      "text": "        flow = app.initiate_device_flow(scopes)\n        if \"error\" in flow:\n            raise ClientAuthenticationError(\n                message=\"Couldn't begin authentication: {}\".format(flow.get(\"error_description\") or flow.get(\"error\"))\n            )\n        if self._prompt_callback:\n            self._prompt_callback(\n",
                      "markdown": "`        flow = app.initiate_device_flow(scopes)\n        if \"error\" in flow:\n            raise ClientAuthenticationError(\n                message=\"Couldn't begin authentication: {}\".format(flow.get(\"error_description\") or flow.get(\"error\"))\n            )\n        if self._prompt_callback:\n            self._prompt_callback(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/device_code.py"
                },
                "region": {
                  "startLine": 42,
                  "startColumn": 57,
                  "endLine": 42,
                  "endColumn": 61,
                  "snippet": {
                    "text": "\n        - ``verification_uri`` (str) the URL the user must visit\n        - ``user_code`` (str) the code the user must enter there\n        - ``expires_on`` (datetime.datetime) the UTC time at which the code will expire\n\n        If this argument isn't provided, the credential will print instructions to stdout.\n    :paramtype prompt_callback: Callable[str, str, ~datetime.datetime]\n",
                    "rendered": {
                      "text": "\n        - ``verification_uri`` (str) the URL the user must visit\n        - ``user_code`` (str) the code the user must enter there\n        - ``expires_on`` (datetime.datetime) the UTC time at which the code will expire\n\n        If this argument isn't provided, the credential will print instructions to stdout.\n    :paramtype prompt_callback: Callable[str, str, ~datetime.datetime]\n",
                      "markdown": "`\n        - ``verification_uri`` (str) the URL the user must visit\n        - ``user_code`` (str) the code the user must enter there\n        - ``expires_on`` (datetime.datetime) the UTC time at which the code will expire\n\n        If this argument isn't provided, the credential will print instructions to stdout.\n    :paramtype prompt_callback: Callable[str, str, ~datetime.datetime]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/device_code.py"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 49,
                  "endLine": 37,
                  "endColumn": 58,
                  "snippet": {
                    "text": "        authenticate work or school accounts. **Required for single-tenant applications.**\n    :keyword int timeout: seconds to wait for the user to authenticate. Defaults to the validity period of the\n        device code as set by Microsoft Entra ID, which also prevails when **timeout** is longer.\n    :keyword prompt_callback: A callback enabling control of how authentication\n        instructions are presented. Must accept arguments (``verification_uri``, ``user_code``, ``expires_on``):\n\n        - ``verification_uri`` (str) the URL the user must visit\n",
                    "rendered": {
                      "text": "        authenticate work or school accounts. **Required for single-tenant applications.**\n    :keyword int timeout: seconds to wait for the user to authenticate. Defaults to the validity period of the\n        device code as set by Microsoft Entra ID, which also prevails when **timeout** is longer.\n    :keyword prompt_callback: A callback enabling control of how authentication\n        instructions are presented. Must accept arguments (``verification_uri``, ``user_code``, ``expires_on``):\n\n        - ``verification_uri`` (str) the URL the user must visit\n",
                      "markdown": "`        authenticate work or school accounts. **Required for single-tenant applications.**\n    :keyword int timeout: seconds to wait for the user to authenticate. Defaults to the validity period of the\n        device code as set by Microsoft Entra ID, which also prevails when **timeout** is longer.\n    :keyword prompt_callback: A callback enabling control of how authentication\n        instructions are presented. Must accept arguments (``verification_uri``, ``user_code``, ``expires_on``):\n\n        - ``verification_uri`` (str) the URL the user must visit\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/device_code.py"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 21,
                  "endLine": 113,
                  "endColumn": 30,
                  "snippet": {
                    "text": "            # MSAL will stop polling when the device code expires\n            result = app.acquire_token_by_device_flow(flow, claims_challenge=kwargs.get(\"claims\"))\n\n        # raise for a timeout here because the error is particular to this class\n        if \"access_token\" not in result and result.get(\"error\") == \"authorization_pending\":\n            raise ClientAuthenticationError(message=\"Timed out waiting for user to authenticate\")\n\n",
                    "rendered": {
                      "text": "            # MSAL will stop polling when the device code expires\n            result = app.acquire_token_by_device_flow(flow, claims_challenge=kwargs.get(\"claims\"))\n\n        # raise for a timeout here because the error is particular to this class\n        if \"access_token\" not in result and result.get(\"error\") == \"authorization_pending\":\n            raise ClientAuthenticationError(message=\"Timed out waiting for user to authenticate\")\n\n",
                      "markdown": "`            # MSAL will stop polling when the device code expires\n            result = app.acquire_token_by_device_flow(flow, claims_challenge=kwargs.get(\"claims\"))\n\n        # raise for a timeout here because the error is particular to this class\n        if \"access_token\" not in result and result.get(\"error\") == \"authorization_pending\":\n            raise ClientAuthenticationError(message=\"Timed out waiting for user to authenticate\")\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/device_code.py"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 41,
                  "endLine": 104,
                  "endColumn": 50,
                  "snippet": {
                    "text": "            print(flow[\"message\"])\n\n        if self._timeout is not None and self._timeout < flow[\"expires_in\"]:\n            # user specified an effective timeout we will observe\n            deadline = int(time.time()) + self._timeout\n            result = app.acquire_token_by_device_flow(\n                flow, exit_condition=lambda flow: time.time() > deadline, claims_challenge=kwargs.get(\"claims\")\n",
                    "rendered": {
                      "text": "            print(flow[\"message\"])\n\n        if self._timeout is not None and self._timeout < flow[\"expires_in\"]:\n            # user specified an effective timeout we will observe\n            deadline = int(time.time()) + self._timeout\n            result = app.acquire_token_by_device_flow(\n                flow, exit_condition=lambda flow: time.time() > deadline, claims_challenge=kwargs.get(\"claims\")\n",
                      "markdown": "`            print(flow[\"message\"])\n\n        if self._timeout is not None and self._timeout < flow[\"expires_in\"]:\n            # user specified an effective timeout we will observe\n            deadline = int(time.time()) + self._timeout\n            result = app.acquire_token_by_device_flow(\n                flow, exit_condition=lambda flow: time.time() > deadline, claims_challenge=kwargs.get(\"claims\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/device_code.py"
                },
                "region": {
                  "startLine": 81,
                  "startColumn": 23,
                  "endLine": 82,
                  "snippet": {
                    "text": "        prompt_callback: Optional[Callable[[str, str, datetime], None]] = None,\n        **kwargs: Any\n    ) -> None:\n        self._timeout = timeout\n        self._prompt_callback = prompt_callback\n        super(DeviceCodeCredential, self).__init__(client_id=client_id, **kwargs)\n\n    @wrap_exceptions\n",
                    "rendered": {
                      "text": "        prompt_callback: Optional[Callable[[str, str, datetime], None]] = None,\n        **kwargs: Any\n    ) -> None:\n        self._timeout = timeout\n        self._prompt_callback = prompt_callback\n        super(DeviceCodeCredential, self).__init__(client_id=client_id, **kwargs)\n\n    @wrap_exceptions\n",
                      "markdown": "`        prompt_callback: Optional[Callable[[str, str, datetime], None]] = None,\n        **kwargs: Any\n    ) -> None:\n        self._timeout = timeout\n        self._prompt_callback = prompt_callback\n        super(DeviceCodeCredential, self).__init__(client_id=client_id, **kwargs)\n\n    @wrap_exceptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/device_code.py"
                },
                "region": {
                  "startLine": 42,
                  "startColumn": 52,
                  "endLine": 42,
                  "endColumn": 58,
                  "snippet": {
                    "text": "\n        - ``verification_uri`` (str) the URL the user must visit\n        - ``user_code`` (str) the code the user must enter there\n        - ``expires_on`` (datetime.datetime) the UTC time at which the code will expire\n\n        If this argument isn't provided, the credential will print instructions to stdout.\n    :paramtype prompt_callback: Callable[str, str, ~datetime.datetime]\n",
                    "rendered": {
                      "text": "\n        - ``verification_uri`` (str) the URL the user must visit\n        - ``user_code`` (str) the code the user must enter there\n        - ``expires_on`` (datetime.datetime) the UTC time at which the code will expire\n\n        If this argument isn't provided, the credential will print instructions to stdout.\n    :paramtype prompt_callback: Callable[str, str, ~datetime.datetime]\n",
                      "markdown": "`\n        - ``verification_uri`` (str) the URL the user must visit\n        - ``user_code`` (str) the code the user must enter there\n        - ``expires_on`` (datetime.datetime) the UTC time at which the code will expire\n\n        If this argument isn't provided, the credential will print instructions to stdout.\n    :paramtype prompt_callback: Callable[str, str, ~datetime.datetime]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/device_code.py"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 3,
                  "endLine": 23,
                  "endColumn": 8,
                  "snippet": {
                    "text": "    authenticates successfully, the credential receives an access token.\n\n    This credential is primarily useful for authenticating a user in an environment without a web browser, such as an\n    SSH session. If a web browser is available, :class:`~azure.identity.InteractiveBrowserCredential` is more\n    convenient because it automatically opens a browser to the login page.\n\n    :param str client_id: Client ID of the Microsoft Entra application that users will sign into. It is recommended\n",
                    "rendered": {
                      "text": "    authenticates successfully, the credential receives an access token.\n\n    This credential is primarily useful for authenticating a user in an environment without a web browser, such as an\n    SSH session. If a web browser is available, :class:`~azure.identity.InteractiveBrowserCredential` is more\n    convenient because it automatically opens a browser to the login page.\n\n    :param str client_id: Client ID of the Microsoft Entra application that users will sign into. It is recommended\n",
                      "markdown": "`    authenticates successfully, the credential receives an access token.\n\n    This credential is primarily useful for authenticating a user in an environment without a web browser, such as an\n    SSH session. If a web browser is available, :class:`~azure.identity.InteractiveBrowserCredential` is more\n    convenient because it automatically opens a browser to the login page.\n\n    :param str client_id: Client ID of the Microsoft Entra application that users will sign into. It is recommended\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/device_code.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 6,
                  "endLine": 7,
                  "snippet": {
                    "text": "# Licensed under the MIT License.\n# ------------------------------------\nfrom datetime import datetime, timezone\nimport time\nfrom typing import Dict, Optional, Callable, Any\n\nfrom azure.core.exceptions import ClientAuthenticationError\n\n",
                    "rendered": {
                      "text": "# Licensed under the MIT License.\n# ------------------------------------\nfrom datetime import datetime, timezone\nimport time\nfrom typing import Dict, Optional, Callable, Any\n\nfrom azure.core.exceptions import ClientAuthenticationError\n\n",
                      "markdown": "`# Licensed under the MIT License.\n# ------------------------------------\nfrom datetime import datetime, timezone\nimport time\nfrom typing import Dict, Optional, Callable, Any\n\nfrom azure.core.exceptions import ClientAuthenticationError\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_arc.py"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 38,
                  "endLine": 76,
                  "endColumn": 43,
                  "snippet": {
                    "text": "    if sys.platform.startswith(\"linux\"):\n        return \"/var/opt/azcmagent/tokens\"\n    if sys.platform.startswith(\"win\"):\n        program_data_path = os.environ.get(\"PROGRAMDATA\")\n        if not program_data_path:\n            raise ValueError(\"PROGRAMDATA environment variable is not set or is empty.\")\n        return os.path.join(f\"{program_data_path}\", \"AzureConnectedMachineAgent\", \"Tokens\")\n",
                    "rendered": {
                      "text": "    if sys.platform.startswith(\"linux\"):\n        return \"/var/opt/azcmagent/tokens\"\n    if sys.platform.startswith(\"win\"):\n        program_data_path = os.environ.get(\"PROGRAMDATA\")\n        if not program_data_path:\n            raise ValueError(\"PROGRAMDATA environment variable is not set or is empty.\")\n        return os.path.join(f\"{program_data_path}\", \"AzureConnectedMachineAgent\", \"Tokens\")\n",
                      "markdown": "`    if sys.platform.startswith(\"linux\"):\n        return \"/var/opt/azcmagent/tokens\"\n    if sys.platform.startswith(\"win\"):\n        program_data_path = os.environ.get(\"PROGRAMDATA\")\n        if not program_data_path:\n            raise ValueError(\"PROGRAMDATA environment variable is not set or is empty.\")\n        return os.path.join(f\"{program_data_path}\", \"AzureConnectedMachineAgent\", \"Tokens\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_arc.py"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 43,
                  "endLine": 37,
                  "endColumn": 48,
                  "snippet": {
                    "text": "\ndef _get_secret_key(response: PipelineResponse) -> str:\n    # expecting header containing path to secret key file\n    header = response.http_response.headers.get(\"WWW-Authenticate\")\n    if not header:\n        raise ClientAuthenticationError(message=\"Did not receive a value from WWW-Authenticate header\")\n\n",
                    "rendered": {
                      "text": "\ndef _get_secret_key(response: PipelineResponse) -> str:\n    # expecting header containing path to secret key file\n    header = response.http_response.headers.get(\"WWW-Authenticate\")\n    if not header:\n        raise ClientAuthenticationError(message=\"Did not receive a value from WWW-Authenticate header\")\n\n",
                      "markdown": "`\ndef _get_secret_key(response: PipelineResponse) -> str:\n    # expecting header containing path to secret key file\n    header = response.http_response.headers.get(\"WWW-Authenticate\")\n    if not header:\n        raise ClientAuthenticationError(message=\"Did not receive a value from WWW-Authenticate header\")\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_arc.py"
                },
                "region": {
                  "startLine": 120,
                  "startColumn": 78,
                  "endLine": 120,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        if response.http_response.status_code == 401:\n            secret_key = _get_secret_key(response)\n            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)\n            response = self.next.send(request)\n\n        return response\n",
                    "rendered": {
                      "text": "\n        if response.http_response.status_code == 401:\n            secret_key = _get_secret_key(response)\n            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)\n            response = self.next.send(request)\n\n        return response\n",
                      "markdown": "`\n        if response.http_response.status_code == 401:\n            secret_key = _get_secret_key(response)\n            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)\n            response = self.next.send(request)\n\n        return response\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_arc.py"
                },
                "region": {
                  "startLine": 119,
                  "startColumn": 30,
                  "endLine": 119,
                  "endColumn": 40,
                  "snippet": {
                    "text": "        response = self.next.send(request)\n\n        if response.http_response.status_code == 401:\n            secret_key = _get_secret_key(response)\n            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)\n            response = self.next.send(request)\n\n",
                    "rendered": {
                      "text": "        response = self.next.send(request)\n\n        if response.http_response.status_code == 401:\n            secret_key = _get_secret_key(response)\n            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)\n            response = self.next.send(request)\n\n",
                      "markdown": "`        response = self.next.send(request)\n\n        if response.http_response.status_code == 401:\n            secret_key = _get_secret_key(response)\n            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)\n            response = self.next.send(request)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_arc.py"
                },
                "region": {
                  "startLine": 119,
                  "startColumn": 12,
                  "endLine": 119,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        response = self.next.send(request)\n\n        if response.http_response.status_code == 401:\n            secret_key = _get_secret_key(response)\n            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)\n            response = self.next.send(request)\n\n",
                    "rendered": {
                      "text": "        response = self.next.send(request)\n\n        if response.http_response.status_code == 401:\n            secret_key = _get_secret_key(response)\n            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)\n            response = self.next.send(request)\n\n",
                      "markdown": "`        response = self.next.send(request)\n\n        if response.http_response.status_code == 401:\n            secret_key = _get_secret_key(response)\n            request.http_request.headers[\"Authorization\"] = \"Basic {}\".format(secret_key)\n            response = self.next.send(request)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_arc.py"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 9,
                  "endLine": 35,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    return request\n\n\ndef _get_secret_key(response: PipelineResponse) -> str:\n    # expecting header containing path to secret key file\n    header = response.http_response.headers.get(\"WWW-Authenticate\")\n    if not header:\n",
                    "rendered": {
                      "text": "    return request\n\n\ndef _get_secret_key(response: PipelineResponse) -> str:\n    # expecting header containing path to secret key file\n    header = response.http_response.headers.get(\"WWW-Authenticate\")\n    if not header:\n",
                      "markdown": "`    return request\n\n\ndef _get_secret_key(response: PipelineResponse) -> str:\n    # expecting header containing path to secret key file\n    header = response.http_response.headers.get(\"WWW-Authenticate\")\n    if not header:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_arc.py"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 31,
                  "endLine": 76,
                  "endColumn": 42,
                  "snippet": {
                    "text": "    if sys.platform.startswith(\"linux\"):\n        return \"/var/opt/azcmagent/tokens\"\n    if sys.platform.startswith(\"win\"):\n        program_data_path = os.environ.get(\"PROGRAMDATA\")\n        if not program_data_path:\n            raise ValueError(\"PROGRAMDATA environment variable is not set or is empty.\")\n        return os.path.join(f\"{program_data_path}\", \"AzureConnectedMachineAgent\", \"Tokens\")\n",
                    "rendered": {
                      "text": "    if sys.platform.startswith(\"linux\"):\n        return \"/var/opt/azcmagent/tokens\"\n    if sys.platform.startswith(\"win\"):\n        program_data_path = os.environ.get(\"PROGRAMDATA\")\n        if not program_data_path:\n            raise ValueError(\"PROGRAMDATA environment variable is not set or is empty.\")\n        return os.path.join(f\"{program_data_path}\", \"AzureConnectedMachineAgent\", \"Tokens\")\n",
                      "markdown": "`    if sys.platform.startswith(\"linux\"):\n        return \"/var/opt/azcmagent/tokens\"\n    if sys.platform.startswith(\"win\"):\n        program_data_path = os.environ.get(\"PROGRAMDATA\")\n        if not program_data_path:\n            raise ValueError(\"PROGRAMDATA environment variable is not set or is empty.\")\n        return os.path.join(f\"{program_data_path}\", \"AzureConnectedMachineAgent\", \"Tokens\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_arc.py"
                },
                "region": {
                  "startLine": 89,
                  "startColumn": 13,
                  "endLine": 89,
                  "endColumn": 17,
                  "snippet": {
                    "text": "    A valid file will:\n        1. Be in the expected path for the current platform.\n        2. Have a `.key` extension.\n        3. Be at most 4096 bytes in size.\n\n    :param str file_path: The path to the key file.\n    :raises ClientAuthenticationError: If the file path is invalid.\n",
                    "rendered": {
                      "text": "    A valid file will:\n        1. Be in the expected path for the current platform.\n        2. Have a `.key` extension.\n        3. Be at most 4096 bytes in size.\n\n    :param str file_path: The path to the key file.\n    :raises ClientAuthenticationError: If the file path is invalid.\n",
                      "markdown": "`    A valid file will:\n        1. Be in the expected path for the current platform.\n        2. Have a `.key` extension.\n        3. Be at most 4096 bytes in size.\n\n    :param str file_path: The path to the key file.\n    :raises ClientAuthenticationError: If the file path is invalid.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_auth_record.py"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 30,
                  "endLine": 84,
                  "endColumn": 35,
                  "snippet": {
                    "text": "\n        deserialized = json.loads(data)\n\n        version = deserialized.get(\"version\")\n        if version not in SUPPORTED_VERSIONS:\n            raise ValueError(\n                'Unexpected version \"{}\". This package supports these versions: {}'.format(version, SUPPORTED_VERSIONS)\n",
                    "rendered": {
                      "text": "\n        deserialized = json.loads(data)\n\n        version = deserialized.get(\"version\")\n        if version not in SUPPORTED_VERSIONS:\n            raise ValueError(\n                'Unexpected version \"{}\". This package supports these versions: {}'.format(version, SUPPORTED_VERSIONS)\n",
                      "markdown": "`\n        deserialized = json.loads(data)\n\n        version = deserialized.get(\"version\")\n        if version not in SUPPORTED_VERSIONS:\n            raise ValueError(\n                'Unexpected version \"{}\". This package supports these versions: {}'.format(version, SUPPORTED_VERSIONS)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_auth_record.py"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 32,
                  "endLine": 67,
                  "endColumn": 41,
                  "snippet": {
                    "text": "\n    @property\n    def username(self) -> str:\n        \"\"\"The user principal or service principal name of the account.\n\n        :rtype: str\n        \"\"\"\n",
                    "rendered": {
                      "text": "\n    @property\n    def username(self) -> str:\n        \"\"\"The user principal or service principal name of the account.\n\n        :rtype: str\n        \"\"\"\n",
                      "markdown": "`\n    @property\n    def username(self) -> str:\n        \"\"\"The user principal or service principal name of the account.\n\n        :rtype: str\n        \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_auth_record.py"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 46,
                  "endLine": 23,
                  "endColumn": 55,
                  "snippet": {
                    "text": "    :param str client_id: The client ID of the application which performed the original authentication.\n    :param str authority: The authority host used to authenticate the account.\n    :param str home_account_id: A unique identifier of the account.\n    :param str username: The user principal or service principal name of the account.\n    \"\"\"\n\n    def __init__(self, tenant_id: str, client_id: str, authority: str, home_account_id: str, username: str) -> None:\n",
                    "rendered": {
                      "text": "    :param str client_id: The client ID of the application which performed the original authentication.\n    :param str authority: The authority host used to authenticate the account.\n    :param str home_account_id: A unique identifier of the account.\n    :param str username: The user principal or service principal name of the account.\n    \"\"\"\n\n    def __init__(self, tenant_id: str, client_id: str, authority: str, home_account_id: str, username: str) -> None:\n",
                      "markdown": "`    :param str client_id: The client ID of the application which performed the original authentication.\n    :param str authority: The authority host used to authenticate the account.\n    :param str home_account_id: A unique identifier of the account.\n    :param str username: The user principal or service principal name of the account.\n    \"\"\"\n\n    def __init__(self, tenant_id: str, client_id: str, authority: str, home_account_id: str, username: str) -> None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 83,
                  "startColumn": 42,
                  "endLine": 83,
                  "endColumn": 47,
                  "snippet": {
                    "text": "            set_variables = [v for v in expected_variables if v in os.environ]\n            if set_variables:\n                _LOGGER.log(\n                    logging.INFO if kwargs.get(\"_within_dac\") else logging.WARNING,\n                    \"Incomplete environment configuration for EnvironmentCredential. These variables are set: %s\",\n                    \", \".join(set_variables),\n                )\n",
                    "rendered": {
                      "text": "            set_variables = [v for v in expected_variables if v in os.environ]\n            if set_variables:\n                _LOGGER.log(\n                    logging.INFO if kwargs.get(\"_within_dac\") else logging.WARNING,\n                    \"Incomplete environment configuration for EnvironmentCredential. These variables are set: %s\",\n                    \", \".join(set_variables),\n                )\n",
                      "markdown": "`            set_variables = [v for v in expected_variables if v in os.environ]\n            if set_variables:\n                _LOGGER.log(\n                    logging.INFO if kwargs.get(\"_within_dac\") else logging.WARNING,\n                    \"Incomplete environment configuration for EnvironmentCredential. These variables are set: %s\",\n                    \", \".join(set_variables),\n                )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 30,
                  "endLine": 71,
                  "endColumn": 35,
                  "snippet": {
                    "text": "                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n                **kwargs\n            )\n",
                    "rendered": {
                      "text": "                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n                **kwargs\n            )\n",
                      "markdown": "`                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n                **kwargs\n            )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 35,
                  "endLine": 69,
                  "endColumn": 40,
                  "snippet": {
                    "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n",
                    "rendered": {
                      "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n",
                      "markdown": "`                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 64,
                  "startColumn": 27,
                  "endLine": 64,
                  "endColumn": 32,
                  "snippet": {
                    "text": "                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.CERT_VARS):\n            self._credential = CertificateCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n",
                    "rendered": {
                      "text": "                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.CERT_VARS):\n            self._credential = CertificateCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n",
                      "markdown": "`                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.CERT_VARS):\n            self._credential = CertificateCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 25,
                  "endLine": 57,
                  "endColumn": 30,
                  "snippet": {
                    "text": "    def __init__(self, **kwargs: Any) -> None:\n        self._credential: Optional[Union[CertificateCredential, ClientSecretCredential]] = None\n\n        if all(os.environ.get(v) is not None for v in EnvironmentVariables.CLIENT_SECRET_VARS):\n            self._credential = ClientSecretCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                client_secret=os.environ[EnvironmentVariables.AZURE_CLIENT_SECRET],\n",
                    "rendered": {
                      "text": "    def __init__(self, **kwargs: Any) -> None:\n        self._credential: Optional[Union[CertificateCredential, ClientSecretCredential]] = None\n\n        if all(os.environ.get(v) is not None for v in EnvironmentVariables.CLIENT_SECRET_VARS):\n            self._credential = ClientSecretCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                client_secret=os.environ[EnvironmentVariables.AZURE_CLIENT_SECRET],\n",
                      "markdown": "`    def __init__(self, **kwargs: Any) -> None:\n        self._credential: Optional[Union[CertificateCredential, ClientSecretCredential]] = None\n\n        if all(os.environ.get(v) is not None for v in EnvironmentVariables.CLIENT_SECRET_VARS):\n            self._credential = ClientSecretCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                client_secret=os.environ[EnvironmentVariables.AZURE_CLIENT_SECRET],\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 86,
                  "endLine": 69,
                  "endColumn": 94,
                  "snippet": {
                    "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n",
                    "rendered": {
                      "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n",
                      "markdown": "`                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 16,
                  "endLine": 69,
                  "endColumn": 24,
                  "snippet": {
                    "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n",
                    "rendered": {
                      "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n",
                      "markdown": "`                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 58,
                  "endLine": 39,
                  "endColumn": 66,
                  "snippet": {
                    "text": "      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n",
                    "rendered": {
                      "text": "      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n",
                      "markdown": "`      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 35,
                  "endLine": 39,
                  "endColumn": 43,
                  "snippet": {
                    "text": "      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n",
                    "rendered": {
                      "text": "      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n",
                      "markdown": "`      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 31,
                  "endLine": 25,
                  "endColumn": 39,
                  "snippet": {
                    "text": "    \"\"\"A credential configured by environment variables.\n\n    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n",
                    "rendered": {
                      "text": "    \"\"\"A credential configured by environment variables.\n\n    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n",
                      "markdown": "`    \"\"\"A credential configured by environment variables.\n\n    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 144,
                  "startColumn": 60,
                  "endLine": 144,
                  "endColumn": 101,
                  "snippet": {
                    "text": "        :rtype: AccessTokenInfo\n        :return: An AccessTokenInfo instance containing information about the token.\n\n        :raises ~azure.identity.CredentialUnavailableError: environment variable configuration is incomplete.\n        \"\"\"\n        if not self._credential:\n            message = (\n",
                    "rendered": {
                      "text": "        :rtype: AccessTokenInfo\n        :return: An AccessTokenInfo instance containing information about the token.\n\n        :raises ~azure.identity.CredentialUnavailableError: environment variable configuration is incomplete.\n        \"\"\"\n        if not self._credential:\n            message = (\n",
                      "markdown": "`        :rtype: AccessTokenInfo\n        :return: An AccessTokenInfo instance containing information about the token.\n\n        :raises ~azure.identity.CredentialUnavailableError: environment variable configuration is incomplete.\n        \"\"\"\n        if not self._credential:\n            message = (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 118,
                  "startColumn": 60,
                  "endLine": 118,
                  "endColumn": 101,
                  "snippet": {
                    "text": "\n        :return: An access token with the desired scopes.\n        :rtype: ~azure.core.credentials.AccessToken\n        :raises ~azure.identity.CredentialUnavailableError: environment variable configuration is incomplete\n        \"\"\"\n        if not self._credential:\n            message = (\n",
                    "rendered": {
                      "text": "\n        :return: An access token with the desired scopes.\n        :rtype: ~azure.core.credentials.AccessToken\n        :raises ~azure.identity.CredentialUnavailableError: environment variable configuration is incomplete\n        \"\"\"\n        if not self._credential:\n            message = (\n",
                      "markdown": "`\n        :return: An access token with the desired scopes.\n        :rtype: ~azure.core.credentials.AccessToken\n        :raises ~azure.identity.CredentialUnavailableError: environment variable configuration is incomplete\n        \"\"\"\n        if not self._credential:\n            message = (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 23,
                  "endLine": 71,
                  "endColumn": 34,
                  "snippet": {
                    "text": "                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n                **kwargs\n            )\n",
                    "rendered": {
                      "text": "                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n                **kwargs\n            )\n",
                      "markdown": "`                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n                **kwargs\n            )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 28,
                  "endLine": 69,
                  "endColumn": 39,
                  "snippet": {
                    "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n",
                    "rendered": {
                      "text": "                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n",
                      "markdown": "`                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                certificate_path=os.environ[EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PATH],\n                password=os.environ.get(EnvironmentVariables.AZURE_CLIENT_CERTIFICATE_PASSWORD),\n                send_certificate_chain=bool(\n                    os.environ.get(EnvironmentVariables.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN, False)\n                ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 64,
                  "startColumn": 20,
                  "endLine": 64,
                  "endColumn": 31,
                  "snippet": {
                    "text": "                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.CERT_VARS):\n            self._credential = CertificateCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n",
                    "rendered": {
                      "text": "                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.CERT_VARS):\n            self._credential = CertificateCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n",
                      "markdown": "`                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n                **kwargs\n            )\n        elif all(os.environ.get(v) is not None for v in EnvironmentVariables.CERT_VARS):\n            self._credential = CertificateCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                tenant_id=os.environ[EnvironmentVariables.AZURE_TENANT_ID],\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 18,
                  "endLine": 57,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    def __init__(self, **kwargs: Any) -> None:\n        self._credential: Optional[Union[CertificateCredential, ClientSecretCredential]] = None\n\n        if all(os.environ.get(v) is not None for v in EnvironmentVariables.CLIENT_SECRET_VARS):\n            self._credential = ClientSecretCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                client_secret=os.environ[EnvironmentVariables.AZURE_CLIENT_SECRET],\n",
                    "rendered": {
                      "text": "    def __init__(self, **kwargs: Any) -> None:\n        self._credential: Optional[Union[CertificateCredential, ClientSecretCredential]] = None\n\n        if all(os.environ.get(v) is not None for v in EnvironmentVariables.CLIENT_SECRET_VARS):\n            self._credential = ClientSecretCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                client_secret=os.environ[EnvironmentVariables.AZURE_CLIENT_SECRET],\n",
                      "markdown": "`    def __init__(self, **kwargs: Any) -> None:\n        self._credential: Optional[Union[CertificateCredential, ClientSecretCredential]] = None\n\n        if all(os.environ.get(v) is not None for v in EnvironmentVariables.CLIENT_SECRET_VARS):\n            self._credential = ClientSecretCredential(\n                client_id=os.environ[EnvironmentVariables.AZURE_CLIENT_ID],\n                client_secret=os.environ[EnvironmentVariables.AZURE_CLIENT_SECRET],\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 37,
                  "endLine": 48,
                  "endColumn": 65,
                  "snippet": {
                    "text": "\n        .. literalinclude:: ../samples/credential_creation_code_snippets.py\n            :start-after: [START create_environment_credential_async]\n            :end-before: [END create_environment_credential_async]\n            :language: python\n            :dedent: 4\n            :caption: Create an EnvironmentCredential.\n",
                    "rendered": {
                      "text": "\n        .. literalinclude:: ../samples/credential_creation_code_snippets.py\n            :start-after: [START create_environment_credential_async]\n            :end-before: [END create_environment_credential_async]\n            :language: python\n            :dedent: 4\n            :caption: Create an EnvironmentCredential.\n",
                      "markdown": "`\n        .. literalinclude:: ../samples/credential_creation_code_snippets.py\n            :start-after: [START create_environment_credential_async]\n            :end-before: [END create_environment_credential_async]\n            :language: python\n            :dedent: 4\n            :caption: Create an EnvironmentCredential.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 47,
                  "startColumn": 40,
                  "endLine": 47,
                  "endColumn": 68,
                  "snippet": {
                    "text": "    .. admonition:: Example:\n\n        .. literalinclude:: ../samples/credential_creation_code_snippets.py\n            :start-after: [START create_environment_credential_async]\n            :end-before: [END create_environment_credential_async]\n            :language: python\n            :dedent: 4\n",
                    "rendered": {
                      "text": "    .. admonition:: Example:\n\n        .. literalinclude:: ../samples/credential_creation_code_snippets.py\n            :start-after: [START create_environment_credential_async]\n            :end-before: [END create_environment_credential_async]\n            :language: python\n            :dedent: 4\n",
                      "markdown": "`    .. admonition:: Example:\n\n        .. literalinclude:: ../samples/credential_creation_code_snippets.py\n            :start-after: [START create_environment_credential_async]\n            :end-before: [END create_environment_credential_async]\n            :language: python\n            :dedent: 4\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 6,
                  "endLine": 21,
                  "endColumn": 33,
                  "snippet": {
                    "text": "_LOGGER = logging.getLogger(__name__)\n\n\nclass EnvironmentCredential(AsyncContextManager):\n    \"\"\"A credential configured by environment variables.\n\n    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n",
                    "rendered": {
                      "text": "_LOGGER = logging.getLogger(__name__)\n\n\nclass EnvironmentCredential(AsyncContextManager):\n    \"\"\"A credential configured by environment variables.\n\n    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n",
                      "markdown": "`_LOGGER = logging.getLogger(__name__)\n\n\nclass EnvironmentCredential(AsyncContextManager):\n    \"\"\"A credential configured by environment variables.\n\n    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 136,
                  "startColumn": 83,
                  "endLine": 136,
                  "endColumn": 87,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scope for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scope for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scope for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 84,
                  "endLine": 109,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 32,
                  "endLine": 37,
                  "endColumn": 41,
                  "snippet": {
                    "text": "\n    Service principal with certificate:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n",
                    "rendered": {
                      "text": "\n    Service principal with certificate:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n",
                      "markdown": "`\n    Service principal with certificate:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 38,
                  "endLine": 36,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        when no value is given.\n\n    Service principal with certificate:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n",
                    "rendered": {
                      "text": "        when no value is given.\n\n    Service principal with certificate:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n",
                      "markdown": "`        when no value is given.\n\n    Service principal with certificate:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n      - **AZURE_CLIENT_CERTIFICATE_PASSWORD**: (optional) password of the certificate file, if any.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 3,
                  "endLine": 35,
                  "endColumn": 12,
                  "snippet": {
                    "text": "        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n\n    Service principal with certificate:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n",
                    "rendered": {
                      "text": "        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n\n    Service principal with certificate:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n",
                      "markdown": "`        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n\n    Service principal with certificate:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_CERTIFICATE_PATH**: path to a PEM or PKCS12 certificate file including the private key.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 30,
                  "startColumn": 43,
                  "endLine": 30,
                  "endColumn": 52,
                  "snippet": {
                    "text": "    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n",
                    "rendered": {
                      "text": "    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n",
                      "markdown": "`    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n        when no value is given.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 32,
                  "endLine": 29,
                  "endColumn": 41,
                  "snippet": {
                    "text": "\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n",
                    "rendered": {
                      "text": "\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n",
                      "markdown": "`\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n        \"login.microsoftonline.com\", the authority for Azure Public Cloud, which is the default\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 38,
                  "endLine": 28,
                  "endColumn": 47,
                  "snippet": {
                    "text": "    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n",
                    "rendered": {
                      "text": "    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n",
                      "markdown": "`    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n      - **AZURE_AUTHORITY_HOST**: authority of a Microsoft Entra endpoint, for example\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 3,
                  "endLine": 27,
                  "endColumn": 12,
                  "snippet": {
                    "text": "    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n",
                    "rendered": {
                      "text": "    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n",
                      "markdown": "`    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n      - **AZURE_TENANT_ID**: ID of the service principal's tenant. Also called its 'directory' ID.\n      - **AZURE_CLIENT_ID**: the service principal's client ID\n      - **AZURE_CLIENT_SECRET**: one of the service principal's client secrets\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/environment.py"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 53,
                  "endLine": 24,
                  "endColumn": 62,
                  "snippet": {
                    "text": "class EnvironmentCredential(AsyncContextManager):\n    \"\"\"A credential configured by environment variables.\n\n    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n",
                    "rendered": {
                      "text": "class EnvironmentCredential(AsyncContextManager):\n    \"\"\"A credential configured by environment variables.\n\n    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n",
                      "markdown": "`class EnvironmentCredential(AsyncContextManager):\n    \"\"\"A credential configured by environment variables.\n\n    This credential is capable of authenticating as a service principal using a client secret or a certificate, or as\n    a user with a username and password. Configuration is attempted in this order, using these environment variables:\n\n    Service principal with secret:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 29,
                  "endLine": 142,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        if not exclude_environment_credential:\n            credentials.append(EnvironmentCredential(authority=authority, _within_dac=True, **kwargs))\n        if not exclude_workload_identity_credential:\n            if all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS):\n                client_id = workload_identity_client_id\n                credentials.append(\n                    WorkloadIdentityCredential(\n",
                    "rendered": {
                      "text": "        if not exclude_environment_credential:\n            credentials.append(EnvironmentCredential(authority=authority, _within_dac=True, **kwargs))\n        if not exclude_workload_identity_credential:\n            if all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS):\n                client_id = workload_identity_client_id\n                credentials.append(\n                    WorkloadIdentityCredential(\n",
                      "markdown": "`        if not exclude_environment_credential:\n            credentials.append(EnvironmentCredential(authority=authority, _within_dac=True, **kwargs))\n        if not exclude_workload_identity_credential:\n            if all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS):\n                client_id = workload_identity_client_id\n                credentials.append(\n                    WorkloadIdentityCredential(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 54,
                  "endLine": 123,
                  "endColumn": 59,
                  "snippet": {
                    "text": "        )\n\n        vscode_tenant_id = kwargs.pop(\n            \"visual_studio_code_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        process_timeout = kwargs.pop(\"process_timeout\", 10)\n",
                    "rendered": {
                      "text": "        )\n\n        vscode_tenant_id = kwargs.pop(\n            \"visual_studio_code_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        process_timeout = kwargs.pop(\"process_timeout\", 10)\n",
                      "markdown": "`        )\n\n        vscode_tenant_id = kwargs.pop(\n            \"visual_studio_code_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        process_timeout = kwargs.pop(\"process_timeout\", 10)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 119,
                  "startColumn": 53,
                  "endLine": 119,
                  "endColumn": 58,
                  "snippet": {
                    "text": "        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n            \"workload_identity_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        vscode_tenant_id = kwargs.pop(\n",
                    "rendered": {
                      "text": "        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n            \"workload_identity_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        vscode_tenant_id = kwargs.pop(\n",
                      "markdown": "`        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n            \"workload_identity_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        vscode_tenant_id = kwargs.pop(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 115,
                  "startColumn": 52,
                  "endLine": 115,
                  "endColumn": 57,
                  "snippet": {
                    "text": "        )\n\n        managed_identity_client_id = kwargs.pop(\n            \"managed_identity_client_id\", os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n",
                    "rendered": {
                      "text": "        )\n\n        managed_identity_client_id = kwargs.pop(\n            \"managed_identity_client_id\", os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n",
                      "markdown": "`        )\n\n        managed_identity_client_id = kwargs.pop(\n            \"managed_identity_client_id\", os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 48,
                  "endLine": 111,
                  "endColumn": 53,
                  "snippet": {
                    "text": "\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        managed_identity_client_id = kwargs.pop(\n",
                    "rendered": {
                      "text": "\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        managed_identity_client_id = kwargs.pop(\n",
                      "markdown": "`\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        managed_identity_client_id = kwargs.pop(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 78,
                  "endLine": 109,
                  "endColumn": 83,
                  "snippet": {
                    "text": "\n        authority = normalize_authority(authority) if authority else get_default_authority()\n\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n",
                    "rendered": {
                      "text": "\n        authority = normalize_authority(authority) if authority else get_default_authority()\n\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n",
                      "markdown": "`\n        authority = normalize_authority(authority) if authority else get_default_authority()\n\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 54,
                  "endLine": 99,
                  "endColumn": 59,
                  "snippet": {
                    "text": "        authority = kwargs.pop(\"authority\", None)\n\n        vscode_tenant_id = kwargs.pop(\n            \"visual_studio_code_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n        vscode_args = dict(kwargs)\n        if authority:\n",
                    "rendered": {
                      "text": "        authority = kwargs.pop(\"authority\", None)\n\n        vscode_tenant_id = kwargs.pop(\n            \"visual_studio_code_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n        vscode_args = dict(kwargs)\n        if authority:\n",
                      "markdown": "`        authority = kwargs.pop(\"authority\", None)\n\n        vscode_tenant_id = kwargs.pop(\n            \"visual_studio_code_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n        vscode_args = dict(kwargs)\n        if authority:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 22,
                  "endLine": 142,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        if not exclude_environment_credential:\n            credentials.append(EnvironmentCredential(authority=authority, _within_dac=True, **kwargs))\n        if not exclude_workload_identity_credential:\n            if all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS):\n                client_id = workload_identity_client_id\n                credentials.append(\n                    WorkloadIdentityCredential(\n",
                    "rendered": {
                      "text": "        if not exclude_environment_credential:\n            credentials.append(EnvironmentCredential(authority=authority, _within_dac=True, **kwargs))\n        if not exclude_workload_identity_credential:\n            if all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS):\n                client_id = workload_identity_client_id\n                credentials.append(\n                    WorkloadIdentityCredential(\n",
                      "markdown": "`        if not exclude_environment_credential:\n            credentials.append(EnvironmentCredential(authority=authority, _within_dac=True, **kwargs))\n        if not exclude_workload_identity_credential:\n            if all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS):\n                client_id = workload_identity_client_id\n                credentials.append(\n                    WorkloadIdentityCredential(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 47,
                  "endLine": 123,
                  "endColumn": 58,
                  "snippet": {
                    "text": "        )\n\n        vscode_tenant_id = kwargs.pop(\n            \"visual_studio_code_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        process_timeout = kwargs.pop(\"process_timeout\", 10)\n",
                    "rendered": {
                      "text": "        )\n\n        vscode_tenant_id = kwargs.pop(\n            \"visual_studio_code_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        process_timeout = kwargs.pop(\"process_timeout\", 10)\n",
                      "markdown": "`        )\n\n        vscode_tenant_id = kwargs.pop(\n            \"visual_studio_code_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        process_timeout = kwargs.pop(\"process_timeout\", 10)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 119,
                  "startColumn": 46,
                  "endLine": 119,
                  "endColumn": 57,
                  "snippet": {
                    "text": "        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n            \"workload_identity_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        vscode_tenant_id = kwargs.pop(\n",
                    "rendered": {
                      "text": "        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n            \"workload_identity_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        vscode_tenant_id = kwargs.pop(\n",
                      "markdown": "`        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n            \"workload_identity_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        vscode_tenant_id = kwargs.pop(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 115,
                  "startColumn": 45,
                  "endLine": 115,
                  "endColumn": 56,
                  "snippet": {
                    "text": "        )\n\n        managed_identity_client_id = kwargs.pop(\n            \"managed_identity_client_id\", os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n",
                    "rendered": {
                      "text": "        )\n\n        managed_identity_client_id = kwargs.pop(\n            \"managed_identity_client_id\", os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n",
                      "markdown": "`        )\n\n        managed_identity_client_id = kwargs.pop(\n            \"managed_identity_client_id\", os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 41,
                  "endLine": 111,
                  "endColumn": 52,
                  "snippet": {
                    "text": "\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        managed_identity_client_id = kwargs.pop(\n",
                    "rendered": {
                      "text": "\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        managed_identity_client_id = kwargs.pop(\n",
                      "markdown": "`\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        managed_identity_client_id = kwargs.pop(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 71,
                  "endLine": 109,
                  "endColumn": 82,
                  "snippet": {
                    "text": "\n        authority = normalize_authority(authority) if authority else get_default_authority()\n\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n",
                    "rendered": {
                      "text": "\n        authority = normalize_authority(authority) if authority else get_default_authority()\n\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n",
                      "markdown": "`\n        authority = normalize_authority(authority) if authority else get_default_authority()\n\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 47,
                  "endLine": 99,
                  "endColumn": 58,
                  "snippet": {
                    "text": "        authority = kwargs.pop(\"authority\", None)\n\n        vscode_tenant_id = kwargs.pop(\n            \"visual_studio_code_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n        vscode_args = dict(kwargs)\n        if authority:\n",
                    "rendered": {
                      "text": "        authority = kwargs.pop(\"authority\", None)\n\n        vscode_tenant_id = kwargs.pop(\n            \"visual_studio_code_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n        vscode_args = dict(kwargs)\n        if authority:\n",
                      "markdown": "`        authority = kwargs.pop(\"authority\", None)\n\n        vscode_tenant_id = kwargs.pop(\n            \"visual_studio_code_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n        vscode_args = dict(kwargs)\n        if authority:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 26,
                  "endLine": 56,
                  "endColumn": 84,
                  "snippet": {
                    "text": "alse**.\n    :keyword bool exclude_developer_cli_credential: Whether to exclude the Azure Developer CLI\n        from the credential. Defaults to **False**.\n    :keyword bool exclude_cli_credential: Whether to exclude the Azure CLI from the credential. Defaults to **False**.\n    :keyword bool exclude_environment_credential: Whether to exclude a service principal configured by environment\n        variables from the credential. Defaults to **False**.\n    :keyword bool exclude_powershell_credential: Whether to exclude Azure PowerShell. Defaults to **False**.\n    :keyword bool exclude_visual_studio_code_credential: Whether to exclude stored credential from",
                    "rendered": {
                      "text": "alse**.\n    :keyword bool exclude_developer_cli_credential: Whether to exclude the Azure Developer CLI\n        from the credential. Defaults to **False**.\n    :keyword bool exclude_cli_credential: Whether to exclude the Azure CLI from the credential. Defaults to **False**.\n    :keyword bool exclude_environment_credential: Whether to exclude a service principal configured by environment\n        variables from the credential. Defaults to **False**.\n    :keyword bool exclude_powershell_credential: Whether to exclude Azure PowerShell. Defaults to **False**.\n    :keyword bool exclude_visual_studio_code_credential: Whether to exclude stored credential from",
                      "markdown": "`alse**.\n    :keyword bool exclude_developer_cli_credential: Whether to exclude the Azure Developer CLI\n        from the credential. Defaults to **False**.\n    :keyword bool exclude_cli_credential: Whether to exclude the Azure CLI from the credential. Defaults to **False**.\n    :keyword bool exclude_environment_credential: Whether to exclude a service principal configured by environment\n        variables from the credential. Defaults to **False**.\n    :keyword bool exclude_powershell_credential: Whether to exclude Azure PowerShell. Defaults to **False**.\n    :keyword bool exclude_visual_studio_code_credential: Whether to exclude stored credential from`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 219,
                  "startColumn": 84,
                  "endLine": 219,
                  "endColumn": 88,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 187,
                  "startColumn": 84,
                  "endLine": 187,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 37,
                  "endLine": 79,
                  "endColumn": 46,
                  "snippet": {
                    "text": "        :class:`~azure.identity.aio.VisualStudioCodeCredential`. Defaults to the \"Azure: Tenant\" setting in VS Code's\n        user settings or, when that setting has no value, the \"organizations\" tenant, which supports only Azure Active\n        Directory work or school accounts.\n    :keyword int process_timeout: The timeout in seconds to use for developer credentials that run\n        subprocesses (e.g. AzureCliCredential, AzurePowerShellCredential). Defaults to **10** seconds.\n\n    .. admonition:: Example:\n",
                    "rendered": {
                      "text": "        :class:`~azure.identity.aio.VisualStudioCodeCredential`. Defaults to the \"Azure: Tenant\" setting in VS Code's\n        user settings or, when that setting has no value, the \"organizations\" tenant, which supports only Azure Active\n        Directory work or school accounts.\n    :keyword int process_timeout: The timeout in seconds to use for developer credentials that run\n        subprocesses (e.g. AzureCliCredential, AzurePowerShellCredential). Defaults to **10** seconds.\n\n    .. admonition:: Example:\n",
                      "markdown": "`        :class:`~azure.identity.aio.VisualStudioCodeCredential`. Defaults to the \"Azure: Tenant\" setting in VS Code's\n        user settings or, when that setting has no value, the \"organizations\" tenant, which supports only Azure Active\n        Directory work or school accounts.\n    :keyword int process_timeout: The timeout in seconds to use for developer credentials that run\n        subprocesses (e.g. AzureCliCredential, AzurePowerShellCredential). Defaults to **10** seconds.\n\n    .. admonition:: Example:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 70,
                  "endLine": 56,
                  "endColumn": 79,
                  "snippet": {
                    "text": "cli_credential: Whether to exclude the Azure Developer CLI\n        from the credential. Defaults to **False**.\n    :keyword bool exclude_cli_credential: Whether to exclude the Azure CLI from the credential. Defaults to **False**.\n    :keyword bool exclude_environment_credential: Whether to exclude a service principal configured by environment\n        variables from the credential. Defaults to **False**.\n    :keyword bool exclude_powershell_credential: Whether to exclude Azure PowerShell. Defaults to **False**.\n    :keyword bool exclude_visual_studio_code_credential: Whether to exclude stored credential",
                    "rendered": {
                      "text": "cli_credential: Whether to exclude the Azure Developer CLI\n        from the credential. Defaults to **False**.\n    :keyword bool exclude_cli_credential: Whether to exclude the Azure CLI from the credential. Defaults to **False**.\n    :keyword bool exclude_environment_credential: Whether to exclude a service principal configured by environment\n        variables from the credential. Defaults to **False**.\n    :keyword bool exclude_powershell_credential: Whether to exclude Azure PowerShell. Defaults to **False**.\n    :keyword bool exclude_visual_studio_code_credential: Whether to exclude stored credential",
                      "markdown": "`cli_credential: Whether to exclude the Azure Developer CLI\n        from the credential. Defaults to **False**.\n    :keyword bool exclude_cli_credential: Whether to exclude the Azure CLI from the credential. Defaults to **False**.\n    :keyword bool exclude_environment_credential: Whether to exclude a service principal configured by environment\n        variables from the credential. Defaults to **False**.\n    :keyword bool exclude_powershell_credential: Whether to exclude Azure PowerShell. Defaults to **False**.\n    :keyword bool exclude_visual_studio_code_credential: Whether to exclude stored credential`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/default.py"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 8,
                  "endLine": 34,
                  "endColumn": 17,
                  "snippet": {
                    "text": "    The identity it uses depends on the environment. When an access token is needed, it requests one using these\n    identities in turn, stopping when one provides a token:\n\n    1. A service principal configured by environment variables. See :class:`~azure.identity.aio.EnvironmentCredential`\n       for more details.\n    2. WorkloadIdentityCredential if environment variable configuration is set by the Azure workload\n       identity webhook.\n",
                    "rendered": {
                      "text": "    The identity it uses depends on the environment. When an access token is needed, it requests one using these\n    identities in turn, stopping when one provides a token:\n\n    1. A service principal configured by environment variables. See :class:`~azure.identity.aio.EnvironmentCredential`\n       for more details.\n    2. WorkloadIdentityCredential if environment variable configuration is set by the Azure workload\n       identity webhook.\n",
                      "markdown": "`    The identity it uses depends on the environment. When an access token is needed, it requests one using these\n    identities in turn, stopping when one provides a token:\n\n    1. A service principal configured by environment variables. See :class:`~azure.identity.aio.EnvironmentCredential`\n       for more details.\n    2. WorkloadIdentityCredential if environment variable configuration is set by the Azure workload\n       identity webhook.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/cloud_shell.py"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 24,
                  "endLine": 21,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n        url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n        if url:\n            return AsyncManagedIdentityClient(\n                request_factory=functools.partial(_get_request, url), base_headers={\"Metadata\": \"true\"}, **kwargs\n",
                    "rendered": {
                      "text": "        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n        url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n        if url:\n            return AsyncManagedIdentityClient(\n                request_factory=functools.partial(_get_request, url), base_headers={\"Metadata\": \"true\"}, **kwargs\n",
                      "markdown": "`        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n        url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n        if url:\n            return AsyncManagedIdentityClient(\n                request_factory=functools.partial(_get_request, url), base_headers={\"Metadata\": \"true\"}, **kwargs\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/cloud_shell.py"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 32,
                  "endLine": 18,
                  "endColumn": 37,
                  "snippet": {
                    "text": "class CloudShellCredential(AsyncManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[AsyncManagedIdentityClient]:\n        client_id = kwargs.get(\"client_id\")\n        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n        url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n",
                    "rendered": {
                      "text": "class CloudShellCredential(AsyncManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[AsyncManagedIdentityClient]:\n        client_id = kwargs.get(\"client_id\")\n        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n        url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n",
                      "markdown": "`class CloudShellCredential(AsyncManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[AsyncManagedIdentityClient]:\n        client_id = kwargs.get(\"client_id\")\n        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n        url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/cloud_shell.py"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 26,
                  "endLine": 17,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\nclass CloudShellCredential(AsyncManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[AsyncManagedIdentityClient]:\n        client_id = kwargs.get(\"client_id\")\n        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n",
                    "rendered": {
                      "text": "\nclass CloudShellCredential(AsyncManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[AsyncManagedIdentityClient]:\n        client_id = kwargs.get(\"client_id\")\n        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n",
                      "markdown": "`\nclass CloudShellCredential(AsyncManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[AsyncManagedIdentityClient]:\n        client_id = kwargs.get(\"client_id\")\n        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/cloud_shell.py"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 17,
                  "endLine": 21,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n        url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n        if url:\n            return AsyncManagedIdentityClient(\n                request_factory=functools.partial(_get_request, url), base_headers={\"Metadata\": \"true\"}, **kwargs\n",
                    "rendered": {
                      "text": "        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n        url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n        if url:\n            return AsyncManagedIdentityClient(\n                request_factory=functools.partial(_get_request, url), base_headers={\"Metadata\": \"true\"}, **kwargs\n",
                      "markdown": "`        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n        url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n        if url:\n            return AsyncManagedIdentityClient(\n                request_factory=functools.partial(_get_request, url), base_headers={\"Metadata\": \"true\"}, **kwargs\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/client_secret.py"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 40,
                  "endLine": 18,
                  "endColumn": 49,
                  "snippet": {
                    "text": "\n    :param str tenant_id: ID of the service principal's tenant. Also called its 'directory' ID.\n    :param str client_id: The service principal's client ID\n    :param str client_secret: One of the service principal's client secrets\n\n    :keyword str authority: Authority of a Microsoft Entra endpoint, for example 'login.microsoftonline.com',\n          the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n",
                    "rendered": {
                      "text": "\n    :param str tenant_id: ID of the service principal's tenant. Also called its 'directory' ID.\n    :param str client_id: The service principal's client ID\n    :param str client_secret: One of the service principal's client secrets\n\n    :keyword str authority: Authority of a Microsoft Entra endpoint, for example 'login.microsoftonline.com',\n          the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n",
                      "markdown": "`\n    :param str tenant_id: ID of the service principal's tenant. Also called its 'directory' ID.\n    :param str client_id: The service principal's client ID\n    :param str client_secret: One of the service principal's client secrets\n\n    :keyword str authority: Authority of a Microsoft Entra endpoint, for example 'login.microsoftonline.com',\n          the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/client_secret.py"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 29,
                  "endLine": 17,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    \"\"\"Authenticates as a service principal using a client secret.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its 'directory' ID.\n    :param str client_id: The service principal's client ID\n    :param str client_secret: One of the service principal's client secrets\n\n    :keyword str authority: Authority of a Microsoft Entra endpoint, for example 'login.microsoftonline.com',\n",
                    "rendered": {
                      "text": "    \"\"\"Authenticates as a service principal using a client secret.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its 'directory' ID.\n    :param str client_id: The service principal's client ID\n    :param str client_secret: One of the service principal's client secrets\n\n    :keyword str authority: Authority of a Microsoft Entra endpoint, for example 'login.microsoftonline.com',\n",
                      "markdown": "`    \"\"\"Authenticates as a service principal using a client secret.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its 'directory' ID.\n    :param str client_id: The service principal's client ID\n    :param str client_secret: One of the service principal's client secrets\n\n    :keyword str authority: Authority of a Microsoft Entra endpoint, for example 'login.microsoftonline.com',\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/client_secret.py"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 35,
                  "endLine": 16,
                  "endColumn": 44,
                  "snippet": {
                    "text": "class ClientSecretCredential(AsyncContextManager, GetTokenMixin):\n    \"\"\"Authenticates as a service principal using a client secret.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its 'directory' ID.\n    :param str client_id: The service principal's client ID\n    :param str client_secret: One of the service principal's client secrets\n\n",
                    "rendered": {
                      "text": "class ClientSecretCredential(AsyncContextManager, GetTokenMixin):\n    \"\"\"Authenticates as a service principal using a client secret.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its 'directory' ID.\n    :param str client_id: The service principal's client ID\n    :param str client_secret: One of the service principal's client secrets\n\n",
                      "markdown": "`class ClientSecretCredential(AsyncContextManager, GetTokenMixin):\n    \"\"\"Authenticates as a service principal using a client secret.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its 'directory' ID.\n    :param str client_id: The service principal's client ID\n    :param str client_secret: One of the service principal's client secrets\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/client_secret.py"
                },
                "region": {
                  "startLine": 14,
                  "startColumn": 25,
                  "endLine": 14,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\n\nclass ClientSecretCredential(AsyncContextManager, GetTokenMixin):\n    \"\"\"Authenticates as a service principal using a client secret.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its 'directory' ID.\n    :param str client_id: The service principal's client ID\n",
                    "rendered": {
                      "text": "\n\nclass ClientSecretCredential(AsyncContextManager, GetTokenMixin):\n    \"\"\"Authenticates as a service principal using a client secret.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its 'directory' ID.\n    :param str client_id: The service principal's client ID\n",
                      "markdown": "`\n\nclass ClientSecretCredential(AsyncContextManager, GetTokenMixin):\n    \"\"\"Authenticates as a service principal using a client secret.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its 'directory' ID.\n    :param str client_id: The service principal's client ID\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aadclient_certificate.py"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 21,
                  "endLine": 46,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        :return: The signature.\n        :rtype: bytes\n        \"\"\"\n        return self._private_key.sign(plaintext, padding.PKCS1v15(), hashes.SHA256())\n",
                    "rendered": {
                      "text": "        :return: The signature.\n        :rtype: bytes\n        \"\"\"\n        return self._private_key.sign(plaintext, padding.PKCS1v15(), hashes.SHA256())\n",
                      "markdown": "`        :return: The signature.\n        :rtype: bytes\n        \"\"\"\n        return self._private_key.sign(plaintext, padding.PKCS1v15(), hashes.SHA256())\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aadclient_certificate.py"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 28,
                  "endLine": 25,
                  "endColumn": 39,
                  "snippet": {
                    "text": "        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n\n        cert = x509.load_pem_x509_certificate(pem_bytes, default_backend())\n        fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n",
                    "rendered": {
                      "text": "        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n\n        cert = x509.load_pem_x509_certificate(pem_bytes, default_backend())\n        fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n",
                      "markdown": "`        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n\n        cert = x509.load_pem_x509_certificate(pem_bytes, default_backend())\n        fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aadclient_certificate.py"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 14,
                  "endLine": 25,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n\n        cert = x509.load_pem_x509_certificate(pem_bytes, default_backend())\n        fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n",
                    "rendered": {
                      "text": "        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n\n        cert = x509.load_pem_x509_certificate(pem_bytes, default_backend())\n        fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n",
                      "markdown": "`        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n\n        cert = x509.load_pem_x509_certificate(pem_bytes, default_backend())\n        fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aadclient_certificate.py"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 42,
                  "endLine": 23,
                  "endColumn": 52,
                  "snippet": {
                    "text": "\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n\n",
                    "rendered": {
                      "text": "\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n\n",
                      "markdown": "`\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aadclient_certificate.py"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 26,
                  "endLine": 23,
                  "endColumn": 37,
                  "snippet": {
                    "text": "\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n\n",
                    "rendered": {
                      "text": "\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n\n",
                      "markdown": "`\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aadclient_certificate.py"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 77,
                  "endLine": 22,
                  "endColumn": 85,
                  "snippet": {
                    "text": "    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n",
                    "rendered": {
                      "text": "    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n",
                      "markdown": "`    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aadclient_certificate.py"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 68,
                  "endLine": 22,
                  "endColumn": 76,
                  "snippet": {
                    "text": "    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n",
                    "rendered": {
                      "text": "    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n",
                      "markdown": "`    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aadclient_certificate.py"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 45,
                  "endLine": 22,
                  "endColumn": 56,
                  "snippet": {
                    "text": "    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n",
                    "rendered": {
                      "text": "    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n",
                      "markdown": "`    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aadclient_certificate.py"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 8,
                  "endLine": 22,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n",
                    "rendered": {
                      "text": "    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n",
                      "markdown": "`    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n        self._private_key = private_key\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aadclient_certificate.py"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 41,
                  "endLine": 21,
                  "endColumn": 49,
                  "snippet": {
                    "text": "    :param bytes password: (optional) the certificate's password\n    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n",
                    "rendered": {
                      "text": "    :param bytes password: (optional) the certificate's password\n    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n",
                      "markdown": "`    :param bytes password: (optional) the certificate's password\n    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n        private_key = serialization.load_pem_private_key(pem_bytes, password=password, backend=default_backend())\n        if not isinstance(private_key, RSAPrivateKey):\n            raise ValueError(\"The certificate must have an RSA private key because RS256 is used for signing\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aadclient_certificate.py"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 56,
                  "endLine": 18,
                  "endColumn": 64,
                  "snippet": {
                    "text": "    \"\"\"Wraps 'cryptography' to provide the crypto operations AadClient requires for certificate authentication.\n\n    :param bytes pem_bytes: bytes of a a PEM-encoded certificate including the (RSA) private key\n    :param bytes password: (optional) the certificate's password\n    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n",
                    "rendered": {
                      "text": "    \"\"\"Wraps 'cryptography' to provide the crypto operations AadClient requires for certificate authentication.\n\n    :param bytes pem_bytes: bytes of a a PEM-encoded certificate including the (RSA) private key\n    :param bytes password: (optional) the certificate's password\n    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n",
                      "markdown": "`    \"\"\"Wraps 'cryptography' to provide the crypto operations AadClient requires for certificate authentication.\n\n    :param bytes pem_bytes: bytes of a a PEM-encoded certificate including the (RSA) private key\n    :param bytes password: (optional) the certificate's password\n    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aadclient_certificate.py"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 17,
                  "endLine": 18,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    \"\"\"Wraps 'cryptography' to provide the crypto operations AadClient requires for certificate authentication.\n\n    :param bytes pem_bytes: bytes of a a PEM-encoded certificate including the (RSA) private key\n    :param bytes password: (optional) the certificate's password\n    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n",
                    "rendered": {
                      "text": "    \"\"\"Wraps 'cryptography' to provide the crypto operations AadClient requires for certificate authentication.\n\n    :param bytes pem_bytes: bytes of a a PEM-encoded certificate including the (RSA) private key\n    :param bytes password: (optional) the certificate's password\n    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n",
                      "markdown": "`    \"\"\"Wraps 'cryptography' to provide the crypto operations AadClient requires for certificate authentication.\n\n    :param bytes pem_bytes: bytes of a a PEM-encoded certificate including the (RSA) private key\n    :param bytes password: (optional) the certificate's password\n    \"\"\"\n\n    def __init__(self, pem_bytes: bytes, password: Optional[bytes] = None) -> None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aadclient_certificate.py"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 61,
                  "endLine": 10,
                  "endColumn": 71,
                  "snippet": {
                    "text": "from cryptography import x509\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import padding\nfrom cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKey\nfrom cryptography.hazmat.backends import default_backend\n\n\n",
                    "rendered": {
                      "text": "from cryptography import x509\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import padding\nfrom cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKey\nfrom cryptography.hazmat.backends import default_backend\n\n\n",
                      "markdown": "`from cryptography import x509\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import padding\nfrom cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKey\nfrom cryptography.hazmat.backends import default_backend\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aadclient_certificate.py"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 27,
                  "endLine": 29,
                  "endColumn": 33,
                  "snippet": {
                    "text": "\n        cert = x509.load_pem_x509_certificate(pem_bytes, default_backend())\n        fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n        self._thumbprint = base64.urlsafe_b64encode(fingerprint).decode(\"utf-8\")\n\n    @property\n    def thumbprint(self) -> str:\n",
                    "rendered": {
                      "text": "\n        cert = x509.load_pem_x509_certificate(pem_bytes, default_backend())\n        fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n        self._thumbprint = base64.urlsafe_b64encode(fingerprint).decode(\"utf-8\")\n\n    @property\n    def thumbprint(self) -> str:\n",
                      "markdown": "`\n        cert = x509.load_pem_x509_certificate(pem_bytes, default_backend())\n        fingerprint = cert.fingerprint(hashes.SHA1())  # nosec\n        self._thumbprint = base64.urlsafe_b64encode(fingerprint).decode(\"utf-8\")\n\n    @property\n    def thumbprint(self) -> str:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aadclient_certificate.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 7,
                  "endLine": 5,
                  "endColumn": 13,
                  "snippet": {
                    "text": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport base64\nfrom typing import Optional\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes, serialization\n",
                    "rendered": {
                      "text": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport base64\nfrom typing import Optional\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes, serialization\n",
                      "markdown": "`# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport base64\nfrom typing import Optional\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes, serialization\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aadclient_certificate.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 6,
                  "endLine": 6,
                  "snippet": {
                    "text": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport base64\nfrom typing import Optional\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import padding\n",
                    "rendered": {
                      "text": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport base64\nfrom typing import Optional\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import padding\n",
                      "markdown": "`# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport base64\nfrom typing import Optional\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import padding\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 351,
                  "startColumn": 63,
                  "endLine": 351,
                  "endColumn": 68,
                  "snippet": {
                    "text": "            \"client_info\": 1,  # request Microsoft Entra ID include home_account_id in its response\n        }\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                    "rendered": {
                      "text": "            \"client_info\": 1,  # request Microsoft Entra ID include home_account_id in its response\n        }\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                      "markdown": "`            \"client_info\": 1,  # request Microsoft Entra ID include home_account_id in its response\n        }\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 351,
                  "startColumn": 29,
                  "endLine": 351,
                  "endColumn": 34,
                  "snippet": {
                    "text": "            \"client_info\": 1,  # request Microsoft Entra ID include home_account_id in its response\n        }\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                    "rendered": {
                      "text": "            \"client_info\": 1,  # request Microsoft Entra ID include home_account_id in its response\n        }\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                      "markdown": "`            \"client_info\": 1,  # request Microsoft Entra ID include home_account_id in its response\n        }\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 328,
                  "startColumn": 63,
                  "endLine": 328,
                  "endColumn": 68,
                  "snippet": {
                    "text": "            data[\"client_secret\"] = client_secret\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                    "rendered": {
                      "text": "            data[\"client_secret\"] = client_secret\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                      "markdown": "`            data[\"client_secret\"] = client_secret\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 328,
                  "startColumn": 29,
                  "endLine": 328,
                  "endColumn": 34,
                  "snippet": {
                    "text": "            data[\"client_secret\"] = client_secret\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                    "rendered": {
                      "text": "            data[\"client_secret\"] = client_secret\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                      "markdown": "`            data[\"client_secret\"] = client_secret\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 297,
                  "startColumn": 63,
                  "endLine": 297,
                  "endColumn": 68,
                  "snippet": {
                    "text": "        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                    "rendered": {
                      "text": "        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                      "markdown": "`        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 297,
                  "startColumn": 29,
                  "endLine": 297,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                    "rendered": {
                      "text": "        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                      "markdown": "`        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 273,
                  "startColumn": 63,
                  "endLine": 273,
                  "endColumn": 68,
                  "snippet": {
                    "text": "        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                    "rendered": {
                      "text": "        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                      "markdown": "`        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 273,
                  "startColumn": 29,
                  "endLine": 273,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                    "rendered": {
                      "text": "        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                      "markdown": "`        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 232,
                  "startColumn": 63,
                  "endLine": 232,
                  "endColumn": 68,
                  "snippet": {
                    "text": "        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                    "rendered": {
                      "text": "        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                      "markdown": "`        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 232,
                  "startColumn": 29,
                  "endLine": 232,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                    "rendered": {
                      "text": "        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                      "markdown": "`        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 212,
                  "startColumn": 63,
                  "endLine": 212,
                  "endColumn": 68,
                  "snippet": {
                    "text": "        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                    "rendered": {
                      "text": "        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                      "markdown": "`        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 212,
                  "startColumn": 29,
                  "endLine": 212,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                    "rendered": {
                      "text": "        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n",
                      "markdown": "`        }\n\n        claims = _merge_claims_challenge_and_capabilities(\n            [\"CP1\"] if kwargs.get(\"enable_cae\") else [], kwargs.get(\"claims\")\n        )\n        if claims:\n            data[\"claims\"] = claims\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 184,
                  "startColumn": 67,
                  "endLine": 184,
                  "endColumn": 72,
                  "snippet": {
                    "text": "\n        refresh_on = request_time + int(content[\"refresh_in\"]) if \"refresh_in\" in content else None\n        token = AccessTokenInfo(\n            content[\"access_token\"], expires_on, token_type=content.get(\"token_type\", \"Bearer\"), refresh_on=refresh_on\n        )\n\n        # caching is the final step because 'add' mutates 'content'\n",
                    "rendered": {
                      "text": "\n        refresh_on = request_time + int(content[\"refresh_in\"]) if \"refresh_in\" in content else None\n        token = AccessTokenInfo(\n            content[\"access_token\"], expires_on, token_type=content.get(\"token_type\", \"Bearer\"), refresh_on=refresh_on\n        )\n\n        # caching is the final step because 'add' mutates 'content'\n",
                      "markdown": "`\n        refresh_on = request_time + int(content[\"refresh_in\"]) if \"refresh_in\" in content else None\n        token = AccessTokenInfo(\n            content[\"access_token\"], expires_on, token_type=content.get(\"token_type\", \"Bearer\"), refresh_on=refresh_on\n        )\n\n        # caching is the final step because 'add' mutates 'content'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 177,
                  "startColumn": 32,
                  "endLine": 177,
                  "endColumn": 37,
                  "snippet": {
                    "text": "            _scrub_secrets(content)\n            raise ClientAuthenticationError(message=\"Unexpected response from Microsoft Entra ID: {}\".format(content))\n\n        expires_in = int(content.get(\"expires_in\") or expires_on - request_time)\n        if \"refresh_in\" not in content and expires_in >= 7200:\n            # MSAL TokenCache expects \"refresh_in\"\n            content[\"refresh_in\"] = expires_in // 2\n",
                    "rendered": {
                      "text": "            _scrub_secrets(content)\n            raise ClientAuthenticationError(message=\"Unexpected response from Microsoft Entra ID: {}\".format(content))\n\n        expires_in = int(content.get(\"expires_in\") or expires_on - request_time)\n        if \"refresh_in\" not in content and expires_in >= 7200:\n            # MSAL TokenCache expects \"refresh_in\"\n            content[\"refresh_in\"] = expires_in // 2\n",
                      "markdown": "`            _scrub_secrets(content)\n            raise ClientAuthenticationError(message=\"Unexpected response from Microsoft Entra ID: {}\".format(content))\n\n        expires_in = int(content.get(\"expires_in\") or expires_on - request_time)\n        if \"refresh_in\" not in content and expires_in >= 7200:\n            # MSAL TokenCache expects \"refresh_in\"\n            content[\"refresh_in\"] = expires_in // 2\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 22,
                  "endLine": 143,
                  "endColumn": 27,
                  "snippet": {
                    "text": "\n        cache = self._get_cache(**kwargs)\n        if response.http_request.body.get(\"grant_type\") == \"refresh_token\":\n            if content.get(\"error\") == \"invalid_grant\":\n                # the request's refresh token is invalid -> evict it from the cache\n                cache_entries = list(\n                    cache.search(\n",
                    "rendered": {
                      "text": "\n        cache = self._get_cache(**kwargs)\n        if response.http_request.body.get(\"grant_type\") == \"refresh_token\":\n            if content.get(\"error\") == \"invalid_grant\":\n                # the request's refresh token is invalid -> evict it from the cache\n                cache_entries = list(\n                    cache.search(\n",
                      "markdown": "`\n        cache = self._get_cache(**kwargs)\n        if response.http_request.body.get(\"grant_type\") == \"refresh_token\":\n            if content.get(\"error\") == \"invalid_grant\":\n                # the request's refresh token is invalid -> evict it from the cache\n                cache_entries = list(\n                    cache.search(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 37,
                  "endLine": 142,
                  "endColumn": 42,
                  "snippet": {
                    "text": "        ) or ContentDecodePolicy.deserialize_from_http_generics(response.http_response)\n\n        cache = self._get_cache(**kwargs)\n        if response.http_request.body.get(\"grant_type\") == \"refresh_token\":\n            if content.get(\"error\") == \"invalid_grant\":\n                # the request's refresh token is invalid -> evict it from the cache\n                cache_entries = list(\n",
                    "rendered": {
                      "text": "        ) or ContentDecodePolicy.deserialize_from_http_generics(response.http_response)\n\n        cache = self._get_cache(**kwargs)\n        if response.http_request.body.get(\"grant_type\") == \"refresh_token\":\n            if content.get(\"error\") == \"invalid_grant\":\n                # the request's refresh token is invalid -> evict it from the cache\n                cache_entries = list(\n",
                      "markdown": "`        ) or ContentDecodePolicy.deserialize_from_http_generics(response.http_response)\n\n        cache = self._get_cache(**kwargs)\n        if response.http_request.body.get(\"grant_type\") == \"refresh_token\":\n            if content.get(\"error\") == \"invalid_grant\":\n                # the request's refresh token is invalid -> evict it from the cache\n                cache_entries = list(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 137,
                  "startColumn": 34,
                  "endLine": 137,
                  "endColumn": 39,
                  "snippet": {
                    "text": "        pass\n\n    def _process_response(self, response: PipelineResponse, request_time: int, **kwargs) -> AccessTokenInfo:\n        content = response.context.get(\n            ContentDecodePolicy.CONTEXT_NAME\n        ) or ContentDecodePolicy.deserialize_from_http_generics(response.http_response)\n\n",
                    "rendered": {
                      "text": "        pass\n\n    def _process_response(self, response: PipelineResponse, request_time: int, **kwargs) -> AccessTokenInfo:\n        content = response.context.get(\n            ContentDecodePolicy.CONTEXT_NAME\n        ) or ContentDecodePolicy.deserialize_from_http_generics(response.http_response)\n\n",
                      "markdown": "`        pass\n\n    def _process_response(self, response: PipelineResponse, request_time: int, **kwargs) -> AccessTokenInfo:\n        content = response.context.get(\n            ContentDecodePolicy.CONTEXT_NAME\n        ) or ContentDecodePolicy.deserialize_from_http_generics(response.http_response)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 65,
                  "endLine": 99,
                  "endColumn": 70,
                  "snippet": {
                    "text": "            if expires_on > int(time.time()):\n                refresh_on = int(token[\"refresh_on\"]) if \"refresh_on\" in token else None\n                return AccessTokenInfo(\n                    token[\"secret\"], expires_on, token_type=token.get(\"token_type\", \"Bearer\"), refresh_on=refresh_on\n                )\n        return None\n\n",
                    "rendered": {
                      "text": "            if expires_on > int(time.time()):\n                refresh_on = int(token[\"refresh_on\"]) if \"refresh_on\" in token else None\n                return AccessTokenInfo(\n                    token[\"secret\"], expires_on, token_type=token.get(\"token_type\", \"Bearer\"), refresh_on=refresh_on\n                )\n        return None\n\n",
                      "markdown": "`            if expires_on > int(time.time()):\n                refresh_on = int(token[\"refresh_on\"]) if \"refresh_on\" in token else None\n                return AccessTokenInfo(\n                    token[\"secret\"], expires_on, token_type=token.get(\"token_type\", \"Bearer\"), refresh_on=refresh_on\n                )\n        return None\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 68,
                  "startColumn": 61,
                  "endLine": 68,
                  "endColumn": 66,
                  "snippet": {
                    "text": "    def _get_cache(self, **kwargs: Any) -> TokenCache:\n        cache = self._cae_cache if kwargs.get(\"enable_cae\") else self._cache\n        if not cache:\n            cache = self._initialize_cache(is_cae=bool(kwargs.get(\"enable_cae\")))\n        return cache\n\n    def _initialize_cache(self, is_cae: bool = False) -> TokenCache:\n",
                    "rendered": {
                      "text": "    def _get_cache(self, **kwargs: Any) -> TokenCache:\n        cache = self._cae_cache if kwargs.get(\"enable_cae\") else self._cache\n        if not cache:\n            cache = self._initialize_cache(is_cae=bool(kwargs.get(\"enable_cae\")))\n        return cache\n\n    def _initialize_cache(self, is_cae: bool = False) -> TokenCache:\n",
                      "markdown": "`    def _get_cache(self, **kwargs: Any) -> TokenCache:\n        cache = self._cae_cache if kwargs.get(\"enable_cae\") else self._cache\n        if not cache:\n            cache = self._initialize_cache(is_cae=bool(kwargs.get(\"enable_cae\")))\n        return cache\n\n    def _initialize_cache(self, is_cae: bool = False) -> TokenCache:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 41,
                  "endLine": 66,
                  "endColumn": 46,
                  "snippet": {
                    "text": "            self._custom_cache = False\n\n    def _get_cache(self, **kwargs: Any) -> TokenCache:\n        cache = self._cae_cache if kwargs.get(\"enable_cae\") else self._cache\n        if not cache:\n            cache = self._initialize_cache(is_cae=bool(kwargs.get(\"enable_cae\")))\n        return cache\n",
                    "rendered": {
                      "text": "            self._custom_cache = False\n\n    def _get_cache(self, **kwargs: Any) -> TokenCache:\n        cache = self._cae_cache if kwargs.get(\"enable_cae\") else self._cache\n        if not cache:\n            cache = self._initialize_cache(is_cae=bool(kwargs.get(\"enable_cae\")))\n        return cache\n",
                      "markdown": "`            self._custom_cache = False\n\n    def _get_cache(self, **kwargs: Any) -> TokenCache:\n        cache = self._cae_cache if kwargs.get(\"enable_cae\") else self._cache\n        if not cache:\n            cache = self._initialize_cache(is_cae=bool(kwargs.get(\"enable_cae\")))\n        return cache\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 255,
                  "startColumn": 33,
                  "endLine": 255,
                  "endColumn": 39,
                  "snippet": {
                    "text": "        ).encode(\"utf-8\")\n        jws = base64.urlsafe_b64encode(header) + b\".\" + base64.urlsafe_b64encode(payload)\n        signature = certificate.sign(jws)\n        jwt_bytes = jws + b\".\" + base64.urlsafe_b64encode(signature)\n        return jwt_bytes.decode(\"utf-8\")\n\n    def _get_client_certificate_request(\n",
                    "rendered": {
                      "text": "        ).encode(\"utf-8\")\n        jws = base64.urlsafe_b64encode(header) + b\".\" + base64.urlsafe_b64encode(payload)\n        signature = certificate.sign(jws)\n        jwt_bytes = jws + b\".\" + base64.urlsafe_b64encode(signature)\n        return jwt_bytes.decode(\"utf-8\")\n\n    def _get_client_certificate_request(\n",
                      "markdown": "`        ).encode(\"utf-8\")\n        jws = base64.urlsafe_b64encode(header) + b\".\" + base64.urlsafe_b64encode(payload)\n        signature = certificate.sign(jws)\n        jwt_bytes = jws + b\".\" + base64.urlsafe_b64encode(signature)\n        return jwt_bytes.decode(\"utf-8\")\n\n    def _get_client_certificate_request(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 253,
                  "startColumn": 56,
                  "endLine": 253,
                  "endColumn": 62,
                  "snippet": {
                    "text": "                \"exp\": now + (60 * 30),\n            }\n        ).encode(\"utf-8\")\n        jws = base64.urlsafe_b64encode(header) + b\".\" + base64.urlsafe_b64encode(payload)\n        signature = certificate.sign(jws)\n        jwt_bytes = jws + b\".\" + base64.urlsafe_b64encode(signature)\n        return jwt_bytes.decode(\"utf-8\")\n",
                    "rendered": {
                      "text": "                \"exp\": now + (60 * 30),\n            }\n        ).encode(\"utf-8\")\n        jws = base64.urlsafe_b64encode(header) + b\".\" + base64.urlsafe_b64encode(payload)\n        signature = certificate.sign(jws)\n        jwt_bytes = jws + b\".\" + base64.urlsafe_b64encode(signature)\n        return jwt_bytes.decode(\"utf-8\")\n",
                      "markdown": "`                \"exp\": now + (60 * 30),\n            }\n        ).encode(\"utf-8\")\n        jws = base64.urlsafe_b64encode(header) + b\".\" + base64.urlsafe_b64encode(payload)\n        signature = certificate.sign(jws)\n        jwt_bytes = jws + b\".\" + base64.urlsafe_b64encode(signature)\n        return jwt_bytes.decode(\"utf-8\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 253,
                  "startColumn": 14,
                  "endLine": 253,
                  "endColumn": 20,
                  "snippet": {
                    "text": "                \"exp\": now + (60 * 30),\n            }\n        ).encode(\"utf-8\")\n        jws = base64.urlsafe_b64encode(header) + b\".\" + base64.urlsafe_b64encode(payload)\n        signature = certificate.sign(jws)\n        jwt_bytes = jws + b\".\" + base64.urlsafe_b64encode(signature)\n        return jwt_bytes.decode(\"utf-8\")\n",
                    "rendered": {
                      "text": "                \"exp\": now + (60 * 30),\n            }\n        ).encode(\"utf-8\")\n        jws = base64.urlsafe_b64encode(header) + b\".\" + base64.urlsafe_b64encode(payload)\n        signature = certificate.sign(jws)\n        jwt_bytes = jws + b\".\" + base64.urlsafe_b64encode(signature)\n        return jwt_bytes.decode(\"utf-8\")\n",
                      "markdown": "`                \"exp\": now + (60 * 30),\n            }\n        ).encode(\"utf-8\")\n        jws = base64.urlsafe_b64encode(header) + b\".\" + base64.urlsafe_b64encode(payload)\n        signature = certificate.sign(jws)\n        jwt_bytes = jws + b\".\" + base64.urlsafe_b64encode(signature)\n        return jwt_bytes.decode(\"utf-8\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 7,
                  "endLine": 6,
                  "endColumn": 13,
                  "snippet": {
                    "text": "# Licensed under the MIT License.\n# ------------------------------------\nimport abc\nimport base64\nimport json\nimport time\nfrom uuid import uuid4\n",
                    "rendered": {
                      "text": "# Licensed under the MIT License.\n# ------------------------------------\nimport abc\nimport base64\nimport json\nimport time\nfrom uuid import uuid4\n",
                      "markdown": "`# Licensed under the MIT License.\n# ------------------------------------\nimport abc\nimport base64\nimport json\nimport time\nfrom uuid import uuid4\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 162,
                  "startColumn": 59,
                  "endLine": 162,
                  "endColumn": 67,
                  "snippet": {
                    "text": "                    )\n                )\n                # If the old token is in multiple cache entries, the cache is in a state we don't\n                # expect or know how to reason about, so we update nothing.\n                if len(cache_entries) == 1:\n                    cache.update_rt(cache_entries[0], content[\"refresh_token\"])\n                    del content[\"refresh_token\"]  # prevent caching a redundant entry\n",
                    "rendered": {
                      "text": "                    )\n                )\n                # If the old token is in multiple cache entries, the cache is in a state we don't\n                # expect or know how to reason about, so we update nothing.\n                if len(cache_entries) == 1:\n                    cache.update_rt(cache_entries[0], content[\"refresh_token\"])\n                    del content[\"refresh_token\"]  # prevent caching a redundant entry\n",
                      "markdown": "`                    )\n                )\n                # If the old token is in multiple cache entries, the cache is in a state we don't\n                # expect or know how to reason about, so we update nothing.\n                if len(cache_entries) == 1:\n                    cache.update_rt(cache_entries[0], content[\"refresh_token\"])\n                    del content[\"refresh_token\"]  # prevent caching a redundant entry\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 154,
                  "startColumn": 68,
                  "endLine": 154,
                  "endColumn": 76,
                  "snippet": {
                    "text": "                for invalid_token in cache_entries:\n                    cache.remove_rt(invalid_token)\n            if \"refresh_token\" in content:\n                # Microsoft Entra ID returned a new refresh token -> update the cache entry\n                cache_entries = list(\n                    cache.search(\n                        TokenCache.CredentialType.REFRESH_TOKEN,\n",
                    "rendered": {
                      "text": "                for invalid_token in cache_entries:\n                    cache.remove_rt(invalid_token)\n            if \"refresh_token\" in content:\n                # Microsoft Entra ID returned a new refresh token -> update the cache entry\n                cache_entries = list(\n                    cache.search(\n                        TokenCache.CredentialType.REFRESH_TOKEN,\n",
                      "markdown": "`                for invalid_token in cache_entries:\n                    cache.remove_rt(invalid_token)\n            if \"refresh_token\" in content:\n                # Microsoft Entra ID returned a new refresh token -> update the cache entry\n                cache_entries = list(\n                    cache.search(\n                        TokenCache.CredentialType.REFRESH_TOKEN,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 162,
                  "startColumn": 17,
                  "endLine": 162,
                  "endColumn": 25,
                  "snippet": {
                    "text": "                    )\n                )\n                # If the old token is in multiple cache entries, the cache is in a state we don't\n                # expect or know how to reason about, so we update nothing.\n                if len(cache_entries) == 1:\n                    cache.update_rt(cache_entries[0], content[\"refresh_token\"])\n                    del content[\"refresh_token\"]  # prevent caching a redundant entry\n",
                    "rendered": {
                      "text": "                    )\n                )\n                # If the old token is in multiple cache entries, the cache is in a state we don't\n                # expect or know how to reason about, so we update nothing.\n                if len(cache_entries) == 1:\n                    cache.update_rt(cache_entries[0], content[\"refresh_token\"])\n                    del content[\"refresh_token\"]  # prevent caching a redundant entry\n",
                      "markdown": "`                    )\n                )\n                # If the old token is in multiple cache entries, the cache is in a state we don't\n                # expect or know how to reason about, so we update nothing.\n                if len(cache_entries) == 1:\n                    cache.update_rt(cache_entries[0], content[\"refresh_token\"])\n                    del content[\"refresh_token\"]  # prevent caching a redundant entry\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 6,
                  "endLine": 9,
                  "snippet": {
                    "text": "import abc\nimport base64\nimport json\nimport time\nfrom uuid import uuid4\nfrom typing import TYPE_CHECKING, List, Any, Iterable, Optional, Union, Dict, cast\n\nfrom msal import TokenCache\n",
                    "rendered": {
                      "text": "import abc\nimport base64\nimport json\nimport time\nfrom uuid import uuid4\nfrom typing import TYPE_CHECKING, List, Any, Iterable, Optional, Union, Dict, cast\n\nfrom msal import TokenCache\n",
                      "markdown": "`import abc\nimport base64\nimport json\nimport time\nfrom uuid import uuid4\nfrom typing import TYPE_CHECKING, List, Any, Iterable, Optional, Union, Dict, cast\n\nfrom msal import TokenCache\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client_base.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 6,
                  "endLine": 7,
                  "snippet": {
                    "text": "# Licensed under the MIT License.\n# ------------------------------------\nimport abc\nimport base64\nimport json\nimport time\nfrom uuid import uuid4\nfrom typing import TYPE_CHECKING, List, Any, Iterable, Optional, Union, Dict, cast\n",
                    "rendered": {
                      "text": "# Licensed under the MIT License.\n# ------------------------------------\nimport abc\nimport base64\nimport json\nimport time\nfrom uuid import uuid4\nfrom typing import TYPE_CHECKING, List, Any, Iterable, Optional, Union, Dict, cast\n",
                      "markdown": "`# Licensed under the MIT License.\n# ------------------------------------\nimport abc\nimport base64\nimport json\nimport time\nfrom uuid import uuid4\nfrom typing import TYPE_CHECKING, List, Any, Iterable, Optional, Union, Dict, cast\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client.py"
                },
                "region": {
                  "startLine": 70,
                  "startColumn": 48,
                  "endLine": 70,
                  "endColumn": 52,
                  "snippet": {
                    "text": "\n    def _run_pipeline(self, request: HttpRequest, **kwargs: Any) -> AccessTokenInfo:\n        # remove tenant_id and claims kwarg that could have been passed from credential's get_token method\n        # tenant_id is already part of `request` at this point\n        kwargs.pop(\"tenant_id\", None)\n        kwargs.pop(\"claims\", None)\n        kwargs.pop(\"client_secret\", None)\n",
                    "rendered": {
                      "text": "\n    def _run_pipeline(self, request: HttpRequest, **kwargs: Any) -> AccessTokenInfo:\n        # remove tenant_id and claims kwarg that could have been passed from credential's get_token method\n        # tenant_id is already part of `request` at this point\n        kwargs.pop(\"tenant_id\", None)\n        kwargs.pop(\"claims\", None)\n        kwargs.pop(\"client_secret\", None)\n",
                      "markdown": "`\n    def _run_pipeline(self, request: HttpRequest, **kwargs: Any) -> AccessTokenInfo:\n        # remove tenant_id and claims kwarg that could have been passed from credential's get_token method\n        # tenant_id is already part of `request` at this point\n        kwargs.pop(\"tenant_id\", None)\n        kwargs.pop(\"claims\", None)\n        kwargs.pop(\"client_secret\", None)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/aad_client.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 6,
                  "endLine": 6,
                  "snippet": {
                    "text": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport time\nfrom typing import Iterable, Union, Optional, Any\n\nfrom azure.core.credentials import AccessTokenInfo\nfrom azure.core.pipeline import Pipeline\n",
                    "rendered": {
                      "text": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport time\nfrom typing import Iterable, Union, Optional, Any\n\nfrom azure.core.credentials import AccessTokenInfo\nfrom azure.core.pipeline import Pipeline\n",
                      "markdown": "`# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport time\nfrom typing import Iterable, Union, Optional, Any\n\nfrom azure.core.credentials import AccessTokenInfo\nfrom azure.core.pipeline import Pipeline\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_powershell.py"
                },
                "region": {
                  "startLine": 230,
                  "startColumn": 17,
                  "endLine": 230,
                  "endColumn": 22,
                  "snippet": {
                    "text": "            _, token, expires_on = line.split(\"%\")\n            return AccessTokenInfo(token, int(expires_on))\n\n    if within_dac.get():\n        raise CredentialUnavailableError(message='Unexpected output from Get-AzAccessToken: \"{}\"'.format(output))\n    raise ClientAuthenticationError(message='Unexpected output from Get-AzAccessToken: \"{}\"'.format(output))\n\n",
                    "rendered": {
                      "text": "            _, token, expires_on = line.split(\"%\")\n            return AccessTokenInfo(token, int(expires_on))\n\n    if within_dac.get():\n        raise CredentialUnavailableError(message='Unexpected output from Get-AzAccessToken: \"{}\"'.format(output))\n    raise ClientAuthenticationError(message='Unexpected output from Get-AzAccessToken: \"{}\"'.format(output))\n\n",
                      "markdown": "`            _, token, expires_on = line.split(\"%\")\n            return AccessTokenInfo(token, int(expires_on))\n\n    if within_dac.get():\n        raise CredentialUnavailableError(message='Unexpected output from Get-AzAccessToken: \"{}\"'.format(output))\n    raise ClientAuthenticationError(message='Unexpected output from Get-AzAccessToken: \"{}\"'.format(output))\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_powershell.py"
                },
                "region": {
                  "startLine": 163,
                  "startColumn": 27,
                  "endLine": 163,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        self, *scopes: str, options: Optional[TokenRequestOptions] = None, **kwargs: Any\n    ) -> AccessTokenInfo:\n\n        tenant_id = options.get(\"tenant_id\") if options else None\n        if tenant_id:\n            validate_tenant_id(tenant_id)\n        for scope in scopes:\n",
                    "rendered": {
                      "text": "        self, *scopes: str, options: Optional[TokenRequestOptions] = None, **kwargs: Any\n    ) -> AccessTokenInfo:\n\n        tenant_id = options.get(\"tenant_id\") if options else None\n        if tenant_id:\n            validate_tenant_id(tenant_id)\n        for scope in scopes:\n",
                      "markdown": "`        self, *scopes: str, options: Optional[TokenRequestOptions] = None, **kwargs: Any\n    ) -> AccessTokenInfo:\n\n        tenant_id = options.get(\"tenant_id\") if options else None\n        if tenant_id:\n            validate_tenant_id(tenant_id)\n        for scope in scopes:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_powershell.py"
                },
                "region": {
                  "startLine": 241,
                  "startColumn": 48,
                  "endLine": 241,
                  "endColumn": 62,
                  "snippet": {
                    "text": "    script = SCRIPT.format(NO_AZ_ACCOUNT_MODULE, resource, tenant_argument)\n    encoded_script = base64.b64encode(script.encode(\"utf-16-le\")).decode()\n\n    command = \"pwsh -NoProfile -NonInteractive -EncodedCommand \" + encoded_script\n    if sys.platform.startswith(\"win\"):\n        return [\"cmd\", \"/c\", command + \" & exit\"]\n    return [\"/bin/sh\", \"-c\", command]\n",
                    "rendered": {
                      "text": "    script = SCRIPT.format(NO_AZ_ACCOUNT_MODULE, resource, tenant_argument)\n    encoded_script = base64.b64encode(script.encode(\"utf-16-le\")).decode()\n\n    command = \"pwsh -NoProfile -NonInteractive -EncodedCommand \" + encoded_script\n    if sys.platform.startswith(\"win\"):\n        return [\"cmd\", \"/c\", command + \" & exit\"]\n    return [\"/bin/sh\", \"-c\", command]\n",
                      "markdown": "`    script = SCRIPT.format(NO_AZ_ACCOUNT_MODULE, resource, tenant_argument)\n    encoded_script = base64.b64encode(script.encode(\"utf-16-le\")).decode()\n\n    command = \"pwsh -NoProfile -NonInteractive -EncodedCommand \" + encoded_script\n    if sys.platform.startswith(\"win\"):\n        return [\"cmd\", \"/c\", command + \" & exit\"]\n    return [\"/bin/sh\", \"-c\", command]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_powershell.py"
                },
                "region": {
                  "startLine": 239,
                  "startColumn": 21,
                  "endLine": 239,
                  "endColumn": 27,
                  "snippet": {
                    "text": "    tenant_argument = tenant_id if tenant_id else \"\"\n    resource = _scopes_to_resource(*scopes)\n    script = SCRIPT.format(NO_AZ_ACCOUNT_MODULE, resource, tenant_argument)\n    encoded_script = base64.b64encode(script.encode(\"utf-16-le\")).decode()\n\n    command = \"pwsh -NoProfile -NonInteractive -EncodedCommand \" + encoded_script\n    if sys.platform.startswith(\"win\"):\n",
                    "rendered": {
                      "text": "    tenant_argument = tenant_id if tenant_id else \"\"\n    resource = _scopes_to_resource(*scopes)\n    script = SCRIPT.format(NO_AZ_ACCOUNT_MODULE, resource, tenant_argument)\n    encoded_script = base64.b64encode(script.encode(\"utf-16-le\")).decode()\n\n    command = \"pwsh -NoProfile -NonInteractive -EncodedCommand \" + encoded_script\n    if sys.platform.startswith(\"win\"):\n",
                      "markdown": "`    tenant_argument = tenant_id if tenant_id else \"\"\n    resource = _scopes_to_resource(*scopes)\n    script = SCRIPT.format(NO_AZ_ACCOUNT_MODULE, resource, tenant_argument)\n    encoded_script = base64.b64encode(script.encode(\"utf-16-le\")).decode()\n\n    command = \"pwsh -NoProfile -NonInteractive -EncodedCommand \" + encoded_script\n    if sys.platform.startswith(\"win\"):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_powershell.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 7,
                  "endLine": 5,
                  "endColumn": 13,
                  "snippet": {
                    "text": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport base64\nimport logging\nimport subprocess\nimport sys\n",
                    "rendered": {
                      "text": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport base64\nimport logging\nimport subprocess\nimport sys\n",
                      "markdown": "`# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport base64\nimport logging\nimport subprocess\nimport sys\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_powershell.py"
                },
                "region": {
                  "startLine": 202,
                  "startColumn": 88,
                  "endLine": 202,
                  "endColumn": 92,
                  "snippet": {
                    "text": "            proc.kill()\n        error = CredentialUnavailableError(\n            message=\"Failed to invoke PowerShell.\\n\"\n            \"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/powershellcredential/troubleshoot.\"\n        )\n        raise error from ex\n",
                    "rendered": {
                      "text": "            proc.kill()\n        error = CredentialUnavailableError(\n            message=\"Failed to invoke PowerShell.\\n\"\n            \"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/powershellcredential/troubleshoot.\"\n        )\n        raise error from ex\n",
                      "markdown": "`            proc.kill()\n        error = CredentialUnavailableError(\n            message=\"Failed to invoke PowerShell.\\n\"\n            \"To mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/powershellcredential/troubleshoot.\"\n        )\n        raise error from ex\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_powershell.py"
                },
                "region": {
                  "startLine": 238,
                  "startColumn": 3,
                  "endLine": 238,
                  "endColumn": 11,
                  "snippet": {
                    "text": "def get_command_line(scopes: Tuple[str, ...], tenant_id: str) -> List[str]:\n    tenant_argument = tenant_id if tenant_id else \"\"\n    resource = _scopes_to_resource(*scopes)\n    script = SCRIPT.format(NO_AZ_ACCOUNT_MODULE, resource, tenant_argument)\n    encoded_script = base64.b64encode(script.encode(\"utf-16-le\")).decode()\n\n    command = \"pwsh -NoProfile -NonInteractive -EncodedCommand \" + encoded_script\n",
                    "rendered": {
                      "text": "def get_command_line(scopes: Tuple[str, ...], tenant_id: str) -> List[str]:\n    tenant_argument = tenant_id if tenant_id else \"\"\n    resource = _scopes_to_resource(*scopes)\n    script = SCRIPT.format(NO_AZ_ACCOUNT_MODULE, resource, tenant_argument)\n    encoded_script = base64.b64encode(script.encode(\"utf-16-le\")).decode()\n\n    command = \"pwsh -NoProfile -NonInteractive -EncodedCommand \" + encoded_script\n",
                      "markdown": "`def get_command_line(scopes: Tuple[str, ...], tenant_id: str) -> List[str]:\n    tenant_argument = tenant_id if tenant_id else \"\"\n    resource = _scopes_to_resource(*scopes)\n    script = SCRIPT.format(NO_AZ_ACCOUNT_MODULE, resource, tenant_argument)\n    encoded_script = base64.b64encode(script.encode(\"utf-16-le\")).decode()\n\n    command = \"pwsh -NoProfile -NonInteractive -EncodedCommand \" + encoded_script\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_powershell.py"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 75,
                  "endLine": 27,
                  "endColumn": 7,
                  "snippet": {
                    "text": "BLOCKED_BY_EXECUTION_POLICY = \"Execution policy prevented invoking Azure PowerShell\"\nNO_AZ_ACCOUNT_MODULE = \"NO_AZ_ACCOUNT_MODULE\"\nPOWERSHELL_NOT_INSTALLED = \"PowerShell is not installed\"\nRUN_CONNECT_AZ_ACCOUNT = 'Please run \"Connect-AzAccount\" to set up account'\nSCRIPT = \"\"\"$ErrorActionPreference = 'Stop'\n[version]$minimumVersion = '2.2.0'\n\n$m = Import-Module Az.Accounts -MinimumVersion $minimumVersion -PassThru -ErrorAction SilentlyContinue\n",
                    "rendered": {
                      "text": "BLOCKED_BY_EXECUTION_POLICY = \"Execution policy prevented invoking Azure PowerShell\"\nNO_AZ_ACCOUNT_MODULE = \"NO_AZ_ACCOUNT_MODULE\"\nPOWERSHELL_NOT_INSTALLED = \"PowerShell is not installed\"\nRUN_CONNECT_AZ_ACCOUNT = 'Please run \"Connect-AzAccount\" to set up account'\nSCRIPT = \"\"\"$ErrorActionPreference = 'Stop'\n[version]$minimumVersion = '2.2.0'\n\n$m = Import-Module Az.Accounts -MinimumVersion $minimumVersion -PassThru -ErrorAction SilentlyContinue\n",
                      "markdown": "`BLOCKED_BY_EXECUTION_POLICY = \"Execution policy prevented invoking Azure PowerShell\"\nNO_AZ_ACCOUNT_MODULE = \"NO_AZ_ACCOUNT_MODULE\"\nPOWERSHELL_NOT_INSTALLED = \"PowerShell is not installed\"\nRUN_CONNECT_AZ_ACCOUNT = 'Please run \"Connect-AzAccount\" to set up account'\nSCRIPT = \"\"\"$ErrorActionPreference = 'Stop'\n[version]$minimumVersion = '2.2.0'\n\n$m = Import-Module Az.Accounts -MinimumVersion $minimumVersion -PassThru -ErrorAction SilentlyContinue\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_powershell.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 6,
                  "endLine": 6,
                  "snippet": {
                    "text": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport base64\nimport logging\nimport subprocess\nimport sys\nfrom typing import Any, List, Tuple, Optional\n",
                    "rendered": {
                      "text": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport base64\nimport logging\nimport subprocess\nimport sys\nfrom typing import Any, List, Tuple, Optional\n",
                      "markdown": "`# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n# ------------------------------------\nimport base64\nimport logging\nimport subprocess\nimport sys\nfrom typing import Any, List, Tuple, Optional\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 139,
                  "startColumn": 83,
                  "endLine": 139,
                  "endColumn": 87,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scope for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scope for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scope for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 112,
                  "startColumn": 84,
                  "endLine": 112,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 90,
                  "startColumn": 78,
                  "endLine": 90,
                  "endColumn": 82,
                  "snippet": {
                    "text": "        if not system_access_token or not tenant_id or not client_id or not service_connection_id:\n            raise ValueError(\n                \"'tenant_id', 'client_id', 'service_connection_id', and 'system_access_token' must be passed in as \"\n                f\"keyword arguments. Please refer to the troubleshooting guide at {TROUBLESHOOTING_GUIDE}.\"\n            )\n        validate_tenant_id(tenant_id)\n        self._system_access_token = system_access_token\n",
                    "rendered": {
                      "text": "        if not system_access_token or not tenant_id or not client_id or not service_connection_id:\n            raise ValueError(\n                \"'tenant_id', 'client_id', 'service_connection_id', and 'system_access_token' must be passed in as \"\n                f\"keyword arguments. Please refer to the troubleshooting guide at {TROUBLESHOOTING_GUIDE}.\"\n            )\n        validate_tenant_id(tenant_id)\n        self._system_access_token = system_access_token\n",
                      "markdown": "`        if not system_access_token or not tenant_id or not client_id or not service_connection_id:\n            raise ValueError(\n                \"'tenant_id', 'client_id', 'service_connection_id', and 'system_access_token' must be passed in as \"\n                f\"keyword arguments. Please refer to the troubleshooting guide at {TROUBLESHOOTING_GUIDE}.\"\n            )\n        validate_tenant_id(tenant_id)\n        self._system_access_token = system_access_token\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 42,
                  "startColumn": 35,
                  "endLine": 42,
                  "endColumn": 39,
                  "snippet": {
                    "text": "            message=f\"Missing value for the {SYSTEM_OIDCREQUESTURI} environment variable. \"\n            f\"AzurePipelinesCredential is intended for use in Azure Pipelines where the \"\n            f\"{SYSTEM_OIDCREQUESTURI} environment variable is set. Please refer to the \"\n            f\"troubleshooting guide at {TROUBLESHOOTING_GUIDE}.\"\n        )\n\n\n",
                    "rendered": {
                      "text": "            message=f\"Missing value for the {SYSTEM_OIDCREQUESTURI} environment variable. \"\n            f\"AzurePipelinesCredential is intended for use in Azure Pipelines where the \"\n            f\"{SYSTEM_OIDCREQUESTURI} environment variable is set. Please refer to the \"\n            f\"troubleshooting guide at {TROUBLESHOOTING_GUIDE}.\"\n        )\n\n\n",
                      "markdown": "`            message=f\"Missing value for the {SYSTEM_OIDCREQUESTURI} environment variable. \"\n            f\"AzurePipelinesCredential is intended for use in Azure Pipelines where the \"\n            f\"{SYSTEM_OIDCREQUESTURI} environment variable is set. Please refer to the \"\n            f\"troubleshooting guide at {TROUBLESHOOTING_GUIDE}.\"\n        )\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 26,
                  "endLine": 55,
                  "endColumn": 35,
                  "snippet": {
                    "text": "\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n    :keyword str system_access_token: The pipeline's System.AccessToken value. It is recommended to assign the value\n        of System.AccessToken to a secur",
                    "rendered": {
                      "text": "\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n    :keyword str system_access_token: The pipeline's System.AccessToken value. It is recommended to assign the value\n        of System.AccessToken to a secur",
                      "markdown": "`\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n    :keyword str system_access_token: The pipeline's System.AccessToken value. It is recommended to assign the value\n        of System.AccessToken to a secur`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 73,
                  "endLine": 54,
                  "endColumn": 82,
                  "snippet": {
                    "text": "\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n    :keyword str system_access_token: The pipeline's System.AccessToken value. It is recommended to assign the value\n",
                    "rendered": {
                      "text": "\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n    :keyword str system_access_token: The pipeline's System.AccessToken value. It is recommended to assign the value\n",
                      "markdown": "`\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n    :keyword str system_access_token: The pipeline's System.AccessToken value. It is recommended to assign the value\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 43,
                  "endLine": 54,
                  "endColumn": 52,
                  "snippet": {
                    "text": "\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n    :keyword str system_access_token: The pipeline's System.AccessToken value. It is recommended to assign the value\n",
                    "rendered": {
                      "text": "\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n    :keyword str system_access_token: The pipeline's System.AccessToken value. It is recommended to assign the value\n",
                      "markdown": "`\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n    :keyword str system_access_token: The pipeline's System.AccessToken value. It is recommended to assign the value\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 49,
                  "endLine": 53,
                  "endColumn": 58,
                  "snippet": {
                    "text": "    connections.\n\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n",
                    "rendered": {
                      "text": "    connections.\n\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n",
                      "markdown": "`    connections.\n\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n        is the value of the \"resourceId\" query parameter. Required.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 49,
                  "endLine": 52,
                  "endColumn": 58,
                  "snippet": {
                    "text": "    This credential enables authentication in Azure Pipelines using workload identity federation for Azure service\n    connections.\n\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n",
                    "rendered": {
                      "text": "    This credential enables authentication in Azure Pipelines using workload identity federation for Azure service\n    connections.\n\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n",
                      "markdown": "`    This credential enables authentication in Azure Pipelines using workload identity federation for Azure service\n    connections.\n\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n    :keyword str service_connection_id: The service connection ID for the service connection associated with the\n        pipeline. From the service connection's configuration page URL in the Azure DevOps web portal, the ID\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 106,
                  "endLine": 50,
                  "snippet": {
                    "text": "class AzurePipelinesCredential:\n    \"\"\"Authenticates using Microsoft Entra Workload ID in Azure Pipelines.\n\n    This credential enables authentication in Azure Pipelines using workload identity federation for Azure service\n    connections.\n\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n",
                    "rendered": {
                      "text": "class AzurePipelinesCredential:\n    \"\"\"Authenticates using Microsoft Entra Workload ID in Azure Pipelines.\n\n    This credential enables authentication in Azure Pipelines using workload identity federation for Azure service\n    connections.\n\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n",
                      "markdown": "`class AzurePipelinesCredential:\n    \"\"\"Authenticates using Microsoft Entra Workload ID in Azure Pipelines.\n\n    This credential enables authentication in Azure Pipelines using workload identity federation for Azure service\n    connections.\n\n    :keyword str tenant_id: The tenant ID for the service connection. Required.\n    :keyword str client_id: The client ID for the service connection. Required.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_pipelines.py"
                },
                "region": {
                  "startLine": 30,
                  "startColumn": 22,
                  "endLine": 30,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {access_token}\",\n        # Prevents the service from responding with a redirect HTTP status code (useful for automation).\n        \"X-TFS-FedAuthRedirect\": \"Suppress\",\n    }\n    return HttpRequest(\"POST\", url, headers=headers)\n",
                    "rendered": {
                      "text": "    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {access_token}\",\n        # Prevents the service from responding with a redirect HTTP status code (useful for automation).\n        \"X-TFS-FedAuthRedirect\": \"Suppress\",\n    }\n    return HttpRequest(\"POST\", url, headers=headers)\n",
                      "markdown": "`    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {access_token}\",\n        # Prevents the service from responding with a redirect HTTP status code (useful for automation).\n        \"X-TFS-FedAuthRedirect\": \"Suppress\",\n    }\n    return HttpRequest(\"POST\", url, headers=headers)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/__pycache__/PaxHeaders.0/user_password."
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 87,
                  "endLine": 2,
                  "endColumn": 95,
                  "snippet": {
                    "text": "68 APK-TOOLS.checksum.SHA1=a22993596d665f5b39773dc4eadc0507d4974197\n112 path=usr/lib/python3.12/site-packages/azure/identity/_credentials/__pycache__/user_password.cpython-312.pyc\n",
                    "rendered": {
                      "text": "68 APK-TOOLS.checksum.SHA1=a22993596d665f5b39773dc4eadc0507d4974197\n112 path=usr/lib/python3.12/site-packages/azure/identity/_credentials/__pycache__/user_password.cpython-312.pyc\n",
                      "markdown": "`68 APK-TOOLS.checksum.SHA1=a22993596d665f5b39773dc4eadc0507d4974197\n112 path=usr/lib/python3.12/site-packages/azure/identity/_credentials/__pycache__/user_password.cpython-312.pyc\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/__init__.py"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 13,
                  "endLine": 44,
                  "endColumn": 21,
                  "snippet": {
                    "text": "    \"OnBehalfOfCredential\",\n    \"SharedTokenCacheCredential\",\n    \"AzureCliCredential\",\n    \"UsernamePasswordCredential\",\n    \"WorkloadIdentityCredential\",\n    \"VisualStudioCodeCredential\",\n]\n",
                    "rendered": {
                      "text": "    \"OnBehalfOfCredential\",\n    \"SharedTokenCacheCredential\",\n    \"AzureCliCredential\",\n    \"UsernamePasswordCredential\",\n    \"WorkloadIdentityCredential\",\n    \"VisualStudioCodeCredential\",\n]\n",
                      "markdown": "`    \"OnBehalfOfCredential\",\n    \"SharedTokenCacheCredential\",\n    \"AzureCliCredential\",\n    \"UsernamePasswordCredential\",\n    \"WorkloadIdentityCredential\",\n    \"VisualStudioCodeCredential\",\n]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/__init__.py"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 35,
                  "endLine": 19,
                  "endColumn": 43,
                  "snippet": {
                    "text": "from .azd_cli import AzureDeveloperCliCredential\nfrom .azure_cli import AzureCliCredential\nfrom .device_code import DeviceCodeCredential\nfrom .user_password import UsernamePasswordCredential\nfrom .vscode import VisualStudioCodeCredential\nfrom .client_assertion import ClientAssertionCredential\nfrom .workload_identity import WorkloadIdentityCredential\n",
                    "rendered": {
                      "text": "from .azd_cli import AzureDeveloperCliCredential\nfrom .azure_cli import AzureCliCredential\nfrom .device_code import DeviceCodeCredential\nfrom .user_password import UsernamePasswordCredential\nfrom .vscode import VisualStudioCodeCredential\nfrom .client_assertion import ClientAssertionCredential\nfrom .workload_identity import WorkloadIdentityCredential\n",
                      "markdown": "`from .azd_cli import AzureDeveloperCliCredential\nfrom .azure_cli import AzureCliCredential\nfrom .device_code import DeviceCodeCredential\nfrom .user_password import UsernamePasswordCredential\nfrom .vscode import VisualStudioCodeCredential\nfrom .client_assertion import ClientAssertionCredential\nfrom .workload_identity import WorkloadIdentityCredential\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/__init__.py"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 11,
                  "endLine": 19,
                  "endColumn": 19,
                  "snippet": {
                    "text": "from .azd_cli import AzureDeveloperCliCredential\nfrom .azure_cli import AzureCliCredential\nfrom .device_code import DeviceCodeCredential\nfrom .user_password import UsernamePasswordCredential\nfrom .vscode import VisualStudioCodeCredential\nfrom .client_assertion import ClientAssertionCredential\nfrom .workload_identity import WorkloadIdentityCredential\n",
                    "rendered": {
                      "text": "from .azd_cli import AzureDeveloperCliCredential\nfrom .azure_cli import AzureCliCredential\nfrom .device_code import DeviceCodeCredential\nfrom .user_password import UsernamePasswordCredential\nfrom .vscode import VisualStudioCodeCredential\nfrom .client_assertion import ClientAssertionCredential\nfrom .workload_identity import WorkloadIdentityCredential\n",
                      "markdown": "`from .azd_cli import AzureDeveloperCliCredential\nfrom .azure_cli import AzureCliCredential\nfrom .device_code import DeviceCodeCredential\nfrom .user_password import UsernamePasswordCredential\nfrom .vscode import VisualStudioCodeCredential\nfrom .client_assertion import ClientAssertionCredential\nfrom .workload_identity import WorkloadIdentityCredential\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 93,
                  "endLine": 98,
                  "endColumn": 98,
                  "snippet": {
                    "text": "            except ValueError as ex:\n                message = '\"client_certificate\" is not a valid certificate in PEM or PKCS12 format'\n                raise ValueError(message) from ex\n            self._client_credential = AadClientCertificate(cert[\"private_key\"], password=cert.get(\"passphrase\"))\n        elif client_secret:\n            self._client_credential = client_secret\n        else:\n",
                    "rendered": {
                      "text": "            except ValueError as ex:\n                message = '\"client_certificate\" is not a valid certificate in PEM or PKCS12 format'\n                raise ValueError(message) from ex\n            self._client_credential = AadClientCertificate(cert[\"private_key\"], password=cert.get(\"passphrase\"))\n        elif client_secret:\n            self._client_credential = client_secret\n        else:\n",
                      "markdown": "`            except ValueError as ex:\n                message = '\"client_certificate\" is not a valid certificate in PEM or PKCS12 format'\n                raise ValueError(message) from ex\n            self._client_credential = AadClientCertificate(cert[\"private_key\"], password=cert.get(\"passphrase\"))\n        elif client_secret:\n            self._client_credential = client_secret\n        else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 80,
                  "endLine": 98,
                  "endColumn": 88,
                  "snippet": {
                    "text": "            except ValueError as ex:\n                message = '\"client_certificate\" is not a valid certificate in PEM or PKCS12 format'\n                raise ValueError(message) from ex\n            self._client_credential = AadClientCertificate(cert[\"private_key\"], password=cert.get(\"passphrase\"))\n        elif client_secret:\n            self._client_credential = client_secret\n        else:\n",
                    "rendered": {
                      "text": "            except ValueError as ex:\n                message = '\"client_certificate\" is not a valid certificate in PEM or PKCS12 format'\n                raise ValueError(message) from ex\n            self._client_credential = AadClientCertificate(cert[\"private_key\"], password=cert.get(\"passphrase\"))\n        elif client_secret:\n            self._client_credential = client_secret\n        else:\n",
                      "markdown": "`            except ValueError as ex:\n                message = '\"client_certificate\" is not a valid certificate in PEM or PKCS12 format'\n                raise ValueError(message) from ex\n            self._client_credential = AadClientCertificate(cert[\"private_key\"], password=cert.get(\"passphrase\"))\n        elif client_secret:\n            self._client_credential = client_secret\n        else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 65,
                  "endLine": 98,
                  "endColumn": 76,
                  "snippet": {
                    "text": "            except ValueError as ex:\n                message = '\"client_certificate\" is not a valid certificate in PEM or PKCS12 format'\n                raise ValueError(message) from ex\n            self._client_credential = AadClientCertificate(cert[\"private_key\"], password=cert.get(\"passphrase\"))\n        elif client_secret:\n            self._client_credential = client_secret\n        else:\n",
                    "rendered": {
                      "text": "            except ValueError as ex:\n                message = '\"client_certificate\" is not a valid certificate in PEM or PKCS12 format'\n                raise ValueError(message) from ex\n            self._client_credential = AadClientCertificate(cert[\"private_key\"], password=cert.get(\"passphrase\"))\n        elif client_secret:\n            self._client_credential = client_secret\n        else:\n",
                      "markdown": "`            except ValueError as ex:\n                message = '\"client_certificate\" is not a valid certificate in PEM or PKCS12 format'\n                raise ValueError(message) from ex\n            self._client_credential = AadClientCertificate(cert[\"private_key\"], password=cert.get(\"passphrase\"))\n        elif client_secret:\n            self._client_credential = client_secret\n        else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 51,
                  "endLine": 94,
                  "endColumn": 59,
                  "snippet": {
                    "text": "            if client_secret:\n                raise ValueError('Specifying both \"client_certificate\" and \"client_secret\" is not valid.')\n            try:\n                cert = get_client_credential(None, password, client_certificate)\n            except ValueError as ex:\n                message = '\"client_certificate\" is not a valid certificate in PEM or PKCS12 format'\n                raise ValueError(message) from ex\n",
                    "rendered": {
                      "text": "            if client_secret:\n                raise ValueError('Specifying both \"client_certificate\" and \"client_secret\" is not valid.')\n            try:\n                cert = get_client_credential(None, password, client_certificate)\n            except ValueError as ex:\n                message = '\"client_certificate\" is not a valid certificate in PEM or PKCS12 format'\n                raise ValueError(message) from ex\n",
                      "markdown": "`            if client_secret:\n                raise ValueError('Specifying both \"client_certificate\" and \"client_secret\" is not valid.')\n            try:\n                cert = get_client_credential(None, password, client_certificate)\n            except ValueError as ex:\n                message = '\"client_certificate\" is not a valid certificate in PEM or PKCS12 format'\n                raise ValueError(message) from ex\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 8,
                  "endLine": 71,
                  "endColumn": 16,
                  "snippet": {
                    "text": "        client_secret: Optional[str] = None,\n        client_assertion_func: Optional[Callable[[], str]] = None,\n        user_assertion: str,\n        password: Optional[Union[str, bytes]] = None,\n        **kwargs: Any\n    ) -> None:\n        super().__init__()\n",
                    "rendered": {
                      "text": "        client_secret: Optional[str] = None,\n        client_assertion_func: Optional[Callable[[], str]] = None,\n        user_assertion: str,\n        password: Optional[Union[str, bytes]] = None,\n        **kwargs: Any\n    ) -> None:\n        super().__init__()\n",
                      "markdown": "`        client_secret: Optional[str] = None,\n        client_assertion_func: Optional[Callable[[], str]] = None,\n        user_assertion: str,\n        password: Optional[Union[str, bytes]] = None,\n        **kwargs: Any\n    ) -> None:\n        super().__init__()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 47,
                  "startColumn": 15,
                  "endLine": 47,
                  "endColumn": 23,
                  "snippet": {
                    "text": "    :keyword password: A certificate password. Used only when **client_certificate** is provided. If this value\n        is a unicode string, it will be encoded as UTF-8. If the certificate requires a different encoding, pass\n        appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword List[str] additionally_allowed_tenants: Specifies tenants in addition to the specified \"tenant_id\"\n        for which the credential may acquire tokens. Add the wildcard value \"*\" to allow the credential to\n        acquire tokens for any tenant the application can access.\n",
                    "rendered": {
                      "text": "    :keyword password: A certificate password. Used only when **client_certificate** is provided. If this value\n        is a unicode string, it will be encoded as UTF-8. If the certificate requires a different encoding, pass\n        appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword List[str] additionally_allowed_tenants: Specifies tenants in addition to the specified \"tenant_id\"\n        for which the credential may acquire tokens. Add the wildcard value \"*\" to allow the credential to\n        acquire tokens for any tenant the application can access.\n",
                      "markdown": "`    :keyword password: A certificate password. Used only when **client_certificate** is provided. If this value\n        is a unicode string, it will be encoded as UTF-8. If the certificate requires a different encoding, pass\n        appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n    :keyword List[str] additionally_allowed_tenants: Specifies tenants in addition to the specified \"tenant_id\"\n        for which the credential may acquire tokens. Add the wildcard value \"*\" to allow the credential to\n        acquire tokens for any tenant the application can access.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 37,
                  "endLine": 44,
                  "endColumn": 45,
                  "snippet": {
                    "text": "    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n        defines authorities for other clouds.\n    :keyword password: A certificate password. Used only when **client_certificate** is provided. If this value\n        is a unicode string, it will be encoded as UTF-8. If the certificate requires a different encoding, pass\n        appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n",
                    "rendered": {
                      "text": "    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n        defines authorities for other clouds.\n    :keyword password: A certificate password. Used only when **client_certificate** is provided. If this value\n        is a unicode string, it will be encoded as UTF-8. If the certificate requires a different encoding, pass\n        appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n",
                      "markdown": "`    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n        defines authorities for other clouds.\n    :keyword password: A certificate password. Used only when **client_certificate** is provided. If this value\n        is a unicode string, it will be encoded as UTF-8. If the certificate requires a different encoding, pass\n        appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 13,
                  "endLine": 44,
                  "endColumn": 21,
                  "snippet": {
                    "text": "    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n        defines authorities for other clouds.\n    :keyword password: A certificate password. Used only when **client_certificate** is provided. If this value\n        is a unicode string, it will be encoded as UTF-8. If the certificate requires a different encoding, pass\n        appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n",
                    "rendered": {
                      "text": "    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n        defines authorities for other clouds.\n    :keyword password: A certificate password. Used only when **client_certificate** is provided. If this value\n        is a unicode string, it will be encoded as UTF-8. If the certificate requires a different encoding, pass\n        appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n",
                      "markdown": "`    :keyword str authority: Authority of a Microsoft Entra endpoint, for example \"login.microsoftonline.com\",\n        the authority for Azure Public Cloud (which is the default). :class:`~azure.identity.AzureAuthorityHosts`\n        defines authorities for other clouds.\n    :keyword password: A certificate password. Used only when **client_certificate** is provided. If this value\n        is a unicode string, it will be encoded as UTF-8. If the certificate requires a different encoding, pass\n        appropriately encoded bytes instead.\n    :paramtype password: str or bytes\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 71,
                  "endLine": 35,
                  "endColumn": 77,
                  "snippet": {
                    "text": "vice principal. One of **client_secret**, **client_certificate**,\n        or **client_assertion_func** must be provided.\n    :keyword client_assertion_func: Optional. Function that returns client assertions that authenticate the\n        application to Microsoft Entra ID. This function is called each time the credential requests a token. It must\n        return a valid assertion for the target resource.\n    :paramtype client_assertion_func: Callable[[], str]\n    :keyword str user_assertion: Required. The access token the credential will use as the user assertion when\n        requesting on-behalf-of to",
                    "rendered": {
                      "text": "vice principal. One of **client_secret**, **client_certificate**,\n        or **client_assertion_func** must be provided.\n    :keyword client_assertion_func: Optional. Function that returns client assertions that authenticate the\n        application to Microsoft Entra ID. This function is called each time the credential requests a token. It must\n        return a valid assertion for the target resource.\n    :paramtype client_assertion_func: Callable[[], str]\n    :keyword str user_assertion: Required. The access token the credential will use as the user assertion when\n        requesting on-behalf-of to",
                      "markdown": "`vice principal. One of **client_secret**, **client_certificate**,\n        or **client_assertion_func** must be provided.\n    :keyword client_assertion_func: Optional. Function that returns client assertions that authenticate the\n        application to Microsoft Entra ID. This function is called each time the credential requests a token. It must\n        return a valid assertion for the target resource.\n    :paramtype client_assertion_func: Callable[[], str]\n    :keyword str user_assertion: Required. The access token the credential will use as the user assertion when\n        requesting on-behalf-of to`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 43,
                  "endLine": 32,
                  "endColumn": 52,
                  "snippet": {
                    "text": "et to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n    :keyword bytes client_certificate: Optional. The bytes of a certificate in PEM or PKCS12 format including\n        the private key to authenticate the service principal. One of **client_secret**, **client_certificate**,\n        or **client_assertion_func** must be provided.\n    :keyword client_assertion_func: Optional. Function that returns client assertions that authenticate the\n        application to Microsoft Entra ID. This function is called each time",
                    "rendered": {
                      "text": "et to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n    :keyword bytes client_certificate: Optional. The bytes of a certificate in PEM or PKCS12 format including\n        the private key to authenticate the service principal. One of **client_secret**, **client_certificate**,\n        or **client_assertion_func** must be provided.\n    :keyword client_assertion_func: Optional. Function that returns client assertions that authenticate the\n        application to Microsoft Entra ID. This function is called each time",
                      "markdown": "`et to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n    :keyword bytes client_certificate: Optional. The bytes of a certificate in PEM or PKCS12 format including\n        the private key to authenticate the service principal. One of **client_secret**, **client_certificate**,\n        or **client_assertion_func** must be provided.\n    :keyword client_assertion_func: Optional. Function that returns client assertions that authenticate the\n        application to Microsoft Entra ID. This function is called each time`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 77,
                  "endLine": 29,
                  "endColumn": 86,
                  "snippet": {
                    "text": "\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID.\n    :keyword str client_secret: Optional. A client secret to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n    :keyword bytes client_certificate: Optional. The bytes of a certificate in PEM or PKCS12 format including\n        the private key to authenticate the service principal. One of **client_secret**, **client_certificate**,\n",
                    "rendered": {
                      "text": "\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID.\n    :keyword str client_secret: Optional. A client secret to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n    :keyword bytes client_certificate: Optional. The bytes of a certificate in PEM or PKCS12 format including\n        the private key to authenticate the service principal. One of **client_secret**, **client_certificate**,\n",
                      "markdown": "`\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID.\n    :keyword str client_secret: Optional. A client secret to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n    :keyword bytes client_certificate: Optional. The bytes of a certificate in PEM or PKCS12 format including\n        the private key to authenticate the service principal. One of **client_secret**, **client_certificate**,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 29,
                  "endLine": 28,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    description of the on-behalf-of flow.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID.\n    :keyword str client_secret: Optional. A client secret to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n    :keyword bytes client_certificate: Optional. The bytes of a certificate in PEM or PKCS12 format including\n",
                    "rendered": {
                      "text": "    description of the on-behalf-of flow.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID.\n    :keyword str client_secret: Optional. A client secret to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n    :keyword bytes client_certificate: Optional. The bytes of a certificate in PEM or PKCS12 format including\n",
                      "markdown": "`    description of the on-behalf-of flow.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID.\n    :keyword str client_secret: Optional. A client secret to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n    :keyword bytes client_certificate: Optional. The bytes of a certificate in PEM or PKCS12 format including\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 35,
                  "endLine": 27,
                  "endColumn": 44,
                  "snippet": {
                    "text": "    <https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow>`__ for a more detailed\n    description of the on-behalf-of flow.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID.\n    :keyword str client_secret: Optional. A client secret to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n",
                    "rendered": {
                      "text": "    <https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow>`__ for a more detailed\n    description of the on-behalf-of flow.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID.\n    :keyword str client_secret: Optional. A client secret to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n",
                      "markdown": "`    <https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow>`__ for a more detailed\n    description of the on-behalf-of flow.\n\n    :param str tenant_id: ID of the service principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The service principal's client ID.\n    :keyword str client_secret: Optional. A client secret to authenticate the service principal.\n        One of **client_secret**, **client_certificate**, or **client_assertion_func** must be provided.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/on_behalf_of.py"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 22,
                  "endLine": 19,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n\nclass OnBehalfOfCredential(AsyncContextManager, GetTokenMixin):\n    \"\"\"Authenticates a service principal via the on-behalf-of flow.\n\n    This flow is typically used by middle-tier services that authorize requests to other services with a delegated\n    user identity. Because this is not an interactive authentication flow, an application using it must have admin\n",
                    "rendered": {
                      "text": "\n\nclass OnBehalfOfCredential(AsyncContextManager, GetTokenMixin):\n    \"\"\"Authenticates a service principal via the on-behalf-of flow.\n\n    This flow is typically used by middle-tier services that authorize requests to other services with a delegated\n    user identity. Because this is not an interactive authentication flow, an application using it must have admin\n",
                      "markdown": "`\n\nclass OnBehalfOfCredential(AsyncContextManager, GetTokenMixin):\n    \"\"\"Authenticates a service principal via the on-behalf-of flow.\n\n    This flow is typically used by middle-tier services that authorize requests to other services with a delegated\n    user identity. Because this is not an interactive authentication flow, an application using it must have admin\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 92,
                  "startColumn": 56,
                  "endLine": 92,
                  "endColumn": 61,
                  "snippet": {
                    "text": "            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n            from .workload_identity import WorkloadIdentityCredential\n\n            workload_client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n            if not workload_client_id:\n                raise ValueError('Configure the environment with a client ID or pass a value for \"client_id\" argument')\n\n",
                    "rendered": {
                      "text": "            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n            from .workload_identity import WorkloadIdentityCredential\n\n            workload_client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n            if not workload_client_id:\n                raise ValueError('Configure the environment with a client ID or pass a value for \"client_id\" argument')\n\n",
                      "markdown": "`            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n            from .workload_identity import WorkloadIdentityCredential\n\n            workload_client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n            if not workload_client_id:\n                raise ValueError('Configure the environment with a client ID or pass a value for \"client_id\" argument')\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 26,
                  "endLine": 86,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n                self._credential = CloudShellCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif (\n            all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS)\n            and not exclude_workload_identity\n        ):\n            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n",
                    "rendered": {
                      "text": "\n                self._credential = CloudShellCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif (\n            all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS)\n            and not exclude_workload_identity\n        ):\n            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n",
                      "markdown": "`\n                self._credential = CloudShellCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif (\n            all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS)\n            and not exclude_workload_identity\n        ):\n            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 25,
                  "endLine": 75,
                  "endColumn": 30,
                  "snippet": {
                    "text": "\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n\n",
                    "rendered": {
                      "text": "\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n\n",
                      "markdown": "`\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 23,
                  "endLine": 74,
                  "endColumn": 28,
                  "snippet": {
                    "text": "                from .azure_arc import AzureArcCredential\n\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n",
                    "rendered": {
                      "text": "                from .azure_arc import AzureArcCredential\n\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n",
                      "markdown": "`                from .azure_arc import AzureArcCredential\n\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 27,
                  "endLine": 69,
                  "endColumn": 32,
                  "snippet": {
                    "text": "                    self._credential = AppServiceCredential(\n                        client_id=client_id, identity_config=identity_config, **kwargs\n                    )\n            elif os.environ.get(EnvironmentVariables.IMDS_ENDPOINT):\n                _LOGGER.info(\"%s will use Azure Arc managed identity\", self.__class__.__name__)\n                from .azure_arc import AzureArcCredential\n\n",
                    "rendered": {
                      "text": "                    self._credential = AppServiceCredential(\n                        client_id=client_id, identity_config=identity_config, **kwargs\n                    )\n            elif os.environ.get(EnvironmentVariables.IMDS_ENDPOINT):\n                _LOGGER.info(\"%s will use Azure Arc managed identity\", self.__class__.__name__)\n                from .azure_arc import AzureArcCredential\n\n",
                      "markdown": "`                    self._credential = AppServiceCredential(\n                        client_id=client_id, identity_config=identity_config, **kwargs\n                    )\n            elif os.environ.get(EnvironmentVariables.IMDS_ENDPOINT):\n                _LOGGER.info(\"%s will use Azure Arc managed identity\", self.__class__.__name__)\n                from .azure_arc import AzureArcCredential\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 29,
                  "endLine": 55,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n\n",
                    "rendered": {
                      "text": "\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n\n",
                      "markdown": "`\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 25,
                  "endLine": 54,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n",
                    "rendered": {
                      "text": "        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n",
                      "markdown": "`        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 21,
                  "endLine": 53,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        self._credential: Optional[AsyncSupportsTokenInfo] = None\n        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n",
                    "rendered": {
                      "text": "        self._credential: Optional[AsyncSupportsTokenInfo] = None\n        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n",
                      "markdown": "`        self._credential: Optional[AsyncSupportsTokenInfo] = None\n        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 92,
                  "startColumn": 49,
                  "endLine": 92,
                  "endColumn": 60,
                  "snippet": {
                    "text": "            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n            from .workload_identity import WorkloadIdentityCredential\n\n            workload_client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n            if not workload_client_id:\n                raise ValueError('Configure the environment with a client ID or pass a value for \"client_id\" argument')\n\n",
                    "rendered": {
                      "text": "            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n            from .workload_identity import WorkloadIdentityCredential\n\n            workload_client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n            if not workload_client_id:\n                raise ValueError('Configure the environment with a client ID or pass a value for \"client_id\" argument')\n\n",
                      "markdown": "`            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n            from .workload_identity import WorkloadIdentityCredential\n\n            workload_client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n            if not workload_client_id:\n                raise ValueError('Configure the environment with a client ID or pass a value for \"client_id\" argument')\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 19,
                  "endLine": 86,
                  "endColumn": 30,
                  "snippet": {
                    "text": "\n                self._credential = CloudShellCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif (\n            all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS)\n            and not exclude_workload_identity\n        ):\n            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n",
                    "rendered": {
                      "text": "\n                self._credential = CloudShellCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif (\n            all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS)\n            and not exclude_workload_identity\n        ):\n            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n",
                      "markdown": "`\n                self._credential = CloudShellCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif (\n            all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS)\n            and not exclude_workload_identity\n        ):\n            _LOGGER.info(\"%s will use workload identity\", self.__class__.__name__)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 18,
                  "endLine": 75,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n\n",
                    "rendered": {
                      "text": "\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n\n",
                      "markdown": "`\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 16,
                  "endLine": 74,
                  "endColumn": 27,
                  "snippet": {
                    "text": "                from .azure_arc import AzureArcCredential\n\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n",
                    "rendered": {
                      "text": "                from .azure_arc import AzureArcCredential\n\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n",
                      "markdown": "`                from .azure_arc import AzureArcCredential\n\n                self._credential = AzureArcCredential(client_id=client_id, identity_config=identity_config, **kwargs)\n        elif os.environ.get(EnvironmentVariables.MSI_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.MSI_SECRET):\n                _LOGGER.info(\"%s will use Azure ML managed identity\", self.__class__.__name__)\n                from .azure_ml import AzureMLCredential\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 20,
                  "endLine": 69,
                  "endColumn": 31,
                  "snippet": {
                    "text": "                    self._credential = AppServiceCredential(\n                        client_id=client_id, identity_config=identity_config, **kwargs\n                    )\n            elif os.environ.get(EnvironmentVariables.IMDS_ENDPOINT):\n                _LOGGER.info(\"%s will use Azure Arc managed identity\", self.__class__.__name__)\n                from .azure_arc import AzureArcCredential\n\n",
                    "rendered": {
                      "text": "                    self._credential = AppServiceCredential(\n                        client_id=client_id, identity_config=identity_config, **kwargs\n                    )\n            elif os.environ.get(EnvironmentVariables.IMDS_ENDPOINT):\n                _LOGGER.info(\"%s will use Azure Arc managed identity\", self.__class__.__name__)\n                from .azure_arc import AzureArcCredential\n\n",
                      "markdown": "`                    self._credential = AppServiceCredential(\n                        client_id=client_id, identity_config=identity_config, **kwargs\n                    )\n            elif os.environ.get(EnvironmentVariables.IMDS_ENDPOINT):\n                _LOGGER.info(\"%s will use Azure Arc managed identity\", self.__class__.__name__)\n                from .azure_arc import AzureArcCredential\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 22,
                  "endLine": 55,
                  "endColumn": 33,
                  "snippet": {
                    "text": "\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n\n",
                    "rendered": {
                      "text": "\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n\n",
                      "markdown": "`\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 18,
                  "endLine": 54,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n",
                    "rendered": {
                      "text": "        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n",
                      "markdown": "`        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 14,
                  "endLine": 53,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        self._credential: Optional[AsyncSupportsTokenInfo] = None\n        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n",
                    "rendered": {
                      "text": "        self._credential: Optional[AsyncSupportsTokenInfo] = None\n        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n",
                      "markdown": "`        self._credential: Optional[AsyncSupportsTokenInfo] = None\n        exclude_workload_identity = kwargs.pop(\"_exclude_workload_identity_credential\", False)\n\n        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 49,
                  "endLine": 63,
                  "endColumn": 58,
                  "snippet": {
                    "text": "                        client_id=client_id, identity_config=identity_config, **kwargs\n                    )\n                else:\n                    _LOGGER.info(\"%s will use App Service managed identity\", self.__class__.__name__)\n                    from .app_service import AppServiceCredential\n\n                    self._credential = AppServiceCredential(\n",
                    "rendered": {
                      "text": "                        client_id=client_id, identity_config=identity_config, **kwargs\n                    )\n                else:\n                    _LOGGER.info(\"%s will use App Service managed identity\", self.__class__.__name__)\n                    from .app_service import AppServiceCredential\n\n                    self._credential = AppServiceCredential(\n",
                      "markdown": "`                        client_id=client_id, identity_config=identity_config, **kwargs\n                    )\n                else:\n                    _LOGGER.info(\"%s will use App Service managed identity\", self.__class__.__name__)\n                    from .app_service import AppServiceCredential\n\n                    self._credential = AppServiceCredential(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/managed_identity.py"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 45,
                  "endLine": 56,
                  "endColumn": 54,
                  "snippet": {
                    "text": "        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n\n                    self._credential = ServiceFabricCredential(\n",
                    "rendered": {
                      "text": "        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n\n                    self._credential = ServiceFabricCredential(\n",
                      "markdown": "`        if os.environ.get(EnvironmentVariables.IDENTITY_ENDPOINT):\n            if os.environ.get(EnvironmentVariables.IDENTITY_HEADER):\n                if os.environ.get(EnvironmentVariables.IDENTITY_SERVER_THUMBPRINT):\n                    _LOGGER.info(\"%s will use Service Fabric managed identity\", self.__class__.__name__)\n                    from .service_fabric import ServiceFabricCredential\n\n                    self._credential = ServiceFabricCredential(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/imds.py"
                },
                "region": {
                  "startLine": 42,
                  "startColumn": 34,
                  "endLine": 42,
                  "endColumn": 39,
                  "snippet": {
                    "text": "\n    async def _request_token(self, *scopes: str, **kwargs: Any) -> AccessTokenInfo:  # pylint:disable=unused-argument\n\n        if within_credential_chain.get() and not self._endpoint_available:\n            # If within a chain (e.g. DefaultAzureCredential), we do a quick check to see if the IMDS endpoint\n            # is available to avoid hanging for a long time if the endpoint isn't available.\n            try:\n",
                    "rendered": {
                      "text": "\n    async def _request_token(self, *scopes: str, **kwargs: Any) -> AccessTokenInfo:  # pylint:disable=unused-argument\n\n        if within_credential_chain.get() and not self._endpoint_available:\n            # If within a chain (e.g. DefaultAzureCredential), we do a quick check to see if the IMDS endpoint\n            # is available to avoid hanging for a long time if the endpoint isn't available.\n            try:\n",
                      "markdown": "`\n    async def _request_token(self, *scopes: str, **kwargs: Any) -> AccessTokenInfo:  # pylint:disable=unused-argument\n\n        if within_credential_chain.get() and not self._endpoint_available:\n            # If within a chain (e.g. DefaultAzureCredential), we do a quick check to see if the IMDS endpoint\n            # is available to avoid hanging for a long time if the endpoint isn't available.\n            try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/imds.py"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 54,
                  "endLine": 44,
                  "endColumn": 60,
                  "snippet": {
                    "text": "\n        if within_credential_chain.get() and not self._endpoint_available:\n            # If within a chain (e.g. DefaultAzureCredential), we do a quick check to see if the IMDS endpoint\n            # is available to avoid hanging for a long time if the endpoint isn't available.\n            try:\n                await self._client.request_token(*scopes, connection_timeout=1, retry_total=0)\n                self._endpoint_available = True\n",
                    "rendered": {
                      "text": "\n        if within_credential_chain.get() and not self._endpoint_available:\n            # If within a chain (e.g. DefaultAzureCredential), we do a quick check to see if the IMDS endpoint\n            # is available to avoid hanging for a long time if the endpoint isn't available.\n            try:\n                await self._client.request_token(*scopes, connection_timeout=1, retry_total=0)\n                self._endpoint_available = True\n",
                      "markdown": "`\n        if within_credential_chain.get() and not self._endpoint_available:\n            # If within a chain (e.g. DefaultAzureCredential), we do a quick check to see if the IMDS endpoint\n            # is available to avoid hanging for a long time if the endpoint isn't available.\n            try:\n                await self._client.request_token(*scopes, connection_timeout=1, retry_total=0)\n                self._endpoint_available = True\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 158,
                  "startColumn": 56,
                  "endLine": 158,
                  "endColumn": 61,
                  "snippet": {
                    "text": "\n        except Exception as ex:\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s.%s failed: %s\",\n                self.__class__.__name__,\n                base_method_name,\n",
                    "rendered": {
                      "text": "\n        except Exception as ex:\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s.%s failed: %s\",\n                self.__class__.__name__,\n                base_method_name,\n",
                      "markdown": "`\n        except Exception as ex:\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s.%s failed: %s\",\n                self.__class__.__name__,\n                base_method_name,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 149,
                  "startColumn": 56,
                  "endLine": 149,
                  "endColumn": 61,
                  "snippet": {
                    "text": "                except Exception:  # pylint:disable=broad-except\n                    pass\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.INFO,\n                \"%s.%s succeeded\",\n                self.__class__.__name__,\n                base_method_name,\n",
                    "rendered": {
                      "text": "                except Exception:  # pylint:disable=broad-except\n                    pass\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.INFO,\n                \"%s.%s succeeded\",\n                self.__class__.__name__,\n                base_method_name,\n",
                      "markdown": "`                except Exception:  # pylint:disable=broad-except\n                    pass\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.INFO,\n                \"%s.%s succeeded\",\n                self.__class__.__name__,\n                base_method_name,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 129,
                  "startColumn": 28,
                  "endLine": 129,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        try:\n            token = self._acquire_token_silently(\n",
                    "rendered": {
                      "text": "        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        try:\n            token = self._acquire_token_silently(\n",
                      "markdown": "`        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        try:\n            token = self._acquire_token_silently(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 27,
                  "endLine": 128,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        try:\n",
                    "rendered": {
                      "text": "\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        try:\n",
                      "markdown": "`\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n        try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 127,
                  "startColumn": 24,
                  "endLine": 127,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            raise ValueError(f'\"{base_method_name}\" requires at least one scope')\n\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n",
                    "rendered": {
                      "text": "            raise ValueError(f'\"{base_method_name}\" requires at least one scope')\n\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n",
                      "markdown": "`            raise ValueError(f'\"{base_method_name}\" requires at least one scope')\n\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        enable_cae = options.get(\"enable_cae\", False)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 124,
                  "startColumn": 60,
                  "endLine": 124,
                  "endColumn": 64,
                  "snippet": {
                    "text": "        **kwargs: Any,\n    ) -> AccessTokenInfo:\n        if not scopes:\n            raise ValueError(f'\"{base_method_name}\" requires at least one scope')\n\n        options = options or {}\n        claims = options.get(\"claims\")\n",
                    "rendered": {
                      "text": "        **kwargs: Any,\n    ) -> AccessTokenInfo:\n        if not scopes:\n            raise ValueError(f'\"{base_method_name}\" requires at least one scope')\n\n        options = options or {}\n        claims = options.get(\"claims\")\n",
                      "markdown": "`        **kwargs: Any,\n    ) -> AccessTokenInfo:\n        if not scopes:\n            raise ValueError(f'\"{base_method_name}\" requires at least one scope')\n\n        options = options or {}\n        claims = options.get(\"claims\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 84,
                  "endLine": 102,
                  "endColumn": 88,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 70,
                  "startColumn": 84,
                  "endLine": 70,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 84,
                  "endLine": 40,
                  "endColumn": 88,
                  "snippet": {
                    "text": "    def _request_token(self, *scopes: str, **kwargs: Any) -> AccessTokenInfo:\n        \"\"\"Request an access token from the STS.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n\n",
                    "rendered": {
                      "text": "    def _request_token(self, *scopes: str, **kwargs: Any) -> AccessTokenInfo:\n        \"\"\"Request an access token from the STS.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n\n",
                      "markdown": "`    def _request_token(self, *scopes: str, **kwargs: Any) -> AccessTokenInfo:\n        \"\"\"Request an access token from the STS.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 84,
                  "endLine": 28,
                  "endColumn": 88,
                  "snippet": {
                    "text": "    def _acquire_token_silently(self, *scopes: str, **kwargs: Any) -> Optional[AccessTokenInfo]:\n        \"\"\"Attempt to acquire an access token from a cache or by redeeming a refresh token.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n\n",
                    "rendered": {
                      "text": "    def _acquire_token_silently(self, *scopes: str, **kwargs: Any) -> Optional[AccessTokenInfo]:\n        \"\"\"Attempt to acquire an access token from a cache or by redeeming a refresh token.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n\n",
                      "markdown": "`    def _acquire_token_silently(self, *scopes: str, **kwargs: Any) -> Optional[AccessTokenInfo]:\n        \"\"\"Attempt to acquire an access token from a cache or by redeeming a refresh token.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/get_token_mixin.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 6,
                  "endLine": 8,
                  "snippet": {
                    "text": "# ------------------------------------\nimport abc\nimport logging\nimport time\nfrom typing import Any, Optional\n\nfrom azure.core.credentials import AccessToken, AccessTokenInfo, TokenRequestOptions\nfrom .utils import within_credential_chain\n",
                    "rendered": {
                      "text": "# ------------------------------------\nimport abc\nimport logging\nimport time\nfrom typing import Any, Optional\n\nfrom azure.core.credentials import AccessToken, AccessTokenInfo, TokenRequestOptions\nfrom .utils import within_credential_chain\n",
                      "markdown": "`# ------------------------------------\nimport abc\nimport logging\nimport time\nfrom typing import Any, Optional\n\nfrom azure.core.credentials import AccessToken, AccessTokenInfo, TokenRequestOptions\nfrom .utils import within_credential_chain\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/decorators.py"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 56,
                  "endLine": 44,
                  "endColumn": 61,
                  "snippet": {
                    "text": "            return token\n        except Exception as ex:  # pylint: disable=broad-except\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s failed: %s\",\n                fn.__qualname__,\n                ex,\n",
                    "rendered": {
                      "text": "            return token\n        except Exception as ex:  # pylint: disable=broad-except\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s failed: %s\",\n                fn.__qualname__,\n                ex,\n",
                      "markdown": "`            return token\n        except Exception as ex:  # pylint: disable=broad-except\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.WARNING,\n                \"%s failed: %s\",\n                fn.__qualname__,\n                ex,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/decorators.py"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 35,
                  "endLine": 33,
                  "endColumn": 40,
                  "snippet": {
                    "text": "                    json_bytes = base64.decodebytes(base64_meta_data)\n                    json_string = json_bytes.decode(\"utf-8\")\n                    json_dict = json.loads(json_string)\n                    upn = json_dict.get(\"upn\", \"unavailableUpn\")\n                    log_string = (\n                        \"[Authenticated account] Client ID: {}. Tenant ID: {}. User Principal Name: {}. \"\n                        \"Object ID (user): {}\".format(json_dict[\"appid\"], json_dict[\"tid\"], upn, json_dict[\"oid\"])\n",
                    "rendered": {
                      "text": "                    json_bytes = base64.decodebytes(base64_meta_data)\n                    json_string = json_bytes.decode(\"utf-8\")\n                    json_dict = json.loads(json_string)\n                    upn = json_dict.get(\"upn\", \"unavailableUpn\")\n                    log_string = (\n                        \"[Authenticated account] Client ID: {}. Tenant ID: {}. User Principal Name: {}. \"\n                        \"Object ID (user): {}\".format(json_dict[\"appid\"], json_dict[\"tid\"], upn, json_dict[\"oid\"])\n",
                      "markdown": "`                    json_bytes = base64.decodebytes(base64_meta_data)\n                    json_string = json_bytes.decode(\"utf-8\")\n                    json_dict = json.loads(json_string)\n                    upn = json_dict.get(\"upn\", \"unavailableUpn\")\n                    log_string = (\n                        \"[Authenticated account] Client ID: {}. Tenant ID: {}. User Principal Name: {}. \"\n                        \"Object ID (user): {}\".format(json_dict[\"appid\"], json_dict[\"tid\"], upn, json_dict[\"oid\"])\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/decorators.py"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 56,
                  "endLine": 25,
                  "endColumn": 61,
                  "snippet": {
                    "text": "        try:\n            token = fn(*args, **kwargs)\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.INFO, \"%s succeeded\", fn.__qualname__\n            )\n            if _LOGGER.isEnabledFor(logging.DEBUG):\n                try:\n",
                    "rendered": {
                      "text": "        try:\n            token = fn(*args, **kwargs)\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.INFO, \"%s succeeded\", fn.__qualname__\n            )\n            if _LOGGER.isEnabledFor(logging.DEBUG):\n                try:\n",
                      "markdown": "`        try:\n            token = fn(*args, **kwargs)\n            _LOGGER.log(\n                logging.DEBUG if within_credential_chain.get() else logging.INFO, \"%s succeeded\", fn.__qualname__\n            )\n            if _LOGGER.isEnabledFor(logging.DEBUG):\n                try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/decorators.py"
                },
                "region": {
                  "startLine": 30,
                  "startColumn": 33,
                  "endLine": 30,
                  "endColumn": 39,
                  "snippet": {
                    "text": "            if _LOGGER.isEnabledFor(logging.DEBUG):\n                try:\n                    base64_meta_data = token.token.split(\".\")[1].encode(\"utf-8\") + b\"==\"\n                    json_bytes = base64.decodebytes(base64_meta_data)\n                    json_string = json_bytes.decode(\"utf-8\")\n                    json_dict = json.loads(json_string)\n                    upn = json_dict.get(\"upn\", \"unavailableUpn\")\n",
                    "rendered": {
                      "text": "            if _LOGGER.isEnabledFor(logging.DEBUG):\n                try:\n                    base64_meta_data = token.token.split(\".\")[1].encode(\"utf-8\") + b\"==\"\n                    json_bytes = base64.decodebytes(base64_meta_data)\n                    json_string = json_bytes.decode(\"utf-8\")\n                    json_dict = json.loads(json_string)\n                    upn = json_dict.get(\"upn\", \"unavailableUpn\")\n",
                      "markdown": "`            if _LOGGER.isEnabledFor(logging.DEBUG):\n                try:\n                    base64_meta_data = token.token.split(\".\")[1].encode(\"utf-8\") + b\"==\"\n                    json_bytes = base64.decodebytes(base64_meta_data)\n                    json_string = json_bytes.decode(\"utf-8\")\n                    json_dict = json.loads(json_string)\n                    upn = json_dict.get(\"upn\", \"unavailableUpn\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/decorators.py"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 7,
                  "endLine": 8,
                  "endColumn": 13,
                  "snippet": {
                    "text": "import functools\nimport logging\nimport json\nimport base64\n\nfrom azure.core.exceptions import ClientAuthenticationError\n\n",
                    "rendered": {
                      "text": "import functools\nimport logging\nimport json\nimport base64\n\nfrom azure.core.exceptions import ClientAuthenticationError\n\n",
                      "markdown": "`import functools\nimport logging\nimport json\nimport base64\n\nfrom azure.core.exceptions import ClientAuthenticationError\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/decorators.py"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 6,
                  "endLine": 9,
                  "snippet": {
                    "text": "import functools\nimport logging\nimport json\nimport base64\n\nfrom azure.core.exceptions import ClientAuthenticationError\n\nfrom .utils import within_credential_chain\n",
                    "rendered": {
                      "text": "import functools\nimport logging\nimport json\nimport base64\n\nfrom azure.core.exceptions import ClientAuthenticationError\n\nfrom .utils import within_credential_chain\n",
                      "markdown": "`import functools\nimport logging\nimport json\nimport base64\n\nfrom azure.core.exceptions import ClientAuthenticationError\n\nfrom .utils import within_credential_chain\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 150,
                  "startColumn": 29,
                  "endLine": 150,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        if not exclude_environment_credential:\n            credentials.append(EnvironmentCredential(authority=authority, _within_dac=True, **kwargs))\n        if not exclude_workload_identity_credential:\n            if all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS):\n                client_id = workload_identity_client_id\n                credentials.append(\n                    WorkloadIdentityCredential(\n",
                    "rendered": {
                      "text": "        if not exclude_environment_credential:\n            credentials.append(EnvironmentCredential(authority=authority, _within_dac=True, **kwargs))\n        if not exclude_workload_identity_credential:\n            if all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS):\n                client_id = workload_identity_client_id\n                credentials.append(\n                    WorkloadIdentityCredential(\n",
                      "markdown": "`        if not exclude_environment_credential:\n            credentials.append(EnvironmentCredential(authority=authority, _within_dac=True, **kwargs))\n        if not exclude_workload_identity_credential:\n            if all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS):\n                client_id = workload_identity_client_id\n                credentials.append(\n                    WorkloadIdentityCredential(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 130,
                  "startColumn": 48,
                  "endLine": 130,
                  "endColumn": 53,
                  "snippet": {
                    "text": "\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        process_timeout = kwargs.pop(\"process_timeout\", 10)\n",
                    "rendered": {
                      "text": "\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        process_timeout = kwargs.pop(\"process_timeout\", 10)\n",
                      "markdown": "`\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        process_timeout = kwargs.pop(\"process_timeout\", 10)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 78,
                  "endLine": 128,
                  "endColumn": 83,
                  "snippet": {
                    "text": "        )\n        interactive_browser_client_id = kwargs.pop(\"interactive_browser_client_id\", None)\n\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n",
                    "rendered": {
                      "text": "        )\n        interactive_browser_client_id = kwargs.pop(\"interactive_browser_client_id\", None)\n\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n",
                      "markdown": "`        )\n        interactive_browser_client_id = kwargs.pop(\"interactive_browser_client_id\", None)\n\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 124,
                  "startColumn": 53,
                  "endLine": 124,
                  "endColumn": 58,
                  "snippet": {
                    "text": "        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n            \"workload_identity_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n        interactive_browser_client_id = kwargs.pop(\"interactive_browser_client_id\", None)\n\n",
                    "rendered": {
                      "text": "        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n            \"workload_identity_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n        interactive_browser_client_id = kwargs.pop(\"interactive_browser_client_id\", None)\n\n",
                      "markdown": "`        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n            \"workload_identity_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n        interactive_browser_client_id = kwargs.pop(\"interactive_browser_client_id\", None)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 120,
                  "startColumn": 52,
                  "endLine": 120,
                  "endColumn": 57,
                  "snippet": {
                    "text": "        )\n\n        managed_identity_client_id = kwargs.pop(\n            \"managed_identity_client_id\", os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n",
                    "rendered": {
                      "text": "        )\n\n        managed_identity_client_id = kwargs.pop(\n            \"managed_identity_client_id\", os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n",
                      "markdown": "`        )\n\n        managed_identity_client_id = kwargs.pop(\n            \"managed_identity_client_id\", os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 116,
                  "startColumn": 55,
                  "endLine": 116,
                  "endColumn": 60,
                  "snippet": {
                    "text": "        authority = normalize_authority(authority) if authority else get_default_authority()\n\n        interactive_browser_tenant_id = kwargs.pop(\n            \"interactive_browser_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        managed_identity_client_id = kwargs.pop(\n",
                    "rendered": {
                      "text": "        authority = normalize_authority(authority) if authority else get_default_authority()\n\n        interactive_browser_tenant_id = kwargs.pop(\n            \"interactive_browser_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        managed_identity_client_id = kwargs.pop(\n",
                      "markdown": "`        authority = normalize_authority(authority) if authority else get_default_authority()\n\n        interactive_browser_tenant_id = kwargs.pop(\n            \"interactive_browser_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        managed_identity_client_id = kwargs.pop(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 54,
                  "endLine": 105,
                  "endColumn": 59,
                  "snippet": {
                    "text": "        authority = kwargs.pop(\"authority\", None)\n\n        vscode_tenant_id = kwargs.pop(\n            \"visual_studio_code_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n        vscode_args = dict(kwargs)\n        if authority:\n",
                    "rendered": {
                      "text": "        authority = kwargs.pop(\"authority\", None)\n\n        vscode_tenant_id = kwargs.pop(\n            \"visual_studio_code_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n        vscode_args = dict(kwargs)\n        if authority:\n",
                      "markdown": "`        authority = kwargs.pop(\"authority\", None)\n\n        vscode_tenant_id = kwargs.pop(\n            \"visual_studio_code_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n        vscode_args = dict(kwargs)\n        if authority:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 150,
                  "startColumn": 22,
                  "endLine": 150,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        if not exclude_environment_credential:\n            credentials.append(EnvironmentCredential(authority=authority, _within_dac=True, **kwargs))\n        if not exclude_workload_identity_credential:\n            if all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS):\n                client_id = workload_identity_client_id\n                credentials.append(\n                    WorkloadIdentityCredential(\n",
                    "rendered": {
                      "text": "        if not exclude_environment_credential:\n            credentials.append(EnvironmentCredential(authority=authority, _within_dac=True, **kwargs))\n        if not exclude_workload_identity_credential:\n            if all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS):\n                client_id = workload_identity_client_id\n                credentials.append(\n                    WorkloadIdentityCredential(\n",
                      "markdown": "`        if not exclude_environment_credential:\n            credentials.append(EnvironmentCredential(authority=authority, _within_dac=True, **kwargs))\n        if not exclude_workload_identity_credential:\n            if all(os.environ.get(var) for var in EnvironmentVariables.WORKLOAD_IDENTITY_VARS):\n                client_id = workload_identity_client_id\n                credentials.append(\n                    WorkloadIdentityCredential(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 130,
                  "startColumn": 41,
                  "endLine": 130,
                  "endColumn": 52,
                  "snippet": {
                    "text": "\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        process_timeout = kwargs.pop(\"process_timeout\", 10)\n",
                    "rendered": {
                      "text": "\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        process_timeout = kwargs.pop(\"process_timeout\", 10)\n",
                      "markdown": "`\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        process_timeout = kwargs.pop(\"process_timeout\", 10)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 71,
                  "endLine": 128,
                  "endColumn": 82,
                  "snippet": {
                    "text": "        )\n        interactive_browser_client_id = kwargs.pop(\"interactive_browser_client_id\", None)\n\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n",
                    "rendered": {
                      "text": "        )\n        interactive_browser_client_id = kwargs.pop(\"interactive_browser_client_id\", None)\n\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n",
                      "markdown": "`        )\n        interactive_browser_client_id = kwargs.pop(\"interactive_browser_client_id\", None)\n\n        shared_cache_username = kwargs.pop(\"shared_cache_username\", os.environ.get(EnvironmentVariables.AZURE_USERNAME))\n        shared_cache_tenant_id = kwargs.pop(\n            \"shared_cache_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 124,
                  "startColumn": 46,
                  "endLine": 124,
                  "endColumn": 57,
                  "snippet": {
                    "text": "        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n            \"workload_identity_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n        interactive_browser_client_id = kwargs.pop(\"interactive_browser_client_id\", None)\n\n",
                    "rendered": {
                      "text": "        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n            \"workload_identity_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n        interactive_browser_client_id = kwargs.pop(\"interactive_browser_client_id\", None)\n\n",
                      "markdown": "`        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n            \"workload_identity_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n        interactive_browser_client_id = kwargs.pop(\"interactive_browser_client_id\", None)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 120,
                  "startColumn": 45,
                  "endLine": 120,
                  "endColumn": 56,
                  "snippet": {
                    "text": "        )\n\n        managed_identity_client_id = kwargs.pop(\n            \"managed_identity_client_id\", os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n",
                    "rendered": {
                      "text": "        )\n\n        managed_identity_client_id = kwargs.pop(\n            \"managed_identity_client_id\", os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n",
                      "markdown": "`        )\n\n        managed_identity_client_id = kwargs.pop(\n            \"managed_identity_client_id\", os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        )\n        workload_identity_client_id = kwargs.pop(\"workload_identity_client_id\", managed_identity_client_id)\n        workload_identity_tenant_id = kwargs.pop(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 116,
                  "startColumn": 48,
                  "endLine": 116,
                  "endColumn": 59,
                  "snippet": {
                    "text": "        authority = normalize_authority(authority) if authority else get_default_authority()\n\n        interactive_browser_tenant_id = kwargs.pop(\n            \"interactive_browser_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        managed_identity_client_id = kwargs.pop(\n",
                    "rendered": {
                      "text": "        authority = normalize_authority(authority) if authority else get_default_authority()\n\n        interactive_browser_tenant_id = kwargs.pop(\n            \"interactive_browser_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        managed_identity_client_id = kwargs.pop(\n",
                      "markdown": "`        authority = normalize_authority(authority) if authority else get_default_authority()\n\n        interactive_browser_tenant_id = kwargs.pop(\n            \"interactive_browser_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n\n        managed_identity_client_id = kwargs.pop(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 47,
                  "endLine": 105,
                  "endColumn": 58,
                  "snippet": {
                    "text": "        authority = kwargs.pop(\"authority\", None)\n\n        vscode_tenant_id = kwargs.pop(\n            \"visual_studio_code_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n        vscode_args = dict(kwargs)\n        if authority:\n",
                    "rendered": {
                      "text": "        authority = kwargs.pop(\"authority\", None)\n\n        vscode_tenant_id = kwargs.pop(\n            \"visual_studio_code_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n        vscode_args = dict(kwargs)\n        if authority:\n",
                      "markdown": "`        authority = kwargs.pop(\"authority\", None)\n\n        vscode_tenant_id = kwargs.pop(\n            \"visual_studio_code_tenant_id\", os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        )\n        vscode_args = dict(kwargs)\n        if authority:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 26,
                  "endLine": 55,
                  "endColumn": 84,
                  "snippet": {
                    "text": "    :keyword bool exclude_developer_cli_credential: Whether to exclude the Azure Developer CLI\n        from the credential. Defaults to **False**.\n    :keyword bool exclude_cli_credential: Whether to exclude the Azure CLI from the credential. Defaults to **False**.\n    :keyword bool exclude_environment_credential: Whether to exclude a service principal configured by environment\n        variables from the credential. Defaults to **False**.\n    :keyword bool exclude_managed_identity_credential: Whether to exclude managed identity from the credential.\n        Defaults to **False**.\n",
                    "rendered": {
                      "text": "    :keyword bool exclude_developer_cli_credential: Whether to exclude the Azure Developer CLI\n        from the credential. Defaults to **False**.\n    :keyword bool exclude_cli_credential: Whether to exclude the Azure CLI from the credential. Defaults to **False**.\n    :keyword bool exclude_environment_credential: Whether to exclude a service principal configured by environment\n        variables from the credential. Defaults to **False**.\n    :keyword bool exclude_managed_identity_credential: Whether to exclude managed identity from the credential.\n        Defaults to **False**.\n",
                      "markdown": "`    :keyword bool exclude_developer_cli_credential: Whether to exclude the Azure Developer CLI\n        from the credential. Defaults to **False**.\n    :keyword bool exclude_cli_credential: Whether to exclude the Azure CLI from the credential. Defaults to **False**.\n    :keyword bool exclude_environment_credential: Whether to exclude a service principal configured by environment\n        variables from the credential. Defaults to **False**.\n    :keyword bool exclude_managed_identity_credential: Whether to exclude managed identity from the credential.\n        Defaults to **False**.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 236,
                  "startColumn": 84,
                  "endLine": 236,
                  "endColumn": 88,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 204,
                  "startColumn": 84,
                  "endLine": 204,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 37,
                  "endLine": 85,
                  "endColumn": 46,
                  "snippet": {
                    "text": "        :class:`~azure.identity.VisualStudioCodeCredential`. Defaults to the \"Azure: Tenant\" setting in VS Code's user\n        settings or, when that setting has no value, the \"organizations\" tenant, which supports only Azure Active\n        Directory work or school accounts.\n    :keyword int process_timeout: The timeout in seconds to use for developer credentials that run\n        subprocesses (e.g. AzureCliCredential, AzurePowerShellCredential). Defaults to **10** seconds.\n\n    .. admonition:: Example:\n",
                    "rendered": {
                      "text": "        :class:`~azure.identity.VisualStudioCodeCredential`. Defaults to the \"Azure: Tenant\" setting in VS Code's user\n        settings or, when that setting has no value, the \"organizations\" tenant, which supports only Azure Active\n        Directory work or school accounts.\n    :keyword int process_timeout: The timeout in seconds to use for developer credentials that run\n        subprocesses (e.g. AzureCliCredential, AzurePowerShellCredential). Defaults to **10** seconds.\n\n    .. admonition:: Example:\n",
                      "markdown": "`        :class:`~azure.identity.VisualStudioCodeCredential`. Defaults to the \"Azure: Tenant\" setting in VS Code's user\n        settings or, when that setting has no value, the \"organizations\" tenant, which supports only Azure Active\n        Directory work or school accounts.\n    :keyword int process_timeout: The timeout in seconds to use for developer credentials that run\n        subprocesses (e.g. AzureCliCredential, AzurePowerShellCredential). Defaults to **10** seconds.\n\n    .. admonition:: Example:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 70,
                  "endLine": 55,
                  "endColumn": 79,
                  "snippet": {
                    "text": "    :keyword bool exclude_developer_cli_credential: Whether to exclude the Azure Developer CLI\n        from the credential. Defaults to **False**.\n    :keyword bool exclude_cli_credential: Whether to exclude the Azure CLI from the credential. Defaults to **False**.\n    :keyword bool exclude_environment_credential: Whether to exclude a service principal configured by environment\n        variables from the credential. Defaults to **False**.\n    :keyword bool exclude_managed_identity_credential: Whether to exclude managed identity from the credential.\n        Defaults to **False**.\n",
                    "rendered": {
                      "text": "    :keyword bool exclude_developer_cli_credential: Whether to exclude the Azure Developer CLI\n        from the credential. Defaults to **False**.\n    :keyword bool exclude_cli_credential: Whether to exclude the Azure CLI from the credential. Defaults to **False**.\n    :keyword bool exclude_environment_credential: Whether to exclude a service principal configured by environment\n        variables from the credential. Defaults to **False**.\n    :keyword bool exclude_managed_identity_credential: Whether to exclude managed identity from the credential.\n        Defaults to **False**.\n",
                      "markdown": "`    :keyword bool exclude_developer_cli_credential: Whether to exclude the Azure Developer CLI\n        from the credential. Defaults to **False**.\n    :keyword bool exclude_cli_credential: Whether to exclude the Azure CLI from the credential. Defaults to **False**.\n    :keyword bool exclude_environment_credential: Whether to exclude a service principal configured by environment\n        variables from the credential. Defaults to **False**.\n    :keyword bool exclude_managed_identity_credential: Whether to exclude managed identity from the credential.\n        Defaults to **False**.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/default.py"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 8,
                  "endLine": 33,
                  "endColumn": 17,
                  "snippet": {
                    "text": "    The identity it uses depends on the environment. When an access token is needed, it requests one using these\n    identities in turn, stopping when one provides a token:\n\n    1. A service principal configured by environment variables. See :class:`~azure.identity.EnvironmentCredential` for\n       more details.\n    2. WorkloadIdentityCredential if environment variable configuration is set by the Azure workload\n       identity webhook.\n",
                    "rendered": {
                      "text": "    The identity it uses depends on the environment. When an access token is needed, it requests one using these\n    identities in turn, stopping when one provides a token:\n\n    1. A service principal configured by environment variables. See :class:`~azure.identity.EnvironmentCredential` for\n       more details.\n    2. WorkloadIdentityCredential if environment variable configuration is set by the Azure workload\n       identity webhook.\n",
                      "markdown": "`    The identity it uses depends on the environment. When an access token is needed, it requests one using these\n    identities in turn, stopping when one provides a token:\n\n    1. A service principal configured by environment variables. See :class:`~azure.identity.EnvironmentCredential` for\n       more details.\n    2. WorkloadIdentityCredential if environment variable configuration is set by the Azure workload\n       identity webhook.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/cloud_shell.py"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 24,
                  "endLine": 34,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n        url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n        if url:\n            return ManagedIdentityClient(\n                request_factory=functools.partial(_get_request, url), base_headers={\"Metadata\": \"true\"}, **kwargs\n",
                    "rendered": {
                      "text": "        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n        url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n        if url:\n            return ManagedIdentityClient(\n                request_factory=functools.partial(_get_request, url), base_headers={\"Metadata\": \"true\"}, **kwargs\n",
                      "markdown": "`        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n        url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n        if url:\n            return ManagedIdentityClient(\n                request_factory=functools.partial(_get_request, url), base_headers={\"Metadata\": \"true\"}, **kwargs\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/cloud_shell.py"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 32,
                  "endLine": 31,
                  "endColumn": 37,
                  "snippet": {
                    "text": "class CloudShellCredential(ManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[ManagedIdentityClient]:\n        client_id = kwargs.get(\"client_id\")\n        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n        url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n",
                    "rendered": {
                      "text": "class CloudShellCredential(ManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[ManagedIdentityClient]:\n        client_id = kwargs.get(\"client_id\")\n        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n        url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n",
                      "markdown": "`class CloudShellCredential(ManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[ManagedIdentityClient]:\n        client_id = kwargs.get(\"client_id\")\n        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n        url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/cloud_shell.py"
                },
                "region": {
                  "startLine": 30,
                  "startColumn": 26,
                  "endLine": 30,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\nclass CloudShellCredential(ManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[ManagedIdentityClient]:\n        client_id = kwargs.get(\"client_id\")\n        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n",
                    "rendered": {
                      "text": "\nclass CloudShellCredential(ManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[ManagedIdentityClient]:\n        client_id = kwargs.get(\"client_id\")\n        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n",
                      "markdown": "`\nclass CloudShellCredential(ManagedIdentityBase):\n    def get_client(self, **kwargs: Any) -> Optional[ManagedIdentityClient]:\n        client_id = kwargs.get(\"client_id\")\n        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/cloud_shell.py"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 17,
                  "endLine": 18,
                  "endColumn": 22,
                  "snippet": {
                    "text": "\n\ndef validate_client_id_and_config(client_id: Optional[str], identity_config: Optional[Mapping[str, str]]) -> None:\n    if within_dac.get():\n        return\n    if client_id:\n        raise ValueError(\"client_id should not be set for cloud shell managed identity.\")\n",
                    "rendered": {
                      "text": "\n\ndef validate_client_id_and_config(client_id: Optional[str], identity_config: Optional[Mapping[str, str]]) -> None:\n    if within_dac.get():\n        return\n    if client_id:\n        raise ValueError(\"client_id should not be set for cloud shell managed identity.\")\n",
                      "markdown": "`\n\ndef validate_client_id_and_config(client_id: Optional[str], identity_config: Optional[Mapping[str, str]]) -> None:\n    if within_dac.get():\n        return\n    if client_id:\n        raise ValueError(\"client_id should not be set for cloud shell managed identity.\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/cloud_shell.py"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 17,
                  "endLine": 34,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n        url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n        if url:\n            return ManagedIdentityClient(\n                request_factory=functools.partial(_get_request, url), base_headers={\"Metadata\": \"true\"}, **kwargs\n",
                    "rendered": {
                      "text": "        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n        url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n        if url:\n            return ManagedIdentityClient(\n                request_factory=functools.partial(_get_request, url), base_headers={\"Metadata\": \"true\"}, **kwargs\n",
                      "markdown": "`        identity_config = kwargs.get(\"identity_config\")\n        validate_client_id_and_config(client_id, identity_config)\n\n        url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n        if url:\n            return ManagedIdentityClient(\n                request_factory=functools.partial(_get_request, url), base_headers={\"Metadata\": \"true\"}, **kwargs\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_ml.py"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 13,
                  "endLine": 29,
                  "endColumn": 18,
                  "snippet": {
                    "text": "        # Azure ML managed identity isn't available in this environment\n        return None\n\n    if kwargs.get(\"client_id\"):\n        identity_config[\"clientid\"] = kwargs.pop(\"client_id\")\n\n    return dict(\n",
                    "rendered": {
                      "text": "        # Azure ML managed identity isn't available in this environment\n        return None\n\n    if kwargs.get(\"client_id\"):\n        identity_config[\"clientid\"] = kwargs.pop(\"client_id\")\n\n    return dict(\n",
                      "markdown": "`        # Azure ML managed identity isn't available in this environment\n        return None\n\n    if kwargs.get(\"client_id\"):\n        identity_config[\"clientid\"] = kwargs.pop(\"client_id\")\n\n    return dict(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_ml.py"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 23,
                  "endLine": 24,
                  "endColumn": 28,
                  "snippet": {
                    "text": "    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.MSI_SECRET)\n    if not (url and secret):\n        # Azure ML managed identity isn't available in this environment\n        return None\n",
                    "rendered": {
                      "text": "    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.MSI_SECRET)\n    if not (url and secret):\n        # Azure ML managed identity isn't available in this environment\n        return None\n",
                      "markdown": "`    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.MSI_SECRET)\n    if not (url and secret):\n        # Azure ML managed identity isn't available in this environment\n        return None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_ml.py"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 20,
                  "endLine": 23,
                  "endColumn": 25,
                  "snippet": {
                    "text": "def _get_client_args(**kwargs) -> Optional[Dict]:\n    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.MSI_SECRET)\n    if not (url and secret):\n        # Azure ML managed identity isn't available in this environment\n",
                    "rendered": {
                      "text": "def _get_client_args(**kwargs) -> Optional[Dict]:\n    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.MSI_SECRET)\n    if not (url and secret):\n        # Azure ML managed identity isn't available in this environment\n",
                      "markdown": "`def _get_client_args(**kwargs) -> Optional[Dict]:\n    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.MSI_SECRET)\n    if not (url and secret):\n        # Azure ML managed identity isn't available in this environment\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_ml.py"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 16,
                  "endLine": 24,
                  "endColumn": 27,
                  "snippet": {
                    "text": "    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.MSI_SECRET)\n    if not (url and secret):\n        # Azure ML managed identity isn't available in this environment\n        return None\n",
                    "rendered": {
                      "text": "    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.MSI_SECRET)\n    if not (url and secret):\n        # Azure ML managed identity isn't available in this environment\n        return None\n",
                      "markdown": "`    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.MSI_SECRET)\n    if not (url and secret):\n        # Azure ML managed identity isn't available in this environment\n        return None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_ml.py"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 13,
                  "endLine": 23,
                  "endColumn": 24,
                  "snippet": {
                    "text": "def _get_client_args(**kwargs) -> Optional[Dict]:\n    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.MSI_SECRET)\n    if not (url and secret):\n        # Azure ML managed identity isn't available in this environment\n",
                    "rendered": {
                      "text": "def _get_client_args(**kwargs) -> Optional[Dict]:\n    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.MSI_SECRET)\n    if not (url and secret):\n        # Azure ML managed identity isn't available in this environment\n",
                      "markdown": "`def _get_client_args(**kwargs) -> Optional[Dict]:\n    identity_config = kwargs.pop(\"identity_config\", None) or {}\n\n    url = os.environ.get(EnvironmentVariables.MSI_ENDPOINT)\n    secret = os.environ.get(EnvironmentVariables.MSI_SECRET)\n    if not (url and secret):\n        # Azure ML managed identity isn't available in this environment\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_ml.py"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 10,
                  "endLine": 68,
                  "snippet": {
                    "text": "        pass\n\n    import calendar\n    import time\n\n    expires_on = content[\"expires_on\"]\n    if expires_on.endswith(\" +00:00\"):\n        date_string = expires_on[: -len(\" +00:00\")]\n",
                    "rendered": {
                      "text": "        pass\n\n    import calendar\n    import time\n\n    expires_on = content[\"expires_on\"]\n    if expires_on.endswith(\" +00:00\"):\n        date_string = expires_on[: -len(\" +00:00\")]\n",
                      "markdown": "`        pass\n\n    import calendar\n    import time\n\n    expires_on = content[\"expires_on\"]\n    if expires_on.endswith(\" +00:00\"):\n        date_string = expires_on[: -len(\" +00:00\")]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_ml.py"
                },
                "region": {
                  "startLine": 58,
                  "startColumn": 57,
                  "endLine": 58,
                  "endColumn": 66,
                  "snippet": {
                    "text": "    :raises ValueError: ``expires_on`` didn't match an expected format\n    \"\"\"\n\n    # Azure ML sets the same environment variables as App Service but returns expires_on as an integer.\n    # That means we could have an Azure ML response here, so let's first try to parse expires_on as an int.\n    try:\n        content[\"expires_on\"] = int(content[\"expires_on\"])\n",
                    "rendered": {
                      "text": "    :raises ValueError: ``expires_on`` didn't match an expected format\n    \"\"\"\n\n    # Azure ML sets the same environment variables as App Service but returns expires_on as an integer.\n    # That means we could have an Azure ML response here, so let's first try to parse expires_on as an int.\n    try:\n        content[\"expires_on\"] = int(content[\"expires_on\"])\n",
                      "markdown": "`    :raises ValueError: ``expires_on`` didn't match an expected format\n    \"\"\"\n\n    # Azure ML sets the same environment variables as App Service but returns expires_on as an integer.\n    # That means we could have an Azure ML response here, so let's first try to parse expires_on as an int.\n    try:\n        content[\"expires_on\"] = int(content[\"expires_on\"])\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_ml.py"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 60,
                  "endLine": 54,
                  "endColumn": 69,
                  "snippet": {
                    "text": "    format depends on the OS. Responses on Windows include AM/PM, for example \"1/16/2020 5:24:12 AM +00:00\".\n    Responses on Linux do not, for example \"06/20/2019 02:57:58 +00:00\".\n\n    :param dict content: a deserialized response from an App Service MSI.\n    :raises ValueError: ``expires_on`` didn't match an expected format\n    \"\"\"\n\n",
                    "rendered": {
                      "text": "    format depends on the OS. Responses on Windows include AM/PM, for example \"1/16/2020 5:24:12 AM +00:00\".\n    Responses on Linux do not, for example \"06/20/2019 02:57:58 +00:00\".\n\n    :param dict content: a deserialized response from an App Service MSI.\n    :raises ValueError: ``expires_on`` didn't match an expected format\n    \"\"\"\n\n",
                      "markdown": "`    format depends on the OS. Responses on Windows include AM/PM, for example \"1/16/2020 5:24:12 AM +00:00\".\n    Responses on Linux do not, for example \"06/20/2019 02:57:58 +00:00\".\n\n    :param dict content: a deserialized response from an App Service MSI.\n    :raises ValueError: ``expires_on`` didn't match an expected format\n    \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/azure_ml.py"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 19,
                  "endLine": 48,
                  "endColumn": 28,
                  "snippet": {
                    "text": "\n\ndef _parse_expires_on(content: Dict) -> None:\n    \"\"\"Parse an App Service MSI version 2017-09-01 expires_on value to epoch seconds.\n\n    This version of the API returns expires_on as a UTC datetime string rather than epoch seconds. The string's\n    format depends on the OS. Responses on Windows include AM/PM, for example \"1/16/2020 5:24:12 AM +00:00\".\n",
                    "rendered": {
                      "text": "\n\ndef _parse_expires_on(content: Dict) -> None:\n    \"\"\"Parse an App Service MSI version 2017-09-01 expires_on value to epoch seconds.\n\n    This version of the API returns expires_on as a UTC datetime string rather than epoch seconds. The string's\n    format depends on the OS. Responses on Windows include AM/PM, for example \"1/16/2020 5:24:12 AM +00:00\".\n",
                      "markdown": "`\n\ndef _parse_expires_on(content: Dict) -> None:\n    \"\"\"Parse an App Service MSI version 2017-09-01 expires_on value to epoch seconds.\n\n    This version of the API returns expires_on as a UTC datetime string rather than epoch seconds. The string's\n    format depends on the OS. Responses on Windows include AM/PM, for example \"1/16/2020 5:24:12 AM +00:00\".\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_constants.py"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 69,
                  "endLine": 52,
                  "endColumn": 77,
                  "snippet": {
                    "text": "\n    AZURE_USERNAME = \"AZURE_USERNAME\"\n    AZURE_PASSWORD = \"AZURE_PASSWORD\"\n    USERNAME_PASSWORD_VARS = (AZURE_CLIENT_ID, AZURE_USERNAME, AZURE_PASSWORD)\n\n    AZURE_POD_IDENTITY_AUTHORITY_HOST = \"AZURE_POD_IDENTITY_AUTHORITY_HOST\"\n    IDENTITY_ENDPOINT = \"IDENTITY_ENDPOINT\"\n",
                    "rendered": {
                      "text": "\n    AZURE_USERNAME = \"AZURE_USERNAME\"\n    AZURE_PASSWORD = \"AZURE_PASSWORD\"\n    USERNAME_PASSWORD_VARS = (AZURE_CLIENT_ID, AZURE_USERNAME, AZURE_PASSWORD)\n\n    AZURE_POD_IDENTITY_AUTHORITY_HOST = \"AZURE_POD_IDENTITY_AUTHORITY_HOST\"\n    IDENTITY_ENDPOINT = \"IDENTITY_ENDPOINT\"\n",
                      "markdown": "`\n    AZURE_USERNAME = \"AZURE_USERNAME\"\n    AZURE_PASSWORD = \"AZURE_PASSWORD\"\n    USERNAME_PASSWORD_VARS = (AZURE_CLIENT_ID, AZURE_USERNAME, AZURE_PASSWORD)\n\n    AZURE_POD_IDENTITY_AUTHORITY_HOST = \"AZURE_POD_IDENTITY_AUTHORITY_HOST\"\n    IDENTITY_ENDPOINT = \"IDENTITY_ENDPOINT\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_constants.py"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 13,
                  "endLine": 52,
                  "endColumn": 21,
                  "snippet": {
                    "text": "\n    AZURE_USERNAME = \"AZURE_USERNAME\"\n    AZURE_PASSWORD = \"AZURE_PASSWORD\"\n    USERNAME_PASSWORD_VARS = (AZURE_CLIENT_ID, AZURE_USERNAME, AZURE_PASSWORD)\n\n    AZURE_POD_IDENTITY_AUTHORITY_HOST = \"AZURE_POD_IDENTITY_AUTHORITY_HOST\"\n    IDENTITY_ENDPOINT = \"IDENTITY_ENDPOINT\"\n",
                    "rendered": {
                      "text": "\n    AZURE_USERNAME = \"AZURE_USERNAME\"\n    AZURE_PASSWORD = \"AZURE_PASSWORD\"\n    USERNAME_PASSWORD_VARS = (AZURE_CLIENT_ID, AZURE_USERNAME, AZURE_PASSWORD)\n\n    AZURE_POD_IDENTITY_AUTHORITY_HOST = \"AZURE_POD_IDENTITY_AUTHORITY_HOST\"\n    IDENTITY_ENDPOINT = \"IDENTITY_ENDPOINT\"\n",
                      "markdown": "`\n    AZURE_USERNAME = \"AZURE_USERNAME\"\n    AZURE_PASSWORD = \"AZURE_PASSWORD\"\n    USERNAME_PASSWORD_VARS = (AZURE_CLIENT_ID, AZURE_USERNAME, AZURE_PASSWORD)\n\n    AZURE_POD_IDENTITY_AUTHORITY_HOST = \"AZURE_POD_IDENTITY_AUTHORITY_HOST\"\n    IDENTITY_ENDPOINT = \"IDENTITY_ENDPOINT\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_constants.py"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 28,
                  "endLine": 51,
                  "endColumn": 36,
                  "snippet": {
                    "text": "    CERT_VARS = (AZURE_CLIENT_ID, AZURE_CLIENT_CERTIFICATE_PATH, AZURE_TENANT_ID)\n\n    AZURE_USERNAME = \"AZURE_USERNAME\"\n    AZURE_PASSWORD = \"AZURE_PASSWORD\"\n    USERNAME_PASSWORD_VARS = (AZURE_CLIENT_ID, AZURE_USERNAME, AZURE_PASSWORD)\n\n    AZURE_POD_IDENTITY_AUTHORITY_HOST = \"AZURE_POD_IDENTITY_AUTHORITY_HOST\"\n",
                    "rendered": {
                      "text": "    CERT_VARS = (AZURE_CLIENT_ID, AZURE_CLIENT_CERTIFICATE_PATH, AZURE_TENANT_ID)\n\n    AZURE_USERNAME = \"AZURE_USERNAME\"\n    AZURE_PASSWORD = \"AZURE_PASSWORD\"\n    USERNAME_PASSWORD_VARS = (AZURE_CLIENT_ID, AZURE_USERNAME, AZURE_PASSWORD)\n\n    AZURE_POD_IDENTITY_AUTHORITY_HOST = \"AZURE_POD_IDENTITY_AUTHORITY_HOST\"\n",
                      "markdown": "`    CERT_VARS = (AZURE_CLIENT_ID, AZURE_CLIENT_CERTIFICATE_PATH, AZURE_TENANT_ID)\n\n    AZURE_USERNAME = \"AZURE_USERNAME\"\n    AZURE_PASSWORD = \"AZURE_PASSWORD\"\n    USERNAME_PASSWORD_VARS = (AZURE_CLIENT_ID, AZURE_USERNAME, AZURE_PASSWORD)\n\n    AZURE_POD_IDENTITY_AUTHORITY_HOST = \"AZURE_POD_IDENTITY_AUTHORITY_HOST\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_constants.py"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 10,
                  "endLine": 51,
                  "endColumn": 18,
                  "snippet": {
                    "text": "    CERT_VARS = (AZURE_CLIENT_ID, AZURE_CLIENT_CERTIFICATE_PATH, AZURE_TENANT_ID)\n\n    AZURE_USERNAME = \"AZURE_USERNAME\"\n    AZURE_PASSWORD = \"AZURE_PASSWORD\"\n    USERNAME_PASSWORD_VARS = (AZURE_CLIENT_ID, AZURE_USERNAME, AZURE_PASSWORD)\n\n    AZURE_POD_IDENTITY_AUTHORITY_HOST = \"AZURE_POD_IDENTITY_AUTHORITY_HOST\"\n",
                    "rendered": {
                      "text": "    CERT_VARS = (AZURE_CLIENT_ID, AZURE_CLIENT_CERTIFICATE_PATH, AZURE_TENANT_ID)\n\n    AZURE_USERNAME = \"AZURE_USERNAME\"\n    AZURE_PASSWORD = \"AZURE_PASSWORD\"\n    USERNAME_PASSWORD_VARS = (AZURE_CLIENT_ID, AZURE_USERNAME, AZURE_PASSWORD)\n\n    AZURE_POD_IDENTITY_AUTHORITY_HOST = \"AZURE_POD_IDENTITY_AUTHORITY_HOST\"\n",
                      "markdown": "`    CERT_VARS = (AZURE_CLIENT_ID, AZURE_CLIENT_CERTIFICATE_PATH, AZURE_TENANT_ID)\n\n    AZURE_USERNAME = \"AZURE_USERNAME\"\n    AZURE_PASSWORD = \"AZURE_PASSWORD\"\n    USERNAME_PASSWORD_VARS = (AZURE_CLIENT_ID, AZURE_USERNAME, AZURE_PASSWORD)\n\n    AZURE_POD_IDENTITY_AUTHORITY_HOST = \"AZURE_POD_IDENTITY_AUTHORITY_HOST\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_constants.py"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 66,
                  "endLine": 46,
                  "endColumn": 74,
                  "snippet": {
                    "text": "    CLIENT_SECRET_VARS = (AZURE_CLIENT_ID, AZURE_CLIENT_SECRET, AZURE_TENANT_ID)\n\n    AZURE_CLIENT_CERTIFICATE_PATH = \"AZURE_CLIENT_CERTIFICATE_PATH\"\n    AZURE_CLIENT_CERTIFICATE_PASSWORD = \"AZURE_CLIENT_CERTIFICATE_PASSWORD\"\n    AZURE_CLIENT_SEND_CERTIFICATE_CHAIN = \"AZURE_CLIENT_SEND_CERTIFICATE_CHAIN\"\n    CERT_VARS = (AZURE_CLIENT_ID, AZURE_CLIENT_CERTIFICATE_PATH, AZURE_TENANT_ID)\n\n",
                    "rendered": {
                      "text": "    CLIENT_SECRET_VARS = (AZURE_CLIENT_ID, AZURE_CLIENT_SECRET, AZURE_TENANT_ID)\n\n    AZURE_CLIENT_CERTIFICATE_PATH = \"AZURE_CLIENT_CERTIFICATE_PATH\"\n    AZURE_CLIENT_CERTIFICATE_PASSWORD = \"AZURE_CLIENT_CERTIFICATE_PASSWORD\"\n    AZURE_CLIENT_SEND_CERTIFICATE_CHAIN = \"AZURE_CLIENT_SEND_CERTIFICATE_CHAIN\"\n    CERT_VARS = (AZURE_CLIENT_ID, AZURE_CLIENT_CERTIFICATE_PATH, AZURE_TENANT_ID)\n\n",
                      "markdown": "`    CLIENT_SECRET_VARS = (AZURE_CLIENT_ID, AZURE_CLIENT_SECRET, AZURE_TENANT_ID)\n\n    AZURE_CLIENT_CERTIFICATE_PATH = \"AZURE_CLIENT_CERTIFICATE_PATH\"\n    AZURE_CLIENT_CERTIFICATE_PASSWORD = \"AZURE_CLIENT_CERTIFICATE_PASSWORD\"\n    AZURE_CLIENT_SEND_CERTIFICATE_CHAIN = \"AZURE_CLIENT_SEND_CERTIFICATE_CHAIN\"\n    CERT_VARS = (AZURE_CLIENT_ID, AZURE_CLIENT_CERTIFICATE_PATH, AZURE_TENANT_ID)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_constants.py"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 29,
                  "endLine": 46,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    CLIENT_SECRET_VARS = (AZURE_CLIENT_ID, AZURE_CLIENT_SECRET, AZURE_TENANT_ID)\n\n    AZURE_CLIENT_CERTIFICATE_PATH = \"AZURE_CLIENT_CERTIFICATE_PATH\"\n    AZURE_CLIENT_CERTIFICATE_PASSWORD = \"AZURE_CLIENT_CERTIFICATE_PASSWORD\"\n    AZURE_CLIENT_SEND_CERTIFICATE_CHAIN = \"AZURE_CLIENT_SEND_CERTIFICATE_CHAIN\"\n    CERT_VARS = (AZURE_CLIENT_ID, AZURE_CLIENT_CERTIFICATE_PATH, AZURE_TENANT_ID)\n\n",
                    "rendered": {
                      "text": "    CLIENT_SECRET_VARS = (AZURE_CLIENT_ID, AZURE_CLIENT_SECRET, AZURE_TENANT_ID)\n\n    AZURE_CLIENT_CERTIFICATE_PATH = \"AZURE_CLIENT_CERTIFICATE_PATH\"\n    AZURE_CLIENT_CERTIFICATE_PASSWORD = \"AZURE_CLIENT_CERTIFICATE_PASSWORD\"\n    AZURE_CLIENT_SEND_CERTIFICATE_CHAIN = \"AZURE_CLIENT_SEND_CERTIFICATE_CHAIN\"\n    CERT_VARS = (AZURE_CLIENT_ID, AZURE_CLIENT_CERTIFICATE_PATH, AZURE_TENANT_ID)\n\n",
                      "markdown": "`    CLIENT_SECRET_VARS = (AZURE_CLIENT_ID, AZURE_CLIENT_SECRET, AZURE_TENANT_ID)\n\n    AZURE_CLIENT_CERTIFICATE_PATH = \"AZURE_CLIENT_CERTIFICATE_PATH\"\n    AZURE_CLIENT_CERTIFICATE_PASSWORD = \"AZURE_CLIENT_CERTIFICATE_PASSWORD\"\n    AZURE_CLIENT_SEND_CERTIFICATE_CHAIN = \"AZURE_CLIENT_SEND_CERTIFICATE_CHAIN\"\n    CERT_VARS = (AZURE_CLIENT_ID, AZURE_CLIENT_CERTIFICATE_PATH, AZURE_TENANT_ID)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 55,
                  "endLine": 54,
                  "endColumn": 60,
                  "snippet": {
                    "text": "    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n                \"'tenant_id' is required. Please pass it in or set the \"\n",
                    "rendered": {
                      "text": "    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n                \"'tenant_id' is required. Please pass it in or set the \"\n",
                      "markdown": "`    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n                \"'tenant_id' is required. Please pass it in or set the \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 43,
                  "endLine": 53,
                  "endColumn": 48,
                  "snippet": {
                    "text": "        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n",
                    "rendered": {
                      "text": "        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n",
                      "markdown": "`        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 43,
                  "endLine": 52,
                  "endColumn": 48,
                  "snippet": {
                    "text": "        token_file_path: Optional[str] = None,\n        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n",
                    "rendered": {
                      "text": "        token_file_path: Optional[str] = None,\n        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n",
                      "markdown": "`        token_file_path: Optional[str] = None,\n        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 48,
                  "endLine": 54,
                  "endColumn": 59,
                  "snippet": {
                    "text": "    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n                \"'tenant_id' is required. Please pass it in or set the \"\n",
                    "rendered": {
                      "text": "    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n                \"'tenant_id' is required. Please pass it in or set the \"\n",
                      "markdown": "`    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n                \"'tenant_id' is required. Please pass it in or set the \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 36,
                  "endLine": 53,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n",
                    "rendered": {
                      "text": "        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n",
                      "markdown": "`        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n            raise ValueError(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 36,
                  "endLine": 52,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        token_file_path: Optional[str] = None,\n        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n",
                    "rendered": {
                      "text": "        token_file_path: Optional[str] = None,\n        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n",
                      "markdown": "`        token_file_path: Optional[str] = None,\n        **kwargs: Any,\n    ) -> None:\n        tenant_id = tenant_id or os.environ.get(EnvironmentVariables.AZURE_TENANT_ID)\n        client_id = client_id or os.environ.get(EnvironmentVariables.AZURE_CLIENT_ID)\n        token_file_path = token_file_path or os.environ.get(EnvironmentVariables.AZURE_FEDERATED_TOKEN_FILE)\n        if not tenant_id:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 76,
                  "endLine": 31,
                  "endColumn": 85,
                  "snippet": {
                    "text": "\n    :keyword str tenant_id: ID of the application's Microsoft Entra tenant. Also called its \"directory\" ID.\n    :keyword str client_id: The client ID of a Microsoft Entra app registration.\n    :keyword str token_file_path: The path to a file containing a Kubernetes service account token that authenticates\n        the identity.\n\n    .. admonition:: Example:\n",
                    "rendered": {
                      "text": "\n    :keyword str tenant_id: ID of the application's Microsoft Entra tenant. Also called its \"directory\" ID.\n    :keyword str client_id: The client ID of a Microsoft Entra app registration.\n    :keyword str token_file_path: The path to a file containing a Kubernetes service account token that authenticates\n        the identity.\n\n    .. admonition:: Example:\n",
                      "markdown": "`\n    :keyword str tenant_id: ID of the application's Microsoft Entra tenant. Also called its \"directory\" ID.\n    :keyword str client_id: The client ID of a Microsoft Entra app registration.\n    :keyword str token_file_path: The path to a file containing a Kubernetes service account token that authenticates\n        the identity.\n\n    .. admonition:: Example:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 21,
                  "endLine": 25,
                  "endColumn": 30,
                  "snippet": {
                    "text": "    Azure, you don't need to worry about storing and securing sensitive credentials themselves.\n\n    The WorkloadIdentityCredential supports Azure workload identity authentication on Azure Kubernetes and acquires\n    a token using the service account credentials available in the Azure Kubernetes environment. Refer\n    to `this workload identity overview <https://learn.microsoft.com/azure/aks/workload-identity-overview>`__\n    for more information.\n\n",
                    "rendered": {
                      "text": "    Azure, you don't need to worry about storing and securing sensitive credentials themselves.\n\n    The WorkloadIdentityCredential supports Azure workload identity authentication on Azure Kubernetes and acquires\n    a token using the service account credentials available in the Azure Kubernetes environment. Refer\n    to `this workload identity overview <https://learn.microsoft.com/azure/aks/workload-identity-overview>`__\n    for more information.\n\n",
                      "markdown": "`    Azure, you don't need to worry about storing and securing sensitive credentials themselves.\n\n    The WorkloadIdentityCredential supports Azure workload identity authentication on Azure Kubernetes and acquires\n    a token using the service account credentials available in the Azure Kubernetes environment. Refer\n    to `this workload identity overview <https://learn.microsoft.com/azure/aks/workload-identity-overview>`__\n    for more information.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 81,
                  "endLine": 20,
                  "endColumn": 90,
                  "snippet": {
                    "text": "incipal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using\n    workload identity authentication, you can avoid the need to manage and rotate service principals or managed\n    identities for each application on each VM. Additionally, because SACs are created automatically and managed by\n    Azure, you don't need to worry about storing and securing sensitive credentials themselves.\n\n    The WorkloadIdentityCredential supports Azure workload identi",
                    "rendered": {
                      "text": "incipal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using\n    workload identity authentication, you can avoid the need to manage and rotate service principals or managed\n    identities for each application on each VM. Additionally, because SACs are created automatically and managed by\n    Azure, you don't need to worry about storing and securing sensitive credentials themselves.\n\n    The WorkloadIdentityCredential supports Azure workload identi",
                      "markdown": "`incipal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using\n    workload identity authentication, you can avoid the need to manage and rotate service principals or managed\n    identities for each application on each VM. Additionally, because SACs are created automatically and managed by\n    Azure, you don't need to worry about storing and securing sensitive credentials themselves.\n\n    The WorkloadIdentityCredential supports Azure workload identi`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 111,
                  "endLine": 19,
                  "snippet": {
                    "text": "t the need for a service principal or managed identity. With workload\n    identity authentication, applications authenticate themselves using their own identity, rather than using a shared\n    service principal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using\n    workload identity authentication, you can avoid the need to manage and rotate service principals or managed\n    identities for each application on each VM. Additionally, because SACs ",
                    "rendered": {
                      "text": "t the need for a service principal or managed identity. With workload\n    identity authentication, applications authenticate themselves using their own identity, rather than using a shared\n    service principal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using\n    workload identity authentication, you can avoid the need to manage and rotate service principals or managed\n    identities for each application on each VM. Additionally, because SACs ",
                      "markdown": "`t the need for a service principal or managed identity. With workload\n    identity authentication, applications authenticate themselves using their own identity, rather than using a shared\n    service principal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using\n    workload identity authentication, you can avoid the need to manage and rotate service principals or managed\n    identities for each application on each VM. Additionally, because SACs `"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 3,
                  "endLine": 18,
                  "endColumn": 12,
                  "snippet": {
                    "text": " Azure that allows applications running on virtual machines (VMs)\n    to access other Azure resources without the need for a service principal or managed identity. With workload\n    identity authentication, applications authenticate themselves using their own identity, rather than using a shared\n    service principal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using\n    workload identity authentication, you can avoid the need to manage and rota",
                    "rendered": {
                      "text": " Azure that allows applications running on virtual machines (VMs)\n    to access other Azure resources without the need for a service principal or managed identity. With workload\n    identity authentication, applications authenticate themselves using their own identity, rather than using a shared\n    service principal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using\n    workload identity authentication, you can avoid the need to manage and rota",
                      "markdown": "` Azure that allows applications running on virtual machines (VMs)\n    to access other Azure resources without the need for a service principal or managed identity. With workload\n    identity authentication, applications authenticate themselves using their own identity, rather than using a shared\n    service principal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using\n    workload identity authentication, you can avoid the need to manage and rota`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/workload_identity.py"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 58,
                  "endLine": 16,
                  "endColumn": 67,
                  "snippet": {
                    "text": "loadIdentityCredential(ClientAssertionCredential, TokenFileMixin):\n    \"\"\"Authenticates using Microsoft Entra Workload ID.\n\n    Workload identity authentication is a feature in Azure that allows applications running on virtual machines (VMs)\n    to access other Azure resources without the need for a service principal or managed identity. With workload\n    identity authentication, applications authenticate themselves using their own identity, rather than using a shared\n    service principal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Cred",
                    "rendered": {
                      "text": "loadIdentityCredential(ClientAssertionCredential, TokenFileMixin):\n    \"\"\"Authenticates using Microsoft Entra Workload ID.\n\n    Workload identity authentication is a feature in Azure that allows applications running on virtual machines (VMs)\n    to access other Azure resources without the need for a service principal or managed identity. With workload\n    identity authentication, applications authenticate themselves using their own identity, rather than using a shared\n    service principal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Cred",
                      "markdown": "`loadIdentityCredential(ClientAssertionCredential, TokenFileMixin):\n    \"\"\"Authenticates using Microsoft Entra Workload ID.\n\n    Workload identity authentication is a feature in Azure that allows applications running on virtual machines (VMs)\n    to access other Azure resources without the need for a service principal or managed identity. With workload\n    identity authentication, applications authenticate themselves using their own identity, rather than using a shared\n    service principal or managed identity. Under the hood, workload identity authentication uses the concept of Service\n    Account Cred`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/vscode.py"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 21,
                  "endLine": 109,
                  "endColumn": 26,
                  "snippet": {
                    "text": "                \" to troubleshoot this issue.\"\n            )\n            raise CredentialUnavailableError(message=error_message)\n        if within_dac.get():\n            try:\n                token = await super().get_token_info(*scopes, options=options)\n                return token\n",
                    "rendered": {
                      "text": "                \" to troubleshoot this issue.\"\n            )\n            raise CredentialUnavailableError(message=error_message)\n        if within_dac.get():\n            try:\n                token = await super().get_token_info(*scopes, options=options)\n                return token\n",
                      "markdown": "`                \" to troubleshoot this issue.\"\n            )\n            raise CredentialUnavailableError(message=error_message)\n        if within_dac.get():\n            try:\n                token = await super().get_token_info(*scopes, options=options)\n                return token\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/vscode.py"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 21,
                  "endLine": 78,
                  "endColumn": 26,
                  "snippet": {
                    "text": "            raise CredentialUnavailableError(message=error_message)\n        if not self._client:\n            raise CredentialUnavailableError(\"Initialization failed\")\n        if within_dac.get():\n            try:\n                token = await super().get_token(*scopes, claims=claims, tenant_id=tenant_id, **kwargs)\n                return token\n",
                    "rendered": {
                      "text": "            raise CredentialUnavailableError(message=error_message)\n        if not self._client:\n            raise CredentialUnavailableError(\"Initialization failed\")\n        if within_dac.get():\n            try:\n                token = await super().get_token(*scopes, claims=claims, tenant_id=tenant_id, **kwargs)\n                return token\n",
                      "markdown": "`            raise CredentialUnavailableError(message=error_message)\n        if not self._client:\n            raise CredentialUnavailableError(\"Initialization failed\")\n        if within_dac.get():\n            try:\n                token = await super().get_token(*scopes, claims=claims, tenant_id=tenant_id, **kwargs)\n                return token\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/vscode.py"
                },
                "region": {
                  "startLine": 92,
                  "startColumn": 84,
                  "endLine": 92,
                  "endColumn": 88,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/vscode.py"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 84,
                  "endLine": 57,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/shared_cache.py"
                },
                "region": {
                  "startLine": 151,
                  "startColumn": 72,
                  "endLine": 151,
                  "endColumn": 77,
                  "snippet": {
                    "text": "            )\n            return token\n\n        raise CredentialUnavailableError(message=NO_TOKEN.format(account.get(\"username\")))\n\n    def _get_auth_client(self, **kwargs: Any) -> AadClientBase:\n        return AadClient(client_id=DEVELOPER_SIGN_ON_CLIENT_ID, **kwargs)\n",
                    "rendered": {
                      "text": "            )\n            return token\n\n        raise CredentialUnavailableError(message=NO_TOKEN.format(account.get(\"username\")))\n\n    def _get_auth_client(self, **kwargs: Any) -> AadClientBase:\n        return AadClient(client_id=DEVELOPER_SIGN_ON_CLIENT_ID, **kwargs)\n",
                      "markdown": "`            )\n            return token\n\n        raise CredentialUnavailableError(message=NO_TOKEN.format(account.get(\"username\")))\n\n    def _get_auth_client(self, **kwargs: Any) -> AadClientBase:\n        return AadClient(client_id=DEVELOPER_SIGN_ON_CLIENT_ID, **kwargs)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/shared_cache.py"
                },
                "region": {
                  "startLine": 126,
                  "startColumn": 24,
                  "endLine": 126,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        is_cae = options.get(\"enable_cae\", False)\n\n        token_cache = self._cae_cache if is_cae else self._cache\n\n",
                    "rendered": {
                      "text": "        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        is_cae = options.get(\"enable_cae\", False)\n\n        token_cache = self._cae_cache if is_cae else self._cache\n\n",
                      "markdown": "`        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        is_cae = options.get(\"enable_cae\", False)\n\n        token_cache = self._cae_cache if is_cae else self._cache\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/shared_cache.py"
                },
                "region": {
                  "startLine": 125,
                  "startColumn": 27,
                  "endLine": 125,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        is_cae = options.get(\"enable_cae\", False)\n\n        token_cache = self._cae_cache if is_cae else self._cache\n",
                    "rendered": {
                      "text": "\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        is_cae = options.get(\"enable_cae\", False)\n\n        token_cache = self._cae_cache if is_cae else self._cache\n",
                      "markdown": "`\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        is_cae = options.get(\"enable_cae\", False)\n\n        token_cache = self._cae_cache if is_cae else self._cache\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/shared_cache.py"
                },
                "region": {
                  "startLine": 124,
                  "startColumn": 24,
                  "endLine": 124,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            self._initialize_client()\n\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        is_cae = options.get(\"enable_cae\", False)\n\n",
                    "rendered": {
                      "text": "            self._initialize_client()\n\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        is_cae = options.get(\"enable_cae\", False)\n\n",
                      "markdown": "`            self._initialize_client()\n\n        options = options or {}\n        claims = options.get(\"claims\")\n        tenant_id = options.get(\"tenant_id\")\n        is_cae = options.get(\"enable_cae\", False)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/shared_cache.py"
                },
                "region": {
                  "startLine": 118,
                  "startColumn": 60,
                  "endLine": 118,
                  "endColumn": 64,
                  "snippet": {
                    "text": "        **kwargs: Any,\n    ) -> AccessTokenInfo:\n        if not scopes:\n            raise ValueError(f\"'{base_method_name}' requires at least one scope\")\n\n        if not self._client_initialized:\n            self._initialize_client()\n",
                    "rendered": {
                      "text": "        **kwargs: Any,\n    ) -> AccessTokenInfo:\n        if not scopes:\n            raise ValueError(f\"'{base_method_name}' requires at least one scope\")\n\n        if not self._client_initialized:\n            self._initialize_client()\n",
                      "markdown": "`        **kwargs: Any,\n    ) -> AccessTokenInfo:\n        if not scopes:\n            raise ValueError(f\"'{base_method_name}' requires at least one scope\")\n\n        if not self._client_initialized:\n            self._initialize_client()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/shared_cache.py"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 83,
                  "endLine": 95,
                  "endColumn": 87,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scope for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scope for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scope for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/aio/_credentials/shared_cache.py"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 84,
                  "endLine": 59,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_persistent_cache.py"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 76,
                  "endLine": 102,
                  "endColumn": 92,
                  "snippet": {
                    "text": "        file_path = os.path.expanduser(os.path.join(\"~\", \".IdentityService\", cache_name))\n        try:\n            return msal_extensions.LibsecretPersistence(\n                file_path, cache_name, {\"MsalClientID\": \"Microsoft.Developer.IdentityService\"}, label=account_name\n            )\n        except Exception as ex:  # pylint:disable=broad-except\n            _LOGGER.debug('msal-extensions is unable to encrypt a persistent cache: \"%s\"', ex, exc_info=True)\n",
                    "rendered": {
                      "text": "        file_path = os.path.expanduser(os.path.join(\"~\", \".IdentityService\", cache_name))\n        try:\n            return msal_extensions.LibsecretPersistence(\n                file_path, cache_name, {\"MsalClientID\": \"Microsoft.Developer.IdentityService\"}, label=account_name\n            )\n        except Exception as ex:  # pylint:disable=broad-except\n            _LOGGER.debug('msal-extensions is unable to encrypt a persistent cache: \"%s\"', ex, exc_info=True)\n",
                      "markdown": "`        file_path = os.path.expanduser(os.path.join(\"~\", \".IdentityService\", cache_name))\n        try:\n            return msal_extensions.LibsecretPersistence(\n                file_path, cache_name, {\"MsalClientID\": \"Microsoft.Developer.IdentityService\"}, label=account_name\n            )\n        except Exception as ex:  # pylint:disable=broad-except\n            _LOGGER.debug('msal-extensions is unable to encrypt a persistent cache: \"%s\"', ex, exc_info=True)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_persistent_cache.py"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 58,
                  "endLine": 99,
                  "endColumn": 74,
                  "snippet": {
                    "text": "    if sys.platform.startswith(\"linux\"):\n        # The cache uses this file's modified timestamp to decide whether to reload. Note this path is the same\n        # as that of the plaintext fallback: a new encrypted cache will stomp an unencrypted cache.\n        file_path = os.path.expanduser(os.path.join(\"~\", \".IdentityService\", cache_name))\n        try:\n            return msal_extensions.LibsecretPersistence(\n                file_path, cache_name, {\"MsalClientID\": \"Microsoft.Developer.IdentityService\"}, label=account_name\n",
                    "rendered": {
                      "text": "    if sys.platform.startswith(\"linux\"):\n        # The cache uses this file's modified timestamp to decide whether to reload. Note this path is the same\n        # as that of the plaintext fallback: a new encrypted cache will stomp an unencrypted cache.\n        file_path = os.path.expanduser(os.path.join(\"~\", \".IdentityService\", cache_name))\n        try:\n            return msal_extensions.LibsecretPersistence(\n                file_path, cache_name, {\"MsalClientID\": \"Microsoft.Developer.IdentityService\"}, label=account_name\n",
                      "markdown": "`    if sys.platform.startswith(\"linux\"):\n        # The cache uses this file's modified timestamp to decide whether to reload. Note this path is the same\n        # as that of the plaintext fallback: a new encrypted cache will stomp an unencrypted cache.\n        file_path = os.path.expanduser(os.path.join(\"~\", \".IdentityService\", cache_name))\n        try:\n            return msal_extensions.LibsecretPersistence(\n                file_path, cache_name, {\"MsalClientID\": \"Microsoft.Developer.IdentityService\"}, label=account_name\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_persistent_cache.py"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 82,
                  "endLine": 94,
                  "endColumn": 98,
                  "snippet": {
                    "text": "    if sys.platform.startswith(\"darwin\"):\n        # the cache uses this file's modified timestamp to decide whether to reload\n        file_path = os.path.expanduser(os.path.join(\"~\", \".IdentityService\", cache_name))\n        return msal_extensions.KeychainPersistence(file_path, \"Microsoft.Developer.IdentityService\", account_name)\n\n    if sys.platform.startswith(\"linux\"):\n        # The cache uses this file's modified timestamp to decide whether to reload. Note this path is the same\n",
                    "rendered": {
                      "text": "    if sys.platform.startswith(\"darwin\"):\n        # the cache uses this file's modified timestamp to decide whether to reload\n        file_path = os.path.expanduser(os.path.join(\"~\", \".IdentityService\", cache_name))\n        return msal_extensions.KeychainPersistence(file_path, \"Microsoft.Developer.IdentityService\", account_name)\n\n    if sys.platform.startswith(\"linux\"):\n        # The cache uses this file's modified timestamp to decide whether to reload. Note this path is the same\n",
                      "markdown": "`    if sys.platform.startswith(\"darwin\"):\n        # the cache uses this file's modified timestamp to decide whether to reload\n        file_path = os.path.expanduser(os.path.join(\"~\", \".IdentityService\", cache_name))\n        return msal_extensions.KeychainPersistence(file_path, \"Microsoft.Developer.IdentityService\", account_name)\n\n    if sys.platform.startswith(\"linux\"):\n        # The cache uses this file's modified timestamp to decide whether to reload. Note this path is the same\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_persistent_cache.py"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 58,
                  "endLine": 93,
                  "endColumn": 74,
                  "snippet": {
                    "text": "\n    if sys.platform.startswith(\"darwin\"):\n        # the cache uses this file's modified timestamp to decide whether to reload\n        file_path = os.path.expanduser(os.path.join(\"~\", \".IdentityService\", cache_name))\n        return msal_extensions.KeychainPersistence(file_path, \"Microsoft.Developer.IdentityService\", account_name)\n\n    if sys.platform.startswith(\"linux\"):\n",
                    "rendered": {
                      "text": "\n    if sys.platform.startswith(\"darwin\"):\n        # the cache uses this file's modified timestamp to decide whether to reload\n        file_path = os.path.expanduser(os.path.join(\"~\", \".IdentityService\", cache_name))\n        return msal_extensions.KeychainPersistence(file_path, \"Microsoft.Developer.IdentityService\", account_name)\n\n    if sys.platform.startswith(\"linux\"):\n",
                      "markdown": "`\n    if sys.platform.startswith(\"darwin\"):\n        # the cache uses this file's modified timestamp to decide whether to reload\n        file_path = os.path.expanduser(os.path.join(\"~\", \".IdentityService\", cache_name))\n        return msal_extensions.KeychainPersistence(file_path, \"Microsoft.Developer.IdentityService\", account_name)\n\n    if sys.platform.startswith(\"linux\"):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_persistent_cache.py"
                },
                "region": {
                  "startLine": 88,
                  "startColumn": 67,
                  "endLine": 88,
                  "endColumn": 83,
                  "snippet": {
                    "text": "    import msal_extensions\n\n    if sys.platform.startswith(\"win\") and \"LOCALAPPDATA\" in os.environ:\n        cache_location = os.path.join(os.environ[\"LOCALAPPDATA\"], \".IdentityService\", cache_name)\n        return msal_extensions.FilePersistenceWithDataProtection(cache_location)\n\n    if sys.platform.startswith(\"darwin\"):\n",
                    "rendered": {
                      "text": "    import msal_extensions\n\n    if sys.platform.startswith(\"win\") and \"LOCALAPPDATA\" in os.environ:\n        cache_location = os.path.join(os.environ[\"LOCALAPPDATA\"], \".IdentityService\", cache_name)\n        return msal_extensions.FilePersistenceWithDataProtection(cache_location)\n\n    if sys.platform.startswith(\"darwin\"):\n",
                      "markdown": "`    import msal_extensions\n\n    if sys.platform.startswith(\"win\") and \"LOCALAPPDATA\" in os.environ:\n        cache_location = os.path.join(os.environ[\"LOCALAPPDATA\"], \".IdentityService\", cache_name)\n        return msal_extensions.FilePersistenceWithDataProtection(cache_location)\n\n    if sys.platform.startswith(\"darwin\"):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_persistent_cache.py"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 77,
                  "endLine": 109,
                  "endColumn": 82,
                  "snippet": {
                    "text": "            if not allow_unencrypted:\n                error = ValueError(\n                    \"Cache encryption is impossible because libsecret dependencies are not installed or are unusable,\"\n                    + \" for example because no display is available (as in an SSH session). The chained exception has\"\n                    + ' more information. Specify \"allow_unencrypted_storage=True\" to store the cache unencrypted'\n                    + \" instead of raising this exception.\"\n                )\n",
                    "rendered": {
                      "text": "            if not allow_unencrypted:\n                error = ValueError(\n                    \"Cache encryption is impossible because libsecret dependencies are not installed or are unusable,\"\n                    + \" for example because no display is available (as in an SSH session). The chained exception has\"\n                    + ' more information. Specify \"allow_unencrypted_storage=True\" to store the cache unencrypted'\n                    + \" instead of raising this exception.\"\n                )\n",
                      "markdown": "`            if not allow_unencrypted:\n                error = ValueError(\n                    \"Cache encryption is impossible because libsecret dependencies are not installed or are unusable,\"\n                    + \" for example because no display is available (as in an SSH session). The chained exception has\"\n                    + ' more information. Specify \"allow_unencrypted_storage=True\" to store the cache unencrypted'\n                    + \" instead of raising this exception.\"\n                )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/utils.py"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 45,
                  "endLine": 93,
                  "endColumn": 50,
                  "snippet": {
                    "text": "    \"\"\"\n    if tenant_id is None or tenant_id == default_tenant:\n        return default_tenant\n    if default_tenant == \"adfs\" or os.environ.get(EnvironmentVariables.AZURE_IDENTITY_DISABLE_MULTITENANTAUTH):\n        _LOGGER.info(\n            \"A token was request for a different tenant than was configured on the credential, \"\n            \"but the configured value was used since multi tenant authentication has been disabled. \"\n",
                    "rendered": {
                      "text": "    \"\"\"\n    if tenant_id is None or tenant_id == default_tenant:\n        return default_tenant\n    if default_tenant == \"adfs\" or os.environ.get(EnvironmentVariables.AZURE_IDENTITY_DISABLE_MULTITENANTAUTH):\n        _LOGGER.info(\n            \"A token was request for a different tenant than was configured on the credential, \"\n            \"but the configured value was used since multi tenant authentication has been disabled. \"\n",
                      "markdown": "`    \"\"\"\n    if tenant_id is None or tenant_id == default_tenant:\n        return default_tenant\n    if default_tenant == \"adfs\" or os.environ.get(EnvironmentVariables.AZURE_IDENTITY_DISABLE_MULTITENANTAUTH):\n        _LOGGER.info(\n            \"A token was request for a different tenant than was configured on the credential, \"\n            \"but the configured value was used since multi tenant authentication has been disabled. \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/utils.py"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 26,
                  "endLine": 46,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n\ndef get_default_authority() -> str:\n    authority = os.environ.get(EnvironmentVariables.AZURE_AUTHORITY_HOST, KnownAuthorities.AZURE_PUBLIC_CLOUD)\n    return normalize_authority(authority)\n\n\n",
                    "rendered": {
                      "text": "\n\ndef get_default_authority() -> str:\n    authority = os.environ.get(EnvironmentVariables.AZURE_AUTHORITY_HOST, KnownAuthorities.AZURE_PUBLIC_CLOUD)\n    return normalize_authority(authority)\n\n\n",
                      "markdown": "`\n\ndef get_default_authority() -> str:\n    authority = os.environ.get(EnvironmentVariables.AZURE_AUTHORITY_HOST, KnownAuthorities.AZURE_PUBLIC_CLOUD)\n    return normalize_authority(authority)\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/utils.py"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 38,
                  "endLine": 93,
                  "endColumn": 49,
                  "snippet": {
                    "text": "    \"\"\"\n    if tenant_id is None or tenant_id == default_tenant:\n        return default_tenant\n    if default_tenant == \"adfs\" or os.environ.get(EnvironmentVariables.AZURE_IDENTITY_DISABLE_MULTITENANTAUTH):\n        _LOGGER.info(\n            \"A token was request for a different tenant than was configured on the credential, \"\n            \"but the configured value was used since multi tenant authentication has been disabled. \"\n",
                    "rendered": {
                      "text": "    \"\"\"\n    if tenant_id is None or tenant_id == default_tenant:\n        return default_tenant\n    if default_tenant == \"adfs\" or os.environ.get(EnvironmentVariables.AZURE_IDENTITY_DISABLE_MULTITENANTAUTH):\n        _LOGGER.info(\n            \"A token was request for a different tenant than was configured on the credential, \"\n            \"but the configured value was used since multi tenant authentication has been disabled. \"\n",
                      "markdown": "`    \"\"\"\n    if tenant_id is None or tenant_id == default_tenant:\n        return default_tenant\n    if default_tenant == \"adfs\" or os.environ.get(EnvironmentVariables.AZURE_IDENTITY_DISABLE_MULTITENANTAUTH):\n        _LOGGER.info(\n            \"A token was request for a different tenant than was configured on the credential, \"\n            \"but the configured value was used since multi tenant authentication has been disabled. \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_internal/utils.py"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 19,
                  "endLine": 46,
                  "endColumn": 30,
                  "snippet": {
                    "text": "\n\ndef get_default_authority() -> str:\n    authority = os.environ.get(EnvironmentVariables.AZURE_AUTHORITY_HOST, KnownAuthorities.AZURE_PUBLIC_CLOUD)\n    return normalize_authority(authority)\n\n\n",
                    "rendered": {
                      "text": "\n\ndef get_default_authority() -> str:\n    authority = os.environ.get(EnvironmentVariables.AZURE_AUTHORITY_HOST, KnownAuthorities.AZURE_PUBLIC_CLOUD)\n    return normalize_authority(authority)\n\n\n",
                      "markdown": "`\n\ndef get_default_authority() -> str:\n    authority = os.environ.get(EnvironmentVariables.AZURE_AUTHORITY_HOST, KnownAuthorities.AZURE_PUBLIC_CLOUD)\n    return normalize_authority(authority)\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/client_assertion.py"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 96,
                  "endLine": 20,
                  "endColumn": 102,
                  "snippet": {
                    "text": "\n    :param str tenant_id: ID of the principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The principal's client ID\n    :param func: A callable that returns a string assertion. The credential will call this every time it\n        acquires a new token.\n    :paramtype func: Callable[[], str]\n\n",
                    "rendered": {
                      "text": "\n    :param str tenant_id: ID of the principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The principal's client ID\n    :param func: A callable that returns a string assertion. The credential will call this every time it\n        acquires a new token.\n    :paramtype func: Callable[[], str]\n\n",
                      "markdown": "`\n    :param str tenant_id: ID of the principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The principal's client ID\n    :param func: A callable that returns a string assertion. The credential will call this every time it\n        acquires a new token.\n    :paramtype func: Callable[[], str]\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/client_assertion.py"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 75,
                  "endLine": 16,
                  "endColumn": 84,
                  "snippet": {
                    "text": "    \"\"\"Authenticates a service principal with a JWT assertion.\n\n    This credential is for advanced scenarios. :class:`~azure.identity.CertificateCredential` has a more\n    convenient API for the most common assertion scenario, authenticating a service principal with a certificate.\n\n    :param str tenant_id: ID of the principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The principal's client ID\n",
                    "rendered": {
                      "text": "    \"\"\"Authenticates a service principal with a JWT assertion.\n\n    This credential is for advanced scenarios. :class:`~azure.identity.CertificateCredential` has a more\n    convenient API for the most common assertion scenario, authenticating a service principal with a certificate.\n\n    :param str tenant_id: ID of the principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The principal's client ID\n",
                      "markdown": "`    \"\"\"Authenticates a service principal with a JWT assertion.\n\n    This credential is for advanced scenarios. :class:`~azure.identity.CertificateCredential` has a more\n    convenient API for the most common assertion scenario, authenticating a service principal with a certificate.\n\n    :param str tenant_id: ID of the principal's tenant. Also called its \"directory\" ID.\n    :param str client_id: The principal's client ID\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/client_assertion.py"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 22,
                  "endLine": 13,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n\nclass ClientAssertionCredential(GetTokenMixin):\n    \"\"\"Authenticates a service principal with a JWT assertion.\n\n    This credential is for advanced scenarios. :class:`~azure.identity.CertificateCredential` has a more\n    convenient API for the most common assertion scenario, authenticating a service principal with a certificate.\n",
                    "rendered": {
                      "text": "\n\nclass ClientAssertionCredential(GetTokenMixin):\n    \"\"\"Authenticates a service principal with a JWT assertion.\n\n    This credential is for advanced scenarios. :class:`~azure.identity.CertificateCredential` has a more\n    convenient API for the most common assertion scenario, authenticating a service principal with a certificate.\n",
                      "markdown": "`\n\nclass ClientAssertionCredential(GetTokenMixin):\n    \"\"\"Authenticates a service principal with a JWT assertion.\n\n    This credential is for advanced scenarios. :class:`~azure.identity.CertificateCredential` has a more\n    convenient API for the most common assertion scenario, authenticating a service principal with a certificate.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/chained.py"
                },
                "region": {
                  "startLine": 183,
                  "startColumn": 30,
                  "endLine": 183,
                  "endColumn": 35,
                  "snippet": {
                    "text": "                if hasattr(credential, \"get_token_info\"):\n                    token_info = cast(SupportsTokenInfo, credential).get_token_info(*scopes, options=options)\n                else:\n                    if options.get(\"pop\"):\n                        raise CredentialUnavailableError(\n                            \"Proof of possession arguments are not supported for this credential.\"\n                        )\n",
                    "rendered": {
                      "text": "                if hasattr(credential, \"get_token_info\"):\n                    token_info = cast(SupportsTokenInfo, credential).get_token_info(*scopes, options=options)\n                else:\n                    if options.get(\"pop\"):\n                        raise CredentialUnavailableError(\n                            \"Proof of possession arguments are not supported for this credential.\"\n                        )\n",
                      "markdown": "`                if hasattr(credential, \"get_token_info\"):\n                    token_info = cast(SupportsTokenInfo, credential).get_token_info(*scopes, options=options)\n                else:\n                    if options.get(\"pop\"):\n                        raise CredentialUnavailableError(\n                            \"Proof of possession arguments are not supported for this credential.\"\n                        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/chained.py"
                },
                "region": {
                  "startLine": 215,
                  "startColumn": 92,
                  "endLine": 215,
                  "endColumn": 96,
                  "snippet": {
                    "text": "            self.__class__.__name__\n            + \" failed to retrieve a token from the included credentials.\"\n            + attempts\n            + \"\\nTo mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/defaultazurecredential/troubleshoot.\"\n        )\n        _LOGGER.warning(message)\n",
                    "rendered": {
                      "text": "            self.__class__.__name__\n            + \" failed to retrieve a token from the included credentials.\"\n            + attempts\n            + \"\\nTo mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/defaultazurecredential/troubleshoot.\"\n        )\n        _LOGGER.warning(message)\n",
                      "markdown": "`            self.__class__.__name__\n            + \" failed to retrieve a token from the included credentials.\"\n            + attempts\n            + \"\\nTo mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/defaultazurecredential/troubleshoot.\"\n        )\n        _LOGGER.warning(message)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/chained.py"
                },
                "region": {
                  "startLine": 164,
                  "startColumn": 84,
                  "endLine": 164,
                  "endColumn": 88,
                  "snippet": {
                    "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                    "rendered": {
                      "text": "        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n",
                      "markdown": "`        This is an alternative to `get_token` to enable certain scenarios that require additional properties\n        on the token. This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword options: A dictionary of options for the token request. Unknown options will be ignored. Optional.\n        :paramtype options: ~azure.core.credentials.TokenRequestOptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/chained.py"
                },
                "region": {
                  "startLine": 149,
                  "startColumn": 92,
                  "endLine": 149,
                  "endColumn": 96,
                  "snippet": {
                    "text": "            self.__class__.__name__\n            + \" failed to retrieve a token from the included credentials.\"\n            + attempts\n            + \"\\nTo mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/defaultazurecredential/troubleshoot.\"\n        )\n        _LOGGER.warning(message)\n",
                    "rendered": {
                      "text": "            self.__class__.__name__\n            + \" failed to retrieve a token from the included credentials.\"\n            + attempts\n            + \"\\nTo mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/defaultazurecredential/troubleshoot.\"\n        )\n        _LOGGER.warning(message)\n",
                      "markdown": "`            self.__class__.__name__\n            + \" failed to retrieve a token from the included credentials.\"\n            + attempts\n            + \"\\nTo mitigate this issue, please refer to the troubleshooting guidelines here at \"\n            \"https://aka.ms/azsdk/python/identity/defaultazurecredential/troubleshoot.\"\n        )\n        _LOGGER.warning(message)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/_credentials/chained.py"
                },
                "region": {
                  "startLine": 91,
                  "startColumn": 84,
                  "endLine": 91,
                  "endColumn": 88,
                  "snippet": {
                    "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                    "rendered": {
                      "text": "\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n",
                      "markdown": "`\n        This method is called automatically by Azure SDK clients.\n\n        :param str scopes: desired scopes for the access token. This method requires at least one scope.\n            For more information about scopes, see\n            https://learn.microsoft.com/entra/identity-platform/scopes-oidc.\n        :keyword str claims: additional claims required in the token, such as those returned in a resource provider's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/__init__.py"
                },
                "region": {
                  "startLine": 58,
                  "startColumn": 13,
                  "endLine": 58,
                  "endColumn": 21,
                  "snippet": {
                    "text": "    \"ManagedIdentityCredential\",\n    \"SharedTokenCacheCredential\",\n    \"TokenCachePersistenceOptions\",\n    \"UsernamePasswordCredential\",\n    \"VisualStudioCodeCredential\",\n    \"WorkloadIdentityCredential\",\n    \"get_bearer_token_provider\",\n",
                    "rendered": {
                      "text": "    \"ManagedIdentityCredential\",\n    \"SharedTokenCacheCredential\",\n    \"TokenCachePersistenceOptions\",\n    \"UsernamePasswordCredential\",\n    \"VisualStudioCodeCredential\",\n    \"WorkloadIdentityCredential\",\n    \"get_bearer_token_provider\",\n",
                      "markdown": "`    \"ManagedIdentityCredential\",\n    \"SharedTokenCacheCredential\",\n    \"TokenCachePersistenceOptions\",\n    \"UsernamePasswordCredential\",\n    \"VisualStudioCodeCredential\",\n    \"WorkloadIdentityCredential\",\n    \"get_bearer_token_provider\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/py3-azure-identity-1.19.0-r0.apk/py3-azure-identity-1.19.0-r0/usr/lib/python3.12/site-packages/azure/identity/__init__.py"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 12,
                  "endLine": 26,
                  "endColumn": 20,
                  "snippet": {
                    "text": "    ManagedIdentityCredential,\n    OnBehalfOfCredential,\n    SharedTokenCacheCredential,\n    UsernamePasswordCredential,\n    VisualStudioCodeCredential,\n    WorkloadIdentityCredential,\n    AzurePipelinesCredential,\n",
                    "rendered": {
                      "text": "    ManagedIdentityCredential,\n    OnBehalfOfCredential,\n    SharedTokenCacheCredential,\n    UsernamePasswordCredential,\n    VisualStudioCodeCredential,\n    WorkloadIdentityCredential,\n    AzurePipelinesCredential,\n",
                      "markdown": "`    ManagedIdentityCredential,\n    OnBehalfOfCredential,\n    SharedTokenCacheCredential,\n    UsernamePasswordCredential,\n    VisualStudioCodeCredential,\n    WorkloadIdentityCredential,\n    AzurePipelinesCredential,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        }
      ],
      "columnKind": "utf16CodeUnits"
    }
  ]
}