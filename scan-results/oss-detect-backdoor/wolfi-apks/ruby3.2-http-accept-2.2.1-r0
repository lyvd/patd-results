{
  "$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.6.json",
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "oss-detect-backdoor",
          "organization": "Microsoft Corporation",
          "product": "OSSGadget (https://github.com/Microsoft/OSSGadget)",
          "version": "0.0.0+ed0e2cfe6a"
        }
      },
      "results": [
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/ruby3.2-http-accept-2.2.1-r0.apk/ruby3.2-http-accept-2.2.1-r0/usr/lib/ruby/gems/3.2.0/gems/http-accept-2.2.1/readme.md"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 3,
                  "endLine": 100,
                  "snippet": {
                    "text": "\nNormally, you'd want to match the languages against some set of available localizations:\n\n``` ruby\navailable_localizations = HTTP::Accept::Languages::Locales.new([\"en-nz\", \"en-us\"])\n\n# Given the languages that the user wants, and the localizations available, compute the set of desired localizations.\ndesired_localizations = available_localizations & languages\n",
                    "rendered": {
                      "text": "\nNormally, you'd want to match the languages against some set of available localizations:\n\n``` ruby\navailable_localizations = HTTP::Accept::Languages::Locales.new([\"en-nz\", \"en-us\"])\n\n# Given the languages that the user wants, and the localizations available, compute the set of desired localizations.\ndesired_localizations = available_localizations & languages\n",
                      "markdown": "`\nNormally, you'd want to match the languages against some set of available localizations:\n\n``` ruby\navailable_localizations = HTTP::Accept::Languages::Locales.new([\"en-nz\", \"en-us\"])\n\n# Given the languages that the user wants, and the localizations available, compute the set of desired localizations.\ndesired_localizations = available_localizations & languages\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/ruby3.2-http-accept-2.2.1-r0.apk/ruby3.2-http-accept-2.2.1-r0/usr/lib/ruby/gems/3.2.0/gems/http-accept-2.2.1/readme.md"
                },
                "region": {
                  "startLine": 89,
                  "startColumn": 3,
                  "endLine": 90,
                  "snippet": {
                    "text": "\nYou can parse the incoming `Accept-Language:` header:\n\n``` ruby\nlanguages = HTTP::Accept::Languages.parse(\"da, en-gb;q=0.8, en;q=0.7\")\n\nexpect(languages[0].locale).to be == \"da\"\nexpect(languages[1].locale).to be == \"en-gb\"\n",
                    "rendered": {
                      "text": "\nYou can parse the incoming `Accept-Language:` header:\n\n``` ruby\nlanguages = HTTP::Accept::Languages.parse(\"da, en-gb;q=0.8, en;q=0.7\")\n\nexpect(languages[0].locale).to be == \"da\"\nexpect(languages[1].locale).to be == \"en-gb\"\n",
                      "markdown": "`\nYou can parse the incoming `Accept-Language:` header:\n\n``` ruby\nlanguages = HTTP::Accept::Languages.parse(\"da, en-gb;q=0.8, en;q=0.7\")\n\nexpect(languages[0].locale).to be == \"da\"\nexpect(languages[1].locale).to be == \"en-gb\"\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/ruby3.2-http-accept-2.2.1-r0.apk/ruby3.2-http-accept-2.2.1-r0/usr/lib/ruby/gems/3.2.0/gems/http-accept-2.2.1/readme.md"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 3,
                  "endLine": 57,
                  "snippet": {
                    "text": "\nNormally, you'd want to match the media types against some set of available mime types:\n\n``` ruby\nmodule ToJSON\n  def content_type\n    HTTP::Accept::ContentType.new(\"application\", \"json\", charset: 'utf-8')\n  end\n",
                    "rendered": {
                      "text": "\nNormally, you'd want to match the media types against some set of available mime types:\n\n``` ruby\nmodule ToJSON\n  def content_type\n    HTTP::Accept::ContentType.new(\"application\", \"json\", charset: 'utf-8')\n  end\n",
                      "markdown": "`\nNormally, you'd want to match the media types against some set of available mime types:\n\n``` ruby\nmodule ToJSON\n  def content_type\n    HTTP::Accept::ContentType.new(\"application\", \"json\", charset: 'utf-8')\n  end\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/ruby3.2-http-accept-2.2.1-r0.apk/ruby3.2-http-accept-2.2.1-r0/usr/lib/ruby/gems/3.2.0/gems/http-accept-2.2.1/readme.md"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 3,
                  "endLine": 46,
                  "snippet": {
                    "text": "\nYou can parse the incoming `Accept:` header:\n\n``` ruby\nmedia_types = HTTP::Accept::MediaTypes.parse(\"text/html;q=0.5, application/json; version=1\")\n\nexpect(media_types[0].mime_type).to be == \"application/json\"\nexpect(media_types[0].parameters).to be == {'version' => '1'}\n",
                    "rendered": {
                      "text": "\nYou can parse the incoming `Accept:` header:\n\n``` ruby\nmedia_types = HTTP::Accept::MediaTypes.parse(\"text/html;q=0.5, application/json; version=1\")\n\nexpect(media_types[0].mime_type).to be == \"application/json\"\nexpect(media_types[0].parameters).to be == {'version' => '1'}\n",
                      "markdown": "`\nYou can parse the incoming `Accept:` header:\n\n``` ruby\nmedia_types = HTTP::Accept::MediaTypes.parse(\"text/html;q=0.5, application/json; version=1\")\n\nexpect(media_types[0].mime_type).to be == \"application/json\"\nexpect(media_types[0].parameters).to be == {'version' => '1'}\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/ruby3.2-http-accept-2.2.1-r0.apk/ruby3.2-http-accept-2.2.1-r0/usr/lib/ruby/gems/3.2.0/gems/http-accept-2.2.1/readme.md"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 3,
                  "endLine": 34,
                  "snippet": {
                    "text": "\nYou can then require it in your code like so:\n\n``` ruby\nrequire 'http/accept'\n```\n\n## Usage\n",
                    "rendered": {
                      "text": "\nYou can then require it in your code like so:\n\n``` ruby\nrequire 'http/accept'\n```\n\n## Usage\n",
                      "markdown": "`\nYou can then require it in your code like so:\n\n``` ruby\nrequire 'http/accept'\n```\n\n## Usage\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/ruby3.2-http-accept-2.2.1-r0.apk/ruby3.2-http-accept-2.2.1-r0/usr/lib/ruby/gems/3.2.0/gems/http-accept-2.2.1/readme.md"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 3,
                  "endLine": 20,
                  "snippet": {
                    "text": "\nAdd this line to your application's Gemfile:\n\n``` ruby\ngem 'http-accept'\n```\n\nAnd then execute:\n",
                    "rendered": {
                      "text": "\nAdd this line to your application's Gemfile:\n\n``` ruby\ngem 'http-accept'\n```\n\nAnd then execute:\n",
                      "markdown": "`\nAdd this line to your application's Gemfile:\n\n``` ruby\ngem 'http-accept'\n```\n\nAnd then execute:\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/ruby3.2-http-accept-2.2.1-r0.apk/ruby3.2-http-accept-2.2.1-r0/usr/lib/ruby/gems/3.2.0/gems/http-accept-2.2.1/lib/http/accept/sort.rb"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 8,
                  "endLine": 9,
                  "snippet": {
                    "text": "\nmodule HTTP\n\tmodule Accept\n\t\tmodule Sort\n\t\t\t# This sorts items with higher priority first, and keeps items with the same priority in the same relative order.\n\t\t\tdef self.by_quality_factor(items)\n\t\t\t\t# We do this to get a stable sort:\n\t\t\t\titems.sort_by.with_index{|object, index| [-object.quality_factor, index]}\n",
                    "rendered": {
                      "text": "\nmodule HTTP\n\tmodule Accept\n\t\tmodule Sort\n\t\t\t# This sorts items with higher priority first, and keeps items with the same priority in the same relative order.\n\t\t\tdef self.by_quality_factor(items)\n\t\t\t\t# We do this to get a stable sort:\n\t\t\t\titems.sort_by.with_index{|object, index| [-object.quality_factor, index]}\n",
                      "markdown": "`\nmodule HTTP\n\tmodule Accept\n\t\tmodule Sort\n\t\t\t# This sorts items with higher priority first, and keeps items with the same priority in the same relative order.\n\t\t\tdef self.by_quality_factor(items)\n\t\t\t\t# We do this to get a stable sort:\n\t\t\t\titems.sort_by.with_index{|object, index| [-object.quality_factor, index]}\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/ruby3.2-http-accept-2.2.1-r0.apk/ruby3.2-http-accept-2.2.1-r0/usr/lib/ruby/gems/3.2.0/specifications/http-accept-2.2.1.gemspec"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 25,
                  "endLine": 2,
                  "endColumn": 31,
                  "snippet": {
                    "text": "# -*- encoding: utf-8 -*-\n# stub: http-accept 2.2.1 ruby lib\n\nGem::Specification.new do |s|\n  s.name = \"http-accept\".freeze\n",
                    "rendered": {
                      "text": "# -*- encoding: utf-8 -*-\n# stub: http-accept 2.2.1 ruby lib\n\nGem::Specification.new do |s|\n  s.name = \"http-accept\".freeze\n",
                      "markdown": "`# -*- encoding: utf-8 -*-\n# stub: http-accept 2.2.1 ruby lib\n\nGem::Specification.new do |s|\n  s.name = \"http-accept\".freeze\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/panic-at-the-distro-malicious-apks/datasets/wolfi_apks/ruby3.2-http-accept-2.2.1-r0.apk/ruby3.2-http-accept-2.2.1-r0/usr/lib/ruby/gems/3.2.0/gems/http-accept-2.2.1/lib/http/accept/encodings.rb"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 32,
                  "endLine": 61,
                  "endColumn": 51,
                  "snippet": {
                    "text": "\t\t\t# specified, the behaviour is the same as if `Accept-Encoding: identity` was provided\n\t\t\t# (according to RFC).\n\t\t\tdef self.browser_preferred_content_codings(env)\n\t\t\t\tif accept_content_codings = env[HTTP_ACCEPT_ENCODING]&.strip\n\t\t\t\t\tif accept_content_codings.empty?\n\t\t\t\t\t\t# \"An Accept-Encoding header field with a combined field-value that is\n\t\t\t\t\t\t# empty implies that the user agent does not want any content-coding in\n",
                    "rendered": {
                      "text": "\t\t\t# specified, the behaviour is the same as if `Accept-Encoding: identity` was provided\n\t\t\t# (according to RFC).\n\t\t\tdef self.browser_preferred_content_codings(env)\n\t\t\t\tif accept_content_codings = env[HTTP_ACCEPT_ENCODING]&.strip\n\t\t\t\t\tif accept_content_codings.empty?\n\t\t\t\t\t\t# \"An Accept-Encoding header field with a combined field-value that is\n\t\t\t\t\t\t# empty implies that the user agent does not want any content-coding in\n",
                      "markdown": "`\t\t\t# specified, the behaviour is the same as if `Accept-Encoding: identity` was provided\n\t\t\t# (according to RFC).\n\t\t\tdef self.browser_preferred_content_codings(env)\n\t\t\t\tif accept_content_codings = env[HTTP_ACCEPT_ENCODING]&.strip\n\t\t\t\t\tif accept_content_codings.empty?\n\t\t\t\t\t\t# \"An Accept-Encoding header field with a combined field-value that is\n\t\t\t\t\t\t# empty implies that the user agent does not want any content-coding in\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        }
      ],
      "columnKind": "utf16CodeUnits"
    }
  ]
}