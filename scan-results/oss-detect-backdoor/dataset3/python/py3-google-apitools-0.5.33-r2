{
  "$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.6.json",
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "oss-detect-backdoor",
          "organization": "Microsoft Corporation",
          "product": "OSSGadget (https://github.com/Microsoft/OSSGadget)",
          "version": "0.0.0+4a24249b20"
        }
      },
      "results": [
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/extended_descriptor.py"
                },
                "region": {
                  "startLine": 403,
                  "startColumn": 45,
                  "endLine": 403,
                  "endColumn": 49,
                  "snippet": {
                    "text": "                self.__printer(import_)\n            self.__printer()\n        # Note: If we ever were going to add imports from this package, we'd\n        # need to sort those out and put them at the end.\n        if google_imports:\n            for import_ in sorted(google_imports):\n                self.__printer(import_)\n",
                    "rendered": {
                      "text": "                self.__printer(import_)\n            self.__printer()\n        # Note: If we ever were going to add imports from this package, we'd\n        # need to sort those out and put them at the end.\n        if google_imports:\n            for import_ in sorted(google_imports):\n                self.__printer(import_)\n",
                      "markdown": "`                self.__printer(import_)\n            self.__printer()\n        # Note: If we ever were going to add imports from this package, we'd\n        # need to sort those out and put them at the end.\n        if google_imports:\n            for import_ in sorted(google_imports):\n                self.__printer(import_)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/extended_descriptor.py"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 34,
                  "endLine": 28,
                  "endColumn": 38,
                  "snippet": {
                    "text": "message, since we need to change the type of the subfields. We could\nhave a \"plain\" descriptor attached, but that seems like unnecessary\nbookkeeping. Where possible, we purposely reuse existing tag numbers;\nfor new fields, we start numbering at 100.\n\"\"\"\nimport abc\nimport operator\n",
                    "rendered": {
                      "text": "message, since we need to change the type of the subfields. We could\nhave a \"plain\" descriptor attached, but that seems like unnecessary\nbookkeeping. Where possible, we purposely reuse existing tag numbers;\nfor new fields, we start numbering at 100.\n\"\"\"\nimport abc\nimport operator\n",
                      "markdown": "`message, since we need to change the type of the subfields. We could\nhave a \"plain\" descriptor attached, but that seems like unnecessary\nbookkeeping. Where possible, we purposely reuse existing tag numbers;\nfor new fields, we start numbering at 100.\n\"\"\"\nimport abc\nimport operator\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/extended_descriptor.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/extended_descriptor.py"
                },
                "region": {
                  "startLine": 403,
                  "startColumn": 17,
                  "endLine": 403,
                  "endColumn": 23,
                  "snippet": {
                    "text": "                self.__printer(import_)\n            self.__printer()\n        # Note: If we ever were going to add imports from this package, we'd\n        # need to sort those out and put them at the end.\n        if google_imports:\n            for import_ in sorted(google_imports):\n                self.__printer(import_)\n",
                    "rendered": {
                      "text": "                self.__printer(import_)\n            self.__printer()\n        # Note: If we ever were going to add imports from this package, we'd\n        # need to sort those out and put them at the end.\n        if google_imports:\n            for import_ in sorted(google_imports):\n                self.__printer(import_)\n",
                      "markdown": "`                self.__printer(import_)\n            self.__printer()\n        # Note: If we ever were going to add imports from this package, we'd\n        # need to sort those out and put them at the end.\n        if google_imports:\n            for import_ in sorted(google_imports):\n                self.__printer(import_)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/extended_descriptor.py"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 41,
                  "endLine": 113,
                  "endColumn": 46,
                  "snippet": {
                    "text": "      description: Description of this message.\n      full_name: Full qualified name of this message.\n      decorators: Decorators to include in the definition when printing.\n          Printed in the given order from top to bottom (so the last entry\n          is the innermost decorator).\n      alias_for: This type is just an alias for the named type.\n      field_mappings: Mappings from python to json field names.\n",
                    "rendered": {
                      "text": "      description: Description of this message.\n      full_name: Full qualified name of this message.\n      decorators: Decorators to include in the definition when printing.\n          Printed in the given order from top to bottom (so the last entry\n          is the innermost decorator).\n      alias_for: This type is just an alias for the named type.\n      field_mappings: Mappings from python to json field names.\n",
                      "markdown": "`      description: Description of this message.\n      full_name: Full qualified name of this message.\n      decorators: Decorators to include in the definition when printing.\n          Printed in the given order from top to bottom (so the last entry\n          is the innermost decorator).\n      alias_for: This type is just an alias for the named type.\n      field_mappings: Mappings from python to json field names.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/extended_descriptor.py"
                },
                "region": {
                  "startLine": 506,
                  "startColumn": 42,
                  "endLine": 506,
                  "endColumn": 47,
                  "snippet": {
                    "text": "            'default_format': '',\n        }\n\n        message_field = _MESSAGE_FIELD_MAP.get(field.type_name)\n        if message_field:\n            printed_field_info['module'] = '_message_types'\n            field_type = message_field\n",
                    "rendered": {
                      "text": "            'default_format': '',\n        }\n\n        message_field = _MESSAGE_FIELD_MAP.get(field.type_name)\n        if message_field:\n            printed_field_info['module'] = '_message_types'\n            field_type = message_field\n",
                      "markdown": "`            'default_format': '',\n        }\n\n        message_field = _MESSAGE_FIELD_MAP.get(field.type_name)\n        if message_field:\n            printed_field_info['module'] = '_message_types'\n            field_type = message_field\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 1095,
                  "startColumn": 19,
                  "endLine": 1095,
                  "endColumn": 23,
                  "snippet": {
                    "text": "                self.__total_size = end\n        elif self.total_size is None:\n            # For the streaming resumable case, we need to detect when\n            # we're at the end of the stream.\n            body_stream = buffered_stream.BufferedStream(\n                self.stream, start, self.chunksize)\n            end = body_stream.stream_end_position\n",
                    "rendered": {
                      "text": "                self.__total_size = end\n        elif self.total_size is None:\n            # For the streaming resumable case, we need to detect when\n            # we're at the end of the stream.\n            body_stream = buffered_stream.BufferedStream(\n                self.stream, start, self.chunksize)\n            end = body_stream.stream_end_position\n",
                      "markdown": "`                self.__total_size = end\n        elif self.total_size is None:\n            # For the streaming resumable case, we need to detect when\n            # we're at the end of the stream.\n            body_stream = buffered_stream.BufferedStream(\n                self.stream, start, self.chunksize)\n            end = body_stream.stream_end_position\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 1090,
                  "startColumn": 38,
                  "endLine": 1090,
                  "endColumn": 42,
                  "snippet": {
                    "text": "                self.stream, self.chunksize)\n            end = start + read_length\n            # If the stream length was previously unknown and the input stream\n            # is exhausted, then we're at the end of the stream.\n            if self.total_size is None and exhausted:\n                self.__total_size = end\n        elif self.total_size is None:\n",
                    "rendered": {
                      "text": "                self.stream, self.chunksize)\n            end = start + read_length\n            # If the stream length was previously unknown and the input stream\n            # is exhausted, then we're at the end of the stream.\n            if self.total_size is None and exhausted:\n                self.__total_size = end\n        elif self.total_size is None:\n",
                      "markdown": "`                self.stream, self.chunksize)\n            end = start + read_length\n            # If the stream length was previously unknown and the input stream\n            # is exhausted, then we're at the end of the stream.\n            if self.total_size is None and exhausted:\n                self.__total_size = end\n        elif self.total_size is None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 994,
                  "startColumn": 73,
                  "endLine": 994,
                  "endColumn": 77,
                  "snippet": {
                    "text": "            if self.progress + 1 != self.stream.tell():\n                # TODO(craigcitro): Add a better way to recover here.\n                raise exceptions.CommunicationError(\n                    'Failed to transfer all bytes in chunk, upload paused at '\n                    'byte %d' % self.progress)\n            self._ExecuteCallback(callback, response)\n        if self.__complete and hasattr(self.stream, 'seek'):\n",
                    "rendered": {
                      "text": "            if self.progress + 1 != self.stream.tell():\n                # TODO(craigcitro): Add a better way to recover here.\n                raise exceptions.CommunicationError(\n                    'Failed to transfer all bytes in chunk, upload paused at '\n                    'byte %d' % self.progress)\n            self._ExecuteCallback(callback, response)\n        if self.__complete and hasattr(self.stream, 'seek'):\n",
                      "markdown": "`            if self.progress + 1 != self.stream.tell():\n                # TODO(craigcitro): Add a better way to recover here.\n                raise exceptions.CommunicationError(\n                    'Failed to transfer all bytes in chunk, upload paused at '\n                    'byte %d' % self.progress)\n            self._ExecuteCallback(callback, response)\n        if self.__complete and hasattr(self.stream, 'seek'):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 621,
                  "startColumn": 53,
                  "endLine": 621,
                  "endColumn": 59,
                  "snippet": {
                    "text": "        \"\"\"Create a new Upload object from a filename.\"\"\"\n        path = os.path.expanduser(filename)\n        if not os.path.exists(path):\n            raise exceptions.NotFoundError('Could not find file %s' % path)\n        if not mime_type:\n            mime_type, _ = mimetypes.guess_type(path)\n            if mime_type is None:\n",
                    "rendered": {
                      "text": "        \"\"\"Create a new Upload object from a filename.\"\"\"\n        path = os.path.expanduser(filename)\n        if not os.path.exists(path):\n            raise exceptions.NotFoundError('Could not find file %s' % path)\n        if not mime_type:\n            mime_type, _ = mimetypes.guess_type(path)\n            if mime_type is None:\n",
                      "markdown": "`        \"\"\"Create a new Upload object from a filename.\"\"\"\n        path = os.path.expanduser(filename)\n        if not os.path.exists(path):\n            raise exceptions.NotFoundError('Could not find file %s' % path)\n        if not mime_type:\n            mime_type, _ = mimetypes.guess_type(path)\n            if mime_type is None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 1083,
                  "startColumn": 30,
                  "endLine": 1083,
                  "endColumn": 39,
                  "snippet": {
                    "text": "        \"\"\"Send the specified chunk.\"\"\"\n        self.EnsureInitialized()\n        no_log_body = self.total_size is None\n        request = http_wrapper.Request(url=self.url, http_method='PUT')\n        if self.__gzip_encoded:\n            request.headers['Content-Encoding'] = 'gzip'\n            body_stream, read_length, exhausted = compression.CompressStream(\n",
                    "rendered": {
                      "text": "        \"\"\"Send the specified chunk.\"\"\"\n        self.EnsureInitialized()\n        no_log_body = self.total_size is None\n        request = http_wrapper.Request(url=self.url, http_method='PUT')\n        if self.__gzip_encoded:\n            request.headers['Content-Encoding'] = 'gzip'\n            body_stream, read_length, exhausted = compression.CompressStream(\n",
                      "markdown": "`        \"\"\"Send the specified chunk.\"\"\"\n        self.EnsureInitialized()\n        no_log_body = self.total_size is None\n        request = http_wrapper.Request(url=self.url, http_method='PUT')\n        if self.__gzip_encoded:\n            request.headers['Content-Encoding'] = 'gzip'\n            body_stream, read_length, exhausted = compression.CompressStream(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 1063,
                  "startColumn": 30,
                  "endLine": 1063,
                  "endColumn": 39,
                  "snippet": {
                    "text": "        body_stream = stream_slice.StreamSlice(\n            self.stream, self.total_size - start)\n\n        request = http_wrapper.Request(url=self.url, http_method='PUT',\n                                       body=body_stream)\n        request.headers['Content-Type'] = self.mime_type\n        if start == self.total_size:\n",
                    "rendered": {
                      "text": "        body_stream = stream_slice.StreamSlice(\n            self.stream, self.total_size - start)\n\n        request = http_wrapper.Request(url=self.url, http_method='PUT',\n                                       body=body_stream)\n        request.headers['Content-Type'] = self.mime_type\n        if start == self.total_size:\n",
                      "markdown": "`        body_stream = stream_slice.StreamSlice(\n            self.stream, self.total_size - start)\n\n        request = http_wrapper.Request(url=self.url, http_method='PUT',\n                                       body=body_stream)\n        request.headers['Content-Type'] = self.mime_type\n        if start == self.total_size:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 911,
                  "startColumn": 60,
                  "endLine": 911,
                  "endColumn": 65,
                  "snippet": {
                    "text": "        if http_response.status_code != http_client.OK:\n            raise exceptions.HttpError.FromResponse(http_response)\n\n        self.__server_chunk_granularity = http_response.info.get(\n            'X-Goog-Upload-Chunk-Granularity')\n        url = http_response.info['location']\n        if client is not None:\n",
                    "rendered": {
                      "text": "        if http_response.status_code != http_client.OK:\n            raise exceptions.HttpError.FromResponse(http_response)\n\n        self.__server_chunk_granularity = http_response.info.get(\n            'X-Goog-Upload-Chunk-Granularity')\n        url = http_response.info['location']\n        if client is not None:\n",
                      "markdown": "`        if http_response.status_code != http_client.OK:\n            raise exceptions.HttpError.FromResponse(http_response)\n\n        self.__server_chunk_granularity = http_response.info.get(\n            'X-Goog-Upload-Chunk-Granularity')\n        url = http_response.info['location']\n        if client is not None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 891,
                  "startColumn": 55,
                  "endLine": 891,
                  "endColumn": 60,
                  "snippet": {
                    "text": "            raise exceptions.HttpError.FromResponse(refresh_response)\n\n    def _GetRangeHeaderFromResponse(self, response):\n        return response.info.get('Range', response.info.get('range'))\n\n    def InitializeUpload(self, http_request, http=None, client=None):\n        \"\"\"Initialize this upload from the given http_request.\"\"\"\n",
                    "rendered": {
                      "text": "            raise exceptions.HttpError.FromResponse(refresh_response)\n\n    def _GetRangeHeaderFromResponse(self, response):\n        return response.info.get('Range', response.info.get('range'))\n\n    def InitializeUpload(self, http_request, http=None, client=None):\n        \"\"\"Initialize this upload from the given http_request.\"\"\"\n",
                      "markdown": "`            raise exceptions.HttpError.FromResponse(refresh_response)\n\n    def _GetRangeHeaderFromResponse(self, response):\n        return response.info.get('Range', response.info.get('range'))\n\n    def InitializeUpload(self, http_request, http=None, client=None):\n        \"\"\"Initialize this upload from the given http_request.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 891,
                  "startColumn": 28,
                  "endLine": 891,
                  "endColumn": 33,
                  "snippet": {
                    "text": "            raise exceptions.HttpError.FromResponse(refresh_response)\n\n    def _GetRangeHeaderFromResponse(self, response):\n        return response.info.get('Range', response.info.get('range'))\n\n    def InitializeUpload(self, http_request, http=None, client=None):\n        \"\"\"Initialize this upload from the given http_request.\"\"\"\n",
                    "rendered": {
                      "text": "            raise exceptions.HttpError.FromResponse(refresh_response)\n\n    def _GetRangeHeaderFromResponse(self, response):\n        return response.info.get('Range', response.info.get('range'))\n\n    def InitializeUpload(self, http_request, http=None, client=None):\n        \"\"\"Initialize this upload from the given http_request.\"\"\"\n",
                      "markdown": "`            raise exceptions.HttpError.FromResponse(refresh_response)\n\n    def _GetRangeHeaderFromResponse(self, response):\n        return response.info.get('Range', response.info.get('range'))\n\n    def InitializeUpload(self, http_request, http=None, client=None):\n        \"\"\"Initialize this upload from the given http_request.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 865,
                  "startColumn": 38,
                  "endLine": 865,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        if self.strategy != RESUMABLE_UPLOAD:\n            return\n        self.EnsureInitialized()\n        refresh_request = http_wrapper.Request(\n            url=self.url, http_method='PUT',\n            headers={'Content-Range': 'bytes */*'})\n        refresh_response = http_wrapper.MakeRequest(\n",
                    "rendered": {
                      "text": "        if self.strategy != RESUMABLE_UPLOAD:\n            return\n        self.EnsureInitialized()\n        refresh_request = http_wrapper.Request(\n            url=self.url, http_method='PUT',\n            headers={'Content-Range': 'bytes */*'})\n        refresh_response = http_wrapper.MakeRequest(\n",
                      "markdown": "`        if self.strategy != RESUMABLE_UPLOAD:\n            return\n        self.EnsureInitialized()\n        refresh_request = http_wrapper.Request(\n            url=self.url, http_method='PUT',\n            headers={'Content-Range': 'bytes */*'})\n        refresh_response = http_wrapper.MakeRequest(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 657,
                  "startColumn": 47,
                  "endLine": 657,
                  "endColumn": 52,
                  "snippet": {
                    "text": "            raise exceptions.InvalidUserInputError(\n                'Cannot override total_size on serialized Upload')\n        upload = cls.FromStream(stream, info['mime_type'],\n                                total_size=info.get('total_size'),\n                                gzip_encoded=gzip_encoded, **kwds)\n        if isinstance(stream, io.IOBase) and not stream.seekable():\n            raise exceptions.InvalidUserInputError(\n",
                    "rendered": {
                      "text": "            raise exceptions.InvalidUserInputError(\n                'Cannot override total_size on serialized Upload')\n        upload = cls.FromStream(stream, info['mime_type'],\n                                total_size=info.get('total_size'),\n                                gzip_encoded=gzip_encoded, **kwds)\n        if isinstance(stream, io.IOBase) and not stream.seekable():\n            raise exceptions.InvalidUserInputError(\n",
                      "markdown": "`            raise exceptions.InvalidUserInputError(\n                'Cannot override total_size on serialized Upload')\n        upload = cls.FromStream(stream, info['mime_type'],\n                                total_size=info.get('total_size'),\n                                gzip_encoded=gzip_encoded, **kwds)\n        if isinstance(stream, io.IOBase) and not stream.seekable():\n            raise exceptions.InvalidUserInputError(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 414,
                  "startColumn": 30,
                  "endLine": 414,
                  "endColumn": 39,
                  "snippet": {
                    "text": "    def __GetChunk(self, start, end, additional_headers=None):\n        \"\"\"Retrieve a chunk, and return the full response.\"\"\"\n        self.EnsureInitialized()\n        request = http_wrapper.Request(url=self.url)\n        self.__SetRangeHeader(request, start, end=end)\n        if additional_headers is not None:\n            request.headers.update(additional_headers)\n",
                    "rendered": {
                      "text": "    def __GetChunk(self, start, end, additional_headers=None):\n        \"\"\"Retrieve a chunk, and return the full response.\"\"\"\n        self.EnsureInitialized()\n        request = http_wrapper.Request(url=self.url)\n        self.__SetRangeHeader(request, start, end=end)\n        if additional_headers is not None:\n            request.headers.update(additional_headers)\n",
                      "markdown": "`    def __GetChunk(self, start, end, additional_headers=None):\n        \"\"\"Retrieve a chunk, and return the full response.\"\"\"\n        self.EnsureInitialized()\n        request = http_wrapper.Request(url=self.url)\n        self.__SetRangeHeader(request, start, end=end)\n        if additional_headers is not None:\n            request.headers.update(additional_headers)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 330,
                  "startColumn": 31,
                  "endLine": 330,
                  "endColumn": 36,
                  "snippet": {
                    "text": "                raise exceptions.HttpError.FromResponse(response)\n            self.__initial_response = response\n            self.__SetTotal(response.info)\n            url = response.info.get('content-location', response.request_url)\n        if client is not None:\n            url = client.FinalizeTransferUrl(url)\n        self._Initialize(http, url)\n",
                    "rendered": {
                      "text": "                raise exceptions.HttpError.FromResponse(response)\n            self.__initial_response = response\n            self.__SetTotal(response.info)\n            url = response.info.get('content-location', response.request_url)\n        if client is not None:\n            url = client.FinalizeTransferUrl(url)\n        self._Initialize(http, url)\n",
                      "markdown": "`                raise exceptions.HttpError.FromResponse(response)\n            self.__initial_response = response\n            self.__SetTotal(response.info)\n            url = response.info.get('content-location', response.request_url)\n        if client is not None:\n            url = client.FinalizeTransferUrl(url)\n        self._Initialize(http, url)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/extra_types.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 441,
                  "startColumn": 42,
                  "endLine": 441,
                  "endColumn": 47,
                  "snippet": {
                    "text": "                parent_name = self.__names.ClassName(\n                    items.get('title') or name_hint)\n                entry_type_name = self.__AddEntryType(\n                    entry_name_hint, items.get('items'), parent_name)\n                return TypeInfo(type_name=entry_type_name,\n                                variant=messages.Variant.MESSAGE)\n            return self.__GetTypeInfo(items, entry_name_hint)\n",
                    "rendered": {
                      "text": "                parent_name = self.__names.ClassName(\n                    items.get('title') or name_hint)\n                entry_type_name = self.__AddEntryType(\n                    entry_name_hint, items.get('items'), parent_name)\n                return TypeInfo(type_name=entry_type_name,\n                                variant=messages.Variant.MESSAGE)\n            return self.__GetTypeInfo(items, entry_name_hint)\n",
                      "markdown": "`                parent_name = self.__names.ClassName(\n                    items.get('title') or name_hint)\n                entry_type_name = self.__AddEntryType(\n                    entry_name_hint, items.get('items'), parent_name)\n                return TypeInfo(type_name=entry_type_name,\n                                variant=messages.Variant.MESSAGE)\n            return self.__GetTypeInfo(items, entry_name_hint)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 439,
                  "startColumn": 25,
                  "endLine": 439,
                  "endColumn": 30,
                  "snippet": {
                    "text": "            entry_label = self.__ComputeLabel(items)\n            if entry_label == descriptor.FieldDescriptor.Label.REPEATED:\n                parent_name = self.__names.ClassName(\n                    items.get('title') or name_hint)\n                entry_type_name = self.__AddEntryType(\n                    entry_name_hint, items.get('items'), parent_name)\n                return TypeInfo(type_name=entry_type_name,\n",
                    "rendered": {
                      "text": "            entry_label = self.__ComputeLabel(items)\n            if entry_label == descriptor.FieldDescriptor.Label.REPEATED:\n                parent_name = self.__names.ClassName(\n                    items.get('title') or name_hint)\n                entry_type_name = self.__AddEntryType(\n                    entry_name_hint, items.get('items'), parent_name)\n                return TypeInfo(type_name=entry_type_name,\n",
                      "markdown": "`            entry_label = self.__ComputeLabel(items)\n            if entry_label == descriptor.FieldDescriptor.Label.REPEATED:\n                parent_name = self.__names.ClassName(\n                    items.get('title') or name_hint)\n                entry_type_name = self.__AddEntryType(\n                    entry_name_hint, items.get('items'), parent_name)\n                return TypeInfo(type_name=entry_type_name,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 435,
                  "startColumn": 21,
                  "endLine": 435,
                  "endColumn": 26,
                  "snippet": {
                    "text": "            if not items:\n                raise ValueError('Array type with no item type: %s' % attrs)\n            entry_name_hint = self.__names.ClassName(\n                items.get('title') or '%sListEntry' % name_hint)\n            entry_label = self.__ComputeLabel(items)\n            if entry_label == descriptor.FieldDescriptor.Label.REPEATED:\n                parent_name = self.__names.ClassName(\n",
                    "rendered": {
                      "text": "            if not items:\n                raise ValueError('Array type with no item type: %s' % attrs)\n            entry_name_hint = self.__names.ClassName(\n                items.get('title') or '%sListEntry' % name_hint)\n            entry_label = self.__ComputeLabel(items)\n            if entry_label == descriptor.FieldDescriptor.Label.REPEATED:\n                parent_name = self.__names.ClassName(\n",
                      "markdown": "`            if not items:\n                raise ValueError('Array type with no item type: %s' % attrs)\n            entry_name_hint = self.__names.ClassName(\n                items.get('title') or '%sListEntry' % name_hint)\n            entry_label = self.__ComputeLabel(items)\n            if entry_label == descriptor.FieldDescriptor.Label.REPEATED:\n                parent_name = self.__names.ClassName(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 431,
                  "startColumn": 25,
                  "endLine": 431,
                  "endColumn": 30,
                  "snippet": {
                    "text": "            return type_info\n\n        if type_name == 'array':\n            items = attrs.get('items')\n            if not items:\n                raise ValueError('Array type with no item type: %s' % attrs)\n            entry_name_hint = self.__names.ClassName(\n",
                    "rendered": {
                      "text": "            return type_info\n\n        if type_name == 'array':\n            items = attrs.get('items')\n            if not items:\n                raise ValueError('Array type with no item type: %s' % attrs)\n            entry_name_hint = self.__names.ClassName(\n",
                      "markdown": "`            return type_info\n\n        if type_name == 'array':\n            items = attrs.get('items')\n            if not items:\n                raise ValueError('Array type with no item type: %s' % attrs)\n            entry_name_hint = self.__names.ClassName(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 404,
                  "startColumn": 49,
                  "endLine": 404,
                  "endColumn": 54,
                  "snippet": {
                    "text": "            return self.__DeclareEnum(enum_name, attrs)\n\n        if 'format' in attrs:\n            type_info = self.PRIMITIVE_FORMAT_MAP.get(attrs['format'])\n            if type_info is None:\n                # If we don't recognize the format, the spec says we fall back\n                # to just using the type name.\n",
                    "rendered": {
                      "text": "            return self.__DeclareEnum(enum_name, attrs)\n\n        if 'format' in attrs:\n            type_info = self.PRIMITIVE_FORMAT_MAP.get(attrs['format'])\n            if type_info is None:\n                # If we don't recognize the format, the spec says we fall back\n                # to just using the type name.\n",
                      "markdown": "`            return self.__DeclareEnum(enum_name, attrs)\n\n        if 'format' in attrs:\n            type_info = self.PRIMITIVE_FORMAT_MAP.get(attrs['format'])\n            if type_info is None:\n                # If we don't recognize the format, the spec says we fall back\n                # to just using the type name.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 387,
                  "startColumn": 25,
                  "endLine": 387,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        \"\"\"Return a TypeInfo object for attrs, creating one if needed.\"\"\"\n\n        type_ref = self.__names.ClassName(attrs.get('$ref'))\n        type_name = attrs.get('type')\n        if not (type_ref or type_name):\n            raise ValueError('No type found for %s' % attrs)\n\n",
                    "rendered": {
                      "text": "        \"\"\"Return a TypeInfo object for attrs, creating one if needed.\"\"\"\n\n        type_ref = self.__names.ClassName(attrs.get('$ref'))\n        type_name = attrs.get('type')\n        if not (type_ref or type_name):\n            raise ValueError('No type found for %s' % attrs)\n\n",
                      "markdown": "`        \"\"\"Return a TypeInfo object for attrs, creating one if needed.\"\"\"\n\n        type_ref = self.__names.ClassName(attrs.get('$ref'))\n        type_name = attrs.get('type')\n        if not (type_ref or type_name):\n            raise ValueError('No type found for %s' % attrs)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 386,
                  "startColumn": 47,
                  "endLine": 386,
                  "endColumn": 52,
                  "snippet": {
                    "text": "    def __GetTypeInfo(self, attrs, name_hint):\n        \"\"\"Return a TypeInfo object for attrs, creating one if needed.\"\"\"\n\n        type_ref = self.__names.ClassName(attrs.get('$ref'))\n        type_name = attrs.get('type')\n        if not (type_ref or type_name):\n            raise ValueError('No type found for %s' % attrs)\n",
                    "rendered": {
                      "text": "    def __GetTypeInfo(self, attrs, name_hint):\n        \"\"\"Return a TypeInfo object for attrs, creating one if needed.\"\"\"\n\n        type_ref = self.__names.ClassName(attrs.get('$ref'))\n        type_name = attrs.get('type')\n        if not (type_ref or type_name):\n            raise ValueError('No type found for %s' % attrs)\n",
                      "markdown": "`    def __GetTypeInfo(self, attrs, name_hint):\n        \"\"\"Return a TypeInfo object for attrs, creating one if needed.\"\"\"\n\n        type_ref = self.__names.ClassName(attrs.get('$ref'))\n        type_name = attrs.get('type')\n        if not (type_ref or type_name):\n            raise ValueError('No type found for %s' % attrs)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 369,
                  "startColumn": 33,
                  "endLine": 369,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    def __DeclareEnum(self, enum_name, attrs):\n        description = util.CleanDescription(attrs.get('description', ''))\n        enum_values = attrs['enum']\n        enum_descriptions = attrs.get(\n            'enumDescriptions', [''] * len(enum_values))\n        self.AddEnumDescriptor(enum_name, description,\n                               enum_values, enum_descriptions)\n",
                    "rendered": {
                      "text": "    def __DeclareEnum(self, enum_name, attrs):\n        description = util.CleanDescription(attrs.get('description', ''))\n        enum_values = attrs['enum']\n        enum_descriptions = attrs.get(\n            'enumDescriptions', [''] * len(enum_values))\n        self.AddEnumDescriptor(enum_name, description,\n                               enum_values, enum_descriptions)\n",
                      "markdown": "`    def __DeclareEnum(self, enum_name, attrs):\n        description = util.CleanDescription(attrs.get('description', ''))\n        enum_values = attrs['enum']\n        enum_descriptions = attrs.get(\n            'enumDescriptions', [''] * len(enum_values))\n        self.AddEnumDescriptor(enum_name, description,\n                               enum_values, enum_descriptions)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 367,
                  "startColumn": 49,
                  "endLine": 367,
                  "endColumn": 54,
                  "snippet": {
                    "text": "        return descriptor.FieldDescriptor.Label.OPTIONAL\n\n    def __DeclareEnum(self, enum_name, attrs):\n        description = util.CleanDescription(attrs.get('description', ''))\n        enum_values = attrs['enum']\n        enum_descriptions = attrs.get(\n            'enumDescriptions', [''] * len(enum_values))\n",
                    "rendered": {
                      "text": "        return descriptor.FieldDescriptor.Label.OPTIONAL\n\n    def __DeclareEnum(self, enum_name, attrs):\n        description = util.CleanDescription(attrs.get('description', ''))\n        enum_values = attrs['enum']\n        enum_descriptions = attrs.get(\n            'enumDescriptions', [''] * len(enum_values))\n",
                      "markdown": "`        return descriptor.FieldDescriptor.Label.OPTIONAL\n\n    def __DeclareEnum(self, enum_name, attrs):\n        description = util.CleanDescription(attrs.get('description', ''))\n        enum_values = attrs['enum']\n        enum_descriptions = attrs.get(\n            'enumDescriptions', [''] * len(enum_values))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 362,
                  "startColumn": 18,
                  "endLine": 362,
                  "endColumn": 23,
                  "snippet": {
                    "text": "            return descriptor.FieldDescriptor.Label.REQUIRED\n        elif attrs.get('type') == 'array':\n            return descriptor.FieldDescriptor.Label.REPEATED\n        elif attrs.get('repeated'):\n            return descriptor.FieldDescriptor.Label.REPEATED\n        return descriptor.FieldDescriptor.Label.OPTIONAL\n\n",
                    "rendered": {
                      "text": "            return descriptor.FieldDescriptor.Label.REQUIRED\n        elif attrs.get('type') == 'array':\n            return descriptor.FieldDescriptor.Label.REPEATED\n        elif attrs.get('repeated'):\n            return descriptor.FieldDescriptor.Label.REPEATED\n        return descriptor.FieldDescriptor.Label.OPTIONAL\n\n",
                      "markdown": "`            return descriptor.FieldDescriptor.Label.REQUIRED\n        elif attrs.get('type') == 'array':\n            return descriptor.FieldDescriptor.Label.REPEATED\n        elif attrs.get('repeated'):\n            return descriptor.FieldDescriptor.Label.REPEATED\n        return descriptor.FieldDescriptor.Label.OPTIONAL\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 360,
                  "startColumn": 18,
                  "endLine": 360,
                  "endColumn": 23,
                  "snippet": {
                    "text": "    def __ComputeLabel(attrs):\n        if attrs.get('required', False):\n            return descriptor.FieldDescriptor.Label.REQUIRED\n        elif attrs.get('type') == 'array':\n            return descriptor.FieldDescriptor.Label.REPEATED\n        elif attrs.get('repeated'):\n            return descriptor.FieldDescriptor.Label.REPEATED\n",
                    "rendered": {
                      "text": "    def __ComputeLabel(attrs):\n        if attrs.get('required', False):\n            return descriptor.FieldDescriptor.Label.REQUIRED\n        elif attrs.get('type') == 'array':\n            return descriptor.FieldDescriptor.Label.REPEATED\n        elif attrs.get('repeated'):\n            return descriptor.FieldDescriptor.Label.REPEATED\n",
                      "markdown": "`    def __ComputeLabel(attrs):\n        if attrs.get('required', False):\n            return descriptor.FieldDescriptor.Label.REQUIRED\n        elif attrs.get('type') == 'array':\n            return descriptor.FieldDescriptor.Label.REPEATED\n        elif attrs.get('repeated'):\n            return descriptor.FieldDescriptor.Label.REPEATED\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 358,
                  "startColumn": 16,
                  "endLine": 358,
                  "endColumn": 21,
                  "snippet": {
                    "text": "\n    @staticmethod\n    def __ComputeLabel(attrs):\n        if attrs.get('required', False):\n            return descriptor.FieldDescriptor.Label.REQUIRED\n        elif attrs.get('type') == 'array':\n            return descriptor.FieldDescriptor.Label.REPEATED\n",
                    "rendered": {
                      "text": "\n    @staticmethod\n    def __ComputeLabel(attrs):\n        if attrs.get('required', False):\n            return descriptor.FieldDescriptor.Label.REQUIRED\n        elif attrs.get('type') == 'array':\n            return descriptor.FieldDescriptor.Label.REPEATED\n",
                      "markdown": "`\n    @staticmethod\n    def __ComputeLabel(attrs):\n        if attrs.get('required', False):\n            return descriptor.FieldDescriptor.Label.REQUIRED\n        elif attrs.get('type') == 'array':\n            return descriptor.FieldDescriptor.Label.REPEATED\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 352,
                  "startColumn": 17,
                  "endLine": 352,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        extended_field = extended_descriptor.ExtendedFieldDescriptor()\n        extended_field.name = field.name\n        extended_field.description = util.CleanDescription(\n            attrs.get('description', 'A %s attribute.' % field.type_name))\n        extended_field.field_descriptor = field\n        return extended_field\n\n",
                    "rendered": {
                      "text": "        extended_field = extended_descriptor.ExtendedFieldDescriptor()\n        extended_field.name = field.name\n        extended_field.description = util.CleanDescription(\n            attrs.get('description', 'A %s attribute.' % field.type_name))\n        extended_field.field_descriptor = field\n        return extended_field\n\n",
                      "markdown": "`        extended_field = extended_descriptor.ExtendedFieldDescriptor()\n        extended_field.name = field.name\n        extended_field.description = util.CleanDescription(\n            attrs.get('description', 'A %s attribute.' % field.type_name))\n        extended_field.field_descriptor = field\n        return extended_field\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 273,
                  "startColumn": 31,
                  "endLine": 273,
                  "endColumn": 36,
                  "snippet": {
                    "text": "            'description', 'A %s object.' % message.name))\n        self.__DeclareDescriptor(message.name)\n        with self.__DescriptorEnv(message):\n            properties = schema.get('properties', {})\n            for index, (name, attrs) in enumerate(sorted(properties.items())):\n                field = self.__FieldDescriptorFromProperties(\n                    name, index + 1, attrs)\n",
                    "rendered": {
                      "text": "            'description', 'A %s object.' % message.name))\n        self.__DeclareDescriptor(message.name)\n        with self.__DescriptorEnv(message):\n            properties = schema.get('properties', {})\n            for index, (name, attrs) in enumerate(sorted(properties.items())):\n                field = self.__FieldDescriptorFromProperties(\n                    name, index + 1, attrs)\n",
                      "markdown": "`            'description', 'A %s object.' % message.name))\n        self.__DeclareDescriptor(message.name)\n        with self.__DescriptorEnv(message):\n            properties = schema.get('properties', {})\n            for index, (name, attrs) in enumerate(sorted(properties.items())):\n                field = self.__FieldDescriptorFromProperties(\n                    name, index + 1, attrs)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 269,
                  "startColumn": 58,
                  "endLine": 269,
                  "endColumn": 63,
                  "snippet": {
                    "text": "                             schema.get('type'))\n        message = extended_descriptor.ExtendedMessageDescriptor()\n        message.name = self.__names.ClassName(schema['id'])\n        message.description = util.CleanDescription(schema.get(\n            'description', 'A %s object.' % message.name))\n        self.__DeclareDescriptor(message.name)\n        with self.__DescriptorEnv(message):\n",
                    "rendered": {
                      "text": "                             schema.get('type'))\n        message = extended_descriptor.ExtendedMessageDescriptor()\n        message.name = self.__names.ClassName(schema['id'])\n        message.description = util.CleanDescription(schema.get(\n            'description', 'A %s object.' % message.name))\n        self.__DeclareDescriptor(message.name)\n        with self.__DescriptorEnv(message):\n",
                      "markdown": "`                             schema.get('type'))\n        message = extended_descriptor.ExtendedMessageDescriptor()\n        message.name = self.__names.ClassName(schema['id'])\n        message.description = util.CleanDescription(schema.get(\n            'description', 'A %s object.' % message.name))\n        self.__DeclareDescriptor(message.name)\n        with self.__DescriptorEnv(message):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 266,
                  "startColumn": 35,
                  "endLine": 266,
                  "endColumn": 40,
                  "snippet": {
                    "text": "            return\n        if schema.get('type') != 'object':\n            raise ValueError('Cannot create message descriptors for type %s' %\n                             schema.get('type'))\n        message = extended_descriptor.ExtendedMessageDescriptor()\n        message.name = self.__names.ClassName(schema['id'])\n        message.description = util.CleanDescription(schema.get(\n",
                    "rendered": {
                      "text": "            return\n        if schema.get('type') != 'object':\n            raise ValueError('Cannot create message descriptors for type %s' %\n                             schema.get('type'))\n        message = extended_descriptor.ExtendedMessageDescriptor()\n        message.name = self.__names.ClassName(schema['id'])\n        message.description = util.CleanDescription(schema.get(\n",
                      "markdown": "`            return\n        if schema.get('type') != 'object':\n            raise ValueError('Cannot create message descriptors for type %s' %\n                             schema.get('type'))\n        message = extended_descriptor.ExtendedMessageDescriptor()\n        message.name = self.__names.ClassName(schema['id'])\n        message.description = util.CleanDescription(schema.get(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 264,
                  "startColumn": 17,
                  "endLine": 264,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        if schema.get('type') == 'any':\n            self.__DeclareMessageAlias(schema, 'extra_types.JsonValue')\n            return\n        if schema.get('type') != 'object':\n            raise ValueError('Cannot create message descriptors for type %s' %\n                             schema.get('type'))\n        message = extended_descriptor.ExtendedMessageDescriptor()\n",
                    "rendered": {
                      "text": "        if schema.get('type') == 'any':\n            self.__DeclareMessageAlias(schema, 'extra_types.JsonValue')\n            return\n        if schema.get('type') != 'object':\n            raise ValueError('Cannot create message descriptors for type %s' %\n                             schema.get('type'))\n        message = extended_descriptor.ExtendedMessageDescriptor()\n",
                      "markdown": "`        if schema.get('type') == 'any':\n            self.__DeclareMessageAlias(schema, 'extra_types.JsonValue')\n            return\n        if schema.get('type') != 'object':\n            raise ValueError('Cannot create message descriptors for type %s' %\n                             schema.get('type'))\n        message = extended_descriptor.ExtendedMessageDescriptor()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 261,
                  "startColumn": 17,
                  "endLine": 261,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        if schema.get('enum'):\n            self.__DeclareEnum(schema_name, schema)\n            return\n        if schema.get('type') == 'any':\n            self.__DeclareMessageAlias(schema, 'extra_types.JsonValue')\n            return\n        if schema.get('type') != 'object':\n",
                    "rendered": {
                      "text": "        if schema.get('enum'):\n            self.__DeclareEnum(schema_name, schema)\n            return\n        if schema.get('type') == 'any':\n            self.__DeclareMessageAlias(schema, 'extra_types.JsonValue')\n            return\n        if schema.get('type') != 'object':\n",
                      "markdown": "`        if schema.get('enum'):\n            self.__DeclareEnum(schema_name, schema)\n            return\n        if schema.get('type') == 'any':\n            self.__DeclareMessageAlias(schema, 'extra_types.JsonValue')\n            return\n        if schema.get('type') != 'object':\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 258,
                  "startColumn": 17,
                  "endLine": 258,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        # TODO(craigcitro): Is schema_name redundant?\n        if self.__GetDescriptor(schema_name):\n            return\n        if schema.get('enum'):\n            self.__DeclareEnum(schema_name, schema)\n            return\n        if schema.get('type') == 'any':\n",
                    "rendered": {
                      "text": "        # TODO(craigcitro): Is schema_name redundant?\n        if self.__GetDescriptor(schema_name):\n            return\n        if schema.get('enum'):\n            self.__DeclareEnum(schema_name, schema)\n            return\n        if schema.get('type') == 'any':\n",
                      "markdown": "`        # TODO(craigcitro): Is schema_name redundant?\n        if self.__GetDescriptor(schema_name):\n            return\n        if schema.get('enum'):\n            self.__DeclareEnum(schema_name, schema)\n            return\n        if schema.get('type') == 'any':\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 236,
                  "startColumn": 38,
                  "endLine": 236,
                  "endColumn": 43,
                  "snippet": {
                    "text": "        entries_type_name = self.__AddAdditionalPropertyType(\n            message.name, additional_properties_info)\n        description = util.CleanDescription(\n            additional_properties_info.get('description'))\n        if description is None:\n            description = 'Additional properties of type %s' % message.name\n        attrs = {\n",
                    "rendered": {
                      "text": "        entries_type_name = self.__AddAdditionalPropertyType(\n            message.name, additional_properties_info)\n        description = util.CleanDescription(\n            additional_properties_info.get('description'))\n        if description is None:\n            description = 'Additional properties of type %s' % message.name\n        attrs = {\n",
                      "markdown": "`        entries_type_name = self.__AddAdditionalPropertyType(\n            message.name, additional_properties_info)\n        description = util.CleanDescription(\n            additional_properties_info.get('description'))\n        if description is None:\n            description = 'Additional properties of type %s' % message.name\n        attrs = {\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/gen_client_lib.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/gen_client_lib.py"
                },
                "region": {
                  "startLine": 116,
                  "startColumn": 42,
                  "endLine": 116,
                  "endColumn": 47,
                  "snippet": {
                    "text": "            self.__services_registry.AddServiceFromResource(\n                service_name, methods)\n        # We might also have top-level methods.\n        api_methods = self.__discovery_doc.get('methods', [])\n        if api_methods:\n            self.__services_registry.AddServiceFromResource(\n                'api', {'methods': api_methods})\n",
                    "rendered": {
                      "text": "            self.__services_registry.AddServiceFromResource(\n                service_name, methods)\n        # We might also have top-level methods.\n        api_methods = self.__discovery_doc.get('methods', [])\n        if api_methods:\n            self.__services_registry.AddServiceFromResource(\n                'api', {'methods': api_methods})\n",
                      "markdown": "`            self.__services_registry.AddServiceFromResource(\n                service_name, methods)\n        # We might also have top-level methods.\n        api_methods = self.__discovery_doc.get('methods', [])\n        if api_methods:\n            self.__services_registry.AddServiceFromResource(\n                'api', {'methods': api_methods})\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/gen_client_lib.py"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 39,
                  "endLine": 111,
                  "endColumn": 44,
                  "snippet": {
                    "text": "            self.__root_package,\n            self.__base_files_package,\n            unelidable_request_methods or [])\n        services = self.__discovery_doc.get('resources', {})\n        for service_name, methods in sorted(services.items()):\n            self.__services_registry.AddServiceFromResource(\n                service_name, methods)\n",
                    "rendered": {
                      "text": "            self.__root_package,\n            self.__base_files_package,\n            unelidable_request_methods or [])\n        services = self.__discovery_doc.get('resources', {})\n        for service_name, methods in sorted(services.items()):\n            self.__services_registry.AddServiceFromResource(\n                service_name, methods)\n",
                      "markdown": "`            self.__root_package,\n            self.__base_files_package,\n            unelidable_request_methods or [])\n        services = self.__discovery_doc.get('resources', {})\n        for service_name, methods in sorted(services.items()):\n            self.__services_registry.AddServiceFromResource(\n                service_name, methods)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/gen_client_lib.py"
                },
                "region": {
                  "startLine": 89,
                  "startColumn": 38,
                  "endLine": 89,
                  "endColumn": 43,
                  "snippet": {
                    "text": "            self.__client_info, self.__names, self.__description,\n            self.__root_package, self.__base_files_package,\n            self.__protorpc_package)\n        schemas = self.__discovery_doc.get('schemas', {})\n        for schema_name, schema in sorted(schemas.items()):\n            self.__message_registry.AddDescriptorFromSchema(\n                schema_name, schema)\n",
                    "rendered": {
                      "text": "            self.__client_info, self.__names, self.__description,\n            self.__root_package, self.__base_files_package,\n            self.__protorpc_package)\n        schemas = self.__discovery_doc.get('schemas', {})\n        for schema_name, schema in sorted(schemas.items()):\n            self.__message_registry.AddDescriptorFromSchema(\n                schema_name, schema)\n",
                      "markdown": "`            self.__client_info, self.__names, self.__description,\n            self.__root_package, self.__base_files_package,\n            self.__protorpc_package)\n        schemas = self.__discovery_doc.get('schemas', {})\n        for schema_name, schema in sorted(schemas.items()):\n            self.__message_registry.AddDescriptorFromSchema(\n                schema_name, schema)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/gen_client_lib.py"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 39,
                  "endLine": 76,
                  "endColumn": 44,
                  "snippet": {
                    "text": "            self.__discovery_doc.get('description', ''))\n        self.__package = self.__client_info.package\n        self.__version = self.__client_info.version\n        self.__revision = discovery_doc.get('revision', '1')\n        self.__init_wildcards_file = init_wildcards_file\n        self.__root_package = root_package\n        self.__base_files_package = base_package\n",
                    "rendered": {
                      "text": "            self.__discovery_doc.get('description', ''))\n        self.__package = self.__client_info.package\n        self.__version = self.__client_info.version\n        self.__revision = discovery_doc.get('revision', '1')\n        self.__init_wildcards_file = init_wildcards_file\n        self.__root_package = root_package\n        self.__base_files_package = base_package\n",
                      "markdown": "`            self.__discovery_doc.get('description', ''))\n        self.__package = self.__client_info.package\n        self.__version = self.__client_info.version\n        self.__revision = discovery_doc.get('revision', '1')\n        self.__init_wildcards_file = init_wildcards_file\n        self.__root_package = root_package\n        self.__base_files_package = base_package\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/gen_client_lib.py"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 32,
                  "endLine": 73,
                  "endColumn": 37,
                  "snippet": {
                    "text": "        self.__outdir = outdir\n        self.__use_proto2 = use_proto2\n        self.__description = util.CleanDescription(\n            self.__discovery_doc.get('description', ''))\n        self.__package = self.__client_info.package\n        self.__version = self.__client_info.version\n        self.__revision = discovery_doc.get('revision', '1')\n",
                    "rendered": {
                      "text": "        self.__outdir = outdir\n        self.__use_proto2 = use_proto2\n        self.__description = util.CleanDescription(\n            self.__discovery_doc.get('description', ''))\n        self.__package = self.__client_info.package\n        self.__version = self.__client_info.version\n        self.__revision = discovery_doc.get('revision', '1')\n",
                      "markdown": "`        self.__outdir = outdir\n        self.__use_proto2 = use_proto2\n        self.__description = util.CleanDescription(\n            self.__discovery_doc.get('description', ''))\n        self.__package = self.__client_info.package\n        self.__version = self.__client_info.version\n        self.__revision = discovery_doc.get('revision', '1')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/gen_client_lib.py"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 35,
                  "endLine": 48,
                  "endColumn": 40,
                  "snippet": {
                    "text": "        'id': 'StandardQueryParameters',\n        'type': 'object',\n        'description': 'Query parameters accepted by all methods.',\n        'properties': discovery_doc.get('parameters', {}),\n    }\n    # We add an entry for the trace, since Discovery doesn't.\n    standard_query_schema['properties']['trace'] = {\n",
                    "rendered": {
                      "text": "        'id': 'StandardQueryParameters',\n        'type': 'object',\n        'description': 'Query parameters accepted by all methods.',\n        'properties': discovery_doc.get('parameters', {}),\n    }\n    # We add an entry for the trace, since Discovery doesn't.\n    standard_query_schema['properties']['trace'] = {\n",
                      "markdown": "`        'id': 'StandardQueryParameters',\n        'type': 'object',\n        'description': 'Query parameters accepted by all methods.',\n        'properties': discovery_doc.get('parameters', {}),\n    }\n    # We add an entry for the trace, since Discovery doesn't.\n    standard_query_schema['properties']['trace'] = {\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 563,
                  "startColumn": 51,
                  "endLine": 563,
                  "endColumn": 55,
                  "snippet": {
                    "text": "                credentials = tools.run_flow(flow, credential_store, flags)\n                break\n            except (oauth2client.client.FlowExchangeError, SystemExit) as e:\n                # Here SystemExit is \"no credential at all\", and the\n                # FlowExchangeError is \"invalid\" -- usually because\n                # you reused a token.\n                print('Invalid authorization: %s' % (e,))\n",
                    "rendered": {
                      "text": "                credentials = tools.run_flow(flow, credential_store, flags)\n                break\n            except (oauth2client.client.FlowExchangeError, SystemExit) as e:\n                # Here SystemExit is \"no credential at all\", and the\n                # FlowExchangeError is \"invalid\" -- usually because\n                # you reused a token.\n                print('Invalid authorization: %s' % (e,))\n",
                      "markdown": "`                credentials = tools.run_flow(flow, credential_store, flags)\n                break\n            except (oauth2client.client.FlowExchangeError, SystemExit) as e:\n                # Here SystemExit is \"no credential at all\", and the\n                # FlowExchangeError is \"invalid\" -- usually because\n                # you reused a token.\n                print('Invalid authorization: %s' % (e,))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 774,
                  "startColumn": 41,
                  "endLine": 774,
                  "endColumn": 45,
                  "snippet": {
                    "text": "    cp = 'https://www.googleapis.com/auth/cloud-platform'\n    if credentials is None:\n        return None\n    if not isinstance(credentials, gc) or cp in scopes:\n        return credentials.create_scoped(scopes)\n    return None\n",
                    "rendered": {
                      "text": "    cp = 'https://www.googleapis.com/auth/cloud-platform'\n    if credentials is None:\n        return None\n    if not isinstance(credentials, gc) or cp in scopes:\n        return credentials.create_scoped(scopes)\n    return None\n",
                      "markdown": "`    cp = 'https://www.googleapis.com/auth/cloud-platform'\n    if credentials is None:\n        return None\n    if not isinstance(credentials, gc) or cp in scopes:\n        return credentials.create_scoped(scopes)\n    return None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 771,
                  "startColumn": 3,
                  "endLine": 771,
                  "endColumn": 7,
                  "snippet": {
                    "text": "    # credential will work for us. We assume that if we're requesting\n    # cloud-platform, our scopes are a subset of cloud scopes, and the\n    # ADC will work.\n    cp = 'https://www.googleapis.com/auth/cloud-platform'\n    if credentials is None:\n        return None\n    if not isinstance(credentials, gc) or cp in scopes:\n",
                    "rendered": {
                      "text": "    # credential will work for us. We assume that if we're requesting\n    # cloud-platform, our scopes are a subset of cloud scopes, and the\n    # ADC will work.\n    cp = 'https://www.googleapis.com/auth/cloud-platform'\n    if credentials is None:\n        return None\n    if not isinstance(credentials, gc) or cp in scopes:\n",
                      "markdown": "`    # credential will work for us. We assume that if we're requesting\n    # cloud-platform, our scopes are a subset of cloud scopes, and the\n    # ADC will work.\n    cp = 'https://www.googleapis.com/auth/cloud-platform'\n    if credentials is None:\n        return None\n    if not isinstance(credentials, gc) or cp in scopes:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 586,
                  "startColumn": 32,
                  "endLine": 586,
                  "endColumn": 38,
                  "snippet": {
                    "text": "      the interprocess lock within `_lock_timeout` the call will return as\n      a cache miss or unsuccessful cache write.\n    * App Engine environments cannot be process locked because (1) the runtime\n      does not provide monotonic time and (2) different processes may or may\n      not share the same machine. Because of this, process locks are disabled\n      and locking is only guaranteed to protect against multithreaded access.\n    \"\"\"\n",
                    "rendered": {
                      "text": "      the interprocess lock within `_lock_timeout` the call will return as\n      a cache miss or unsuccessful cache write.\n    * App Engine environments cannot be process locked because (1) the runtime\n      does not provide monotonic time and (2) different processes may or may\n      not share the same machine. Because of this, process locks are disabled\n      and locking is only guaranteed to protect against multithreaded access.\n    \"\"\"\n",
                      "markdown": "`      the interprocess lock within `_lock_timeout` the call will return as\n      a cache miss or unsuccessful cache write.\n    * App Engine environments cannot be process locked because (1) the runtime\n      does not provide monotonic time and (2) different processes may or may\n      not share the same machine. Because of this, process locks are disabled\n      and locking is only guaranteed to protect against multithreaded access.\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 509,
                  "startColumn": 27,
                  "endLine": 509,
                  "endColumn": 36,
                  "snippet": {
                    "text": "            NotImplementedError, always.\n        \"\"\"\n        raise NotImplementedError(\n            'Compute Engine service accounts cannot sign blobs')\n\n\ndef _GetRunFlowFlags(args=None):\n",
                    "rendered": {
                      "text": "            NotImplementedError, always.\n        \"\"\"\n        raise NotImplementedError(\n            'Compute Engine service accounts cannot sign blobs')\n\n\ndef _GetRunFlowFlags(args=None):\n",
                      "markdown": "`            NotImplementedError, always.\n        \"\"\"\n        raise NotImplementedError(\n            'Compute Engine service accounts cannot sign blobs')\n\n\ndef _GetRunFlowFlags(args=None):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 499,
                  "startColumn": 55,
                  "endLine": 499,
                  "endColumn": 64,
                  "snippet": {
                    "text": "        \"\"\"Cryptographically sign a blob (of bytes).\n\n        This method is provided to support a common interface, but\n        the actual key used for a Google Compute Engine service account\n        is not available, so it can't be used to sign content.\n\n        Args:\n",
                    "rendered": {
                      "text": "        \"\"\"Cryptographically sign a blob (of bytes).\n\n        This method is provided to support a common interface, but\n        the actual key used for a Google Compute Engine service account\n        is not available, so it can't be used to sign content.\n\n        Args:\n",
                      "markdown": "`        \"\"\"Cryptographically sign a blob (of bytes).\n\n        This method is provided to support a common interface, but\n        the actual key used for a Google Compute Engine service account\n        is not available, so it can't be used to sign content.\n\n        Args:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 451,
                  "startColumn": 49,
                  "endLine": 451,
                  "endColumn": 58,
                  "snippet": {
                    "text": "    @property\n    def serialization_data(self):\n        raise NotImplementedError(\n            'Cannot serialize credentials for GCE service accounts.')\n\n\n# TODO(craigcitro): Currently, we can't even *load*\n",
                    "rendered": {
                      "text": "    @property\n    def serialization_data(self):\n        raise NotImplementedError(\n            'Cannot serialize credentials for GCE service accounts.')\n\n\n# TODO(craigcitro): Currently, we can't even *load*\n",
                      "markdown": "`    @property\n    def serialization_data(self):\n        raise NotImplementedError(\n            'Cannot serialize credentials for GCE service accounts.')\n\n\n# TODO(craigcitro): Currently, we can't even *load*\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 343,
                  "startColumn": 46,
                  "endLine": 343,
                  "endColumn": 55,
                  "snippet": {
                    "text": "                'GCE credentials requested outside a GCE instance')\n        if not self.GetServiceAccount(self.__service_account_name):\n            raise exceptions.ResourceUnavailableError(\n                'GCE credentials requested but service account '\n                '%s does not exist.' % self.__service_account_name)\n        if scopes:\n            scope_ls = util.NormalizeScopes(scopes)\n",
                    "rendered": {
                      "text": "                'GCE credentials requested outside a GCE instance')\n        if not self.GetServiceAccount(self.__service_account_name):\n            raise exceptions.ResourceUnavailableError(\n                'GCE credentials requested but service account '\n                '%s does not exist.' % self.__service_account_name)\n        if scopes:\n            scope_ls = util.NormalizeScopes(scopes)\n",
                      "markdown": "`                'GCE credentials requested outside a GCE instance')\n        if not self.GetServiceAccount(self.__service_account_name):\n            raise exceptions.ResourceUnavailableError(\n                'GCE credentials requested but service account '\n                '%s does not exist.' % self.__service_account_name)\n        if scopes:\n            scope_ls = util.NormalizeScopes(scopes)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 244,
                  "startColumn": 35,
                  "endLine": 244,
                  "endColumn": 44,
                  "snippet": {
                    "text": "        Args:\n          scopes: The scopes to get. If None, whatever scopes that are\n              available to the instance are used.\n          service_account_name: The service account to retrieve the scopes\n              from.\n          **kwds: Additional keyword args.\n\n",
                    "rendered": {
                      "text": "        Args:\n          scopes: The scopes to get. If None, whatever scopes that are\n              available to the instance are used.\n          service_account_name: The service account to retrieve the scopes\n              from.\n          **kwds: Additional keyword args.\n\n",
                      "markdown": "`        Args:\n          scopes: The scopes to get. If None, whatever scopes that are\n              available to the instance are used.\n          service_account_name: The service account to retrieve the scopes\n              from.\n          **kwds: Additional keyword args.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 180,
                  "startColumn": 24,
                  "endLine": 180,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        account_type = service_account_info.get('type')\n        if account_type != oauth2client.client.SERVICE_ACCOUNT:\n            raise exceptions.CredentialsError(\n                'Invalid service account credentials: %s' % (filename,))\n        # pylint: disable=protected-access\n        credentials = service_account._ServiceAccountCredentials(\n            service_account_id=service_account_info['client_id'],\n",
                    "rendered": {
                      "text": "        account_type = service_account_info.get('type')\n        if account_type != oauth2client.client.SERVICE_ACCOUNT:\n            raise exceptions.CredentialsError(\n                'Invalid service account credentials: %s' % (filename,))\n        # pylint: disable=protected-access\n        credentials = service_account._ServiceAccountCredentials(\n            service_account_id=service_account_info['client_id'],\n",
                      "markdown": "`        account_type = service_account_info.get('type')\n        if account_type != oauth2client.client.SERVICE_ACCOUNT:\n            raise exceptions.CredentialsError(\n                'Invalid service account credentials: %s' % (filename,))\n        # pylint: disable=protected-access\n        credentials = service_account._ServiceAccountCredentials(\n            service_account_id=service_account_info['client_id'],\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 11,
                  "endLine": 41,
                  "endColumn": 17,
                  "snippet": {
                    "text": "from apitools.base.py import util\n\n# App Engine does not support ctypes which are required for the\n# monotonic time used in fasteners. Conversely, App Engine does\n# not support colocated concurrent processes, so process locks\n# are not needed.\ntry:\n",
                    "rendered": {
                      "text": "from apitools.base.py import util\n\n# App Engine does not support ctypes which are required for the\n# monotonic time used in fasteners. Conversely, App Engine does\n# not support colocated concurrent processes, so process locks\n# are not needed.\ntry:\n",
                      "markdown": "`from apitools.base.py import util\n\n# App Engine does not support ctypes which are required for the\n# monotonic time used in fasteners. Conversely, App Engine does\n# not support colocated concurrent processes, so process locks\n# are not needed.\ntry:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 746,
                  "startColumn": 34,
                  "endLine": 746,
                  "endColumn": 39,
                  "snippet": {
                    "text": "@_RegisterCredentialsMethod\ndef _GetGceServiceAccount(client_info, **unused_kwds):\n    scopes = client_info['scope'].split(' ')\n    return GceAssertionCredentials.Get(scopes=scopes)\n\n\n@_RegisterCredentialsMethod\n",
                    "rendered": {
                      "text": "@_RegisterCredentialsMethod\ndef _GetGceServiceAccount(client_info, **unused_kwds):\n    scopes = client_info['scope'].split(' ')\n    return GceAssertionCredentials.Get(scopes=scopes)\n\n\n@_RegisterCredentialsMethod\n",
                      "markdown": "`@_RegisterCredentialsMethod\ndef _GetGceServiceAccount(client_info, **unused_kwds):\n    scopes = client_info['scope'].split(' ')\n    return GceAssertionCredentials.Get(scopes=scopes)\n\n\n@_RegisterCredentialsMethod\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 740,
                  "startColumn": 34,
                  "endLine": 740,
                  "endColumn": 39,
                  "snippet": {
                    "text": "@_RegisterCredentialsMethod\ndef _GetGaeServiceAccount(client_info, **unused_kwds):\n    scopes = client_info['scope'].split(' ')\n    return GaeAssertionCredentials.Get(scopes=scopes)\n\n\n@_RegisterCredentialsMethod\n",
                    "rendered": {
                      "text": "@_RegisterCredentialsMethod\ndef _GetGaeServiceAccount(client_info, **unused_kwds):\n    scopes = client_info['scope'].split(' ')\n    return GaeAssertionCredentials.Get(scopes=scopes)\n\n\n@_RegisterCredentialsMethod\n",
                      "markdown": "`@_RegisterCredentialsMethod\ndef _GetGaeServiceAccount(client_info, **unused_kwds):\n    scopes = client_info['scope'].split(' ')\n    return GaeAssertionCredentials.Get(scopes=scopes)\n\n\n@_RegisterCredentialsMethod\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 706,
                  "startColumn": 32,
                  "endLine": 706,
                  "endColumn": 41,
                  "snippet": {
                    "text": "    if response.status == http_client.BAD_REQUEST:\n        credentials.refresh(http)\n        url = _GetUserinfoUrl(credentials)\n        response, content = http.request(url)\n    return json.loads(content or '{}')  # Save ourselves from an empty reply.\n\n\n",
                    "rendered": {
                      "text": "    if response.status == http_client.BAD_REQUEST:\n        credentials.refresh(http)\n        url = _GetUserinfoUrl(credentials)\n        response, content = http.request(url)\n    return json.loads(content or '{}')  # Save ourselves from an empty reply.\n\n\n",
                      "markdown": "`    if response.status == http_client.BAD_REQUEST:\n        credentials.refresh(http)\n        url = _GetUserinfoUrl(credentials)\n        response, content = http.request(url)\n    return json.loads(content or '{}')  # Save ourselves from an empty reply.\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 702,
                  "startColumn": 28,
                  "endLine": 702,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    url = _GetUserinfoUrl(credentials)\n    # We ignore communication woes here (i.e. SSL errors, socket\n    # timeout), as handling these should be done in a common location.\n    response, content = http.request(url)\n    if response.status == http_client.BAD_REQUEST:\n        credentials.refresh(http)\n        url = _GetUserinfoUrl(credentials)\n",
                    "rendered": {
                      "text": "    url = _GetUserinfoUrl(credentials)\n    # We ignore communication woes here (i.e. SSL errors, socket\n    # timeout), as handling these should be done in a common location.\n    response, content = http.request(url)\n    if response.status == http_client.BAD_REQUEST:\n        credentials.refresh(http)\n        url = _GetUserinfoUrl(credentials)\n",
                      "markdown": "`    url = _GetUserinfoUrl(credentials)\n    # We ignore communication woes here (i.e. SSL errors, socket\n    # timeout), as handling these should be done in a common location.\n    response, content = http.request(url)\n    if response.status == http_client.BAD_REQUEST:\n        credentials.refresh(http)\n        url = _GetUserinfoUrl(credentials)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 550,
                  "startColumn": 34,
                  "endLine": 550,
                  "endColumn": 39,
                  "snippet": {
                    "text": "            path, storage_key)\n    if hasattr(FLAGS, 'auth_local_webserver'):\n        FLAGS.auth_local_webserver = False\n    credentials = credential_store.get()\n    if credentials is None or credentials.invalid:\n        print('Generating new OAuth credentials ...')\n        for _ in range(20):\n",
                    "rendered": {
                      "text": "            path, storage_key)\n    if hasattr(FLAGS, 'auth_local_webserver'):\n        FLAGS.auth_local_webserver = False\n    credentials = credential_store.get()\n    if credentials is None or credentials.invalid:\n        print('Generating new OAuth credentials ...')\n        for _ in range(20):\n",
                      "markdown": "`            path, storage_key)\n    if hasattr(FLAGS, 'auth_local_webserver'):\n        FLAGS.auth_local_webserver = False\n    credentials = credential_store.get()\n    if credentials is None or credentials.invalid:\n        print('Generating new OAuth credentials ...')\n        for _ in range(20):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 431,
                  "startColumn": 35,
                  "endLine": 431,
                  "endColumn": 40,
                  "snippet": {
                    "text": "    def from_json(cls, json_data):\n        data = json.loads(json_data)\n        kwargs = {}\n        if 'cache_filename' in data.get('kwargs', []):\n            kwargs['cache_filename'] = data['kwargs']['cache_filename']\n        # Newer versions of GceAssertionCredentials don't have a \"scope\"\n        # attribute.\n",
                    "rendered": {
                      "text": "    def from_json(cls, json_data):\n        data = json.loads(json_data)\n        kwargs = {}\n        if 'cache_filename' in data.get('kwargs', []):\n            kwargs['cache_filename'] = data['kwargs']['cache_filename']\n        # Newer versions of GceAssertionCredentials don't have a \"scope\"\n        # attribute.\n",
                      "markdown": "`    def from_json(cls, json_data):\n        data = json.loads(json_data)\n        kwargs = {}\n        if 'cache_filename' in data.get('kwargs', []):\n            kwargs['cache_filename'] = data['kwargs']['cache_filename']\n        # Newer versions of GceAssertionCredentials don't have a \"scope\"\n        # attribute.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 258,
                  "startColumn": 29,
                  "endLine": 258,
                  "endColumn": 34,
                  "snippet": {
                    "text": "            service_account_name,\n            encoding='utf-8',)\n        cached_scopes = None\n        cache_filename = kwds.get('cache_filename')\n        if cache_filename:\n            cached_scopes = self._CheckCacheFileForMatch(\n                cache_filename, scopes)\n",
                    "rendered": {
                      "text": "            service_account_name,\n            encoding='utf-8',)\n        cached_scopes = None\n        cache_filename = kwds.get('cache_filename')\n        if cache_filename:\n            cached_scopes = self._CheckCacheFileForMatch(\n                cache_filename, scopes)\n",
                      "markdown": "`            service_account_name,\n            encoding='utf-8',)\n        cached_scopes = None\n        cache_filename = kwds.get('cache_filename')\n        if cache_filename:\n            cached_scopes = self._CheckCacheFileForMatch(\n                cache_filename, scopes)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 224,
                  "startColumn": 28,
                  "endLine": 224,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    # Extra header requirement can be found here:\n    # https://developers.google.com/compute/docs/metadata\n    headers = {'Metadata-Flavor': 'Google'}\n    request = urllib.request.Request(url, headers=headers)\n    opener = urllib.request.build_opener(urllib.request.ProxyHandler({}))\n    try:\n        response = opener.open(request)\n",
                    "rendered": {
                      "text": "    # Extra header requirement can be found here:\n    # https://developers.google.com/compute/docs/metadata\n    headers = {'Metadata-Flavor': 'Google'}\n    request = urllib.request.Request(url, headers=headers)\n    opener = urllib.request.build_opener(urllib.request.ProxyHandler({}))\n    try:\n        response = opener.open(request)\n",
                      "markdown": "`    # Extra header requirement can be found here:\n    # https://developers.google.com/compute/docs/metadata\n    headers = {'Metadata-Flavor': 'Google'}\n    request = urllib.request.Request(url, headers=headers)\n    opener = urllib.request.build_opener(urllib.request.ProxyHandler({}))\n    try:\n        response = opener.open(request)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 29,
                  "endLine": 218,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n    url = 'http://' + base_url + '/computeMetadata/v1/' + relative_url\n    # Extra header requirement can be found here:\n",
                    "rendered": {
                      "text": "    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n    url = 'http://' + base_url + '/computeMetadata/v1/' + relative_url\n    # Extra header requirement can be found here:\n",
                      "markdown": "`    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n    url = 'http://' + base_url + '/computeMetadata/v1/' + relative_url\n    # Extra header requirement can be found here:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 216,
                  "startColumn": 29,
                  "endLine": 216,
                  "endColumn": 34,
                  "snippet": {
                    "text": "def _GceMetadataRequest(relative_url, use_metadata_ip=False):\n    \"\"\"Request the given url from the GCE metadata service.\"\"\"\n    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n",
                    "rendered": {
                      "text": "def _GceMetadataRequest(relative_url, use_metadata_ip=False):\n    \"\"\"Request the given url from the GCE metadata service.\"\"\"\n    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n",
                      "markdown": "`def _GceMetadataRequest(relative_url, use_metadata_ip=False):\n    \"\"\"Request the given url from the GCE metadata service.\"\"\"\n    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 177,
                  "startColumn": 43,
                  "endLine": 177,
                  "endColumn": 48,
                  "snippet": {
                    "text": "        # oauth2client < 2.0.0\n        with open(filename) as keyfile:\n            service_account_info = json.load(keyfile)\n        account_type = service_account_info.get('type')\n        if account_type != oauth2client.client.SERVICE_ACCOUNT:\n            raise exceptions.CredentialsError(\n                'Invalid service account credentials: %s' % (filename,))\n",
                    "rendered": {
                      "text": "        # oauth2client < 2.0.0\n        with open(filename) as keyfile:\n            service_account_info = json.load(keyfile)\n        account_type = service_account_info.get('type')\n        if account_type != oauth2client.client.SERVICE_ACCOUNT:\n            raise exceptions.CredentialsError(\n                'Invalid service account credentials: %s' % (filename,))\n",
                      "markdown": "`        # oauth2client < 2.0.0\n        with open(filename) as keyfile:\n            service_account_info = json.load(keyfile)\n        account_type = service_account_info.get('type')\n        if account_type != oauth2client.client.SERVICE_ACCOUNT:\n            raise exceptions.CredentialsError(\n                'Invalid service account credentials: %s' % (filename,))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 27,
                  "endLine": 48,
                  "endColumn": 32,
                  "snippet": {
                    "text": "    import fasteners\n    _FASTENERS_AVAILABLE = True\nexcept ImportError as import_error:\n    server_env = os.environ.get('SERVER_SOFTWARE', '')\n    if not (server_env.startswith('Development') or\n            server_env.startswith('Google App Engine')):\n        raise import_error\n",
                    "rendered": {
                      "text": "    import fasteners\n    _FASTENERS_AVAILABLE = True\nexcept ImportError as import_error:\n    server_env = os.environ.get('SERVER_SOFTWARE', '')\n    if not (server_env.startswith('Development') or\n            server_env.startswith('Google App Engine')):\n        raise import_error\n",
                      "markdown": "`    import fasteners\n    _FASTENERS_AVAILABLE = True\nexcept ImportError as import_error:\n    server_env = os.environ.get('SERVER_SOFTWARE', '')\n    if not (server_env.startswith('Development') or\n            server_env.startswith('Google App Engine')):\n        raise import_error\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 207,
                  "startColumn": 18,
                  "endLine": 207,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        return credentials\n    else:\n        # oauth2client < 2.0.0\n        with open(private_key_filename, 'rb') as key_file:\n            return oauth2client.client.SignedJwtAssertionCredentials(\n                service_account_name, key_file.read(), scopes,\n                user_agent=user_agent)\n",
                    "rendered": {
                      "text": "        return credentials\n    else:\n        # oauth2client < 2.0.0\n        with open(private_key_filename, 'rb') as key_file:\n            return oauth2client.client.SignedJwtAssertionCredentials(\n                service_account_name, key_file.read(), scopes,\n                user_agent=user_agent)\n",
                      "markdown": "`        return credentials\n    else:\n        # oauth2client < 2.0.0\n        with open(private_key_filename, 'rb') as key_file:\n            return oauth2client.client.SignedJwtAssertionCredentials(\n                service_account_name, key_file.read(), scopes,\n                user_agent=user_agent)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 201,
                  "startColumn": 38,
                  "endLine": 201,
                  "endColumn": 49,
                  "snippet": {
                    "text": "        # oauth2client >= 2.0.0\n        credentials = (\n            service_account.ServiceAccountCredentials.from_p12_keyfile(\n                service_account_name, private_key_filename, scopes=scopes))\n        if credentials is not None:\n            credentials.user_agent = user_agent\n        return credentials\n",
                    "rendered": {
                      "text": "        # oauth2client >= 2.0.0\n        credentials = (\n            service_account.ServiceAccountCredentials.from_p12_keyfile(\n                service_account_name, private_key_filename, scopes=scopes))\n        if credentials is not None:\n            credentials.user_agent = user_agent\n        return credentials\n",
                      "markdown": "`        # oauth2client >= 2.0.0\n        credentials = (\n            service_account.ServiceAccountCredentials.from_p12_keyfile(\n                service_account_name, private_key_filename, scopes=scopes))\n        if credentials is not None:\n            credentials.user_agent = user_agent\n        return credentials\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 195,
                  "startColumn": 46,
                  "endLine": 195,
                  "endColumn": 57,
                  "snippet": {
                    "text": "def ServiceAccountCredentialsFromP12File(\n        service_account_name, private_key_filename, scopes, user_agent):\n    \"\"\"Create a new credential from the named .p12 keyfile.\"\"\"\n    private_key_filename = os.path.expanduser(private_key_filename)\n    scopes = util.NormalizeScopes(scopes)\n    if oauth2client.__version__ > '1.5.2':\n        # oauth2client >= 2.0.0\n",
                    "rendered": {
                      "text": "def ServiceAccountCredentialsFromP12File(\n        service_account_name, private_key_filename, scopes, user_agent):\n    \"\"\"Create a new credential from the named .p12 keyfile.\"\"\"\n    private_key_filename = os.path.expanduser(private_key_filename)\n    scopes = util.NormalizeScopes(scopes)\n    if oauth2client.__version__ > '1.5.2':\n        # oauth2client >= 2.0.0\n",
                      "markdown": "`def ServiceAccountCredentialsFromP12File(\n        service_account_name, private_key_filename, scopes, user_agent):\n    \"\"\"Create a new credential from the named .p12 keyfile.\"\"\"\n    private_key_filename = os.path.expanduser(private_key_filename)\n    scopes = util.NormalizeScopes(scopes)\n    if oauth2client.__version__ > '1.5.2':\n        # oauth2client >= 2.0.0\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 195,
                  "startColumn": 4,
                  "endLine": 195,
                  "endColumn": 15,
                  "snippet": {
                    "text": "def ServiceAccountCredentialsFromP12File(\n        service_account_name, private_key_filename, scopes, user_agent):\n    \"\"\"Create a new credential from the named .p12 keyfile.\"\"\"\n    private_key_filename = os.path.expanduser(private_key_filename)\n    scopes = util.NormalizeScopes(scopes)\n    if oauth2client.__version__ > '1.5.2':\n        # oauth2client >= 2.0.0\n",
                    "rendered": {
                      "text": "def ServiceAccountCredentialsFromP12File(\n        service_account_name, private_key_filename, scopes, user_agent):\n    \"\"\"Create a new credential from the named .p12 keyfile.\"\"\"\n    private_key_filename = os.path.expanduser(private_key_filename)\n    scopes = util.NormalizeScopes(scopes)\n    if oauth2client.__version__ > '1.5.2':\n        # oauth2client >= 2.0.0\n",
                      "markdown": "`def ServiceAccountCredentialsFromP12File(\n        service_account_name, private_key_filename, scopes, user_agent):\n    \"\"\"Create a new credential from the named .p12 keyfile.\"\"\"\n    private_key_filename = os.path.expanduser(private_key_filename)\n    scopes = util.NormalizeScopes(scopes)\n    if oauth2client.__version__ > '1.5.2':\n        # oauth2client >= 2.0.0\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 193,
                  "startColumn": 30,
                  "endLine": 193,
                  "endColumn": 41,
                  "snippet": {
                    "text": "\n\ndef ServiceAccountCredentialsFromP12File(\n        service_account_name, private_key_filename, scopes, user_agent):\n    \"\"\"Create a new credential from the named .p12 keyfile.\"\"\"\n    private_key_filename = os.path.expanduser(private_key_filename)\n    scopes = util.NormalizeScopes(scopes)\n",
                    "rendered": {
                      "text": "\n\ndef ServiceAccountCredentialsFromP12File(\n        service_account_name, private_key_filename, scopes, user_agent):\n    \"\"\"Create a new credential from the named .p12 keyfile.\"\"\"\n    private_key_filename = os.path.expanduser(private_key_filename)\n    scopes = util.NormalizeScopes(scopes)\n",
                      "markdown": "`\n\ndef ServiceAccountCredentialsFromP12File(\n        service_account_name, private_key_filename, scopes, user_agent):\n    \"\"\"Create a new credential from the named .p12 keyfile.\"\"\"\n    private_key_filename = os.path.expanduser(private_key_filename)\n    scopes = util.NormalizeScopes(scopes)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 186,
                  "startColumn": 57,
                  "endLine": 186,
                  "endColumn": 68,
                  "snippet": {
                    "text": "            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n        return credentials\n",
                    "rendered": {
                      "text": "            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n        return credentials\n",
                      "markdown": "`            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n        return credentials\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 186,
                  "startColumn": 12,
                  "endLine": 186,
                  "endColumn": 23,
                  "snippet": {
                    "text": "            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n        return credentials\n",
                    "rendered": {
                      "text": "            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n        return credentials\n",
                      "markdown": "`            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n        return credentials\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 185,
                  "startColumn": 49,
                  "endLine": 185,
                  "endColumn": 60,
                  "snippet": {
                    "text": "        credentials = service_account._ServiceAccountCredentials(\n            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n",
                    "rendered": {
                      "text": "        credentials = service_account._ServiceAccountCredentials(\n            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n",
                      "markdown": "`        credentials = service_account._ServiceAccountCredentials(\n            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 185,
                  "startColumn": 12,
                  "endLine": 185,
                  "endColumn": 23,
                  "snippet": {
                    "text": "        credentials = service_account._ServiceAccountCredentials(\n            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n",
                    "rendered": {
                      "text": "        credentials = service_account._ServiceAccountCredentials(\n            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n",
                      "markdown": "`        credentials = service_account._ServiceAccountCredentials(\n            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 22,
                  "endLine": 218,
                  "endColumn": 33,
                  "snippet": {
                    "text": "    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n    url = 'http://' + base_url + '/computeMetadata/v1/' + relative_url\n    # Extra header requirement can be found here:\n",
                    "rendered": {
                      "text": "    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n    url = 'http://' + base_url + '/computeMetadata/v1/' + relative_url\n    # Extra header requirement can be found here:\n",
                      "markdown": "`    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n    url = 'http://' + base_url + '/computeMetadata/v1/' + relative_url\n    # Extra header requirement can be found here:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 216,
                  "startColumn": 22,
                  "endLine": 216,
                  "endColumn": 33,
                  "snippet": {
                    "text": "def _GceMetadataRequest(relative_url, use_metadata_ip=False):\n    \"\"\"Request the given url from the GCE metadata service.\"\"\"\n    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n",
                    "rendered": {
                      "text": "def _GceMetadataRequest(relative_url, use_metadata_ip=False):\n    \"\"\"Request the given url from the GCE metadata service.\"\"\"\n    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n",
                      "markdown": "`def _GceMetadataRequest(relative_url, use_metadata_ip=False):\n    \"\"\"Request the given url from the GCE metadata service.\"\"\"\n    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 11,
                  "endLine": 48,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    import fasteners\n    _FASTENERS_AVAILABLE = True\nexcept ImportError as import_error:\n    server_env = os.environ.get('SERVER_SOFTWARE', '')\n    if not (server_env.startswith('Development') or\n            server_env.startswith('Google App Engine')):\n        raise import_error\n",
                    "rendered": {
                      "text": "    import fasteners\n    _FASTENERS_AVAILABLE = True\nexcept ImportError as import_error:\n    server_env = os.environ.get('SERVER_SOFTWARE', '')\n    if not (server_env.startswith('Development') or\n            server_env.startswith('Google App Engine')):\n        raise import_error\n",
                      "markdown": "`    import fasteners\n    _FASTENERS_AVAILABLE = True\nexcept ImportError as import_error:\n    server_env = os.environ.get('SERVER_SOFTWARE', '')\n    if not (server_env.startswith('Development') or\n            server_env.startswith('Google App Engine')):\n        raise import_error\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/compression.py"
                },
                "region": {
                  "startLine": 124,
                  "startColumn": 15,
                  "endLine": 124,
                  "endColumn": 19,
                  "snippet": {
                    "text": "            self.__size += len(data)\n\n    def read(self, size=None):\n        \"\"\"Read at most size bytes from this buffer.\n\n        Bytes read from this buffer are consumed and are permanently removed.\n\n",
                    "rendered": {
                      "text": "            self.__size += len(data)\n\n    def read(self, size=None):\n        \"\"\"Read at most size bytes from this buffer.\n\n        Bytes read from this buffer are consumed and are permanently removed.\n\n",
                      "markdown": "`            self.__size += len(data)\n\n    def read(self, size=None):\n        \"\"\"Read at most size bytes from this buffer.\n\n        Bytes read from this buffer are consumed and are permanently removed.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/compression.py"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 34,
                  "endLine": 75,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    with gzip.GzipFile(mode='wb',\n                       fileobj=out_stream,\n                       compresslevel=compresslevel) as compress_stream:\n        # Read until we've written at least length bytes to the output stream.\n        while not length or out_stream.length < length:\n            data = in_stream.read(chunksize)\n            data_length = len(data)\n",
                    "rendered": {
                      "text": "    with gzip.GzipFile(mode='wb',\n                       fileobj=out_stream,\n                       compresslevel=compresslevel) as compress_stream:\n        # Read until we've written at least length bytes to the output stream.\n        while not length or out_stream.length < length:\n            data = in_stream.read(chunksize)\n            data_length = len(data)\n",
                      "markdown": "`    with gzip.GzipFile(mode='wb',\n                       fileobj=out_stream,\n                       compresslevel=compresslevel) as compress_stream:\n        # Read until we've written at least length bytes to the output stream.\n        while not length or out_stream.length < length:\n            data = in_stream.read(chunksize)\n            data_length = len(data)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/compression.py"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 62,
                  "endLine": 35,
                  "endColumn": 66,
                  "snippet": {
                    "text": "\n    \"\"\"Compresses an input stream into a file-like buffer.\n\n    This reads from the input stream until either we've stored at least length\n    compressed bytes, or the input stream has been exhausted.\n\n    This supports streams of unknown size.\n",
                    "rendered": {
                      "text": "\n    \"\"\"Compresses an input stream into a file-like buffer.\n\n    This reads from the input stream until either we've stored at least length\n    compressed bytes, or the input stream has been exhausted.\n\n    This supports streams of unknown size.\n",
                      "markdown": "`\n    \"\"\"Compresses an input stream into a file-like buffer.\n\n    This reads from the input stream until either we've stored at least length\n    compressed bytes, or the input stream has been exhausted.\n\n    This supports streams of unknown size.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/compression.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/buffered_stream.py"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 37,
                  "endLine": 63,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        if size is None or size < 0:\n            raise exceptions.NotYetImplementedError(\n                'Illegal read of size %s requested on BufferedStream. '\n                'Wrapped stream %s is at position %s-%s, '\n                '%s bytes remaining.' %\n                (size, self.__stream, self.__start_pos, self.__end_pos,\n                 self._bytes_remaining))\n",
                    "rendered": {
                      "text": "        if size is None or size < 0:\n            raise exceptions.NotYetImplementedError(\n                'Illegal read of size %s requested on BufferedStream. '\n                'Wrapped stream %s is at position %s-%s, '\n                '%s bytes remaining.' %\n                (size, self.__stream, self.__start_pos, self.__end_pos,\n                 self._bytes_remaining))\n",
                      "markdown": "`        if size is None or size < 0:\n            raise exceptions.NotYetImplementedError(\n                'Illegal read of size %s requested on BufferedStream. '\n                'Wrapped stream %s is at position %s-%s, '\n                '%s bytes remaining.' %\n                (size, self.__stream, self.__start_pos, self.__end_pos,\n                 self._bytes_remaining))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/buffered_stream.py"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 60,
                  "endLine": 28,
                  "endColumn": 64,
                  "snippet": {
                    "text": "# TODO(user): Consider replacing this with a StringIO.\nclass BufferedStream(object):\n\n    \"\"\"Buffers a stream, reading ahead to determine if we're at the end.\"\"\"\n\n    def __init__(self, stream, start, size):\n        self.__stream = stream\n",
                    "rendered": {
                      "text": "# TODO(user): Consider replacing this with a StringIO.\nclass BufferedStream(object):\n\n    \"\"\"Buffers a stream, reading ahead to determine if we're at the end.\"\"\"\n\n    def __init__(self, stream, start, size):\n        self.__stream = stream\n",
                      "markdown": "`# TODO(user): Consider replacing this with a StringIO.\nclass BufferedStream(object):\n\n    \"\"\"Buffers a stream, reading ahead to determine if we're at the end.\"\"\"\n\n    def __init__(self, stream, start, size):\n        self.__stream = stream\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/buffered_stream.py"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 42,
                  "endLine": 19,
                  "endColumn": 46,
                  "snippet": {
                    "text": "\n\"\"\"Small helper class to provide a small slice of a stream.\n\nThis class reads ahead to detect if we are at the end of the stream.\n\"\"\"\n\nfrom apitools.base.py import exceptions\n",
                    "rendered": {
                      "text": "\n\"\"\"Small helper class to provide a small slice of a stream.\n\nThis class reads ahead to detect if we are at the end of the stream.\n\"\"\"\n\nfrom apitools.base.py import exceptions\n",
                      "markdown": "`\n\"\"\"Small helper class to provide a small slice of a stream.\n\nThis class reads ahead to detect if we are at the end of the stream.\n\"\"\"\n\nfrom apitools.base.py import exceptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/buffered_stream.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/__init__.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/descriptor.py"
                },
                "region": {
                  "startLine": 126,
                  "startColumn": 17,
                  "endLine": 126,
                  "endColumn": 21,
                  "snippet": {
                    "text": "\n\n# NOTE: MessageField is missing because message fields cannot have\n# a default value at this time.\n# TODO(rafek): Support default message values.\n#\n# Map to functions that convert default values of fields of a given type\n",
                    "rendered": {
                      "text": "\n\n# NOTE: MessageField is missing because message fields cannot have\n# a default value at this time.\n# TODO(rafek): Support default message values.\n#\n# Map to functions that convert default values of fields of a given type\n",
                      "markdown": "`\n\n# NOTE: MessageField is missing because message fields cannot have\n# a default value at this time.\n# TODO(rafek): Support default message values.\n#\n# Map to functions that convert default values of fields of a given type\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/descriptor.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/descriptor.py"
                },
                "region": {
                  "startLine": 604,
                  "startColumn": 45,
                  "endLine": 604,
                  "endColumn": 51,
                  "snippet": {
                    "text": "        descriptors if provided descriptor loader.\n\n        Args:\n          definition_name: Definition name to find package for.\n\n        \"\"\"\n        while True:\n",
                    "rendered": {
                      "text": "        descriptors if provided descriptor loader.\n\n        Args:\n          definition_name: Definition name to find package for.\n\n        \"\"\"\n        while True:\n",
                      "markdown": "`        descriptors if provided descriptor loader.\n\n        Args:\n          definition_name: Definition name to find package for.\n\n        \"\"\"\n        while True:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/descriptor.py"
                },
                "region": {
                  "startLine": 594,
                  "startColumn": 26,
                  "endLine": 594,
                  "endColumn": 32,
                  "snippet": {
                    "text": "            return definition\n        else:\n            raise messages.DefinitionNotFoundError(\n                'Could not find definition for %s' % definition_name)\n\n    def lookup_package(self, definition_name):\n        \"\"\"Determines the package name for any definition.\n",
                    "rendered": {
                      "text": "            return definition\n        else:\n            raise messages.DefinitionNotFoundError(\n                'Could not find definition for %s' % definition_name)\n\n    def lookup_package(self, definition_name):\n        \"\"\"Determines the package name for any definition.\n",
                      "markdown": "`            return definition\n        else:\n            raise messages.DefinitionNotFoundError(\n                'Could not find definition for %s' % definition_name)\n\n    def lookup_package(self, definition_name):\n        \"\"\"Determines the package name for any definition.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/descriptor.py"
                },
                "region": {
                  "startLine": 572,
                  "startColumn": 18,
                  "endLine": 572,
                  "endColumn": 24,
                  "snippet": {
                    "text": "        \"\"\"Lookup descriptor by name.\n\n        Get descriptor from library by name.  If descriptor is not found will\n        attempt to find via descriptor loader if provided.\n\n        Args:\n          definition_name: Definition name to find.\n",
                    "rendered": {
                      "text": "        \"\"\"Lookup descriptor by name.\n\n        Get descriptor from library by name.  If descriptor is not found will\n        attempt to find via descriptor loader if provided.\n\n        Args:\n          definition_name: Definition name to find.\n",
                      "markdown": "`        \"\"\"Lookup descriptor by name.\n\n        Get descriptor from library by name.  If descriptor is not found will\n        attempt to find via descriptor loader if provided.\n\n        Args:\n          definition_name: Definition name to find.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/descriptor.py"
                },
                "region": {
                  "startLine": 507,
                  "startColumn": 52,
                  "endLine": 507,
                  "endColumn": 58,
                  "snippet": {
                    "text": "                return describe(module)\n\n    try:\n        # Attempt to use messages.find_definition to find item.\n        return describe(messages.find_definition(definition_name,\n                                                 importer=__import__))\n    except messages.DefinitionNotFoundError as err:\n",
                    "rendered": {
                      "text": "                return describe(module)\n\n    try:\n        # Attempt to use messages.find_definition to find item.\n        return describe(messages.find_definition(definition_name,\n                                                 importer=__import__))\n    except messages.DefinitionNotFoundError as err:\n",
                      "markdown": "`                return describe(module)\n\n    try:\n        # Attempt to use messages.find_definition to find item.\n        return describe(messages.find_definition(definition_name,\n                                                 importer=__import__))\n    except messages.DefinitionNotFoundError as err:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/descriptor.py"
                },
                "region": {
                  "startLine": 404,
                  "startColumn": 30,
                  "endLine": 404,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    message_descriptors = []\n    enum_descriptors = []\n\n    # Need to iterate over all top level attributes of the module looking for\n    # message and enum definitions.  Each definition must be itself described.\n    for name in sorted(dir(module)):\n        value = getattr(module, name)\n",
                    "rendered": {
                      "text": "    message_descriptors = []\n    enum_descriptors = []\n\n    # Need to iterate over all top level attributes of the module looking for\n    # message and enum definitions.  Each definition must be itself described.\n    for name in sorted(dir(module)):\n        value = getattr(module, name)\n",
                      "markdown": "`    message_descriptors = []\n    enum_descriptors = []\n\n    # Need to iterate over all top level attributes of the module looking for\n    # message and enum definitions.  Each definition must be itself described.\n    for name in sorted(dir(module)):\n        value = getattr(module, name)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/descriptor.py"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 57,
                  "endLine": 21,
                  "endColumn": 8,
                  "snippet": {
                    "text": "\n\"\"\"Services descriptor definitions.\n\nContains message definitions and functions for converting\nservice classes into transmittable message format.\n\nDescribing an Enum instance, Enum class, Field class or Message class will\ngenerate an appropriate descriptor object that describes that class.\n",
                    "rendered": {
                      "text": "\n\"\"\"Services descriptor definitions.\n\nContains message definitions and functions for converting\nservice classes into transmittable message format.\n\nDescribing an Enum instance, Enum class, Field class or Message class will\ngenerate an appropriate descriptor object that describes that class.\n",
                      "markdown": "`\n\"\"\"Services descriptor definitions.\n\nContains message definitions and functions for converting\nservice classes into transmittable message format.\n\nDescribing an Enum instance, Enum class, Field class or Message class will\ngenerate an appropriate descriptor object that describes that class.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/google_apitools-0.5.34.dist-info/METADATA"
                },
                "region": {
                  "startLine": 70,
                  "startColumn": 4,
                  "endLine": 70,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\nand the ``nose`` testrunner::\n\n   $ pip install nose\n\nThen run the tests::\n\n",
                    "rendered": {
                      "text": "\nand the ``nose`` testrunner::\n\n   $ pip install nose\n\nThen run the tests::\n\n",
                      "markdown": "`\nand the ``nose`` testrunner::\n\n   $ pip install nose\n\nThen run the tests::\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/google_apitools-0.5.34.dist-info/METADATA"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 4,
                  "endLine": 66,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\nFirst, install the testing dependencies::\n\n   $ pip install google-apitools[testing]\n\nand the ``nose`` testrunner::\n\n",
                    "rendered": {
                      "text": "\nFirst, install the testing dependencies::\n\n   $ pip install google-apitools[testing]\n\nand the ``nose`` testrunner::\n\n",
                      "markdown": "`\nFirst, install the testing dependencies::\n\n   $ pip install google-apitools[testing]\n\nand the ``nose`` testrunner::\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/google_apitools-0.5.34.dist-info/METADATA"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 4,
                  "endLine": 59,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\nTo install the command-line scripts into the current virtual environment::\n\n   $ pip install google-apitools[cli]\n\nRunning the tests\n-----------------\n",
                    "rendered": {
                      "text": "\nTo install the command-line scripts into the current virtual environment::\n\n   $ pip install google-apitools[cli]\n\nRunning the tests\n-----------------\n",
                      "markdown": "`\nTo install the command-line scripts into the current virtual environment::\n\n   $ pip install google-apitools[cli]\n\nRunning the tests\n-----------------\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/google_apitools-0.5.34.dist-info/METADATA"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 4,
                  "endLine": 52,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\nTo install the library into the current virtual environment::\n\n   $ pip install google-apitools\n\nInstalling the command-line tools\n---------------------------------\n",
                    "rendered": {
                      "text": "\nTo install the library into the current virtual environment::\n\n   $ pip install google-apitools\n\nInstalling the command-line tools\n---------------------------------\n",
                      "markdown": "`\nTo install the library into the current virtual environment::\n\n   $ pip install google-apitools\n\nInstalling the command-line tools\n---------------------------------\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/scripts/__init__.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/http_wrapper.py"
                },
                "region": {
                  "startLine": 394,
                  "startColumn": 26,
                  "endLine": 394,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        if url_scheme and url_scheme in http.connections:\n            connection_type = http.connections[url_scheme]\n\n    # Custom printing only at debuglevel 4\n    new_debuglevel = 4 if httplib2.debuglevel == 4 else 0\n    with _Httplib2Debuglevel(http_request, new_debuglevel, http=http):\n        info, content = http.request(\n",
                    "rendered": {
                      "text": "        if url_scheme and url_scheme in http.connections:\n            connection_type = http.connections[url_scheme]\n\n    # Custom printing only at debuglevel 4\n    new_debuglevel = 4 if httplib2.debuglevel == 4 else 0\n    with _Httplib2Debuglevel(http_request, new_debuglevel, http=http):\n        info, content = http.request(\n",
                      "markdown": "`        if url_scheme and url_scheme in http.connections:\n            connection_type = http.connections[url_scheme]\n\n    # Custom printing only at debuglevel 4\n    new_debuglevel = 4 if httplib2.debuglevel == 4 else 0\n    with _Httplib2Debuglevel(http_request, new_debuglevel, http=http):\n        info, content = http.request(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/http_wrapper.py"
                },
                "region": {
                  "startLine": 387,
                  "startColumn": 11,
                  "endLine": 387,
                  "endColumn": 20,
                  "snippet": {
                    "text": "    \"\"\"\n    connection_type = None\n    # Handle overrides for connection types.  This is used if the caller\n    # wants control over the underlying connection for managing callbacks\n    # or hash digestion.\n    if getattr(http, 'connections', None):\n        url_scheme = parse.urlsplit(http_request.url).scheme\n",
                    "rendered": {
                      "text": "    \"\"\"\n    connection_type = None\n    # Handle overrides for connection types.  This is used if the caller\n    # wants control over the underlying connection for managing callbacks\n    # or hash digestion.\n    if getattr(http, 'connections', None):\n        url_scheme = parse.urlsplit(http_request.url).scheme\n",
                      "markdown": "`    \"\"\"\n    connection_type = None\n    # Handle overrides for connection types.  This is used if the caller\n    # wants control over the underlying connection for managing callbacks\n    # or hash digestion.\n    if getattr(http, 'connections', None):\n        url_scheme = parse.urlsplit(http_request.url).scheme\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/http_wrapper.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/http_wrapper.py"
                },
                "region": {
                  "startLine": 277,
                  "startColumn": 26,
                  "endLine": 277,
                  "endColumn": 35,
                  "snippet": {
                    "text": "            'Caught socket address error, retrying: %s', retry_args.exc)\n    elif isinstance(retry_args.exc, socket.timeout):\n        logging.debug(\n            'Caught socket timeout error, retrying: %s', retry_args.exc)\n    elif isinstance(retry_args.exc, httplib2.ServerNotFoundError):\n        logging.debug(\n            'Caught server not found error, retrying: %s', retry_args.exc)\n",
                    "rendered": {
                      "text": "            'Caught socket address error, retrying: %s', retry_args.exc)\n    elif isinstance(retry_args.exc, socket.timeout):\n        logging.debug(\n            'Caught socket timeout error, retrying: %s', retry_args.exc)\n    elif isinstance(retry_args.exc, httplib2.ServerNotFoundError):\n        logging.debug(\n            'Caught server not found error, retrying: %s', retry_args.exc)\n",
                      "markdown": "`            'Caught socket address error, retrying: %s', retry_args.exc)\n    elif isinstance(retry_args.exc, socket.timeout):\n        logging.debug(\n            'Caught socket timeout error, retrying: %s', retry_args.exc)\n    elif isinstance(retry_args.exc, httplib2.ServerNotFoundError):\n        logging.debug(\n            'Caught server not found error, retrying: %s', retry_args.exc)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/http_wrapper.py"
                },
                "region": {
                  "startLine": 261,
                  "startColumn": 24,
                  "endLine": 261,
                  "endColumn": 30,
                  "snippet": {
                    "text": "      retry_args: An ExceptionRetryArgs tuple.\n    \"\"\"\n    # If the server indicates how long to wait, use that value.  Otherwise,\n    # calculate the wait time on our own.\n    retry_after = None\n\n    # Transport failures\n",
                    "rendered": {
                      "text": "      retry_args: An ExceptionRetryArgs tuple.\n    \"\"\"\n    # If the server indicates how long to wait, use that value.  Otherwise,\n    # calculate the wait time on our own.\n    retry_after = None\n\n    # Transport failures\n",
                      "markdown": "`      retry_args: An ExceptionRetryArgs tuple.\n    \"\"\"\n    # If the server indicates how long to wait, use that value.  Otherwise,\n    # calculate the wait time on our own.\n    retry_after = None\n\n    # Transport failures\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/http_wrapper.py"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 6,
                  "endLine": 28,
                  "snippet": {
                    "text": "import contextlib\nimport logging\nimport socket\nimport time\n\nimport httplib2\nimport six\nfrom six.moves import http_client\n",
                    "rendered": {
                      "text": "import contextlib\nimport logging\nimport socket\nimport time\n\nimport httplib2\nimport six\nfrom six.moves import http_client\n",
                      "markdown": "`import contextlib\nimport logging\nimport socket\nimport time\n\nimport httplib2\nimport six\nfrom six.moves import http_client\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/http_wrapper.py"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 4,
                  "endLine": 46,
                  "endColumn": 47,
                  "snippet": {
                    "text": "__all__ = [\n    'CheckResponse',\n    'GetHttp',\n    'HandleExceptionsAndRebuildHttpConnections',\n    'MakeRequest',\n    'RebuildHttpConnections',\n    'Request',\n",
                    "rendered": {
                      "text": "__all__ = [\n    'CheckResponse',\n    'GetHttp',\n    'HandleExceptionsAndRebuildHttpConnections',\n    'MakeRequest',\n    'RebuildHttpConnections',\n    'Request',\n",
                      "markdown": "`__all__ = [\n    'CheckResponse',\n    'GetHttp',\n    'HandleExceptionsAndRebuildHttpConnections',\n    'MakeRequest',\n    'RebuildHttpConnections',\n    'Request',\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/http_wrapper.py"
                },
                "region": {
                  "startLine": 397,
                  "startColumn": 28,
                  "endLine": 397,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    # Custom printing only at debuglevel 4\n    new_debuglevel = 4 if httplib2.debuglevel == 4 else 0\n    with _Httplib2Debuglevel(http_request, new_debuglevel, http=http):\n        info, content = http.request(\n            str(http_request.url), method=str(http_request.http_method),\n            body=http_request.body, headers=http_request.headers,\n            redirections=redirections, connection_type=connection_type)\n",
                    "rendered": {
                      "text": "    # Custom printing only at debuglevel 4\n    new_debuglevel = 4 if httplib2.debuglevel == 4 else 0\n    with _Httplib2Debuglevel(http_request, new_debuglevel, http=http):\n        info, content = http.request(\n            str(http_request.url), method=str(http_request.http_method),\n            body=http_request.body, headers=http_request.headers,\n            redirections=redirections, connection_type=connection_type)\n",
                      "markdown": "`    # Custom printing only at debuglevel 4\n    new_debuglevel = 4 if httplib2.debuglevel == 4 else 0\n    with _Httplib2Debuglevel(http_request, new_debuglevel, http=http):\n        info, content = http.request(\n            str(http_request.url), method=str(http_request.http_method),\n            body=http_request.body, headers=http_request.headers,\n            redirections=redirections, connection_type=connection_type)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/http_wrapper.py"
                },
                "region": {
                  "startLine": 195,
                  "startColumn": 32,
                  "endLine": 195,
                  "endColumn": 37,
                  "snippet": {
                    "text": "            # case, but we *can* trust content-range, if it's present.\n            return ProcessContentRange(self.info['content-range'])\n        elif 'content-length' in self.info:\n            return int(self.info.get('content-length'))\n        elif 'content-range' in self.info:\n            return ProcessContentRange(self.info['content-range'])\n        return len(self.content)\n",
                    "rendered": {
                      "text": "            # case, but we *can* trust content-range, if it's present.\n            return ProcessContentRange(self.info['content-range'])\n        elif 'content-length' in self.info:\n            return int(self.info.get('content-length'))\n        elif 'content-range' in self.info:\n            return ProcessContentRange(self.info['content-range'])\n        return len(self.content)\n",
                      "markdown": "`            # case, but we *can* trust content-range, if it's present.\n            return ProcessContentRange(self.info['content-range'])\n        elif 'content-length' in self.info:\n            return int(self.info.get('content-length'))\n        elif 'content-range' in self.info:\n            return ProcessContentRange(self.info['content-range'])\n        return len(self.content)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/gzip.py"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 7,
                  "endLine": 145,
                  "endColumn": 11,
                  "snippet": {
                    "text": "        The compresslevel argument is an integer from 0 to 9 controlling the\n        level of compression; 1 is fastest and produces the least compression,\n        and 9 is slowest and produces the most compression. 0 is no compression\n        at all. The default is 9.\n\n        The mtime argument is an optional numeric timestamp to be written\n        to the stream when compressing.  All gzip compressed streams\n",
                    "rendered": {
                      "text": "        The compresslevel argument is an integer from 0 to 9 controlling the\n        level of compression; 1 is fastest and produces the least compression,\n        and 9 is slowest and produces the most compression. 0 is no compression\n        at all. The default is 9.\n\n        The mtime argument is an optional numeric timestamp to be written\n        to the stream when compressing.  All gzip compressed streams\n",
                      "markdown": "`        The compresslevel argument is an integer from 0 to 9 controlling the\n        level of compression; 1 is fastest and produces the least compression,\n        and 9 is slowest and produces the most compression. 0 is no compression\n        at all. The default is 9.\n\n        The mtime argument is an optional numeric timestamp to be written\n        to the stream when compressing.  All gzip compressed streams\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/gzip.py"
                },
                "region": {
                  "startLine": 122,
                  "startColumn": 7,
                  "endLine": 122,
                  "endColumn": 11,
                  "snippet": {
                    "text": "                 compresslevel=9, fileobj=None, mtime=None):\n        \"\"\"Constructor for the GzipFile class.\n\n        At least one of fileobj and filename must be given a\n        non-trivial value.\n\n        The new class instance is based on fileobj, which can be a regular\n",
                    "rendered": {
                      "text": "                 compresslevel=9, fileobj=None, mtime=None):\n        \"\"\"Constructor for the GzipFile class.\n\n        At least one of fileobj and filename must be given a\n        non-trivial value.\n\n        The new class instance is based on fileobj, which can be a regular\n",
                      "markdown": "`                 compresslevel=9, fileobj=None, mtime=None):\n        \"\"\"Constructor for the GzipFile class.\n\n        At least one of fileobj and filename must be given a\n        non-trivial value.\n\n        The new class instance is based on fileobj, which can be a regular\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/gzip.py"
                },
                "region": {
                  "startLine": 388,
                  "startColumn": 32,
                  "endLine": 388,
                  "endColumn": 40,
                  "snippet": {
                    "text": "            raise OSError(errno.EBADF, \"peek() on write-only GzipFile object\")\n\n        # Do not return ridiculously small buffers, for one common idiom\n        # is to call peek(1) and expect more bytes in return.\n        if n < 100:\n            n = 100\n        if self.extrasize == 0:\n",
                    "rendered": {
                      "text": "            raise OSError(errno.EBADF, \"peek() on write-only GzipFile object\")\n\n        # Do not return ridiculously small buffers, for one common idiom\n        # is to call peek(1) and expect more bytes in return.\n        if n < 100:\n            n = 100\n        if self.extrasize == 0:\n",
                      "markdown": "`            raise OSError(errno.EBADF, \"peek() on write-only GzipFile object\")\n\n        # Do not return ridiculously small buffers, for one common idiom\n        # is to call peek(1) and expect more bytes in return.\n        if n < 100:\n            n = 100\n        if self.extrasize == 0:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/gzip.py"
                },
                "region": {
                  "startLine": 150,
                  "startColumn": 15,
                  "endLine": 150,
                  "endColumn": 21,
                  "snippet": {
                    "text": "        The mtime argument is an optional numeric timestamp to be written\n        to the stream when compressing.  All gzip compressed streams\n        are required to contain a timestamp.  If omitted or None, the\n        current time is used.  This module ignores the timestamp when\n        decompressing; however, some programs, such as gunzip, make use\n        of it.  The format of the timestamp is the same as that of the\n        return value of time.time() and of the st_mtime member of the\n",
                    "rendered": {
                      "text": "        The mtime argument is an optional numeric timestamp to be written\n        to the stream when compressing.  All gzip compressed streams\n        are required to contain a timestamp.  If omitted or None, the\n        current time is used.  This module ignores the timestamp when\n        decompressing; however, some programs, such as gunzip, make use\n        of it.  The format of the timestamp is the same as that of the\n        return value of time.time() and of the st_mtime member of the\n",
                      "markdown": "`        The mtime argument is an optional numeric timestamp to be written\n        to the stream when compressing.  All gzip compressed streams\n        are required to contain a timestamp.  If omitted or None, the\n        current time is used.  This module ignores the timestamp when\n        decompressing; however, some programs, such as gunzip, make use\n        of it.  The format of the timestamp is the same as that of the\n        return value of time.time() and of the st_mtime member of the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/gzip.py"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 6,
                  "endLine": 23,
                  "snippet": {
                    "text": "\nimport struct\nimport sys\nimport time\nimport os\nimport zlib\nimport io\n\n",
                    "rendered": {
                      "text": "\nimport struct\nimport sys\nimport time\nimport os\nimport zlib\nimport io\n\n",
                      "markdown": "`\nimport struct\nimport sys\nimport time\nimport os\nimport zlib\nimport io\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/exceptions.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/exceptions.py"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 36,
                  "endLine": 84,
                  "endColumn": 41,
                  "snippet": {
                    "text": "    def FromResponse(cls, http_response, **kwargs):\n        try:\n            status_code = int(http_response.info.get('status'))\n            error_cls = _HTTP_ERRORS.get(status_code, cls)\n        except ValueError:\n            error_cls = cls\n        return error_cls(http_response.info, http_response.content,\n",
                    "rendered": {
                      "text": "    def FromResponse(cls, http_response, **kwargs):\n        try:\n            status_code = int(http_response.info.get('status'))\n            error_cls = _HTTP_ERRORS.get(status_code, cls)\n        except ValueError:\n            error_cls = cls\n        return error_cls(http_response.info, http_response.content,\n",
                      "markdown": "`    def FromResponse(cls, http_response, **kwargs):\n        try:\n            status_code = int(http_response.info.get('status'))\n            error_cls = _HTTP_ERRORS.get(status_code, cls)\n        except ValueError:\n            error_cls = cls\n        return error_cls(http_response.info, http_response.content,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/exceptions.py"
                },
                "region": {
                  "startLine": 83,
                  "startColumn": 48,
                  "endLine": 83,
                  "endColumn": 53,
                  "snippet": {
                    "text": "    @classmethod\n    def FromResponse(cls, http_response, **kwargs):\n        try:\n            status_code = int(http_response.info.get('status'))\n            error_cls = _HTTP_ERRORS.get(status_code, cls)\n        except ValueError:\n            error_cls = cls\n",
                    "rendered": {
                      "text": "    @classmethod\n    def FromResponse(cls, http_response, **kwargs):\n        try:\n            status_code = int(http_response.info.get('status'))\n            error_cls = _HTTP_ERRORS.get(status_code, cls)\n        except ValueError:\n            error_cls = cls\n",
                      "markdown": "`    @classmethod\n    def FromResponse(cls, http_response, **kwargs):\n        try:\n            status_code = int(http_response.info.get('status'))\n            error_cls = _HTTP_ERRORS.get(status_code, cls)\n        except ValueError:\n            error_cls = cls\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 705,
                  "startColumn": 56,
                  "endLine": 705,
                  "endColumn": 60,
                  "snippet": {
                    "text": "            # and then passes its reply to a download if one exists, and\n            # then that goes to ProcessResponse and is returned.\n            raise exceptions.NotYetImplementedError(\n                'Cannot yet use both upload and download at once')\n\n        http_request = self.PrepareHttpRequest(\n            method_config, request, global_params, upload, upload_config,\n",
                    "rendered": {
                      "text": "            # and then passes its reply to a download if one exists, and\n            # then that goes to ProcessResponse and is returned.\n            raise exceptions.NotYetImplementedError(\n                'Cannot yet use both upload and download at once')\n\n        http_request = self.PrepareHttpRequest(\n            method_config, request, global_params, upload, upload_config,\n",
                      "markdown": "`            # and then passes its reply to a download if one exists, and\n            # then that goes to ProcessResponse and is returned.\n            raise exceptions.NotYetImplementedError(\n                'Cannot yet use both upload and download at once')\n\n        http_request = self.PrepareHttpRequest(\n            method_config, request, global_params, upload, upload_config,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 612,
                  "startColumn": 31,
                  "endLine": 612,
                  "endColumn": 37,
                  "snippet": {
                    "text": "            raise exceptions.HttpError.FromResponse(\n                http_response, method_config=method_config, request=request)\n        if http_response.status_code == http_client.NO_CONTENT:\n            # TODO(craigcitro): Find out why _replace doesn't seem to work\n            # here.\n            http_response = http_wrapper.Response(\n                info=http_response.info, content='{}',\n",
                    "rendered": {
                      "text": "            raise exceptions.HttpError.FromResponse(\n                http_response, method_config=method_config, request=request)\n        if http_response.status_code == http_client.NO_CONTENT:\n            # TODO(craigcitro): Find out why _replace doesn't seem to work\n            # here.\n            http_response = http_wrapper.Response(\n                info=http_response.info, content='{}',\n",
                      "markdown": "`            raise exceptions.HttpError.FromResponse(\n                http_response, method_config=method_config, request=request)\n        if http_response.status_code == http_client.NO_CONTENT:\n            # TODO(craigcitro): Find out why _replace doesn't seem to work\n            # here.\n            http_response = http_wrapper.Response(\n                info=http_response.info, content='{}',\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 486,
                  "startColumn": 18,
                  "endLine": 486,
                  "endColumn": 27,
                  "snippet": {
                    "text": "        return self.__client\n\n    def GetMethodConfig(self, method):\n        \"\"\"Returns service cached method config for given method.\"\"\"\n        method_config = self._method_configs.get(method)\n        if method_config:\n            return method_config\n",
                    "rendered": {
                      "text": "        return self.__client\n\n    def GetMethodConfig(self, method):\n        \"\"\"Returns service cached method config for given method.\"\"\"\n        method_config = self._method_configs.get(method)\n        if method_config:\n            return method_config\n",
                      "markdown": "`        return self.__client\n\n    def GetMethodConfig(self, method):\n        \"\"\"Returns service cached method config for given method.\"\"\"\n        method_config = self._method_configs.get(method)\n        if method_config:\n            return method_config\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 6,
                  "endLine": 20,
                  "snippet": {
                    "text": "\n\"\"\"Base class for api services.\"\"\"\n\nimport base64\nimport contextlib\nimport datetime\nimport logging\nimport pprint\n",
                    "rendered": {
                      "text": "\n\"\"\"Base class for api services.\"\"\"\n\nimport base64\nimport contextlib\nimport datetime\nimport logging\nimport pprint\n",
                      "markdown": "`\n\"\"\"Base class for api services.\"\"\"\n\nimport base64\nimport contextlib\nimport datetime\nimport logging\nimport pprint\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 544,
                  "startColumn": 19,
                  "endLine": 544,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    def __FinalUrlValue(self, value, field):\n        \"\"\"Encode value for the URL, using field to skip encoding for bytes.\"\"\"\n        if isinstance(field, messages.BytesField) and value is not None:\n            return base64.urlsafe_b64encode(value)\n        elif isinstance(value, six.text_type):\n            return value.encode('utf8')\n        elif isinstance(value, six.binary_type):\n",
                    "rendered": {
                      "text": "    def __FinalUrlValue(self, value, field):\n        \"\"\"Encode value for the URL, using field to skip encoding for bytes.\"\"\"\n        if isinstance(field, messages.BytesField) and value is not None:\n            return base64.urlsafe_b64encode(value)\n        elif isinstance(value, six.text_type):\n            return value.encode('utf8')\n        elif isinstance(value, six.binary_type):\n",
                      "markdown": "`    def __FinalUrlValue(self, value, field):\n        \"\"\"Encode value for the URL, using field to skip encoding for bytes.\"\"\"\n        if isinstance(field, messages.BytesField) and value is not None:\n            return base64.urlsafe_b64encode(value)\n        elif isinstance(value, six.text_type):\n            return value.encode('utf8')\n        elif isinstance(value, six.binary_type):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 7,
                  "endLine": 19,
                  "endColumn": 13,
                  "snippet": {
                    "text": "\n\"\"\"Base class for api services.\"\"\"\n\nimport base64\nimport contextlib\nimport datetime\nimport logging\n",
                    "rendered": {
                      "text": "\n\"\"\"Base class for api services.\"\"\"\n\nimport base64\nimport contextlib\nimport datetime\nimport logging\n",
                      "markdown": "`\n\"\"\"Base class for api services.\"\"\"\n\nimport base64\nimport contextlib\nimport datetime\nimport logging\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 672,
                  "startColumn": 35,
                  "endLine": 672,
                  "endColumn": 44,
                  "snippet": {
                    "text": "        util.Typecheck(request, request_type)\n        request = self.__client.ProcessRequest(method_config, request)\n\n        http_request = http_wrapper.Request(\n            http_method=method_config.http_method)\n        self.__SetBaseHeaders(http_request, self.__client)\n        self.__SetBody(http_request, method_config, request, upload)\n",
                    "rendered": {
                      "text": "        util.Typecheck(request, request_type)\n        request = self.__client.ProcessRequest(method_config, request)\n\n        http_request = http_wrapper.Request(\n            http_method=method_config.http_method)\n        self.__SetBaseHeaders(http_request, self.__client)\n        self.__SetBody(http_request, method_config, request, upload)\n",
                      "markdown": "`        util.Typecheck(request, request_type)\n        request = self.__client.ProcessRequest(method_config, request)\n\n        http_request = http_wrapper.Request(\n            http_method=method_config.http_method)\n        self.__SetBaseHeaders(http_request, self.__client)\n        self.__SetBody(http_request, method_config, request, upload)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 505,
                  "startColumn": 35,
                  "endLine": 505,
                  "endColumn": 40,
                  "snippet": {
                    "text": "                if getattr(f, 'method_config', None)]\n\n    def GetUploadConfig(self, method):\n        return self._upload_configs.get(method)\n\n    def GetRequestType(self, method):\n        method_config = self.GetMethodConfig(method)\n",
                    "rendered": {
                      "text": "                if getattr(f, 'method_config', None)]\n\n    def GetUploadConfig(self, method):\n        return self._upload_configs.get(method)\n\n    def GetRequestType(self, method):\n        method_config = self.GetMethodConfig(method)\n",
                      "markdown": "`                if getattr(f, 'method_config', None)]\n\n    def GetUploadConfig(self, method):\n        return self._upload_configs.get(method)\n\n    def GetRequestType(self, method):\n        method_config = self.GetMethodConfig(method)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 487,
                  "startColumn": 44,
                  "endLine": 487,
                  "endColumn": 49,
                  "snippet": {
                    "text": "\n    def GetMethodConfig(self, method):\n        \"\"\"Returns service cached method config for given method.\"\"\"\n        method_config = self._method_configs.get(method)\n        if method_config:\n            return method_config\n        func = getattr(self, method, None)\n",
                    "rendered": {
                      "text": "\n    def GetMethodConfig(self, method):\n        \"\"\"Returns service cached method config for given method.\"\"\"\n        method_config = self._method_configs.get(method)\n        if method_config:\n            return method_config\n        func = getattr(self, method, None)\n",
                      "markdown": "`\n    def GetMethodConfig(self, method):\n        \"\"\"Returns service cached method config for given method.\"\"\"\n        method_config = self._method_configs.get(method)\n        if method_config:\n            return method_config\n        func = getattr(self, method, None)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/protojson.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/protojson.py"
                },
                "region": {
                  "startLine": 238,
                  "startColumn": 13,
                  "endLine": 238,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        elif isinstance(value, six.string_types):\n            return messages.Variant.STRING\n        elif isinstance(value, (list, tuple)):\n            # Find the most specific variant that covers all elements.\n            variant_priority = [None,\n                                messages.Variant.INT64,\n                                messages.Variant.DOUBLE,\n",
                    "rendered": {
                      "text": "        elif isinstance(value, six.string_types):\n            return messages.Variant.STRING\n        elif isinstance(value, (list, tuple)):\n            # Find the most specific variant that covers all elements.\n            variant_priority = [None,\n                                messages.Variant.INT64,\n                                messages.Variant.DOUBLE,\n",
                      "markdown": "`        elif isinstance(value, six.string_types):\n            return messages.Variant.STRING\n        elif isinstance(value, (list, tuple)):\n            # Find the most specific variant that covers all elements.\n            variant_priority = [None,\n                                messages.Variant.INT64,\n                                messages.Variant.DOUBLE,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/protojson.py"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 6,
                  "endLine": 28,
                  "snippet": {
                    "text": "  encode_message: Encodes a message in to a JSON string.\n  decode_message: Merge from a JSON string in to a message.\n\"\"\"\nimport base64\nimport binascii\nimport logging\n\nimport six\n",
                    "rendered": {
                      "text": "  encode_message: Encodes a message in to a JSON string.\n  decode_message: Merge from a JSON string in to a message.\n\"\"\"\nimport base64\nimport binascii\nimport logging\n\nimport six\n",
                      "markdown": "`  encode_message: Encodes a message in to a JSON string.\n  decode_message: Merge from a JSON string in to a message.\n\"\"\"\nimport base64\nimport binascii\nimport logging\n\nimport six\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/protojson.py"
                },
                "region": {
                  "startLine": 345,
                  "startColumn": 44,
                  "endLine": 345,
                  "endColumn": 50,
                  "snippet": {
                    "text": "            try:\n                return base64.b64decode(value)\n            except (binascii.Error, TypeError) as err:\n                raise messages.DecodeError('Base64 decoding error: %s' % err)\n\n        elif isinstance(field, message_types.DateTimeField):\n            try:\n",
                    "rendered": {
                      "text": "            try:\n                return base64.b64decode(value)\n            except (binascii.Error, TypeError) as err:\n                raise messages.DecodeError('Base64 decoding error: %s' % err)\n\n        elif isinstance(field, message_types.DateTimeField):\n            try:\n",
                      "markdown": "`            try:\n                return base64.b64decode(value)\n            except (binascii.Error, TypeError) as err:\n                raise messages.DecodeError('Base64 decoding error: %s' % err)\n\n        elif isinstance(field, message_types.DateTimeField):\n            try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/protojson.py"
                },
                "region": {
                  "startLine": 343,
                  "startColumn": 23,
                  "endLine": 343,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n        elif isinstance(field, messages.BytesField):\n            try:\n                return base64.b64decode(value)\n            except (binascii.Error, TypeError) as err:\n                raise messages.DecodeError('Base64 decoding error: %s' % err)\n\n",
                    "rendered": {
                      "text": "\n        elif isinstance(field, messages.BytesField):\n            try:\n                return base64.b64decode(value)\n            except (binascii.Error, TypeError) as err:\n                raise messages.DecodeError('Base64 decoding error: %s' % err)\n\n",
                      "markdown": "`\n        elif isinstance(field, messages.BytesField):\n            try:\n                return base64.b64decode(value)\n            except (binascii.Error, TypeError) as err:\n                raise messages.DecodeError('Base64 decoding error: %s' % err)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/protojson.py"
                },
                "region": {
                  "startLine": 169,
                  "startColumn": 24,
                  "endLine": 169,
                  "endColumn": 30,
                  "snippet": {
                    "text": "            if field.repeated:\n                value = [base64.b64encode(byte) for byte in value]\n            else:\n                value = base64.b64encode(value)\n        elif isinstance(field, message_types.DateTimeField):\n            # DateTimeField stores its data as a RFC 3339 compliant string.\n            if field.repeated:\n",
                    "rendered": {
                      "text": "            if field.repeated:\n                value = [base64.b64encode(byte) for byte in value]\n            else:\n                value = base64.b64encode(value)\n        elif isinstance(field, message_types.DateTimeField):\n            # DateTimeField stores its data as a RFC 3339 compliant string.\n            if field.repeated:\n",
                      "markdown": "`            if field.repeated:\n                value = [base64.b64encode(byte) for byte in value]\n            else:\n                value = base64.b64encode(value)\n        elif isinstance(field, message_types.DateTimeField):\n            # DateTimeField stores its data as a RFC 3339 compliant string.\n            if field.repeated:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/protojson.py"
                },
                "region": {
                  "startLine": 167,
                  "startColumn": 25,
                  "endLine": 167,
                  "endColumn": 31,
                  "snippet": {
                    "text": "        \"\"\"\n        if isinstance(field, messages.BytesField):\n            if field.repeated:\n                value = [base64.b64encode(byte) for byte in value]\n            else:\n                value = base64.b64encode(value)\n        elif isinstance(field, message_types.DateTimeField):\n",
                    "rendered": {
                      "text": "        \"\"\"\n        if isinstance(field, messages.BytesField):\n            if field.repeated:\n                value = [base64.b64encode(byte) for byte in value]\n            else:\n                value = base64.b64encode(value)\n        elif isinstance(field, message_types.DateTimeField):\n",
                      "markdown": "`        \"\"\"\n        if isinstance(field, messages.BytesField):\n            if field.repeated:\n                value = [base64.b64encode(byte) for byte in value]\n            else:\n                value = base64.b64encode(value)\n        elif isinstance(field, message_types.DateTimeField):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/protojson.py"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 7,
                  "endLine": 27,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  encode_message: Encodes a message in to a JSON string.\n  decode_message: Merge from a JSON string in to a message.\n\"\"\"\nimport base64\nimport binascii\nimport logging\n\n",
                    "rendered": {
                      "text": "  encode_message: Encodes a message in to a JSON string.\n  decode_message: Merge from a JSON string in to a message.\n\"\"\"\nimport base64\nimport binascii\nimport logging\n\n",
                      "markdown": "`  encode_message: Encodes a message in to a JSON string.\n  decode_message: Merge from a JSON string in to a message.\n\"\"\"\nimport base64\nimport binascii\nimport logging\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/__init__.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 435,
                  "startColumn": 41,
                  "endLine": 435,
                  "endColumn": 45,
                  "snippet": {
                    "text": "                last_exception = e\n    if discovery_doc is None:\n        raise CommunicationError(\n            'Could not find discovery doc at any of %s: %s' % (\n                discovery_urls, last_exception))\n",
                    "rendered": {
                      "text": "                last_exception = e\n    if discovery_doc is None:\n        raise CommunicationError(\n            'Could not find discovery doc at any of %s: %s' % (\n                discovery_urls, last_exception))\n",
                      "markdown": "`                last_exception = e\n    if discovery_doc is None:\n        raise CommunicationError(\n            'Could not find discovery doc at any of %s: %s' % (\n                discovery_urls, last_exception))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 416,
                  "startColumn": 35,
                  "endLine": 416,
                  "endColumn": 39,
                  "snippet": {
                    "text": "\n\ndef FetchDiscoveryDoc(discovery_url, retries=5):\n    \"\"\"Fetch the discovery document at the given url.\"\"\"\n    discovery_urls = _NormalizeDiscoveryUrls(discovery_url)\n    discovery_doc = None\n    last_exception = None\n",
                    "rendered": {
                      "text": "\n\ndef FetchDiscoveryDoc(discovery_url, retries=5):\n    \"\"\"Fetch the discovery document at the given url.\"\"\"\n    discovery_urls = _NormalizeDiscoveryUrls(discovery_url)\n    discovery_doc = None\n    last_exception = None\n",
                      "markdown": "`\n\ndef FetchDiscoveryDoc(discovery_url, retries=5):\n    \"\"\"Fetch the discovery document at the given url.\"\"\"\n    discovery_urls = _NormalizeDiscoveryUrls(discovery_url)\n    discovery_doc = None\n    last_exception = None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 435,
                  "startColumn": 22,
                  "endLine": 435,
                  "endColumn": 28,
                  "snippet": {
                    "text": "                last_exception = e\n    if discovery_doc is None:\n        raise CommunicationError(\n            'Could not find discovery doc at any of %s: %s' % (\n                discovery_urls, last_exception))\n",
                    "rendered": {
                      "text": "                last_exception = e\n    if discovery_doc is None:\n        raise CommunicationError(\n            'Could not find discovery doc at any of %s: %s' % (\n                discovery_urls, last_exception))\n",
                      "markdown": "`                last_exception = e\n    if discovery_doc is None:\n        raise CommunicationError(\n            'Could not find discovery doc at any of %s: %s' % (\n                discovery_urls, last_exception))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 292,
                  "startColumn": 32,
                  "endLine": 293,
                  "snippet": {
                    "text": "        '\\u201c': '\"',  # LEFT DOUBLE QUOTATION MARK\n        '\\u201d': '\"',  # RIGHT DOUBLE QUOTATION MARK\n        '\\u2026': '...',  # HORIZONTAL ELLIPSIS\n        '\\u2e3a': '-',  # TWO-EM DASH\n    }\n\n    def _ReplaceOne(c):\n        \"\"\"Returns the homoglyph or escaped replacement for c.\"\"\"\n",
                    "rendered": {
                      "text": "        '\\u201c': '\"',  # LEFT DOUBLE QUOTATION MARK\n        '\\u201d': '\"',  # RIGHT DOUBLE QUOTATION MARK\n        '\\u2026': '...',  # HORIZONTAL ELLIPSIS\n        '\\u2e3a': '-',  # TWO-EM DASH\n    }\n\n    def _ReplaceOne(c):\n        \"\"\"Returns the homoglyph or escaped replacement for c.\"\"\"\n",
                      "markdown": "`        '\\u201c': '\"',  # LEFT DOUBLE QUOTATION MARK\n        '\\u201d': '\"',  # RIGHT DOUBLE QUOTATION MARK\n        '\\u2026': '...',  # HORIZONTAL ELLIPSIS\n        '\\u2e3a': '-',  # TWO-EM DASH\n    }\n\n    def _ReplaceOne(c):\n        \"\"\"Returns the homoglyph or escaped replacement for c.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 286,
                  "startColumn": 28,
                  "endLine": 287,
                  "snippet": {
                    "text": "        '\\u00a0': ' ',  # &nbsp; ?\n        '\\u00a9': '(C)',  # COPYRIGHT SIGN (would you believe \"asciiglyph\"?)\n        '\\u00ae': '(R)',  # REGISTERED SIGN (would you believe \"asciiglyph\"?)\n        '\\u2014': '-',  # EM DASH\n        '\\u2018': \"'\",  # LEFT SINGLE QUOTATION MARK\n        '\\u2019': \"'\",  # RIGHT SINGLE QUOTATION MARK\n        '\\u201c': '\"',  # LEFT DOUBLE QUOTATION MARK\n        '\\u201d': '\"',  # RIGHT DOUBLE QUOTATION MARK\n",
                    "rendered": {
                      "text": "        '\\u00a0': ' ',  # &nbsp; ?\n        '\\u00a9': '(C)',  # COPYRIGHT SIGN (would you believe \"asciiglyph\"?)\n        '\\u00ae': '(R)',  # REGISTERED SIGN (would you believe \"asciiglyph\"?)\n        '\\u2014': '-',  # EM DASH\n        '\\u2018': \"'\",  # LEFT SINGLE QUOTATION MARK\n        '\\u2019': \"'\",  # RIGHT SINGLE QUOTATION MARK\n        '\\u201c': '\"',  # LEFT DOUBLE QUOTATION MARK\n        '\\u201d': '\"',  # RIGHT DOUBLE QUOTATION MARK\n",
                      "markdown": "`        '\\u00a0': ' ',  # &nbsp; ?\n        '\\u00a9': '(C)',  # COPYRIGHT SIGN (would you believe \"asciiglyph\"?)\n        '\\u00ae': '(R)',  # REGISTERED SIGN (would you believe \"asciiglyph\"?)\n        '\\u2014': '-',  # EM DASH\n        '\\u2018': \"'\",  # LEFT SINGLE QUOTATION MARK\n        '\\u2019': \"'\",  # RIGHT SINGLE QUOTATION MARK\n        '\\u201c': '\"',  # LEFT DOUBLE QUOTATION MARK\n        '\\u201d': '\"',  # RIGHT DOUBLE QUOTATION MARK\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 189,
                  "startColumn": 41,
                  "endLine": 189,
                  "endColumn": 50,
                  "snippet": {
                    "text": "    Returns:\n      base url: string, base url of the service,\n        'https://www.googleapis.com/storage/v1/' for the storage service.\n      base path: string, common prefix of service endpoints after the base url.\n    \"\"\"\n    full_path = urllib_parse.urljoin(root_url, service_path)\n    api_path_component = '/'.join((package, version, ''))\n",
                    "rendered": {
                      "text": "    Returns:\n      base url: string, base url of the service,\n        'https://www.googleapis.com/storage/v1/' for the storage service.\n      base path: string, common prefix of service endpoints after the base url.\n    \"\"\"\n    full_path = urllib_parse.urljoin(root_url, service_path)\n    api_path_component = '/'.join((package, version, ''))\n",
                      "markdown": "`    Returns:\n      base url: string, base url of the service,\n        'https://www.googleapis.com/storage/v1/' for the storage service.\n      base path: string, common prefix of service endpoints after the base url.\n    \"\"\"\n    full_path = urllib_parse.urljoin(root_url, service_path)\n    api_path_component = '/'.join((package, version, ''))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 184,
                  "startColumn": 31,
                  "endLine": 184,
                  "endColumn": 40,
                  "snippet": {
                    "text": "      package: name field of the discovery, i.e. 'storage' for storage service.\n      version: version of the service, i.e. 'v1'.\n      root_url: root url of the service, i.e. 'https://www.googleapis.com/'.\n      service_path: path of the service under the rool url, i.e. 'storage/v1/'.\n\n    Returns:\n      base url: string, base url of the service,\n",
                    "rendered": {
                      "text": "      package: name field of the discovery, i.e. 'storage' for storage service.\n      version: version of the service, i.e. 'v1'.\n      root_url: root url of the service, i.e. 'https://www.googleapis.com/'.\n      service_path: path of the service under the rool url, i.e. 'storage/v1/'.\n\n    Returns:\n      base url: string, base url of the service,\n",
                      "markdown": "`      package: name field of the discovery, i.e. 'storage' for storage service.\n      version: version of the service, i.e. 'v1'.\n      root_url: root url of the service, i.e. 'https://www.googleapis.com/'.\n      service_path: path of the service under the rool url, i.e. 'storage/v1/'.\n\n    Returns:\n      base url: string, base url of the service,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 161,
                  "startColumn": 33,
                  "endLine": 161,
                  "endColumn": 39,
                  "snippet": {
                    "text": "def Chdir(dirname, create=True):\n    if not os.path.exists(dirname):\n        if not create:\n            raise OSError('Cannot find directory %s' % dirname)\n        else:\n            os.mkdir(dirname)\n    previous_directory = os.getcwd()\n",
                    "rendered": {
                      "text": "def Chdir(dirname, create=True):\n    if not os.path.exists(dirname):\n        if not create:\n            raise OSError('Cannot find directory %s' % dirname)\n        else:\n            os.mkdir(dirname)\n    previous_directory = os.getcwd()\n",
                      "markdown": "`def Chdir(dirname, create=True):\n    if not os.path.exists(dirname):\n        if not create:\n            raise OSError('Cannot find directory %s' % dirname)\n        else:\n            os.mkdir(dirname)\n    previous_directory = os.getcwd()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 147,
                  "startColumn": 16,
                  "endLine": 147,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    def FieldName(self, name):\n        \"\"\"Generate a valid field name from name.\"\"\"\n        # TODO(craigcitro): We shouldn't need to strip this name, but some\n        # of the service names here are excessive. Fix the API and then\n        # remove this.\n        name = self.__StripName(name)\n        if self.__name_convention == 'LOWER_CAMEL':\n",
                    "rendered": {
                      "text": "    def FieldName(self, name):\n        \"\"\"Generate a valid field name from name.\"\"\"\n        # TODO(craigcitro): We shouldn't need to strip this name, but some\n        # of the service names here are excessive. Fix the API and then\n        # remove this.\n        name = self.__StripName(name)\n        if self.__name_convention == 'LOWER_CAMEL':\n",
                      "markdown": "`    def FieldName(self, name):\n        \"\"\"Generate a valid field name from name.\"\"\"\n        # TODO(craigcitro): We shouldn't need to strip this name, but some\n        # of the service names here are excessive. Fix the API and then\n        # remove this.\n        name = self.__StripName(name)\n        if self.__name_convention == 'LOWER_CAMEL':\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 407,
                  "startColumn": 30,
                  "endLine": 407,
                  "endColumn": 35,
                  "snippet": {
                    "text": "def _GetURLContent(url):\n    \"\"\"Download and return the content of URL.\"\"\"\n    response = urllib_request.urlopen(url)\n    encoding = response.info().get('Content-Encoding')\n    if encoding == 'gzip':\n        content = _Gunzip(response.read())\n    else:\n",
                    "rendered": {
                      "text": "def _GetURLContent(url):\n    \"\"\"Download and return the content of URL.\"\"\"\n    response = urllib_request.urlopen(url)\n    encoding = response.info().get('Content-Encoding')\n    if encoding == 'gzip':\n        content = _Gunzip(response.read())\n    else:\n",
                      "markdown": "`def _GetURLContent(url):\n    \"\"\"Download and return the content of URL.\"\"\"\n    response = urllib_request.urlopen(url)\n    encoding = response.info().get('Content-Encoding')\n    if encoding == 'gzip':\n        content = _Gunzip(response.read())\n    else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 297,
                  "startColumn": 26,
                  "endLine": 297,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n    def _ReplaceOne(c):\n        \"\"\"Returns the homoglyph or escaped replacement for c.\"\"\"\n        equiv = homoglyphs.get(c)\n        if equiv is not None:\n            return equiv\n        try:\n",
                    "rendered": {
                      "text": "\n    def _ReplaceOne(c):\n        \"\"\"Returns the homoglyph or escaped replacement for c.\"\"\"\n        equiv = homoglyphs.get(c)\n        if equiv is not None:\n            return equiv\n        try:\n",
                      "markdown": "`\n    def _ReplaceOne(c):\n        \"\"\"Returns the homoglyph or escaped replacement for c.\"\"\"\n        equiv = homoglyphs.get(c)\n        if equiv is not None:\n            return equiv\n        try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 219,
                  "startColumn": 37,
                  "endLine": 219,
                  "endColumn": 42,
                  "snippet": {
                    "text": "                                            discovery_doc['rootUrl'],\n                                            discovery_doc['servicePath'])\n\n        mtls_root_url = discovery_doc.get('mtlsRootUrl', '')\n        mtls_base_url = ''\n        if mtls_root_url:\n            mtls_base_url, _ = _ComputePaths(package, url_version,\n",
                    "rendered": {
                      "text": "                                            discovery_doc['rootUrl'],\n                                            discovery_doc['servicePath'])\n\n        mtls_root_url = discovery_doc.get('mtlsRootUrl', '')\n        mtls_base_url = ''\n        if mtls_root_url:\n            mtls_base_url, _ = _ComputePaths(package, url_version,\n",
                      "markdown": "`                                            discovery_doc['rootUrl'],\n                                            discovery_doc['servicePath'])\n\n        mtls_root_url = discovery_doc.get('mtlsRootUrl', '')\n        mtls_base_url = ''\n        if mtls_root_url:\n            mtls_base_url, _ = _ComputePaths(package, url_version,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 211,
                  "startColumn": 59,
                  "endLine": 211,
                  "endColumn": 64,
                  "snippet": {
                    "text": "               scope_ls, client_id, client_secret, user_agent, names, api_key):\n        \"\"\"Create a new ClientInfo object from a discovery document.\"\"\"\n        scopes = set(\n            discovery_doc.get('auth', {}).get('oauth2', {}).get('scopes', {}))\n        scopes.update(scope_ls)\n        package = discovery_doc['name']\n        url_version = discovery_doc['version']\n",
                    "rendered": {
                      "text": "               scope_ls, client_id, client_secret, user_agent, names, api_key):\n        \"\"\"Create a new ClientInfo object from a discovery document.\"\"\"\n        scopes = set(\n            discovery_doc.get('auth', {}).get('oauth2', {}).get('scopes', {}))\n        scopes.update(scope_ls)\n        package = discovery_doc['name']\n        url_version = discovery_doc['version']\n",
                      "markdown": "`               scope_ls, client_id, client_secret, user_agent, names, api_key):\n        \"\"\"Create a new ClientInfo object from a discovery document.\"\"\"\n        scopes = set(\n            discovery_doc.get('auth', {}).get('oauth2', {}).get('scopes', {}))\n        scopes.update(scope_ls)\n        package = discovery_doc['name']\n        url_version = discovery_doc['version']\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 211,
                  "startColumn": 41,
                  "endLine": 211,
                  "endColumn": 46,
                  "snippet": {
                    "text": "               scope_ls, client_id, client_secret, user_agent, names, api_key):\n        \"\"\"Create a new ClientInfo object from a discovery document.\"\"\"\n        scopes = set(\n            discovery_doc.get('auth', {}).get('oauth2', {}).get('scopes', {}))\n        scopes.update(scope_ls)\n        package = discovery_doc['name']\n        url_version = discovery_doc['version']\n",
                    "rendered": {
                      "text": "               scope_ls, client_id, client_secret, user_agent, names, api_key):\n        \"\"\"Create a new ClientInfo object from a discovery document.\"\"\"\n        scopes = set(\n            discovery_doc.get('auth', {}).get('oauth2', {}).get('scopes', {}))\n        scopes.update(scope_ls)\n        package = discovery_doc['name']\n        url_version = discovery_doc['version']\n",
                      "markdown": "`               scope_ls, client_id, client_secret, user_agent, names, api_key):\n        \"\"\"Create a new ClientInfo object from a discovery document.\"\"\"\n        scopes = set(\n            discovery_doc.get('auth', {}).get('oauth2', {}).get('scopes', {}))\n        scopes.update(scope_ls)\n        package = discovery_doc['name']\n        url_version = discovery_doc['version']\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 211,
                  "startColumn": 25,
                  "endLine": 211,
                  "endColumn": 30,
                  "snippet": {
                    "text": "               scope_ls, client_id, client_secret, user_agent, names, api_key):\n        \"\"\"Create a new ClientInfo object from a discovery document.\"\"\"\n        scopes = set(\n            discovery_doc.get('auth', {}).get('oauth2', {}).get('scopes', {}))\n        scopes.update(scope_ls)\n        package = discovery_doc['name']\n        url_version = discovery_doc['version']\n",
                    "rendered": {
                      "text": "               scope_ls, client_id, client_secret, user_agent, names, api_key):\n        \"\"\"Create a new ClientInfo object from a discovery document.\"\"\"\n        scopes = set(\n            discovery_doc.get('auth', {}).get('oauth2', {}).get('scopes', {}))\n        scopes.update(scope_ls)\n        package = discovery_doc['name']\n        url_version = discovery_doc['version']\n",
                      "markdown": "`               scope_ls, client_id, client_secret, user_agent, names, api_key):\n        \"\"\"Create a new ClientInfo object from a discovery document.\"\"\"\n        scopes = set(\n            discovery_doc.get('auth', {}).get('oauth2', {}).get('scopes', {}))\n        scopes.update(scope_ls)\n        package = discovery_doc['name']\n        url_version = discovery_doc['version']\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 441,
                  "startColumn": 36,
                  "endLine": 441,
                  "endColumn": 40,
                  "snippet": {
                    "text": "            body_field_name = self.__names.FieldName(\n                '%s_resource' % body_field_name)\n        # It's exceedingly unlikely that we'd get two name collisions, which\n        # means it's bound to happen at some point.\n        while body_field_name in method_description.get('parameters', {}):\n            body_field_name = self.__names.FieldName(\n                '%s_body' % body_field_name)\n",
                    "rendered": {
                      "text": "            body_field_name = self.__names.FieldName(\n                '%s_resource' % body_field_name)\n        # It's exceedingly unlikely that we'd get two name collisions, which\n        # means it's bound to happen at some point.\n        while body_field_name in method_description.get('parameters', {}):\n            body_field_name = self.__names.FieldName(\n                '%s_body' % body_field_name)\n",
                      "markdown": "`            body_field_name = self.__names.FieldName(\n                '%s_resource' % body_field_name)\n        # It's exceedingly unlikely that we'd get two name collisions, which\n        # means it's bound to happen at some point.\n        while body_field_name in method_description.get('parameters', {}):\n            body_field_name = self.__names.FieldName(\n                '%s_body' % body_field_name)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 448,
                  "startColumn": 20,
                  "endLine": 448,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        return body_field_name\n\n    def AddServiceFromResource(self, service_name, methods):\n        \"\"\"Add a new service named service_name with the given methods.\"\"\"\n        service_name = self.__names.CleanName(service_name)\n        method_descriptions = methods.get('methods', {})\n        method_info_map = collections.OrderedDict()\n",
                    "rendered": {
                      "text": "        return body_field_name\n\n    def AddServiceFromResource(self, service_name, methods):\n        \"\"\"Add a new service named service_name with the given methods.\"\"\"\n        service_name = self.__names.CleanName(service_name)\n        method_descriptions = methods.get('methods', {})\n        method_info_map = collections.OrderedDict()\n",
                      "markdown": "`        return body_field_name\n\n    def AddServiceFromResource(self, service_name, methods):\n        \"\"\"Add a new service named service_name with the given methods.\"\"\"\n        service_name = self.__names.CleanName(service_name)\n        method_descriptions = methods.get('methods', {})\n        method_info_map = collections.OrderedDict()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 219,
                  "startColumn": 48,
                  "endLine": 219,
                  "endColumn": 57,
                  "snippet": {
                    "text": "                client_info.client_class_name)\n        with printer.Indent():\n            printer(\n                '\"\"\"Generated client library for service %s version %s.\"\"\"',\n                client_info.package, client_info.version)\n            printer()\n            printer('MESSAGES_MODULE = messages')\n",
                    "rendered": {
                      "text": "                client_info.client_class_name)\n        with printer.Indent():\n            printer(\n                '\"\"\"Generated client library for service %s version %s.\"\"\"',\n                client_info.package, client_info.version)\n            printer()\n            printer('MESSAGES_MODULE = messages')\n",
                      "markdown": "`                client_info.client_class_name)\n        with printer.Indent():\n            printer(\n                '\"\"\"Generated client library for service %s version %s.\"\"\"',\n                client_info.package, client_info.version)\n            printer()\n            printer('MESSAGES_MODULE = messages')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 167,
                  "startColumn": 25,
                  "endLine": 167,
                  "endColumn": 34,
                  "snippet": {
                    "text": "                printer(')')\n\n    def __WriteProtoServiceDeclaration(self, printer, name, method_info_map):\n        \"\"\"Write a single service declaration to a proto file.\"\"\"\n        printer()\n        printer('service %s {', self.__GetServiceClassName(name))\n        with printer.Indent():\n",
                    "rendered": {
                      "text": "                printer(')')\n\n    def __WriteProtoServiceDeclaration(self, printer, name, method_info_map):\n        \"\"\"Write a single service declaration to a proto file.\"\"\"\n        printer()\n        printer('service %s {', self.__GetServiceClassName(name))\n        with printer.Indent():\n",
                      "markdown": "`                printer(')')\n\n    def __WriteProtoServiceDeclaration(self, printer, name, method_info_map):\n        \"\"\"Write a single service declaration to a proto file.\"\"\"\n        printer()\n        printer('service %s {', self.__GetServiceClassName(name))\n        with printer.Indent():\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 62,
                  "startColumn": 34,
                  "endLine": 62,
                  "endColumn": 43,
                  "snippet": {
                    "text": "            '%sService' % self.__names.ClassName(service_name))\n\n    def __PrintDocstring(self, printer, method_info, method_name, name):\n        \"\"\"Print a docstring for a service method.\"\"\"\n        if method_info.description:\n            description = util.CleanDescription(method_info.description)\n            first_line, newline, remaining = method_info.description.partition(\n",
                    "rendered": {
                      "text": "            '%sService' % self.__names.ClassName(service_name))\n\n    def __PrintDocstring(self, printer, method_info, method_name, name):\n        \"\"\"Print a docstring for a service method.\"\"\"\n        if method_info.description:\n            description = util.CleanDescription(method_info.description)\n            first_line, newline, remaining = method_info.description.partition(\n",
                      "markdown": "`            '%sService' % self.__names.ClassName(service_name))\n\n    def __PrintDocstring(self, printer, method_info, method_name, name):\n        \"\"\"Print a docstring for a service method.\"\"\"\n        if method_info.description:\n            description = util.CleanDescription(method_info.description)\n            first_line, newline, remaining = method_info.description.partition(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 19,
                  "endLine": 35,
                  "endColumn": 28,
                  "snippet": {
                    "text": "\nclass ServiceRegistry(object):\n\n    \"\"\"Registry for service types.\"\"\"\n\n    def __init__(self, client_info, message_registry,\n                 names, root_package, base_files_package,\n",
                    "rendered": {
                      "text": "\nclass ServiceRegistry(object):\n\n    \"\"\"Registry for service types.\"\"\"\n\n    def __init__(self, client_info, message_registry,\n                 names, root_package, base_files_package,\n",
                      "markdown": "`\nclass ServiceRegistry(object):\n\n    \"\"\"Registry for service types.\"\"\"\n\n    def __init__(self, client_info, message_registry,\n                 names, root_package, base_files_package,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 480,
                  "startColumn": 33,
                  "endLine": 480,
                  "endColumn": 38,
                  "snippet": {
                    "text": "            method_info_map[method_name] = self.__ComputeMethodInfo(\n                method_description, request, response, request_field)\n\n        nested_services = methods.get('resources', {})\n        services = sorted(nested_services.items())\n        for subservice_name, submethods in services:\n            new_service_name = '%s_%s' % (service_name, subservice_name)\n",
                    "rendered": {
                      "text": "            method_info_map[method_name] = self.__ComputeMethodInfo(\n                method_description, request, response, request_field)\n\n        nested_services = methods.get('resources', {})\n        services = sorted(nested_services.items())\n        for subservice_name, submethods in services:\n            new_service_name = '%s_%s' % (service_name, subservice_name)\n",
                      "markdown": "`            method_info_map[method_name] = self.__ComputeMethodInfo(\n                method_description, request, response, request_field)\n\n        nested_services = methods.get('resources', {})\n        services = sorted(nested_services.items())\n        for subservice_name, submethods in services:\n            new_service_name = '%s_%s' % (service_name, subservice_name)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 458,
                  "startColumn": 42,
                  "endLine": 458,
                  "endColumn": 47,
                  "snippet": {
                    "text": "\n            # NOTE: According to the discovery document, if the request or\n            # response is present, it will simply contain a `$ref`.\n            body_type = method_description.get('request')\n            if body_type is None:\n                request_type = None\n            else:\n",
                    "rendered": {
                      "text": "\n            # NOTE: According to the discovery document, if the request or\n            # response is present, it will simply contain a `$ref`.\n            body_type = method_description.get('request')\n            if body_type is None:\n                request_type = None\n            else:\n",
                      "markdown": "`\n            # NOTE: According to the discovery document, if the request or\n            # response is present, it will simply contain a `$ref`.\n            body_type = method_description.get('request')\n            if body_type is None:\n                request_type = None\n            else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 450,
                  "startColumn": 37,
                  "endLine": 450,
                  "endColumn": 42,
                  "snippet": {
                    "text": "    def AddServiceFromResource(self, service_name, methods):\n        \"\"\"Add a new service named service_name with the given methods.\"\"\"\n        service_name = self.__names.CleanName(service_name)\n        method_descriptions = methods.get('methods', {})\n        method_info_map = collections.OrderedDict()\n        items = sorted(method_descriptions.items())\n        for method_name, method_description in items:\n",
                    "rendered": {
                      "text": "    def AddServiceFromResource(self, service_name, methods):\n        \"\"\"Add a new service named service_name with the given methods.\"\"\"\n        service_name = self.__names.CleanName(service_name)\n        method_descriptions = methods.get('methods', {})\n        method_info_map = collections.OrderedDict()\n        items = sorted(method_descriptions.items())\n        for method_name, method_description in items:\n",
                      "markdown": "`    def AddServiceFromResource(self, service_name, methods):\n        \"\"\"Add a new service named service_name with the given methods.\"\"\"\n        service_name = self.__names.CleanName(service_name)\n        method_descriptions = methods.get('methods', {})\n        method_info_map = collections.OrderedDict()\n        items = sorted(method_descriptions.items())\n        for method_name, method_description in items:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 442,
                  "startColumn": 51,
                  "endLine": 442,
                  "endColumn": 56,
                  "snippet": {
                    "text": "                '%s_resource' % body_field_name)\n        # It's exceedingly unlikely that we'd get two name collisions, which\n        # means it's bound to happen at some point.\n        while body_field_name in method_description.get('parameters', {}):\n            body_field_name = self.__names.FieldName(\n                '%s_body' % body_field_name)\n        return body_field_name\n",
                    "rendered": {
                      "text": "                '%s_resource' % body_field_name)\n        # It's exceedingly unlikely that we'd get two name collisions, which\n        # means it's bound to happen at some point.\n        while body_field_name in method_description.get('parameters', {}):\n            body_field_name = self.__names.FieldName(\n                '%s_body' % body_field_name)\n        return body_field_name\n",
                      "markdown": "`                '%s_resource' % body_field_name)\n        # It's exceedingly unlikely that we'd get two name collisions, which\n        # means it's bound to happen at some point.\n        while body_field_name in method_description.get('parameters', {}):\n            body_field_name = self.__names.FieldName(\n                '%s_body' % body_field_name)\n        return body_field_name\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 437,
                  "startColumn": 48,
                  "endLine": 437,
                  "endColumn": 53,
                  "snippet": {
                    "text": "    def __GetRequestField(self, method_description, body_type):\n        \"\"\"Determine the request field for this method.\"\"\"\n        body_field_name = self.__BodyFieldName(body_type)\n        if body_field_name in method_description.get('parameters', {}):\n            body_field_name = self.__names.FieldName(\n                '%s_resource' % body_field_name)\n        # It's exceedingly unlikely that we'd get two name collisions, which\n",
                    "rendered": {
                      "text": "    def __GetRequestField(self, method_description, body_type):\n        \"\"\"Determine the request field for this method.\"\"\"\n        body_field_name = self.__BodyFieldName(body_type)\n        if body_field_name in method_description.get('parameters', {}):\n            body_field_name = self.__names.FieldName(\n                '%s_resource' % body_field_name)\n        # It's exceedingly unlikely that we'd get two name collisions, which\n",
                      "markdown": "`    def __GetRequestField(self, method_description, body_type):\n        \"\"\"Determine the request field for this method.\"\"\"\n        body_field_name = self.__BodyFieldName(body_type)\n        if body_field_name in method_description.get('parameters', {}):\n            body_field_name = self.__names.FieldName(\n                '%s_resource' % body_field_name)\n        # It's exceedingly unlikely that we'd get two name collisions, which\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 432,
                  "startColumn": 47,
                  "endLine": 432,
                  "endColumn": 52,
                  "snippet": {
                    "text": "        return self.__names.FieldName(body_type['$ref'])\n\n    def __GetRequestType(self, body_type):\n        return self.__names.ClassName(body_type.get('$ref'))\n\n    def __GetRequestField(self, method_description, body_type):\n        \"\"\"Determine the request field for this method.\"\"\"\n",
                    "rendered": {
                      "text": "        return self.__names.FieldName(body_type['$ref'])\n\n    def __GetRequestType(self, body_type):\n        return self.__names.ClassName(body_type.get('$ref'))\n\n    def __GetRequestField(self, method_description, body_type):\n        \"\"\"Determine the request field for this method.\"\"\"\n",
                      "markdown": "`        return self.__names.FieldName(body_type['$ref'])\n\n    def __GetRequestType(self, body_type):\n        return self.__names.ClassName(body_type.get('$ref'))\n\n    def __GetRequestField(self, method_description, body_type):\n        \"\"\"Determine the request field for this method.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 411,
                  "startColumn": 45,
                  "endLine": 411,
                  "endColumn": 50,
                  "snippet": {
                    "text": "        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n        for param, desc in method_description.get('parameters', {}).items():\n            param = self.__names.CleanName(param)\n            location = desc['location']\n            if location == 'query':\n",
                    "rendered": {
                      "text": "        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n        for param, desc in method_description.get('parameters', {}).items():\n            param = self.__names.CleanName(param)\n            location = desc['location']\n            if location == 'query':\n",
                      "markdown": "`        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n        for param, desc in method_description.get('parameters', {}).items():\n            param = self.__names.CleanName(param)\n            location = desc['location']\n            if location == 'query':\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 410,
                  "startColumn": 51,
                  "endLine": 410,
                  "endColumn": 56,
                  "snippet": {
                    "text": "                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n        for param, desc in method_description.get('parameters', {}).items():\n            param = self.__names.CleanName(param)\n            location = desc['location']\n",
                    "rendered": {
                      "text": "                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n        for param, desc in method_description.get('parameters', {}).items():\n            param = self.__names.CleanName(param)\n            location = desc['location']\n",
                      "markdown": "`                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n        for param, desc in method_description.get('parameters', {}).items():\n            param = self.__names.CleanName(param)\n            location = desc['location']\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 408,
                  "startColumn": 58,
                  "endLine": 408,
                  "endColumn": 63,
                  "snippet": {
                    "text": "        if method_description.get('supportsMediaUpload', False):\n            method_info.upload_config = self.__ComputeUploadConfig(\n                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n        for param, desc in method_description.get('parameters', {}).items():\n",
                    "rendered": {
                      "text": "        if method_description.get('supportsMediaUpload', False):\n            method_info.upload_config = self.__ComputeUploadConfig(\n                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n        for param, desc in method_description.get('parameters', {}).items():\n",
                      "markdown": "`        if method_description.get('supportsMediaUpload', False):\n            method_info.upload_config = self.__ComputeUploadConfig(\n                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n        for param, desc in method_description.get('parameters', {}).items():\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 407,
                  "startColumn": 34,
                  "endLine": 407,
                  "endColumn": 39,
                  "snippet": {
                    "text": "                method_info.flat_path = flat_path\n        if method_description.get('supportsMediaUpload', False):\n            method_info.upload_config = self.__ComputeUploadConfig(\n                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n",
                    "rendered": {
                      "text": "                method_info.flat_path = flat_path\n        if method_description.get('supportsMediaUpload', False):\n            method_info.upload_config = self.__ComputeUploadConfig(\n                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n",
                      "markdown": "`                method_info.flat_path = flat_path\n        if method_description.get('supportsMediaUpload', False):\n            method_info.upload_config = self.__ComputeUploadConfig(\n                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 405,
                  "startColumn": 29,
                  "endLine": 405,
                  "endColumn": 34,
                  "snippet": {
                    "text": "                self.__client_info.base_path + flat_path)\n            if flat_path != relative_path:\n                method_info.flat_path = flat_path\n        if method_description.get('supportsMediaUpload', False):\n            method_info.upload_config = self.__ComputeUploadConfig(\n                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n",
                    "rendered": {
                      "text": "                self.__client_info.base_path + flat_path)\n            if flat_path != relative_path:\n                method_info.flat_path = flat_path\n        if method_description.get('supportsMediaUpload', False):\n            method_info.upload_config = self.__ComputeUploadConfig(\n                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n",
                      "markdown": "`                self.__client_info.base_path + flat_path)\n            if flat_path != relative_path:\n                method_info.flat_path = flat_path\n        if method_description.get('supportsMediaUpload', False):\n            method_info.upload_config = self.__ComputeUploadConfig(\n                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 399,
                  "startColumn": 38,
                  "endLine": 399,
                  "endColumn": 43,
                  "snippet": {
                    "text": "            response_type_name=self.__names.ClassName(response),\n            request_field=request_field,\n        )\n        flat_path = method_description.get('flatPath', None)\n        if flat_path is not None:\n            flat_path = self.__names.NormalizeRelativePath(\n                self.__client_info.base_path + flat_path)\n",
                    "rendered": {
                      "text": "            response_type_name=self.__names.ClassName(response),\n            request_field=request_field,\n        )\n        flat_path = method_description.get('flatPath', None)\n        if flat_path is not None:\n            flat_path = self.__names.NormalizeRelativePath(\n                self.__client_info.base_path + flat_path)\n",
                      "markdown": "`            response_type_name=self.__names.ClassName(response),\n            request_field=request_field,\n        )\n        flat_path = method_description.get('flatPath', None)\n        if flat_path is not None:\n            flat_path = self.__names.NormalizeRelativePath(\n                self.__client_info.base_path + flat_path)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 391,
                  "startColumn": 34,
                  "endLine": 391,
                  "endColumn": 39,
                  "snippet": {
                    "text": "            method_id=method_id,\n            http_method=method_description['httpMethod'],\n            description=util.CleanDescription(\n                method_description.get('description', '')),\n            query_params=[],\n            path_params=[],\n            ordered_params=ordered_params,\n",
                    "rendered": {
                      "text": "            method_id=method_id,\n            http_method=method_description['httpMethod'],\n            description=util.CleanDescription(\n                method_description.get('description', '')),\n            query_params=[],\n            path_params=[],\n            ordered_params=ordered_params,\n",
                      "markdown": "`            method_id=method_id,\n            http_method=method_description['httpMethod'],\n            description=util.CleanDescription(\n                method_description.get('description', '')),\n            query_params=[],\n            path_params=[],\n            ordered_params=ordered_params,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 384,
                  "startColumn": 25,
                  "endLine": 384,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        ordered_params = []\n        for param_name in method_description.get('parameterOrder', []):\n            param_info = method_description['parameters'][param_name]\n            if param_info.get('required', False):\n                ordered_params.append(param_name)\n        method_info = base_api.ApiMethodInfo(\n            relative_path=relative_path,\n",
                    "rendered": {
                      "text": "        ordered_params = []\n        for param_name in method_description.get('parameterOrder', []):\n            param_info = method_description['parameters'][param_name]\n            if param_info.get('required', False):\n                ordered_params.append(param_name)\n        method_info = base_api.ApiMethodInfo(\n            relative_path=relative_path,\n",
                      "markdown": "`        ordered_params = []\n        for param_name in method_description.get('parameterOrder', []):\n            param_info = method_description['parameters'][param_name]\n            if param_info.get('required', False):\n                ordered_params.append(param_name)\n        method_info = base_api.ApiMethodInfo(\n            relative_path=relative_path,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 382,
                  "startColumn": 44,
                  "endLine": 382,
                  "endColumn": 49,
                  "snippet": {
                    "text": "                     method_description['path'])))\n        method_id = method_description['id']\n        ordered_params = []\n        for param_name in method_description.get('parameterOrder', []):\n            param_info = method_description['parameters'][param_name]\n            if param_info.get('required', False):\n                ordered_params.append(param_name)\n",
                    "rendered": {
                      "text": "                     method_description['path'])))\n        method_id = method_description['id']\n        ordered_params = []\n        for param_name in method_description.get('parameterOrder', []):\n            param_info = method_description['parameters'][param_name]\n            if param_info.get('required', False):\n                ordered_params.append(param_name)\n",
                      "markdown": "`                     method_description['path'])))\n        method_id = method_description['id']\n        ordered_params = []\n        for param_name in method_description.get('parameterOrder', []):\n            param_info = method_description['parameters'][param_name]\n            if param_info.get('required', False):\n                ordered_params.append(param_name)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 368,
                  "startColumn": 29,
                  "endLine": 368,
                  "endColumn": 34,
                  "snippet": {
                    "text": "                logging.warning('Unexpected MIME type: %s', accept_pattern)\n        protocols = media_upload_config.get('protocols', {})\n        for protocol in ('simple', 'resumable'):\n            media = protocols.get(protocol, {})\n            for attr in ('multipart', 'path'):\n                if attr in media:\n                    setattr(config, '%s_%s' % (protocol, attr), media[attr])\n",
                    "rendered": {
                      "text": "                logging.warning('Unexpected MIME type: %s', accept_pattern)\n        protocols = media_upload_config.get('protocols', {})\n        for protocol in ('simple', 'resumable'):\n            media = protocols.get(protocol, {})\n            for attr in ('multipart', 'path'):\n                if attr in media:\n                    setattr(config, '%s_%s' % (protocol, attr), media[attr])\n",
                      "markdown": "`                logging.warning('Unexpected MIME type: %s', accept_pattern)\n        protocols = media_upload_config.get('protocols', {})\n        for protocol in ('simple', 'resumable'):\n            media = protocols.get(protocol, {})\n            for attr in ('multipart', 'path'):\n                if attr in media:\n                    setattr(config, '%s_%s' % (protocol, attr), media[attr])\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 366,
                  "startColumn": 39,
                  "endLine": 366,
                  "endColumn": 44,
                  "snippet": {
                    "text": "        for accept_pattern in config.accept:\n            if not _MIME_PATTERN_RE.match(accept_pattern):\n                logging.warning('Unexpected MIME type: %s', accept_pattern)\n        protocols = media_upload_config.get('protocols', {})\n        for protocol in ('simple', 'resumable'):\n            media = protocols.get(protocol, {})\n            for attr in ('multipart', 'path'):\n",
                    "rendered": {
                      "text": "        for accept_pattern in config.accept:\n            if not _MIME_PATTERN_RE.match(accept_pattern):\n                logging.warning('Unexpected MIME type: %s', accept_pattern)\n        protocols = media_upload_config.get('protocols', {})\n        for protocol in ('simple', 'resumable'):\n            media = protocols.get(protocol, {})\n            for attr in ('multipart', 'path'):\n",
                      "markdown": "`        for accept_pattern in config.accept:\n            if not _MIME_PATTERN_RE.match(accept_pattern):\n                logging.warning('Unexpected MIME type: %s', accept_pattern)\n        protocols = media_upload_config.get('protocols', {})\n        for protocol in ('simple', 'resumable'):\n            media = protocols.get(protocol, {})\n            for attr in ('multipart', 'path'):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 361,
                  "startColumn": 47,
                  "endLine": 361,
                  "endColumn": 52,
                  "snippet": {
                    "text": "                'No accept types found for upload configuration in '\n                'method %s, using */*', method_id)\n        config.accept.extend([\n            str(a) for a in media_upload_config.get('accept', '*/*')])\n\n        for accept_pattern in config.accept:\n            if not _MIME_PATTERN_RE.match(accept_pattern):\n",
                    "rendered": {
                      "text": "                'No accept types found for upload configuration in '\n                'method %s, using */*', method_id)\n        config.accept.extend([\n            str(a) for a in media_upload_config.get('accept', '*/*')])\n\n        for accept_pattern in config.accept:\n            if not _MIME_PATTERN_RE.match(accept_pattern):\n",
                      "markdown": "`                'No accept types found for upload configuration in '\n                'method %s, using */*', method_id)\n        config.accept.extend([\n            str(a) for a in media_upload_config.get('accept', '*/*')])\n\n        for accept_pattern in config.accept:\n            if not _MIME_PATTERN_RE.match(accept_pattern):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 345,
                  "startColumn": 29,
                  "endLine": 345,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        shift = 0\n        if unit is not None:\n            unit_dict = {'KB': 10, 'MB': 20, 'GB': 30, 'TB': 40}\n            shift = unit_dict.get(unit.upper())\n            if shift is None:\n                raise ValueError('Unknown unit %s' % unit)\n        return int(size) * (1 << shift)\n",
                    "rendered": {
                      "text": "        shift = 0\n        if unit is not None:\n            unit_dict = {'KB': 10, 'MB': 20, 'GB': 30, 'TB': 40}\n            shift = unit_dict.get(unit.upper())\n            if shift is None:\n                raise ValueError('Unknown unit %s' % unit)\n        return int(size) * (1 << shift)\n",
                      "markdown": "`        shift = 0\n        if unit is not None:\n            unit_dict = {'KB': 10, 'MB': 20, 'GB': 30, 'TB': 40}\n            shift = unit_dict.get(unit.upper())\n            if shift is None:\n                raise ValueError('Unknown unit %s' % unit)\n        return int(size) * (1 << shift)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 329,
                  "startColumn": 26,
                  "endLine": 329,
                  "endColumn": 31,
                  "snippet": {
                    "text": "        field_names = [x.name for x in message.fields]\n        parameters = method_description.get('parameters', {})\n        for param_name, param_info in parameters.items():\n            if (param_info.get('location') != 'path' or\n                    self.__names.CleanName(param_name) not in field_names):\n                break\n        else:\n",
                    "rendered": {
                      "text": "        field_names = [x.name for x in message.fields]\n        parameters = method_description.get('parameters', {})\n        for param_name, param_info in parameters.items():\n            if (param_info.get('location') != 'path' or\n                    self.__names.CleanName(param_name) not in field_names):\n                break\n        else:\n",
                      "markdown": "`        field_names = [x.name for x in message.fields]\n        parameters = method_description.get('parameters', {})\n        for param_name, param_info in parameters.items():\n            if (param_info.get('location') != 'path' or\n                    self.__names.CleanName(param_name) not in field_names):\n                break\n        else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 327,
                  "startColumn": 39,
                  "endLine": 327,
                  "endColumn": 44,
                  "snippet": {
                    "text": "        if message is None:\n            return True\n        field_names = [x.name for x in message.fields]\n        parameters = method_description.get('parameters', {})\n        for param_name, param_info in parameters.items():\n            if (param_info.get('location') != 'path' or\n                    self.__names.CleanName(param_name) not in field_names):\n",
                    "rendered": {
                      "text": "        if message is None:\n            return True\n        field_names = [x.name for x in message.fields]\n        parameters = method_description.get('parameters', {})\n        for param_name, param_info in parameters.items():\n            if (param_info.get('location') != 'path' or\n                    self.__names.CleanName(param_name) not in field_names):\n",
                      "markdown": "`        if message is None:\n            return True\n        field_names = [x.name for x in message.fields]\n        parameters = method_description.get('parameters', {})\n        for param_name, param_info in parameters.items():\n            if (param_info.get('location') != 'path' or\n                    self.__names.CleanName(param_name) not in field_names):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 320,
                  "startColumn": 38,
                  "endLine": 320,
                  "endColumn": 43,
                  "snippet": {
                    "text": "        \"\"\"Determine if this method needs a new request type created.\"\"\"\n        if not request_type:\n            return True\n        method_id = method_description.get('id', '')\n        if method_id in self.__unelidable_request_methods:\n            return True\n        message = self.__message_registry.LookupDescriptorOrDie(request_type)\n",
                    "rendered": {
                      "text": "        \"\"\"Determine if this method needs a new request type created.\"\"\"\n        if not request_type:\n            return True\n        method_id = method_description.get('id', '')\n        if method_id in self.__unelidable_request_methods:\n            return True\n        message = self.__message_registry.LookupDescriptorOrDie(request_type)\n",
                      "markdown": "`        \"\"\"Determine if this method needs a new request type created.\"\"\"\n        if not request_type:\n            return True\n        method_id = method_description.get('id', '')\n        if method_id in self.__unelidable_request_methods:\n            return True\n        message = self.__message_registry.LookupDescriptorOrDie(request_type)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 281,
                  "startColumn": 56,
                  "endLine": 281,
                  "endColumn": 61,
                  "snippet": {
                    "text": "        schema['type'] = 'object'\n        schema['properties'] = collections.OrderedDict()\n        if 'parameterOrder' not in method_description:\n            ordered_parameters = list(method_description.get('parameters', []))\n        else:\n            ordered_parameters = method_description['parameterOrder'][:]\n            for k in method_description['parameters']:\n",
                    "rendered": {
                      "text": "        schema['type'] = 'object'\n        schema['properties'] = collections.OrderedDict()\n        if 'parameterOrder' not in method_description:\n            ordered_parameters = list(method_description.get('parameters', []))\n        else:\n            ordered_parameters = method_description['parameterOrder'][:]\n            for k in method_description['parameters']:\n",
                      "markdown": "`        schema['type'] = 'object'\n        schema['properties'] = collections.OrderedDict()\n        if 'parameterOrder' not in method_description:\n            ordered_parameters = list(method_description.get('parameters', []))\n        else:\n            ordered_parameters = method_description['parameterOrder'][:]\n            for k in method_description['parameters']:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/__init__.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 153,
                  "startColumn": 36,
                  "endLine": 153,
                  "endColumn": 42,
                  "snippet": {
                    "text": "\n    Args:\n      retry_attempt: Retry attempt counter.\n      max_wait: Upper bound for wait time [seconds].\n\n    Returns:\n      Number of seconds to wait before retrying request.\n",
                    "rendered": {
                      "text": "\n    Args:\n      retry_attempt: Retry attempt counter.\n      max_wait: Upper bound for wait time [seconds].\n\n    Returns:\n      Number of seconds to wait before retrying request.\n",
                      "markdown": "`\n    Args:\n      retry_attempt: Retry attempt counter.\n      max_wait: Upper bound for wait time [seconds].\n\n    Returns:\n      Number of seconds to wait before retrying request.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 147,
                  "startColumn": 8,
                  "endLine": 147,
                  "endColumn": 14,
                  "snippet": {
                    "text": "def CalculateWaitForRetry(retry_attempt, max_wait=60):\n    \"\"\"Calculates amount of time to wait before a retry attempt.\n\n    Wait time grows exponentially with the number of attempts. A\n    random amount of jitter is added to spread out retry attempts from\n    different clients.\n\n",
                    "rendered": {
                      "text": "def CalculateWaitForRetry(retry_attempt, max_wait=60):\n    \"\"\"Calculates amount of time to wait before a retry attempt.\n\n    Wait time grows exponentially with the number of attempts. A\n    random amount of jitter is added to spread out retry attempts from\n    different clients.\n\n",
                      "markdown": "`def CalculateWaitForRetry(retry_attempt, max_wait=60):\n    \"\"\"Calculates amount of time to wait before a retry attempt.\n\n    Wait time grows exponentially with the number of attempts. A\n    random amount of jitter is added to spread out retry attempts from\n    different clients.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 27,
                  "endLine": 145,
                  "endColumn": 33,
                  "snippet": {
                    "text": "\n\ndef CalculateWaitForRetry(retry_attempt, max_wait=60):\n    \"\"\"Calculates amount of time to wait before a retry attempt.\n\n    Wait time grows exponentially with the number of attempts. A\n    random amount of jitter is added to spread out retry attempts from\n",
                    "rendered": {
                      "text": "\n\ndef CalculateWaitForRetry(retry_attempt, max_wait=60):\n    \"\"\"Calculates amount of time to wait before a retry attempt.\n\n    Wait time grows exponentially with the number of attempts. A\n    random amount of jitter is added to spread out retry attempts from\n",
                      "markdown": "`\n\ndef CalculateWaitForRetry(retry_attempt, max_wait=60):\n    \"\"\"Calculates amount of time to wait before a retry attempt.\n\n    Wait time grows exponentially with the number of attempts. A\n    random amount of jitter is added to spread out retry attempts from\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 21,
                  "endLine": 77,
                  "endColumn": 26,
                  "snippet": {
                    "text": "    except urllib_error.URLError:\n        return False\n    return (o.getcode() == http_client.OK and\n            o.headers.get('metadata-flavor') == 'Google')\n\n\ndef NormalizeScopes(scope_spec):\n",
                    "rendered": {
                      "text": "    except urllib_error.URLError:\n        return False\n    return (o.getcode() == http_client.OK and\n            o.headers.get('metadata-flavor') == 'Google')\n\n\ndef NormalizeScopes(scope_spec):\n",
                      "markdown": "`    except urllib_error.URLError:\n        return False\n    return (o.getcode() == http_client.OK and\n            o.headers.get('metadata-flavor') == 'Google')\n\n\ndef NormalizeScopes(scope_spec):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 26,
                  "endLine": 72,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        os.environ.get('GCE_METADATA_ROOT', 'metadata.google.internal'))\n    try:\n        o = urllib_request.build_opener(urllib_request.ProxyHandler({})).open(\n            urllib_request.Request(\n                metadata_url, headers={'Metadata-Flavor': 'Google'}))\n    except urllib_error.URLError:\n        return False\n",
                    "rendered": {
                      "text": "        os.environ.get('GCE_METADATA_ROOT', 'metadata.google.internal'))\n    try:\n        o = urllib_request.build_opener(urllib_request.ProxyHandler({})).open(\n            urllib_request.Request(\n                metadata_url, headers={'Metadata-Flavor': 'Google'}))\n    except urllib_error.URLError:\n        return False\n",
                      "markdown": "`        os.environ.get('GCE_METADATA_ROOT', 'metadata.google.internal'))\n    try:\n        o = urllib_request.build_opener(urllib_request.ProxyHandler({})).open(\n            urllib_request.Request(\n                metadata_url, headers={'Metadata-Flavor': 'Google'}))\n    except urllib_error.URLError:\n        return False\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 18,
                  "endLine": 69,
                  "endColumn": 23,
                  "snippet": {
                    "text": "      True iff we're running on a GCE instance.\n    \"\"\"\n    metadata_url = 'http://{}'.format(\n        os.environ.get('GCE_METADATA_ROOT', 'metadata.google.internal'))\n    try:\n        o = urllib_request.build_opener(urllib_request.ProxyHandler({})).open(\n            urllib_request.Request(\n",
                    "rendered": {
                      "text": "      True iff we're running on a GCE instance.\n    \"\"\"\n    metadata_url = 'http://{}'.format(\n        os.environ.get('GCE_METADATA_ROOT', 'metadata.google.internal'))\n    try:\n        o = urllib_request.build_opener(urllib_request.ProxyHandler({})).open(\n            urllib_request.Request(\n",
                      "markdown": "`      True iff we're running on a GCE instance.\n    \"\"\"\n    metadata_url = 'http://{}'.format(\n        os.environ.get('GCE_METADATA_ROOT', 'metadata.google.internal'))\n    try:\n        o = urllib_request.build_opener(urllib_request.ProxyHandler({})).open(\n            urllib_request.Request(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 32,
                  "endLine": 54,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    Returns:\n      True iff we're running on GAE.\n    \"\"\"\n    server_software = os.environ.get('SERVER_SOFTWARE', '')\n    return (server_software.startswith('Development/') or\n            server_software.startswith('Google App Engine/'))\n\n",
                    "rendered": {
                      "text": "    Returns:\n      True iff we're running on GAE.\n    \"\"\"\n    server_software = os.environ.get('SERVER_SOFTWARE', '')\n    return (server_software.startswith('Development/') or\n            server_software.startswith('Google App Engine/'))\n\n",
                      "markdown": "`    Returns:\n      True iff we're running on GAE.\n    \"\"\"\n    server_software = os.environ.get('SERVER_SOFTWARE', '')\n    return (server_software.startswith('Development/') or\n            server_software.startswith('Google App Engine/'))\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 11,
                  "endLine": 69,
                  "endColumn": 22,
                  "snippet": {
                    "text": "      True iff we're running on a GCE instance.\n    \"\"\"\n    metadata_url = 'http://{}'.format(\n        os.environ.get('GCE_METADATA_ROOT', 'metadata.google.internal'))\n    try:\n        o = urllib_request.build_opener(urllib_request.ProxyHandler({})).open(\n            urllib_request.Request(\n",
                    "rendered": {
                      "text": "      True iff we're running on a GCE instance.\n    \"\"\"\n    metadata_url = 'http://{}'.format(\n        os.environ.get('GCE_METADATA_ROOT', 'metadata.google.internal'))\n    try:\n        o = urllib_request.build_opener(urllib_request.ProxyHandler({})).open(\n            urllib_request.Request(\n",
                      "markdown": "`      True iff we're running on a GCE instance.\n    \"\"\"\n    metadata_url = 'http://{}'.format(\n        os.environ.get('GCE_METADATA_ROOT', 'metadata.google.internal'))\n    try:\n        o = urllib_request.build_opener(urllib_request.ProxyHandler({})).open(\n            urllib_request.Request(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 25,
                  "endLine": 54,
                  "endColumn": 36,
                  "snippet": {
                    "text": "    Returns:\n      True iff we're running on GAE.\n    \"\"\"\n    server_software = os.environ.get('SERVER_SOFTWARE', '')\n    return (server_software.startswith('Development/') or\n            server_software.startswith('Google App Engine/'))\n\n",
                    "rendered": {
                      "text": "    Returns:\n      True iff we're running on GAE.\n    \"\"\"\n    server_software = os.environ.get('SERVER_SOFTWARE', '')\n    return (server_software.startswith('Development/') or\n            server_software.startswith('Google App Engine/'))\n\n",
                      "markdown": "`    Returns:\n      True iff we're running on GAE.\n    \"\"\"\n    server_software = os.environ.get('SERVER_SOFTWARE', '')\n    return (server_software.startswith('Development/') or\n            server_software.startswith('Google App Engine/'))\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/list_pager.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/list_pager.py"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 46,
                  "endLine": 75,
                  "endColumn": 55,
                  "snippet": {
                    "text": "    \"\"\"Make a series of List requests, keeping track of page tokens.\n\n    Args:\n      service: apitools_base.BaseApiService, A service with a .List() method.\n      request: protorpc.messages.Message, The request message\n          corresponding to the service's .List() method, with all the\n          attributes populated except the .maxResults and .pageToken\n",
                    "rendered": {
                      "text": "    \"\"\"Make a series of List requests, keeping track of page tokens.\n\n    Args:\n      service: apitools_base.BaseApiService, A service with a .List() method.\n      request: protorpc.messages.Message, The request message\n          corresponding to the service's .List() method, with all the\n          attributes populated except the .maxResults and .pageToken\n",
                      "markdown": "`    \"\"\"Make a series of List requests, keeping track of page tokens.\n\n    Args:\n      service: apitools_base.BaseApiService, A service with a .List() method.\n      request: protorpc.messages.Message, The request message\n          corresponding to the service's .List() method, with all the\n          attributes populated except the .maxResults and .pageToken\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 176,
                  "startColumn": 19,
                  "endLine": 176,
                  "endColumn": 23,
                  "snippet": {
                    "text": "\n    Known **kwargs:\n      shortstrings: bool, True if all string values should be\n          truncated at 100 characters, since when mocking the contents\n          typically don't matter except for IDs, and IDs are usually\n          less than 100 characters.\n      no_modules: bool, True if the long module name should not be printed with\n",
                    "rendered": {
                      "text": "\n    Known **kwargs:\n      shortstrings: bool, True if all string values should be\n          truncated at 100 characters, since when mocking the contents\n          typically don't matter except for IDs, and IDs are usually\n          less than 100 characters.\n      no_modules: bool, True if the long module name should not be printed with\n",
                      "markdown": "`\n    Known **kwargs:\n      shortstrings: bool, True if all string values should be\n          truncated at 100 characters, since when mocking the contents\n          typically don't matter except for IDs, and IDs are usually\n          less than 100 characters.\n      no_modules: bool, True if the long module name should not be printed with\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 503,
                  "startColumn": 25,
                  "endLine": 503,
                  "endColumn": 33,
                  "snippet": {
                    "text": "\n\ndef _SafeDecodeBytes(unused_field, value):\n    \"\"\"Decode the urlsafe base64 value into bytes.\"\"\"\n    try:\n        result = base64.urlsafe_b64decode(str(value))\n        complete = True\n",
                    "rendered": {
                      "text": "\n\ndef _SafeDecodeBytes(unused_field, value):\n    \"\"\"Decode the urlsafe base64 value into bytes.\"\"\"\n    try:\n        result = base64.urlsafe_b64decode(str(value))\n        complete = True\n",
                      "markdown": "`\n\ndef _SafeDecodeBytes(unused_field, value):\n    \"\"\"Decode the urlsafe base64 value into bytes.\"\"\"\n    try:\n        result = base64.urlsafe_b64decode(str(value))\n        complete = True\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 6,
                  "endLine": 20,
                  "snippet": {
                    "text": "\n\"\"\"Common code for converting proto to other formats, such as JSON.\"\"\"\n\nimport base64\nimport collections\nimport datetime\nimport json\n\n",
                    "rendered": {
                      "text": "\n\"\"\"Common code for converting proto to other formats, such as JSON.\"\"\"\n\nimport base64\nimport collections\nimport datetime\nimport json\n\n",
                      "markdown": "`\n\"\"\"Common code for converting proto to other formats, such as JSON.\"\"\"\n\nimport base64\nimport collections\nimport datetime\nimport json\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 505,
                  "startColumn": 17,
                  "endLine": 505,
                  "endColumn": 23,
                  "snippet": {
                    "text": "def _SafeDecodeBytes(unused_field, value):\n    \"\"\"Decode the urlsafe base64 value into bytes.\"\"\"\n    try:\n        result = base64.urlsafe_b64decode(str(value))\n        complete = True\n    except TypeError:\n        result = value\n",
                    "rendered": {
                      "text": "def _SafeDecodeBytes(unused_field, value):\n    \"\"\"Decode the urlsafe base64 value into bytes.\"\"\"\n    try:\n        result = base64.urlsafe_b64decode(str(value))\n        complete = True\n    except TypeError:\n        result = value\n",
                      "markdown": "`def _SafeDecodeBytes(unused_field, value):\n    \"\"\"Decode the urlsafe base64 value into bytes.\"\"\"\n    try:\n        result = base64.urlsafe_b64decode(str(value))\n        complete = True\n    except TypeError:\n        result = value\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 503,
                  "startColumn": 26,
                  "endLine": 503,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n\ndef _SafeDecodeBytes(unused_field, value):\n    \"\"\"Decode the urlsafe base64 value into bytes.\"\"\"\n    try:\n        result = base64.urlsafe_b64decode(str(value))\n        complete = True\n",
                    "rendered": {
                      "text": "\n\ndef _SafeDecodeBytes(unused_field, value):\n    \"\"\"Decode the urlsafe base64 value into bytes.\"\"\"\n    try:\n        result = base64.urlsafe_b64decode(str(value))\n        complete = True\n",
                      "markdown": "`\n\ndef _SafeDecodeBytes(unused_field, value):\n    \"\"\"Decode the urlsafe base64 value into bytes.\"\"\"\n    try:\n        result = base64.urlsafe_b64decode(str(value))\n        complete = True\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 494,
                  "startColumn": 21,
                  "endLine": 494,
                  "endColumn": 27,
                  "snippet": {
                    "text": "        if field.repeated:\n            result = [base64.urlsafe_b64encode(byte) for byte in value]\n        else:\n            result = base64.urlsafe_b64encode(value)\n        complete = True\n    except TypeError:\n        result = value\n",
                    "rendered": {
                      "text": "        if field.repeated:\n            result = [base64.urlsafe_b64encode(byte) for byte in value]\n        else:\n            result = base64.urlsafe_b64encode(value)\n        complete = True\n    except TypeError:\n        result = value\n",
                      "markdown": "`        if field.repeated:\n            result = [base64.urlsafe_b64encode(byte) for byte in value]\n        else:\n            result = base64.urlsafe_b64encode(value)\n        complete = True\n    except TypeError:\n        result = value\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 492,
                  "startColumn": 22,
                  "endLine": 492,
                  "endColumn": 28,
                  "snippet": {
                    "text": "    \"\"\"Encode the bytes in value as urlsafe base64.\"\"\"\n    try:\n        if field.repeated:\n            result = [base64.urlsafe_b64encode(byte) for byte in value]\n        else:\n            result = base64.urlsafe_b64encode(value)\n        complete = True\n",
                    "rendered": {
                      "text": "    \"\"\"Encode the bytes in value as urlsafe base64.\"\"\"\n    try:\n        if field.repeated:\n            result = [base64.urlsafe_b64encode(byte) for byte in value]\n        else:\n            result = base64.urlsafe_b64encode(value)\n        complete = True\n",
                      "markdown": "`    \"\"\"Encode the bytes in value as urlsafe base64.\"\"\"\n    try:\n        if field.repeated:\n            result = [base64.urlsafe_b64encode(byte) for byte in value]\n        else:\n            result = base64.urlsafe_b64encode(value)\n        complete = True\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 489,
                  "startColumn": 44,
                  "endLine": 489,
                  "endColumn": 50,
                  "snippet": {
                    "text": "\n\ndef _SafeEncodeBytes(field, value):\n    \"\"\"Encode the bytes in value as urlsafe base64.\"\"\"\n    try:\n        if field.repeated:\n            result = [base64.urlsafe_b64encode(byte) for byte in value]\n",
                    "rendered": {
                      "text": "\n\ndef _SafeEncodeBytes(field, value):\n    \"\"\"Encode the bytes in value as urlsafe base64.\"\"\"\n    try:\n        if field.repeated:\n            result = [base64.urlsafe_b64encode(byte) for byte in value]\n",
                      "markdown": "`\n\ndef _SafeEncodeBytes(field, value):\n    \"\"\"Encode the bytes in value as urlsafe base64.\"\"\"\n    try:\n        if field.repeated:\n            result = [base64.urlsafe_b64encode(byte) for byte in value]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 7,
                  "endLine": 19,
                  "endColumn": 13,
                  "snippet": {
                    "text": "\n\"\"\"Common code for converting proto to other formats, such as JSON.\"\"\"\n\nimport base64\nimport collections\nimport datetime\nimport json\n",
                    "rendered": {
                      "text": "\n\"\"\"Common code for converting proto to other formats, such as JSON.\"\"\"\n\nimport base64\nimport collections\nimport datetime\nimport json\n",
                      "markdown": "`\n\"\"\"Common code for converting proto to other formats, such as JSON.\"\"\"\n\nimport base64\nimport collections\nimport datetime\nimport json\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000801"
          },
          "message": {
            "text": "Backdoor: Executing Obfuscated Code",
            "id": "BD000801"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 29,
                  "endLine": 123,
                  "endColumn": 42,
                  "snippet": {
                    "text": "\ndef JsonToMessage(message_type, message):\n    \"\"\"Convert the given JSON to a message of type message_type.\"\"\"\n    return _ProtoJsonApiTools.Get().decode_message(message_type, message)\n\n\n# TODO(craigcitro): Do this directly, instead of via JSON.\n",
                    "rendered": {
                      "text": "\ndef JsonToMessage(message_type, message):\n    \"\"\"Convert the given JSON to a message of type message_type.\"\"\"\n    return _ProtoJsonApiTools.Get().decode_message(message_type, message)\n\n\n# TODO(craigcitro): Do this directly, instead of via JSON.\n",
                      "markdown": "`\ndef JsonToMessage(message_type, message):\n    \"\"\"Convert the given JSON to a message of type message_type.\"\"\"\n    return _ProtoJsonApiTools.Get().decode_message(message_type, message)\n\n\n# TODO(craigcitro): Do this directly, instead of via JSON.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 701,
                  "startColumn": 43,
                  "endLine": 701,
                  "endColumn": 48,
                  "snippet": {
                    "text": "\n\ndef _DecodeCustomFieldNames(message_type, encoded_message):\n    field_remappings = _JSON_FIELD_MAPPINGS.get(message_type, {})\n    if field_remappings:\n        decoded_message = json.loads(encoded_message)\n        for python_name, json_name in list(field_remappings.items()):\n",
                    "rendered": {
                      "text": "\n\ndef _DecodeCustomFieldNames(message_type, encoded_message):\n    field_remappings = _JSON_FIELD_MAPPINGS.get(message_type, {})\n    if field_remappings:\n        decoded_message = json.loads(encoded_message)\n        for python_name, json_name in list(field_remappings.items()):\n",
                      "markdown": "`\n\ndef _DecodeCustomFieldNames(message_type, encoded_message):\n    field_remappings = _JSON_FIELD_MAPPINGS.get(message_type, {})\n    if field_remappings:\n        decoded_message = json.loads(encoded_message)\n        for python_name, json_name in list(field_remappings.items()):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 689,
                  "startColumn": 48,
                  "endLine": 689,
                  "endColumn": 53,
                  "snippet": {
                    "text": "\n\ndef _EncodeCustomFieldNames(message, encoded_value):\n    field_remappings = list(_JSON_FIELD_MAPPINGS.get(type(message), {})\n                            .items())\n    if field_remappings:\n        decoded_value = json.loads(encoded_value)\n",
                    "rendered": {
                      "text": "\n\ndef _EncodeCustomFieldNames(message, encoded_value):\n    field_remappings = list(_JSON_FIELD_MAPPINGS.get(type(message), {})\n                            .items())\n    if field_remappings:\n        decoded_value = json.loads(encoded_value)\n",
                      "markdown": "`\n\ndef _EncodeCustomFieldNames(message, encoded_value):\n    field_remappings = list(_JSON_FIELD_MAPPINGS.get(type(message), {})\n                            .items())\n    if field_remappings:\n        decoded_value = json.loads(encoded_value)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 661,
                  "startColumn": 35,
                  "endLine": 661,
                  "endColumn": 40,
                  "snippet": {
                    "text": "    field_remappings = mappings.get(type_name, {})\n    if field_remappings:\n        if python_name:\n            return field_remappings.get(python_name)\n        elif json_name:\n            if json_name in list(field_remappings.values()):\n                return [k for k in field_remappings\n",
                    "rendered": {
                      "text": "    field_remappings = mappings.get(type_name, {})\n    if field_remappings:\n        if python_name:\n            return field_remappings.get(python_name)\n        elif json_name:\n            if json_name in list(field_remappings.values()):\n                return [k for k in field_remappings\n",
                      "markdown": "`    field_remappings = mappings.get(type_name, {})\n    if field_remappings:\n        if python_name:\n            return field_remappings.get(python_name)\n        elif json_name:\n            if json_name in list(field_remappings.values()):\n                return [k for k in field_remappings\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 658,
                  "startColumn": 31,
                  "endLine": 658,
                  "endColumn": 36,
                  "snippet": {
                    "text": "        raise exceptions.InvalidDataError(\n            'Must specify either python_name or json_name for %s remapping' % (\n                mapping_type,))\n    field_remappings = mappings.get(type_name, {})\n    if field_remappings:\n        if python_name:\n            return field_remappings.get(python_name)\n",
                    "rendered": {
                      "text": "        raise exceptions.InvalidDataError(\n            'Must specify either python_name or json_name for %s remapping' % (\n                mapping_type,))\n    field_remappings = mappings.get(type_name, {})\n    if field_remappings:\n        if python_name:\n            return field_remappings.get(python_name)\n",
                      "markdown": "`        raise exceptions.InvalidDataError(\n            'Must specify either python_name or json_name for %s remapping' % (\n                mapping_type,))\n    field_remappings = mappings.get(type_name, {})\n    if field_remappings:\n        if python_name:\n            return field_remappings.get(python_name)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 480,
                  "startColumn": 30,
                  "endLine": 480,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    value_field = pairs_type.field_by_name('value')\n    value_variant = value_field.variant\n    pairs = getattr(message, source)\n    codec = _ProtoJsonApiTools.Get()\n    for pair in pairs:\n        encoded_value = codec.encode_field(value_field, pair.value)\n        result.set_unrecognized_field(pair.key, encoded_value, value_variant)\n",
                    "rendered": {
                      "text": "    value_field = pairs_type.field_by_name('value')\n    value_variant = value_field.variant\n    pairs = getattr(message, source)\n    codec = _ProtoJsonApiTools.Get()\n    for pair in pairs:\n        encoded_value = codec.encode_field(value_field, pair.value)\n        result.set_unrecognized_field(pair.key, encoded_value, value_variant)\n",
                      "markdown": "`    value_field = pairs_type.field_by_name('value')\n    value_variant = value_field.variant\n    pairs = getattr(message, source)\n    codec = _ProtoJsonApiTools.Get()\n    for pair in pairs:\n        encoded_value = codec.encode_field(value_field, pair.value)\n        result.set_unrecognized_field(pair.key, encoded_value, value_variant)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 466,
                  "startColumn": 41,
                  "endLine": 466,
                  "endColumn": 46,
                  "snippet": {
                    "text": "\ndef _EncodeUnknownFields(message):\n    \"\"\"Remap unknown fields in message out of message.source.\"\"\"\n    source = _UNRECOGNIZED_FIELD_MAPPINGS.get(type(message))\n    if source is None:\n        return message\n    # CopyProtoMessage uses _ProtoJsonApiTools, which uses this message. Use\n",
                    "rendered": {
                      "text": "\ndef _EncodeUnknownFields(message):\n    \"\"\"Remap unknown fields in message out of message.source.\"\"\"\n    source = _UNRECOGNIZED_FIELD_MAPPINGS.get(type(message))\n    if source is None:\n        return message\n    # CopyProtoMessage uses _ProtoJsonApiTools, which uses this message. Use\n",
                      "markdown": "`\ndef _EncodeUnknownFields(message):\n    \"\"\"Remap unknown fields in message out of message.source.\"\"\"\n    source = _UNRECOGNIZED_FIELD_MAPPINGS.get(type(message))\n    if source is None:\n        return message\n    # CopyProtoMessage uses _ProtoJsonApiTools, which uses this message. Use\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 436,
                  "startColumn": 30,
                  "endLine": 436,
                  "endColumn": 35,
                  "snippet": {
                    "text": "def _DecodeUnrecognizedFields(message, pair_type):\n    \"\"\"Process unrecognized fields in message.\"\"\"\n    new_values = []\n    codec = _ProtoJsonApiTools.Get()\n    for unknown_field in message.all_unrecognized_fields():\n        # TODO(craigcitro): Consider validating the variant if\n        # the assignment below doesn't take care of it. It may\n",
                    "rendered": {
                      "text": "def _DecodeUnrecognizedFields(message, pair_type):\n    \"\"\"Process unrecognized fields in message.\"\"\"\n    new_values = []\n    codec = _ProtoJsonApiTools.Get()\n    for unknown_field in message.all_unrecognized_fields():\n        # TODO(craigcitro): Consider validating the variant if\n        # the assignment below doesn't take care of it. It may\n",
                      "markdown": "`def _DecodeUnrecognizedFields(message, pair_type):\n    \"\"\"Process unrecognized fields in message.\"\"\"\n    new_values = []\n    codec = _ProtoJsonApiTools.Get()\n    for unknown_field in message.all_unrecognized_fields():\n        # TODO(craigcitro): Consider validating the variant if\n        # the assignment below doesn't take care of it. It may\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 394,
                  "startColumn": 46,
                  "endLine": 394,
                  "endColumn": 51,
                  "snippet": {
                    "text": "# TODO(craigcitro): Fold this and _IncludeFields in as codecs.\ndef _DecodeUnknownFields(message, encoded_message):\n    \"\"\"Rewrite unknown fields in message into message.destination.\"\"\"\n    destination = _UNRECOGNIZED_FIELD_MAPPINGS.get(type(message))\n    if destination is None:\n        return message\n    pair_field = message.field_by_name(destination)\n",
                    "rendered": {
                      "text": "# TODO(craigcitro): Fold this and _IncludeFields in as codecs.\ndef _DecodeUnknownFields(message, encoded_message):\n    \"\"\"Rewrite unknown fields in message into message.destination.\"\"\"\n    destination = _UNRECOGNIZED_FIELD_MAPPINGS.get(type(message))\n    if destination is None:\n        return message\n    pair_field = message.field_by_name(destination)\n",
                      "markdown": "`# TODO(craigcitro): Fold this and _IncludeFields in as codecs.\ndef _DecodeUnknownFields(message, encoded_message):\n    \"\"\"Rewrite unknown fields in message into message.destination.\"\"\"\n    destination = _UNRECOGNIZED_FIELD_MAPPINGS.get(type(message))\n    if destination is None:\n        return message\n    pair_field = message.field_by_name(destination)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 287,
                  "startColumn": 34,
                  "endLine": 287,
                  "endColumn": 39,
                  "snippet": {
                    "text": "def _GetFieldCodecs(field, attr):\n    result = [\n        getattr(_CUSTOM_FIELD_CODECS.get(field), attr, None),\n        getattr(_FIELD_TYPE_CODECS.get(type(field)), attr, None),\n    ]\n    return [x for x in result if x is not None]\n\n",
                    "rendered": {
                      "text": "def _GetFieldCodecs(field, attr):\n    result = [\n        getattr(_CUSTOM_FIELD_CODECS.get(field), attr, None),\n        getattr(_FIELD_TYPE_CODECS.get(type(field)), attr, None),\n    ]\n    return [x for x in result if x is not None]\n\n",
                      "markdown": "`def _GetFieldCodecs(field, attr):\n    result = [\n        getattr(_CUSTOM_FIELD_CODECS.get(field), attr, None),\n        getattr(_FIELD_TYPE_CODECS.get(type(field)), attr, None),\n    ]\n    return [x for x in result if x is not None]\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 286,
                  "startColumn": 36,
                  "endLine": 286,
                  "endColumn": 41,
                  "snippet": {
                    "text": "\ndef _GetFieldCodecs(field, attr):\n    result = [\n        getattr(_CUSTOM_FIELD_CODECS.get(field), attr, None),\n        getattr(_FIELD_TYPE_CODECS.get(type(field)), attr, None),\n    ]\n    return [x for x in result if x is not None]\n",
                    "rendered": {
                      "text": "\ndef _GetFieldCodecs(field, attr):\n    result = [\n        getattr(_CUSTOM_FIELD_CODECS.get(field), attr, None),\n        getattr(_FIELD_TYPE_CODECS.get(type(field)), attr, None),\n    ]\n    return [x for x in result if x is not None]\n",
                      "markdown": "`\ndef _GetFieldCodecs(field, attr):\n    result = [\n        getattr(_CUSTOM_FIELD_CODECS.get(field), attr, None),\n        getattr(_FIELD_TYPE_CODECS.get(type(field)), attr, None),\n    ]\n    return [x for x in result if x is not None]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 240,
                  "startColumn": 29,
                  "endLine": 240,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\n            def __repr__(self):\n                s = 'TimeZoneOffset(' + repr(self.offset) + ')'\n                if not kwargs.get('no_modules'):\n                    s = 'apitools.base.protorpclite.util.' + s\n                return s\n\n",
                    "rendered": {
                      "text": "\n            def __repr__(self):\n                s = 'TimeZoneOffset(' + repr(self.offset) + ')'\n                if not kwargs.get('no_modules'):\n                    s = 'apitools.base.protorpclite.util.' + s\n                return s\n\n",
                      "markdown": "`\n            def __repr__(self):\n                s = 'TimeZoneOffset(' + repr(self.offset) + ')'\n                if not kwargs.get('no_modules'):\n                    s = 'apitools.base.protorpclite.util.' + s\n                return s\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 227,
                  "startColumn": 17,
                  "endLine": 227,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        return s\n\n    if isinstance(msg, six.string_types):\n        if kwargs.get('shortstrings') and len(msg) > 100:\n            msg = msg[:100]\n\n    if isinstance(msg, datetime.datetime):\n",
                    "rendered": {
                      "text": "        return s\n\n    if isinstance(msg, six.string_types):\n        if kwargs.get('shortstrings') and len(msg) > 100:\n            msg = msg[:100]\n\n    if isinstance(msg, datetime.datetime):\n",
                      "markdown": "`        return s\n\n    if isinstance(msg, six.string_types):\n        if kwargs.get('shortstrings') and len(msg) > 100:\n            msg = msg[:100]\n\n    if isinstance(msg, datetime.datetime):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 211,
                  "startColumn": 21,
                  "endLine": 211,
                  "endColumn": 26,
                  "snippet": {
                    "text": "\n    if isinstance(msg, messages.Message):\n        s = type(msg).__name__ + '('\n        if not kwargs.get('no_modules'):\n            s = msg.__module__ + '.' + s\n        names = sorted([field.name for field in msg.all_fields()])\n        for name in names:\n",
                    "rendered": {
                      "text": "\n    if isinstance(msg, messages.Message):\n        s = type(msg).__name__ + '('\n        if not kwargs.get('no_modules'):\n            s = msg.__module__ + '.' + s\n        names = sorted([field.name for field in msg.all_fields()])\n        for name in names:\n",
                      "markdown": "`\n    if isinstance(msg, messages.Message):\n        s = type(msg).__name__ + '('\n        if not kwargs.get('no_modules'):\n            s = msg.__module__ + '.' + s\n        names = sorted([field.name for field in msg.all_fields()])\n        for name in names:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 194,
                  "startColumn": 33,
                  "endLine": 194,
                  "endColumn": 38,
                  "snippet": {
                    "text": "\n    def IndentKwargs(kwargs):\n        kwargs = dict(kwargs)\n        kwargs['indent'] = kwargs.get('indent', 0) + 4\n        return kwargs\n\n    if isinstance(msg, list):\n",
                    "rendered": {
                      "text": "\n    def IndentKwargs(kwargs):\n        kwargs = dict(kwargs)\n        kwargs['indent'] = kwargs.get('indent', 0) + 4\n        return kwargs\n\n    if isinstance(msg, list):\n",
                      "markdown": "`\n    def IndentKwargs(kwargs):\n        kwargs = dict(kwargs)\n        kwargs['indent'] = kwargs.get('indent', 0) + 4\n        return kwargs\n\n    if isinstance(msg, list):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 190,
                  "startColumn": 19,
                  "endLine": 190,
                  "endColumn": 24,
                  "snippet": {
                    "text": "\n    # TODO(jasmuth): craigcitro suggests a pretty-printer from apitools/gen.\n\n    indent = kwargs.get('indent', 0)\n\n    def IndentKwargs(kwargs):\n        kwargs = dict(kwargs)\n",
                    "rendered": {
                      "text": "\n    # TODO(jasmuth): craigcitro suggests a pretty-printer from apitools/gen.\n\n    indent = kwargs.get('indent', 0)\n\n    def IndentKwargs(kwargs):\n        kwargs = dict(kwargs)\n",
                      "markdown": "`\n    # TODO(jasmuth): craigcitro suggests a pretty-printer from apitools/gen.\n\n    indent = kwargs.get('indent', 0)\n\n    def IndentKwargs(kwargs):\n        kwargs = dict(kwargs)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 29,
                  "endLine": 123,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\ndef JsonToMessage(message_type, message):\n    \"\"\"Convert the given JSON to a message of type message_type.\"\"\"\n    return _ProtoJsonApiTools.Get().decode_message(message_type, message)\n\n\n# TODO(craigcitro): Do this directly, instead of via JSON.\n",
                    "rendered": {
                      "text": "\ndef JsonToMessage(message_type, message):\n    \"\"\"Convert the given JSON to a message of type message_type.\"\"\"\n    return _ProtoJsonApiTools.Get().decode_message(message_type, message)\n\n\n# TODO(craigcitro): Do this directly, instead of via JSON.\n",
                      "markdown": "`\ndef JsonToMessage(message_type, message):\n    \"\"\"Convert the given JSON to a message of type message_type.\"\"\"\n    return _ProtoJsonApiTools.Get().decode_message(message_type, message)\n\n\n# TODO(craigcitro): Do this directly, instead of via JSON.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 117,
                  "startColumn": 31,
                  "endLine": 117,
                  "endColumn": 36,
                  "snippet": {
                    "text": "\ndef MessageToJson(message, include_fields=None):\n    \"\"\"Convert the given message to JSON.\"\"\"\n    result = _ProtoJsonApiTools.Get().encode_message(message)\n    return _IncludeFields(result, message, include_fields)\n\n\n",
                    "rendered": {
                      "text": "\ndef MessageToJson(message, include_fields=None):\n    \"\"\"Convert the given message to JSON.\"\"\"\n    result = _ProtoJsonApiTools.Get().encode_message(message)\n    return _IncludeFields(result, message, include_fields)\n\n\n",
                      "markdown": "`\ndef MessageToJson(message, include_fields=None):\n    \"\"\"Convert the given message to JSON.\"\"\"\n    result = _ProtoJsonApiTools.Get().encode_message(message)\n    return _IncludeFields(result, message, include_fields)\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/batch.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/batch.py"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 28,
                  "endLine": 94,
                  "snippet": {
                    "text": "            self.__retryable_codes = list(\n                set(retryable_codes + [http_client.UNAUTHORIZED]))\n            self.__http_response = None\n            self.__service = service\n            self.__method_config = method_config\n\n            self.http_request = request\n            # TODO(user): Add some validation to these fields.\n",
                    "rendered": {
                      "text": "            self.__retryable_codes = list(\n                set(retryable_codes + [http_client.UNAUTHORIZED]))\n            self.__http_response = None\n            self.__service = service\n            self.__method_config = method_config\n\n            self.http_request = request\n            # TODO(user): Add some validation to these fields.\n",
                      "markdown": "`            self.__retryable_codes = list(\n                set(retryable_codes + [http_client.UNAUTHORIZED]))\n            self.__http_response = None\n            self.__service = service\n            self.__method_config = method_config\n\n            self.http_request = request\n            # TODO(user): Add some validation to these fields.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/batch.py"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 24,
                  "endLine": 86,
                  "endColumn": 33,
                  "snippet": {
                    "text": "              request: An http_wrapper.Request object.\n              retryable_codes: A list of integer HTTP codes that can\n                  be retried.\n              service: A service inheriting from base_api.BaseApiService.\n              method_config: Method config for the desired API request.\n\n            \"\"\"\n",
                    "rendered": {
                      "text": "              request: An http_wrapper.Request object.\n              retryable_codes: A list of integer HTTP codes that can\n                  be retried.\n              service: A service inheriting from base_api.BaseApiService.\n              method_config: Method config for the desired API request.\n\n            \"\"\"\n",
                      "markdown": "`              request: An http_wrapper.Request object.\n              retryable_codes: A list of integer HTTP codes that can\n                  be retried.\n              service: A service inheriting from base_api.BaseApiService.\n              method_config: Method config for the desired API request.\n\n            \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/batch.py"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 6,
                  "endLine": 26,
                  "snippet": {
                    "text": "import email.mime.nonmultipart as mime_nonmultipart\nimport email.parser as email_parser\nimport itertools\nimport time\nimport uuid\n\nimport six\nfrom six.moves import http_client\n",
                    "rendered": {
                      "text": "import email.mime.nonmultipart as mime_nonmultipart\nimport email.parser as email_parser\nimport itertools\nimport time\nimport uuid\n\nimport six\nfrom six.moves import http_client\n",
                      "markdown": "`import email.mime.nonmultipart as mime_nonmultipart\nimport email.parser as email_parser\nimport itertools\nimport time\nimport uuid\n\nimport six\nfrom six.moves import http_client\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/batch.py"
                },
                "region": {
                  "startLine": 444,
                  "startColumn": 30,
                  "endLine": 444,
                  "endColumn": 39,
                  "snippet": {
                    "text": "            msg.set_payload(body)\n            message.attach(msg)\n\n        request = http_wrapper.Request(self.__batch_url, 'POST')\n        request.body = message.as_string()\n        request.headers['content-type'] = (\n            'multipart/mixed; boundary=\"%s\"') % message.get_boundary()\n",
                    "rendered": {
                      "text": "            msg.set_payload(body)\n            message.attach(msg)\n\n        request = http_wrapper.Request(self.__batch_url, 'POST')\n        request.body = message.as_string()\n        request.headers['content-type'] = (\n            'multipart/mixed; boundary=\"%s\"') % message.get_boundary()\n",
                      "markdown": "`            msg.set_payload(body)\n            message.attach(msg)\n\n        request = http_wrapper.Request(self.__batch_url, 'POST')\n        request.body = message.as_string()\n        request.headers['content-type'] = (\n            'multipart/mixed; boundary=\"%s\"') % message.get_boundary()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/batch.py"
                },
                "region": {
                  "startLine": 339,
                  "startColumn": 38,
                  "endLine": 339,
                  "endColumn": 43,
                  "snippet": {
                    "text": "            request_line,\n            u'HTTP/1.1\\n'\n        ))\n        major, minor = request.headers.get(\n            'content-type', 'application/json').split('/')\n        msg = mime_nonmultipart.MIMENonMultipart(major, minor)\n\n",
                    "rendered": {
                      "text": "            request_line,\n            u'HTTP/1.1\\n'\n        ))\n        major, minor = request.headers.get(\n            'content-type', 'application/json').split('/')\n        msg = mime_nonmultipart.MIMENonMultipart(major, minor)\n\n",
                      "markdown": "`            request_line,\n            u'HTTP/1.1\\n'\n        ))\n        major, minor = request.headers.get(\n            'content-type', 'application/json').split('/')\n        msg = mime_nonmultipart.MIMENonMultipart(major, minor)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 141,
                  "startColumn": 43,
                  "endLine": 141,
                  "endColumn": 47,
                  "snippet": {
                    "text": "                plural_s = ''\n                if max_positional_args != 1:\n                    plural_s = 's'\n                raise TypeError('%s() takes at most %d positional argument%s '\n                                '(%d given)' % (wrapped.__name__,\n                                                max_positional_args,\n                                                plural_s, len(args)))\n",
                    "rendered": {
                      "text": "                plural_s = ''\n                if max_positional_args != 1:\n                    plural_s = 's'\n                raise TypeError('%s() takes at most %d positional argument%s '\n                                '(%d given)' % (wrapped.__name__,\n                                                max_positional_args,\n                                                plural_s, len(args)))\n",
                      "markdown": "`                plural_s = ''\n                if max_positional_args != 1:\n                    plural_s = 's'\n                raise TypeError('%s() takes at most %d positional argument%s '\n                                '(%d given)' % (wrapped.__name__,\n                                                max_positional_args,\n                                                plural_s, len(args)))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 294,
                  "startColumn": 5,
                  "endLine": 294,
                  "endColumn": 11,
                  "snippet": {
                    "text": "    if not time_zone_match:\n        return decoded_datetime\n\n    # Time zone info was included in the parameter.  Add a tzinfo\n    # object to the datetime.  Datetimes can't be changed after they're\n    # created, so we'll need to create a new one.\n    if time_zone_match.group('z'):\n",
                    "rendered": {
                      "text": "    if not time_zone_match:\n        return decoded_datetime\n\n    # Time zone info was included in the parameter.  Add a tzinfo\n    # object to the datetime.  Datetimes can't be changed after they're\n    # created, so we'll need to create a new one.\n    if time_zone_match.group('z'):\n",
                      "markdown": "`    if not time_zone_match:\n        return decoded_datetime\n\n    # Time zone info was included in the parameter.  Add a tzinfo\n    # object to the datetime.  Datetimes can't be changed after they're\n    # created, so we'll need to create a new one.\n    if time_zone_match.group('z'):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 257,
                  "startColumn": 31,
                  "endLine": 257,
                  "endColumn": 37,
                  "snippet": {
                    "text": "      ValueError: If the string is not in a recognized format.\n    \"\"\"\n    # Check if the string includes a time zone offset.  Break out the\n    # part that doesn't include time zone info.  Convert to uppercase\n    # because all our comparisons should be case-insensitive.\n    time_zone_match = _TIME_ZONE_RE.search(encoded_datetime)\n    if time_zone_match:\n",
                    "rendered": {
                      "text": "      ValueError: If the string is not in a recognized format.\n    \"\"\"\n    # Check if the string includes a time zone offset.  Break out the\n    # part that doesn't include time zone info.  Convert to uppercase\n    # because all our comparisons should be case-insensitive.\n    time_zone_match = _TIME_ZONE_RE.search(encoded_datetime)\n    if time_zone_match:\n",
                      "markdown": "`      ValueError: If the string is not in a recognized format.\n    \"\"\"\n    # Check if the string includes a time zone offset.  Break out the\n    # part that doesn't include time zone info.  Convert to uppercase\n    # because all our comparisons should be case-insensitive.\n    time_zone_match = _TIME_ZONE_RE.search(encoded_datetime)\n    if time_zone_match:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 256,
                  "startColumn": 36,
                  "endLine": 256,
                  "endColumn": 42,
                  "snippet": {
                    "text": "    Raises:\n      ValueError: If the string is not in a recognized format.\n    \"\"\"\n    # Check if the string includes a time zone offset.  Break out the\n    # part that doesn't include time zone info.  Convert to uppercase\n    # because all our comparisons should be case-insensitive.\n    time_zone_match = _TIME_ZONE_RE.search(encoded_datetime)\n",
                    "rendered": {
                      "text": "    Raises:\n      ValueError: If the string is not in a recognized format.\n    \"\"\"\n    # Check if the string includes a time zone offset.  Break out the\n    # part that doesn't include time zone info.  Convert to uppercase\n    # because all our comparisons should be case-insensitive.\n    time_zone_match = _TIME_ZONE_RE.search(encoded_datetime)\n",
                      "markdown": "`    Raises:\n      ValueError: If the string is not in a recognized format.\n    \"\"\"\n    # Check if the string includes a time zone offset.  Break out the\n    # part that doesn't include time zone info.  Convert to uppercase\n    # because all our comparisons should be case-insensitive.\n    time_zone_match = _TIME_ZONE_RE.search(encoded_datetime)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 251,
                  "startColumn": 41,
                  "endLine": 251,
                  "endColumn": 47,
                  "snippet": {
                    "text": "          microsecs.\n\n    Returns:\n      A datetime object with the date and time specified in encoded_datetime.\n\n    Raises:\n      ValueError: If the string is not in a recognized format.\n",
                    "rendered": {
                      "text": "          microsecs.\n\n    Returns:\n      A datetime object with the date and time specified in encoded_datetime.\n\n    Raises:\n      ValueError: If the string is not in a recognized format.\n",
                      "markdown": "`          microsecs.\n\n    Returns:\n      A datetime object with the date and time specified in encoded_datetime.\n\n    Raises:\n      ValueError: If the string is not in a recognized format.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 247,
                  "startColumn": 38,
                  "endLine": 247,
                  "endColumn": 44,
                  "snippet": {
                    "text": "\n    Args:\n      encoded_datetime: A string in RFC 3339 format.\n      truncate_time: If true, truncate time string with precision higher than\n          microsecs.\n\n    Returns:\n",
                    "rendered": {
                      "text": "\n    Args:\n      encoded_datetime: A string in RFC 3339 format.\n      truncate_time: If true, truncate time string with precision higher than\n          microsecs.\n\n    Returns:\n",
                      "markdown": "`\n    Args:\n      encoded_datetime: A string in RFC 3339 format.\n      truncate_time: If true, truncate time string with precision higher than\n          microsecs.\n\n    Returns:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 231,
                  "startColumn": 55,
                  "endLine": 231,
                  "endColumn": 61,
                  "snippet": {
                    "text": "    def dst(self, _):\n        \"\"\"Get the daylight savings time offset.\n\n        The formats that ProtoRPC uses to encode/decode time zone\n        information don't contain any information about daylight\n        savings time. So this always returns a timedelta of 0.\n\n",
                    "rendered": {
                      "text": "    def dst(self, _):\n        \"\"\"Get the daylight savings time offset.\n\n        The formats that ProtoRPC uses to encode/decode time zone\n        information don't contain any information about daylight\n        savings time. So this always returns a timedelta of 0.\n\n",
                      "markdown": "`    def dst(self, _):\n        \"\"\"Get the daylight savings time offset.\n\n        The formats that ProtoRPC uses to encode/decode time zone\n        information don't contain any information about daylight\n        savings time. So this always returns a timedelta of 0.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 229,
                  "startColumn": 35,
                  "endLine": 229,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        return datetime.timedelta(minutes=self.__offset)\n\n    def dst(self, _):\n        \"\"\"Get the daylight savings time offset.\n\n        The formats that ProtoRPC uses to encode/decode time zone\n        information don't contain any information about daylight\n",
                    "rendered": {
                      "text": "        return datetime.timedelta(minutes=self.__offset)\n\n    def dst(self, _):\n        \"\"\"Get the daylight savings time offset.\n\n        The formats that ProtoRPC uses to encode/decode time zone\n        information don't contain any information about daylight\n",
                      "markdown": "`        return datetime.timedelta(minutes=self.__offset)\n\n    def dst(self, _):\n        \"\"\"Get the daylight savings time offset.\n\n        The formats that ProtoRPC uses to encode/decode time zone\n        information don't contain any information about daylight\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 224,
                  "startColumn": 13,
                  "endLine": 224,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        \"\"\"Get the a timedelta with the time zone's offset from UTC.\n\n        Returns:\n          The time zone offset from UTC, as a timedelta.\n        \"\"\"\n        return datetime.timedelta(minutes=self.__offset)\n\n",
                    "rendered": {
                      "text": "        \"\"\"Get the a timedelta with the time zone's offset from UTC.\n\n        Returns:\n          The time zone offset from UTC, as a timedelta.\n        \"\"\"\n        return datetime.timedelta(minutes=self.__offset)\n\n",
                      "markdown": "`        \"\"\"Get the a timedelta with the time zone's offset from UTC.\n\n        Returns:\n          The time zone offset from UTC, as a timedelta.\n        \"\"\"\n        return datetime.timedelta(minutes=self.__offset)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 221,
                  "startColumn": 39,
                  "endLine": 221,
                  "endColumn": 45,
                  "snippet": {
                    "text": "        self.__offset = offset\n\n    def utcoffset(self, _):\n        \"\"\"Get the a timedelta with the time zone's offset from UTC.\n\n        Returns:\n          The time zone offset from UTC, as a timedelta.\n",
                    "rendered": {
                      "text": "        self.__offset = offset\n\n    def utcoffset(self, _):\n        \"\"\"Get the a timedelta with the time zone's offset from UTC.\n\n        Returns:\n          The time zone offset from UTC, as a timedelta.\n",
                      "markdown": "`        self.__offset = offset\n\n    def utcoffset(self, _):\n        \"\"\"Get the a timedelta with the time zone's offset from UTC.\n\n        Returns:\n          The time zone offset from UTC, as a timedelta.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 212,
                  "startColumn": 38,
                  "endLine": 212,
                  "endColumn": 44,
                  "snippet": {
                    "text": "        \"\"\"Initialize a time zone offset.\n\n        Args:\n          offset: Integer or timedelta time zone offset, in minutes from UTC.\n            This can be negative.\n        \"\"\"\n        super(TimeZoneOffset, self).__init__()\n",
                    "rendered": {
                      "text": "        \"\"\"Initialize a time zone offset.\n\n        Args:\n          offset: Integer or timedelta time zone offset, in minutes from UTC.\n            This can be negative.\n        \"\"\"\n        super(TimeZoneOffset, self).__init__()\n",
                      "markdown": "`        \"\"\"Initialize a time zone offset.\n\n        Args:\n          offset: Integer or timedelta time zone offset, in minutes from UTC.\n            This can be negative.\n        \"\"\"\n        super(TimeZoneOffset, self).__init__()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 209,
                  "startColumn": 23,
                  "endLine": 209,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    \"\"\"Time zone information as encoded/decoded for DateTimeFields.\"\"\"\n\n    def __init__(self, offset):\n        \"\"\"Initialize a time zone offset.\n\n        Args:\n          offset: Integer or timedelta time zone offset, in minutes from UTC.\n",
                    "rendered": {
                      "text": "    \"\"\"Time zone information as encoded/decoded for DateTimeFields.\"\"\"\n\n    def __init__(self, offset):\n        \"\"\"Initialize a time zone offset.\n\n        Args:\n          offset: Integer or timedelta time zone offset, in minutes from UTC.\n",
                      "markdown": "`    \"\"\"Time zone information as encoded/decoded for DateTimeFields.\"\"\"\n\n    def __init__(self, offset):\n        \"\"\"Initialize a time zone offset.\n\n        Args:\n          offset: Integer or timedelta time zone offset, in minutes from UTC.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 166,
                  "startColumn": 68,
                  "endLine": 167,
                  "snippet": {
                    "text": "    Helper calculates the package name of a module.\n\n    Args:\n      module: Module to get name for.  If module is a string, try to find\n        module in sys.modules.\n\n    Returns:\n      If module contains 'package' attribute, uses that as package name.\n",
                    "rendered": {
                      "text": "    Helper calculates the package name of a module.\n\n    Args:\n      module: Module to get name for.  If module is a string, try to find\n        module in sys.modules.\n\n    Returns:\n      If module contains 'package' attribute, uses that as package name.\n",
                      "markdown": "`    Helper calculates the package name of a module.\n\n    Args:\n      module: Module to get name for.  If module is a string, try to find\n        module in sys.modules.\n\n    Returns:\n      If module contains 'package' attribute, uses that as package name.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/message_types.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/message_types.py"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 59,
                  "endLine": 109,
                  "endColumn": 65,
                  "snippet": {
                    "text": "                                                          tz=value.tzinfo)\n        delta = value - local_epoch\n\n        # Create and fill in the DateTimeMessage, including time zone if\n        # one was specified.\n        message = DateTimeMessage()\n        message.milliseconds = int(util.total_seconds(delta) * 1000)\n",
                    "rendered": {
                      "text": "                                                          tz=value.tzinfo)\n        delta = value - local_epoch\n\n        # Create and fill in the DateTimeMessage, including time zone if\n        # one was specified.\n        message = DateTimeMessage()\n        message.milliseconds = int(util.total_seconds(delta) * 1000)\n",
                      "markdown": "`                                                          tz=value.tzinfo)\n        delta = value - local_epoch\n\n        # Create and fill in the DateTimeMessage, including time zone if\n        # one was specified.\n        message = DateTimeMessage()\n        message.milliseconds = int(util.total_seconds(delta) * 1000)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/message_types.py"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 49,
                  "endLine": 85,
                  "endColumn": 55,
                  "snippet": {
                    "text": "                message.milliseconds / 1000.0)\n\n        # Need to subtract the time zone offset, because when we call\n        # datetime.fromtimestamp, it will add the time zone offset to the\n        # value we pass.\n        milliseconds = (message.milliseconds -\n                        60000 * message.time_zone_offset)\n",
                    "rendered": {
                      "text": "                message.milliseconds / 1000.0)\n\n        # Need to subtract the time zone offset, because when we call\n        # datetime.fromtimestamp, it will add the time zone offset to the\n        # value we pass.\n        milliseconds = (message.milliseconds -\n                        60000 * message.time_zone_offset)\n",
                      "markdown": "`                message.milliseconds / 1000.0)\n\n        # Need to subtract the time zone offset, because when we call\n        # datetime.fromtimestamp, it will add the time zone offset to the\n        # value we pass.\n        milliseconds = (message.milliseconds -\n                        60000 * message.time_zone_offset)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/message_types.py"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 30,
                  "endLine": 84,
                  "endColumn": 36,
                  "snippet": {
                    "text": "            return datetime.datetime.utcfromtimestamp(\n                message.milliseconds / 1000.0)\n\n        # Need to subtract the time zone offset, because when we call\n        # datetime.fromtimestamp, it will add the time zone offset to the\n        # value we pass.\n        milliseconds = (message.milliseconds -\n",
                    "rendered": {
                      "text": "            return datetime.datetime.utcfromtimestamp(\n                message.milliseconds / 1000.0)\n\n        # Need to subtract the time zone offset, because when we call\n        # datetime.fromtimestamp, it will add the time zone offset to the\n        # value we pass.\n        milliseconds = (message.milliseconds -\n",
                      "markdown": "`            return datetime.datetime.utcfromtimestamp(\n                message.milliseconds / 1000.0)\n\n        # Need to subtract the time zone offset, because when we call\n        # datetime.fromtimestamp, it will add the time zone offset to the\n        # value we pass.\n        milliseconds = (message.milliseconds -\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/message_types.py"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 51,
                  "endLine": 53,
                  "endColumn": 57,
                  "snippet": {
                    "text": "class DateTimeField(messages.MessageField):\n    \"\"\"Field definition for datetime values.\n\n    Stores a python datetime object as a field.  If time zone information is\n    included in the datetime object, it will be included in\n    the encoded data when this is encoded/decoded.\n    \"\"\"\n",
                    "rendered": {
                      "text": "class DateTimeField(messages.MessageField):\n    \"\"\"Field definition for datetime values.\n\n    Stores a python datetime object as a field.  If time zone information is\n    included in the datetime object, it will be included in\n    the encoded data when this is encoded/decoded.\n    \"\"\"\n",
                      "markdown": "`class DateTimeField(messages.MessageField):\n    \"\"\"Field definition for datetime values.\n\n    Stores a python datetime object as a field.  If time zone information is\n    included in the datetime object, it will be included in\n    the encoded data when this is encoded/decoded.\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/message_types.py"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 32,
                  "endLine": 44,
                  "endColumn": 38,
                  "snippet": {
                    "text": "\n    Fields:\n      milliseconds: Milliseconds since Jan 1st 1970 local time.\n      time_zone_offset: Optional time zone offset, in minutes from UTC.\n    \"\"\"\n    milliseconds = messages.IntegerField(1, required=True)\n    time_zone_offset = messages.IntegerField(2)\n",
                    "rendered": {
                      "text": "\n    Fields:\n      milliseconds: Milliseconds since Jan 1st 1970 local time.\n      time_zone_offset: Optional time zone offset, in minutes from UTC.\n    \"\"\"\n    milliseconds = messages.IntegerField(1, required=True)\n    time_zone_offset = messages.IntegerField(2)\n",
                      "markdown": "`\n    Fields:\n      milliseconds: Milliseconds since Jan 1st 1970 local time.\n      time_zone_offset: Optional time zone offset, in minutes from UTC.\n    \"\"\"\n    milliseconds = messages.IntegerField(1, required=True)\n    time_zone_offset = messages.IntegerField(2)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/__init__.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/gen_client.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/gen_client.py"
                },
                "region": {
                  "startLine": 331,
                  "startColumn": 53,
                  "endLine": 331,
                  "endColumn": 58,
                  "snippet": {
                    "text": "    client_parser.set_defaults(func=GenerateClient)\n\n    pip_package_parser = subparsers.add_parser(\n        'pip_package', help='Generate apitools client pip package')\n    pip_package_parser.set_defaults(func=GeneratePipPackage)\n\n    proto_parser = subparsers.add_parser(\n",
                    "rendered": {
                      "text": "    client_parser.set_defaults(func=GenerateClient)\n\n    pip_package_parser = subparsers.add_parser(\n        'pip_package', help='Generate apitools client pip package')\n    pip_package_parser.set_defaults(func=GeneratePipPackage)\n\n    proto_parser = subparsers.add_parser(\n",
                      "markdown": "`    client_parser.set_defaults(func=GenerateClient)\n\n    pip_package_parser = subparsers.add_parser(\n        'pip_package', help='Generate apitools client pip package')\n    pip_package_parser.set_defaults(func=GeneratePipPackage)\n\n    proto_parser = subparsers.add_parser(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/gen_client.py"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 26,
                  "endLine": 39,
                  "endColumn": 32,
                  "snippet": {
                    "text": "            'apitools.base.py', filename)\n        if src_data is None:\n            raise exceptions.GeneratedClientError(\n                'Could not find file %s' % filename)\n        out.write(src_data)\n\n\n",
                    "rendered": {
                      "text": "            'apitools.base.py', filename)\n        if src_data is None:\n            raise exceptions.GeneratedClientError(\n                'Could not find file %s' % filename)\n        out.write(src_data)\n\n\n",
                      "markdown": "`            'apitools.base.py', filename)\n        if src_data is None:\n            raise exceptions.GeneratedClientError(\n                'Could not find file %s' % filename)\n        out.write(src_data)\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/gen_client.py"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 35,
                  "endLine": 71,
                  "endColumn": 40,
                  "snippet": {
                    "text": "                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n            raise exceptions.NotFoundError(\n                'Failed to open client json file: %s' % args.client_json)\n",
                    "rendered": {
                      "text": "                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n            raise exceptions.NotFoundError(\n                'Failed to open client json file: %s' % args.client_json)\n",
                      "markdown": "`                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n            raise exceptions.NotFoundError(\n                'Failed to open client json file: %s' % args.client_json)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/gen_client.py"
                },
                "region": {
                  "startLine": 70,
                  "startColumn": 31,
                  "endLine": 70,
                  "endColumn": 36,
                  "snippet": {
                    "text": "            with io.open(args.client_json, encoding='utf8') as client_json:\n                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n            raise exceptions.NotFoundError(\n",
                    "rendered": {
                      "text": "            with io.open(args.client_json, encoding='utf8') as client_json:\n                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n            raise exceptions.NotFoundError(\n",
                      "markdown": "`            with io.open(args.client_json, encoding='utf8') as client_json:\n                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n            raise exceptions.NotFoundError(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/gen_client.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 42,
                  "endLine": 69,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        try:\n            with io.open(args.client_json, encoding='utf8') as client_json:\n                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n",
                    "rendered": {
                      "text": "        try:\n            with io.open(args.client_json, encoding='utf8') as client_json:\n                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n",
                      "markdown": "`        try:\n            with io.open(args.client_json, encoding='utf8') as client_json:\n                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/gen/gen_client.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 23,
                  "endLine": 69,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        try:\n            with io.open(args.client_json, encoding='utf8') as client_json:\n                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n",
                    "rendered": {
                      "text": "        try:\n            with io.open(args.client_json, encoding='utf8') as client_json:\n                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n",
                      "markdown": "`        try:\n            with io.open(args.client_json, encoding='utf8') as client_json:\n                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/stream_slice.py"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 15,
                  "endLine": 49,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        return self.__max_bytes\n\n    def read(self, size=None):  # pylint: disable=missing-docstring\n        \"\"\"Read at most size bytes from this slice.\n\n        Compared to other streams, there is one case where we may\n        unexpectedly raise an exception on read: if the underlying stream\n",
                    "rendered": {
                      "text": "        return self.__max_bytes\n\n    def read(self, size=None):  # pylint: disable=missing-docstring\n        \"\"\"Read at most size bytes from this slice.\n\n        Compared to other streams, there is one case where we may\n        unexpectedly raise an exception on read: if the underlying stream\n",
                      "markdown": "`        return self.__max_bytes\n\n    def read(self, size=None):  # pylint: disable=missing-docstring\n        \"\"\"Read at most size bytes from this slice.\n\n        Compared to other streams, there is one case where we may\n        unexpectedly raise an exception on read: if the underlying stream\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/py/stream_slice.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1935,
                  "startColumn": 25,
                  "endLine": 1935,
                  "endColumn": 29,
                  "snippet": {
                    "text": "                                this part of search --+\n\n        Returns:\n          Message or Enum at the end of name_path, else None.\n        \"\"\"\n        next_part = relative_to\n        for node in name_path:\n",
                    "rendered": {
                      "text": "                                this part of search --+\n\n        Returns:\n          Message or Enum at the end of name_path, else None.\n        \"\"\"\n        next_part = relative_to\n        for node in name_path:\n",
                      "markdown": "`                                this part of search --+\n\n        Returns:\n          Message or Enum at the end of name_path, else None.\n        \"\"\"\n        next_part = relative_to\n        for node in name_path:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1987,
                  "startColumn": 21,
                  "endLine": 1987,
                  "endColumn": 27,
                  "snippet": {
                    "text": "                    'Could not find definition for %s' % name)\n            else:\n                if isinstance(relative_to, types.ModuleType):\n                    # Find parent module.\n                    module_path = relative_to.__name__.split('.')[:-1]\n                    if not module_path:\n                        relative_to = None\n",
                    "rendered": {
                      "text": "                    'Could not find definition for %s' % name)\n            else:\n                if isinstance(relative_to, types.ModuleType):\n                    # Find parent module.\n                    module_path = relative_to.__name__.split('.')[:-1]\n                    if not module_path:\n                        relative_to = None\n",
                      "markdown": "`                    'Could not find definition for %s' % name)\n            else:\n                if isinstance(relative_to, types.ModuleType):\n                    # Find parent module.\n                    module_path = relative_to.__name__.split('.')[:-1]\n                    if not module_path:\n                        relative_to = None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1984,
                  "startColumn": 30,
                  "endLine": 1984,
                  "endColumn": 36,
                  "snippet": {
                    "text": "            if relative_to is None:\n                # Fully qualified search was done.  Nothing found.  Fail.\n                raise DefinitionNotFoundError(\n                    'Could not find definition for %s' % name)\n            else:\n                if isinstance(relative_to, types.ModuleType):\n                    # Find parent module.\n",
                    "rendered": {
                      "text": "            if relative_to is None:\n                # Fully qualified search was done.  Nothing found.  Fail.\n                raise DefinitionNotFoundError(\n                    'Could not find definition for %s' % name)\n            else:\n                if isinstance(relative_to, types.ModuleType):\n                    # Find parent module.\n",
                      "markdown": "`            if relative_to is None:\n                # Fully qualified search was done.  Nothing found.  Fail.\n                raise DefinitionNotFoundError(\n                    'Could not find definition for %s' % name)\n            else:\n                if isinstance(relative_to, types.ModuleType):\n                    # Find parent module.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1974,
                  "startColumn": 13,
                  "endLine": 1974,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        if isinstance(found, type) and issubclass(found, (Enum, Message)):\n            return found\n        else:\n            # Find next relative_to to search against.\n            #\n            #   fully.qualified.object . relative.or.nested.Definition\n            #   <---------------------\n",
                    "rendered": {
                      "text": "        if isinstance(found, type) and issubclass(found, (Enum, Message)):\n            return found\n        else:\n            # Find next relative_to to search against.\n            #\n            #   fully.qualified.object . relative.or.nested.Definition\n            #   <---------------------\n",
                      "markdown": "`        if isinstance(found, type) and issubclass(found, (Enum, Message)):\n            return found\n        else:\n            # Find next relative_to to search against.\n            #\n            #   fully.qualified.object . relative.or.nested.Definition\n            #   <---------------------\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1949,
                  "startColumn": 37,
                  "endLine": 1950,
                  "snippet": {
                    "text": "                if (next_part is None or\n                        isinstance(next_part, types.ModuleType)):\n                    if next_part is None:\n                        module_name = node\n                    else:\n                        module_name = '%s.%s' % (next_part.__name__, node)\n\n                    try:\n",
                    "rendered": {
                      "text": "                if (next_part is None or\n                        isinstance(next_part, types.ModuleType)):\n                    if next_part is None:\n                        module_name = node\n                    else:\n                        module_name = '%s.%s' % (next_part.__name__, node)\n\n                    try:\n",
                      "markdown": "`                if (next_part is None or\n                        isinstance(next_part, types.ModuleType)):\n                    if next_part is None:\n                        module_name = node\n                    else:\n                        module_name = '%s.%s' % (next_part.__name__, node)\n\n                    try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1938,
                  "startColumn": 11,
                  "endLine": 1938,
                  "endColumn": 17,
                  "snippet": {
                    "text": "          Message or Enum at the end of name_path, else None.\n        \"\"\"\n        next_part = relative_to\n        for node in name_path:\n            # Look for attribute first.\n            attribute = getattr(next_part, node, None)\n\n",
                    "rendered": {
                      "text": "          Message or Enum at the end of name_path, else None.\n        \"\"\"\n        next_part = relative_to\n        for node in name_path:\n            # Look for attribute first.\n            attribute = getattr(next_part, node, None)\n\n",
                      "markdown": "`          Message or Enum at the end of name_path, else None.\n        \"\"\"\n        next_part = relative_to\n        for node in name_path:\n            # Look for attribute first.\n            attribute = getattr(next_part, node, None)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1850,
                  "startColumn": 7,
                  "endLine": 1850,
                  "endColumn": 13,
                  "snippet": {
                    "text": "def find_definition(name, relative_to=None, importer=__import__):\n    \"\"\"Find definition by name in module-space.\n\n    The find algorthm will look for definitions by name relative to a\n    message definition or by fully qualfied name. If no definition is\n    found relative to the relative_to parameter it will do the same\n    search against the container of relative_to. If relative_to is a\n",
                    "rendered": {
                      "text": "def find_definition(name, relative_to=None, importer=__import__):\n    \"\"\"Find definition by name in module-space.\n\n    The find algorthm will look for definitions by name relative to a\n    message definition or by fully qualfied name. If no definition is\n    found relative to the relative_to parameter it will do the same\n    search against the container of relative_to. If relative_to is a\n",
                      "markdown": "`def find_definition(name, relative_to=None, importer=__import__):\n    \"\"\"Find definition by name in module-space.\n\n    The find algorthm will look for definitions by name relative to a\n    message definition or by fully qualfied name. If no definition is\n    found relative to the relative_to parameter it will do the same\n    search against the container of relative_to. If relative_to is a\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1744,
                  "startColumn": 9,
                  "endLine": 1744,
                  "endColumn": 14,
                  "snippet": {
                    "text": "        class Animal(Enum):\n\n          DOG = 1\n          CAT = 2\n          HORSE = 3\n\n        # This fields default value will be validated right away since Color\n",
                    "rendered": {
                      "text": "        class Animal(Enum):\n\n          DOG = 1\n          CAT = 2\n          HORSE = 3\n\n        # This fields default value will be validated right away since Color\n",
                      "markdown": "`        class Animal(Enum):\n\n          DOG = 1\n          CAT = 2\n          HORSE = 3\n\n        # This fields default value will be validated right away since Color\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1732,
                  "startColumn": 9,
                  "endLine": 1732,
                  "endColumn": 14,
                  "snippet": {
                    "text": "\n        class Color(Enum):\n\n          RED = 1\n          GREEN = 2\n          BLUE = 3\n\n",
                    "rendered": {
                      "text": "\n        class Color(Enum):\n\n          RED = 1\n          GREEN = 2\n          BLUE = 3\n\n",
                      "markdown": "`\n        class Color(Enum):\n\n          RED = 1\n          GREEN = 2\n          BLUE = 3\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1302,
                  "startColumn": 48,
                  "endLine": 1302,
                  "endColumn": 53,
                  "snippet": {
                    "text": "        if message_instance is None:\n            return self\n\n        result = message_instance._Message__tags.get(self.number)\n        if result is None:\n            return self.default\n        return result\n",
                    "rendered": {
                      "text": "        if message_instance is None:\n            return self\n\n        result = message_instance._Message__tags.get(self.number)\n        if result is None:\n            return self.default\n        return result\n",
                      "markdown": "`        if message_instance is None:\n            return self\n\n        result = message_instance._Message__tags.get(self.number)\n        if result is None:\n            return self.default\n        return result\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1162,
                  "startColumn": 45,
                  "endLine": 1162,
                  "endColumn": 50,
                  "snippet": {
                    "text": "\n    def __init__(cls, name, bases, dct):\n        getattr(cls, '_Field__variant_to_type').update(\n            (variant, cls) for variant in dct.get('VARIANTS', []))\n        type.__init__(cls, name, bases, dct)\n\n\n",
                    "rendered": {
                      "text": "\n    def __init__(cls, name, bases, dct):\n        getattr(cls, '_Field__variant_to_type').update(\n            (variant, cls) for variant in dct.get('VARIANTS', []))\n        type.__init__(cls, name, bases, dct)\n\n\n",
                      "markdown": "`\n    def __init__(cls, name, bases, dct):\n        getattr(cls, '_Field__variant_to_type').update(\n            (variant, cls) for variant in dct.get('VARIANTS', []))\n        type.__init__(cls, name, bases, dct)\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 938,
                  "startColumn": 51,
                  "endLine": 938,
                  "endColumn": 56,
                  "snippet": {
                    "text": "          (value, variant), where value and variant are whatever was passed\n          to set_unrecognized_field.\n        \"\"\"\n        value, variant = self.__unrecognized_fields.get(key, (value_default,\n                                                              variant_default))\n        return value, variant\n\n",
                    "rendered": {
                      "text": "          (value, variant), where value and variant are whatever was passed\n          to set_unrecognized_field.\n        \"\"\"\n        value, variant = self.__unrecognized_fields.get(key, (value_default,\n                                                              variant_default))\n        return value, variant\n\n",
                      "markdown": "`          (value, variant), where value and variant are whatever was passed\n          to set_unrecognized_field.\n        \"\"\"\n        value, variant = self.__unrecognized_fields.get(key, (value_default,\n                                                              variant_default))\n        return value, variant\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 898,
                  "startColumn": 26,
                  "endLine": 898,
                  "endColumn": 31,
                  "snippet": {
                    "text": "        except KeyError:\n            raise AttributeError('Message %s has no field %s' % (\n                message_type.__name__, name))\n        return self.__tags.get(field.number)\n\n    def reset(self, name):\n        \"\"\"Reset assigned value for field.\n",
                    "rendered": {
                      "text": "        except KeyError:\n            raise AttributeError('Message %s has no field %s' % (\n                message_type.__name__, name))\n        return self.__tags.get(field.number)\n\n    def reset(self, name):\n        \"\"\"Reset assigned value for field.\n",
                      "markdown": "`        except KeyError:\n            raise AttributeError('Message %s has no field %s' % (\n                message_type.__name__, name))\n        return self.__tags.get(field.number)\n\n    def reset(self, name):\n        \"\"\"Reset assigned value for field.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/tmp/datasets/dataset3/python/py3-google-apitools-0.5.33-r2.apk/py3-google-apitools-0.5.33-r2/usr/lib/python3.12/site-packages/apitools/base/protorpclite/__init__.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        }
      ],
      "columnKind": "utf16CodeUnits"
    }
  ]
}